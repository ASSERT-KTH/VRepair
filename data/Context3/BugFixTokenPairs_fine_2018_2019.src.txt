CWE-125 static int jpeg_size ( unsigned char * data , unsigned int data_size , int * width , int * height ) { int i = 0 ; if ( i + 3 < data_size && data [ i ] == 0xFF && data [ i + 1 ] == 0xD8 && data [ i + 2 ] == 0xFF && data [ i + 3 ] == 0xE0 ) { i += 4 ; if ( i + 6 < data_size && data [ i + 2 ] == 'J' && data [ i + 3 ] == 'F' && data [ i + 4 ] == 'I' && data [ i + 5 ] == 'F' && data [ i + 6 ] == 0x00 ) { unsigned short block_length = data [ i ] * 256 + data [ i + 1 ] ; while ( i < data_size ) { i += block_length ; if ( ( i + 1 ) >= data_size ) return - 1 ; if ( data [ i ] != 0xFF ) return - 1 ; if ( data [ i + 1 ] == 0xC0 ) { * height = data [ i + 5 ] * 256 + data [ i + 6 ] ; * width = data [ i + 7 ] * 256 + data [ i + 8 ] ; return 0 ; } i += 2 ; <S2SV_StartBug> block_length = data [ i ] * 256 + data [ i + 1 ] ; <S2SV_EndBug> } } } return - 1 ; }
CWE-285 crm_client_t * crm_client_new ( qb_ipcs_connection_t * c , uid_t uid_client , gid_t gid_client ) { <S2SV_StartBug> static uid_t uid_server = 0 ; <S2SV_EndBug> static gid_t gid_cluster = 0 ; crm_client_t * client = NULL ; CRM_LOG_ASSERT ( c ) ; if ( c == NULL ) { return NULL ; } if ( gid_cluster == 0 ) { <S2SV_StartBug> uid_server = getuid ( ) ; <S2SV_EndBug> if ( crm_user_lookup ( CRM_DAEMON_USER , NULL , & gid_cluster ) < 0 ) { static bool have_error = FALSE ; if ( have_error == FALSE ) { crm_warn ( "Could<S2SV_blank>not<S2SV_blank>find<S2SV_blank>group<S2SV_blank>for<S2SV_blank>user<S2SV_blank>%s" , CRM_DAEMON_USER ) ; have_error = TRUE ; } } } <S2SV_StartBug> if ( gid_cluster != 0 && gid_client != 0 ) { <S2SV_EndBug> uid_t best_uid = - 1 ; if ( uid_client == 0 || uid_server == 0 ) { best_uid = QB_MAX ( uid_client , uid_server ) ; crm_trace ( "Allowing<S2SV_blank>user<S2SV_blank>%u<S2SV_blank>to<S2SV_blank>clean<S2SV_blank>up<S2SV_blank>after<S2SV_blank>disconnect" , best_uid ) ; } crm_trace ( "Giving<S2SV_blank>access<S2SV_blank>to<S2SV_blank>group<S2SV_blank>%u" , gid_cluster ) ; qb_ipcs_connection_auth_set ( c , best_uid , gid_cluster , S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP ) ; } crm_client_init ( ) ; client = calloc ( 1 , sizeof ( crm_client_t ) ) ; client -> ipcs = c ; client -> kind = CRM_CLIENT_IPC ; client -> pid = crm_ipcs_client_pid ( c ) ; client -> id = crm_generate_uuid ( ) ; crm_debug ( "Connecting<S2SV_blank>%p<S2SV_blank>for<S2SV_blank>uid=%d<S2SV_blank>gid=%d<S2SV_blank>pid=%u<S2SV_blank>id=%s" , c , uid_client , gid_client , client -> pid , client -> id ) ; # if ENABLE_ACL client -> user = uid2username ( uid_client ) ; # endif g_hash_table_insert ( client_connections , c , client ) ; return client ; }
CWE-119 static l_int32 pixHtmlViewer ( const char * dirin , const char * dirout , const char * rootname , l_int32 thumbwidth , l_int32 viewwidth ) { char * fname , * fullname , * outname ; char * mainname , * linkname , * linknameshort ; char * viewfile , * thumbfile ; char * shtml , * slink ; char charbuf [ 512 ] ; char htmlstring [ ] = "<html>" ; char framestring [ ] = "</frameset></html>" ; l_int32 i , nfiles , index , w , d , nimages , ret ; l_float32 factor ; PIX * pix , * pixthumb , * pixview ; SARRAY * safiles , * sathumbs , * saviews , * sahtml , * salink ; PROCNAME ( "pixHtmlViewer" ) ; if ( ! dirin ) return ERROR_INT ( "dirin<S2SV_blank>not<S2SV_blank>defined" , procName , 1 ) ; if ( ! dirout ) return ERROR_INT ( "dirout<S2SV_blank>not<S2SV_blank>defined" , procName , 1 ) ; if ( ! rootname ) return ERROR_INT ( "rootname<S2SV_blank>not<S2SV_blank>defined" , procName , 1 ) ; if ( thumbwidth == 0 ) thumbwidth = DEFAULT_THUMB_WIDTH ; if ( thumbwidth < MIN_THUMB_WIDTH ) { L_WARNING ( "thumbwidth<S2SV_blank>too<S2SV_blank>small;<S2SV_blank>using<S2SV_blank>min<S2SV_blank>value\\n" , procName ) ; thumbwidth = MIN_THUMB_WIDTH ; } if ( viewwidth == 0 ) viewwidth = DEFAULT_VIEW_WIDTH ; if ( viewwidth < MIN_VIEW_WIDTH ) { L_WARNING ( "viewwidth<S2SV_blank>too<S2SV_blank>small;<S2SV_blank>using<S2SV_blank>min<S2SV_blank>value\\n" , procName ) ; viewwidth = MIN_VIEW_WIDTH ; } # ifndef _WIN32 snprintf ( charbuf , sizeof ( charbuf ) , "mkdir<S2SV_blank>-p<S2SV_blank>%s" , dirout ) ; ret = system ( charbuf ) ; # else ret = CreateDirectory ( dirout , NULL ) ? 0 : 1 ; # endif if ( ret ) { L_ERROR ( "output<S2SV_blank>directory<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>made\\n" , procName , dirout ) ; return 1 ; } if ( ( safiles = getFilenamesInDirectory ( dirin ) ) == NULL ) return ERROR_INT ( "safiles<S2SV_blank>not<S2SV_blank>made" , procName , 1 ) ; <S2SV_StartBug> sprintf ( charbuf , "%s/%s.html" , dirout , rootname ) ; <S2SV_EndBug> mainname = stringNew ( charbuf ) ; <S2SV_StartBug> sprintf ( charbuf , "%s/%s-links.html" , dirout , rootname ) ; <S2SV_EndBug> linkname = stringNew ( charbuf ) ; linknameshort = stringJoin ( rootname , "-links.html" ) ; sathumbs = sarrayCreate ( 0 ) ; saviews = sarrayCreate ( 0 ) ; nfiles = sarrayGetCount ( safiles ) ; index = 0 ; for ( i = 0 ; i < nfiles ; i ++ ) { fname = sarrayGetString ( safiles , i , L_NOCOPY ) ; fullname = genPathname ( dirin , fname ) ; fprintf ( stderr , "name:<S2SV_blank>%s\\n" , fullname ) ; if ( ( pix = pixRead ( fullname ) ) == NULL ) { fprintf ( stderr , "file<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>a<S2SV_blank>readable<S2SV_blank>image\\n" , fullname ) ; lept_free ( fullname ) ; continue ; } lept_free ( fullname ) ; pixGetDimensions ( pix , & w , NULL , & d ) ; factor = ( l_float32 ) thumbwidth / ( l_float32 ) w ; pixthumb = pixScale ( pix , factor , factor ) ; <S2SV_StartBug> sprintf ( charbuf , "%s_thumb_%03d" , rootname , index ) ; <S2SV_EndBug> sarrayAddString ( sathumbs , charbuf , L_COPY ) ; outname = genPathname ( dirout , charbuf ) ; WriteFormattedPix ( outname , pixthumb ) ; lept_free ( outname ) ; pixDestroy ( & pixthumb ) ; factor = ( l_float32 ) viewwidth / ( l_float32 ) w ; if ( factor >= 1.0 ) pixview = pixClone ( pix ) ; else pixview = pixScale ( pix , factor , factor ) ; snprintf ( charbuf , sizeof ( charbuf ) , "%s_view_%03d" , rootname , index ) ; sarrayAddString ( saviews , charbuf , L_COPY ) ; outname = genPathname ( dirout , charbuf ) ; WriteFormattedPix ( outname , pixview ) ; lept_free ( outname ) ; pixDestroy ( & pixview ) ; pixDestroy ( & pix ) ; index ++ ; } sahtml = sarrayCreate ( 0 ) ; sarrayAddString ( sahtml , htmlstring , L_COPY ) ; sprintf ( charbuf , "<frameset<S2SV_blank>cols=\\"%d,<S2SV_blank>*\\">" , thumbwidth + 30 ) ; sarrayAddString ( sahtml , charbuf , L_COPY ) ; sprintf ( charbuf , "<frame<S2SV_blank>name=\\"thumbs\\"<S2SV_blank>src=\\"%s\\">" , linknameshort ) ; sarrayAddString ( sahtml , charbuf , L_COPY ) ; sprintf ( charbuf , "<frame<S2SV_blank>name=\\"views\\"<S2SV_blank>src=\\"%s\\">" , sarrayGetString ( saviews , 0 , L_NOCOPY ) ) ; sarrayAddString ( sahtml , charbuf , L_COPY ) ; sarrayAddString ( sahtml , framestring , L_COPY ) ; shtml = sarrayToString ( sahtml , 1 ) ; l_binaryWrite ( mainname , "w" , shtml , strlen ( shtml ) ) ; fprintf ( stderr , "******************************************\\n" "Writing<S2SV_blank>html<S2SV_blank>file:<S2SV_blank>%s\\n" "******************************************\\n" , mainname ) ; lept_free ( shtml ) ; lept_free ( mainname ) ; nimages = sarrayGetCount ( saviews ) ; fprintf ( stderr , "num.<S2SV_blank>images<S2SV_blank>=<S2SV_blank>%d\\n" , nimages ) ; salink = sarrayCreate ( 0 ) ; for ( i = 0 ; i < nimages ; i ++ ) { viewfile = sarrayGetString ( saviews , i , L_NOCOPY ) ; thumbfile = sarrayGetString ( sathumbs , i , L_NOCOPY ) ; sprintf ( charbuf , "<a<S2SV_blank>href=\\"%s\\"<S2SV_blank>TARGET=views><img<S2SV_blank>src=\\"%s\\"></a>" , viewfile , thumbfile ) ; sarrayAddString ( salink , charbuf , L_COPY ) ; } slink = sarrayToString ( salink , 1 ) ; l_binaryWrite ( linkname , "w" , slink , strlen ( slink ) ) ; lept_free ( slink ) ; lept_free ( linkname ) ; lept_free ( linknameshort ) ; sarrayDestroy ( & safiles ) ; sarrayDestroy ( & sathumbs ) ; sarrayDestroy ( & saviews ) ; sarrayDestroy ( & sahtml ) ; sarrayDestroy ( & salink ) ; return 0 ; }
CWE-119 int main ( int argc , char * * argv ) { char * filein , * str , * tempfile , * prestring , * outprotos , * protostr ; const char * spacestr = "<S2SV_blank>" ; <S2SV_StartBug> char buf [ L_BUF_SIZE ] ; <S2SV_EndBug> l_uint8 * allheaders ; l_int32 i , maxindex , in_line , nflags , protos_added , firstfile , len , ret ; size_t nbytes ; L_BYTEA * ba , * ba2 ; SARRAY * sa , * safirst ; static char mainName [ ] = "xtractprotos" ; if ( argc == 1 ) { fprintf ( stderr , "xtractprotos<S2SV_blank>[-prestring=<string>]<S2SV_blank>[-protos=<where>]<S2SV_blank>" "[list<S2SV_blank>of<S2SV_blank>C<S2SV_blank>files]\\n" "where<S2SV_blank>the<S2SV_blank>prestring<S2SV_blank>is<S2SV_blank>prepended<S2SV_blank>to<S2SV_blank>each<S2SV_blank>prototype,<S2SV_blank>and<S2SV_blank>\\n" "protos<S2SV_blank>can<S2SV_blank>be<S2SV_blank>either<S2SV_blank>\'inline\'<S2SV_blank>or<S2SV_blank>the<S2SV_blank>name<S2SV_blank>of<S2SV_blank>an<S2SV_blank>output<S2SV_blank>" "prototype<S2SV_blank>file\\n" ) ; return 1 ; } prestring = outprotos = NULL ; in_line = FALSE ; nflags = 0 ; maxindex = L_MIN ( 3 , argc ) ; for ( i = 1 ; i < maxindex ; i ++ ) { if ( argv [ i ] [ 0 ] == '-' ) { if ( ! strncmp ( argv [ i ] , "-prestring" , 10 ) ) { nflags ++ ; <S2SV_StartBug> ret = sscanf ( argv [ i ] + 1 , "prestring=%s" , buf ) ; <S2SV_EndBug> if ( ret != 1 ) { fprintf ( stderr , "parse<S2SV_blank>failure<S2SV_blank>for<S2SV_blank>prestring\\n" ) ; return 1 ; } <S2SV_StartBug> if ( ( len = strlen ( buf ) ) > L_BUF_SIZE - 3 ) { <S2SV_EndBug> L_WARNING ( "prestring<S2SV_blank>too<S2SV_blank>large;<S2SV_blank>omitting!\\n" , mainName ) ; } else { buf [ len ] = '<S2SV_blank>' ; buf [ len + 1 ] = '\\0' ; prestring = stringNew ( buf ) ; } } else if ( ! strncmp ( argv [ i ] , "-protos" , 7 ) ) { nflags ++ ; <S2SV_StartBug> ret = sscanf ( argv [ i ] + 1 , "protos=%s" , buf ) ; <S2SV_EndBug> if ( ret != 1 ) { fprintf ( stderr , "parse<S2SV_blank>failure<S2SV_blank>for<S2SV_blank>protos\\n" ) ; return 1 ; } outprotos = stringNew ( buf ) ; if ( ! strncmp ( outprotos , "inline" , 7 ) ) in_line = TRUE ; } } } if ( argc - nflags < 2 ) { fprintf ( stderr , "no<S2SV_blank>files<S2SV_blank>specified!\\n" ) ; return 1 ; } ba = l_byteaCreate ( 500 ) ; sa = sarrayCreate ( 0 ) ; sarrayAddString ( sa , ( char * ) "/*" , L_COPY ) ; <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , <S2SV_EndBug> "<S2SV_blank>*<S2SV_blank><S2SV_blank>These<S2SV_blank>prototypes<S2SV_blank>were<S2SV_blank>autogen\'d<S2SV_blank>by<S2SV_blank>xtractprotos,<S2SV_blank>v.<S2SV_blank>%s" , version ) ; sarrayAddString ( sa , buf , L_COPY ) ; sarrayAddString ( sa , ( char * ) "<S2SV_blank>*/" , L_COPY ) ; sarrayAddString ( sa , ( char * ) "#ifdef<S2SV_blank>__cplusplus" , L_COPY ) ; sarrayAddString ( sa , ( char * ) "extern<S2SV_blank>\\"C\\"<S2SV_blank>{" , L_COPY ) ; sarrayAddString ( sa , ( char * ) "#endif<S2SV_blank><S2SV_blank>/*<S2SV_blank>__cplusplus<S2SV_blank>*/\\n" , L_COPY ) ; str = sarrayToString ( sa , 1 ) ; l_byteaAppendString ( ba , str ) ; lept_free ( str ) ; sarrayDestroy ( & sa ) ; firstfile = 1 + nflags ; protos_added = FALSE ; if ( ( tempfile = l_makeTempFilename ( ) ) == NULL ) { fprintf ( stderr , "failure<S2SV_blank>to<S2SV_blank>make<S2SV_blank>a<S2SV_blank>writeable<S2SV_blank>temp<S2SV_blank>file\\n" ) ; return 1 ; } for ( i = firstfile ; i < argc ; i ++ ) { filein = argv [ i ] ; len = strlen ( filein ) ; if ( filein [ len - 1 ] == 'h' ) continue ; <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , "cpp<S2SV_blank>-ansi<S2SV_blank>-DNO_PROTOS<S2SV_blank>%s<S2SV_blank>%s" , <S2SV_EndBug> filein , tempfile ) ; ret = system ( buf ) ; if ( ret ) { fprintf ( stderr , "cpp<S2SV_blank>failure<S2SV_blank>for<S2SV_blank>%s;<S2SV_blank>continuing\\n" , filein ) ; continue ; } if ( ( str = parseForProtos ( tempfile , prestring ) ) == NULL ) { fprintf ( stderr , "parse<S2SV_blank>failure<S2SV_blank>for<S2SV_blank>%s;<S2SV_blank>continuing\\n" , filein ) ; continue ; } if ( strlen ( str ) > 1 ) { l_byteaAppendString ( ba , str ) ; protos_added = TRUE ; } lept_free ( str ) ; } lept_rmfile ( tempfile ) ; lept_free ( tempfile ) ; sa = sarrayCreate ( 0 ) ; sarrayAddString ( sa , ( char * ) "\\n#ifdef<S2SV_blank>__cplusplus" , L_COPY ) ; sarrayAddString ( sa , ( char * ) "}" , L_COPY ) ; sarrayAddString ( sa , ( char * ) "#endif<S2SV_blank><S2SV_blank>/*<S2SV_blank>__cplusplus<S2SV_blank>*/" , L_COPY ) ; str = sarrayToString ( sa , 1 ) ; l_byteaAppendString ( ba , str ) ; lept_free ( str ) ; sarrayDestroy ( & sa ) ; protostr = ( char * ) l_byteaCopyData ( ba , & nbytes ) ; l_byteaDestroy ( & ba ) ; if ( ! outprotos ) { fprintf ( stderr , "%s\\n" , protostr ) ; lept_free ( protostr ) ; return 0 ; } if ( ! protos_added ) { fprintf ( stderr , "No<S2SV_blank>protos<S2SV_blank>found\\n" ) ; lept_free ( protostr ) ; return 1 ; } ba = l_byteaInitFromFile ( "allheaders_top.txt" ) ; if ( ! in_line ) { snprintf ( buf , sizeof ( buf ) , "#include<S2SV_blank>\\"%s\\"\\n" , outprotos ) ; l_byteaAppendString ( ba , buf ) ; l_binaryWrite ( outprotos , "w" , protostr , nbytes ) ; } else { l_byteaAppendString ( ba , protostr ) ; } ba2 = l_byteaInitFromFile ( "allheaders_bot.txt" ) ; l_byteaJoin ( ba , & ba2 ) ; l_byteaWrite ( "allheaders.h" , ba , 0 , 0 ) ; l_byteaDestroy ( & ba ) ; lept_free ( protostr ) ; return 0 ; }
CWE-119 l_int32 gplotAddPlot ( GPLOT * gplot , NUMA * nax , NUMA * nay , l_int32 plotstyle , const char * plottitle ) { <S2SV_StartBug> char buf [ L_BUF_SIZE ] ; <S2SV_EndBug> char emptystring [ ] = "" ; char * datastr , * title ; l_int32 n , i ; l_float32 valx , valy , startx , delx ; SARRAY * sa ; PROCNAME ( "gplotAddPlot" ) ; if ( ! gplot ) return ERROR_INT ( "gplot<S2SV_blank>not<S2SV_blank>defined" , procName , 1 ) ; if ( ! nay ) return ERROR_INT ( "nay<S2SV_blank>not<S2SV_blank>defined" , procName , 1 ) ; if ( plotstyle < 0 || plotstyle >= NUM_GPLOT_STYLES ) return ERROR_INT ( "invalid<S2SV_blank>plotstyle" , procName , 1 ) ; if ( ( n = numaGetCount ( nay ) ) == 0 ) return ERROR_INT ( "no<S2SV_blank>points<S2SV_blank>to<S2SV_blank>plot" , procName , 1 ) ; if ( nax && ( n != numaGetCount ( nax ) ) ) return ERROR_INT ( "nax<S2SV_blank>and<S2SV_blank>nay<S2SV_blank>sizes<S2SV_blank>differ" , procName , 1 ) ; if ( n == 1 && plotstyle == GPLOT_LINES ) { L_INFO ( "only<S2SV_blank>1<S2SV_blank>pt;<S2SV_blank>changing<S2SV_blank>style<S2SV_blank>to<S2SV_blank>points\\n" , procName ) ; plotstyle = GPLOT_POINTS ; } numaGetParameters ( nay , & startx , & delx ) ; numaAddNumber ( gplot -> plotstyles , plotstyle ) ; if ( plottitle ) { title = stringNew ( plottitle ) ; sarrayAddString ( gplot -> plottitles , title , L_INSERT ) ; } else { sarrayAddString ( gplot -> plottitles , emptystring , L_COPY ) ; } gplot -> nplots ++ ; <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , "%s.data.%d" , gplot -> rootname , gplot -> nplots ) ; <S2SV_EndBug> sarrayAddString ( gplot -> datanames , buf , L_COPY ) ; sa = sarrayCreate ( n ) ; for ( i = 0 ; i < n ; i ++ ) { if ( nax ) numaGetFValue ( nax , i , & valx ) ; else valx = startx + i * delx ; numaGetFValue ( nay , i , & valy ) ; <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , "%f<S2SV_blank>%f\\n" , valx , valy ) ; <S2SV_EndBug> sarrayAddString ( sa , buf , L_COPY ) ; } datastr = sarrayToString ( sa , 0 ) ; sarrayAddString ( gplot -> plotdata , datastr , L_INSERT ) ; sarrayDestroy ( & sa ) ; return 0 ; }
CWE-119 GPLOT * gplotCreate ( const char * rootname , l_int32 outformat , const char * title , const char * xlabel , const char * ylabel ) { char * newroot ; <S2SV_StartBug> char buf [ L_BUF_SIZE ] ; <S2SV_EndBug> l_int32 badchar ; GPLOT * gplot ; PROCNAME ( "gplotCreate" ) ; if ( ! rootname ) return ( GPLOT * ) ERROR_PTR ( "rootname<S2SV_blank>not<S2SV_blank>defined" , procName , NULL ) ; if ( outformat != GPLOT_PNG && outformat != GPLOT_PS && outformat != GPLOT_EPS && outformat != GPLOT_LATEX ) return ( GPLOT * ) ERROR_PTR ( "outformat<S2SV_blank>invalid" , procName , NULL ) ; stringCheckForChars ( rootname , "`;&|><\\"?*" , & badchar ) ; if ( badchar ) return ( GPLOT * ) ERROR_PTR ( "invalid<S2SV_blank>rootname" , procName , NULL ) ; if ( ( gplot = ( GPLOT * ) LEPT_CALLOC ( 1 , sizeof ( GPLOT ) ) ) == NULL ) return ( GPLOT * ) ERROR_PTR ( "gplot<S2SV_blank>not<S2SV_blank>made" , procName , NULL ) ; gplot -> cmddata = sarrayCreate ( 0 ) ; gplot -> datanames = sarrayCreate ( 0 ) ; gplot -> plotdata = sarrayCreate ( 0 ) ; gplot -> plottitles = sarrayCreate ( 0 ) ; gplot -> plotstyles = numaCreate ( 0 ) ; newroot = genPathname ( rootname , NULL ) ; gplot -> rootname = newroot ; gplot -> outformat = outformat ; <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , "%s.cmd" , rootname ) ; <S2SV_EndBug> gplot -> cmdname = stringNew ( buf ) ; if ( outformat == GPLOT_PNG ) <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , "%s.png" , newroot ) ; <S2SV_EndBug> else if ( outformat == GPLOT_PS ) <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , "%s.ps" , newroot ) ; <S2SV_EndBug> else if ( outformat == GPLOT_EPS ) <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , "%s.eps" , newroot ) ; <S2SV_EndBug> else if ( outformat == GPLOT_LATEX ) <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , "%s.tex" , newroot ) ; <S2SV_EndBug> gplot -> outname = stringNew ( buf ) ; if ( title ) gplot -> title = stringNew ( title ) ; if ( xlabel ) gplot -> xlabel = stringNew ( xlabel ) ; if ( ylabel ) gplot -> ylabel = stringNew ( ylabel ) ; return gplot ; }
CWE-119 l_int32 gplotGenCommandFile ( GPLOT * gplot ) { <S2SV_StartBug> char buf [ L_BUF_SIZE ] ; <S2SV_EndBug> char * cmdstr , * plottitle , * dataname ; l_int32 i , plotstyle , nplots ; FILE * fp ; PROCNAME ( "gplotGenCommandFile" ) ; if ( ! gplot ) return ERROR_INT ( "gplot<S2SV_blank>not<S2SV_blank>defined" , procName , 1 ) ; sarrayClear ( gplot -> cmddata ) ; if ( gplot -> title ) { <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , "set<S2SV_blank>title<S2SV_blank>\'%s\'" , gplot -> title ) ; <S2SV_EndBug> sarrayAddString ( gplot -> cmddata , buf , L_COPY ) ; } if ( gplot -> xlabel ) { <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , "set<S2SV_blank>xlabel<S2SV_blank>\'%s\'" , gplot -> xlabel ) ; <S2SV_EndBug> sarrayAddString ( gplot -> cmddata , buf , L_COPY ) ; } if ( gplot -> ylabel ) { <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , "set<S2SV_blank>ylabel<S2SV_blank>\'%s\'" , gplot -> ylabel ) ; <S2SV_EndBug> sarrayAddString ( gplot -> cmddata , buf , L_COPY ) ; } if ( gplot -> outformat == GPLOT_PNG ) { <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , "set<S2SV_blank>terminal<S2SV_blank>png;<S2SV_blank>set<S2SV_blank>output<S2SV_blank>\'%s\'" , <S2SV_EndBug> gplot -> outname ) ; } else if ( gplot -> outformat == GPLOT_PS ) { <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , "set<S2SV_blank>terminal<S2SV_blank>postscript;<S2SV_blank>set<S2SV_blank>output<S2SV_blank>\'%s\'" , <S2SV_EndBug> gplot -> outname ) ; } else if ( gplot -> outformat == GPLOT_EPS ) { <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , <S2SV_EndBug> "set<S2SV_blank>terminal<S2SV_blank>postscript<S2SV_blank>eps;<S2SV_blank>set<S2SV_blank>output<S2SV_blank>\'%s\'" , gplot -> outname ) ; } else if ( gplot -> outformat == GPLOT_LATEX ) { <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , "set<S2SV_blank>terminal<S2SV_blank>latex;<S2SV_blank>set<S2SV_blank>output<S2SV_blank>\'%s\'" , <S2SV_EndBug> gplot -> outname ) ; } sarrayAddString ( gplot -> cmddata , buf , L_COPY ) ; if ( gplot -> scaling == GPLOT_LOG_SCALE_X || gplot -> scaling == GPLOT_LOG_SCALE_X_Y ) { <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , "set<S2SV_blank>logscale<S2SV_blank>x" ) ; <S2SV_EndBug> sarrayAddString ( gplot -> cmddata , buf , L_COPY ) ; } if ( gplot -> scaling == GPLOT_LOG_SCALE_Y || gplot -> scaling == GPLOT_LOG_SCALE_X_Y ) { <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , "set<S2SV_blank>logscale<S2SV_blank>y" ) ; <S2SV_EndBug> sarrayAddString ( gplot -> cmddata , buf , L_COPY ) ; } nplots = sarrayGetCount ( gplot -> datanames ) ; for ( i = 0 ; i < nplots ; i ++ ) { plottitle = sarrayGetString ( gplot -> plottitles , i , L_NOCOPY ) ; dataname = sarrayGetString ( gplot -> datanames , i , L_NOCOPY ) ; numaGetIValue ( gplot -> plotstyles , i , & plotstyle ) ; if ( nplots == 1 ) { <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , "plot<S2SV_blank>\'%s\'<S2SV_blank>title<S2SV_blank>\'%s\'<S2SV_blank>%s" , <S2SV_EndBug> dataname , plottitle , gplotstylenames [ plotstyle ] ) ; } else { if ( i == 0 ) <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , "plot<S2SV_blank>\'%s\'<S2SV_blank>title<S2SV_blank>\'%s\'<S2SV_blank>%s,<S2SV_blank>\\\\" , <S2SV_EndBug> dataname , plottitle , gplotstylenames [ plotstyle ] ) ; else if ( i < nplots - 1 ) <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , "<S2SV_blank>\'%s\'<S2SV_blank>title<S2SV_blank>\'%s\'<S2SV_blank>%s,<S2SV_blank>\\\\" , <S2SV_EndBug> dataname , plottitle , gplotstylenames [ plotstyle ] ) ; else <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , "<S2SV_blank>\'%s\'<S2SV_blank>title<S2SV_blank>\'%s\'<S2SV_blank>%s" , <S2SV_EndBug> dataname , plottitle , gplotstylenames [ plotstyle ] ) ; } sarrayAddString ( gplot -> cmddata , buf , L_COPY ) ; } cmdstr = sarrayToString ( gplot -> cmddata , 1 ) ; if ( ( fp = fopenWriteStream ( gplot -> cmdname , "w" ) ) == NULL ) { LEPT_FREE ( cmdstr ) ; return ERROR_INT ( "cmd<S2SV_blank>stream<S2SV_blank>not<S2SV_blank>opened" , procName , 1 ) ; } fwrite ( cmdstr , 1 , strlen ( cmdstr ) , fp ) ; fclose ( fp ) ; LEPT_FREE ( cmdstr ) ; return 0 ; }
CWE-119 l_int32 gplotMakeOutput ( GPLOT * gplot ) { <S2SV_StartBug> char buf [ L_BUF_SIZE ] ; <S2SV_EndBug> char * cmdname ; l_int32 ignore ; PROCNAME ( "gplotMakeOutput" ) ; if ( ! gplot ) return ERROR_INT ( "gplot<S2SV_blank>not<S2SV_blank>defined" , procName , 1 ) ; gplotGenCommandFile ( gplot ) ; gplotGenDataFiles ( gplot ) ; cmdname = genPathname ( gplot -> cmdname , NULL ) ; # ifndef _WIN32 <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , "gnuplot<S2SV_blank>%s" , cmdname ) ; <S2SV_EndBug> # else <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , "wgnuplot<S2SV_blank>%s" , cmdname ) ; <S2SV_EndBug> # endif # ifndef OS_IOS ignore = system ( buf ) ; # endif LEPT_FREE ( cmdname ) ; return 0 ; }
CWE-119 GPLOT * gplotRead ( const char * filename ) { <S2SV_StartBug> char buf [ L_BUF_SIZE ] ; <S2SV_EndBug> char * rootname , * title , * xlabel , * ylabel , * ignores ; l_int32 outformat , ret , version , ignore ; FILE * fp ; GPLOT * gplot ; PROCNAME ( "gplotRead" ) ; if ( ! filename ) return ( GPLOT * ) ERROR_PTR ( "filename<S2SV_blank>not<S2SV_blank>defined" , procName , NULL ) ; if ( ( fp = fopenReadStream ( filename ) ) == NULL ) return ( GPLOT * ) ERROR_PTR ( "stream<S2SV_blank>not<S2SV_blank>opened" , procName , NULL ) ; ret = fscanf ( fp , "Gplot<S2SV_blank>Version<S2SV_blank>%d\\n" , & version ) ; if ( ret != 1 ) { fclose ( fp ) ; return ( GPLOT * ) ERROR_PTR ( "not<S2SV_blank>a<S2SV_blank>gplot<S2SV_blank>file" , procName , NULL ) ; } if ( version != GPLOT_VERSION_NUMBER ) { fclose ( fp ) ; return ( GPLOT * ) ERROR_PTR ( "invalid<S2SV_blank>gplot<S2SV_blank>version" , procName , NULL ) ; } <S2SV_StartBug> ignore = fscanf ( fp , "Rootname:<S2SV_blank>%s\\n" , buf ) ; <S2SV_EndBug> rootname = stringNew ( buf ) ; ignore = fscanf ( fp , "Output<S2SV_blank>format:<S2SV_blank>%d\\n" , & outformat ) ; <S2SV_StartBug> ignores = fgets ( buf , L_BUF_SIZE , fp ) ; <S2SV_EndBug> title = stringNew ( buf + 7 ) ; title [ strlen ( title ) - 1 ] = '\\0' ; <S2SV_StartBug> ignores = fgets ( buf , L_BUF_SIZE , fp ) ; <S2SV_EndBug> xlabel = stringNew ( buf + 14 ) ; xlabel [ strlen ( xlabel ) - 1 ] = '\\0' ; <S2SV_StartBug> ignores = fgets ( buf , L_BUF_SIZE , fp ) ; <S2SV_EndBug> ylabel = stringNew ( buf + 14 ) ; ylabel [ strlen ( ylabel ) - 1 ] = '\\0' ; gplot = gplotCreate ( rootname , outformat , title , xlabel , ylabel ) ; LEPT_FREE ( rootname ) ; LEPT_FREE ( title ) ; LEPT_FREE ( xlabel ) ; LEPT_FREE ( ylabel ) ; if ( ! gplot ) { fclose ( fp ) ; return ( GPLOT * ) ERROR_PTR ( "gplot<S2SV_blank>not<S2SV_blank>made" , procName , NULL ) ; } sarrayDestroy ( & gplot -> cmddata ) ; sarrayDestroy ( & gplot -> datanames ) ; sarrayDestroy ( & gplot -> plotdata ) ; sarrayDestroy ( & gplot -> plottitles ) ; numaDestroy ( & gplot -> plotstyles ) ; <S2SV_StartBug> ignore = fscanf ( fp , "Commandfile<S2SV_blank>name:<S2SV_blank>%s\\n" , buf ) ; <S2SV_EndBug> stringReplace ( & gplot -> cmdname , buf ) ; ignore = fscanf ( fp , "\\nCommandfile<S2SV_blank>data:" ) ; gplot -> cmddata = sarrayReadStream ( fp ) ; ignore = fscanf ( fp , "\\nDatafile<S2SV_blank>names:" ) ; gplot -> datanames = sarrayReadStream ( fp ) ; ignore = fscanf ( fp , "\\nPlot<S2SV_blank>data:" ) ; gplot -> plotdata = sarrayReadStream ( fp ) ; ignore = fscanf ( fp , "\\nPlot<S2SV_blank>titles:" ) ; gplot -> plottitles = sarrayReadStream ( fp ) ; ignore = fscanf ( fp , "\\nPlot<S2SV_blank>styles:" ) ; gplot -> plotstyles = numaReadStream ( fp ) ; ignore = fscanf ( fp , "Number<S2SV_blank>of<S2SV_blank>plots:<S2SV_blank>%d\\n" , & gplot -> nplots ) ; <S2SV_StartBug> ignore = fscanf ( fp , "Output<S2SV_blank>file<S2SV_blank>name:<S2SV_blank>%s\\n" , buf ) ; <S2SV_EndBug> stringReplace ( & gplot -> outname , buf ) ; ignore = fscanf ( fp , "Axis<S2SV_blank>scaling:<S2SV_blank>%d\\n" , & gplot -> scaling ) ; fclose ( fp ) ; return gplot ; }
CWE-119 PTA * ptaReadStream ( FILE * fp ) { char typestr [ 128 ] ; l_int32 i , n , ix , iy , type , version ; l_float32 x , y ; PTA * pta ; PROCNAME ( "ptaReadStream" ) ; if ( ! fp ) return ( PTA * ) ERROR_PTR ( "stream<S2SV_blank>not<S2SV_blank>defined" , procName , NULL ) ; if ( fscanf ( fp , "\\n<S2SV_blank>Pta<S2SV_blank>Version<S2SV_blank>%d\\n" , & version ) != 1 ) return ( PTA * ) ERROR_PTR ( "not<S2SV_blank>a<S2SV_blank>pta<S2SV_blank>file" , procName , NULL ) ; if ( version != PTA_VERSION_NUMBER ) return ( PTA * ) ERROR_PTR ( "invalid<S2SV_blank>pta<S2SV_blank>version" , procName , NULL ) ; <S2SV_StartBug> if ( fscanf ( fp , "<S2SV_blank>Number<S2SV_blank>of<S2SV_blank>pts<S2SV_blank>=<S2SV_blank>%d;<S2SV_blank>format<S2SV_blank>=<S2SV_blank>%s\\n" , & n , typestr ) != 2 ) <S2SV_EndBug> return ( PTA * ) ERROR_PTR ( "not<S2SV_blank>a<S2SV_blank>pta<S2SV_blank>file" , procName , NULL ) ; if ( ! strcmp ( typestr , "float" ) ) type = 0 ; else type = 1 ; if ( ( pta = ptaCreate ( n ) ) == NULL ) return ( PTA * ) ERROR_PTR ( "pta<S2SV_blank>not<S2SV_blank>made" , procName , NULL ) ; for ( i = 0 ; i < n ; i ++ ) { if ( type == 0 ) { if ( fscanf ( fp , "<S2SV_blank><S2SV_blank><S2SV_blank>(%f,<S2SV_blank>%f)\\n" , & x , & y ) != 2 ) { ptaDestroy ( & pta ) ; return ( PTA * ) ERROR_PTR ( "error<S2SV_blank>reading<S2SV_blank>floats" , procName , NULL ) ; } ptaAddPt ( pta , x , y ) ; } else { if ( fscanf ( fp , "<S2SV_blank><S2SV_blank><S2SV_blank>(%d,<S2SV_blank>%d)\\n" , & ix , & iy ) != 2 ) { ptaDestroy ( & pta ) ; return ( PTA * ) ERROR_PTR ( "error<S2SV_blank>reading<S2SV_blank>ints" , procName , NULL ) ; } ptaAddPt ( pta , ix , iy ) ; } } return pta ; }
CWE-119 SEL * selReadStream ( FILE * fp ) { char * selname ; <S2SV_StartBug> char linebuf [ L_BUF_SIZE ] ; <S2SV_EndBug> l_int32 sy , sx , cy , cx , i , j , version , ignore ; SEL * sel ; PROCNAME ( "selReadStream" ) ; if ( ! fp ) return ( SEL * ) ERROR_PTR ( "stream<S2SV_blank>not<S2SV_blank>defined" , procName , NULL ) ; if ( fscanf ( fp , "<S2SV_blank><S2SV_blank>Sel<S2SV_blank>Version<S2SV_blank>%d\\n" , & version ) != 1 ) return ( SEL * ) ERROR_PTR ( "not<S2SV_blank>a<S2SV_blank>sel<S2SV_blank>file" , procName , NULL ) ; if ( version != SEL_VERSION_NUMBER ) return ( SEL * ) ERROR_PTR ( "invalid<S2SV_blank>sel<S2SV_blank>version" , procName , NULL ) ; <S2SV_StartBug> if ( fgets ( linebuf , L_BUF_SIZE , fp ) == NULL ) <S2SV_EndBug> return ( SEL * ) ERROR_PTR ( "error<S2SV_blank>reading<S2SV_blank>into<S2SV_blank>linebuf" , procName , NULL ) ; selname = stringNew ( linebuf ) ; <S2SV_StartBug> sscanf ( linebuf , "<S2SV_blank><S2SV_blank>------<S2SV_blank><S2SV_blank>%s<S2SV_blank><S2SV_blank>------" , selname ) ; <S2SV_EndBug> if ( fscanf ( fp , "<S2SV_blank><S2SV_blank>sy<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>sx<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>cy<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>cx<S2SV_blank>=<S2SV_blank>%d\\n" , & sy , & sx , & cy , & cx ) != 4 ) { LEPT_FREE ( selname ) ; return ( SEL * ) ERROR_PTR ( "dimensions<S2SV_blank>not<S2SV_blank>read" , procName , NULL ) ; } if ( ( sel = selCreate ( sy , sx , selname ) ) == NULL ) { LEPT_FREE ( selname ) ; return ( SEL * ) ERROR_PTR ( "sel<S2SV_blank>not<S2SV_blank>made" , procName , NULL ) ; } selSetOrigin ( sel , cy , cx ) ; for ( i = 0 ; i < sy ; i ++ ) { ignore = fscanf ( fp , "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" ) ; for ( j = 0 ; j < sx ; j ++ ) ignore = fscanf ( fp , "%1d" , & sel -> data [ i ] [ j ] ) ; ignore = fscanf ( fp , "\\n" ) ; } ignore = fscanf ( fp , "\\n" ) ; LEPT_FREE ( selname ) ; return sel ; }
CWE-119 char * selaGetCombName ( SELA * sela , l_int32 size , l_int32 direction ) { char * selname ; <S2SV_StartBug> char combname [ L_BUF_SIZE ] ; <S2SV_EndBug> l_int32 i , nsels , sx , sy , found ; SEL * sel ; PROCNAME ( "selaGetCombName" ) ; if ( ! sela ) return ( char * ) ERROR_PTR ( "sela<S2SV_blank>not<S2SV_blank>defined" , procName , NULL ) ; if ( direction != L_HORIZ && direction != L_VERT ) return ( char * ) ERROR_PTR ( "invalid<S2SV_blank>direction" , procName , NULL ) ; if ( direction == L_HORIZ ) <S2SV_StartBug> snprintf ( combname , L_BUF_SIZE , "sel_comb_%dh" , size ) ; <S2SV_EndBug> else <S2SV_StartBug> snprintf ( combname , L_BUF_SIZE , "sel_comb_%dv" , size ) ; <S2SV_EndBug> found = FALSE ; nsels = selaGetCount ( sela ) ; for ( i = 0 ; i < nsels ; i ++ ) { sel = selaGetSel ( sela , i ) ; selGetParameters ( sel , & sy , & sx , NULL , NULL ) ; if ( sy != 1 && sx != 1 ) continue ; selname = selGetName ( sel ) ; if ( ! strcmp ( selname , combname ) ) { found = TRUE ; break ; } } if ( found ) return stringNew ( selname ) ; else return ( char * ) ERROR_PTR ( "sel<S2SV_blank>not<S2SV_blank>found" , procName , NULL ) ; }
CWE-125 static const char * parse_string ( cJSON * item , const char * str , const char * * ep ) { const char * ptr = str + 1 , * end_ptr = str + 1 ; char * ptr2 ; char * out ; int len = 0 ; unsigned uc , uc2 ; if ( * str != \'\\"\' ) { * ep = str ; return 0 ; } <S2SV_StartBug> while ( * end_ptr != \'\\"\' && * end_ptr && ++ len ) if ( * end_ptr ++ == '\\\\' ) end_ptr ++ ; <S2SV_EndBug> out = ( char * ) cJSON_malloc ( len + 1 ) ; if ( ! out ) return 0 ; item -> valuestring = out ; item -> type = cJSON_String ; ptr = str + 1 ; ptr2 = out ; while ( ptr < end_ptr ) { if ( * ptr != '\\\\' ) * ptr2 ++ = * ptr ++ ; else { ptr ++ ; switch ( * ptr ) { case 'b' : * ptr2 ++ = '\\b' ; break ; case 'f' : * ptr2 ++ = '\\f' ; break ; case 'n' : * ptr2 ++ = '\\n' ; break ; case 'r' : * ptr2 ++ = '\\r' ; break ; case 't' : * ptr2 ++ = '\\t' ; break ; case 'u' : uc = parse_hex4 ( ptr + 1 ) ; ptr += 4 ; if ( ptr >= end_ptr ) { * ep = str ; return 0 ; } if ( ( uc >= 0xDC00 && uc <= 0xDFFF ) || uc == 0 ) { * ep = str ; return 0 ; } if ( uc >= 0xD800 && uc <= 0xDBFF ) { if ( ptr + 6 > end_ptr ) { * ep = str ; return 0 ; } if ( ptr [ 1 ] != '\\\\' || ptr [ 2 ] != 'u' ) { * ep = str ; return 0 ; } uc2 = parse_hex4 ( ptr + 3 ) ; ptr += 6 ; if ( uc2 < 0xDC00 || uc2 > 0xDFFF ) { * ep = str ; return 0 ; } uc = 0x10000 + ( ( ( uc & 0x3FF ) << 10 ) | ( uc2 & 0x3FF ) ) ; } len = 4 ; if ( uc < 0x80 ) len = 1 ; else if ( uc < 0x800 ) len = 2 ; else if ( uc < 0x10000 ) len = 3 ; ptr2 += len ; switch ( len ) { case 4 : * -- ptr2 = ( ( uc | 0x80 ) & 0xBF ) ; uc >>= 6 ; case 3 : * -- ptr2 = ( ( uc | 0x80 ) & 0xBF ) ; uc >>= 6 ; case 2 : * -- ptr2 = ( ( uc | 0x80 ) & 0xBF ) ; uc >>= 6 ; case 1 : * -- ptr2 = ( uc | firstByteMark [ len ] ) ; } ptr2 += len ; break ; default : * ptr2 ++ = * ptr ; break ; } ptr ++ ; } } * ptr2 = 0 ; if ( * ptr == \'\\"\' ) ptr ++ ; return ptr ; }
CWE-125 static int decode_studio_vop_header ( Mpeg4DecContext * ctx , GetBitContext * gb ) { MpegEncContext * s = & ctx -> m ; if ( get_bits_left ( gb ) <= 32 ) return 0 ; s -> partitioned_frame = 0 ; <S2SV_StartBug> s -> decode_mb = mpeg4_decode_studio_mb ; <S2SV_EndBug> decode_smpte_tc ( ctx , gb ) ; skip_bits ( gb , 10 ) ; skip_bits ( gb , 2 ) ; s -> pict_type = get_bits ( gb , 2 ) + AV_PICTURE_TYPE_I ; if ( get_bits1 ( gb ) ) { skip_bits1 ( gb ) ; skip_bits1 ( gb ) ; s -> progressive_frame = get_bits1 ( gb ) ^ 1 ; } if ( s -> pict_type == AV_PICTURE_TYPE_I ) { if ( get_bits1 ( gb ) ) reset_studio_dc_predictors ( s ) ; } if ( ctx -> shape != BIN_ONLY_SHAPE ) { s -> alternate_scan = get_bits1 ( gb ) ; s -> frame_pred_frame_dct = get_bits1 ( gb ) ; s -> dct_precision = get_bits ( gb , 2 ) ; s -> intra_dc_precision = get_bits ( gb , 2 ) ; s -> q_scale_type = get_bits1 ( gb ) ; } if ( s -> alternate_scan ) { ff_init_scantable ( s -> idsp . idct_permutation , & s -> inter_scantable , ff_alternate_vertical_scan ) ; ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_scantable , ff_alternate_vertical_scan ) ; ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_h_scantable , ff_alternate_vertical_scan ) ; ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_v_scantable , ff_alternate_vertical_scan ) ; } else { ff_init_scantable ( s -> idsp . idct_permutation , & s -> inter_scantable , ff_zigzag_direct ) ; ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_scantable , ff_zigzag_direct ) ; ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_h_scantable , ff_alternate_horizontal_scan ) ; ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_v_scantable , ff_alternate_vertical_scan ) ; } mpeg4_load_default_matrices ( s ) ; next_start_code_studio ( gb ) ; extension_and_user_data ( s , gb , 4 ) ; return 0 ; }
CWE-476 int ff_mpeg4_decode_picture_header ( Mpeg4DecContext * ctx , GetBitContext * gb ) { MpegEncContext * s = & ctx -> m ; unsigned startcode , v ; int ret ; int vol = 0 ; align_get_bits ( gb ) ; if ( ! s -> studio_profile && s -> avctx -> bits_per_raw_sample != 8 ) s -> avctx -> bits_per_raw_sample = 0 ; if ( s -> codec_tag == AV_RL32 ( "WV1F" ) && show_bits ( gb , 24 ) == 0x575630 ) { skip_bits ( gb , 24 ) ; if ( get_bits ( gb , 8 ) == 0xF0 ) goto end ; } startcode = 0xff ; for ( ; ; ) { if ( get_bits_count ( gb ) >= gb -> size_in_bits ) { if ( gb -> size_in_bits == 8 && ( ctx -> divx_version >= 0 || ctx -> xvid_build >= 0 ) || s -> codec_tag == AV_RL32 ( "QMP4" ) ) { av_log ( s -> avctx , AV_LOG_VERBOSE , "frame<S2SV_blank>skip<S2SV_blank>%d\\n" , gb -> size_in_bits ) ; return FRAME_SKIPPED ; } else return AVERROR_INVALIDDATA ; } v = get_bits ( gb , 8 ) ; startcode = ( ( startcode << 8 ) | v ) & 0xffffffff ; if ( ( startcode & 0xFFFFFF00 ) != 0x100 ) continue ; if ( s -> avctx -> debug & FF_DEBUG_STARTCODE ) { av_log ( s -> avctx , AV_LOG_DEBUG , "startcode:<S2SV_blank>%3X<S2SV_blank>" , startcode ) ; if ( startcode <= 0x11F ) av_log ( s -> avctx , AV_LOG_DEBUG , "Video<S2SV_blank>Object<S2SV_blank>Start" ) ; else if ( startcode <= 0x12F ) av_log ( s -> avctx , AV_LOG_DEBUG , "Video<S2SV_blank>Object<S2SV_blank>Layer<S2SV_blank>Start" ) ; else if ( startcode <= 0x13F ) av_log ( s -> avctx , AV_LOG_DEBUG , "Reserved" ) ; else if ( startcode <= 0x15F ) av_log ( s -> avctx , AV_LOG_DEBUG , "FGS<S2SV_blank>bp<S2SV_blank>start" ) ; else if ( startcode <= 0x1AF ) av_log ( s -> avctx , AV_LOG_DEBUG , "Reserved" ) ; else if ( startcode == 0x1B0 ) av_log ( s -> avctx , AV_LOG_DEBUG , "Visual<S2SV_blank>Object<S2SV_blank>Seq<S2SV_blank>Start" ) ; else if ( startcode == 0x1B1 ) av_log ( s -> avctx , AV_LOG_DEBUG , "Visual<S2SV_blank>Object<S2SV_blank>Seq<S2SV_blank>End" ) ; else if ( startcode == 0x1B2 ) av_log ( s -> avctx , AV_LOG_DEBUG , "User<S2SV_blank>Data" ) ; else if ( startcode == 0x1B3 ) av_log ( s -> avctx , AV_LOG_DEBUG , "Group<S2SV_blank>of<S2SV_blank>VOP<S2SV_blank>start" ) ; else if ( startcode == 0x1B4 ) av_log ( s -> avctx , AV_LOG_DEBUG , "Video<S2SV_blank>Session<S2SV_blank>Error" ) ; else if ( startcode == 0x1B5 ) av_log ( s -> avctx , AV_LOG_DEBUG , "Visual<S2SV_blank>Object<S2SV_blank>Start" ) ; else if ( startcode == 0x1B6 ) av_log ( s -> avctx , AV_LOG_DEBUG , "Video<S2SV_blank>Object<S2SV_blank>Plane<S2SV_blank>start" ) ; else if ( startcode == 0x1B7 ) av_log ( s -> avctx , AV_LOG_DEBUG , "slice<S2SV_blank>start" ) ; else if ( startcode == 0x1B8 ) av_log ( s -> avctx , AV_LOG_DEBUG , "extension<S2SV_blank>start" ) ; else if ( startcode == 0x1B9 ) av_log ( s -> avctx , AV_LOG_DEBUG , "fgs<S2SV_blank>start" ) ; else if ( startcode == 0x1BA ) av_log ( s -> avctx , AV_LOG_DEBUG , "FBA<S2SV_blank>Object<S2SV_blank>start" ) ; else if ( startcode == 0x1BB ) av_log ( s -> avctx , AV_LOG_DEBUG , "FBA<S2SV_blank>Object<S2SV_blank>Plane<S2SV_blank>start" ) ; else if ( startcode == 0x1BC ) av_log ( s -> avctx , AV_LOG_DEBUG , "Mesh<S2SV_blank>Object<S2SV_blank>start" ) ; else if ( startcode == 0x1BD ) av_log ( s -> avctx , AV_LOG_DEBUG , "Mesh<S2SV_blank>Object<S2SV_blank>Plane<S2SV_blank>start" ) ; else if ( startcode == 0x1BE ) av_log ( s -> avctx , AV_LOG_DEBUG , "Still<S2SV_blank>Texture<S2SV_blank>Object<S2SV_blank>start" ) ; else if ( startcode == 0x1BF ) av_log ( s -> avctx , AV_LOG_DEBUG , "Texture<S2SV_blank>Spatial<S2SV_blank>Layer<S2SV_blank>start" ) ; else if ( startcode == 0x1C0 ) av_log ( s -> avctx , AV_LOG_DEBUG , "Texture<S2SV_blank>SNR<S2SV_blank>Layer<S2SV_blank>start" ) ; else if ( startcode == 0x1C1 ) av_log ( s -> avctx , AV_LOG_DEBUG , "Texture<S2SV_blank>Tile<S2SV_blank>start" ) ; else if ( startcode == 0x1C2 ) av_log ( s -> avctx , AV_LOG_DEBUG , "Texture<S2SV_blank>Shape<S2SV_blank>Layer<S2SV_blank>start" ) ; else if ( startcode == 0x1C3 ) av_log ( s -> avctx , AV_LOG_DEBUG , "stuffing<S2SV_blank>start" ) ; else if ( startcode <= 0x1C5 ) av_log ( s -> avctx , AV_LOG_DEBUG , "reserved" ) ; else if ( startcode <= 0x1FF ) av_log ( s -> avctx , AV_LOG_DEBUG , "System<S2SV_blank>start" ) ; av_log ( s -> avctx , AV_LOG_DEBUG , "<S2SV_blank>at<S2SV_blank>%d\\n" , get_bits_count ( gb ) ) ; } if ( startcode >= 0x120 && startcode <= 0x12F ) { if ( vol ) { av_log ( s -> avctx , AV_LOG_WARNING , "Ignoring<S2SV_blank>multiple<S2SV_blank>VOL<S2SV_blank>headers\\n" ) ; continue ; } vol ++ ; if ( ( ret = decode_vol_header ( ctx , gb ) ) < 0 ) return ret ; } else if ( startcode == USER_DATA_STARTCODE ) { decode_user_data ( ctx , gb ) ; } else if ( startcode == GOP_STARTCODE ) { mpeg4_decode_gop_header ( s , gb ) ; } else if ( startcode == VOS_STARTCODE ) { <S2SV_StartBug> mpeg4_decode_profile_level ( s , gb ) ; <S2SV_EndBug> if ( s -> avctx -> profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO && <S2SV_StartBug> ( s -> avctx -> level > 0 && s -> avctx -> level < 9 ) ) { <S2SV_EndBug> s -> studio_profile = 1 ; next_start_code_studio ( gb ) ; extension_and_user_data ( s , gb , 0 ) ; <S2SV_StartBug> } <S2SV_EndBug> } else if ( startcode == VISUAL_OBJ_STARTCODE ) { if ( s -> studio_profile ) { if ( ( ret = decode_studiovisualobject ( ctx , gb ) ) < 0 ) return ret ; } else mpeg4_decode_visual_object ( s , gb ) ; } else if ( startcode == VOP_STARTCODE ) { break ; } align_get_bits ( gb ) ; startcode = 0xff ; } end : if ( s -> avctx -> flags & AV_CODEC_FLAG_LOW_DELAY ) s -> low_delay = 1 ; s -> avctx -> has_b_frames = ! s -> low_delay ; if ( s -> studio_profile ) { <S2SV_StartBug> if ( ! s -> avctx -> bits_per_raw_sample ) { <S2SV_EndBug> av_log ( s -> avctx , AV_LOG_ERROR , "Missing<S2SV_blank>VOL<S2SV_blank>header\\n" ) ; return AVERROR_INVALIDDATA ; } return decode_studio_vop_header ( ctx , gb ) ; } else return decode_vop_header ( ctx , gb ) ; }
CWE-476 <S2SV_StartBug> static int mpeg4_decode_profile_level ( MpegEncContext * s , GetBitContext * gb ) <S2SV_EndBug> { s -> avctx -> profile = get_bits ( gb , 4 ) ; <S2SV_StartBug> s -> avctx -> level = get_bits ( gb , 4 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( s -> avctx -> profile == 0 && s -> avctx -> level == 8 ) { <S2SV_EndBug> <S2SV_StartBug> s -> avctx -> level = 0 ; <S2SV_EndBug> } return 0 ; }
CWE-119 static int parse_video_info ( AVIOContext * pb , AVStream * st ) { uint16_t size_asf ; uint32_t size_bmp ; unsigned int tag ; st -> codecpar -> width = avio_rl32 ( pb ) ; st -> codecpar -> height = avio_rl32 ( pb ) ; avio_skip ( pb , 1 ) ; size_asf = avio_rl16 ( pb ) ; tag = ff_get_bmp_header ( pb , st , & size_bmp ) ; st -> codecpar -> codec_tag = tag ; st -> codecpar -> codec_id = ff_codec_get_id ( ff_codec_bmp_tags , tag ) ; size_bmp = FFMAX ( size_asf , size_bmp ) ; <S2SV_StartBug> if ( size_bmp > BMP_HEADER_SIZE ) { <S2SV_EndBug> int ret ; st -> codecpar -> extradata_size = size_bmp - BMP_HEADER_SIZE ; if ( ! ( st -> codecpar -> extradata = av_malloc ( st -> codecpar -> extradata_size + AV_INPUT_BUFFER_PADDING_SIZE ) ) ) { st -> codecpar -> extradata_size = 0 ; return AVERROR ( ENOMEM ) ; } memset ( st -> codecpar -> extradata + st -> codecpar -> extradata_size , 0 , AV_INPUT_BUFFER_PADDING_SIZE ) ; if ( ( ret = avio_read ( pb , st -> codecpar -> extradata , st -> codecpar -> extradata_size ) ) < 0 ) return ret ; } return 0 ; }
CWE-20 int ff_mpeg4_decode_picture_header ( Mpeg4DecContext * ctx , GetBitContext * gb ) { MpegEncContext * s = & ctx -> m ; unsigned startcode , v ; int ret ; int vol = 0 ; <S2SV_StartBug> align_get_bits ( gb ) ; <S2SV_EndBug> if ( s -> codec_tag == AV_RL32 ( "WV1F" ) && show_bits ( gb , 24 ) == 0x575630 ) { skip_bits ( gb , 24 ) ; if ( get_bits ( gb , 8 ) == 0xF0 ) goto end ; } startcode = 0xff ; for ( ; ; ) { if ( get_bits_count ( gb ) >= gb -> size_in_bits ) { if ( gb -> size_in_bits == 8 && ( ctx -> divx_version >= 0 || ctx -> xvid_build >= 0 ) || s -> codec_tag == AV_RL32 ( "QMP4" ) ) { av_log ( s -> avctx , AV_LOG_VERBOSE , "frame<S2SV_blank>skip<S2SV_blank>%d\\n" , gb -> size_in_bits ) ; return FRAME_SKIPPED ; } else return AVERROR_INVALIDDATA ; } v = get_bits ( gb , 8 ) ; startcode = ( ( startcode << 8 ) | v ) & 0xffffffff ; if ( ( startcode & 0xFFFFFF00 ) != 0x100 ) continue ; if ( s -> avctx -> debug & FF_DEBUG_STARTCODE ) { av_log ( s -> avctx , AV_LOG_DEBUG , "startcode:<S2SV_blank>%3X<S2SV_blank>" , startcode ) ; if ( startcode <= 0x11F ) av_log ( s -> avctx , AV_LOG_DEBUG , "Video<S2SV_blank>Object<S2SV_blank>Start" ) ; else if ( startcode <= 0x12F ) av_log ( s -> avctx , AV_LOG_DEBUG , "Video<S2SV_blank>Object<S2SV_blank>Layer<S2SV_blank>Start" ) ; else if ( startcode <= 0x13F ) av_log ( s -> avctx , AV_LOG_DEBUG , "Reserved" ) ; else if ( startcode <= 0x15F ) av_log ( s -> avctx , AV_LOG_DEBUG , "FGS<S2SV_blank>bp<S2SV_blank>start" ) ; else if ( startcode <= 0x1AF ) av_log ( s -> avctx , AV_LOG_DEBUG , "Reserved" ) ; else if ( startcode == 0x1B0 ) av_log ( s -> avctx , AV_LOG_DEBUG , "Visual<S2SV_blank>Object<S2SV_blank>Seq<S2SV_blank>Start" ) ; else if ( startcode == 0x1B1 ) av_log ( s -> avctx , AV_LOG_DEBUG , "Visual<S2SV_blank>Object<S2SV_blank>Seq<S2SV_blank>End" ) ; else if ( startcode == 0x1B2 ) av_log ( s -> avctx , AV_LOG_DEBUG , "User<S2SV_blank>Data" ) ; else if ( startcode == 0x1B3 ) av_log ( s -> avctx , AV_LOG_DEBUG , "Group<S2SV_blank>of<S2SV_blank>VOP<S2SV_blank>start" ) ; else if ( startcode == 0x1B4 ) av_log ( s -> avctx , AV_LOG_DEBUG , "Video<S2SV_blank>Session<S2SV_blank>Error" ) ; else if ( startcode == 0x1B5 ) av_log ( s -> avctx , AV_LOG_DEBUG , "Visual<S2SV_blank>Object<S2SV_blank>Start" ) ; else if ( startcode == 0x1B6 ) av_log ( s -> avctx , AV_LOG_DEBUG , "Video<S2SV_blank>Object<S2SV_blank>Plane<S2SV_blank>start" ) ; else if ( startcode == 0x1B7 ) av_log ( s -> avctx , AV_LOG_DEBUG , "slice<S2SV_blank>start" ) ; else if ( startcode == 0x1B8 ) av_log ( s -> avctx , AV_LOG_DEBUG , "extension<S2SV_blank>start" ) ; else if ( startcode == 0x1B9 ) av_log ( s -> avctx , AV_LOG_DEBUG , "fgs<S2SV_blank>start" ) ; else if ( startcode == 0x1BA ) av_log ( s -> avctx , AV_LOG_DEBUG , "FBA<S2SV_blank>Object<S2SV_blank>start" ) ; else if ( startcode == 0x1BB ) av_log ( s -> avctx , AV_LOG_DEBUG , "FBA<S2SV_blank>Object<S2SV_blank>Plane<S2SV_blank>start" ) ; else if ( startcode == 0x1BC ) av_log ( s -> avctx , AV_LOG_DEBUG , "Mesh<S2SV_blank>Object<S2SV_blank>start" ) ; else if ( startcode == 0x1BD ) av_log ( s -> avctx , AV_LOG_DEBUG , "Mesh<S2SV_blank>Object<S2SV_blank>Plane<S2SV_blank>start" ) ; else if ( startcode == 0x1BE ) av_log ( s -> avctx , AV_LOG_DEBUG , "Still<S2SV_blank>Texture<S2SV_blank>Object<S2SV_blank>start" ) ; else if ( startcode == 0x1BF ) av_log ( s -> avctx , AV_LOG_DEBUG , "Texture<S2SV_blank>Spatial<S2SV_blank>Layer<S2SV_blank>start" ) ; else if ( startcode == 0x1C0 ) av_log ( s -> avctx , AV_LOG_DEBUG , "Texture<S2SV_blank>SNR<S2SV_blank>Layer<S2SV_blank>start" ) ; else if ( startcode == 0x1C1 ) av_log ( s -> avctx , AV_LOG_DEBUG , "Texture<S2SV_blank>Tile<S2SV_blank>start" ) ; else if ( startcode == 0x1C2 ) av_log ( s -> avctx , AV_LOG_DEBUG , "Texture<S2SV_blank>Shape<S2SV_blank>Layer<S2SV_blank>start" ) ; else if ( startcode == 0x1C3 ) av_log ( s -> avctx , AV_LOG_DEBUG , "stuffing<S2SV_blank>start" ) ; else if ( startcode <= 0x1C5 ) av_log ( s -> avctx , AV_LOG_DEBUG , "reserved" ) ; else if ( startcode <= 0x1FF ) av_log ( s -> avctx , AV_LOG_DEBUG , "System<S2SV_blank>start" ) ; av_log ( s -> avctx , AV_LOG_DEBUG , "<S2SV_blank>at<S2SV_blank>%d\\n" , get_bits_count ( gb ) ) ; } if ( startcode >= 0x120 && startcode <= 0x12F ) { if ( vol ) { av_log ( s -> avctx , AV_LOG_WARNING , "Ignoring<S2SV_blank>multiple<S2SV_blank>VOL<S2SV_blank>headers\\n" ) ; continue ; } vol ++ ; if ( ( ret = decode_vol_header ( ctx , gb ) ) < 0 ) return ret ; } else if ( startcode == USER_DATA_STARTCODE ) { decode_user_data ( ctx , gb ) ; } else if ( startcode == GOP_STARTCODE ) { mpeg4_decode_gop_header ( s , gb ) ; } else if ( startcode == VOS_STARTCODE ) { mpeg4_decode_profile_level ( s , gb ) ; if ( s -> avctx -> profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO && ( s -> avctx -> level > 0 && s -> avctx -> level < 9 ) ) { s -> studio_profile = 1 ; next_start_code_studio ( gb ) ; extension_and_user_data ( s , gb , 0 ) ; } } else if ( startcode == VISUAL_OBJ_STARTCODE ) { if ( s -> studio_profile ) { if ( ( ret = decode_studiovisualobject ( ctx , gb ) ) < 0 ) return ret ; } else mpeg4_decode_visual_object ( s , gb ) ; } else if ( startcode == VOP_STARTCODE ) { break ; } align_get_bits ( gb ) ; startcode = 0xff ; } end : if ( s -> avctx -> flags & AV_CODEC_FLAG_LOW_DELAY ) s -> low_delay = 1 ; s -> avctx -> has_b_frames = ! s -> low_delay ; if ( s -> studio_profile ) { if ( ! s -> avctx -> bits_per_raw_sample ) { av_log ( s -> avctx , AV_LOG_ERROR , "Missing<S2SV_blank>VOL<S2SV_blank>header\\n" ) ; return AVERROR_INVALIDDATA ; } return decode_studio_vop_header ( ctx , gb ) ; } else return decode_vop_header ( ctx , gb ) ; }
CWE-369 int ff_mov_write_packet ( AVFormatContext * s , AVPacket * pkt ) { MOVMuxContext * mov = s -> priv_data ; AVIOContext * pb = s -> pb ; MOVTrack * trk = & mov -> tracks [ pkt -> stream_index ] ; AVCodecParameters * par = trk -> par ; unsigned int samples_in_chunk = 0 ; int size = pkt -> size , ret = 0 ; uint8_t * reformatted_data = NULL ; ret = check_pkt ( s , pkt ) ; if ( ret < 0 ) return ret ; if ( mov -> flags & FF_MOV_FLAG_FRAGMENT ) { int ret ; if ( mov -> moov_written || mov -> flags & FF_MOV_FLAG_EMPTY_MOOV ) { if ( mov -> frag_interleave && mov -> fragments > 0 ) { if ( trk -> entry - trk -> entries_flushed >= mov -> frag_interleave ) { if ( ( ret = mov_flush_fragment_interleaving ( s , trk ) ) < 0 ) return ret ; } } if ( ! trk -> mdat_buf ) { if ( ( ret = avio_open_dyn_buf ( & trk -> mdat_buf ) ) < 0 ) return ret ; } pb = trk -> mdat_buf ; } else { if ( ! mov -> mdat_buf ) { if ( ( ret = avio_open_dyn_buf ( & mov -> mdat_buf ) ) < 0 ) return ret ; } pb = mov -> mdat_buf ; } } if ( par -> codec_id == AV_CODEC_ID_AMR_NB ) { static const uint16_t packed_size [ 16 ] = { 13 , 14 , 16 , 18 , 20 , 21 , 27 , 32 , 6 , 0 , 0 , 0 , 0 , 0 , 0 , 1 } ; int len = 0 ; while ( len < size && samples_in_chunk < 100 ) { len += packed_size [ ( pkt -> data [ len ] >> 3 ) & 0x0F ] ; samples_in_chunk ++ ; } if ( samples_in_chunk > 1 ) { av_log ( s , AV_LOG_ERROR , "fatal<S2SV_blank>error,<S2SV_blank>input<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>single<S2SV_blank>packet,<S2SV_blank>implement<S2SV_blank>a<S2SV_blank>AVParser<S2SV_blank>for<S2SV_blank>it\\n" ) ; return - 1 ; } } else if ( par -> codec_id == AV_CODEC_ID_ADPCM_MS || par -> codec_id == AV_CODEC_ID_ADPCM_IMA_WAV ) { samples_in_chunk = trk -> par -> frame_size ; } else if ( trk -> sample_size ) samples_in_chunk = size / trk -> sample_size ; else samples_in_chunk = 1 ; <S2SV_StartBug> if ( trk -> vos_len == 0 && par -> extradata_size > 0 && <S2SV_EndBug> ! TAG_IS_AVCI ( trk -> tag ) && ( par -> codec_id != AV_CODEC_ID_DNXHD ) ) { trk -> vos_len = par -> extradata_size ; trk -> vos_data = av_malloc ( trk -> vos_len ) ; if ( ! trk -> vos_data ) { ret = AVERROR ( ENOMEM ) ; goto err ; } memcpy ( trk -> vos_data , par -> extradata , trk -> vos_len ) ; } if ( par -> codec_id == AV_CODEC_ID_AAC && pkt -> size > 2 && ( AV_RB16 ( pkt -> data ) & 0xfff0 ) == 0xfff0 ) { if ( ! s -> streams [ pkt -> stream_index ] -> nb_frames ) { av_log ( s , AV_LOG_ERROR , "Malformed<S2SV_blank>AAC<S2SV_blank>bitstream<S2SV_blank>detected:<S2SV_blank>" "use<S2SV_blank>the<S2SV_blank>audio<S2SV_blank>bitstream<S2SV_blank>filter<S2SV_blank>\'aac_adtstoasc\'<S2SV_blank>to<S2SV_blank>fix<S2SV_blank>it<S2SV_blank>" "(\'-bsf:a<S2SV_blank>aac_adtstoasc\'<S2SV_blank>option<S2SV_blank>with<S2SV_blank>ffmpeg)\\n" ) ; return - 1 ; } av_log ( s , AV_LOG_WARNING , "aac<S2SV_blank>bitstream<S2SV_blank>error\\n" ) ; } if ( par -> codec_id == AV_CODEC_ID_H264 && trk -> vos_len > 0 && * ( uint8_t * ) trk -> vos_data != 1 && ! TAG_IS_AVCI ( trk -> tag ) ) { if ( trk -> hint_track >= 0 && trk -> hint_track < mov -> nb_streams ) { ff_avc_parse_nal_units_buf ( pkt -> data , & reformatted_data , & size ) ; avio_write ( pb , reformatted_data , size ) ; } else { if ( trk -> cenc . aes_ctr ) { size = ff_mov_cenc_avc_parse_nal_units ( & trk -> cenc , pb , pkt -> data , size ) ; if ( size < 0 ) { ret = size ; goto err ; } } else { size = ff_avc_parse_nal_units ( pb , pkt -> data , pkt -> size ) ; } } } else if ( par -> codec_id == AV_CODEC_ID_HEVC && trk -> vos_len > 6 && ( AV_RB24 ( trk -> vos_data ) == 1 || AV_RB32 ( trk -> vos_data ) == 1 ) ) { if ( trk -> hint_track >= 0 && trk -> hint_track < mov -> nb_streams ) { ff_hevc_annexb2mp4_buf ( pkt -> data , & reformatted_data , & size , 0 , NULL ) ; avio_write ( pb , reformatted_data , size ) ; } else { size = ff_hevc_annexb2mp4 ( pb , pkt -> data , pkt -> size , 0 , NULL ) ; } # if CONFIG_AC3_PARSER } else if ( par -> codec_id == AV_CODEC_ID_EAC3 ) { size = handle_eac3 ( mov , pkt , trk ) ; if ( size < 0 ) return size ; else if ( ! size ) goto end ; avio_write ( pb , pkt -> data , size ) ; # endif } else { if ( trk -> cenc . aes_ctr ) { if ( par -> codec_id == AV_CODEC_ID_H264 && par -> extradata_size > 4 ) { int nal_size_length = ( par -> extradata [ 4 ] & 0x3 ) + 1 ; ret = ff_mov_cenc_avc_write_nal_units ( s , & trk -> cenc , nal_size_length , pb , pkt -> data , size ) ; } else { ret = ff_mov_cenc_write_packet ( & trk -> cenc , pb , pkt -> data , size ) ; } if ( ret ) { goto err ; } } else { avio_write ( pb , pkt -> data , size ) ; } } if ( ( par -> codec_id == AV_CODEC_ID_DNXHD || par -> codec_id == AV_CODEC_ID_AC3 ) && ! trk -> vos_len ) { trk -> vos_len = size ; trk -> vos_data = av_malloc ( size ) ; if ( ! trk -> vos_data ) { ret = AVERROR ( ENOMEM ) ; goto err ; } memcpy ( trk -> vos_data , pkt -> data , size ) ; } if ( trk -> entry >= trk -> cluster_capacity ) { unsigned new_capacity = 2 * ( trk -> entry + MOV_INDEX_CLUSTER_SIZE ) ; if ( av_reallocp_array ( & trk -> cluster , new_capacity , sizeof ( * trk -> cluster ) ) ) { ret = AVERROR ( ENOMEM ) ; goto err ; } trk -> cluster_capacity = new_capacity ; } trk -> cluster [ trk -> entry ] . pos = avio_tell ( pb ) - size ; trk -> cluster [ trk -> entry ] . samples_in_chunk = samples_in_chunk ; trk -> cluster [ trk -> entry ] . chunkNum = 0 ; trk -> cluster [ trk -> entry ] . size = size ; trk -> cluster [ trk -> entry ] . entries = samples_in_chunk ; trk -> cluster [ trk -> entry ] . dts = pkt -> dts ; trk -> cluster [ trk -> entry ] . pts = pkt -> pts ; if ( ! trk -> entry && trk -> start_dts != AV_NOPTS_VALUE ) { if ( ! trk -> frag_discont ) { trk -> cluster [ trk -> entry ] . dts = trk -> start_dts + trk -> track_duration ; if ( ( mov -> flags & FF_MOV_FLAG_DASH && ! ( mov -> flags & FF_MOV_FLAG_GLOBAL_SIDX ) ) || mov -> mode == MODE_ISM ) pkt -> pts = pkt -> dts + trk -> end_pts - trk -> cluster [ trk -> entry ] . dts ; } else { trk -> frag_start = pkt -> dts - trk -> start_dts ; trk -> end_pts = AV_NOPTS_VALUE ; trk -> frag_discont = 0 ; } } if ( ! trk -> entry && trk -> start_dts == AV_NOPTS_VALUE && ! mov -> use_editlist && s -> avoid_negative_ts == AVFMT_AVOID_NEG_TS_MAKE_ZERO ) { trk -> cluster [ trk -> entry ] . dts = trk -> start_dts = 0 ; } if ( trk -> start_dts == AV_NOPTS_VALUE ) { trk -> start_dts = pkt -> dts ; if ( trk -> frag_discont ) { if ( mov -> use_editlist ) { trk -> frag_start = pkt -> pts ; trk -> start_dts = pkt -> dts - pkt -> pts ; } else { trk -> frag_start = pkt -> dts ; trk -> start_dts = 0 ; } trk -> frag_discont = 0 ; } else if ( pkt -> dts && mov -> moov_written ) av_log ( s , AV_LOG_WARNING , "Track<S2SV_blank>%d<S2SV_blank>starts<S2SV_blank>with<S2SV_blank>a<S2SV_blank>nonzero<S2SV_blank>dts<S2SV_blank>%" PRId64 ",<S2SV_blank>while<S2SV_blank>the<S2SV_blank>moov<S2SV_blank>" "already<S2SV_blank>has<S2SV_blank>been<S2SV_blank>written.<S2SV_blank>Set<S2SV_blank>the<S2SV_blank>delay_moov<S2SV_blank>flag<S2SV_blank>to<S2SV_blank>handle<S2SV_blank>" "this<S2SV_blank>case.\\n" , pkt -> stream_index , pkt -> dts ) ; } trk -> track_duration = pkt -> dts - trk -> start_dts + pkt -> duration ; trk -> last_sample_is_subtitle_end = 0 ; if ( pkt -> pts == AV_NOPTS_VALUE ) { av_log ( s , AV_LOG_WARNING , "pts<S2SV_blank>has<S2SV_blank>no<S2SV_blank>value\\n" ) ; pkt -> pts = pkt -> dts ; } if ( pkt -> dts != pkt -> pts ) trk -> flags |= MOV_TRACK_CTTS ; trk -> cluster [ trk -> entry ] . cts = pkt -> pts - pkt -> dts ; trk -> cluster [ trk -> entry ] . flags = 0 ; if ( trk -> start_cts == AV_NOPTS_VALUE ) trk -> start_cts = pkt -> pts - pkt -> dts ; if ( trk -> end_pts == AV_NOPTS_VALUE ) trk -> end_pts = trk -> cluster [ trk -> entry ] . dts + trk -> cluster [ trk -> entry ] . cts + pkt -> duration ; else trk -> end_pts = FFMAX ( trk -> end_pts , trk -> cluster [ trk -> entry ] . dts + trk -> cluster [ trk -> entry ] . cts + pkt -> duration ) ; if ( par -> codec_id == AV_CODEC_ID_VC1 ) { mov_parse_vc1_frame ( pkt , trk ) ; } else if ( pkt -> flags & AV_PKT_FLAG_KEY ) { if ( mov -> mode == MODE_MOV && par -> codec_id == AV_CODEC_ID_MPEG2VIDEO && trk -> entry > 0 ) { mov_parse_mpeg2_frame ( pkt , & trk -> cluster [ trk -> entry ] . flags ) ; if ( trk -> cluster [ trk -> entry ] . flags & MOV_PARTIAL_SYNC_SAMPLE ) trk -> flags |= MOV_TRACK_STPS ; } else { trk -> cluster [ trk -> entry ] . flags = MOV_SYNC_SAMPLE ; } if ( trk -> cluster [ trk -> entry ] . flags & MOV_SYNC_SAMPLE ) trk -> has_keyframes ++ ; } if ( pkt -> flags & AV_PKT_FLAG_DISPOSABLE ) { trk -> cluster [ trk -> entry ] . flags |= MOV_DISPOSABLE_SAMPLE ; trk -> has_disposable ++ ; } trk -> entry ++ ; trk -> sample_count += samples_in_chunk ; mov -> mdat_size += size ; if ( trk -> hint_track >= 0 && trk -> hint_track < mov -> nb_streams ) ff_mov_add_hinted_packet ( s , pkt , trk -> hint_track , trk -> entry , reformatted_data , size ) ; end : err : av_free ( reformatted_data ) ; return ret ; }
CWE-476 static int decode_nal_unit ( HEVCContext * s , const H2645NAL * nal ) { HEVCLocalContext * lc = s -> HEVClc ; GetBitContext * gb = & lc -> gb ; int ctb_addr_ts , ret ; * gb = nal -> gb ; s -> nal_unit_type = nal -> type ; s -> temporal_id = nal -> temporal_id ; switch ( s -> nal_unit_type ) { case HEVC_NAL_VPS : if ( s -> avctx -> hwaccel && s -> avctx -> hwaccel -> decode_params ) { ret = s -> avctx -> hwaccel -> decode_params ( s -> avctx , nal -> type , nal -> raw_data , nal -> raw_size ) ; if ( ret < 0 ) goto fail ; } ret = ff_hevc_decode_nal_vps ( gb , s -> avctx , & s -> ps ) ; if ( ret < 0 ) goto fail ; break ; case HEVC_NAL_SPS : if ( s -> avctx -> hwaccel && s -> avctx -> hwaccel -> decode_params ) { ret = s -> avctx -> hwaccel -> decode_params ( s -> avctx , nal -> type , nal -> raw_data , nal -> raw_size ) ; if ( ret < 0 ) goto fail ; } ret = ff_hevc_decode_nal_sps ( gb , s -> avctx , & s -> ps , s -> apply_defdispwin ) ; if ( ret < 0 ) goto fail ; break ; case HEVC_NAL_PPS : if ( s -> avctx -> hwaccel && s -> avctx -> hwaccel -> decode_params ) { ret = s -> avctx -> hwaccel -> decode_params ( s -> avctx , nal -> type , nal -> raw_data , nal -> raw_size ) ; if ( ret < 0 ) goto fail ; } ret = ff_hevc_decode_nal_pps ( gb , s -> avctx , & s -> ps ) ; if ( ret < 0 ) goto fail ; break ; case HEVC_NAL_SEI_PREFIX : case HEVC_NAL_SEI_SUFFIX : if ( s -> avctx -> hwaccel && s -> avctx -> hwaccel -> decode_params ) { ret = s -> avctx -> hwaccel -> decode_params ( s -> avctx , nal -> type , nal -> raw_data , nal -> raw_size ) ; if ( ret < 0 ) goto fail ; } ret = ff_hevc_decode_nal_sei ( gb , s -> avctx , & s -> sei , & s -> ps , s -> nal_unit_type ) ; if ( ret < 0 ) goto fail ; break ; case HEVC_NAL_TRAIL_R : case HEVC_NAL_TRAIL_N : case HEVC_NAL_TSA_N : case HEVC_NAL_TSA_R : case HEVC_NAL_STSA_N : case HEVC_NAL_STSA_R : case HEVC_NAL_BLA_W_LP : case HEVC_NAL_BLA_W_RADL : case HEVC_NAL_BLA_N_LP : case HEVC_NAL_IDR_W_RADL : case HEVC_NAL_IDR_N_LP : case HEVC_NAL_CRA_NUT : case HEVC_NAL_RADL_N : case HEVC_NAL_RADL_R : case HEVC_NAL_RASL_N : case HEVC_NAL_RASL_R : ret = hls_slice_header ( s ) ; if ( ret < 0 ) <S2SV_StartBug> return ret ; <S2SV_EndBug> if ( ( s -> avctx -> skip_frame >= AVDISCARD_BIDIR && s -> sh . slice_type == HEVC_SLICE_B ) || ( s -> avctx -> skip_frame >= AVDISCARD_NONINTRA && s -> sh . slice_type != HEVC_SLICE_I ) || ( s -> avctx -> skip_frame >= AVDISCARD_NONKEY && ! IS_IRAP ( s ) ) ) { break ; } if ( s -> sh . first_slice_in_pic_flag ) { <S2SV_StartBug> if ( s -> ref ) { <S2SV_EndBug> av_log ( s -> avctx , AV_LOG_ERROR , "Two<S2SV_blank>slices<S2SV_blank>reporting<S2SV_blank>being<S2SV_blank>the<S2SV_blank>first<S2SV_blank>in<S2SV_blank>the<S2SV_blank>same<S2SV_blank>frame.\\n" ) ; goto fail ; } if ( s -> max_ra == INT_MAX ) { if ( s -> nal_unit_type == HEVC_NAL_CRA_NUT || IS_BLA ( s ) ) { s -> max_ra = s -> poc ; } else { if ( IS_IDR ( s ) ) s -> max_ra = INT_MIN ; } } if ( ( s -> nal_unit_type == HEVC_NAL_RASL_R || s -> nal_unit_type == HEVC_NAL_RASL_N ) && s -> poc <= s -> max_ra ) { s -> is_decoded = 0 ; break ; } else { if ( s -> nal_unit_type == HEVC_NAL_RASL_R && s -> poc > s -> max_ra ) s -> max_ra = INT_MIN ; } s -> overlap ++ ; ret = hevc_frame_start ( s ) ; if ( ret < 0 ) return ret ; } else if ( ! s -> ref ) { av_log ( s -> avctx , AV_LOG_ERROR , "First<S2SV_blank>slice<S2SV_blank>in<S2SV_blank>a<S2SV_blank>frame<S2SV_blank>missing.\\n" ) ; goto fail ; } if ( s -> nal_unit_type != s -> first_nal_type ) { av_log ( s -> avctx , AV_LOG_ERROR , "Non-matching<S2SV_blank>NAL<S2SV_blank>types<S2SV_blank>of<S2SV_blank>the<S2SV_blank>VCL<S2SV_blank>NALUs:<S2SV_blank>%d<S2SV_blank>%d\\n" , s -> first_nal_type , s -> nal_unit_type ) ; return AVERROR_INVALIDDATA ; } if ( ! s -> sh . dependent_slice_segment_flag && s -> sh . slice_type != HEVC_SLICE_I ) { ret = ff_hevc_slice_rpl ( s ) ; if ( ret < 0 ) { av_log ( s -> avctx , AV_LOG_WARNING , "Error<S2SV_blank>constructing<S2SV_blank>the<S2SV_blank>reference<S2SV_blank>lists<S2SV_blank>for<S2SV_blank>the<S2SV_blank>current<S2SV_blank>slice.\\n" ) ; goto fail ; } } if ( s -> sh . first_slice_in_pic_flag && s -> avctx -> hwaccel ) { ret = s -> avctx -> hwaccel -> start_frame ( s -> avctx , NULL , 0 ) ; if ( ret < 0 ) goto fail ; } if ( s -> avctx -> hwaccel ) { ret = s -> avctx -> hwaccel -> decode_slice ( s -> avctx , nal -> raw_data , nal -> raw_size ) ; if ( ret < 0 ) goto fail ; } else { if ( s -> threads_number > 1 && s -> sh . num_entry_point_offsets > 0 ) ctb_addr_ts = hls_slice_data_wpp ( s , nal ) ; else ctb_addr_ts = hls_slice_data ( s ) ; if ( ctb_addr_ts >= ( s -> ps . sps -> ctb_width * s -> ps . sps -> ctb_height ) ) { s -> is_decoded = 1 ; } if ( ctb_addr_ts < 0 ) { ret = ctb_addr_ts ; goto fail ; } } break ; case HEVC_NAL_EOS_NUT : case HEVC_NAL_EOB_NUT : s -> seq_decode = ( s -> seq_decode + 1 ) & 0xff ; s -> max_ra = INT_MAX ; break ; case HEVC_NAL_AUD : case HEVC_NAL_FD_NUT : break ; default : av_log ( s -> avctx , AV_LOG_INFO , "Skipping<S2SV_blank>NAL<S2SV_blank>unit<S2SV_blank>%d\\n" , s -> nal_unit_type ) ; } return 0 ; fail : if ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) return ret ; return 0 ; }
CWE-476 static int hls_slice_header ( HEVCContext * s ) { GetBitContext * gb = & s -> HEVClc -> gb ; SliceHeader * sh = & s -> sh ; int i , ret ; <S2SV_StartBug> sh -> first_slice_in_pic_flag = get_bits1 ( gb ) ; <S2SV_EndBug> if ( ( IS_IDR ( s ) || IS_BLA ( s ) ) && sh -> first_slice_in_pic_flag ) { s -> seq_decode = ( s -> seq_decode + 1 ) & 0xff ; s -> max_ra = INT_MAX ; if ( IS_IDR ( s ) ) ff_hevc_clear_refs ( s ) ; } sh -> no_output_of_prior_pics_flag = 0 ; if ( IS_IRAP ( s ) ) sh -> no_output_of_prior_pics_flag = get_bits1 ( gb ) ; sh -> pps_id = get_ue_golomb_long ( gb ) ; if ( sh -> pps_id >= HEVC_MAX_PPS_COUNT || ! s -> ps . pps_list [ sh -> pps_id ] ) { av_log ( s -> avctx , AV_LOG_ERROR , "PPS<S2SV_blank>id<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range:<S2SV_blank>%d\\n" , sh -> pps_id ) ; return AVERROR_INVALIDDATA ; } if ( ! sh -> first_slice_in_pic_flag && s -> ps . pps != ( HEVCPPS * ) s -> ps . pps_list [ sh -> pps_id ] -> data ) { av_log ( s -> avctx , AV_LOG_ERROR , "PPS<S2SV_blank>changed<S2SV_blank>between<S2SV_blank>slices.\\n" ) ; return AVERROR_INVALIDDATA ; } s -> ps . pps = ( HEVCPPS * ) s -> ps . pps_list [ sh -> pps_id ] -> data ; if ( s -> nal_unit_type == HEVC_NAL_CRA_NUT && s -> last_eos == 1 ) sh -> no_output_of_prior_pics_flag = 1 ; if ( s -> ps . sps != ( HEVCSPS * ) s -> ps . sps_list [ s -> ps . pps -> sps_id ] -> data ) { const HEVCSPS * sps = ( HEVCSPS * ) s -> ps . sps_list [ s -> ps . pps -> sps_id ] -> data ; const HEVCSPS * last_sps = s -> ps . sps ; enum AVPixelFormat pix_fmt ; if ( last_sps && IS_IRAP ( s ) && s -> nal_unit_type != HEVC_NAL_CRA_NUT ) { if ( sps -> width != last_sps -> width || sps -> height != last_sps -> height || sps -> temporal_layer [ sps -> max_sub_layers - 1 ] . max_dec_pic_buffering != last_sps -> temporal_layer [ last_sps -> max_sub_layers - 1 ] . max_dec_pic_buffering ) sh -> no_output_of_prior_pics_flag = 0 ; } ff_hevc_clear_refs ( s ) ; ret = set_sps ( s , sps , sps -> pix_fmt ) ; if ( ret < 0 ) return ret ; pix_fmt = get_format ( s , sps ) ; if ( pix_fmt < 0 ) return pix_fmt ; s -> avctx -> pix_fmt = pix_fmt ; s -> seq_decode = ( s -> seq_decode + 1 ) & 0xff ; s -> max_ra = INT_MAX ; } sh -> dependent_slice_segment_flag = 0 ; if ( ! sh -> first_slice_in_pic_flag ) { int slice_address_length ; if ( s -> ps . pps -> dependent_slice_segments_enabled_flag ) sh -> dependent_slice_segment_flag = get_bits1 ( gb ) ; slice_address_length = av_ceil_log2 ( s -> ps . sps -> ctb_width * s -> ps . sps -> ctb_height ) ; sh -> slice_segment_addr = get_bitsz ( gb , slice_address_length ) ; if ( sh -> slice_segment_addr >= s -> ps . sps -> ctb_width * s -> ps . sps -> ctb_height ) { av_log ( s -> avctx , AV_LOG_ERROR , "Invalid<S2SV_blank>slice<S2SV_blank>segment<S2SV_blank>address:<S2SV_blank>%u.\\n" , sh -> slice_segment_addr ) ; return AVERROR_INVALIDDATA ; } if ( ! sh -> dependent_slice_segment_flag ) { sh -> slice_addr = sh -> slice_segment_addr ; s -> slice_idx ++ ; } } else { sh -> slice_segment_addr = sh -> slice_addr = 0 ; s -> slice_idx = 0 ; s -> slice_initialized = 0 ; } if ( ! sh -> dependent_slice_segment_flag ) { s -> slice_initialized = 0 ; for ( i = 0 ; i < s -> ps . pps -> num_extra_slice_header_bits ; i ++ ) skip_bits ( gb , 1 ) ; sh -> slice_type = get_ue_golomb_long ( gb ) ; if ( ! ( sh -> slice_type == HEVC_SLICE_I || sh -> slice_type == HEVC_SLICE_P || sh -> slice_type == HEVC_SLICE_B ) ) { av_log ( s -> avctx , AV_LOG_ERROR , "Unknown<S2SV_blank>slice<S2SV_blank>type:<S2SV_blank>%d.\\n" , sh -> slice_type ) ; return AVERROR_INVALIDDATA ; } if ( IS_IRAP ( s ) && sh -> slice_type != HEVC_SLICE_I ) { av_log ( s -> avctx , AV_LOG_ERROR , "Inter<S2SV_blank>slices<S2SV_blank>in<S2SV_blank>an<S2SV_blank>IRAP<S2SV_blank>frame.\\n" ) ; return AVERROR_INVALIDDATA ; } sh -> pic_output_flag = 1 ; if ( s -> ps . pps -> output_flag_present_flag ) sh -> pic_output_flag = get_bits1 ( gb ) ; if ( s -> ps . sps -> separate_colour_plane_flag ) sh -> colour_plane_id = get_bits ( gb , 2 ) ; if ( ! IS_IDR ( s ) ) { int poc , pos ; sh -> pic_order_cnt_lsb = get_bits ( gb , s -> ps . sps -> log2_max_poc_lsb ) ; poc = ff_hevc_compute_poc ( s -> ps . sps , s -> pocTid0 , sh -> pic_order_cnt_lsb , s -> nal_unit_type ) ; if ( ! sh -> first_slice_in_pic_flag && poc != s -> poc ) { av_log ( s -> avctx , AV_LOG_WARNING , "Ignoring<S2SV_blank>POC<S2SV_blank>change<S2SV_blank>between<S2SV_blank>slices:<S2SV_blank>%d<S2SV_blank>-><S2SV_blank>%d\\n" , s -> poc , poc ) ; if ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) return AVERROR_INVALIDDATA ; poc = s -> poc ; } s -> poc = poc ; sh -> short_term_ref_pic_set_sps_flag = get_bits1 ( gb ) ; pos = get_bits_left ( gb ) ; if ( ! sh -> short_term_ref_pic_set_sps_flag ) { ret = ff_hevc_decode_short_term_rps ( gb , s -> avctx , & sh -> slice_rps , s -> ps . sps , 1 ) ; if ( ret < 0 ) return ret ; sh -> short_term_rps = & sh -> slice_rps ; } else { int numbits , rps_idx ; if ( ! s -> ps . sps -> nb_st_rps ) { av_log ( s -> avctx , AV_LOG_ERROR , "No<S2SV_blank>ref<S2SV_blank>lists<S2SV_blank>in<S2SV_blank>the<S2SV_blank>SPS.\\n" ) ; return AVERROR_INVALIDDATA ; } numbits = av_ceil_log2 ( s -> ps . sps -> nb_st_rps ) ; rps_idx = numbits > 0 ? get_bits ( gb , numbits ) : 0 ; sh -> short_term_rps = & s -> ps . sps -> st_rps [ rps_idx ] ; } sh -> short_term_ref_pic_set_size = pos - get_bits_left ( gb ) ; pos = get_bits_left ( gb ) ; ret = decode_lt_rps ( s , & sh -> long_term_rps , gb ) ; if ( ret < 0 ) { av_log ( s -> avctx , AV_LOG_WARNING , "Invalid<S2SV_blank>long<S2SV_blank>term<S2SV_blank>RPS.\\n" ) ; if ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) return AVERROR_INVALIDDATA ; } sh -> long_term_ref_pic_set_size = pos - get_bits_left ( gb ) ; if ( s -> ps . sps -> sps_temporal_mvp_enabled_flag ) sh -> slice_temporal_mvp_enabled_flag = get_bits1 ( gb ) ; else sh -> slice_temporal_mvp_enabled_flag = 0 ; } else { s -> sh . short_term_rps = NULL ; s -> poc = 0 ; } if ( sh -> first_slice_in_pic_flag && s -> temporal_id == 0 && s -> nal_unit_type != HEVC_NAL_TRAIL_N && s -> nal_unit_type != HEVC_NAL_TSA_N && s -> nal_unit_type != HEVC_NAL_STSA_N && s -> nal_unit_type != HEVC_NAL_RADL_N && s -> nal_unit_type != HEVC_NAL_RADL_R && s -> nal_unit_type != HEVC_NAL_RASL_N && s -> nal_unit_type != HEVC_NAL_RASL_R ) s -> pocTid0 = s -> poc ; if ( s -> ps . sps -> sao_enabled ) { sh -> slice_sample_adaptive_offset_flag [ 0 ] = get_bits1 ( gb ) ; if ( s -> ps . sps -> chroma_format_idc ) { sh -> slice_sample_adaptive_offset_flag [ 1 ] = sh -> slice_sample_adaptive_offset_flag [ 2 ] = get_bits1 ( gb ) ; } } else { sh -> slice_sample_adaptive_offset_flag [ 0 ] = 0 ; sh -> slice_sample_adaptive_offset_flag [ 1 ] = 0 ; sh -> slice_sample_adaptive_offset_flag [ 2 ] = 0 ; } sh -> nb_refs [ L0 ] = sh -> nb_refs [ L1 ] = 0 ; if ( sh -> slice_type == HEVC_SLICE_P || sh -> slice_type == HEVC_SLICE_B ) { int nb_refs ; sh -> nb_refs [ L0 ] = s -> ps . pps -> num_ref_idx_l0_default_active ; if ( sh -> slice_type == HEVC_SLICE_B ) sh -> nb_refs [ L1 ] = s -> ps . pps -> num_ref_idx_l1_default_active ; if ( get_bits1 ( gb ) ) { sh -> nb_refs [ L0 ] = get_ue_golomb_long ( gb ) + 1 ; if ( sh -> slice_type == HEVC_SLICE_B ) sh -> nb_refs [ L1 ] = get_ue_golomb_long ( gb ) + 1 ; } if ( sh -> nb_refs [ L0 ] > HEVC_MAX_REFS || sh -> nb_refs [ L1 ] > HEVC_MAX_REFS ) { av_log ( s -> avctx , AV_LOG_ERROR , "Too<S2SV_blank>many<S2SV_blank>refs:<S2SV_blank>%d/%d.\\n" , sh -> nb_refs [ L0 ] , sh -> nb_refs [ L1 ] ) ; return AVERROR_INVALIDDATA ; } sh -> rpl_modification_flag [ 0 ] = 0 ; sh -> rpl_modification_flag [ 1 ] = 0 ; nb_refs = ff_hevc_frame_nb_refs ( s ) ; if ( ! nb_refs ) { av_log ( s -> avctx , AV_LOG_ERROR , "Zero<S2SV_blank>refs<S2SV_blank>for<S2SV_blank>a<S2SV_blank>frame<S2SV_blank>with<S2SV_blank>P<S2SV_blank>or<S2SV_blank>B<S2SV_blank>slices.\\n" ) ; return AVERROR_INVALIDDATA ; } if ( s -> ps . pps -> lists_modification_present_flag && nb_refs > 1 ) { sh -> rpl_modification_flag [ 0 ] = get_bits1 ( gb ) ; if ( sh -> rpl_modification_flag [ 0 ] ) { for ( i = 0 ; i < sh -> nb_refs [ L0 ] ; i ++ ) sh -> list_entry_lx [ 0 ] [ i ] = get_bits ( gb , av_ceil_log2 ( nb_refs ) ) ; } if ( sh -> slice_type == HEVC_SLICE_B ) { sh -> rpl_modification_flag [ 1 ] = get_bits1 ( gb ) ; if ( sh -> rpl_modification_flag [ 1 ] == 1 ) for ( i = 0 ; i < sh -> nb_refs [ L1 ] ; i ++ ) sh -> list_entry_lx [ 1 ] [ i ] = get_bits ( gb , av_ceil_log2 ( nb_refs ) ) ; } } if ( sh -> slice_type == HEVC_SLICE_B ) sh -> mvd_l1_zero_flag = get_bits1 ( gb ) ; if ( s -> ps . pps -> cabac_init_present_flag ) sh -> cabac_init_flag = get_bits1 ( gb ) ; else sh -> cabac_init_flag = 0 ; sh -> collocated_ref_idx = 0 ; if ( sh -> slice_temporal_mvp_enabled_flag ) { sh -> collocated_list = L0 ; if ( sh -> slice_type == HEVC_SLICE_B ) sh -> collocated_list = ! get_bits1 ( gb ) ; if ( sh -> nb_refs [ sh -> collocated_list ] > 1 ) { sh -> collocated_ref_idx = get_ue_golomb_long ( gb ) ; if ( sh -> collocated_ref_idx >= sh -> nb_refs [ sh -> collocated_list ] ) { av_log ( s -> avctx , AV_LOG_ERROR , "Invalid<S2SV_blank>collocated_ref_idx:<S2SV_blank>%d.\\n" , sh -> collocated_ref_idx ) ; return AVERROR_INVALIDDATA ; } } } if ( ( s -> ps . pps -> weighted_pred_flag && sh -> slice_type == HEVC_SLICE_P ) || ( s -> ps . pps -> weighted_bipred_flag && sh -> slice_type == HEVC_SLICE_B ) ) { int ret = pred_weight_table ( s , gb ) ; if ( ret < 0 ) return ret ; } sh -> max_num_merge_cand = 5 - get_ue_golomb_long ( gb ) ; if ( sh -> max_num_merge_cand < 1 || sh -> max_num_merge_cand > 5 ) { av_log ( s -> avctx , AV_LOG_ERROR , "Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>merging<S2SV_blank>MVP<S2SV_blank>candidates:<S2SV_blank>%d.\\n" , sh -> max_num_merge_cand ) ; return AVERROR_INVALIDDATA ; } } sh -> slice_qp_delta = get_se_golomb ( gb ) ; if ( s -> ps . pps -> pic_slice_level_chroma_qp_offsets_present_flag ) { sh -> slice_cb_qp_offset = get_se_golomb ( gb ) ; sh -> slice_cr_qp_offset = get_se_golomb ( gb ) ; } else { sh -> slice_cb_qp_offset = 0 ; sh -> slice_cr_qp_offset = 0 ; } if ( s -> ps . pps -> chroma_qp_offset_list_enabled_flag ) sh -> cu_chroma_qp_offset_enabled_flag = get_bits1 ( gb ) ; else sh -> cu_chroma_qp_offset_enabled_flag = 0 ; if ( s -> ps . pps -> deblocking_filter_control_present_flag ) { int deblocking_filter_override_flag = 0 ; if ( s -> ps . pps -> deblocking_filter_override_enabled_flag ) deblocking_filter_override_flag = get_bits1 ( gb ) ; if ( deblocking_filter_override_flag ) { sh -> disable_deblocking_filter_flag = get_bits1 ( gb ) ; if ( ! sh -> disable_deblocking_filter_flag ) { int beta_offset_div2 = get_se_golomb ( gb ) ; int tc_offset_div2 = get_se_golomb ( gb ) ; if ( beta_offset_div2 < - 6 || beta_offset_div2 > 6 || tc_offset_div2 < - 6 || tc_offset_div2 > 6 ) { av_log ( s -> avctx , AV_LOG_ERROR , "Invalid<S2SV_blank>deblock<S2SV_blank>filter<S2SV_blank>offsets:<S2SV_blank>%d,<S2SV_blank>%d\\n" , beta_offset_div2 , tc_offset_div2 ) ; return AVERROR_INVALIDDATA ; } sh -> beta_offset = beta_offset_div2 * 2 ; sh -> tc_offset = tc_offset_div2 * 2 ; } } else { sh -> disable_deblocking_filter_flag = s -> ps . pps -> disable_dbf ; sh -> beta_offset = s -> ps . pps -> beta_offset ; sh -> tc_offset = s -> ps . pps -> tc_offset ; } } else { sh -> disable_deblocking_filter_flag = 0 ; sh -> beta_offset = 0 ; sh -> tc_offset = 0 ; } if ( s -> ps . pps -> seq_loop_filter_across_slices_enabled_flag && ( sh -> slice_sample_adaptive_offset_flag [ 0 ] || sh -> slice_sample_adaptive_offset_flag [ 1 ] || ! sh -> disable_deblocking_filter_flag ) ) { sh -> slice_loop_filter_across_slices_enabled_flag = get_bits1 ( gb ) ; } else { sh -> slice_loop_filter_across_slices_enabled_flag = s -> ps . pps -> seq_loop_filter_across_slices_enabled_flag ; } } else if ( ! s -> slice_initialized ) { av_log ( s -> avctx , AV_LOG_ERROR , "Independent<S2SV_blank>slice<S2SV_blank>segment<S2SV_blank>missing.\\n" ) ; return AVERROR_INVALIDDATA ; } sh -> num_entry_point_offsets = 0 ; if ( s -> ps . pps -> tiles_enabled_flag || s -> ps . pps -> entropy_coding_sync_enabled_flag ) { unsigned num_entry_point_offsets = get_ue_golomb_long ( gb ) ; if ( num_entry_point_offsets > get_bits_left ( gb ) ) { av_log ( s -> avctx , AV_LOG_ERROR , "num_entry_point_offsets<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>invalid\\n" , num_entry_point_offsets ) ; return AVERROR_INVALIDDATA ; } sh -> num_entry_point_offsets = num_entry_point_offsets ; if ( sh -> num_entry_point_offsets > 0 ) { int offset_len = get_ue_golomb_long ( gb ) + 1 ; if ( offset_len < 1 || offset_len > 32 ) { sh -> num_entry_point_offsets = 0 ; av_log ( s -> avctx , AV_LOG_ERROR , "offset_len<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>invalid\\n" , offset_len ) ; return AVERROR_INVALIDDATA ; } av_freep ( & sh -> entry_point_offset ) ; av_freep ( & sh -> offset ) ; av_freep ( & sh -> size ) ; sh -> entry_point_offset = av_malloc_array ( sh -> num_entry_point_offsets , sizeof ( unsigned ) ) ; sh -> offset = av_malloc_array ( sh -> num_entry_point_offsets , sizeof ( int ) ) ; sh -> size = av_malloc_array ( sh -> num_entry_point_offsets , sizeof ( int ) ) ; if ( ! sh -> entry_point_offset || ! sh -> offset || ! sh -> size ) { sh -> num_entry_point_offsets = 0 ; av_log ( s -> avctx , AV_LOG_ERROR , "Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory\\n" ) ; return AVERROR ( ENOMEM ) ; } for ( i = 0 ; i < sh -> num_entry_point_offsets ; i ++ ) { unsigned val = get_bits_long ( gb , offset_len ) ; sh -> entry_point_offset [ i ] = val + 1 ; } if ( s -> threads_number > 1 && ( s -> ps . pps -> num_tile_rows > 1 || s -> ps . pps -> num_tile_columns > 1 ) ) { s -> enable_parallel_tiles = 0 ; s -> threads_number = 1 ; } else s -> enable_parallel_tiles = 0 ; } else s -> enable_parallel_tiles = 0 ; } if ( s -> ps . pps -> slice_header_extension_present_flag ) { unsigned int length = get_ue_golomb_long ( gb ) ; if ( length * 8LL > get_bits_left ( gb ) ) { av_log ( s -> avctx , AV_LOG_ERROR , "too<S2SV_blank>many<S2SV_blank>slice_header_extension_data_bytes\\n" ) ; return AVERROR_INVALIDDATA ; } for ( i = 0 ; i < length ; i ++ ) skip_bits ( gb , 8 ) ; } sh -> slice_qp = 26U + s -> ps . pps -> pic_init_qp_minus26 + sh -> slice_qp_delta ; if ( sh -> slice_qp > 51 || sh -> slice_qp < - s -> ps . sps -> qp_bd_offset ) { av_log ( s -> avctx , AV_LOG_ERROR , "The<S2SV_blank>slice_qp<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>outside<S2SV_blank>the<S2SV_blank>valid<S2SV_blank>range<S2SV_blank>" "[%d,<S2SV_blank>51].\\n" , sh -> slice_qp , - s -> ps . sps -> qp_bd_offset ) ; return AVERROR_INVALIDDATA ; } sh -> slice_ctb_addr_rs = sh -> slice_segment_addr ; if ( ! s -> sh . slice_ctb_addr_rs && s -> sh . dependent_slice_segment_flag ) { av_log ( s -> avctx , AV_LOG_ERROR , "Impossible<S2SV_blank>slice<S2SV_blank>segment.\\n" ) ; return AVERROR_INVALIDDATA ; } if ( get_bits_left ( gb ) < 0 ) { av_log ( s -> avctx , AV_LOG_ERROR , "Overread<S2SV_blank>slice<S2SV_blank>header<S2SV_blank>by<S2SV_blank>%d<S2SV_blank>bits\\n" , - get_bits_left ( gb ) ) ; return AVERROR_INVALIDDATA ; } s -> HEVClc -> first_qp_group = ! s -> sh . dependent_slice_segment_flag ; if ( ! s -> ps . pps -> cu_qp_delta_enabled_flag ) s -> HEVClc -> qp_y = s -> sh . slice_qp ; s -> slice_initialized = 1 ; s -> HEVClc -> tu . cu_qp_offset_cb = 0 ; s -> HEVClc -> tu . cu_qp_offset_cr = 0 ; return 0 ; }
CWE-125 <S2SV_StartBug> static void read_quant_matrix_ext ( MpegEncContext * s , GetBitContext * gb ) <S2SV_EndBug> { int i , j , v ; <S2SV_StartBug> if ( get_bits1 ( gb ) ) { <S2SV_EndBug> for ( i = 0 ; i < 64 ; i ++ ) { v = get_bits ( gb , 8 ) ; j = s -> idsp . idct_permutation [ ff_zigzag_direct [ i ] ] ; s -> intra_matrix [ j ] = v ; s -> chroma_intra_matrix [ j ] = v ; } } if ( get_bits1 ( gb ) ) { <S2SV_StartBug> for ( i = 0 ; i < 64 ; i ++ ) { <S2SV_EndBug> get_bits ( gb , 8 ) ; } } <S2SV_StartBug> if ( get_bits1 ( gb ) ) { <S2SV_EndBug> for ( i = 0 ; i < 64 ; i ++ ) { v = get_bits ( gb , 8 ) ; j = s -> idsp . idct_permutation [ ff_zigzag_direct [ i ] ] ; s -> chroma_intra_matrix [ j ] = v ; } } if ( get_bits1 ( gb ) ) { <S2SV_StartBug> for ( i = 0 ; i < 64 ; i ++ ) { <S2SV_EndBug> get_bits ( gb , 8 ) ; } } next_start_code_studio ( gb ) ; <S2SV_StartBug> } <S2SV_EndBug>
CWE-617 static int flv_write_packet ( AVFormatContext * s , AVPacket * pkt ) { AVIOContext * pb = s -> pb ; AVCodecParameters * par = s -> streams [ pkt -> stream_index ] -> codecpar ; FLVContext * flv = s -> priv_data ; FLVStreamContext * sc = s -> streams [ pkt -> stream_index ] -> priv_data ; unsigned ts ; int size = pkt -> size ; uint8_t * data = NULL ; int flags = - 1 , flags_size , ret ; <S2SV_StartBug> int64_t cur_offset = avio_tell ( pb ) ; <S2SV_EndBug> if ( par -> codec_id == AV_CODEC_ID_VP6F || par -> codec_id == AV_CODEC_ID_VP6A || par -> codec_id == AV_CODEC_ID_VP6 || par -> codec_id == AV_CODEC_ID_AAC ) flags_size = 2 ; else if ( par -> codec_id == AV_CODEC_ID_H264 || par -> codec_id == AV_CODEC_ID_MPEG4 ) flags_size = 5 ; else flags_size = 1 ; if ( par -> codec_id == AV_CODEC_ID_AAC || par -> codec_id == AV_CODEC_ID_H264 || par -> codec_id == AV_CODEC_ID_MPEG4 ) { int side_size = 0 ; uint8_t * side = av_packet_get_side_data ( pkt , AV_PKT_DATA_NEW_EXTRADATA , & side_size ) ; if ( side && side_size > 0 && ( side_size != par -> extradata_size || memcmp ( side , par -> extradata , side_size ) ) ) { av_free ( par -> extradata ) ; par -> extradata = av_mallocz ( side_size + AV_INPUT_BUFFER_PADDING_SIZE ) ; if ( ! par -> extradata ) { par -> extradata_size = 0 ; return AVERROR ( ENOMEM ) ; } memcpy ( par -> extradata , side , side_size ) ; par -> extradata_size = side_size ; flv_write_codec_header ( s , par , pkt -> dts ) ; } } if ( flv -> delay == AV_NOPTS_VALUE ) flv -> delay = - pkt -> dts ; if ( pkt -> dts < - flv -> delay ) { av_log ( s , AV_LOG_WARNING , "Packets<S2SV_blank>are<S2SV_blank>not<S2SV_blank>in<S2SV_blank>the<S2SV_blank>proper<S2SV_blank>order<S2SV_blank>with<S2SV_blank>respect<S2SV_blank>to<S2SV_blank>DTS\\n" ) ; return AVERROR ( EINVAL ) ; } ts = pkt -> dts ; if ( s -> event_flags & AVSTREAM_EVENT_FLAG_METADATA_UPDATED ) { write_metadata ( s , ts ) ; s -> event_flags &= ~ AVSTREAM_EVENT_FLAG_METADATA_UPDATED ; } avio_write_marker ( pb , av_rescale ( ts , AV_TIME_BASE , 1000 ) , pkt -> flags & AV_PKT_FLAG_KEY && ( flv -> video_par ? par -> codec_type == AVMEDIA_TYPE_VIDEO : 1 ) ? AVIO_DATA_MARKER_SYNC_POINT : AVIO_DATA_MARKER_BOUNDARY_POINT ) ; switch ( par -> codec_type ) { case AVMEDIA_TYPE_VIDEO : avio_w8 ( pb , FLV_TAG_TYPE_VIDEO ) ; flags = ff_codec_get_tag ( flv_video_codec_ids , par -> codec_id ) ; flags |= pkt -> flags & AV_PKT_FLAG_KEY ? FLV_FRAME_KEY : FLV_FRAME_INTER ; break ; case AVMEDIA_TYPE_AUDIO : flags = get_audio_flags ( s , par ) ; av_assert0 ( size ) ; avio_w8 ( pb , FLV_TAG_TYPE_AUDIO ) ; break ; case AVMEDIA_TYPE_SUBTITLE : case AVMEDIA_TYPE_DATA : avio_w8 ( pb , FLV_TAG_TYPE_META ) ; break ; default : return AVERROR ( EINVAL ) ; } if ( par -> codec_id == AV_CODEC_ID_H264 || par -> codec_id == AV_CODEC_ID_MPEG4 ) { if ( par -> extradata_size > 0 && * ( uint8_t * ) par -> extradata != 1 ) if ( ( ret = ff_avc_parse_nal_units_buf ( pkt -> data , & data , & size ) ) < 0 ) return ret ; } else if ( par -> codec_id == AV_CODEC_ID_AAC && pkt -> size > 2 && ( AV_RB16 ( pkt -> data ) & 0xfff0 ) == 0xfff0 ) { if ( ! s -> streams [ pkt -> stream_index ] -> nb_frames ) { av_log ( s , AV_LOG_ERROR , "Malformed<S2SV_blank>AAC<S2SV_blank>bitstream<S2SV_blank>detected:<S2SV_blank>" "use<S2SV_blank>the<S2SV_blank>audio<S2SV_blank>bitstream<S2SV_blank>filter<S2SV_blank>\'aac_adtstoasc\'<S2SV_blank>to<S2SV_blank>fix<S2SV_blank>it<S2SV_blank>" "(\'-bsf:a<S2SV_blank>aac_adtstoasc\'<S2SV_blank>option<S2SV_blank>with<S2SV_blank>ffmpeg)\\n" ) ; return AVERROR_INVALIDDATA ; } av_log ( s , AV_LOG_WARNING , "aac<S2SV_blank>bitstream<S2SV_blank>error\\n" ) ; } if ( par -> codec_id == AV_CODEC_ID_SPEEX && ts - sc -> last_ts > 160 ) av_log ( s , AV_LOG_WARNING , "Warning:<S2SV_blank>Speex<S2SV_blank>stream<S2SV_blank>has<S2SV_blank>more<S2SV_blank>than<S2SV_blank>" "8<S2SV_blank>frames<S2SV_blank>per<S2SV_blank>packet.<S2SV_blank>Adobe<S2SV_blank>Flash<S2SV_blank>" "Player<S2SV_blank>cannot<S2SV_blank>handle<S2SV_blank>this!\\n" ) ; if ( sc -> last_ts < ts ) sc -> last_ts = ts ; if ( size + flags_size >= 1 << 24 ) { av_log ( s , AV_LOG_ERROR , "Too<S2SV_blank>large<S2SV_blank>packet<S2SV_blank>with<S2SV_blank>size<S2SV_blank>%u<S2SV_blank>>=<S2SV_blank>%u\\n" , size + flags_size , 1 << 24 ) ; return AVERROR ( EINVAL ) ; } avio_wb24 ( pb , size + flags_size ) ; put_timestamp ( pb , ts ) ; avio_wb24 ( pb , flv -> reserved ) ; if ( par -> codec_type == AVMEDIA_TYPE_DATA || par -> codec_type == AVMEDIA_TYPE_SUBTITLE ) { int data_size ; int64_t metadata_size_pos = avio_tell ( pb ) ; if ( par -> codec_id == AV_CODEC_ID_TEXT ) { avio_w8 ( pb , AMF_DATA_TYPE_STRING ) ; put_amf_string ( pb , "onTextData" ) ; avio_w8 ( pb , AMF_DATA_TYPE_MIXEDARRAY ) ; avio_wb32 ( pb , 2 ) ; put_amf_string ( pb , "type" ) ; avio_w8 ( pb , AMF_DATA_TYPE_STRING ) ; put_amf_string ( pb , "Text" ) ; put_amf_string ( pb , "text" ) ; avio_w8 ( pb , AMF_DATA_TYPE_STRING ) ; put_amf_string ( pb , pkt -> data ) ; put_amf_string ( pb , "" ) ; avio_w8 ( pb , AMF_END_OF_OBJECT ) ; } else { avio_write ( pb , data ? data : pkt -> data , size ) ; } data_size = avio_tell ( pb ) - metadata_size_pos ; avio_seek ( pb , metadata_size_pos - 10 , SEEK_SET ) ; avio_wb24 ( pb , data_size ) ; avio_seek ( pb , data_size + 10 - 3 , SEEK_CUR ) ; avio_wb32 ( pb , data_size + 11 ) ; } else { av_assert1 ( flags >= 0 ) ; avio_w8 ( pb , flags ) ; if ( par -> codec_id == AV_CODEC_ID_VP6 ) avio_w8 ( pb , 0 ) ; if ( par -> codec_id == AV_CODEC_ID_VP6F || par -> codec_id == AV_CODEC_ID_VP6A ) { if ( par -> extradata_size ) avio_w8 ( pb , par -> extradata [ 0 ] ) ; else avio_w8 ( pb , ( ( FFALIGN ( par -> width , 16 ) - par -> width ) << 4 ) | ( FFALIGN ( par -> height , 16 ) - par -> height ) ) ; } else if ( par -> codec_id == AV_CODEC_ID_AAC ) avio_w8 ( pb , 1 ) ; else if ( par -> codec_id == AV_CODEC_ID_H264 || par -> codec_id == AV_CODEC_ID_MPEG4 ) { avio_w8 ( pb , 1 ) ; avio_wb24 ( pb , pkt -> pts - pkt -> dts ) ; } avio_write ( pb , data ? data : pkt -> data , size ) ; avio_wb32 ( pb , size + flags_size + 11 ) ; flv -> duration = FFMAX ( flv -> duration , pkt -> pts + flv -> delay + pkt -> duration ) ; } if ( flv -> flags & FLV_ADD_KEYFRAME_INDEX ) { switch ( par -> codec_type ) { case AVMEDIA_TYPE_VIDEO : flv -> videosize += ( avio_tell ( pb ) - cur_offset ) ; flv -> lasttimestamp = flv -> acurframeindex / flv -> framerate ; if ( pkt -> flags & AV_PKT_FLAG_KEY ) { double ts = flv -> acurframeindex / flv -> framerate ; int64_t pos = cur_offset ; flv -> lastkeyframetimestamp = flv -> acurframeindex / flv -> framerate ; flv -> lastkeyframelocation = pos ; flv_append_keyframe_info ( s , flv , ts , pos ) ; } flv -> acurframeindex ++ ; break ; case AVMEDIA_TYPE_AUDIO : flv -> audiosize += ( avio_tell ( pb ) - cur_offset ) ; break ; default : av_log ( s , AV_LOG_WARNING , "par->codec_type<S2SV_blank>is<S2SV_blank>type<S2SV_blank>=<S2SV_blank>[%d]\\n" , par -> codec_type ) ; break ; } } av_free ( data ) ; return pb -> error ; }
CWE-835 static int read_part_of_packet ( AVFormatContext * s , int64_t * pts , int * len , int * strid , int read_packet ) { AVIOContext * pb = s -> pb ; PVAContext * pvactx = s -> priv_data ; int syncword , streamid , reserved , flags , length , pts_flag ; int64_t pva_pts = AV_NOPTS_VALUE , startpos ; int ret ; recover : startpos = avio_tell ( pb ) ; syncword = avio_rb16 ( pb ) ; streamid = avio_r8 ( pb ) ; avio_r8 ( pb ) ; reserved = avio_r8 ( pb ) ; flags = avio_r8 ( pb ) ; length = avio_rb16 ( pb ) ; pts_flag = flags & 0x10 ; if ( syncword != PVA_MAGIC ) { pva_log ( s , AV_LOG_ERROR , "invalid<S2SV_blank>syncword\\n" ) ; return AVERROR ( EIO ) ; } if ( streamid != PVA_VIDEO_PAYLOAD && streamid != PVA_AUDIO_PAYLOAD ) { pva_log ( s , AV_LOG_ERROR , "invalid<S2SV_blank>streamid\\n" ) ; return AVERROR ( EIO ) ; } if ( reserved != 0x55 ) { pva_log ( s , AV_LOG_WARNING , "expected<S2SV_blank>reserved<S2SV_blank>byte<S2SV_blank>to<S2SV_blank>be<S2SV_blank>0x55\\n" ) ; } if ( length > PVA_MAX_PAYLOAD_LENGTH ) { pva_log ( s , AV_LOG_ERROR , "invalid<S2SV_blank>payload<S2SV_blank>length<S2SV_blank>%u\\n" , length ) ; return AVERROR ( EIO ) ; } if ( streamid == PVA_VIDEO_PAYLOAD && pts_flag ) { pva_pts = avio_rb32 ( pb ) ; length -= 4 ; } else if ( streamid == PVA_AUDIO_PAYLOAD ) { if ( ! pvactx -> continue_pes ) { int pes_signal , pes_header_data_length , pes_packet_length , pes_flags ; unsigned char pes_header_data [ 256 ] ; pes_signal = avio_rb24 ( pb ) ; avio_r8 ( pb ) ; pes_packet_length = avio_rb16 ( pb ) ; pes_flags = avio_rb16 ( pb ) ; pes_header_data_length = avio_r8 ( pb ) ; <S2SV_StartBug> if ( pes_signal != 1 || pes_header_data_length == 0 ) { <S2SV_EndBug> pva_log ( s , AV_LOG_WARNING , "expected<S2SV_blank>non<S2SV_blank>empty<S2SV_blank>signaled<S2SV_blank>PES<S2SV_blank>packet,<S2SV_blank>" "trying<S2SV_blank>to<S2SV_blank>recover\\n" ) ; avio_skip ( pb , length - 9 ) ; if ( ! read_packet ) return AVERROR ( EIO ) ; goto recover ; } ret = avio_read ( pb , pes_header_data , pes_header_data_length ) ; if ( ret != pes_header_data_length ) return ret < 0 ? ret : AVERROR_INVALIDDATA ; length -= 9 + pes_header_data_length ; pes_packet_length -= 3 + pes_header_data_length ; pvactx -> continue_pes = pes_packet_length ; if ( pes_flags & 0x80 && ( pes_header_data [ 0 ] & 0xf0 ) == 0x20 ) { if ( pes_header_data_length < 5 ) { pva_log ( s , AV_LOG_ERROR , "header<S2SV_blank>too<S2SV_blank>short\\n" ) ; avio_skip ( pb , length ) ; return AVERROR_INVALIDDATA ; } pva_pts = ff_parse_pes_pts ( pes_header_data ) ; } } pvactx -> continue_pes -= length ; if ( pvactx -> continue_pes < 0 ) { pva_log ( s , AV_LOG_WARNING , "audio<S2SV_blank>data<S2SV_blank>corruption\\n" ) ; pvactx -> continue_pes = 0 ; } } if ( pva_pts != AV_NOPTS_VALUE ) av_add_index_entry ( s -> streams [ streamid - 1 ] , startpos , pva_pts , 0 , 0 , AVINDEX_KEYFRAME ) ; * pts = pva_pts ; * len = length ; * strid = streamid ; return 0 ; }
CWE-416 static int rm_read_multi ( AVFormatContext * s , AVIOContext * pb , AVStream * st , char * mime ) { int number_of_streams = avio_rb16 ( pb ) ; int number_of_mdpr ; int i , ret ; unsigned size2 ; for ( i = 0 ; i < number_of_streams ; i ++ ) avio_rb16 ( pb ) ; number_of_mdpr = avio_rb16 ( pb ) ; if ( number_of_mdpr != 1 ) { avpriv_request_sample ( s , "MLTI<S2SV_blank>with<S2SV_blank>multiple<S2SV_blank>(%d)<S2SV_blank>MDPR" , number_of_mdpr ) ; } for ( i = 0 ; i < number_of_mdpr ; i ++ ) { AVStream * st2 ; if ( i > 0 ) { st2 = avformat_new_stream ( s , NULL ) ; if ( ! st2 ) { ret = AVERROR ( ENOMEM ) ; return ret ; } st2 -> id = st -> id + ( i << 16 ) ; st2 -> codecpar -> bit_rate = st -> codecpar -> bit_rate ; st2 -> start_time = st -> start_time ; st2 -> duration = st -> duration ; st2 -> codecpar -> codec_type = AVMEDIA_TYPE_DATA ; st2 -> priv_data = ff_rm_alloc_rmstream ( ) ; if ( ! st2 -> priv_data ) return AVERROR ( ENOMEM ) ; } else st2 = st ; size2 = avio_rb32 ( pb ) ; ret = ff_rm_read_mdpr_codecdata ( s , s -> pb , st2 , st2 -> priv_data , <S2SV_StartBug> size2 , mime ) ; <S2SV_EndBug> if ( ret < 0 ) return ret ; } return 0 ; }
CWE-476 av_cold void ff_idctdsp_init ( IDCTDSPContext * c , AVCodecContext * avctx ) { const unsigned high_bit_depth = avctx -> bits_per_raw_sample > 8 ; if ( avctx -> lowres == 1 ) { c -> idct_put = ff_jref_idct4_put ; c -> idct_add = ff_jref_idct4_add ; c -> idct = ff_j_rev_dct4 ; c -> perm_type = FF_IDCT_PERM_NONE ; } else if ( avctx -> lowres == 2 ) { c -> idct_put = ff_jref_idct2_put ; c -> idct_add = ff_jref_idct2_add ; c -> idct = ff_j_rev_dct2 ; c -> perm_type = FF_IDCT_PERM_NONE ; } else if ( avctx -> lowres == 3 ) { c -> idct_put = ff_jref_idct1_put ; c -> idct_add = ff_jref_idct1_add ; c -> idct = ff_j_rev_dct1 ; c -> perm_type = FF_IDCT_PERM_NONE ; } else { if ( avctx -> bits_per_raw_sample == 10 || avctx -> bits_per_raw_sample == 9 ) { <S2SV_StartBug> if ( avctx -> codec_id == AV_CODEC_ID_MPEG4 && avctx -> profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO ) <S2SV_EndBug> c -> idct_put = ff_simple_idct_put_int32_10bit ; else { c -> idct_put = ff_simple_idct_put_int16_10bit ; c -> idct_add = ff_simple_idct_add_int16_10bit ; c -> idct = ff_simple_idct_int16_10bit ; } c -> perm_type = FF_IDCT_PERM_NONE ; } else if ( avctx -> bits_per_raw_sample == 12 ) { c -> idct_put = ff_simple_idct_put_int16_12bit ; c -> idct_add = ff_simple_idct_add_int16_12bit ; c -> idct = ff_simple_idct_int16_12bit ; c -> perm_type = FF_IDCT_PERM_NONE ; } else { if ( avctx -> idct_algo == FF_IDCT_INT ) { c -> idct_put = ff_jref_idct_put ; c -> idct_add = ff_jref_idct_add ; c -> idct = ff_j_rev_dct ; c -> perm_type = FF_IDCT_PERM_LIBMPEG2 ; # if CONFIG_FAANIDCT } else if ( avctx -> idct_algo == FF_IDCT_FAAN ) { c -> idct_put = ff_faanidct_put ; c -> idct_add = ff_faanidct_add ; c -> idct = ff_faanidct ; c -> perm_type = FF_IDCT_PERM_NONE ; # endif } else { c -> idct_put = ff_simple_idct_put_int16_8bit ; c -> idct_add = ff_simple_idct_add_int16_8bit ; c -> idct = ff_simple_idct_int16_8bit ; c -> perm_type = FF_IDCT_PERM_NONE ; } } } c -> put_pixels_clamped = ff_put_pixels_clamped_c ; c -> put_signed_pixels_clamped = put_signed_pixels_clamped_c ; c -> add_pixels_clamped = ff_add_pixels_clamped_c ; if ( CONFIG_MPEG4_DECODER && avctx -> idct_algo == FF_IDCT_XVID ) ff_xvid_idct_init ( c , avctx ) ; if ( ARCH_AARCH64 ) ff_idctdsp_init_aarch64 ( c , avctx , high_bit_depth ) ; if ( ARCH_ALPHA ) ff_idctdsp_init_alpha ( c , avctx , high_bit_depth ) ; if ( ARCH_ARM ) ff_idctdsp_init_arm ( c , avctx , high_bit_depth ) ; if ( ARCH_PPC ) ff_idctdsp_init_ppc ( c , avctx , high_bit_depth ) ; if ( ARCH_X86 ) ff_idctdsp_init_x86 ( c , avctx , high_bit_depth ) ; if ( ARCH_MIPS ) ff_idctdsp_init_mips ( c , avctx , high_bit_depth ) ; ff_init_scantable_permutation ( c -> idct_permutation , c -> perm_type ) ; }
CWE-476 av_cold void ff_mpv_idct_init ( MpegEncContext * s ) <S2SV_StartBug> { <S2SV_EndBug> ff_idctdsp_init ( & s -> idsp , s -> avctx ) ; if ( s -> alternate_scan ) { ff_init_scantable ( s -> idsp . idct_permutation , & s -> inter_scantable , ff_alternate_vertical_scan ) ; ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_scantable , ff_alternate_vertical_scan ) ; } else { ff_init_scantable ( s -> idsp . idct_permutation , & s -> inter_scantable , ff_zigzag_direct ) ; ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_scantable , ff_zigzag_direct ) ; } ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_h_scantable , ff_alternate_horizontal_scan ) ; ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_v_scantable , ff_alternate_vertical_scan ) ; }
CWE-125 static int mxf_parse_structural_metadata ( MXFContext * mxf ) { MXFPackage * material_package = NULL ; int i , j , k , ret ; av_log ( mxf -> fc , AV_LOG_TRACE , "metadata<S2SV_blank>sets<S2SV_blank>count<S2SV_blank>%d\\n" , mxf -> metadata_sets_count ) ; for ( i = 0 ; i < mxf -> packages_count ; i ++ ) { material_package = mxf_resolve_strong_ref ( mxf , & mxf -> packages_refs [ i ] , MaterialPackage ) ; if ( material_package ) break ; } if ( ! material_package ) { av_log ( mxf -> fc , AV_LOG_ERROR , "no<S2SV_blank>material<S2SV_blank>package<S2SV_blank>found\\n" ) ; return AVERROR_INVALIDDATA ; } mxf_add_umid_metadata ( & mxf -> fc -> metadata , "material_package_umid" , material_package ) ; if ( material_package -> name && material_package -> name [ 0 ] ) av_dict_set ( & mxf -> fc -> metadata , "material_package_name" , material_package -> name , 0 ) ; mxf_parse_package_comments ( mxf , & mxf -> fc -> metadata , material_package ) ; for ( i = 0 ; i < material_package -> tracks_count ; i ++ ) { MXFPackage * source_package = NULL ; MXFTrack * material_track = NULL ; MXFTrack * source_track = NULL ; MXFTrack * temp_track = NULL ; MXFDescriptor * descriptor = NULL ; MXFStructuralComponent * component = NULL ; MXFTimecodeComponent * mxf_tc = NULL ; UID * essence_container_ul = NULL ; const MXFCodecUL * codec_ul = NULL ; const MXFCodecUL * container_ul = NULL ; const MXFCodecUL * pix_fmt_ul = NULL ; AVStream * st ; AVTimecode tc ; int flags ; if ( ! ( material_track = mxf_resolve_strong_ref ( mxf , & material_package -> tracks_refs [ i ] , Track ) ) ) { av_log ( mxf -> fc , AV_LOG_ERROR , "could<S2SV_blank>not<S2SV_blank>resolve<S2SV_blank>material<S2SV_blank>track<S2SV_blank>strong<S2SV_blank>ref\\n" ) ; continue ; } if ( ( component = mxf_resolve_strong_ref ( mxf , & material_track -> sequence_ref , TimecodeComponent ) ) ) { mxf_tc = ( MXFTimecodeComponent * ) component ; flags = mxf_tc -> drop_frame == 1 ? AV_TIMECODE_FLAG_DROPFRAME : 0 ; if ( av_timecode_init ( & tc , mxf_tc -> rate , flags , mxf_tc -> start_frame , mxf -> fc ) == 0 ) { mxf_add_timecode_metadata ( & mxf -> fc -> metadata , "timecode" , & tc ) ; } } if ( ! ( material_track -> sequence = mxf_resolve_strong_ref ( mxf , & material_track -> sequence_ref , Sequence ) ) ) { av_log ( mxf -> fc , AV_LOG_ERROR , "could<S2SV_blank>not<S2SV_blank>resolve<S2SV_blank>material<S2SV_blank>track<S2SV_blank>sequence<S2SV_blank>strong<S2SV_blank>ref\\n" ) ; continue ; } for ( j = 0 ; j < material_track -> sequence -> structural_components_count ; j ++ ) { component = mxf_resolve_strong_ref ( mxf , & material_track -> sequence -> structural_components_refs [ j ] , TimecodeComponent ) ; if ( ! component ) continue ; mxf_tc = ( MXFTimecodeComponent * ) component ; flags = mxf_tc -> drop_frame == 1 ? AV_TIMECODE_FLAG_DROPFRAME : 0 ; if ( av_timecode_init ( & tc , mxf_tc -> rate , flags , mxf_tc -> start_frame , mxf -> fc ) == 0 ) { mxf_add_timecode_metadata ( & mxf -> fc -> metadata , "timecode" , & tc ) ; break ; } } if ( material_track -> sequence -> structural_components_count > 1 ) av_log ( mxf -> fc , AV_LOG_WARNING , "material<S2SV_blank>track<S2SV_blank>%d:<S2SV_blank>has<S2SV_blank>%d<S2SV_blank>components\\n" , material_track -> track_id , material_track -> sequence -> structural_components_count ) ; for ( j = 0 ; j < material_track -> sequence -> structural_components_count ; j ++ ) { component = mxf_resolve_sourceclip ( mxf , & material_track -> sequence -> structural_components_refs [ j ] ) ; if ( ! component ) continue ; source_package = mxf_resolve_source_package ( mxf , component -> source_package_ul , component -> source_package_uid ) ; if ( ! source_package ) { av_log ( mxf -> fc , AV_LOG_TRACE , "material<S2SV_blank>track<S2SV_blank>%d:<S2SV_blank>no<S2SV_blank>corresponding<S2SV_blank>source<S2SV_blank>package<S2SV_blank>found\\n" , material_track -> track_id ) ; continue ; } for ( k = 0 ; k < source_package -> tracks_count ; k ++ ) { if ( ! ( temp_track = mxf_resolve_strong_ref ( mxf , & source_package -> tracks_refs [ k ] , Track ) ) ) { av_log ( mxf -> fc , AV_LOG_ERROR , "could<S2SV_blank>not<S2SV_blank>resolve<S2SV_blank>source<S2SV_blank>track<S2SV_blank>strong<S2SV_blank>ref\\n" ) ; ret = AVERROR_INVALIDDATA ; goto fail_and_free ; } if ( temp_track -> track_id == component -> source_track_id ) { source_track = temp_track ; break ; } } if ( ! source_track ) { av_log ( mxf -> fc , AV_LOG_ERROR , "material<S2SV_blank>track<S2SV_blank>%d:<S2SV_blank>no<S2SV_blank>corresponding<S2SV_blank>source<S2SV_blank>track<S2SV_blank>found\\n" , material_track -> track_id ) ; break ; } for ( k = 0 ; k < mxf -> essence_container_data_count ; k ++ ) { MXFEssenceContainerData * essence_data ; if ( ! ( essence_data = mxf_resolve_strong_ref ( mxf , & mxf -> essence_container_data_refs [ k ] , EssenceContainerData ) ) ) { <S2SV_StartBug> av_log ( mxf , AV_LOG_TRACE , "could<S2SV_blank>not<S2SV_blank>resolve<S2SV_blank>essence<S2SV_blank>container<S2SV_blank>data<S2SV_blank>strong<S2SV_blank>ref\\n" ) ; <S2SV_EndBug> continue ; } if ( ! memcmp ( component -> source_package_ul , essence_data -> package_ul , sizeof ( UID ) ) && ! memcmp ( component -> source_package_uid , essence_data -> package_uid , sizeof ( UID ) ) ) { source_track -> body_sid = essence_data -> body_sid ; source_track -> index_sid = essence_data -> index_sid ; break ; } } if ( source_track && component ) break ; } if ( ! source_track || ! component || ! source_package ) { if ( ( ret = mxf_add_metadata_stream ( mxf , material_track ) ) ) goto fail_and_free ; continue ; } if ( ! ( source_track -> sequence = mxf_resolve_strong_ref ( mxf , & source_track -> sequence_ref , Sequence ) ) ) { av_log ( mxf -> fc , AV_LOG_ERROR , "could<S2SV_blank>not<S2SV_blank>resolve<S2SV_blank>source<S2SV_blank>track<S2SV_blank>sequence<S2SV_blank>strong<S2SV_blank>ref\\n" ) ; ret = AVERROR_INVALIDDATA ; goto fail_and_free ; } if ( memcmp ( material_track -> sequence -> data_definition_ul , source_track -> sequence -> data_definition_ul , 16 ) ) { av_log ( mxf -> fc , AV_LOG_ERROR , "material<S2SV_blank>track<S2SV_blank>%d:<S2SV_blank>DataDefinition<S2SV_blank>mismatch\\n" , material_track -> track_id ) ; continue ; } st = avformat_new_stream ( mxf -> fc , NULL ) ; if ( ! st ) { av_log ( mxf -> fc , AV_LOG_ERROR , "could<S2SV_blank>not<S2SV_blank>allocate<S2SV_blank>stream\\n" ) ; ret = AVERROR ( ENOMEM ) ; goto fail_and_free ; } st -> id = material_track -> track_id ; st -> priv_data = source_track ; source_package -> descriptor = mxf_resolve_strong_ref ( mxf , & source_package -> descriptor_ref , AnyType ) ; descriptor = mxf_resolve_multidescriptor ( mxf , source_package -> descriptor , source_track -> track_id ) ; if ( descriptor && descriptor -> duration != AV_NOPTS_VALUE ) source_track -> original_duration = st -> duration = FFMIN ( descriptor -> duration , component -> duration ) ; else source_track -> original_duration = st -> duration = component -> duration ; if ( st -> duration == - 1 ) st -> duration = AV_NOPTS_VALUE ; st -> start_time = component -> start_position ; if ( material_track -> edit_rate . num <= 0 || material_track -> edit_rate . den <= 0 ) { av_log ( mxf -> fc , AV_LOG_WARNING , "Invalid<S2SV_blank>edit<S2SV_blank>rate<S2SV_blank>(%d/%d)<S2SV_blank>found<S2SV_blank>on<S2SV_blank>stream<S2SV_blank>#%d,<S2SV_blank>" "defaulting<S2SV_blank>to<S2SV_blank>25/1\\n" , material_track -> edit_rate . num , material_track -> edit_rate . den , st -> index ) ; material_track -> edit_rate = ( AVRational ) { 25 , 1 } ; } avpriv_set_pts_info ( st , 64 , material_track -> edit_rate . den , material_track -> edit_rate . num ) ; source_track -> edit_rate = material_track -> edit_rate ; PRINT_KEY ( mxf -> fc , "data<S2SV_blank>definition<S2SV_blank><S2SV_blank><S2SV_blank>ul" , source_track -> sequence -> data_definition_ul ) ; codec_ul = mxf_get_codec_ul ( ff_mxf_data_definition_uls , & source_track -> sequence -> data_definition_ul ) ; st -> codecpar -> codec_type = codec_ul -> id ; if ( ! descriptor ) { av_log ( mxf -> fc , AV_LOG_INFO , "source<S2SV_blank>track<S2SV_blank>%d:<S2SV_blank>stream<S2SV_blank>%d,<S2SV_blank>no<S2SV_blank>descriptor<S2SV_blank>found\\n" , source_track -> track_id , st -> index ) ; continue ; } PRINT_KEY ( mxf -> fc , "essence<S2SV_blank>codec<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>ul" , descriptor -> essence_codec_ul ) ; PRINT_KEY ( mxf -> fc , "essence<S2SV_blank>container<S2SV_blank>ul" , descriptor -> essence_container_ul ) ; essence_container_ul = & descriptor -> essence_container_ul ; source_track -> wrapping = ( mxf -> op == OPAtom ) ? ClipWrapped : mxf_get_wrapping_kind ( essence_container_ul ) ; if ( source_track -> wrapping == UnknownWrapped ) av_log ( mxf -> fc , AV_LOG_INFO , "wrapping<S2SV_blank>of<S2SV_blank>stream<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>unknown\\n" , st -> index ) ; if ( IS_KLV_KEY ( essence_container_ul , mxf_encrypted_essence_container ) ) { av_log ( mxf -> fc , AV_LOG_INFO , "broken<S2SV_blank>encrypted<S2SV_blank>mxf<S2SV_blank>file\\n" ) ; for ( k = 0 ; k < mxf -> metadata_sets_count ; k ++ ) { MXFMetadataSet * metadata = mxf -> metadata_sets [ k ] ; if ( metadata -> type == CryptoContext ) { essence_container_ul = & ( ( MXFCryptoContext * ) metadata ) -> source_container_ul ; break ; } } } codec_ul = mxf_get_codec_ul ( ff_mxf_codec_uls , & descriptor -> essence_codec_ul ) ; st -> codecpar -> codec_id = ( enum AVCodecID ) codec_ul -> id ; if ( st -> codecpar -> codec_id == AV_CODEC_ID_NONE ) { codec_ul = mxf_get_codec_ul ( ff_mxf_codec_uls , & descriptor -> codec_ul ) ; st -> codecpar -> codec_id = ( enum AVCodecID ) codec_ul -> id ; } av_log ( mxf -> fc , AV_LOG_VERBOSE , "%s:<S2SV_blank>Universal<S2SV_blank>Label:<S2SV_blank>" , avcodec_get_name ( st -> codecpar -> codec_id ) ) ; for ( k = 0 ; k < 16 ; k ++ ) { av_log ( mxf -> fc , AV_LOG_VERBOSE , "%.2x" , descriptor -> essence_codec_ul [ k ] ) ; if ( ! ( k + 1 & 19 ) || k == 5 ) av_log ( mxf -> fc , AV_LOG_VERBOSE , "." ) ; } av_log ( mxf -> fc , AV_LOG_VERBOSE , "\\n" ) ; mxf_add_umid_metadata ( & st -> metadata , "file_package_umid" , source_package ) ; if ( source_package -> name && source_package -> name [ 0 ] ) av_dict_set ( & st -> metadata , "file_package_name" , source_package -> name , 0 ) ; if ( material_track -> name && material_track -> name [ 0 ] ) av_dict_set ( & st -> metadata , "track_name" , material_track -> name , 0 ) ; mxf_parse_physical_source_package ( mxf , source_track , st ) ; if ( st -> codecpar -> codec_type == AVMEDIA_TYPE_VIDEO ) { source_track -> intra_only = mxf_is_intra_only ( descriptor ) ; container_ul = mxf_get_codec_ul ( mxf_picture_essence_container_uls , essence_container_ul ) ; if ( st -> codecpar -> codec_id == AV_CODEC_ID_NONE ) st -> codecpar -> codec_id = container_ul -> id ; st -> codecpar -> width = descriptor -> width ; st -> codecpar -> height = descriptor -> height ; switch ( descriptor -> frame_layout ) { case FullFrame : st -> codecpar -> field_order = AV_FIELD_PROGRESSIVE ; break ; case OneField : av_log ( mxf -> fc , AV_LOG_INFO , "OneField<S2SV_blank>frame<S2SV_blank>layout<S2SV_blank>isn\'t<S2SV_blank>currently<S2SV_blank>supported\\n" ) ; break ; case MixedFields : break ; case SegmentedFrame : st -> codecpar -> field_order = AV_FIELD_PROGRESSIVE ; case SeparateFields : av_log ( mxf -> fc , AV_LOG_DEBUG , "video_line_map:<S2SV_blank>(%d,<S2SV_blank>%d),<S2SV_blank>field_dominance:<S2SV_blank>%d\\n" , descriptor -> video_line_map [ 0 ] , descriptor -> video_line_map [ 1 ] , descriptor -> field_dominance ) ; if ( ( descriptor -> video_line_map [ 0 ] > 0 ) && ( descriptor -> video_line_map [ 1 ] > 0 ) ) { if ( ( descriptor -> video_line_map [ 0 ] + descriptor -> video_line_map [ 1 ] ) % 2 ) { switch ( descriptor -> field_dominance ) { case MXF_FIELD_DOMINANCE_DEFAULT : case MXF_FIELD_DOMINANCE_FF : st -> codecpar -> field_order = AV_FIELD_TT ; break ; case MXF_FIELD_DOMINANCE_FL : st -> codecpar -> field_order = AV_FIELD_TB ; break ; default : avpriv_request_sample ( mxf -> fc , "Field<S2SV_blank>dominance<S2SV_blank>%d<S2SV_blank>support" , descriptor -> field_dominance ) ; } } else { switch ( descriptor -> field_dominance ) { case MXF_FIELD_DOMINANCE_DEFAULT : case MXF_FIELD_DOMINANCE_FF : st -> codecpar -> field_order = AV_FIELD_BB ; break ; case MXF_FIELD_DOMINANCE_FL : st -> codecpar -> field_order = AV_FIELD_BT ; break ; default : avpriv_request_sample ( mxf -> fc , "Field<S2SV_blank>dominance<S2SV_blank>%d<S2SV_blank>support" , descriptor -> field_dominance ) ; } } } st -> codecpar -> height *= 2 ; break ; default : av_log ( mxf -> fc , AV_LOG_INFO , "Unknown<S2SV_blank>frame<S2SV_blank>layout<S2SV_blank>type:<S2SV_blank>%d\\n" , descriptor -> frame_layout ) ; } if ( st -> codecpar -> codec_id == AV_CODEC_ID_RAWVIDEO ) { st -> codecpar -> format = descriptor -> pix_fmt ; if ( st -> codecpar -> format == AV_PIX_FMT_NONE ) { pix_fmt_ul = mxf_get_codec_ul ( ff_mxf_pixel_format_uls , & descriptor -> essence_codec_ul ) ; st -> codecpar -> format = ( enum AVPixelFormat ) pix_fmt_ul -> id ; if ( st -> codecpar -> format == AV_PIX_FMT_NONE ) { st -> codecpar -> codec_tag = mxf_get_codec_ul ( ff_mxf_codec_tag_uls , & descriptor -> essence_codec_ul ) -> id ; if ( ! st -> codecpar -> codec_tag ) { if ( descriptor -> horiz_subsampling == 2 && descriptor -> vert_subsampling == 1 && descriptor -> component_depth == 8 ) { st -> codecpar -> format = AV_PIX_FMT_UYVY422 ; } } } } } st -> need_parsing = AVSTREAM_PARSE_HEADERS ; if ( material_track -> sequence -> origin ) { av_dict_set_int ( & st -> metadata , "material_track_origin" , material_track -> sequence -> origin , 0 ) ; } if ( source_track -> sequence -> origin ) { av_dict_set_int ( & st -> metadata , "source_track_origin" , source_track -> sequence -> origin , 0 ) ; } if ( descriptor -> aspect_ratio . num && descriptor -> aspect_ratio . den ) st -> display_aspect_ratio = descriptor -> aspect_ratio ; } else if ( st -> codecpar -> codec_type == AVMEDIA_TYPE_AUDIO ) { container_ul = mxf_get_codec_ul ( mxf_sound_essence_container_uls , essence_container_ul ) ; if ( st -> codecpar -> codec_id == AV_CODEC_ID_NONE || ( st -> codecpar -> codec_id == AV_CODEC_ID_PCM_ALAW && ( enum AVCodecID ) container_ul -> id != AV_CODEC_ID_NONE ) ) st -> codecpar -> codec_id = ( enum AVCodecID ) container_ul -> id ; st -> codecpar -> channels = descriptor -> channels ; st -> codecpar -> bits_per_coded_sample = descriptor -> bits_per_sample ; if ( descriptor -> sample_rate . den > 0 ) { st -> codecpar -> sample_rate = descriptor -> sample_rate . num / descriptor -> sample_rate . den ; avpriv_set_pts_info ( st , 64 , descriptor -> sample_rate . den , descriptor -> sample_rate . num ) ; } else { av_log ( mxf -> fc , AV_LOG_WARNING , "invalid<S2SV_blank>sample<S2SV_blank>rate<S2SV_blank>(%d/%d)<S2SV_blank>" "found<S2SV_blank>for<S2SV_blank>stream<S2SV_blank>#%d,<S2SV_blank>time<S2SV_blank>base<S2SV_blank>forced<S2SV_blank>to<S2SV_blank>1/48000\\n" , descriptor -> sample_rate . num , descriptor -> sample_rate . den , st -> index ) ; avpriv_set_pts_info ( st , 64 , 1 , 48000 ) ; } if ( st -> duration != AV_NOPTS_VALUE ) st -> duration = av_rescale_q ( st -> duration , av_inv_q ( material_track -> edit_rate ) , st -> time_base ) ; if ( st -> codecpar -> codec_id == AV_CODEC_ID_PCM_S16LE ) { if ( descriptor -> bits_per_sample > 16 && descriptor -> bits_per_sample <= 24 ) st -> codecpar -> codec_id = AV_CODEC_ID_PCM_S24LE ; else if ( descriptor -> bits_per_sample == 32 ) st -> codecpar -> codec_id = AV_CODEC_ID_PCM_S32LE ; } else if ( st -> codecpar -> codec_id == AV_CODEC_ID_PCM_S16BE ) { if ( descriptor -> bits_per_sample > 16 && descriptor -> bits_per_sample <= 24 ) st -> codecpar -> codec_id = AV_CODEC_ID_PCM_S24BE ; else if ( descriptor -> bits_per_sample == 32 ) st -> codecpar -> codec_id = AV_CODEC_ID_PCM_S32BE ; } else if ( st -> codecpar -> codec_id == AV_CODEC_ID_MP2 ) { st -> need_parsing = AVSTREAM_PARSE_FULL ; } } else if ( st -> codecpar -> codec_type == AVMEDIA_TYPE_DATA ) { enum AVMediaType type ; container_ul = mxf_get_codec_ul ( mxf_data_essence_container_uls , essence_container_ul ) ; if ( st -> codecpar -> codec_id == AV_CODEC_ID_NONE ) st -> codecpar -> codec_id = container_ul -> id ; type = avcodec_get_type ( st -> codecpar -> codec_id ) ; if ( type == AVMEDIA_TYPE_SUBTITLE ) st -> codecpar -> codec_type = type ; if ( container_ul -> desc ) av_dict_set ( & st -> metadata , "data_type" , container_ul -> desc , 0 ) ; } if ( descriptor -> extradata ) { if ( ! ff_alloc_extradata ( st -> codecpar , descriptor -> extradata_size ) ) { memcpy ( st -> codecpar -> extradata , descriptor -> extradata , descriptor -> extradata_size ) ; } } else if ( st -> codecpar -> codec_id == AV_CODEC_ID_H264 ) { int coded_width = mxf_get_codec_ul ( mxf_intra_only_picture_coded_width , & descriptor -> essence_codec_ul ) -> id ; if ( coded_width ) st -> codecpar -> width = coded_width ; ret = ff_generate_avci_extradata ( st ) ; if ( ret < 0 ) return ret ; } if ( st -> codecpar -> codec_type != AVMEDIA_TYPE_DATA && source_track -> wrapping != FrameWrapped ) { st -> need_parsing = AVSTREAM_PARSE_TIMESTAMPS ; } } ret = 0 ; fail_and_free : return ret ; }
CWE-617 static int er_supported ( ERContext * s ) { if ( s -> avctx -> hwaccel && s -> avctx -> hwaccel -> decode_slice || ! s -> cur_pic . f || <S2SV_StartBug> s -> cur_pic . field_picture || <S2SV_EndBug> s -> avctx -> profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO ) return 0 ; return 1 ; }
CWE-617 int ff_h263_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) { const uint8_t * buf = avpkt -> data ; int buf_size = avpkt -> size ; MpegEncContext * s = avctx -> priv_data ; int ret ; int slice_ret = 0 ; AVFrame * pict = data ; if ( buf_size == 0 ) { if ( s -> low_delay == 0 && s -> next_picture_ptr ) { if ( ( ret = av_frame_ref ( pict , s -> next_picture_ptr -> f ) ) < 0 ) return ret ; s -> next_picture_ptr = NULL ; * got_frame = 1 ; } return 0 ; } if ( s -> avctx -> flags & AV_CODEC_FLAG_TRUNCATED ) { int next ; if ( CONFIG_MPEG4_DECODER && s -> codec_id == AV_CODEC_ID_MPEG4 ) { next = ff_mpeg4_find_frame_end ( & s -> parse_context , buf , buf_size ) ; } else if ( CONFIG_H263_DECODER && s -> codec_id == AV_CODEC_ID_H263 ) { next = ff_h263_find_frame_end ( & s -> parse_context , buf , buf_size ) ; } else if ( CONFIG_H263P_DECODER && s -> codec_id == AV_CODEC_ID_H263P ) { next = ff_h263_find_frame_end ( & s -> parse_context , buf , buf_size ) ; } else { av_log ( s -> avctx , AV_LOG_ERROR , "this<S2SV_blank>codec<S2SV_blank>does<S2SV_blank>not<S2SV_blank>support<S2SV_blank>truncated<S2SV_blank>bitstreams\\n" ) ; return AVERROR ( ENOSYS ) ; } if ( ff_combine_frame ( & s -> parse_context , next , ( const uint8_t * * ) & buf , & buf_size ) < 0 ) return buf_size ; } retry : if ( s -> divx_packed && s -> bitstream_buffer_size ) { int i ; for ( i = 0 ; i < buf_size - 3 ; i ++ ) { if ( buf [ i ] == 0 && buf [ i + 1 ] == 0 && buf [ i + 2 ] == 1 ) { if ( buf [ i + 3 ] == 0xB0 ) { av_log ( s -> avctx , AV_LOG_WARNING , "Discarding<S2SV_blank>excessive<S2SV_blank>bitstream<S2SV_blank>in<S2SV_blank>packed<S2SV_blank>xvid\\n" ) ; s -> bitstream_buffer_size = 0 ; } break ; } } } if ( s -> bitstream_buffer_size && ( s -> divx_packed || buf_size <= MAX_NVOP_SIZE ) ) ret = init_get_bits8 ( & s -> gb , s -> bitstream_buffer , s -> bitstream_buffer_size ) ; else ret = init_get_bits8 ( & s -> gb , buf , buf_size ) ; s -> bitstream_buffer_size = 0 ; if ( ret < 0 ) return ret ; if ( ! s -> context_initialized ) ff_mpv_idct_init ( s ) ; if ( CONFIG_WMV2_DECODER && s -> msmpeg4_version == 5 ) { ret = ff_wmv2_decode_picture_header ( s ) ; } else if ( CONFIG_MSMPEG4_DECODER && s -> msmpeg4_version ) { ret = ff_msmpeg4_decode_picture_header ( s ) ; } else if ( CONFIG_MPEG4_DECODER && avctx -> codec_id == AV_CODEC_ID_MPEG4 ) { if ( s -> avctx -> extradata_size && s -> picture_number == 0 ) { GetBitContext gb ; if ( init_get_bits8 ( & gb , s -> avctx -> extradata , s -> avctx -> extradata_size ) >= 0 ) ff_mpeg4_decode_picture_header ( avctx -> priv_data , & gb ) ; } ret = ff_mpeg4_decode_picture_header ( avctx -> priv_data , & s -> gb ) ; } else if ( CONFIG_H263I_DECODER && s -> codec_id == AV_CODEC_ID_H263I ) { ret = ff_intel_h263_decode_picture_header ( s ) ; } else if ( CONFIG_FLV_DECODER && s -> h263_flv ) { ret = ff_flv_decode_picture_header ( s ) ; } else { ret = ff_h263_decode_picture_header ( s ) ; } if ( ret < 0 || ret == FRAME_SKIPPED ) { if ( s -> width != avctx -> coded_width || s -> height != avctx -> coded_height ) { av_log ( s -> avctx , AV_LOG_WARNING , "Reverting<S2SV_blank>picture<S2SV_blank>dimensions<S2SV_blank>change<S2SV_blank>due<S2SV_blank>to<S2SV_blank>header<S2SV_blank>decoding<S2SV_blank>failure\\n" ) ; s -> width = avctx -> coded_width ; s -> height = avctx -> coded_height ; } } if ( ret == FRAME_SKIPPED ) return get_consumed_bytes ( s , buf_size ) ; if ( ret < 0 ) { av_log ( s -> avctx , AV_LOG_ERROR , "header<S2SV_blank>damaged\\n" ) ; return ret ; } if ( ! s -> context_initialized ) { avctx -> pix_fmt = h263_get_format ( avctx ) ; if ( ( ret = ff_mpv_common_init ( s ) ) < 0 ) return ret ; } if ( ! s -> current_picture_ptr || s -> current_picture_ptr -> f -> data [ 0 ] ) { int i = ff_find_unused_picture ( s -> avctx , s -> picture , 0 ) ; if ( i < 0 ) return i ; s -> current_picture_ptr = & s -> picture [ i ] ; } avctx -> has_b_frames = ! s -> low_delay ; if ( CONFIG_MPEG4_DECODER && avctx -> codec_id == AV_CODEC_ID_MPEG4 ) { if ( ff_mpeg4_workaround_bugs ( avctx ) == 1 ) goto retry ; if ( s -> studio_profile != ( s -> idsp . idct == NULL ) ) ff_mpv_idct_init ( s ) ; } if ( s -> width != avctx -> coded_width || s -> height != avctx -> coded_height || s -> context_reinit ) { s -> context_reinit = 0 ; ret = ff_set_dimensions ( avctx , s -> width , s -> height ) ; if ( ret < 0 ) return ret ; ff_set_sar ( avctx , avctx -> sample_aspect_ratio ) ; if ( ( ret = ff_mpv_common_frame_size_change ( s ) ) ) return ret ; if ( avctx -> pix_fmt != h263_get_format ( avctx ) ) { av_log ( avctx , AV_LOG_ERROR , "format<S2SV_blank>change<S2SV_blank>not<S2SV_blank>supported\\n" ) ; avctx -> pix_fmt = AV_PIX_FMT_NONE ; return AVERROR_UNKNOWN ; } } if ( s -> codec_id == AV_CODEC_ID_H263 || s -> codec_id == AV_CODEC_ID_H263P || s -> codec_id == AV_CODEC_ID_H263I ) s -> gob_index = H263_GOB_HEIGHT ( s -> height ) ; s -> current_picture . f -> pict_type = s -> pict_type ; s -> current_picture . f -> key_frame = s -> pict_type == AV_PICTURE_TYPE_I ; if ( ! s -> last_picture_ptr && ( s -> pict_type == AV_PICTURE_TYPE_B || s -> droppable ) ) return get_consumed_bytes ( s , buf_size ) ; if ( ( avctx -> skip_frame >= AVDISCARD_NONREF && s -> pict_type == AV_PICTURE_TYPE_B ) || ( avctx -> skip_frame >= AVDISCARD_NONKEY && s -> pict_type != AV_PICTURE_TYPE_I ) || avctx -> skip_frame >= AVDISCARD_ALL ) return get_consumed_bytes ( s , buf_size ) ; if ( s -> next_p_frame_damaged ) { if ( s -> pict_type == AV_PICTURE_TYPE_B ) return get_consumed_bytes ( s , buf_size ) ; else s -> next_p_frame_damaged = 0 ; } if ( ( ! s -> no_rounding ) || s -> pict_type == AV_PICTURE_TYPE_B ) { s -> me . qpel_put = s -> qdsp . put_qpel_pixels_tab ; s -> me . qpel_avg = s -> qdsp . avg_qpel_pixels_tab ; } else { s -> me . qpel_put = s -> qdsp . put_no_rnd_qpel_pixels_tab ; s -> me . qpel_avg = s -> qdsp . avg_qpel_pixels_tab ; } if ( ( ret = ff_mpv_frame_start ( s , avctx ) ) < 0 ) return ret ; if ( ! s -> divx_packed ) ff_thread_finish_setup ( avctx ) ; if ( avctx -> hwaccel ) { ret = avctx -> hwaccel -> start_frame ( avctx , s -> gb . buffer , s -> gb . buffer_end - s -> gb . buffer ) ; if ( ret < 0 ) return ret ; } ff_mpeg_er_frame_start ( s ) ; if ( CONFIG_WMV2_DECODER && s -> msmpeg4_version == 5 ) { ret = ff_wmv2_decode_secondary_picture_header ( s ) ; if ( ret < 0 ) return ret ; if ( ret == 1 ) goto frame_end ; } s -> mb_x = 0 ; s -> mb_y = 0 ; slice_ret = decode_slice ( s ) ; while ( s -> mb_y < s -> mb_height ) { if ( s -> msmpeg4_version ) { if ( s -> slice_height == 0 || s -> mb_x != 0 || slice_ret < 0 || ( s -> mb_y % s -> slice_height ) != 0 || get_bits_left ( & s -> gb ) < 0 ) break ; } else { int prev_x = s -> mb_x , prev_y = s -> mb_y ; if ( ff_h263_resync ( s ) < 0 ) break ; if ( prev_y * s -> mb_width + prev_x < s -> mb_y * s -> mb_width + s -> mb_x ) s -> er . error_occurred = 1 ; } if ( s -> msmpeg4_version < 4 && s -> h263_pred ) ff_mpeg4_clean_buffers ( s ) ; if ( decode_slice ( s ) < 0 ) slice_ret = AVERROR_INVALIDDATA ; } if ( s -> msmpeg4_version && s -> msmpeg4_version < 4 && s -> pict_type == AV_PICTURE_TYPE_I ) if ( ! CONFIG_MSMPEG4_DECODER || ff_msmpeg4_decode_ext_header ( s , buf_size ) < 0 ) s -> er . error_status_table [ s -> mb_num - 1 ] = ER_MB_ERROR ; av_assert1 ( s -> bitstream_buffer_size == 0 ) ; <S2SV_StartBug> frame_end : <S2SV_EndBug> ff_er_frame_end ( & s -> er ) ; if ( avctx -> hwaccel ) { ret = avctx -> hwaccel -> end_frame ( avctx ) ; if ( ret < 0 ) return ret ; } ff_mpv_frame_end ( s ) ; if ( CONFIG_MPEG4_DECODER && avctx -> codec_id == AV_CODEC_ID_MPEG4 ) ff_mpeg4_frame_end ( avctx , buf , buf_size ) ; if ( ! s -> divx_packed && avctx -> hwaccel ) ff_thread_finish_setup ( avctx ) ; av_assert1 ( s -> current_picture . f -> pict_type == s -> current_picture_ptr -> f -> pict_type ) ; av_assert1 ( s -> current_picture . f -> pict_type == s -> pict_type ) ; if ( s -> pict_type == AV_PICTURE_TYPE_B || s -> low_delay ) { if ( ( ret = av_frame_ref ( pict , s -> current_picture_ptr -> f ) ) < 0 ) return ret ; ff_print_debug_info ( s , s -> current_picture_ptr , pict ) ; ff_mpv_export_qp_table ( s , pict , s -> current_picture_ptr , FF_QSCALE_TYPE_MPEG1 ) ; } else if ( s -> last_picture_ptr ) { if ( ( ret = av_frame_ref ( pict , s -> last_picture_ptr -> f ) ) < 0 ) return ret ; ff_print_debug_info ( s , s -> last_picture_ptr , pict ) ; ff_mpv_export_qp_table ( s , pict , s -> last_picture_ptr , FF_QSCALE_TYPE_MPEG1 ) ; } if ( s -> last_picture_ptr || s -> low_delay ) { if ( pict -> format == AV_PIX_FMT_YUV420P && ( s -> codec_tag == AV_RL32 ( "GEOV" ) || s -> codec_tag == AV_RL32 ( "GEOX" ) ) ) { int x , y , p ; av_frame_make_writable ( pict ) ; for ( p = 0 ; p < 3 ; p ++ ) { int w = AV_CEIL_RSHIFT ( pict -> width , ! ! p ) ; int h = AV_CEIL_RSHIFT ( pict -> height , ! ! p ) ; int linesize = pict -> linesize [ p ] ; for ( y = 0 ; y < ( h >> 1 ) ; y ++ ) for ( x = 0 ; x < w ; x ++ ) FFSWAP ( int , pict -> data [ p ] [ x + y * linesize ] , pict -> data [ p ] [ x + ( h - 1 - y ) * linesize ] ) ; } } * got_frame = 1 ; } if ( slice_ret < 0 && ( avctx -> err_recognition & AV_EF_EXPLODE ) ) return slice_ret ; else return get_consumed_bytes ( s , buf_size ) ; }
CWE-617 static enum AVPixelFormat h263_get_format ( AVCodecContext * avctx ) <S2SV_StartBug> { <S2SV_EndBug> if ( avctx -> bits_per_raw_sample > 8 ) { <S2SV_StartBug> av_assert1 ( avctx -> profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO ) ; <S2SV_EndBug> return avctx -> pix_fmt ; } if ( avctx -> codec -> id == AV_CODEC_ID_MSS2 ) return AV_PIX_FMT_YUV420P ; if ( CONFIG_GRAY && ( avctx -> flags & AV_CODEC_FLAG_GRAY ) ) { if ( avctx -> color_range == AVCOL_RANGE_UNSPECIFIED ) avctx -> color_range = AVCOL_RANGE_MPEG ; return AV_PIX_FMT_GRAY8 ; } return avctx -> pix_fmt = ff_get_format ( avctx , avctx -> codec -> pix_fmts ) ; }
CWE-617 int ff_mpeg4_decode_picture_header ( Mpeg4DecContext * ctx , GetBitContext * gb ) { MpegEncContext * s = & ctx -> m ; unsigned startcode , v ; int ret ; int vol = 0 ; align_get_bits ( gb ) ; if ( ! s -> studio_profile && s -> avctx -> bits_per_raw_sample != 8 ) s -> avctx -> bits_per_raw_sample = 0 ; if ( s -> codec_tag == AV_RL32 ( "WV1F" ) && show_bits ( gb , 24 ) == 0x575630 ) { skip_bits ( gb , 24 ) ; if ( get_bits ( gb , 8 ) == 0xF0 ) goto end ; } startcode = 0xff ; for ( ; ; ) { if ( get_bits_count ( gb ) >= gb -> size_in_bits ) { if ( gb -> size_in_bits == 8 && ( ctx -> divx_version >= 0 || ctx -> xvid_build >= 0 ) || s -> codec_tag == AV_RL32 ( "QMP4" ) ) { av_log ( s -> avctx , AV_LOG_VERBOSE , "frame<S2SV_blank>skip<S2SV_blank>%d\\n" , gb -> size_in_bits ) ; return FRAME_SKIPPED ; } else return AVERROR_INVALIDDATA ; } v = get_bits ( gb , 8 ) ; startcode = ( ( startcode << 8 ) | v ) & 0xffffffff ; if ( ( startcode & 0xFFFFFF00 ) != 0x100 ) continue ; if ( s -> avctx -> debug & FF_DEBUG_STARTCODE ) { av_log ( s -> avctx , AV_LOG_DEBUG , "startcode:<S2SV_blank>%3X<S2SV_blank>" , startcode ) ; if ( startcode <= 0x11F ) av_log ( s -> avctx , AV_LOG_DEBUG , "Video<S2SV_blank>Object<S2SV_blank>Start" ) ; else if ( startcode <= 0x12F ) av_log ( s -> avctx , AV_LOG_DEBUG , "Video<S2SV_blank>Object<S2SV_blank>Layer<S2SV_blank>Start" ) ; else if ( startcode <= 0x13F ) av_log ( s -> avctx , AV_LOG_DEBUG , "Reserved" ) ; else if ( startcode <= 0x15F ) av_log ( s -> avctx , AV_LOG_DEBUG , "FGS<S2SV_blank>bp<S2SV_blank>start" ) ; else if ( startcode <= 0x1AF ) av_log ( s -> avctx , AV_LOG_DEBUG , "Reserved" ) ; else if ( startcode == 0x1B0 ) av_log ( s -> avctx , AV_LOG_DEBUG , "Visual<S2SV_blank>Object<S2SV_blank>Seq<S2SV_blank>Start" ) ; else if ( startcode == 0x1B1 ) av_log ( s -> avctx , AV_LOG_DEBUG , "Visual<S2SV_blank>Object<S2SV_blank>Seq<S2SV_blank>End" ) ; else if ( startcode == 0x1B2 ) av_log ( s -> avctx , AV_LOG_DEBUG , "User<S2SV_blank>Data" ) ; else if ( startcode == 0x1B3 ) av_log ( s -> avctx , AV_LOG_DEBUG , "Group<S2SV_blank>of<S2SV_blank>VOP<S2SV_blank>start" ) ; else if ( startcode == 0x1B4 ) av_log ( s -> avctx , AV_LOG_DEBUG , "Video<S2SV_blank>Session<S2SV_blank>Error" ) ; else if ( startcode == 0x1B5 ) av_log ( s -> avctx , AV_LOG_DEBUG , "Visual<S2SV_blank>Object<S2SV_blank>Start" ) ; else if ( startcode == 0x1B6 ) av_log ( s -> avctx , AV_LOG_DEBUG , "Video<S2SV_blank>Object<S2SV_blank>Plane<S2SV_blank>start" ) ; else if ( startcode == 0x1B7 ) av_log ( s -> avctx , AV_LOG_DEBUG , "slice<S2SV_blank>start" ) ; else if ( startcode == 0x1B8 ) av_log ( s -> avctx , AV_LOG_DEBUG , "extension<S2SV_blank>start" ) ; else if ( startcode == 0x1B9 ) av_log ( s -> avctx , AV_LOG_DEBUG , "fgs<S2SV_blank>start" ) ; else if ( startcode == 0x1BA ) av_log ( s -> avctx , AV_LOG_DEBUG , "FBA<S2SV_blank>Object<S2SV_blank>start" ) ; else if ( startcode == 0x1BB ) av_log ( s -> avctx , AV_LOG_DEBUG , "FBA<S2SV_blank>Object<S2SV_blank>Plane<S2SV_blank>start" ) ; else if ( startcode == 0x1BC ) av_log ( s -> avctx , AV_LOG_DEBUG , "Mesh<S2SV_blank>Object<S2SV_blank>start" ) ; else if ( startcode == 0x1BD ) av_log ( s -> avctx , AV_LOG_DEBUG , "Mesh<S2SV_blank>Object<S2SV_blank>Plane<S2SV_blank>start" ) ; else if ( startcode == 0x1BE ) av_log ( s -> avctx , AV_LOG_DEBUG , "Still<S2SV_blank>Texture<S2SV_blank>Object<S2SV_blank>start" ) ; else if ( startcode == 0x1BF ) av_log ( s -> avctx , AV_LOG_DEBUG , "Texture<S2SV_blank>Spatial<S2SV_blank>Layer<S2SV_blank>start" ) ; else if ( startcode == 0x1C0 ) av_log ( s -> avctx , AV_LOG_DEBUG , "Texture<S2SV_blank>SNR<S2SV_blank>Layer<S2SV_blank>start" ) ; else if ( startcode == 0x1C1 ) av_log ( s -> avctx , AV_LOG_DEBUG , "Texture<S2SV_blank>Tile<S2SV_blank>start" ) ; else if ( startcode == 0x1C2 ) av_log ( s -> avctx , AV_LOG_DEBUG , "Texture<S2SV_blank>Shape<S2SV_blank>Layer<S2SV_blank>start" ) ; else if ( startcode == 0x1C3 ) av_log ( s -> avctx , AV_LOG_DEBUG , "stuffing<S2SV_blank>start" ) ; else if ( startcode <= 0x1C5 ) av_log ( s -> avctx , AV_LOG_DEBUG , "reserved" ) ; else if ( startcode <= 0x1FF ) av_log ( s -> avctx , AV_LOG_DEBUG , "System<S2SV_blank>start" ) ; av_log ( s -> avctx , AV_LOG_DEBUG , "<S2SV_blank>at<S2SV_blank>%d\\n" , get_bits_count ( gb ) ) ; } if ( startcode >= 0x120 && startcode <= 0x12F ) { if ( vol ) { av_log ( s -> avctx , AV_LOG_WARNING , "Ignoring<S2SV_blank>multiple<S2SV_blank>VOL<S2SV_blank>headers\\n" ) ; continue ; } vol ++ ; if ( ( ret = decode_vol_header ( ctx , gb ) ) < 0 ) return ret ; } else if ( startcode == USER_DATA_STARTCODE ) { decode_user_data ( ctx , gb ) ; } else if ( startcode == GOP_STARTCODE ) { mpeg4_decode_gop_header ( s , gb ) ; } else if ( startcode == VOS_STARTCODE ) { int profile , level ; mpeg4_decode_profile_level ( s , gb , & profile , & level ) ; if ( profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO && ( level > 0 && level < 9 ) ) { s -> studio_profile = 1 ; next_start_code_studio ( gb ) ; extension_and_user_data ( s , gb , 0 ) ; } else if ( s -> studio_profile ) { avpriv_request_sample ( s -> avctx , "Mixes<S2SV_blank>studio<S2SV_blank>and<S2SV_blank>non<S2SV_blank>studio<S2SV_blank>profile\\n" ) ; return AVERROR_PATCHWELCOME ; } s -> avctx -> profile = profile ; s -> avctx -> level = level ; } else if ( startcode == VISUAL_OBJ_STARTCODE ) { if ( s -> studio_profile ) { if ( ( ret = decode_studiovisualobject ( ctx , gb ) ) < 0 ) return ret ; } else mpeg4_decode_visual_object ( s , gb ) ; } else if ( startcode == VOP_STARTCODE ) { break ; } align_get_bits ( gb ) ; startcode = 0xff ; } end : if ( s -> avctx -> flags & AV_CODEC_FLAG_LOW_DELAY ) s -> low_delay = 1 ; s -> avctx -> has_b_frames = ! s -> low_delay ; if ( s -> studio_profile ) { <S2SV_StartBug> av_assert0 ( s -> avctx -> profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO ) ; <S2SV_EndBug> if ( ! s -> avctx -> bits_per_raw_sample ) { av_log ( s -> avctx , AV_LOG_ERROR , "Missing<S2SV_blank>VOL<S2SV_blank>header\\n" ) ; return AVERROR_INVALIDDATA ; } return decode_studio_vop_header ( ctx , gb ) ; } else return decode_vop_header ( ctx , gb ) ; }
CWE-125 int ff_mms_asf_header_parser ( MMSContext * mms ) { uint8_t * p = mms -> asf_header ; uint8_t * end ; int flags , stream_id ; mms -> stream_num = 0 ; if ( mms -> asf_header_size < sizeof ( ff_asf_guid ) * 2 + 22 || memcmp ( p , ff_asf_header , sizeof ( ff_asf_guid ) ) ) { av_log ( NULL , AV_LOG_ERROR , "Corrupt<S2SV_blank>stream<S2SV_blank>(invalid<S2SV_blank>ASF<S2SV_blank>header,<S2SV_blank>size=%d)\\n" , mms -> asf_header_size ) ; return AVERROR_INVALIDDATA ; } end = mms -> asf_header + mms -> asf_header_size ; p += sizeof ( ff_asf_guid ) + 14 ; while ( end - p >= sizeof ( ff_asf_guid ) + 8 ) { uint64_t chunksize ; if ( ! memcmp ( p , ff_asf_data_header , sizeof ( ff_asf_guid ) ) ) { chunksize = 50 ; } else { chunksize = AV_RL64 ( p + sizeof ( ff_asf_guid ) ) ; } if ( ! chunksize || chunksize > end - p ) { av_log ( NULL , AV_LOG_ERROR , "Corrupt<S2SV_blank>stream<S2SV_blank>(header<S2SV_blank>chunksize<S2SV_blank>%" PRId64 "<S2SV_blank>is<S2SV_blank>invalid)\\n" , chunksize ) ; return AVERROR_INVALIDDATA ; } if ( ! memcmp ( p , ff_asf_file_header , sizeof ( ff_asf_guid ) ) ) { if ( end - p > sizeof ( ff_asf_guid ) * 2 + 68 ) { mms -> asf_packet_len = AV_RL32 ( p + sizeof ( ff_asf_guid ) * 2 + 64 ) ; if ( mms -> asf_packet_len <= 0 || mms -> asf_packet_len > sizeof ( mms -> in_buffer ) ) { av_log ( NULL , AV_LOG_ERROR , "Corrupt<S2SV_blank>stream<S2SV_blank>(too<S2SV_blank>large<S2SV_blank>pkt_len<S2SV_blank>%d)\\n" , mms -> asf_packet_len ) ; return AVERROR_INVALIDDATA ; } } } else if ( ! memcmp ( p , ff_asf_stream_header , sizeof ( ff_asf_guid ) ) ) { <S2SV_StartBug> flags = AV_RL16 ( p + sizeof ( ff_asf_guid ) * 3 + 24 ) ; <S2SV_EndBug> stream_id = flags & 0x7F ; if ( mms -> stream_num < MMS_MAX_STREAMS && 46 + mms -> stream_num * 6 < sizeof ( mms -> out_buffer ) ) { mms -> streams = av_fast_realloc ( mms -> streams , & mms -> nb_streams_allocated , ( mms -> stream_num + 1 ) * sizeof ( MMSStream ) ) ; if ( ! mms -> streams ) return AVERROR ( ENOMEM ) ; mms -> streams [ mms -> stream_num ] . id = stream_id ; mms -> stream_num ++ ; } else { av_log ( NULL , AV_LOG_ERROR , "Corrupt<S2SV_blank>stream<S2SV_blank>(too<S2SV_blank>many<S2SV_blank>A/V<S2SV_blank>streams)\\n" ) ; return AVERROR_INVALIDDATA ; } <S2SV_StartBug> } else if ( ! memcmp ( p , ff_asf_ext_stream_header , sizeof ( ff_asf_guid ) ) ) { <S2SV_EndBug> if ( end - p >= 88 ) { int stream_count = AV_RL16 ( p + 84 ) , ext_len_count = AV_RL16 ( p + 86 ) ; uint64_t skip_bytes = 88 ; while ( stream_count -- ) { if ( end - p < skip_bytes + 4 ) { av_log ( NULL , AV_LOG_ERROR , "Corrupt<S2SV_blank>stream<S2SV_blank>(next<S2SV_blank>stream<S2SV_blank>name<S2SV_blank>length<S2SV_blank>is<S2SV_blank>not<S2SV_blank>in<S2SV_blank>the<S2SV_blank>buffer)\\n" ) ; return AVERROR_INVALIDDATA ; } skip_bytes += 4 + AV_RL16 ( p + skip_bytes + 2 ) ; } while ( ext_len_count -- ) { if ( end - p < skip_bytes + 22 ) { av_log ( NULL , AV_LOG_ERROR , "Corrupt<S2SV_blank>stream<S2SV_blank>(next<S2SV_blank>extension<S2SV_blank>system<S2SV_blank>info<S2SV_blank>length<S2SV_blank>is<S2SV_blank>not<S2SV_blank>in<S2SV_blank>the<S2SV_blank>buffer)\\n" ) ; return AVERROR_INVALIDDATA ; } skip_bytes += 22 + AV_RL32 ( p + skip_bytes + 18 ) ; } if ( end - p < skip_bytes ) { av_log ( NULL , AV_LOG_ERROR , "Corrupt<S2SV_blank>stream<S2SV_blank>(the<S2SV_blank>last<S2SV_blank>extension<S2SV_blank>system<S2SV_blank>info<S2SV_blank>length<S2SV_blank>is<S2SV_blank>invalid)\\n" ) ; return AVERROR_INVALIDDATA ; } if ( chunksize - skip_bytes > 24 ) chunksize = skip_bytes ; } } else if ( ! memcmp ( p , ff_asf_head1_guid , sizeof ( ff_asf_guid ) ) ) { chunksize = 46 ; <S2SV_StartBug> } <S2SV_EndBug> p += chunksize ; } return 0 ; }
CWE-125 static int mpeg4_decode_studio_block ( MpegEncContext * s , int32_t block [ 64 ] , int n ) { Mpeg4DecContext * ctx = s -> avctx -> priv_data ; int cc , dct_dc_size , dct_diff , code , j , idx = 1 , group = 0 , run = 0 , additional_code_len , sign , mismatch ; VLC * cur_vlc = & ctx -> studio_intra_tab [ 0 ] ; uint8_t * const scantable = s -> intra_scantable . permutated ; const uint16_t * quant_matrix ; uint32_t flc ; const int min = - 1 * ( 1 << ( s -> avctx -> bits_per_raw_sample + 6 ) ) ; const int max = ( ( 1 << ( s -> avctx -> bits_per_raw_sample + 6 ) ) - 1 ) ; mismatch = 1 ; memset ( block , 0 , 64 * sizeof ( int32_t ) ) ; if ( n < 4 ) { cc = 0 ; dct_dc_size = get_vlc2 ( & s -> gb , ctx -> studio_luma_dc . table , STUDIO_INTRA_BITS , 2 ) ; quant_matrix = s -> intra_matrix ; } else { cc = ( n & 1 ) + 1 ; if ( ctx -> rgb ) dct_dc_size = get_vlc2 ( & s -> gb , ctx -> studio_luma_dc . table , STUDIO_INTRA_BITS , 2 ) ; else dct_dc_size = get_vlc2 ( & s -> gb , ctx -> studio_chroma_dc . table , STUDIO_INTRA_BITS , 2 ) ; quant_matrix = s -> chroma_intra_matrix ; } if ( dct_dc_size < 0 ) { av_log ( s -> avctx , AV_LOG_ERROR , "illegal<S2SV_blank>dct_dc_size<S2SV_blank>vlc\\n" ) ; return AVERROR_INVALIDDATA ; } else if ( dct_dc_size == 0 ) { dct_diff = 0 ; } else { dct_diff = get_xbits ( & s -> gb , dct_dc_size ) ; if ( dct_dc_size > 8 ) { if ( ! check_marker ( s -> avctx , & s -> gb , "dct_dc_size<S2SV_blank>><S2SV_blank>8" ) ) return AVERROR_INVALIDDATA ; } } s -> last_dc [ cc ] += dct_diff ; if ( s -> mpeg_quant ) block [ 0 ] = s -> last_dc [ cc ] * ( 8 >> s -> intra_dc_precision ) ; else block [ 0 ] = s -> last_dc [ cc ] * ( 8 >> s -> intra_dc_precision ) * ( 8 >> s -> dct_precision ) ; block [ 0 ] = av_clip ( block [ 0 ] , min , max ) ; mismatch ^= block [ 0 ] ; while ( 1 ) { group = get_vlc2 ( & s -> gb , cur_vlc -> table , STUDIO_INTRA_BITS , 2 ) ; if ( group < 0 ) { av_log ( s -> avctx , AV_LOG_ERROR , "illegal<S2SV_blank>ac<S2SV_blank>coefficient<S2SV_blank>group<S2SV_blank>vlc\\n" ) ; return AVERROR_INVALIDDATA ; } additional_code_len = ac_state_tab [ group ] [ 0 ] ; cur_vlc = & ctx -> studio_intra_tab [ ac_state_tab [ group ] [ 1 ] ] ; if ( group == 0 ) { break ; } else if ( group >= 1 && group <= 6 ) { run = 1 << additional_code_len ; if ( additional_code_len ) run += get_bits ( & s -> gb , additional_code_len ) ; idx += run ; continue ; } else if ( group >= 7 && group <= 12 ) { code = get_bits ( & s -> gb , additional_code_len ) ; sign = code & 1 ; code >>= 1 ; run = ( 1 << ( additional_code_len - 1 ) ) + code ; idx += run ; <S2SV_StartBug> j = scantable [ idx ++ ] ; <S2SV_EndBug> block [ j ] = sign ? 1 : - 1 ; } else if ( group >= 13 && group <= 20 ) { <S2SV_StartBug> j = scantable [ idx ++ ] ; <S2SV_EndBug> block [ j ] = get_xbits ( & s -> gb , additional_code_len ) ; <S2SV_StartBug> } else if ( group == 21 ) { <S2SV_EndBug> j = scantable [ idx ++ ] ; additional_code_len = s -> avctx -> bits_per_raw_sample + s -> dct_precision + 4 ; flc = get_bits ( & s -> gb , additional_code_len ) ; if ( flc >> ( additional_code_len - 1 ) ) block [ j ] = - 1 * ( ( flc ^ ( ( 1 << additional_code_len ) - 1 ) ) + 1 ) ; else block [ j ] = flc ; } block [ j ] = ( ( 8 * 2 * block [ j ] * quant_matrix [ j ] * s -> qscale ) >> s -> dct_precision ) / 32 ; block [ j ] = av_clip ( block [ j ] , min , max ) ; mismatch ^= block [ j ] ; } block [ 63 ] ^= mismatch & 1 ; return 0 ; }
CWE-20 static void mpeg4_encode_gop_header ( MpegEncContext * s ) { <S2SV_StartBug> int hours , minutes , seconds ; <S2SV_EndBug> int64_t time ; put_bits ( & s -> pb , 16 , 0 ) ; put_bits ( & s -> pb , 16 , GOP_STARTCODE ) ; time = s -> current_picture_ptr -> f -> pts ; if ( s -> reordered_input_picture [ 1 ] ) time = FFMIN ( time , s -> reordered_input_picture [ 1 ] -> f -> pts ) ; time = time * s -> avctx -> time_base . num ; s -> last_time_base = FFUDIV ( time , s -> avctx -> time_base . den ) ; seconds = FFUDIV ( time , s -> avctx -> time_base . den ) ; minutes = FFUDIV ( seconds , 60 ) ; seconds = FFUMOD ( seconds , 60 ) ; hours = FFUDIV ( minutes , 60 ) ; minutes = FFUMOD ( minutes , 60 ) ; hours = FFUMOD ( hours , 24 ) ; put_bits ( & s -> pb , 5 , hours ) ; put_bits ( & s -> pb , 6 , minutes ) ; put_bits ( & s -> pb , 1 , 1 ) ; put_bits ( & s -> pb , 6 , seconds ) ; put_bits ( & s -> pb , 1 , ! ! ( s -> avctx -> flags & AV_CODEC_FLAG_CLOSED_GOP ) ) ; put_bits ( & s -> pb , 1 , 0 ) ; ff_mpeg4_stuffing ( & s -> pb ) ; }
CWE-665 static int aa_read_header ( AVFormatContext * s ) { int i , j , idx , largest_idx = - 1 ; uint32_t nkey , nval , toc_size , npairs , header_seed = 0 , start ; char key [ 128 ] , val [ 128 ] , codec_name [ 64 ] = { 0 } ; uint8_t output [ 24 ] , dst [ 8 ] , src [ 8 ] ; int64_t largest_size = - 1 , current_size = - 1 , chapter_pos ; struct toc_entry { uint32_t offset ; uint32_t size ; } TOC [ MAX_TOC_ENTRIES ] ; uint32_t header_key_part [ 4 ] ; uint8_t header_key [ 16 ] = { 0 } ; AADemuxContext * c = s -> priv_data ; AVIOContext * pb = s -> pb ; AVStream * st ; <S2SV_StartBug> avio_skip ( pb , 4 ) ; <S2SV_EndBug> avio_skip ( pb , 4 ) ; toc_size = avio_rb32 ( pb ) ; avio_skip ( pb , 4 ) ; if ( toc_size > MAX_TOC_ENTRIES ) return AVERROR_INVALIDDATA ; for ( i = 0 ; i < toc_size ; i ++ ) { avio_skip ( pb , 4 ) ; TOC [ i ] . offset = avio_rb32 ( pb ) ; TOC [ i ] . size = avio_rb32 ( pb ) ; } avio_skip ( pb , 24 ) ; npairs = avio_rb32 ( pb ) ; if ( npairs > MAX_DICTIONARY_ENTRIES ) return AVERROR_INVALIDDATA ; for ( i = 0 ; i < npairs ; i ++ ) { memset ( val , 0 , sizeof ( val ) ) ; memset ( key , 0 , sizeof ( key ) ) ; avio_skip ( pb , 1 ) ; nkey = avio_rb32 ( pb ) ; nval = avio_rb32 ( pb ) ; avio_get_str ( pb , nkey , key , sizeof ( key ) ) ; avio_get_str ( pb , nval , val , sizeof ( val ) ) ; if ( ! strcmp ( key , "codec" ) ) { av_log ( s , AV_LOG_DEBUG , "Codec<S2SV_blank>is<S2SV_blank><%s>\\n" , val ) ; strncpy ( codec_name , val , sizeof ( codec_name ) - 1 ) ; } else if ( ! strcmp ( key , "HeaderSeed" ) ) { av_log ( s , AV_LOG_DEBUG , "HeaderSeed<S2SV_blank>is<S2SV_blank><%s>\\n" , val ) ; header_seed = atoi ( val ) ; } else if ( ! strcmp ( key , "HeaderKey" ) ) { av_log ( s , AV_LOG_DEBUG , "HeaderKey<S2SV_blank>is<S2SV_blank><%s>\\n" , val ) ; <S2SV_StartBug> sscanf ( val , "%" SCNu32 "%" SCNu32 "%" SCNu32 "%" SCNu32 , <S2SV_EndBug> & header_key_part [ 0 ] , & header_key_part [ 1 ] , & header_key_part [ 2 ] , & header_key_part [ 3 ] ) ; <S2SV_StartBug> for ( idx = 0 ; idx < 4 ; idx ++ ) { <S2SV_EndBug> AV_WB32 ( & header_key [ idx * 4 ] , header_key_part [ idx ] ) ; } av_log ( s , AV_LOG_DEBUG , "Processed<S2SV_blank>HeaderKey<S2SV_blank>is<S2SV_blank>" ) ; for ( i = 0 ; i < 16 ; i ++ ) av_log ( s , AV_LOG_DEBUG , "%02x" , header_key [ i ] ) ; av_log ( s , AV_LOG_DEBUG , "\\n" ) ; } else { av_dict_set ( & s -> metadata , key , val , 0 ) ; } } if ( c -> aa_fixed_key_len != 16 ) { av_log ( s , AV_LOG_ERROR , "aa_fixed_key<S2SV_blank>value<S2SV_blank>needs<S2SV_blank>to<S2SV_blank>be<S2SV_blank>16<S2SV_blank>bytes!\\n" ) ; return AVERROR ( EINVAL ) ; } if ( ( c -> codec_second_size = get_second_size ( codec_name ) ) == - 1 ) { av_log ( s , AV_LOG_ERROR , "unknown<S2SV_blank>codec<S2SV_blank><%s>!\\n" , codec_name ) ; return AVERROR ( EINVAL ) ; } c -> tea_ctx = av_tea_alloc ( ) ; if ( ! c -> tea_ctx ) return AVERROR ( ENOMEM ) ; av_tea_init ( c -> tea_ctx , c -> aa_fixed_key , 16 ) ; output [ 0 ] = output [ 1 ] = 0 ; memcpy ( output + 2 , header_key , 16 ) ; idx = 0 ; for ( i = 0 ; i < 3 ; i ++ ) { AV_WB32 ( src , header_seed ) ; AV_WB32 ( src + 4 , header_seed + 1 ) ; header_seed += 2 ; av_tea_crypt ( c -> tea_ctx , dst , src , 1 , NULL , 0 ) ; for ( j = 0 ; j < TEA_BLOCK_SIZE && idx < 18 ; j += 1 , idx += 1 ) { output [ idx ] = output [ idx ] ^ dst [ j ] ; } } memcpy ( c -> file_key , output + 2 , 16 ) ; av_log ( s , AV_LOG_DEBUG , "File<S2SV_blank>key<S2SV_blank>is<S2SV_blank>" ) ; for ( i = 0 ; i < 16 ; i ++ ) av_log ( s , AV_LOG_DEBUG , "%02x" , c -> file_key [ i ] ) ; av_log ( s , AV_LOG_DEBUG , "\\n" ) ; st = avformat_new_stream ( s , NULL ) ; if ( ! st ) { av_freep ( & c -> tea_ctx ) ; return AVERROR ( ENOMEM ) ; } st -> codecpar -> codec_type = AVMEDIA_TYPE_AUDIO ; if ( ! strcmp ( codec_name , "mp332" ) ) { st -> codecpar -> codec_id = AV_CODEC_ID_MP3 ; st -> codecpar -> sample_rate = 22050 ; st -> need_parsing = AVSTREAM_PARSE_FULL_RAW ; avpriv_set_pts_info ( st , 64 , 8 , 32000 * TIMEPREC ) ; } else if ( ! strcmp ( codec_name , "acelp85" ) ) { st -> codecpar -> codec_id = AV_CODEC_ID_SIPR ; st -> codecpar -> block_align = 19 ; st -> codecpar -> channels = 1 ; st -> codecpar -> sample_rate = 8500 ; st -> codecpar -> bit_rate = 8500 ; st -> need_parsing = AVSTREAM_PARSE_FULL_RAW ; avpriv_set_pts_info ( st , 64 , 8 , 8500 * TIMEPREC ) ; } else if ( ! strcmp ( codec_name , "acelp16" ) ) { st -> codecpar -> codec_id = AV_CODEC_ID_SIPR ; st -> codecpar -> block_align = 20 ; st -> codecpar -> channels = 1 ; st -> codecpar -> sample_rate = 16000 ; st -> codecpar -> bit_rate = 16000 ; st -> need_parsing = AVSTREAM_PARSE_FULL_RAW ; avpriv_set_pts_info ( st , 64 , 8 , 16000 * TIMEPREC ) ; } for ( i = 1 ; i < toc_size ; i ++ ) { current_size = TOC [ i ] . size ; if ( current_size > largest_size ) { largest_idx = i ; largest_size = current_size ; } } start = TOC [ largest_idx ] . offset ; avio_seek ( pb , start , SEEK_SET ) ; st -> start_time = 0 ; c -> content_start = start ; c -> content_end = start + largest_size ; while ( ( chapter_pos = avio_tell ( pb ) ) >= 0 && chapter_pos < c -> content_end ) { int chapter_idx = s -> nb_chapters ; uint32_t chapter_size = avio_rb32 ( pb ) ; if ( chapter_size == 0 ) break ; chapter_pos -= start + CHAPTER_HEADER_SIZE * chapter_idx ; avio_skip ( pb , 4 + chapter_size ) ; if ( ! avpriv_new_chapter ( s , chapter_idx , st -> time_base , chapter_pos * TIMEPREC , ( chapter_pos + chapter_size ) * TIMEPREC , NULL ) ) return AVERROR ( ENOMEM ) ; } st -> duration = ( largest_size - CHAPTER_HEADER_SIZE * s -> nb_chapters ) * TIMEPREC ; ff_update_cur_dts ( s , st , 0 ) ; avio_seek ( pb , start , SEEK_SET ) ; c -> current_chapter_size = 0 ; c -> seek_offset = 0 ; return 0 ; }
CWE-369 static int mov_write_audio_tag ( AVFormatContext * s , AVIOContext * pb , MOVMuxContext * mov , MOVTrack * track ) { int64_t pos = avio_tell ( pb ) ; int version = 0 ; uint32_t tag = track -> tag ; if ( track -> mode == MODE_MOV ) { <S2SV_StartBug> if ( track -> timescale > UINT16_MAX ) { <S2SV_EndBug> if ( mov_get_lpcm_flags ( track -> par -> codec_id ) ) tag = AV_RL32 ( "lpcm" ) ; version = 2 ; } else if ( track -> audio_vbr || mov_pcm_le_gt16 ( track -> par -> codec_id ) || mov_pcm_be_gt16 ( track -> par -> codec_id ) || track -> par -> codec_id == AV_CODEC_ID_ADPCM_MS || track -> par -> codec_id == AV_CODEC_ID_ADPCM_IMA_WAV || track -> par -> codec_id == AV_CODEC_ID_QDM2 ) { version = 1 ; } } avio_wb32 ( pb , 0 ) ; if ( mov -> encryption_scheme != MOV_ENC_NONE ) { ffio_wfourcc ( pb , "enca" ) ; } else { avio_wl32 ( pb , tag ) ; } avio_wb32 ( pb , 0 ) ; avio_wb16 ( pb , 0 ) ; avio_wb16 ( pb , 1 ) ; avio_wb16 ( pb , version ) ; avio_wb16 ( pb , 0 ) ; avio_wb32 ( pb , 0 ) ; if ( version == 2 ) { avio_wb16 ( pb , 3 ) ; avio_wb16 ( pb , 16 ) ; avio_wb16 ( pb , 0xfffe ) ; avio_wb16 ( pb , 0 ) ; avio_wb32 ( pb , 0x00010000 ) ; avio_wb32 ( pb , 72 ) ; avio_wb64 ( pb , av_double2int ( track -> par -> sample_rate ) ) ; avio_wb32 ( pb , track -> par -> channels ) ; avio_wb32 ( pb , 0x7F000000 ) ; avio_wb32 ( pb , av_get_bits_per_sample ( track -> par -> codec_id ) ) ; avio_wb32 ( pb , mov_get_lpcm_flags ( track -> par -> codec_id ) ) ; avio_wb32 ( pb , track -> sample_size ) ; avio_wb32 ( pb , get_samples_per_packet ( track ) ) ; } else { if ( track -> mode == MODE_MOV ) { avio_wb16 ( pb , track -> par -> channels ) ; if ( track -> par -> codec_id == AV_CODEC_ID_PCM_U8 || track -> par -> codec_id == AV_CODEC_ID_PCM_S8 ) avio_wb16 ( pb , 8 ) ; else if ( track -> par -> codec_id == AV_CODEC_ID_ADPCM_G726 ) avio_wb16 ( pb , track -> par -> bits_per_coded_sample ) ; else avio_wb16 ( pb , 16 ) ; avio_wb16 ( pb , track -> audio_vbr ? - 2 : 0 ) ; } else { if ( track -> par -> codec_id == AV_CODEC_ID_FLAC || track -> par -> codec_id == AV_CODEC_ID_OPUS ) { avio_wb16 ( pb , track -> par -> channels ) ; } else { avio_wb16 ( pb , 2 ) ; } if ( track -> par -> codec_id == AV_CODEC_ID_FLAC ) { avio_wb16 ( pb , track -> par -> bits_per_raw_sample ) ; } else { avio_wb16 ( pb , 16 ) ; } avio_wb16 ( pb , 0 ) ; } avio_wb16 ( pb , 0 ) ; if ( track -> par -> codec_id == AV_CODEC_ID_OPUS ) avio_wb16 ( pb , 48000 ) ; else avio_wb16 ( pb , track -> par -> sample_rate <= UINT16_MAX ? track -> par -> sample_rate : 0 ) ; avio_wb16 ( pb , 0 ) ; } if ( version == 1 ) { if ( mov_pcm_le_gt16 ( track -> par -> codec_id ) || mov_pcm_be_gt16 ( track -> par -> codec_id ) ) avio_wb32 ( pb , 1 ) ; else avio_wb32 ( pb , track -> par -> frame_size ) ; avio_wb32 ( pb , track -> sample_size / track -> par -> channels ) ; avio_wb32 ( pb , track -> sample_size ) ; avio_wb32 ( pb , 2 ) ; } if ( track -> mode == MODE_MOV && ( track -> par -> codec_id == AV_CODEC_ID_AAC || track -> par -> codec_id == AV_CODEC_ID_AC3 || track -> par -> codec_id == AV_CODEC_ID_EAC3 || track -> par -> codec_id == AV_CODEC_ID_AMR_NB || track -> par -> codec_id == AV_CODEC_ID_ALAC || track -> par -> codec_id == AV_CODEC_ID_ADPCM_MS || track -> par -> codec_id == AV_CODEC_ID_ADPCM_IMA_WAV || track -> par -> codec_id == AV_CODEC_ID_QDM2 || ( mov_pcm_le_gt16 ( track -> par -> codec_id ) && version == 1 ) || ( mov_pcm_be_gt16 ( track -> par -> codec_id ) && version == 1 ) ) ) mov_write_wave_tag ( s , pb , track ) ; else if ( track -> tag == MKTAG ( 'm' , 'p' , '4' , 'a' ) ) mov_write_esds_tag ( pb , track ) ; else if ( track -> par -> codec_id == AV_CODEC_ID_AMR_NB ) mov_write_amr_tag ( pb , track ) ; else if ( track -> par -> codec_id == AV_CODEC_ID_AC3 ) mov_write_ac3_tag ( pb , track ) ; else if ( track -> par -> codec_id == AV_CODEC_ID_EAC3 ) mov_write_eac3_tag ( pb , track ) ; else if ( track -> par -> codec_id == AV_CODEC_ID_ALAC ) mov_write_extradata_tag ( pb , track ) ; else if ( track -> par -> codec_id == AV_CODEC_ID_WMAPRO ) mov_write_wfex_tag ( s , pb , track ) ; else if ( track -> par -> codec_id == AV_CODEC_ID_FLAC ) mov_write_dfla_tag ( pb , track ) ; else if ( track -> par -> codec_id == AV_CODEC_ID_OPUS ) mov_write_dops_tag ( pb , track ) ; else if ( track -> vos_len > 0 ) mov_write_glbl_tag ( pb , track ) ; if ( track -> mode == MODE_MOV && track -> par -> codec_type == AVMEDIA_TYPE_AUDIO ) mov_write_chan_tag ( s , pb , track ) ; if ( mov -> encryption_scheme != MOV_ENC_NONE ) { ff_mov_cenc_write_sinf_tag ( track , pb , mov -> encryption_kid ) ; } return update_size ( pb , pos ) ; }
CWE-190 static BOOL gdi_Bitmap_Decompress ( rdpContext * context , rdpBitmap * bitmap , const BYTE * pSrcData , UINT32 DstWidth , UINT32 DstHeight , UINT32 bpp , UINT32 length , BOOL compressed , UINT32 codecId ) { UINT32 SrcSize = length ; rdpGdi * gdi = context -> gdi ; <S2SV_StartBug> bitmap -> compressed = FALSE ; <S2SV_EndBug> bitmap -> format = gdi -> dstFormat ; <S2SV_StartBug> bitmap -> length = DstWidth * DstHeight * GetBytesPerPixel ( bitmap -> format ) ; <S2SV_EndBug> bitmap -> data = ( BYTE * ) _aligned_malloc ( bitmap -> length , 16 ) ; if ( ! bitmap -> data ) return FALSE ; if ( compressed ) { if ( bpp < 32 ) { if ( ! interleaved_decompress ( context -> codecs -> interleaved , pSrcData , SrcSize , DstWidth , DstHeight , bpp , bitmap -> data , bitmap -> format , 0 , 0 , 0 , DstWidth , DstHeight , & gdi -> palette ) ) return FALSE ; } else { if ( ! planar_decompress ( context -> codecs -> planar , pSrcData , SrcSize , DstWidth , DstHeight , bitmap -> data , bitmap -> format , 0 , 0 , 0 , DstWidth , DstHeight , TRUE ) ) return FALSE ; } } else { const UINT32 SrcFormat = gdi_get_pixel_format ( bpp ) ; const size_t sbpp = GetBytesPerPixel ( SrcFormat ) ; const size_t dbpp = GetBytesPerPixel ( bitmap -> format ) ; if ( ( sbpp == 0 ) || ( dbpp == 0 ) ) return FALSE ; else { const size_t dstSize = SrcSize * dbpp / sbpp ; if ( dstSize < bitmap -> length ) return FALSE ; } if ( ! freerdp_image_copy ( bitmap -> data , bitmap -> format , 0 , 0 , 0 , DstWidth , DstHeight , pSrcData , SrcFormat , 0 , 0 , 0 , & gdi -> palette , FREERDP_FLIP_VERTICAL ) ) return FALSE ; } return TRUE ; }
CWE-125 <S2SV_StartBug> void ntlm_free_message_fields_buffer ( NTLM_MESSAGE_FIELDS * fields ) <S2SV_EndBug> { if ( fields ) { if ( fields -> Buffer ) { free ( fields -> Buffer ) ; fields -> Len = 0 ; fields -> MaxLen = 0 ; fields -> Buffer = NULL ; fields -> BufferOffset = 0 ; } } }
CWE-125 <S2SV_StartBug> void ntlm_populate_message_header ( NTLM_MESSAGE_HEADER * header , UINT32 MessageType ) <S2SV_EndBug> { CopyMemory ( header -> Signature , NTLM_SIGNATURE , sizeof ( NTLM_SIGNATURE ) ) ; header -> MessageType = MessageType ; }
CWE-125 <S2SV_StartBug> void ntlm_print_message_fields ( NTLM_MESSAGE_FIELDS * fields , const char * name ) <S2SV_EndBug> { WLog_DBG ( TAG , "%s<S2SV_blank>(Len:<S2SV_blank>%" PRIu16 "<S2SV_blank>MaxLen:<S2SV_blank>%" PRIu16 "<S2SV_blank>BufferOffset:<S2SV_blank>%" PRIu32 ")" , name , fields -> Len , fields -> MaxLen , fields -> BufferOffset ) ; if ( fields -> Len > 0 ) winpr_HexDump ( TAG , WLOG_DEBUG , fields -> Buffer , fields -> Len ) ; }
CWE-125 <S2SV_StartBug> void ntlm_print_negotiate_flags ( UINT32 flags ) <S2SV_EndBug> { int i ; const char * str ; WLog_INFO ( TAG , "negotiateFlags<S2SV_blank>\\"0x%08" PRIX32 "\\"" , flags ) ; for ( i = 31 ; i >= 0 ; i -- ) { if ( ( flags >> i ) & 1 ) { str = NTLM_NEGOTIATE_STRINGS [ ( 31 - i ) ] ; WLog_INFO ( TAG , "\\t%s<S2SV_blank>(%d)," , str , ( 31 - i ) ) ; } } }
CWE-125 <S2SV_StartBug> int ntlm_read_message_fields ( wStream * s , NTLM_MESSAGE_FIELDS * fields ) <S2SV_EndBug> { if ( Stream_GetRemainingLength ( s ) < 8 ) return - 1 ; Stream_Read_UINT16 ( s , fields -> Len ) ; Stream_Read_UINT16 ( s , fields -> MaxLen ) ; Stream_Read_UINT32 ( s , fields -> BufferOffset ) ; return 1 ; }
CWE-125 <S2SV_StartBug> int ntlm_read_message_fields_buffer ( wStream * s , NTLM_MESSAGE_FIELDS * fields ) <S2SV_EndBug> { if ( fields -> Len > 0 ) { <S2SV_StartBug> if ( ( fields -> BufferOffset + fields -> Len ) > Stream_Length ( s ) ) <S2SV_EndBug> return - 1 ; fields -> Buffer = ( PBYTE ) malloc ( fields -> Len ) ; if ( ! fields -> Buffer ) return - 1 ; Stream_SetPosition ( s , fields -> BufferOffset ) ; Stream_Read ( s , fields -> Buffer , fields -> Len ) ; } return 1 ; }
CWE-125 <S2SV_StartBug> int ntlm_read_message_header ( wStream * s , NTLM_MESSAGE_HEADER * header ) <S2SV_EndBug> { if ( Stream_GetRemainingLength ( s ) < 12 ) return - 1 ; Stream_Read ( s , header -> Signature , 8 ) ; Stream_Read_UINT32 ( s , header -> MessageType ) ; if ( strncmp ( ( char * ) header -> Signature , NTLM_SIGNATURE , 8 ) != 0 ) return - 1 ; return 1 ; }
CWE-125 <S2SV_StartBug> void ntlm_write_message_fields ( wStream * s , NTLM_MESSAGE_FIELDS * fields ) <S2SV_EndBug> { if ( fields -> MaxLen < 1 ) fields -> MaxLen = fields -> Len ; Stream_Write_UINT16 ( s , fields -> Len ) ; Stream_Write_UINT16 ( s , fields -> MaxLen ) ; Stream_Write_UINT32 ( s , fields -> BufferOffset ) ; }
CWE-125 <S2SV_StartBug> void ntlm_write_message_fields_buffer ( wStream * s , NTLM_MESSAGE_FIELDS * fields ) <S2SV_EndBug> { if ( fields -> Len > 0 ) { Stream_SetPosition ( s , fields -> BufferOffset ) ; Stream_Write ( s , fields -> Buffer , fields -> Len ) ; } }
CWE-125 <S2SV_StartBug> void ntlm_write_message_header ( wStream * s , NTLM_MESSAGE_HEADER * header ) <S2SV_EndBug> { Stream_Write ( s , header -> Signature , sizeof ( NTLM_SIGNATURE ) ) ; Stream_Write_UINT32 ( s , header -> MessageType ) ; }
CWE-119 BITMAP_UPDATE * update_read_bitmap_update ( rdpUpdate * update , wStream * s ) { UINT32 i ; BITMAP_UPDATE * bitmapUpdate = calloc ( 1 , sizeof ( BITMAP_UPDATE ) ) ; if ( ! bitmapUpdate ) goto fail ; if ( Stream_GetRemainingLength ( s ) < 2 ) goto fail ; Stream_Read_UINT16 ( s , bitmapUpdate -> number ) ; WLog_Print ( update -> log , WLOG_TRACE , "BitmapUpdate:<S2SV_blank>%" PRIu32 "" , bitmapUpdate -> number ) ; if ( bitmapUpdate -> number > bitmapUpdate -> count ) { <S2SV_StartBug> UINT16 count ; <S2SV_EndBug> BITMAP_DATA * newdata ; count = bitmapUpdate -> number * 2 ; <S2SV_StartBug> newdata = ( BITMAP_DATA * ) realloc ( bitmapUpdate -> rectangles , <S2SV_EndBug> sizeof ( BITMAP_DATA ) * count ) ; if ( ! newdata ) goto fail ; bitmapUpdate -> rectangles = newdata ; ZeroMemory ( & bitmapUpdate -> rectangles [ bitmapUpdate -> count ] , sizeof ( BITMAP_DATA ) * ( count - bitmapUpdate -> count ) ) ; bitmapUpdate -> count = count ; } for ( i = 0 ; i < bitmapUpdate -> number ; i ++ ) { if ( ! update_read_bitmap_data ( update , s , & bitmapUpdate -> rectangles [ i ] ) ) goto fail ; } return bitmapUpdate ; fail : free_bitmap_update ( update -> context , bitmapUpdate ) ; return NULL ; }
CWE-787 <S2SV_StartBug> static void nsc_decode ( NSC_CONTEXT * context ) <S2SV_EndBug> { UINT16 x ; UINT16 y ; <S2SV_StartBug> UINT16 rw = ROUND_UP_TO ( context -> width , 8 ) ; <S2SV_EndBug> <S2SV_StartBug> BYTE shift = context -> ColorLossLevel - 1 ; <S2SV_EndBug> <S2SV_StartBug> BYTE * bmpdata = context -> BitmapData ; <S2SV_EndBug> for ( y = 0 ; y < context -> height ; y ++ ) { const BYTE * yplane ; const BYTE * coplane ; const BYTE * cgplane ; const BYTE * aplane = context -> priv -> PlaneBuffers [ 3 ] + y * context -> width ; if ( context -> ChromaSubsamplingLevel ) { yplane = context -> priv -> PlaneBuffers [ 0 ] + y * rw ; coplane = context -> priv -> PlaneBuffers [ 1 ] + ( y >> 1 ) * ( rw >> 1 ) ; cgplane = context -> priv -> PlaneBuffers [ 2 ] + ( y >> 1 ) * ( rw >> 1 ) ; } else { yplane = context -> priv -> PlaneBuffers [ 0 ] + y * context -> width ; coplane = context -> priv -> PlaneBuffers [ 1 ] + y * context -> width ; cgplane = context -> priv -> PlaneBuffers [ 2 ] + y * context -> width ; } for ( x = 0 ; x < context -> width ; x ++ ) { INT16 y_val = ( INT16 ) * yplane ; INT16 co_val = ( INT16 ) ( INT8 ) ( * coplane << shift ) ; INT16 cg_val = ( INT16 ) ( INT8 ) ( * cgplane << shift ) ; INT16 r_val = y_val + co_val - cg_val ; INT16 g_val = y_val + cg_val ; INT16 b_val = y_val - co_val - cg_val ; <S2SV_StartBug> * bmpdata ++ = MINMAX ( b_val , 0 , 0xFF ) ; <S2SV_EndBug> * bmpdata ++ = MINMAX ( g_val , 0 , 0xFF ) ; * bmpdata ++ = MINMAX ( r_val , 0 , 0xFF ) ; * bmpdata ++ = * aplane ; yplane ++ ; coplane += ( context -> ChromaSubsamplingLevel ? x % 2 : 1 ) ; cgplane += ( context -> ChromaSubsamplingLevel ? x % 2 : 1 ) ; aplane ++ ; } } <S2SV_StartBug> } <S2SV_EndBug>
CWE-787 BOOL nsc_process_message ( NSC_CONTEXT * context , UINT16 bpp , UINT32 width , UINT32 height , const BYTE * data , UINT32 length , BYTE * pDstData , UINT32 DstFormat , UINT32 nDstStride , UINT32 nXDst , UINT32 nYDst , UINT32 nWidth , UINT32 nHeight , UINT32 flip ) { wStream * s ; BOOL ret ; s = Stream_New ( ( BYTE * ) data , length ) ; if ( ! s ) return FALSE ; if ( nDstStride == 0 ) nDstStride = nWidth * GetBytesPerPixel ( DstFormat ) ; switch ( bpp ) { case 32 : context -> format = PIXEL_FORMAT_BGRA32 ; break ; case 24 : context -> format = PIXEL_FORMAT_BGR24 ; break ; case 16 : context -> format = PIXEL_FORMAT_BGR16 ; break ; case 8 : context -> format = PIXEL_FORMAT_RGB8 ; break ; case 4 : context -> format = PIXEL_FORMAT_A4 ; break ; default : Stream_Free ( s , TRUE ) ; return FALSE ; } context -> width = width ; context -> height = height ; ret = nsc_context_initialize ( context , s ) ; Stream_Free ( s , FALSE ) ; if ( ! ret ) return FALSE ; <S2SV_StartBug> PROFILER_ENTER ( context -> priv -> prof_nsc_rle_decompress_data ) <S2SV_EndBug> <S2SV_StartBug> nsc_rle_decompress_data ( context ) ; <S2SV_EndBug> PROFILER_EXIT ( context -> priv -> prof_nsc_rle_decompress_data ) <S2SV_StartBug> PROFILER_ENTER ( context -> priv -> prof_nsc_decode ) <S2SV_EndBug> <S2SV_StartBug> context -> decode ( context ) ; <S2SV_EndBug> <S2SV_StartBug> PROFILER_EXIT ( context -> priv -> prof_nsc_decode ) <S2SV_EndBug> if ( ! freerdp_image_copy ( pDstData , DstFormat , nDstStride , nXDst , nYDst , width , height , context -> BitmapData , PIXEL_FORMAT_BGRA32 , 0 , 0 , 0 , NULL , flip ) ) return FALSE ; return TRUE ; }
CWE-787 <S2SV_StartBug> static void nsc_rle_decode ( BYTE * in , BYTE * out , UINT32 originalSize ) <S2SV_EndBug> { UINT32 len ; UINT32 left ; BYTE value ; left = originalSize ; while ( left > 4 ) { value = * in ++ ; if ( left == 5 ) { <S2SV_StartBug> * out ++ = value ; <S2SV_EndBug> left -- ; } else if ( value == * in ) { in ++ ; if ( * in < 0xFF ) { len = ( UINT32 ) * in ++ ; len += 2 ; } else { in ++ ; len = * ( ( UINT32 * ) in ) ; in += 4 ; } <S2SV_StartBug> FillMemory ( out , len , value ) ; <S2SV_EndBug> out += len ; left -= len ; } else { <S2SV_StartBug> * out ++ = value ; <S2SV_EndBug> left -- ; } } * ( ( UINT32 * ) out ) = * ( ( UINT32 * ) in ) ; }
CWE-787 <S2SV_StartBug> static void nsc_rle_decompress_data ( NSC_CONTEXT * context ) <S2SV_EndBug> { UINT16 i ; BYTE * rle ; UINT32 planeSize ; UINT32 originalSize ; <S2SV_StartBug> rle = context -> Planes ; <S2SV_EndBug> for ( i = 0 ; i < 4 ; i ++ ) { originalSize = context -> OrgByteCount [ i ] ; planeSize = context -> PlaneByteCount [ i ] ; if ( planeSize == 0 ) <S2SV_StartBug> FillMemory ( context -> priv -> PlaneBuffers [ i ] , originalSize , 0xFF ) ; <S2SV_EndBug> <S2SV_StartBug> else if ( planeSize < originalSize ) <S2SV_EndBug> <S2SV_StartBug> nsc_rle_decode ( rle , context -> priv -> PlaneBuffers [ i ] , originalSize ) ; <S2SV_EndBug> else CopyMemory ( context -> priv -> PlaneBuffers [ i ] , rle , originalSize ) ; <S2SV_StartBug> rle += planeSize ; <S2SV_EndBug> } <S2SV_StartBug> } <S2SV_EndBug>
CWE-787 <S2SV_StartBug> void nsc_encode ( NSC_CONTEXT * context , const BYTE * bmpdata , UINT32 rowstride ) <S2SV_EndBug> { <S2SV_StartBug> nsc_encode_argb_to_aycocg ( context , bmpdata , rowstride ) ; <S2SV_EndBug> if ( context -> ChromaSubsamplingLevel ) { <S2SV_StartBug> nsc_encode_subsampling ( context ) ; <S2SV_EndBug> } }
CWE-787 <S2SV_StartBug> static void nsc_encode_argb_to_aycocg ( NSC_CONTEXT * context , const BYTE * data , <S2SV_EndBug> UINT32 scanline ) { UINT16 x ; UINT16 y ; UINT16 rw ; BYTE ccl ; const BYTE * src ; BYTE * yplane = NULL ; BYTE * coplane = NULL ; BYTE * cgplane = NULL ; BYTE * aplane = NULL ; INT16 r_val ; INT16 g_val ; INT16 b_val ; BYTE a_val ; <S2SV_StartBug> UINT32 tempWidth ; <S2SV_EndBug> tempWidth = ROUND_UP_TO ( context -> width , 8 ) ; rw = ( context -> ChromaSubsamplingLevel ? tempWidth : context -> width ) ; ccl = context -> ColorLossLevel ; <S2SV_StartBug> for ( y = 0 ; y < context -> height ; y ++ ) <S2SV_EndBug> { src = data + ( context -> height - 1 - y ) * scanline ; yplane = context -> priv -> PlaneBuffers [ 0 ] + y * rw ; coplane = context -> priv -> PlaneBuffers [ 1 ] + y * rw ; cgplane = context -> priv -> PlaneBuffers [ 2 ] + y * rw ; aplane = context -> priv -> PlaneBuffers [ 3 ] + y * context -> width ; for ( x = 0 ; x < context -> width ; x ++ ) { switch ( context -> format ) { case PIXEL_FORMAT_BGRX32 : b_val = * src ++ ; g_val = * src ++ ; r_val = * src ++ ; src ++ ; a_val = 0xFF ; break ; case PIXEL_FORMAT_BGRA32 : b_val = * src ++ ; g_val = * src ++ ; r_val = * src ++ ; a_val = * src ++ ; break ; case PIXEL_FORMAT_RGBX32 : r_val = * src ++ ; g_val = * src ++ ; b_val = * src ++ ; src ++ ; a_val = 0xFF ; break ; case PIXEL_FORMAT_RGBA32 : r_val = * src ++ ; g_val = * src ++ ; b_val = * src ++ ; a_val = * src ++ ; break ; case PIXEL_FORMAT_BGR24 : b_val = * src ++ ; g_val = * src ++ ; r_val = * src ++ ; a_val = 0xFF ; break ; case PIXEL_FORMAT_RGB24 : r_val = * src ++ ; g_val = * src ++ ; b_val = * src ++ ; a_val = 0xFF ; break ; case PIXEL_FORMAT_BGR16 : b_val = ( INT16 ) ( ( ( * ( src + 1 ) ) & 0xF8 ) | ( ( * ( src + 1 ) ) >> 5 ) ) ; g_val = ( INT16 ) ( ( ( ( * ( src + 1 ) ) & 0x07 ) << 5 ) | ( ( ( * src ) & 0xE0 ) >> 3 ) ) ; r_val = ( INT16 ) ( ( ( ( * src ) & 0x1F ) << 3 ) | ( ( ( * src ) >> 2 ) & 0x07 ) ) ; a_val = 0xFF ; src += 2 ; break ; case PIXEL_FORMAT_RGB16 : r_val = ( INT16 ) ( ( ( * ( src + 1 ) ) & 0xF8 ) | ( ( * ( src + 1 ) ) >> 5 ) ) ; g_val = ( INT16 ) ( ( ( ( * ( src + 1 ) ) & 0x07 ) << 5 ) | ( ( ( * src ) & 0xE0 ) >> 3 ) ) ; b_val = ( INT16 ) ( ( ( ( * src ) & 0x1F ) << 3 ) | ( ( ( * src ) >> 2 ) & 0x07 ) ) ; a_val = 0xFF ; src += 2 ; break ; case PIXEL_FORMAT_A4 : { int shift ; BYTE idx ; shift = ( 7 - ( x % 8 ) ) ; idx = ( ( * src ) >> shift ) & 1 ; idx |= ( ( ( * ( src + 1 ) ) >> shift ) & 1 ) << 1 ; idx |= ( ( ( * ( src + 2 ) ) >> shift ) & 1 ) << 2 ; idx |= ( ( ( * ( src + 3 ) ) >> shift ) & 1 ) << 3 ; idx *= 3 ; r_val = ( INT16 ) context -> palette [ idx ] ; g_val = ( INT16 ) context -> palette [ idx + 1 ] ; b_val = ( INT16 ) context -> palette [ idx + 2 ] ; if ( shift == 0 ) src += 4 ; } a_val = 0xFF ; break ; case PIXEL_FORMAT_RGB8 : { int idx = ( * src ) * 3 ; r_val = ( INT16 ) context -> palette [ idx ] ; g_val = ( INT16 ) context -> palette [ idx + 1 ] ; b_val = ( INT16 ) context -> palette [ idx + 2 ] ; src ++ ; } a_val = 0xFF ; break ; default : r_val = g_val = b_val = a_val = 0 ; break ; } * yplane ++ = ( BYTE ) ( ( r_val >> 2 ) + ( g_val >> 1 ) + ( b_val >> 2 ) ) ; * coplane ++ = ( BYTE ) ( ( r_val - b_val ) >> ccl ) ; * cgplane ++ = ( BYTE ) ( ( - ( r_val >> 1 ) + g_val - ( b_val >> 1 ) ) >> ccl ) ; * aplane ++ = a_val ; } if ( context -> ChromaSubsamplingLevel && ( x % 2 ) == 1 ) { * yplane = * ( yplane - 1 ) ; * coplane = * ( coplane - 1 ) ; * cgplane = * ( cgplane - 1 ) ; } } if ( context -> ChromaSubsamplingLevel && ( y % 2 ) == 1 ) { yplane = context -> priv -> PlaneBuffers [ 0 ] + y * rw ; coplane = context -> priv -> PlaneBuffers [ 1 ] + y * rw ; cgplane = context -> priv -> PlaneBuffers [ 2 ] + y * rw ; CopyMemory ( yplane , yplane - rw , rw ) ; CopyMemory ( coplane , coplane - rw , rw ) ; CopyMemory ( cgplane , cgplane - rw , rw ) ; } <S2SV_StartBug> } <S2SV_EndBug>
CWE-787 <S2SV_StartBug> static void nsc_encode_subsampling ( NSC_CONTEXT * context ) <S2SV_EndBug> { UINT16 x ; UINT16 y ; <S2SV_StartBug> BYTE * co_dst ; <S2SV_EndBug> BYTE * cg_dst ; INT8 * co_src0 ; INT8 * co_src1 ; INT8 * cg_src0 ; INT8 * cg_src1 ; UINT32 tempWidth ; <S2SV_StartBug> UINT32 tempHeight ; <S2SV_EndBug> tempWidth = ROUND_UP_TO ( context -> width , 8 ) ; tempHeight = ROUND_UP_TO ( context -> height , 2 ) ; <S2SV_StartBug> for ( y = 0 ; y < tempHeight >> 1 ; y ++ ) <S2SV_EndBug> { <S2SV_StartBug> co_dst = context -> priv -> PlaneBuffers [ 1 ] + y * ( tempWidth >> 1 ) ; <S2SV_EndBug> <S2SV_StartBug> cg_dst = context -> priv -> PlaneBuffers [ 2 ] + y * ( tempWidth >> 1 ) ; <S2SV_EndBug> <S2SV_StartBug> co_src0 = ( INT8 * ) context -> priv -> PlaneBuffers [ 1 ] + ( y << 1 ) * tempWidth ; <S2SV_EndBug> <S2SV_StartBug> co_src1 = co_src0 + tempWidth ; <S2SV_EndBug> <S2SV_StartBug> cg_src0 = ( INT8 * ) context -> priv -> PlaneBuffers [ 2 ] + ( y << 1 ) * tempWidth ; <S2SV_EndBug> <S2SV_StartBug> cg_src1 = cg_src0 + tempWidth ; <S2SV_EndBug> for ( x = 0 ; x < tempWidth >> 1 ; x ++ ) { * co_dst ++ = ( BYTE ) ( ( ( INT16 ) * co_src0 + ( INT16 ) * ( co_src0 + 1 ) + ( INT16 ) * co_src1 + ( INT16 ) * ( co_src1 + 1 ) ) >> 2 ) ; * cg_dst ++ = ( BYTE ) ( ( ( INT16 ) * cg_src0 + ( INT16 ) * ( cg_src0 + 1 ) + ( INT16 ) * cg_src1 + ( INT16 ) * ( cg_src1 + 1 ) ) >> 2 ) ; co_src0 += 2 ; co_src1 += 2 ; cg_src0 += 2 ; cg_src1 += 2 ; } } <S2SV_StartBug> } <S2SV_EndBug>
CWE-787 <S2SV_StartBug> static UINT32 nsc_rle_encode ( BYTE * in , BYTE * out , UINT32 originalSize ) <S2SV_EndBug> { UINT32 left ; UINT32 runlength = 1 ; UINT32 planeSize = 0 ; left = originalSize ; while ( left > 4 && planeSize < originalSize - 4 ) { if ( left > 5 && * in == * ( in + 1 ) ) { runlength ++ ; } else if ( runlength == 1 ) { * out ++ = * in ; planeSize ++ ; } else if ( runlength < 256 ) { * out ++ = * in ; * out ++ = * in ; * out ++ = runlength - 2 ; runlength = 1 ; planeSize += 3 ; } else { * out ++ = * in ; * out ++ = * in ; * out ++ = 0xFF ; * out ++ = ( runlength & 0x000000FF ) ; * out ++ = ( runlength & 0x0000FF00 ) >> 8 ; * out ++ = ( runlength & 0x00FF0000 ) >> 16 ; * out ++ = ( runlength & 0xFF000000 ) >> 24 ; runlength = 1 ; planeSize += 7 ; } in ++ ; left -- ; } if ( planeSize < originalSize - 4 ) CopyMemory ( out , in , 4 ) ; planeSize += 4 ; return planeSize ; }
CWE-787 <S2SV_StartBug> static void nsc_encode_sse2 ( NSC_CONTEXT * context , const BYTE * data , <S2SV_EndBug> UINT32 scanline ) { nsc_encode_argb_to_aycocg_sse2 ( context , data , scanline ) ; if ( context -> ChromaSubsamplingLevel > 0 ) { nsc_encode_subsampling_sse2 ( context ) ; } <S2SV_StartBug> } <S2SV_EndBug>
CWE-20 static void gimp_write_and_read_file ( Gimp * gimp , gboolean with_unusual_stuff , gboolean compat_paths , gboolean use_gimp_2_8_features ) { GimpImage * image ; GimpImage * loaded_image ; GimpPlugInProcedure * proc ; <S2SV_StartBug> gchar * filename ; <S2SV_EndBug> GFile * file ; image = gimp_create_mainimage ( gimp , with_unusual_stuff , compat_paths , use_gimp_2_8_features ) ; gimp_assert_mainimage ( image , with_unusual_stuff , compat_paths , use_gimp_2_8_features ) ; <S2SV_StartBug> filename = g_build_filename ( g_get_tmp_dir ( ) , "gimp-test.xcf" , NULL ) ; <S2SV_EndBug> file = g_file_new_for_path ( filename ) ; g_free ( filename ) ; proc = gimp_plug_in_manager_file_procedure_find ( image -> gimp -> plug_in_manager , GIMP_FILE_PROCEDURE_GROUP_SAVE , file , NULL ) ; file_save ( gimp , image , NULL , file , proc , GIMP_RUN_NONINTERACTIVE , FALSE , FALSE , FALSE , NULL ) ; loaded_image = gimp_test_load_image ( image -> gimp , file ) ; gimp_assert_mainimage ( loaded_image , with_unusual_stuff , compat_paths , use_gimp_2_8_features ) ; g_file_delete ( file , NULL , NULL ) ; g_object_unref ( file ) ; }
CWE-119 gboolean _pango_emoji_iter_next ( PangoEmojiIter * iter ) { PangoEmojiType current_emoji_type = PANGO_EMOJI_TYPE_INVALID ; if ( iter -> end == iter -> text_end ) return FALSE ; iter -> start = iter -> end ; for ( ; iter -> end < iter -> text_end ; iter -> end = g_utf8_next_char ( iter -> end ) ) { gunichar ch = g_utf8_get_char ( iter -> end ) ; if ( ( ! ( ch == kZeroWidthJoinerCharacter && ! iter -> is_emoji ) && ch != kVariationSelector15Character && ch != kVariationSelector16Character && ch != kCombiningEnclosingCircleBackslashCharacter && ! _pango_Is_Regional_Indicator ( ch ) && ! ( ( ch == kLeftSpeechBubbleCharacter || ch == kRainbowCharacter || ch == kMaleSignCharacter || ch == kFemaleSignCharacter || ch == kStaffOfAesculapiusCharacter ) && ! iter -> is_emoji ) ) || current_emoji_type == PANGO_EMOJI_TYPE_INVALID ) { current_emoji_type = _pango_get_emoji_type ( ch ) ; } if ( g_utf8_next_char ( iter -> end ) < iter -> text_end ) { gunichar peek_char = g_utf8_get_char ( g_utf8_next_char ( iter -> end ) ) ; if ( current_emoji_type == PANGO_EMOJI_TYPE_EMOJI_EMOJI && peek_char == kVariationSelector15Character ) { current_emoji_type = PANGO_EMOJI_TYPE_EMOJI_TEXT ; } if ( ( current_emoji_type == PANGO_EMOJI_TYPE_EMOJI_TEXT || _pango_Is_Emoji_Keycap_Base ( ch ) ) && peek_char == kVariationSelector16Character ) { current_emoji_type = PANGO_EMOJI_TYPE_EMOJI_EMOJI ; } if ( _pango_Is_Emoji_Keycap_Base ( ch ) && peek_char == kCombiningEnclosingKeycapCharacter ) { current_emoji_type = PANGO_EMOJI_TYPE_EMOJI_EMOJI ; } ; if ( _pango_Is_Regional_Indicator ( ch ) && _pango_Is_Regional_Indicator ( peek_char ) ) { current_emoji_type = PANGO_EMOJI_TYPE_EMOJI_EMOJI ; } if ( ( ch == kEyeCharacter || ch == kWavingWhiteFlagCharacter ) && peek_char == kZeroWidthJoinerCharacter ) { current_emoji_type = PANGO_EMOJI_TYPE_EMOJI_EMOJI ; } } if ( iter -> is_emoji == ( gboolean ) 2 ) iter -> is_emoji = ! PANGO_EMOJI_TYPE_IS_EMOJI ( current_emoji_type ) ; if ( iter -> is_emoji == PANGO_EMOJI_TYPE_IS_EMOJI ( current_emoji_type ) ) { iter -> is_emoji = ! PANGO_EMOJI_TYPE_IS_EMOJI ( current_emoji_type ) ; <S2SV_StartBug> return TRUE ; <S2SV_EndBug> } } iter -> is_emoji = PANGO_EMOJI_TYPE_IS_EMOJI ( current_emoji_type ) ; return TRUE ; }
CWE-119 static PixelChannels * * AcquirePixelThreadSet ( const Image * images ) { const Image * next ; PixelChannels * * pixels ; register ssize_t i ; size_t columns , <S2SV_StartBug> number_threads ; <S2SV_EndBug> <S2SV_StartBug> number_threads = ( size_t ) GetMagickResourceLimit ( ThreadResource ) ; <S2SV_EndBug> <S2SV_StartBug> pixels = ( PixelChannels * * ) AcquireQuantumMemory ( number_threads , <S2SV_EndBug> sizeof ( * pixels ) ) ; if ( pixels == ( PixelChannels * * ) NULL ) return ( ( PixelChannels * * ) NULL ) ; <S2SV_StartBug> ( void ) memset ( pixels , 0 , number_threads * sizeof ( * pixels ) ) ; <S2SV_EndBug> columns = images -> columns ; for ( next = images ; next != ( Image * ) NULL ; next = next -> next ) columns = MagickMax ( next -> columns , columns ) ; <S2SV_StartBug> for ( i = 0 ; i < ( ssize_t ) number_threads ; i ++ ) <S2SV_EndBug> { register ssize_t j ; pixels [ i ] = ( PixelChannels * ) AcquireQuantumMemory ( columns , sizeof ( * * pixels ) ) ; if ( pixels [ i ] == ( PixelChannels * ) NULL ) return ( DestroyPixelThreadSet ( pixels ) ) ; for ( j = 0 ; j < ( ssize_t ) columns ; j ++ ) { register ssize_t k ; for ( k = 0 ; k < MaxPixelChannels ; k ++ ) pixels [ i ] [ j ] . channel [ k ] = 0.0 ; } } return ( pixels ) ; }
CWE-20 static Image * ReadDCMImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { <S2SV_StartBug> # define ThrowDCMException ( exception , message ) { if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; if ( stream_info != ( DCMStreamInfo * ) NULL ) stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; ThrowReaderException ( ( exception ) , ( message ) ) ; } <S2SV_EndBug> char explicit_vr [ MagickPathExtent ] , implicit_vr [ MagickPathExtent ] , magick [ MagickPathExtent ] , photometric [ MagickPathExtent ] ; DCMInfo info ; DCMStreamInfo * stream_info ; Image * image ; int * bluemap , datum , * greenmap , * graymap , * redmap ; MagickBooleanType explicit_file , explicit_retry , use_explicit ; MagickOffsetType offset ; register unsigned char * p ; register ssize_t i ; size_t colors , height , length , number_scenes , quantum , status , width ; ssize_t count , scene ; unsigned char * data ; unsigned short group , element ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image -> depth = 8UL ; image -> endian = LSBEndian ; ( void ) memset ( & info , 0 , sizeof ( info ) ) ; data = ( unsigned char * ) NULL ; graymap = ( int * ) NULL ; redmap = ( int * ) NULL ; greenmap = ( int * ) NULL ; bluemap = ( int * ) NULL ; stream_info = ( DCMStreamInfo * ) AcquireMagickMemory ( sizeof ( * stream_info ) ) ; if ( stream_info == ( DCMStreamInfo * ) NULL ) ThrowDCMException ( ResourceLimitError , "MemoryAllocationFailed" ) ; ( void ) memset ( stream_info , 0 , sizeof ( * stream_info ) ) ; count = ReadBlob ( image , 128 , ( unsigned char * ) magick ) ; if ( count != 128 ) ThrowDCMException ( CorruptImageError , "ImproperImageHeader" ) ; count = ReadBlob ( image , 4 , ( unsigned char * ) magick ) ; if ( ( count != 4 ) || ( LocaleNCompare ( magick , "DICM" , 4 ) != 0 ) ) { offset = SeekBlob ( image , 0L , SEEK_SET ) ; if ( offset < 0 ) ThrowDCMException ( CorruptImageError , "ImproperImageHeader" ) ; } ( void ) CopyMagickString ( photometric , "MONOCHROME1<S2SV_blank>" , MagickPathExtent ) ; info . bits_allocated = 8 ; info . bytes_per_pixel = 1 ; info . depth = 8 ; info . mask = 0xffff ; info . max_value = 255UL ; info . samples_per_pixel = 1 ; info . signed_data = ( ~ 0UL ) ; info . rescale_slope = 1.0 ; data = ( unsigned char * ) NULL ; element = 0 ; explicit_vr [ 2 ] = '\\0' ; explicit_file = MagickFalse ; colors = 0 ; redmap = ( int * ) NULL ; greenmap = ( int * ) NULL ; bluemap = ( int * ) NULL ; graymap = ( int * ) NULL ; height = 0 ; number_scenes = 1 ; use_explicit = MagickFalse ; explicit_retry = MagickFalse ; width = 0 ; while ( TellBlob ( image ) < ( MagickOffsetType ) GetBlobSize ( image ) ) { for ( group = 0 ; ( group != 0x7FE0 ) || ( element != 0x0010 ) ; ) { image -> offset = ( ssize_t ) TellBlob ( image ) ; group = ReadBlobLSBShort ( image ) ; element = ReadBlobLSBShort ( image ) ; if ( ( group == 0xfffc ) && ( element == 0xfffc ) ) break ; if ( ( group != 0x0002 ) && ( image -> endian == MSBEndian ) ) { group = ( unsigned short ) ( ( group << 8 ) | ( ( group >> 8 ) & 0xFF ) ) ; element = ( unsigned short ) ( ( element << 8 ) | ( ( element >> 8 ) & 0xFF ) ) ; } quantum = 0 ; for ( i = 0 ; dicom_info [ i ] . group < 0xffff ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; ( void ) CopyMagickString ( implicit_vr , dicom_info [ i ] . vr , MagickPathExtent ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) explicit_vr ) ; if ( count != 2 ) ThrowDCMException ( CorruptImageError , "ImproperImageHeader" ) ; if ( ( explicit_file == MagickFalse ) && ( group != 0x0002 ) ) explicit_file = ( isupper ( ( unsigned char ) * explicit_vr ) != MagickFalse ) && ( isupper ( ( unsigned char ) * ( explicit_vr + 1 ) ) != MagickFalse ) ? MagickTrue : MagickFalse ; use_explicit = ( ( group == 0x0002 ) && ( explicit_retry == MagickFalse ) ) || ( explicit_file != MagickFalse ) ? MagickTrue : MagickFalse ; if ( ( use_explicit != MagickFalse ) && ( strncmp ( implicit_vr , "xs" , 2 ) == 0 ) ) ( void ) CopyMagickString ( implicit_vr , explicit_vr , MagickPathExtent ) ; if ( ( use_explicit == MagickFalse ) || ( strncmp ( implicit_vr , "!!" , 2 ) == 0 ) ) { offset = SeekBlob ( image , ( MagickOffsetType ) - 2 , SEEK_CUR ) ; if ( offset < 0 ) ThrowDCMException ( CorruptImageError , "ImproperImageHeader" ) ; quantum = 4 ; } else { quantum = 2 ; if ( ( strncmp ( explicit_vr , "OB" , 2 ) == 0 ) || ( strncmp ( explicit_vr , "UN" , 2 ) == 0 ) || ( strncmp ( explicit_vr , "OW" , 2 ) == 0 ) || ( strncmp ( explicit_vr , "SQ" , 2 ) == 0 ) ) { ( void ) ReadBlobLSBShort ( image ) ; quantum = 4 ; } } datum = 0 ; if ( quantum == 4 ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedLong ( image ) ; else datum = ReadBlobSignedLong ( image ) ; } else if ( quantum == 2 ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedShort ( image ) ; else datum = ReadBlobSignedShort ( image ) ; } quantum = 0 ; length = 1 ; if ( datum != 0 ) { if ( ( strncmp ( implicit_vr , "OW" , 2 ) == 0 ) || ( strncmp ( implicit_vr , "SS" , 2 ) == 0 ) || ( strncmp ( implicit_vr , "US" , 2 ) == 0 ) ) quantum = 2 ; else if ( ( strncmp ( implicit_vr , "FL" , 2 ) == 0 ) || ( strncmp ( implicit_vr , "OF" , 2 ) == 0 ) || ( strncmp ( implicit_vr , "SL" , 2 ) == 0 ) || ( strncmp ( implicit_vr , "UL" , 2 ) == 0 ) ) quantum = 4 ; else if ( strncmp ( implicit_vr , "FD" , 2 ) == 0 ) quantum = 8 ; else quantum = 1 ; if ( datum != ~ 0 ) length = ( size_t ) datum / quantum ; else { quantum = 0 ; length = 0 ; } } if ( image_info -> verbose != MagickFalse ) { if ( use_explicit == MagickFalse ) explicit_vr [ 0 ] = '\\0' ; for ( i = 0 ; dicom_info [ i ] . description != ( char * ) NULL ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; ( void ) FormatLocaleFile ( stdout , "0x%04lX<S2SV_blank>%4ld<S2SV_blank>%s-%s<S2SV_blank>(0x%04lx,0x%04lx)" , ( unsigned long ) image -> offset , ( long ) length , implicit_vr , explicit_vr , ( unsigned long ) group , ( unsigned long ) element ) ; if ( dicom_info [ i ] . description != ( char * ) NULL ) ( void ) FormatLocaleFile ( stdout , "<S2SV_blank>%s" , dicom_info [ i ] . description ) ; ( void ) FormatLocaleFile ( stdout , ":<S2SV_blank>" ) ; } if ( ( group == 0x7FE0 ) && ( element == 0x0010 ) ) { if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , "\\n" ) ; break ; } data = ( unsigned char * ) NULL ; if ( ( length == 1 ) && ( quantum == 1 ) ) datum = ReadBlobByte ( image ) ; else if ( ( length == 1 ) && ( quantum == 2 ) ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedShort ( image ) ; else datum = ReadBlobSignedShort ( image ) ; } else if ( ( length == 1 ) && ( quantum == 4 ) ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedLong ( image ) ; else datum = ReadBlobSignedLong ( image ) ; } else if ( ( quantum != 0 ) && ( length != 0 ) ) { if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , "InsufficientImageDataInFile" ) ; if ( ~ length >= 1 ) data = ( unsigned char * ) AcquireQuantumMemory ( length + 1 , quantum * sizeof ( * data ) ) ; if ( data == ( unsigned char * ) NULL ) ThrowDCMException ( ResourceLimitError , "MemoryAllocationFailed" ) ; count = ReadBlob ( image , ( size_t ) quantum * length , data ) ; if ( count != ( ssize_t ) ( quantum * length ) ) { if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , "count=%d<S2SV_blank>quantum=%d<S2SV_blank>" "length=%d<S2SV_blank>group=%d\\n" , ( int ) count , ( int ) quantum , ( int ) length , ( int ) group ) ; ThrowDCMException ( CorruptImageError , "InsufficientImageDataInFile" ) ; } data [ length * quantum ] = '\\0' ; } if ( ( ( ( unsigned int ) group << 16 ) | element ) == 0xFFFEE0DD ) { if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; continue ; } switch ( group ) { case 0x0002 : { switch ( element ) { case 0x0010 : { char transfer_syntax [ MagickPathExtent ] ; if ( ( datum == 0 ) && ( explicit_retry == MagickFalse ) ) { explicit_retry = MagickTrue ; ( void ) SeekBlob ( image , ( MagickOffsetType ) 0 , SEEK_SET ) ; group = 0 ; element = 0 ; if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , "Corrupted<S2SV_blank>image<S2SV_blank>-<S2SV_blank>trying<S2SV_blank>explicit<S2SV_blank>format\\n" ) ; break ; } * transfer_syntax = '\\0' ; if ( data != ( unsigned char * ) NULL ) ( void ) CopyMagickString ( transfer_syntax , ( char * ) data , MagickPathExtent ) ; if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , "transfer_syntax=%s\\n" , ( const char * ) transfer_syntax ) ; if ( strncmp ( transfer_syntax , "1.2.840.10008.1.2" , 17 ) == 0 ) { int subtype , type ; type = 1 ; subtype = 0 ; if ( strlen ( transfer_syntax ) > 17 ) { count = ( ssize_t ) sscanf ( transfer_syntax + 17 , ".%d.%d" , & type , & subtype ) ; if ( count < 1 ) ThrowDCMException ( CorruptImageError , "ImproperImageHeader" ) ; } switch ( type ) { case 1 : { image -> endian = LSBEndian ; break ; } case 2 : { image -> endian = MSBEndian ; break ; } case 4 : { if ( ( subtype >= 80 ) && ( subtype <= 81 ) ) image -> compression = JPEGCompression ; else if ( ( subtype >= 90 ) && ( subtype <= 93 ) ) image -> compression = JPEG2000Compression ; else image -> compression = JPEGCompression ; break ; } case 5 : { image -> compression = RLECompression ; break ; } } } break ; } default : break ; } break ; } case 0x0028 : { switch ( element ) { case 0x0002 : { info . samples_per_pixel = ( size_t ) datum ; if ( ( info . samples_per_pixel == 0 ) || ( info . samples_per_pixel > 4 ) ) ThrowDCMException ( CorruptImageError , "ImproperImageHeader" ) ; break ; } case 0x0004 : { if ( data == ( unsigned char * ) NULL ) break ; for ( i = 0 ; i < ( ssize_t ) MagickMin ( length , MagickPathExtent - 1 ) ; i ++ ) photometric [ i ] = ( char ) data [ i ] ; photometric [ i ] = '\\0' ; info . polarity = LocaleCompare ( photometric , "MONOCHROME1<S2SV_blank>" ) == 0 ? MagickTrue : MagickFalse ; break ; } case 0x0006 : { if ( datum == 1 ) image -> interlace = PlaneInterlace ; break ; } case 0x0008 : { if ( data == ( unsigned char * ) NULL ) break ; number_scenes = StringToUnsignedLong ( ( char * ) data ) ; break ; } case 0x0010 : { height = ( size_t ) datum ; break ; } case 0x0011 : { width = ( size_t ) datum ; break ; } case 0x0100 : { info . bits_allocated = ( size_t ) datum ; info . bytes_per_pixel = 1 ; if ( datum > 8 ) info . bytes_per_pixel = 2 ; info . depth = info . bits_allocated ; if ( ( info . depth == 0 ) || ( info . depth > 32 ) ) ThrowDCMException ( CorruptImageError , "ImproperImageHeader" ) ; info . max_value = ( 1UL << info . bits_allocated ) - 1 ; image -> depth = info . depth ; break ; } case 0x0101 : { info . significant_bits = ( size_t ) datum ; info . bytes_per_pixel = 1 ; if ( info . significant_bits > 8 ) info . bytes_per_pixel = 2 ; info . depth = info . significant_bits ; if ( ( info . depth == 0 ) || ( info . depth > 16 ) ) ThrowDCMException ( CorruptImageError , "ImproperImageHeader" ) ; info . max_value = ( 1UL << info . significant_bits ) - 1 ; info . mask = ( size_t ) GetQuantumRange ( info . significant_bits ) ; image -> depth = info . depth ; break ; } case 0x0102 : { break ; } case 0x0103 : { info . signed_data = ( size_t ) datum ; break ; } case 0x1050 : { if ( data != ( unsigned char * ) NULL ) info . window_center = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1051 : { if ( data != ( unsigned char * ) NULL ) info . window_width = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1052 : { if ( data != ( unsigned char * ) NULL ) info . rescale_intercept = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1053 : { if ( data != ( unsigned char * ) NULL ) info . rescale_slope = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1200 : case 0x3006 : { if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / info . bytes_per_pixel ) ; datum = ( int ) colors ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; graymap = ( int * ) AcquireQuantumMemory ( MagickMax ( colors , 65536 ) , sizeof ( * graymap ) ) ; if ( graymap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , "MemoryAllocationFailed" ) ; ( void ) memset ( graymap , 0 , MagickMax ( colors , 65536 ) * sizeof ( * graymap ) ) ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) if ( info . bytes_per_pixel == 1 ) graymap [ i ] = ( int ) data [ i ] ; else graymap [ i ] = ( int ) ( ( short * ) data ) [ i ] ; break ; } case 0x1201 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; redmap = ( int * ) AcquireQuantumMemory ( MagickMax ( colors , 65536 ) , sizeof ( * redmap ) ) ; if ( redmap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , "MemoryAllocationFailed" ) ; ( void ) memset ( redmap , 0 , MagickMax ( colors , 65536 ) * sizeof ( * redmap ) ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; redmap [ i ] = ( int ) index ; p += 2 ; } break ; } case 0x1202 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; greenmap = ( int * ) AcquireQuantumMemory ( MagickMax ( colors , 65536 ) , sizeof ( * greenmap ) ) ; if ( greenmap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , "MemoryAllocationFailed" ) ; ( void ) memset ( greenmap , 0 , MagickMax ( colors , 65536 ) * sizeof ( * greenmap ) ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; greenmap [ i ] = ( int ) index ; p += 2 ; } break ; } case 0x1203 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; bluemap = ( int * ) AcquireQuantumMemory ( MagickMax ( colors , 65536 ) , sizeof ( * bluemap ) ) ; if ( bluemap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , "MemoryAllocationFailed" ) ; ( void ) memset ( bluemap , 0 , MagickMax ( colors , 65536 ) * sizeof ( * bluemap ) ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; bluemap [ i ] = ( int ) index ; p += 2 ; } break ; } default : break ; } break ; } case 0x2050 : { switch ( element ) { case 0x0020 : { if ( ( data != ( unsigned char * ) NULL ) && ( strncmp ( ( char * ) data , "INVERSE" , 7 ) == 0 ) ) info . polarity = MagickTrue ; break ; } default : break ; } break ; } default : break ; } if ( data != ( unsigned char * ) NULL ) { char * attribute ; for ( i = 0 ; dicom_info [ i ] . description != ( char * ) NULL ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; if ( dicom_info [ i ] . description != ( char * ) NULL ) { attribute = AcquireString ( "dcm:" ) ; ( void ) ConcatenateString ( & attribute , dicom_info [ i ] . description ) ; for ( i = 0 ; i < ( ssize_t ) MagickMax ( length , 4 ) ; i ++ ) if ( isprint ( ( int ) data [ i ] ) == MagickFalse ) break ; if ( ( i == ( ssize_t ) length ) || ( length > 4 ) ) { ( void ) SubstituteString ( & attribute , "<S2SV_blank>" , "" ) ; ( void ) SetImageProperty ( image , attribute , ( char * ) data , exception ) ; } attribute = DestroyString ( attribute ) ; } } if ( image_info -> verbose != MagickFalse ) { if ( data == ( unsigned char * ) NULL ) ( void ) FormatLocaleFile ( stdout , "%d\\n" , datum ) ; else { for ( i = 0 ; i < ( ssize_t ) MagickMax ( length , 4 ) ; i ++ ) if ( isprint ( ( int ) data [ i ] ) == MagickFalse ) break ; if ( ( i != ( ssize_t ) length ) && ( length <= 4 ) ) { ssize_t j ; datum = 0 ; for ( j = ( ssize_t ) length - 1 ; j >= 0 ; j -- ) datum = ( 256 * datum + data [ j ] ) ; ( void ) FormatLocaleFile ( stdout , "%d" , datum ) ; } else for ( i = 0 ; i < ( ssize_t ) length ; i ++ ) if ( isprint ( ( int ) data [ i ] ) != MagickFalse ) ( void ) FormatLocaleFile ( stdout , "%c" , data [ i ] ) ; else ( void ) FormatLocaleFile ( stdout , "%c" , '.' ) ; ( void ) FormatLocaleFile ( stdout , "\\n" ) ; } } if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , "UnexpectedEndOfFile" , image -> filename ) ; break ; } } if ( ( group == 0xfffc ) && ( element == 0xfffc ) ) { Image * last ; last = RemoveLastImageFromList ( & image ) ; if ( last != ( Image * ) NULL ) last = DestroyImage ( last ) ; break ; } if ( ( width == 0 ) || ( height == 0 ) ) ThrowDCMException ( CorruptImageError , "ImproperImageHeader" ) ; image -> columns = ( size_t ) width ; image -> rows = ( size_t ) height ; if ( info . signed_data == 0xffff ) info . signed_data = ( size_t ) ( info . significant_bits == 16 ? 1 : 0 ) ; if ( ( image -> compression == JPEGCompression ) || ( image -> compression == JPEG2000Compression ) ) { Image * images ; ImageInfo * read_info ; int c ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; ( void ) ( ( ( ssize_t ) ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ) ; length = ( size_t ) ReadBlobLSBLong ( image ) ; if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , "InsufficientImageDataInFile" ) ; stream_info -> offset_count = length >> 2 ; if ( stream_info -> offset_count != 0 ) { if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; stream_info -> offsets = ( ssize_t * ) AcquireQuantumMemory ( stream_info -> offset_count , sizeof ( * stream_info -> offsets ) ) ; if ( stream_info -> offsets == ( ssize_t * ) NULL ) ThrowDCMException ( ResourceLimitError , "MemoryAllocationFailed" ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; offset = TellBlob ( image ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] += offset ; } read_info = CloneImageInfo ( image_info ) ; SetImageInfoBlob ( read_info , ( void * ) NULL , 0 ) ; images = NewImageList ( ) ; for ( scene = 0 ; scene < ( ssize_t ) number_scenes ; scene ++ ) { char filename [ MagickPathExtent ] ; const char * property ; FILE * file ; Image * jpeg_image ; int unique_file ; unsigned int tag ; tag = ( ( unsigned int ) ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; length = ( size_t ) ReadBlobLSBLong ( image ) ; <S2SV_StartBug> if ( tag == 0xFFFEE0DD ) <S2SV_EndBug> break ; if ( tag != 0xFFFEE000 ) { read_info = DestroyImageInfo ( read_info ) ; ThrowDCMException ( CorruptImageError , "ImproperImageHeader" ) ; } file = ( FILE * ) NULL ; unique_file = AcquireUniqueFileResource ( filename ) ; if ( unique_file != - 1 ) file = fdopen ( unique_file , "wb" ) ; if ( file == ( FILE * ) NULL ) { ( void ) RelinquishUniqueFileResource ( filename ) ; ThrowFileException ( exception , FileOpenError , "UnableToCreateTemporaryFile" , filename ) ; break ; } for ( c = EOF ; length != 0 ; length -- ) { c = ReadBlobByte ( image ) ; if ( c == EOF ) { ThrowFileException ( exception , CorruptImageError , "UnexpectedEndOfFile" , image -> filename ) ; break ; } if ( fputc ( c , file ) != c ) break ; } ( void ) fclose ( file ) ; if ( c == EOF ) break ; ( void ) FormatLocaleString ( read_info -> filename , MagickPathExtent , "jpeg:%s" , filename ) ; if ( image -> compression == JPEG2000Compression ) ( void ) FormatLocaleString ( read_info -> filename , MagickPathExtent , "j2k:%s" , filename ) ; jpeg_image = ReadImage ( read_info , exception ) ; if ( jpeg_image != ( Image * ) NULL ) { ResetImagePropertyIterator ( image ) ; property = GetNextImageProperty ( image ) ; while ( property != ( const char * ) NULL ) { ( void ) SetImageProperty ( jpeg_image , property , GetImageProperty ( image , property , exception ) , exception ) ; property = GetNextImageProperty ( image ) ; } AppendImageToList ( & images , jpeg_image ) ; } ( void ) RelinquishUniqueFileResource ( filename ) ; } read_info = DestroyImageInfo ( read_info ) ; if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; image = DestroyImageList ( image ) ; return ( GetFirstImageInList ( images ) ) ; } if ( info . depth != ( 1UL * MAGICKCORE_QUANTUM_DEPTH ) ) { QuantumAny range ; length = ( size_t ) ( GetQuantumRange ( info . depth ) + 1 ) ; if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , "InsufficientImageDataInFile" ) ; if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; info . scale = ( Quantum * ) AcquireQuantumMemory ( MagickMax ( length , 256 ) , sizeof ( * info . scale ) ) ; if ( info . scale == ( Quantum * ) NULL ) ThrowDCMException ( ResourceLimitError , "MemoryAllocationFailed" ) ; ( void ) memset ( info . scale , 0 , MagickMax ( length , 256 ) * sizeof ( * info . scale ) ) ; range = GetQuantumRange ( info . depth ) ; for ( i = 0 ; i <= ( ssize_t ) GetQuantumRange ( info . depth ) ; i ++ ) info . scale [ i ] = ScaleAnyToQuantum ( ( size_t ) i , range ) ; } if ( image -> compression == RLECompression ) { unsigned int tag ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) { int c ; c = ReadBlobByte ( image ) ; if ( c == EOF ) break ; } tag = ( ( unsigned int ) ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; ( void ) tag ; length = ( size_t ) ReadBlobLSBLong ( image ) ; if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , "InsufficientImageDataInFile" ) ; stream_info -> offset_count = length >> 2 ; if ( stream_info -> offset_count != 0 ) { if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; stream_info -> offsets = ( ssize_t * ) AcquireQuantumMemory ( stream_info -> offset_count , sizeof ( * stream_info -> offsets ) ) ; if ( stream_info -> offsets == ( ssize_t * ) NULL ) ThrowDCMException ( ResourceLimitError , "MemoryAllocationFailed" ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) { stream_info -> offsets [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) break ; } offset = TellBlob ( image ) + 8 ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] += offset ; } } for ( scene = 0 ; scene < ( ssize_t ) number_scenes ; scene ++ ) { image -> columns = ( size_t ) width ; image -> rows = ( size_t ) height ; image -> depth = info . depth ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) break ; image -> colorspace = RGBColorspace ; ( void ) SetImageBackgroundColor ( image , exception ) ; if ( ( image -> colormap == ( PixelInfo * ) NULL ) && ( info . samples_per_pixel == 1 ) ) { int index ; size_t one ; one = 1 ; if ( colors == 0 ) colors = one << info . depth ; if ( AcquireImageColormap ( image , colors , exception ) == MagickFalse ) ThrowDCMException ( ResourceLimitError , "MemoryAllocationFailed" ) ; if ( redmap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = redmap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index >= 0 ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . red = ( MagickRealType ) index ; } if ( greenmap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = greenmap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index >= 0 ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . green = ( MagickRealType ) index ; } if ( bluemap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = bluemap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index >= 0 ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . blue = ( MagickRealType ) index ; } if ( graymap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = graymap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index >= 0 ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . red = ( MagickRealType ) index ; image -> colormap [ i ] . green = ( MagickRealType ) index ; image -> colormap [ i ] . blue = ( MagickRealType ) index ; } } if ( image -> compression == RLECompression ) { unsigned int tag ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) { int c ; c = ReadBlobByte ( image ) ; if ( c == EOF ) break ; } tag = ( ( unsigned int ) ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; stream_info -> remaining = ( size_t ) ReadBlobLSBLong ( image ) ; if ( ( tag != 0xFFFEE000 ) || ( stream_info -> remaining <= 64 ) || ( EOFBlob ( image ) != MagickFalse ) ) { if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; ThrowDCMException ( CorruptImageError , "ImproperImageHeader" ) ; } stream_info -> count = 0 ; stream_info -> segment_count = ReadBlobLSBLong ( image ) ; for ( i = 0 ; i < 15 ; i ++ ) stream_info -> segments [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; stream_info -> remaining -= 64 ; if ( stream_info -> segment_count > 1 ) { info . bytes_per_pixel = 1 ; info . depth = 8 ; if ( stream_info -> offset_count > 0 ) ( void ) SeekBlob ( image , ( MagickOffsetType ) stream_info -> offsets [ 0 ] + stream_info -> segments [ 0 ] , SEEK_SET ) ; } } if ( ( info . samples_per_pixel > 1 ) && ( image -> interlace == PlaneInterlace ) ) { register ssize_t x ; register Quantum * q ; ssize_t y ; for ( i = 0 ; i < ( ssize_t ) info . samples_per_pixel ; i ++ ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = GetAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { switch ( ( int ) i ) { case 0 : { SetPixelRed ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } case 1 : { SetPixelGreen ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } case 2 : { SetPixelBlue ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } case 3 : { SetPixelAlpha ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } default : break ; } q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } } else { const char * option ; option = GetImageOption ( image_info , "dcm:display-range" ) ; if ( option != ( const char * ) NULL ) { if ( LocaleCompare ( option , "reset" ) == 0 ) info . window_width = 0 ; } option = GetImageOption ( image_info , "dcm:window" ) ; if ( option != ( char * ) NULL ) { GeometryInfo geometry_info ; MagickStatusType flags ; flags = ParseGeometry ( option , & geometry_info ) ; if ( flags & RhoValue ) info . window_center = geometry_info . rho ; if ( flags & SigmaValue ) info . window_width = geometry_info . sigma ; info . rescale = MagickTrue ; } option = GetImageOption ( image_info , "dcm:rescale" ) ; if ( option != ( char * ) NULL ) info . rescale = IsStringTrue ( option ) ; if ( ( info . window_center != 0 ) && ( info . window_width == 0 ) ) info . window_width = info . window_center ; status = ReadDCMPixels ( image , & info , stream_info , MagickTrue , exception ) ; if ( ( status != MagickFalse ) && ( stream_info -> segment_count > 1 ) ) { if ( stream_info -> offset_count > 0 ) ( void ) SeekBlob ( image , ( MagickOffsetType ) stream_info -> offsets [ 0 ] + stream_info -> segments [ 1 ] , SEEK_SET ) ; ( void ) ReadDCMPixels ( image , & info , stream_info , MagickFalse , exception ) ; } } if ( SetImageGray ( image , exception ) != MagickFalse ) ( void ) SetImageColorspace ( image , GRAYColorspace , exception ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , "UnexpectedEndOfFile" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; if ( scene < ( ssize_t ) ( number_scenes - 1 ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { status = MagickFalse ; break ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } if ( TellBlob ( image ) < ( MagickOffsetType ) GetBlobSize ( image ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { status = MagickFalse ; break ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; if ( image == ( Image * ) NULL ) return ( image ) ; ( void ) CloseBlob ( image ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; return ( GetFirstImageInList ( image ) ) ; }
CWE-399 static MagickBooleanType DecodeImage ( Image * image , unsigned char * luma , unsigned char * chroma1 , unsigned char * chroma2 , ExceptionInfo * exception ) { # define IsSync ( sum ) ( ( sum & 0xffffff00UL ) == 0xfffffe00UL ) <S2SV_StartBug> # define PCDGetBits ( n ) { sum = ( sum << n ) & 0xffffffff ; bits -= n ; while ( bits <= 24 ) { if ( p >= ( buffer + 0x800 ) ) { count = ReadBlob ( image , 0x800 , buffer ) ; p = buffer ; } sum |= ( ( unsigned int ) ( * p ) << ( 24 - bits ) ) ; bits += 8 ; p ++ ; } } <S2SV_EndBug> typedef struct PCDTable { unsigned int length , sequence ; MagickStatusType mask ; unsigned char key ; } PCDTable ; PCDTable * pcd_table [ 3 ] ; register ssize_t i , j ; register PCDTable * r ; register unsigned char * p , * q ; size_t bits , length , plane , pcd_length [ 3 ] , row , sum ; ssize_t count , quantum ; unsigned char * buffer ; assert ( image != ( const Image * ) NULL ) ; assert ( image -> signature == MagickCoreSignature ) ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , image -> filename ) ; assert ( luma != ( unsigned char * ) NULL ) ; assert ( chroma1 != ( unsigned char * ) NULL ) ; assert ( chroma2 != ( unsigned char * ) NULL ) ; buffer = ( unsigned char * ) AcquireQuantumMemory ( 0x800 , sizeof ( * buffer ) ) ; if ( buffer == ( unsigned char * ) NULL ) ThrowBinaryException ( ResourceLimitError , "MemoryAllocationFailed" , image -> filename ) ; sum = 0 ; bits = 32 ; p = buffer + 0x800 ; for ( i = 0 ; i < 3 ; i ++ ) { pcd_table [ i ] = ( PCDTable * ) NULL ; pcd_length [ i ] = 0 ; } for ( i = 0 ; i < ( image -> columns > 1536 ? 3 : 1 ) ; i ++ ) { PCDGetBits ( 8 ) ; length = ( sum & 0xff ) + 1 ; pcd_table [ i ] = ( PCDTable * ) AcquireQuantumMemory ( length , sizeof ( * pcd_table [ i ] ) ) ; if ( pcd_table [ i ] == ( PCDTable * ) NULL ) { buffer = ( unsigned char * ) RelinquishMagickMemory ( buffer ) ; <S2SV_StartBug> ThrowBinaryException ( ResourceLimitError , "MemoryAllocationFailed" , <S2SV_EndBug> image -> filename ) ; } r = pcd_table [ i ] ; for ( j = 0 ; j < ( ssize_t ) length ; j ++ ) { PCDGetBits ( 8 ) ; r -> length = ( unsigned int ) ( sum & 0xff ) + 1 ; if ( r -> length > 16 ) { <S2SV_StartBug> buffer = ( unsigned char * ) RelinquishMagickMemory ( buffer ) ; <S2SV_EndBug> return ( MagickFalse ) ; } PCDGetBits ( 16 ) ; r -> sequence = ( unsigned int ) ( sum & 0xffff ) << 16 ; PCDGetBits ( 8 ) ; r -> key = ( unsigned char ) ( sum & 0xff ) ; r -> mask = ( ~ ( ( 1U << ( 32 - r -> length ) ) - 1 ) ) ; r ++ ; } pcd_length [ i ] = ( size_t ) length ; } for ( i = 0 ; i < 1 ; i ++ ) PCDGetBits ( 16 ) ; for ( i = 0 ; i < 1 ; i ++ ) PCDGetBits ( 16 ) ; while ( ( sum & 0x00fff000UL ) != 0x00fff000UL ) PCDGetBits ( 8 ) ; while ( IsSync ( sum ) == 0 ) PCDGetBits ( 1 ) ; count = 0 ; length = 0 ; plane = 0 ; row = 0 ; q = luma ; for ( ; ; ) { if ( IsSync ( sum ) != 0 ) { PCDGetBits ( 16 ) ; row = ( ( sum >> 9 ) & 0x1fff ) ; if ( row == image -> rows ) break ; PCDGetBits ( 8 ) ; plane = sum >> 30 ; PCDGetBits ( 16 ) ; switch ( plane ) { case 0 : { q = luma + row * image -> columns ; count = ( ssize_t ) image -> columns ; break ; } case 2 : { q = chroma1 + ( row >> 1 ) * image -> columns ; count = ( ssize_t ) ( image -> columns >> 1 ) ; plane -- ; break ; } case 3 : { q = chroma2 + ( row >> 1 ) * image -> columns ; count = ( ssize_t ) ( image -> columns >> 1 ) ; plane -- ; break ; } default : { for ( i = 0 ; i < ( image -> columns > 1536 ? 3 : 1 ) ; i ++ ) pcd_table [ i ] = ( PCDTable * ) RelinquishMagickMemory ( pcd_table [ i ] ) ; buffer = ( unsigned char * ) RelinquishMagickMemory ( buffer ) ; ThrowBinaryException ( CorruptImageError , "CorruptImage" , image -> filename ) ; } } length = pcd_length [ plane ] ; continue ; } r = pcd_table [ plane ] ; for ( i = 0 ; ( ( i < ( ssize_t ) length ) && ( ( sum & r -> mask ) != r -> sequence ) ) ; i ++ ) r ++ ; if ( ( row > image -> rows ) || ( r == ( PCDTable * ) NULL ) ) { ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , CorruptImageWarning , "SkipToSyncByte" , "`%s\'" , image -> filename ) ; while ( ( sum & 0x00fff000 ) != 0x00fff000 ) PCDGetBits ( 8 ) ; while ( IsSync ( sum ) == 0 ) PCDGetBits ( 1 ) ; continue ; } if ( r -> key < 128 ) quantum = ( ssize_t ) ( * q ) + r -> key ; else quantum = ( ssize_t ) ( * q ) + r -> key - 256 ; * q = ( unsigned char ) ( ( quantum < 0 ) ? 0 : ( quantum > 255 ) ? 255 : quantum ) ; q ++ ; PCDGetBits ( r -> length ) ; count -- ; } for ( i = 0 ; i < ( image -> columns > 1536 ? 3 : 1 ) ; i ++ ) pcd_table [ i ] = ( PCDTable * ) RelinquishMagickMemory ( pcd_table [ i ] ) ; buffer = ( unsigned char * ) RelinquishMagickMemory ( buffer ) ; return ( MagickTrue ) ; }
CWE-200 static Image * ReadXBMImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char buffer [ MagickPathExtent ] , name [ MagickPathExtent ] ; Image * image ; int c ; MagickBooleanType status ; register ssize_t i , x ; register Quantum * q ; register unsigned char * p ; short int hex_digits [ 256 ] ; ssize_t y ; unsigned char * data ; unsigned int bit , byte , bytes_per_line , height , length , padding , version , width ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } width = 0 ; height = 0 ; * name = '\\0' ; while ( ReadBlobString ( image , buffer ) != ( char * ) NULL ) if ( sscanf ( buffer , "#define<S2SV_blank>%1024s<S2SV_blank>%u" , name , & width ) == 2 ) if ( ( strlen ( name ) >= 6 ) && ( LocaleCompare ( name + strlen ( name ) - 6 , "_width" ) == 0 ) ) break ; while ( ReadBlobString ( image , buffer ) != ( char * ) NULL ) if ( sscanf ( buffer , "#define<S2SV_blank>%1024s<S2SV_blank>%u" , name , & height ) == 2 ) if ( ( strlen ( name ) >= 7 ) && ( LocaleCompare ( name + strlen ( name ) - 7 , "_height" ) == 0 ) ) break ; image -> columns = width ; image -> rows = height ; image -> depth = 8 ; image -> storage_class = PseudoClass ; image -> colors = 2 ; version = 11 ; while ( ReadBlobString ( image , buffer ) != ( char * ) NULL ) { if ( sscanf ( buffer , "static<S2SV_blank>short<S2SV_blank>%1024s<S2SV_blank>=<S2SV_blank>{" , name ) == 1 ) version = 10 ; else if ( sscanf ( buffer , "static<S2SV_blank>unsigned<S2SV_blank>char<S2SV_blank>%1024s<S2SV_blank>=<S2SV_blank>{" , name ) == 1 ) version = 11 ; else if ( sscanf ( buffer , "static<S2SV_blank>char<S2SV_blank>%1024s<S2SV_blank>=<S2SV_blank>{" , name ) == 1 ) version = 11 ; else continue ; p = ( unsigned char * ) strrchr ( name , '_' ) ; if ( p == ( unsigned char * ) NULL ) p = ( unsigned char * ) name ; else p ++ ; if ( LocaleCompare ( "bits[]" , ( char * ) p ) == 0 ) break ; } if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) || ( EOFBlob ( image ) != MagickFalse ) ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; image -> colormap [ 0 ] . red = ( MagickRealType ) QuantumRange ; image -> colormap [ 0 ] . green = ( MagickRealType ) QuantumRange ; image -> colormap [ 0 ] . blue = ( MagickRealType ) QuantumRange ; image -> colormap [ 1 ] . red = 0.0 ; image -> colormap [ 1 ] . green = 0.0 ; image -> colormap [ 1 ] . blue = 0.0 ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; for ( i = 0 ; i < ( ssize_t ) ( sizeof ( hex_digits ) / sizeof ( * hex_digits ) ) ; i ++ ) hex_digits [ i ] = ( - 1 ) ; hex_digits [ ( int ) '0' ] = 0 ; hex_digits [ ( int ) '1' ] = 1 ; hex_digits [ ( int ) '2' ] = 2 ; hex_digits [ ( int ) '3' ] = 3 ; hex_digits [ ( int ) '4' ] = 4 ; hex_digits [ ( int ) '5' ] = 5 ; hex_digits [ ( int ) '6' ] = 6 ; hex_digits [ ( int ) '7' ] = 7 ; hex_digits [ ( int ) '8' ] = 8 ; hex_digits [ ( int ) '9' ] = 9 ; hex_digits [ ( int ) 'A' ] = 10 ; hex_digits [ ( int ) 'B' ] = 11 ; hex_digits [ ( int ) 'C' ] = 12 ; hex_digits [ ( int ) 'D' ] = 13 ; hex_digits [ ( int ) 'E' ] = 14 ; hex_digits [ ( int ) 'F' ] = 15 ; hex_digits [ ( int ) 'a' ] = 10 ; hex_digits [ ( int ) 'b' ] = 11 ; hex_digits [ ( int ) 'c' ] = 12 ; hex_digits [ ( int ) 'd' ] = 13 ; hex_digits [ ( int ) 'e' ] = 14 ; hex_digits [ ( int ) 'f' ] = 15 ; hex_digits [ ( int ) 'x' ] = 0 ; hex_digits [ ( int ) '<S2SV_blank>' ] = ( - 1 ) ; hex_digits [ ( int ) ',' ] = ( - 1 ) ; hex_digits [ ( int ) '}' ] = ( - 1 ) ; hex_digits [ ( int ) '\\n' ] = ( - 1 ) ; hex_digits [ ( int ) '\\t' ] = ( - 1 ) ; padding = 0 ; if ( ( ( image -> columns % 16 ) != 0 ) && ( ( image -> columns % 16 ) < 9 ) && ( version == 10 ) ) padding = 1 ; bytes_per_line = ( unsigned int ) ( image -> columns + 7 ) / 8 + padding ; length = ( unsigned int ) image -> rows ; data = ( unsigned char * ) AcquireQuantumMemory ( length , bytes_per_line * sizeof ( * data ) ) ; if ( data == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; p = data ; if ( version == 10 ) for ( i = 0 ; i < ( ssize_t ) ( bytes_per_line * image -> rows ) ; ( i += 2 ) ) { c = XBMInteger ( image , hex_digits ) ; if ( c < 0 ) <S2SV_StartBug> break ; <S2SV_EndBug> * p ++ = ( unsigned char ) c ; if ( ( padding == 0 ) || ( ( ( i + 2 ) % bytes_per_line ) != 0 ) ) * p ++ = ( unsigned char ) ( c >> 8 ) ; } else for ( i = 0 ; i < ( ssize_t ) ( bytes_per_line * image -> rows ) ; i ++ ) { c = XBMInteger ( image , hex_digits ) ; if ( c < 0 ) <S2SV_StartBug> break ; <S2SV_EndBug> * p ++ = ( unsigned char ) c ; } if ( EOFBlob ( image ) != MagickFalse ) { data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; ThrowReaderException ( CorruptImageError , "UnexpectedEndOfFile" ) ; } p = data ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; bit = 0 ; byte = 0 ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( bit == 0 ) byte = ( unsigned int ) ( * p ++ ) ; SetPixelIndex ( image , ( Quantum ) ( ( byte & 0x01 ) != 0 ? 0x01 : 0x00 ) , q ) ; bit ++ ; byte >>= 1 ; if ( bit == 8 ) bit = 0 ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; ( void ) SyncImage ( image , exception ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
CWE-399 static Image * ReadPSImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define BoundingBox "BoundingBox:" # define BeginDocument "BeginDocument:" # define BeginXMPPacket "<?xpacket<S2SV_blank>begin=" # define EndXMPPacket "<?xpacket<S2SV_blank>end=" # define ICCProfile "BeginICCProfile:" # define CMYKCustomColor "CMYKCustomColor:" # define CMYKProcessColor "CMYKProcessColor:" # define DocumentMedia "DocumentMedia:" # define DocumentCustomColors "DocumentCustomColors:" # define DocumentProcessColors "DocumentProcessColors:" # define EndDocument "EndDocument:" # define HiResBoundingBox "HiResBoundingBox:" # define ImageData "ImageData:" # define PageBoundingBox "PageBoundingBox:" # define LanguageLevel "LanguageLevel:" # define PageMedia "PageMedia:" # define Pages "Pages:" # define PhotoshopProfile "BeginPhotoshop:" # define PostscriptLevel "!PS-" # define RenderPostscriptText "<S2SV_blank><S2SV_blank>Rendering<S2SV_blank>Postscript...<S2SV_blank><S2SV_blank>" # define SpotColor "+<S2SV_blank>" char command [ MagickPathExtent ] , * density , filename [ MagickPathExtent ] , geometry [ MagickPathExtent ] , input_filename [ MagickPathExtent ] , message [ MagickPathExtent ] , * options , postscript_filename [ MagickPathExtent ] ; const char * option ; const DelegateInfo * delegate_info ; GeometryInfo geometry_info ; Image * image , * next , * postscript_image ; ImageInfo * read_info ; int c , file ; MagickBooleanType cmyk , fitPage , skip , status ; MagickStatusType flags ; PointInfo delta , resolution ; RectangleInfo page ; register char * p ; register ssize_t i ; SegmentInfo bounds , hires_bounds ; short int hex_digits [ 256 ] ; size_t length ; ssize_t count , priority ; StringInfo * profile ; unsigned long columns , extent , language_level , pages , rows , scene , spotcolor ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } status = AcquireUniqueSymbolicLink ( image_info -> filename , input_filename ) ; if ( status == MagickFalse ) { ThrowFileException ( exception , FileOpenError , "UnableToCreateTemporaryFile" , image_info -> filename ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) memset ( hex_digits , 0 , sizeof ( hex_digits ) ) ; hex_digits [ ( int ) '0' ] = 0 ; hex_digits [ ( int ) '1' ] = 1 ; hex_digits [ ( int ) '2' ] = 2 ; hex_digits [ ( int ) '3' ] = 3 ; hex_digits [ ( int ) '4' ] = 4 ; hex_digits [ ( int ) '5' ] = 5 ; hex_digits [ ( int ) '6' ] = 6 ; hex_digits [ ( int ) '7' ] = 7 ; hex_digits [ ( int ) '8' ] = 8 ; hex_digits [ ( int ) '9' ] = 9 ; hex_digits [ ( int ) 'a' ] = 10 ; hex_digits [ ( int ) 'b' ] = 11 ; hex_digits [ ( int ) 'c' ] = 12 ; hex_digits [ ( int ) 'd' ] = 13 ; hex_digits [ ( int ) 'e' ] = 14 ; hex_digits [ ( int ) 'f' ] = 15 ; hex_digits [ ( int ) 'A' ] = 10 ; hex_digits [ ( int ) 'B' ] = 11 ; hex_digits [ ( int ) 'C' ] = 12 ; hex_digits [ ( int ) 'D' ] = 13 ; hex_digits [ ( int ) 'E' ] = 14 ; hex_digits [ ( int ) 'F' ] = 15 ; delta . x = DefaultResolution ; delta . y = DefaultResolution ; if ( ( image -> resolution . x == 0.0 ) || ( image -> resolution . y == 0.0 ) ) { flags = ParseGeometry ( PSDensityGeometry , & geometry_info ) ; image -> resolution . x = geometry_info . rho ; image -> resolution . y = geometry_info . sigma ; if ( ( flags & SigmaValue ) == 0 ) image -> resolution . y = image -> resolution . x ; } if ( image_info -> density != ( char * ) NULL ) { flags = ParseGeometry ( image_info -> density , & geometry_info ) ; image -> resolution . x = geometry_info . rho ; image -> resolution . y = geometry_info . sigma ; if ( ( flags & SigmaValue ) == 0 ) image -> resolution . y = image -> resolution . x ; } ( void ) ParseAbsoluteGeometry ( PSPageGeometry , & page ) ; if ( image_info -> page != ( char * ) NULL ) ( void ) ParseAbsoluteGeometry ( image_info -> page , & page ) ; resolution = image -> resolution ; page . width = ( size_t ) ceil ( ( double ) ( page . width * resolution . x / delta . x ) - 0.5 ) ; page . height = ( size_t ) ceil ( ( double ) ( page . height * resolution . y / delta . y ) - 0.5 ) ; ( void ) memset ( & bounds , 0 , sizeof ( bounds ) ) ; ( void ) memset ( command , 0 , sizeof ( command ) ) ; cmyk = image_info -> colorspace == CMYKColorspace ? MagickTrue : MagickFalse ; ( void ) memset ( & hires_bounds , 0 , sizeof ( hires_bounds ) ) ; columns = 0 ; rows = 0 ; priority = 0 ; rows = 0 ; extent = 0 ; spotcolor = 0 ; language_level = 1 ; pages = ( ~ 0UL ) ; skip = MagickFalse ; p = command ; for ( c = ReadBlobByte ( image ) ; c != EOF ; c = ReadBlobByte ( image ) ) { * p ++ = ( char ) c ; if ( ( strchr ( "\\n\\r%" , c ) == ( char * ) NULL ) && ( ( size_t ) ( p - command ) < ( MagickPathExtent - 1 ) ) ) continue ; * p = '\\0' ; p = command ; if ( LocaleNCompare ( BeginDocument , command , strlen ( BeginDocument ) ) == 0 ) skip = MagickTrue ; if ( LocaleNCompare ( EndDocument , command , strlen ( EndDocument ) ) == 0 ) skip = MagickFalse ; if ( skip != MagickFalse ) continue ; if ( LocaleNCompare ( PostscriptLevel , command , strlen ( PostscriptLevel ) ) == 0 ) { ( void ) SetImageProperty ( image , "ps:Level" , command + 4 , exception ) ; if ( GlobExpression ( command , "*EPSF-*" , MagickTrue ) != MagickFalse ) pages = 1 ; } if ( LocaleNCompare ( LanguageLevel , command , strlen ( LanguageLevel ) ) == 0 ) ( void ) sscanf ( command , LanguageLevel "<S2SV_blank>%lu" , & language_level ) ; if ( LocaleNCompare ( Pages , command , strlen ( Pages ) ) == 0 ) ( void ) sscanf ( command , Pages "<S2SV_blank>%lu" , & pages ) ; if ( LocaleNCompare ( ImageData , command , strlen ( ImageData ) ) == 0 ) ( void ) sscanf ( command , ImageData "<S2SV_blank>%lu<S2SV_blank>%lu" , & columns , & rows ) ; length = strlen ( DocumentProcessColors ) ; if ( LocaleNCompare ( DocumentProcessColors , command , length ) == 0 ) { if ( ( GlobExpression ( command , "*Cyan*" , MagickTrue ) != MagickFalse ) || ( GlobExpression ( command , "*Magenta*" , MagickTrue ) != MagickFalse ) || ( GlobExpression ( command , "*Yellow*" , MagickTrue ) != MagickFalse ) ) cmyk = MagickTrue ; } if ( LocaleNCompare ( CMYKCustomColor , command , strlen ( CMYKCustomColor ) ) == 0 ) cmyk = MagickTrue ; if ( LocaleNCompare ( CMYKProcessColor , command , strlen ( CMYKProcessColor ) ) == 0 ) cmyk = MagickTrue ; length = strlen ( DocumentCustomColors ) ; if ( ( LocaleNCompare ( DocumentCustomColors , command , length ) == 0 ) || ( LocaleNCompare ( CMYKCustomColor , command , strlen ( CMYKCustomColor ) ) == 0 ) || ( LocaleNCompare ( SpotColor , command , strlen ( SpotColor ) ) == 0 ) ) { char property [ MagickPathExtent ] , * value ; register char * q ; ( void ) FormatLocaleString ( property , MagickPathExtent , "ps:SpotColor-%.20g" , ( double ) ( spotcolor ++ ) ) ; for ( q = command ; * q != '\\0' ; q ++ ) if ( isspace ( ( int ) ( unsigned char ) * q ) != 0 ) break ; value = ConstantString ( q ) ; ( void ) SubstituteString ( & value , "(" , "" ) ; ( void ) SubstituteString ( & value , ")" , "" ) ; ( void ) StripString ( value ) ; if ( * value != '\\0' ) ( void ) SetImageProperty ( image , property , value , exception ) ; value = DestroyString ( value ) ; continue ; } if ( image_info -> page != ( char * ) NULL ) continue ; count = 0 ; i = 0 ; if ( LocaleNCompare ( BoundingBox , command , strlen ( BoundingBox ) ) == 0 ) { count = ( ssize_t ) sscanf ( command , BoundingBox "<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf" , & bounds . x1 , & bounds . y1 , & bounds . x2 , & bounds . y2 ) ; i = 2 ; } if ( LocaleNCompare ( DocumentMedia , command , strlen ( DocumentMedia ) ) == 0 ) { count = ( ssize_t ) sscanf ( command , DocumentMedia "<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf" , & bounds . x1 , & bounds . y1 , & bounds . x2 , & bounds . y2 ) ; i = 1 ; } if ( LocaleNCompare ( HiResBoundingBox , command , strlen ( HiResBoundingBox ) ) == 0 ) { count = ( ssize_t ) sscanf ( command , HiResBoundingBox "<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf" , & bounds . x1 , & bounds . y1 , & bounds . x2 , & bounds . y2 ) ; i = 3 ; } if ( LocaleNCompare ( PageBoundingBox , command , strlen ( PageBoundingBox ) ) == 0 ) { count = ( ssize_t ) sscanf ( command , PageBoundingBox "<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf" , & bounds . x1 , & bounds . y1 , & bounds . x2 , & bounds . y2 ) ; i = 1 ; } if ( LocaleNCompare ( PageMedia , command , strlen ( PageMedia ) ) == 0 ) { count = ( ssize_t ) sscanf ( command , PageMedia "<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf" , & bounds . x1 , & bounds . y1 , & bounds . x2 , & bounds . y2 ) ; i = 1 ; } if ( ( count != 4 ) || ( i < ( ssize_t ) priority ) ) continue ; if ( ( fabs ( bounds . x2 - bounds . x1 ) <= fabs ( hires_bounds . x2 - hires_bounds . x1 ) ) || ( fabs ( bounds . y2 - bounds . y1 ) <= fabs ( hires_bounds . y2 - hires_bounds . y1 ) ) ) if ( i == ( ssize_t ) priority ) continue ; hires_bounds = bounds ; priority = i ; } if ( ( fabs ( hires_bounds . x2 - hires_bounds . x1 ) >= MagickEpsilon ) && ( fabs ( hires_bounds . y2 - hires_bounds . y1 ) >= MagickEpsilon ) ) { ( void ) FormatLocaleString ( geometry , MagickPathExtent , "%gx%g%+.15g%+.15g" , hires_bounds . x2 - hires_bounds . x1 , hires_bounds . y2 - hires_bounds . y1 , hires_bounds . x1 , hires_bounds . y1 ) ; ( void ) SetImageProperty ( image , "ps:HiResBoundingBox" , geometry , exception ) ; page . width = ( size_t ) ceil ( ( double ) ( ( hires_bounds . x2 - hires_bounds . x1 ) * resolution . x / delta . x ) - 0.5 ) ; page . height = ( size_t ) ceil ( ( double ) ( ( hires_bounds . y2 - hires_bounds . y1 ) * resolution . y / delta . y ) - 0.5 ) ; } fitPage = MagickFalse ; option = GetImageOption ( image_info , "eps:fit-page" ) ; if ( option != ( char * ) NULL ) { char * page_geometry ; page_geometry = GetPageGeometry ( option ) ; flags = ParseMetaGeometry ( page_geometry , & page . x , & page . y , & page . width , & page . height ) ; if ( flags == NoValue ) { ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , OptionError , <S2SV_StartBug> "InvalidGeometry" , "`%s\'" , option ) ; <S2SV_EndBug> image = DestroyImage ( image ) ; return ( ( Image * ) NULL ) ; } page . width = ( size_t ) ceil ( ( double ) ( page . width * image -> resolution . x / delta . x ) - 0.5 ) ; page . height = ( size_t ) ceil ( ( double ) ( page . height * image -> resolution . y / delta . y ) - 0.5 ) ; page_geometry = DestroyString ( page_geometry ) ; fitPage = MagickTrue ; } if ( IssRGBCompatibleColorspace ( image_info -> colorspace ) != MagickFalse ) cmyk = MagickFalse ; file = AcquireUniqueFileResource ( postscript_filename ) ; if ( file == - 1 ) { ThrowFileException ( exception , FileOpenError , "UnableToOpenFile" , image_info -> filename ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) CopyMagickString ( command , "/setpagedevice<S2SV_blank>{pop}<S2SV_blank>bind<S2SV_blank>1<S2SV_blank>index<S2SV_blank>where<S2SV_blank>{" "dup<S2SV_blank>wcheck<S2SV_blank>{3<S2SV_blank>1<S2SV_blank>roll<S2SV_blank>put}<S2SV_blank>{pop<S2SV_blank>def}<S2SV_blank>ifelse}<S2SV_blank>{def}<S2SV_blank>ifelse\\n" "<</UseCIEColor<S2SV_blank>true>>setpagedevice\\n" , MagickPathExtent ) ; count = write ( file , command , ( unsigned int ) strlen ( command ) ) ; if ( image_info -> page == ( char * ) NULL ) { char translate_geometry [ MagickPathExtent ] ; ( void ) FormatLocaleString ( translate_geometry , MagickPathExtent , "%g<S2SV_blank>%g<S2SV_blank>translate\\n" , - bounds . x1 , - bounds . y1 ) ; count = write ( file , translate_geometry , ( unsigned int ) strlen ( translate_geometry ) ) ; } file = close ( file ) - 1 ; if ( image_info -> monochrome != MagickFalse ) delegate_info = GetDelegateInfo ( "ps:mono" , ( char * ) NULL , exception ) ; else if ( cmyk != MagickFalse ) delegate_info = GetDelegateInfo ( "ps:cmyk" , ( char * ) NULL , exception ) ; else delegate_info = GetDelegateInfo ( "ps:alpha" , ( char * ) NULL , exception ) ; if ( delegate_info == ( const DelegateInfo * ) NULL ) { ( void ) RelinquishUniqueFileResource ( postscript_filename ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } density = AcquireString ( "" ) ; options = AcquireString ( "" ) ; ( void ) FormatLocaleString ( density , MagickPathExtent , "%gx%g" , resolution . x , resolution . y ) ; ( void ) FormatLocaleString ( options , MagickPathExtent , "-g%.20gx%.20g<S2SV_blank>" , ( double ) page . width , ( double ) page . height ) ; read_info = CloneImageInfo ( image_info ) ; * read_info -> magick = '\\0' ; if ( read_info -> number_scenes != 0 ) { char pages [ MagickPathExtent ] ; ( void ) FormatLocaleString ( pages , MagickPathExtent , "-dFirstPage=%.20g<S2SV_blank>" "-dLastPage=%.20g<S2SV_blank>" , ( double ) read_info -> scene + 1 , ( double ) ( read_info -> scene + read_info -> number_scenes ) ) ; ( void ) ConcatenateMagickString ( options , pages , MagickPathExtent ) ; read_info -> number_scenes = 0 ; if ( read_info -> scenes != ( char * ) NULL ) * read_info -> scenes = '\\0' ; } if ( * image_info -> magick == 'E' ) { option = GetImageOption ( image_info , "eps:use-cropbox" ) ; if ( ( option == ( const char * ) NULL ) || ( IsStringTrue ( option ) != MagickFalse ) ) ( void ) ConcatenateMagickString ( options , "-dEPSCrop<S2SV_blank>" , MagickPathExtent ) ; if ( fitPage != MagickFalse ) ( void ) ConcatenateMagickString ( options , "-dEPSFitPage<S2SV_blank>" , MagickPathExtent ) ; } ( void ) CopyMagickString ( filename , read_info -> filename , MagickPathExtent ) ; ( void ) AcquireUniqueFilename ( filename ) ; ( void ) RelinquishUniqueFileResource ( filename ) ; ( void ) ConcatenateMagickString ( filename , "%d" , MagickPathExtent ) ; ( void ) FormatLocaleString ( command , MagickPathExtent , GetDelegateCommands ( delegate_info ) , read_info -> antialias != MagickFalse ? 4 : 1 , read_info -> antialias != MagickFalse ? 4 : 1 , density , options , filename , postscript_filename , input_filename ) ; options = DestroyString ( options ) ; density = DestroyString ( density ) ; * message = '\\0' ; status = InvokePostscriptDelegate ( read_info -> verbose , command , message , exception ) ; ( void ) InterpretImageFilename ( image_info , image , filename , 1 , read_info -> filename , exception ) ; if ( ( status == MagickFalse ) || ( IsPostscriptRendered ( read_info -> filename ) == MagickFalse ) ) { ( void ) ConcatenateMagickString ( command , "<S2SV_blank>-c<S2SV_blank>showpage" , MagickPathExtent ) ; status = InvokePostscriptDelegate ( read_info -> verbose , command , message , exception ) ; } ( void ) RelinquishUniqueFileResource ( postscript_filename ) ; ( void ) RelinquishUniqueFileResource ( input_filename ) ; postscript_image = ( Image * ) NULL ; if ( status == MagickFalse ) for ( i = 1 ; ; i ++ ) { ( void ) InterpretImageFilename ( image_info , image , filename , ( int ) i , read_info -> filename , exception ) ; if ( IsPostscriptRendered ( read_info -> filename ) == MagickFalse ) break ; ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; } else for ( i = 1 ; ; i ++ ) { ( void ) InterpretImageFilename ( image_info , image , filename , ( int ) i , read_info -> filename , exception ) ; if ( IsPostscriptRendered ( read_info -> filename ) == MagickFalse ) break ; read_info -> blob = NULL ; read_info -> length = 0 ; next = ReadImage ( read_info , exception ) ; ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; if ( next == ( Image * ) NULL ) break ; AppendImageToList ( & postscript_image , next ) ; } ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; read_info = DestroyImageInfo ( read_info ) ; if ( postscript_image == ( Image * ) NULL ) { if ( * message != '\\0' ) ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , DelegateError , "PostscriptDelegateFailed" , "`%s\'" , message ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } if ( LocaleCompare ( postscript_image -> magick , "BMP" ) == 0 ) { Image * cmyk_image ; cmyk_image = ConsolidateCMYKImages ( postscript_image , exception ) ; if ( cmyk_image != ( Image * ) NULL ) { postscript_image = DestroyImageList ( postscript_image ) ; postscript_image = cmyk_image ; } } ( void ) SeekBlob ( image , 0 , SEEK_SET ) ; for ( c = ReadBlobByte ( image ) ; c != EOF ; c = ReadBlobByte ( image ) ) { * p ++ = ( char ) c ; if ( ( strchr ( "\\n\\r%" , c ) == ( char * ) NULL ) && ( ( size_t ) ( p - command ) < ( MagickPathExtent - 1 ) ) ) continue ; * p = '\\0' ; p = command ; if ( LocaleNCompare ( BeginDocument , command , strlen ( BeginDocument ) ) == 0 ) skip = MagickTrue ; if ( LocaleNCompare ( EndDocument , command , strlen ( EndDocument ) ) == 0 ) skip = MagickFalse ; if ( skip != MagickFalse ) continue ; if ( LocaleNCompare ( ICCProfile , command , strlen ( ICCProfile ) ) == 0 ) { unsigned char * datum ; profile = AcquireStringInfo ( MagickPathExtent ) ; datum = GetStringInfoDatum ( profile ) ; for ( i = 0 ; ( c = ProfileInteger ( image , hex_digits ) ) != EOF ; i ++ ) { if ( i >= ( ssize_t ) GetStringInfoLength ( profile ) ) { SetStringInfoLength ( profile , ( size_t ) i << 1 ) ; datum = GetStringInfoDatum ( profile ) ; } datum [ i ] = ( unsigned char ) c ; } SetStringInfoLength ( profile , ( size_t ) i + 1 ) ; ( void ) SetImageProfile ( image , "icc" , profile , exception ) ; profile = DestroyStringInfo ( profile ) ; continue ; } if ( LocaleNCompare ( PhotoshopProfile , command , strlen ( PhotoshopProfile ) ) == 0 ) { unsigned char * q ; count = ( ssize_t ) sscanf ( command , PhotoshopProfile "<S2SV_blank>%lu" , & extent ) ; if ( count != 1 ) continue ; length = extent ; if ( ( MagickSizeType ) length > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , "InsufficientImageDataInFile" ) ; profile = BlobToStringInfo ( ( const void * ) NULL , length ) ; if ( profile != ( StringInfo * ) NULL ) { q = GetStringInfoDatum ( profile ) ; for ( i = 0 ; i < ( ssize_t ) length ; i ++ ) * q ++ = ( unsigned char ) ProfileInteger ( image , hex_digits ) ; ( void ) SetImageProfile ( image , "8bim" , profile , exception ) ; profile = DestroyStringInfo ( profile ) ; } continue ; } if ( LocaleNCompare ( BeginXMPPacket , command , strlen ( BeginXMPPacket ) ) == 0 ) { p = command ; profile = StringToStringInfo ( command ) ; for ( i = ( ssize_t ) GetStringInfoLength ( profile ) - 1 ; c != EOF ; i ++ ) { SetStringInfoLength ( profile , ( size_t ) ( i + 1 ) ) ; c = ReadBlobByte ( image ) ; GetStringInfoDatum ( profile ) [ i ] = ( unsigned char ) c ; * p ++ = ( char ) c ; if ( ( strchr ( "\\n\\r%" , c ) == ( char * ) NULL ) && ( ( size_t ) ( p - command ) < ( MagickPathExtent - 1 ) ) ) continue ; * p = '\\0' ; p = command ; if ( LocaleNCompare ( EndXMPPacket , command , strlen ( EndXMPPacket ) ) == 0 ) break ; } SetStringInfoLength ( profile , ( size_t ) i ) ; ( void ) SetImageProfile ( image , "xmp" , profile , exception ) ; profile = DestroyStringInfo ( profile ) ; continue ; } } ( void ) CloseBlob ( image ) ; if ( image_info -> number_scenes != 0 ) { Image * clone_image ; for ( i = 0 ; i < ( ssize_t ) image_info -> scene ; i ++ ) { clone_image = CloneImage ( postscript_image , 1 , 1 , MagickTrue , exception ) ; if ( clone_image != ( Image * ) NULL ) PrependImageToList ( & postscript_image , clone_image ) ; } } do { ( void ) CopyMagickString ( postscript_image -> filename , filename , MagickPathExtent ) ; ( void ) CopyMagickString ( postscript_image -> magick , image -> magick , MagickPathExtent ) ; if ( columns != 0 ) postscript_image -> magick_columns = columns ; if ( rows != 0 ) postscript_image -> magick_rows = rows ; postscript_image -> page = page ; ( void ) CloneImageProfiles ( postscript_image , image ) ; ( void ) CloneImageProperties ( postscript_image , image ) ; next = SyncNextImageInList ( postscript_image ) ; if ( next != ( Image * ) NULL ) postscript_image = next ; } while ( next != ( Image * ) NULL ) ; image = DestroyImageList ( image ) ; scene = 0 ; for ( next = GetFirstImageInList ( postscript_image ) ; next != ( Image * ) NULL ; ) { next -> scene = scene ++ ; next = GetNextImageInList ( next ) ; } return ( GetFirstImageInList ( postscript_image ) ) ; }
CWE-119 static MagickBooleanType EncodeImage ( const ImageInfo * image_info , Image * image , const size_t data_size , ExceptionInfo * exception ) { # define MaxCode ( number_bits ) ( ( one << ( number_bits ) ) - 1 ) # define MaxHashTable 5003 # define MaxGIFBits 12UL # define MaxGIFTable ( 1UL << MaxGIFBits ) <S2SV_StartBug> # define GIFOutputCode ( code ) { if ( bits > 0 ) datum |= ( size_t ) ( code ) << bits ; else datum = ( size_t ) ( code ) ; bits += number_bits ; while ( bits >= 8 ) { packet [ length ++ ] = ( unsigned char ) ( datum & 0xff ) ; if ( length >= 254 ) { ( void ) WriteBlobByte ( image , ( unsigned char ) length ) ; ( void ) WriteBlob ( image , length , packet ) ; length = 0 ; } datum >>= 8 ; bits -= 8 ; } if ( free_code > max_code ) { number_bits ++ ; if ( number_bits == MaxGIFBits ) max_code = MaxGIFTable ; else max_code = MaxCode ( number_bits ) ; } } <S2SV_EndBug> Quantum index ; short * hash_code , * hash_prefix , waiting_code ; size_t bits , clear_code , datum , end_of_information_code , free_code , length , max_code , next_pixel , number_bits , one , pass ; ssize_t displacement , offset , k , y ; unsigned char * packet , * hash_suffix ; assert ( image != ( Image * ) NULL ) ; one = 1 ; packet = ( unsigned char * ) AcquireQuantumMemory ( 256 , sizeof ( * packet ) ) ; hash_code = ( short * ) AcquireQuantumMemory ( MaxHashTable , sizeof ( * hash_code ) ) ; hash_prefix = ( short * ) AcquireQuantumMemory ( MaxHashTable , sizeof ( * hash_prefix ) ) ; hash_suffix = ( unsigned char * ) AcquireQuantumMemory ( MaxHashTable , sizeof ( * hash_suffix ) ) ; if ( ( packet == ( unsigned char * ) NULL ) || ( hash_code == ( short * ) NULL ) || ( hash_prefix == ( short * ) NULL ) || ( hash_suffix == ( unsigned char * ) NULL ) ) { if ( packet != ( unsigned char * ) NULL ) packet = ( unsigned char * ) RelinquishMagickMemory ( packet ) ; if ( hash_code != ( short * ) NULL ) hash_code = ( short * ) RelinquishMagickMemory ( hash_code ) ; if ( hash_prefix != ( short * ) NULL ) hash_prefix = ( short * ) RelinquishMagickMemory ( hash_prefix ) ; if ( hash_suffix != ( unsigned char * ) NULL ) hash_suffix = ( unsigned char * ) RelinquishMagickMemory ( hash_suffix ) ; return ( MagickFalse ) ; } ( void ) memset ( packet , 0 , 256 * sizeof ( * packet ) ) ; ( void ) memset ( hash_code , 0 , MaxHashTable * sizeof ( * hash_code ) ) ; ( void ) memset ( hash_prefix , 0 , MaxHashTable * sizeof ( * hash_prefix ) ) ; ( void ) memset ( hash_suffix , 0 , MaxHashTable * sizeof ( * hash_suffix ) ) ; number_bits = data_size ; max_code = MaxCode ( number_bits ) ; clear_code = ( ( short ) one << ( data_size - 1 ) ) ; end_of_information_code = clear_code + 1 ; free_code = clear_code + 2 ; length = 0 ; datum = 0 ; bits = 0 ; GIFOutputCode ( clear_code ) ; offset = 0 ; pass = 0 ; waiting_code = 0 ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { register const Quantum * magick_restrict p ; register ssize_t x ; p = GetVirtualPixels ( image , 0 , offset , image -> columns , 1 , exception ) ; if ( p == ( const Quantum * ) NULL ) break ; if ( y == 0 ) { waiting_code = ( short ) GetPixelIndex ( image , p ) ; p += GetPixelChannels ( image ) ; } for ( x = ( ssize_t ) ( y == 0 ? 1 : 0 ) ; x < ( ssize_t ) image -> columns ; x ++ ) { <S2SV_StartBug> index = ( Quantum ) ( ( size_t ) GetPixelIndex ( image , p ) & 0xff ) ; <S2SV_EndBug> p += GetPixelChannels ( image ) ; k = ( ssize_t ) ( ( ( size_t ) index << ( MaxGIFBits - 8 ) ) + waiting_code ) ; if ( k >= MaxHashTable ) k -= MaxHashTable ; <S2SV_StartBug> next_pixel = MagickFalse ; <S2SV_EndBug> displacement = 1 ; if ( hash_code [ k ] > 0 ) { if ( ( hash_prefix [ k ] == waiting_code ) && ( hash_suffix [ k ] == ( unsigned char ) index ) ) { waiting_code = hash_code [ k ] ; continue ; } if ( k != 0 ) displacement = MaxHashTable - k ; for ( ; ; ) { k -= displacement ; if ( k < 0 ) k += MaxHashTable ; if ( hash_code [ k ] == 0 ) break ; if ( ( hash_prefix [ k ] == waiting_code ) && ( hash_suffix [ k ] == ( unsigned char ) index ) ) { waiting_code = hash_code [ k ] ; next_pixel = MagickTrue ; break ; } } if ( next_pixel != MagickFalse ) continue ; } GIFOutputCode ( waiting_code ) ; if ( free_code < MaxGIFTable ) { hash_code [ k ] = ( short ) free_code ++ ; hash_prefix [ k ] = waiting_code ; hash_suffix [ k ] = ( unsigned char ) index ; } else { for ( k = 0 ; k < MaxHashTable ; k ++ ) hash_code [ k ] = 0 ; free_code = clear_code + 2 ; GIFOutputCode ( clear_code ) ; number_bits = data_size ; max_code = MaxCode ( number_bits ) ; } waiting_code = ( short ) index ; } if ( image_info -> interlace == NoInterlace ) offset ++ ; else switch ( pass ) { case 0 : default : { offset += 8 ; if ( offset >= ( ssize_t ) image -> rows ) { pass ++ ; offset = 4 ; } break ; } case 1 : { offset += 8 ; if ( offset >= ( ssize_t ) image -> rows ) { pass ++ ; offset = 2 ; } break ; } case 2 : { offset += 4 ; if ( offset >= ( ssize_t ) image -> rows ) { pass ++ ; offset = 1 ; } break ; } case 3 : { offset += 2 ; break ; } } } GIFOutputCode ( waiting_code ) ; GIFOutputCode ( end_of_information_code ) ; if ( bits > 0 ) { packet [ length ++ ] = ( unsigned char ) ( datum & 0xff ) ; if ( length >= 254 ) { ( void ) WriteBlobByte ( image , ( unsigned char ) length ) ; ( void ) WriteBlob ( image , length , packet ) ; length = 0 ; } } if ( length > 0 ) { ( void ) WriteBlobByte ( image , ( unsigned char ) length ) ; ( void ) WriteBlob ( image , length , packet ) ; } hash_suffix = ( unsigned char * ) RelinquishMagickMemory ( hash_suffix ) ; hash_prefix = ( short * ) RelinquishMagickMemory ( hash_prefix ) ; hash_code = ( short * ) RelinquishMagickMemory ( hash_code ) ; packet = ( unsigned char * ) RelinquishMagickMemory ( packet ) ; return ( MagickTrue ) ; }
CWE-20 static Image * ReadCALSImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char filename [ MagickPathExtent ] , header [ MagickPathExtent ] , message [ MagickPathExtent ] ; FILE * file ; Image * image ; ImageInfo * read_info ; int c , unique_file ; MagickBooleanType status ; register ssize_t i ; unsigned long density , direction , height , orientation , pel_path , type , width ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) memset ( header , 0 , sizeof ( header ) ) ; density = 0 ; direction = 0 ; orientation = 1 ; pel_path = 0 ; type = 1 ; width = 0 ; height = 0 ; for ( i = 0 ; i < 16 ; i ++ ) { if ( ReadBlob ( image , 128 , ( unsigned char * ) header ) != 128 ) break ; switch ( * header ) { case 'R' : case 'r' : { if ( LocaleNCompare ( header , "rdensty:" , 8 ) == 0 ) { ( void ) sscanf ( header + 8 , "%lu" , & density ) ; break ; } if ( LocaleNCompare ( header , "rpelcnt:" , 8 ) == 0 ) { ( void ) sscanf ( header + 8 , "%lu,%lu" , & width , & height ) ; break ; } if ( LocaleNCompare ( header , "rorient:" , 8 ) == 0 ) { ( void ) sscanf ( header + 8 , "%lu,%lu" , & pel_path , & direction ) ; if ( pel_path == 90 ) orientation = 5 ; else if ( pel_path == 180 ) orientation = 3 ; else if ( pel_path == 270 ) orientation = 7 ; if ( direction == 90 ) orientation ++ ; break ; } if ( LocaleNCompare ( header , "rtype:" , 6 ) == 0 ) { ( void ) sscanf ( header + 6 , "%lu" , & type ) ; break ; } break ; } } } file = ( FILE * ) NULL ; unique_file = AcquireUniqueFileResource ( filename ) ; if ( unique_file != - 1 ) file = fdopen ( unique_file , "wb" ) ; if ( ( unique_file == - 1 ) || ( file == ( FILE * ) NULL ) ) ThrowImageException ( FileOpenError , "UnableToCreateTemporaryFile" ) ; while ( ( c = ReadBlobByte ( image ) ) != EOF ) <S2SV_StartBug> ( void ) fputc ( c , file ) ; <S2SV_EndBug> ( void ) fclose ( file ) ; ( void ) CloseBlob ( image ) ; image = DestroyImage ( image ) ; read_info = CloneImageInfo ( image_info ) ; SetImageInfoBlob ( read_info , ( void * ) NULL , 0 ) ; ( void ) FormatLocaleString ( read_info -> filename , MagickPathExtent , "group4:%s" , filename ) ; ( void ) FormatLocaleString ( message , MagickPathExtent , "%lux%lu" , width , height ) ; ( void ) CloneString ( & read_info -> size , message ) ; ( void ) FormatLocaleString ( message , MagickPathExtent , "%lu" , density ) ; ( void ) CloneString ( & read_info -> density , message ) ; read_info -> orientation = ( OrientationType ) orientation ; image = ReadImage ( read_info , exception ) ; if ( image != ( Image * ) NULL ) { ( void ) CopyMagickString ( image -> filename , image_info -> filename , MagickPathExtent ) ; ( void ) CopyMagickString ( image -> magick_filename , image_info -> filename , MagickPathExtent ) ; ( void ) CopyMagickString ( image -> magick , "CALS" , MagickPathExtent ) ; } read_info = DestroyImageInfo ( read_info ) ; ( void ) RelinquishUniqueFileResource ( filename ) ; return ( image ) ; }
CWE-20 static Image * ReadDCMImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { <S2SV_StartBug> # define ThrowDCMException ( exception , message ) { if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; if ( stream_info != ( DCMStreamInfo * ) NULL ) stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; ThrowReaderException ( ( exception ) , ( message ) ) ; } <S2SV_EndBug> char explicit_vr [ MagickPathExtent ] , implicit_vr [ MagickPathExtent ] , magick [ MagickPathExtent ] , photometric [ MagickPathExtent ] ; DCMInfo info ; DCMStreamInfo * stream_info ; Image * image ; int * bluemap , datum , * greenmap , * graymap , * redmap ; MagickBooleanType explicit_file , explicit_retry , use_explicit ; MagickOffsetType offset ; register unsigned char * p ; register ssize_t i ; size_t colors , height , length , number_scenes , quantum , status , width ; ssize_t count , scene ; unsigned char * data ; unsigned short group , element ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image -> depth = 8UL ; image -> endian = LSBEndian ; ( void ) memset ( & info , 0 , sizeof ( info ) ) ; data = ( unsigned char * ) NULL ; graymap = ( int * ) NULL ; redmap = ( int * ) NULL ; greenmap = ( int * ) NULL ; bluemap = ( int * ) NULL ; stream_info = ( DCMStreamInfo * ) AcquireMagickMemory ( sizeof ( * stream_info ) ) ; if ( stream_info == ( DCMStreamInfo * ) NULL ) ThrowDCMException ( ResourceLimitError , "MemoryAllocationFailed" ) ; ( void ) memset ( stream_info , 0 , sizeof ( * stream_info ) ) ; count = ReadBlob ( image , 128 , ( unsigned char * ) magick ) ; if ( count != 128 ) ThrowDCMException ( CorruptImageError , "ImproperImageHeader" ) ; count = ReadBlob ( image , 4 , ( unsigned char * ) magick ) ; if ( ( count != 4 ) || ( LocaleNCompare ( magick , "DICM" , 4 ) != 0 ) ) { offset = SeekBlob ( image , 0L , SEEK_SET ) ; if ( offset < 0 ) ThrowDCMException ( CorruptImageError , "ImproperImageHeader" ) ; } ( void ) CopyMagickString ( photometric , "MONOCHROME1<S2SV_blank>" , MagickPathExtent ) ; info . bits_allocated = 8 ; info . bytes_per_pixel = 1 ; info . depth = 8 ; info . mask = 0xffff ; info . max_value = 255UL ; info . samples_per_pixel = 1 ; info . signed_data = ( ~ 0UL ) ; info . rescale_slope = 1.0 ; data = ( unsigned char * ) NULL ; element = 0 ; explicit_vr [ 2 ] = '\\0' ; explicit_file = MagickFalse ; colors = 0 ; redmap = ( int * ) NULL ; greenmap = ( int * ) NULL ; bluemap = ( int * ) NULL ; graymap = ( int * ) NULL ; height = 0 ; number_scenes = 1 ; use_explicit = MagickFalse ; explicit_retry = MagickFalse ; width = 0 ; while ( TellBlob ( image ) < ( MagickOffsetType ) GetBlobSize ( image ) ) { for ( group = 0 ; ( group != 0x7FE0 ) || ( element != 0x0010 ) ; ) { image -> offset = ( ssize_t ) TellBlob ( image ) ; group = ReadBlobLSBShort ( image ) ; element = ReadBlobLSBShort ( image ) ; if ( ( group == 0xfffc ) && ( element == 0xfffc ) ) break ; if ( ( group != 0x0002 ) && ( image -> endian == MSBEndian ) ) { group = ( unsigned short ) ( ( group << 8 ) | ( ( group >> 8 ) & 0xFF ) ) ; element = ( unsigned short ) ( ( element << 8 ) | ( ( element >> 8 ) & 0xFF ) ) ; } quantum = 0 ; for ( i = 0 ; dicom_info [ i ] . group < 0xffff ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; ( void ) CopyMagickString ( implicit_vr , dicom_info [ i ] . vr , MagickPathExtent ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) explicit_vr ) ; if ( count != 2 ) ThrowDCMException ( CorruptImageError , "ImproperImageHeader" ) ; if ( ( explicit_file == MagickFalse ) && ( group != 0x0002 ) ) explicit_file = ( isupper ( ( unsigned char ) * explicit_vr ) != MagickFalse ) && ( isupper ( ( unsigned char ) * ( explicit_vr + 1 ) ) != MagickFalse ) ? MagickTrue : MagickFalse ; use_explicit = ( ( group == 0x0002 ) && ( explicit_retry == MagickFalse ) ) || ( explicit_file != MagickFalse ) ? MagickTrue : MagickFalse ; if ( ( use_explicit != MagickFalse ) && ( strncmp ( implicit_vr , "xs" , 2 ) == 0 ) ) ( void ) CopyMagickString ( implicit_vr , explicit_vr , MagickPathExtent ) ; if ( ( use_explicit == MagickFalse ) || ( strncmp ( implicit_vr , "!!" , 2 ) == 0 ) ) { offset = SeekBlob ( image , ( MagickOffsetType ) - 2 , SEEK_CUR ) ; if ( offset < 0 ) ThrowDCMException ( CorruptImageError , "ImproperImageHeader" ) ; quantum = 4 ; } else { quantum = 2 ; if ( ( strncmp ( explicit_vr , "OB" , 2 ) == 0 ) || ( strncmp ( explicit_vr , "UN" , 2 ) == 0 ) || ( strncmp ( explicit_vr , "OW" , 2 ) == 0 ) || ( strncmp ( explicit_vr , "SQ" , 2 ) == 0 ) ) { ( void ) ReadBlobLSBShort ( image ) ; quantum = 4 ; } } datum = 0 ; if ( quantum == 4 ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedLong ( image ) ; else datum = ReadBlobSignedLong ( image ) ; } else if ( quantum == 2 ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedShort ( image ) ; else datum = ReadBlobSignedShort ( image ) ; } quantum = 0 ; length = 1 ; if ( datum != 0 ) { if ( ( strncmp ( implicit_vr , "OW" , 2 ) == 0 ) || ( strncmp ( implicit_vr , "SS" , 2 ) == 0 ) || ( strncmp ( implicit_vr , "US" , 2 ) == 0 ) ) quantum = 2 ; else if ( ( strncmp ( implicit_vr , "FL" , 2 ) == 0 ) || ( strncmp ( implicit_vr , "OF" , 2 ) == 0 ) || ( strncmp ( implicit_vr , "SL" , 2 ) == 0 ) || ( strncmp ( implicit_vr , "UL" , 2 ) == 0 ) ) quantum = 4 ; else if ( strncmp ( implicit_vr , "FD" , 2 ) == 0 ) quantum = 8 ; else quantum = 1 ; if ( datum != ~ 0 ) length = ( size_t ) datum / quantum ; else { quantum = 0 ; length = 0 ; } } if ( image_info -> verbose != MagickFalse ) { if ( use_explicit == MagickFalse ) explicit_vr [ 0 ] = '\\0' ; for ( i = 0 ; dicom_info [ i ] . description != ( char * ) NULL ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; ( void ) FormatLocaleFile ( stdout , "0x%04lX<S2SV_blank>%4ld<S2SV_blank>%s-%s<S2SV_blank>(0x%04lx,0x%04lx)" , ( unsigned long ) image -> offset , ( long ) length , implicit_vr , explicit_vr , ( unsigned long ) group , ( unsigned long ) element ) ; if ( dicom_info [ i ] . description != ( char * ) NULL ) ( void ) FormatLocaleFile ( stdout , "<S2SV_blank>%s" , dicom_info [ i ] . description ) ; ( void ) FormatLocaleFile ( stdout , ":<S2SV_blank>" ) ; } if ( ( group == 0x7FE0 ) && ( element == 0x0010 ) ) { if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , "\\n" ) ; break ; } data = ( unsigned char * ) NULL ; if ( ( length == 1 ) && ( quantum == 1 ) ) datum = ReadBlobByte ( image ) ; else if ( ( length == 1 ) && ( quantum == 2 ) ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedShort ( image ) ; else datum = ReadBlobSignedShort ( image ) ; } else if ( ( length == 1 ) && ( quantum == 4 ) ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedLong ( image ) ; else datum = ReadBlobSignedLong ( image ) ; } else if ( ( quantum != 0 ) && ( length != 0 ) ) { if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , "InsufficientImageDataInFile" ) ; if ( ~ length >= 1 ) data = ( unsigned char * ) AcquireQuantumMemory ( length + 1 , quantum * sizeof ( * data ) ) ; if ( data == ( unsigned char * ) NULL ) ThrowDCMException ( ResourceLimitError , "MemoryAllocationFailed" ) ; count = ReadBlob ( image , ( size_t ) quantum * length , data ) ; if ( count != ( ssize_t ) ( quantum * length ) ) { if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , "count=%d<S2SV_blank>quantum=%d<S2SV_blank>" "length=%d<S2SV_blank>group=%d\\n" , ( int ) count , ( int ) quantum , ( int ) length , ( int ) group ) ; ThrowDCMException ( CorruptImageError , "InsufficientImageDataInFile" ) ; } data [ length * quantum ] = '\\0' ; } if ( ( ( ( unsigned int ) group << 16 ) | element ) == 0xFFFEE0DD ) { if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; continue ; } switch ( group ) { case 0x0002 : { switch ( element ) { case 0x0010 : { char transfer_syntax [ MagickPathExtent ] ; if ( ( datum == 0 ) && ( explicit_retry == MagickFalse ) ) { explicit_retry = MagickTrue ; ( void ) SeekBlob ( image , ( MagickOffsetType ) 0 , SEEK_SET ) ; group = 0 ; element = 0 ; if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , "Corrupted<S2SV_blank>image<S2SV_blank>-<S2SV_blank>trying<S2SV_blank>explicit<S2SV_blank>format\\n" ) ; break ; } * transfer_syntax = '\\0' ; if ( data != ( unsigned char * ) NULL ) ( void ) CopyMagickString ( transfer_syntax , ( char * ) data , MagickPathExtent ) ; if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , "transfer_syntax=%s\\n" , ( const char * ) transfer_syntax ) ; if ( strncmp ( transfer_syntax , "1.2.840.10008.1.2" , 17 ) == 0 ) { int subtype , type ; type = 1 ; subtype = 0 ; if ( strlen ( transfer_syntax ) > 17 ) { count = ( ssize_t ) sscanf ( transfer_syntax + 17 , ".%d.%d" , & type , & subtype ) ; if ( count < 1 ) ThrowDCMException ( CorruptImageError , "ImproperImageHeader" ) ; } switch ( type ) { case 1 : { image -> endian = LSBEndian ; break ; } case 2 : { image -> endian = MSBEndian ; break ; } case 4 : { if ( ( subtype >= 80 ) && ( subtype <= 81 ) ) image -> compression = JPEGCompression ; else if ( ( subtype >= 90 ) && ( subtype <= 93 ) ) image -> compression = JPEG2000Compression ; else image -> compression = JPEGCompression ; break ; } case 5 : { image -> compression = RLECompression ; break ; } } } break ; } default : break ; } break ; } case 0x0028 : { switch ( element ) { case 0x0002 : { info . samples_per_pixel = ( size_t ) datum ; if ( ( info . samples_per_pixel == 0 ) || ( info . samples_per_pixel > 4 ) ) ThrowDCMException ( CorruptImageError , "ImproperImageHeader" ) ; break ; } case 0x0004 : { if ( data == ( unsigned char * ) NULL ) break ; for ( i = 0 ; i < ( ssize_t ) MagickMin ( length , MagickPathExtent - 1 ) ; i ++ ) photometric [ i ] = ( char ) data [ i ] ; photometric [ i ] = '\\0' ; info . polarity = LocaleCompare ( photometric , "MONOCHROME1<S2SV_blank>" ) == 0 ? MagickTrue : MagickFalse ; break ; } case 0x0006 : { if ( datum == 1 ) image -> interlace = PlaneInterlace ; break ; } case 0x0008 : { if ( data == ( unsigned char * ) NULL ) break ; number_scenes = StringToUnsignedLong ( ( char * ) data ) ; break ; } case 0x0010 : { height = ( size_t ) datum ; break ; } case 0x0011 : { width = ( size_t ) datum ; break ; } case 0x0100 : { info . bits_allocated = ( size_t ) datum ; info . bytes_per_pixel = 1 ; if ( datum > 8 ) info . bytes_per_pixel = 2 ; info . depth = info . bits_allocated ; if ( ( info . depth == 0 ) || ( info . depth > 32 ) ) ThrowDCMException ( CorruptImageError , "ImproperImageHeader" ) ; info . max_value = ( 1UL << info . bits_allocated ) - 1 ; image -> depth = info . depth ; break ; } case 0x0101 : { info . significant_bits = ( size_t ) datum ; info . bytes_per_pixel = 1 ; if ( info . significant_bits > 8 ) info . bytes_per_pixel = 2 ; info . depth = info . significant_bits ; if ( ( info . depth == 0 ) || ( info . depth > 16 ) ) ThrowDCMException ( CorruptImageError , "ImproperImageHeader" ) ; info . max_value = ( 1UL << info . significant_bits ) - 1 ; info . mask = ( size_t ) GetQuantumRange ( info . significant_bits ) ; image -> depth = info . depth ; break ; } case 0x0102 : { break ; } case 0x0103 : { info . signed_data = ( size_t ) datum ; break ; } case 0x1050 : { if ( data != ( unsigned char * ) NULL ) info . window_center = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1051 : { if ( data != ( unsigned char * ) NULL ) info . window_width = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1052 : { if ( data != ( unsigned char * ) NULL ) info . rescale_intercept = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1053 : { if ( data != ( unsigned char * ) NULL ) info . rescale_slope = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1200 : case 0x3006 : { if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / info . bytes_per_pixel ) ; datum = ( int ) colors ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; graymap = ( int * ) AcquireQuantumMemory ( MagickMax ( colors , 65536 ) , sizeof ( * graymap ) ) ; if ( graymap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , "MemoryAllocationFailed" ) ; ( void ) memset ( graymap , 0 , MagickMax ( colors , 65536 ) * sizeof ( * graymap ) ) ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) if ( info . bytes_per_pixel == 1 ) graymap [ i ] = ( int ) data [ i ] ; else graymap [ i ] = ( int ) ( ( short * ) data ) [ i ] ; break ; } case 0x1201 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; redmap = ( int * ) AcquireQuantumMemory ( MagickMax ( colors , 65536 ) , sizeof ( * redmap ) ) ; if ( redmap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , "MemoryAllocationFailed" ) ; ( void ) memset ( redmap , 0 , MagickMax ( colors , 65536 ) * sizeof ( * redmap ) ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; redmap [ i ] = ( int ) index ; p += 2 ; } break ; } case 0x1202 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; greenmap = ( int * ) AcquireQuantumMemory ( MagickMax ( colors , 65536 ) , sizeof ( * greenmap ) ) ; if ( greenmap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , "MemoryAllocationFailed" ) ; ( void ) memset ( greenmap , 0 , MagickMax ( colors , 65536 ) * sizeof ( * greenmap ) ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; greenmap [ i ] = ( int ) index ; p += 2 ; } break ; } case 0x1203 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; bluemap = ( int * ) AcquireQuantumMemory ( MagickMax ( colors , 65536 ) , sizeof ( * bluemap ) ) ; if ( bluemap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , "MemoryAllocationFailed" ) ; ( void ) memset ( bluemap , 0 , MagickMax ( colors , 65536 ) * sizeof ( * bluemap ) ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; bluemap [ i ] = ( int ) index ; p += 2 ; } break ; } default : break ; } break ; } case 0x2050 : { switch ( element ) { case 0x0020 : { if ( ( data != ( unsigned char * ) NULL ) && ( strncmp ( ( char * ) data , "INVERSE" , 7 ) == 0 ) ) info . polarity = MagickTrue ; break ; } default : break ; } break ; } default : break ; } if ( data != ( unsigned char * ) NULL ) { char * attribute ; for ( i = 0 ; dicom_info [ i ] . description != ( char * ) NULL ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; if ( dicom_info [ i ] . description != ( char * ) NULL ) { attribute = AcquireString ( "dcm:" ) ; ( void ) ConcatenateString ( & attribute , dicom_info [ i ] . description ) ; for ( i = 0 ; i < ( ssize_t ) MagickMax ( length , 4 ) ; i ++ ) if ( isprint ( ( int ) data [ i ] ) == MagickFalse ) break ; if ( ( i == ( ssize_t ) length ) || ( length > 4 ) ) { ( void ) SubstituteString ( & attribute , "<S2SV_blank>" , "" ) ; ( void ) SetImageProperty ( image , attribute , ( char * ) data , exception ) ; } attribute = DestroyString ( attribute ) ; } } if ( image_info -> verbose != MagickFalse ) { if ( data == ( unsigned char * ) NULL ) ( void ) FormatLocaleFile ( stdout , "%d\\n" , datum ) ; else { for ( i = 0 ; i < ( ssize_t ) MagickMax ( length , 4 ) ; i ++ ) if ( isprint ( ( int ) data [ i ] ) == MagickFalse ) break ; if ( ( i != ( ssize_t ) length ) && ( length <= 4 ) ) { ssize_t j ; datum = 0 ; for ( j = ( ssize_t ) length - 1 ; j >= 0 ; j -- ) datum = ( 256 * datum + data [ j ] ) ; ( void ) FormatLocaleFile ( stdout , "%d" , datum ) ; } else for ( i = 0 ; i < ( ssize_t ) length ; i ++ ) if ( isprint ( ( int ) data [ i ] ) != MagickFalse ) ( void ) FormatLocaleFile ( stdout , "%c" , data [ i ] ) ; else ( void ) FormatLocaleFile ( stdout , "%c" , '.' ) ; ( void ) FormatLocaleFile ( stdout , "\\n" ) ; } } if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , "UnexpectedEndOfFile" , image -> filename ) ; break ; } } if ( ( group == 0xfffc ) && ( element == 0xfffc ) ) { Image * last ; last = RemoveLastImageFromList ( & image ) ; if ( last != ( Image * ) NULL ) last = DestroyImage ( last ) ; break ; } if ( ( width == 0 ) || ( height == 0 ) ) ThrowDCMException ( CorruptImageError , "ImproperImageHeader" ) ; image -> columns = ( size_t ) width ; image -> rows = ( size_t ) height ; if ( info . signed_data == 0xffff ) info . signed_data = ( size_t ) ( info . significant_bits == 16 ? 1 : 0 ) ; if ( ( image -> compression == JPEGCompression ) || ( image -> compression == JPEG2000Compression ) ) { Image * images ; ImageInfo * read_info ; int c ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; ( void ) ( ( ( ssize_t ) ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ) ; length = ( size_t ) ReadBlobLSBLong ( image ) ; if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , "InsufficientImageDataInFile" ) ; stream_info -> offset_count = length >> 2 ; if ( stream_info -> offset_count != 0 ) { if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; stream_info -> offsets = ( ssize_t * ) AcquireQuantumMemory ( stream_info -> offset_count , sizeof ( * stream_info -> offsets ) ) ; if ( stream_info -> offsets == ( ssize_t * ) NULL ) ThrowDCMException ( ResourceLimitError , "MemoryAllocationFailed" ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; offset = TellBlob ( image ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] += offset ; } read_info = CloneImageInfo ( image_info ) ; SetImageInfoBlob ( read_info , ( void * ) NULL , 0 ) ; images = NewImageList ( ) ; for ( scene = 0 ; scene < ( ssize_t ) number_scenes ; scene ++ ) { char filename [ MagickPathExtent ] ; const char * property ; FILE * file ; Image * jpeg_image ; int unique_file ; unsigned int tag ; tag = ( ( unsigned int ) ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; length = ( size_t ) ReadBlobLSBLong ( image ) ; if ( tag == 0xFFFEE0DD ) break ; if ( tag != 0xFFFEE000 ) { read_info = DestroyImageInfo ( read_info ) ; ThrowDCMException ( CorruptImageError , "ImproperImageHeader" ) ; } file = ( FILE * ) NULL ; unique_file = AcquireUniqueFileResource ( filename ) ; if ( unique_file != - 1 ) file = fdopen ( unique_file , "wb" ) ; if ( file == ( FILE * ) NULL ) { ( void ) RelinquishUniqueFileResource ( filename ) ; ThrowFileException ( exception , FileOpenError , "UnableToCreateTemporaryFile" , filename ) ; break ; } for ( c = EOF ; length != 0 ; length -- ) { c = ReadBlobByte ( image ) ; if ( c == EOF ) { ThrowFileException ( exception , CorruptImageError , "UnexpectedEndOfFile" , image -> filename ) ; break ; } <S2SV_StartBug> ( void ) fputc ( c , file ) ; <S2SV_EndBug> } ( void ) fclose ( file ) ; if ( c == EOF ) break ; ( void ) FormatLocaleString ( read_info -> filename , MagickPathExtent , "jpeg:%s" , filename ) ; if ( image -> compression == JPEG2000Compression ) ( void ) FormatLocaleString ( read_info -> filename , MagickPathExtent , "j2k:%s" , filename ) ; jpeg_image = ReadImage ( read_info , exception ) ; if ( jpeg_image != ( Image * ) NULL ) { ResetImagePropertyIterator ( image ) ; property = GetNextImageProperty ( image ) ; while ( property != ( const char * ) NULL ) { ( void ) SetImageProperty ( jpeg_image , property , GetImageProperty ( image , property , exception ) , exception ) ; property = GetNextImageProperty ( image ) ; } AppendImageToList ( & images , jpeg_image ) ; } ( void ) RelinquishUniqueFileResource ( filename ) ; } read_info = DestroyImageInfo ( read_info ) ; if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; image = DestroyImageList ( image ) ; return ( GetFirstImageInList ( images ) ) ; } if ( info . depth != ( 1UL * MAGICKCORE_QUANTUM_DEPTH ) ) { QuantumAny range ; length = ( size_t ) ( GetQuantumRange ( info . depth ) + 1 ) ; if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , "InsufficientImageDataInFile" ) ; if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; info . scale = ( Quantum * ) AcquireQuantumMemory ( MagickMax ( length , 256 ) , sizeof ( * info . scale ) ) ; if ( info . scale == ( Quantum * ) NULL ) ThrowDCMException ( ResourceLimitError , "MemoryAllocationFailed" ) ; ( void ) memset ( info . scale , 0 , MagickMax ( length , 256 ) * sizeof ( * info . scale ) ) ; range = GetQuantumRange ( info . depth ) ; for ( i = 0 ; i <= ( ssize_t ) GetQuantumRange ( info . depth ) ; i ++ ) info . scale [ i ] = ScaleAnyToQuantum ( ( size_t ) i , range ) ; } if ( image -> compression == RLECompression ) { unsigned int tag ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) { int c ; c = ReadBlobByte ( image ) ; if ( c == EOF ) break ; } tag = ( ( unsigned int ) ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; ( void ) tag ; length = ( size_t ) ReadBlobLSBLong ( image ) ; if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , "InsufficientImageDataInFile" ) ; stream_info -> offset_count = length >> 2 ; if ( stream_info -> offset_count != 0 ) { stream_info -> offsets = ( ssize_t * ) AcquireQuantumMemory ( stream_info -> offset_count , sizeof ( * stream_info -> offsets ) ) ; if ( stream_info -> offsets == ( ssize_t * ) NULL ) ThrowDCMException ( ResourceLimitError , "MemoryAllocationFailed" ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) { stream_info -> offsets [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) break ; } offset = TellBlob ( image ) + 8 ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] += offset ; } } for ( scene = 0 ; scene < ( ssize_t ) number_scenes ; scene ++ ) { if ( image_info -> ping != MagickFalse ) break ; image -> columns = ( size_t ) width ; image -> rows = ( size_t ) height ; image -> depth = info . depth ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) break ; image -> colorspace = RGBColorspace ; ( void ) SetImageBackgroundColor ( image , exception ) ; if ( ( image -> colormap == ( PixelInfo * ) NULL ) && ( info . samples_per_pixel == 1 ) ) { int index ; size_t one ; one = 1 ; if ( colors == 0 ) colors = one << info . depth ; if ( AcquireImageColormap ( image , colors , exception ) == MagickFalse ) ThrowDCMException ( ResourceLimitError , "MemoryAllocationFailed" ) ; if ( redmap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = redmap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index >= 0 ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . red = ( MagickRealType ) index ; } if ( greenmap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = greenmap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index >= 0 ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . green = ( MagickRealType ) index ; } if ( bluemap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = bluemap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index >= 0 ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . blue = ( MagickRealType ) index ; } if ( graymap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = graymap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index >= 0 ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . red = ( MagickRealType ) index ; image -> colormap [ i ] . green = ( MagickRealType ) index ; image -> colormap [ i ] . blue = ( MagickRealType ) index ; } } if ( image -> compression == RLECompression ) { unsigned int tag ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) { int c ; c = ReadBlobByte ( image ) ; if ( c == EOF ) break ; } tag = ( ( unsigned int ) ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; stream_info -> remaining = ( size_t ) ReadBlobLSBLong ( image ) ; if ( ( tag != 0xFFFEE000 ) || ( stream_info -> remaining <= 64 ) || ( EOFBlob ( image ) != MagickFalse ) ) { if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; ThrowDCMException ( CorruptImageError , "ImproperImageHeader" ) ; } stream_info -> count = 0 ; stream_info -> segment_count = ReadBlobLSBLong ( image ) ; for ( i = 0 ; i < 15 ; i ++ ) stream_info -> segments [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; stream_info -> remaining -= 64 ; if ( stream_info -> segment_count > 1 ) { info . bytes_per_pixel = 1 ; info . depth = 8 ; if ( stream_info -> offset_count > 0 ) ( void ) SeekBlob ( image , ( MagickOffsetType ) stream_info -> offsets [ 0 ] + stream_info -> segments [ 0 ] , SEEK_SET ) ; } } if ( ( info . samples_per_pixel > 1 ) && ( image -> interlace == PlaneInterlace ) ) { register ssize_t x ; register Quantum * q ; ssize_t y ; for ( i = 0 ; i < ( ssize_t ) info . samples_per_pixel ; i ++ ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = GetAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { switch ( ( int ) i ) { case 0 : { SetPixelRed ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } case 1 : { SetPixelGreen ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } case 2 : { SetPixelBlue ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } case 3 : { SetPixelAlpha ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } default : break ; } q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } } else { const char * option ; option = GetImageOption ( image_info , "dcm:display-range" ) ; if ( option != ( const char * ) NULL ) { if ( LocaleCompare ( option , "reset" ) == 0 ) info . window_width = 0 ; } option = GetImageOption ( image_info , "dcm:window" ) ; if ( option != ( char * ) NULL ) { GeometryInfo geometry_info ; MagickStatusType flags ; flags = ParseGeometry ( option , & geometry_info ) ; if ( flags & RhoValue ) info . window_center = geometry_info . rho ; if ( flags & SigmaValue ) info . window_width = geometry_info . sigma ; info . rescale = MagickTrue ; } option = GetImageOption ( image_info , "dcm:rescale" ) ; if ( option != ( char * ) NULL ) info . rescale = IsStringTrue ( option ) ; if ( ( info . window_center != 0 ) && ( info . window_width == 0 ) ) info . window_width = info . window_center ; status = ReadDCMPixels ( image , & info , stream_info , MagickTrue , exception ) ; if ( ( status != MagickFalse ) && ( stream_info -> segment_count > 1 ) ) { if ( stream_info -> offset_count > 0 ) ( void ) SeekBlob ( image , ( MagickOffsetType ) stream_info -> offsets [ 0 ] + stream_info -> segments [ 1 ] , SEEK_SET ) ; ( void ) ReadDCMPixels ( image , & info , stream_info , MagickFalse , exception ) ; } } if ( SetImageGray ( image , exception ) != MagickFalse ) ( void ) SetImageColorspace ( image , GRAYColorspace , exception ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , "UnexpectedEndOfFile" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; if ( scene < ( ssize_t ) ( number_scenes - 1 ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { status = MagickFalse ; break ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } if ( TellBlob ( image ) < ( MagickOffsetType ) GetBlobSize ( image ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { status = MagickFalse ; break ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; ( void ) CloseBlob ( image ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; return ( GetFirstImageInList ( image ) ) ; }
CWE-20 static Image * ReadPICTImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { <S2SV_StartBug> # define ThrowPICTException ( exception , message ) { if ( tile_image != ( Image * ) NULL ) tile_image = DestroyImage ( tile_image ) ; if ( read_info != ( ImageInfo * ) NULL ) read_info = DestroyImageInfo ( read_info ) ; ThrowReaderException ( ( exception ) , ( message ) ) ; } <S2SV_EndBug> char geometry [ MagickPathExtent ] , header_ole [ 4 ] ; Image * image , * tile_image ; ImageInfo * read_info ; int c , code ; MagickBooleanType jpeg , status ; PICTRectangle frame ; PICTPixmap pixmap ; Quantum index ; register Quantum * q ; register ssize_t i , x ; size_t extent , length ; ssize_t count , flags , j , version , y ; StringInfo * profile ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } read_info = ( ImageInfo * ) NULL ; tile_image = ( Image * ) NULL ; pixmap . bits_per_pixel = 0 ; pixmap . component_count = 0 ; header_ole [ 0 ] = ReadBlobByte ( image ) ; header_ole [ 1 ] = ReadBlobByte ( image ) ; header_ole [ 2 ] = ReadBlobByte ( image ) ; header_ole [ 3 ] = ReadBlobByte ( image ) ; if ( ! ( ( header_ole [ 0 ] == 0x50 ) && ( header_ole [ 1 ] == 0x49 ) && ( header_ole [ 2 ] == 0x43 ) && ( header_ole [ 3 ] == 0x54 ) ) ) for ( i = 0 ; i < 508 ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; ( void ) ReadBlobMSBShort ( image ) ; if ( ReadRectangle ( image , & frame ) == MagickFalse ) ThrowPICTException ( CorruptImageError , "ImproperImageHeader" ) ; while ( ( c = ReadBlobByte ( image ) ) == 0 ) ; if ( c != 0x11 ) ThrowPICTException ( CorruptImageError , "ImproperImageHeader" ) ; version = ( ssize_t ) ReadBlobByte ( image ) ; if ( version == 2 ) { c = ReadBlobByte ( image ) ; if ( c != 0xff ) ThrowPICTException ( CorruptImageError , "ImproperImageHeader" ) ; } else if ( version != 1 ) ThrowPICTException ( CorruptImageError , "ImproperImageHeader" ) ; if ( ( frame . left < 0 ) || ( frame . right < 0 ) || ( frame . top < 0 ) || ( frame . bottom < 0 ) || ( frame . left >= frame . right ) || ( frame . top >= frame . bottom ) ) ThrowPICTException ( CorruptImageError , "ImproperImageHeader" ) ; flags = 0 ; image -> depth = 8 ; image -> columns = ( size_t ) ( frame . right - frame . left ) ; image -> rows = ( size_t ) ( frame . bottom - frame . top ) ; image -> resolution . x = DefaultResolution ; image -> resolution . y = DefaultResolution ; image -> units = UndefinedResolution ; if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status != MagickFalse ) status = ResetImagePixels ( image , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; jpeg = MagickFalse ; for ( code = 0 ; EOFBlob ( image ) == MagickFalse ; ) { if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; if ( ( version == 1 ) || ( ( TellBlob ( image ) % 2 ) != 0 ) ) code = ReadBlobByte ( image ) ; if ( version == 2 ) code = ReadBlobMSBSignedShort ( image ) ; if ( code < 0 ) break ; if ( code == 0 ) continue ; if ( code > 0xa1 ) { if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "%04X:" , code ) ; } else { if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "<S2SV_blank><S2SV_blank>%04X<S2SV_blank>%s:<S2SV_blank>%s" , code , codes [ code ] . name , codes [ code ] . description ) ; switch ( code ) { case 0x01 : { length = ReadBlobMSBShort ( image ) ; if ( length != 0x000a ) { for ( i = 0 ; i < ( ssize_t ) ( length - 2 ) ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; break ; } if ( ReadRectangle ( image , & frame ) == MagickFalse ) ThrowPICTException ( CorruptImageError , "ImproperImageHeader" ) ; if ( ( ( frame . left & 0x8000 ) != 0 ) || ( ( frame . top & 0x8000 ) != 0 ) ) break ; image -> columns = ( size_t ) ( frame . right - frame . left ) ; image -> rows = ( size_t ) ( frame . bottom - frame . top ) ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status != MagickFalse ) status = ResetImagePixels ( image , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; break ; } case 0x12 : case 0x13 : case 0x14 : { ssize_t pattern ; size_t height , width ; pattern = ( ssize_t ) ReadBlobMSBShort ( image ) ; for ( i = 0 ; i < 8 ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; if ( pattern == 2 ) { for ( i = 0 ; i < 5 ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; break ; } if ( pattern != 1 ) ThrowPICTException ( CorruptImageError , "UnknownPatternType" ) ; length = ReadBlobMSBShort ( image ) ; if ( ReadRectangle ( image , & frame ) == MagickFalse ) ThrowPICTException ( CorruptImageError , "ImproperImageHeader" ) ; if ( ReadPixmap ( image , & pixmap ) == MagickFalse ) ThrowPICTException ( CorruptImageError , "ImproperImageHeader" ) ; image -> depth = ( size_t ) pixmap . component_size ; image -> resolution . x = 1.0 * pixmap . horizontal_resolution ; image -> resolution . y = 1.0 * pixmap . vertical_resolution ; image -> units = PixelsPerInchResolution ; ( void ) ReadBlobMSBLong ( image ) ; flags = ( ssize_t ) ReadBlobMSBShort ( image ) ; length = ReadBlobMSBShort ( image ) ; for ( i = 0 ; i <= ( ssize_t ) length ; i ++ ) ( void ) ReadBlobMSBLong ( image ) ; width = ( size_t ) ( frame . bottom - frame . top ) ; height = ( size_t ) ( frame . right - frame . left ) ; if ( pixmap . bits_per_pixel <= 8 ) length &= 0x7fff ; if ( pixmap . bits_per_pixel == 16 ) width <<= 1 ; if ( length == 0 ) length = width ; if ( length < 8 ) { for ( i = 0 ; i < ( ssize_t ) ( length * height ) ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; } else for ( i = 0 ; i < ( ssize_t ) height ; i ++ ) { if ( EOFBlob ( image ) != MagickFalse ) break ; if ( length > 200 ) { for ( j = 0 ; j < ( ssize_t ) ReadBlobMSBShort ( image ) ; j ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; } else for ( j = 0 ; j < ( ssize_t ) ReadBlobByte ( image ) ; j ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; } break ; } case 0x1b : { image -> background_color . red = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ; image -> background_color . green = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ; image -> background_color . blue = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ; break ; } case 0x70 : case 0x71 : case 0x72 : case 0x73 : case 0x74 : case 0x75 : case 0x76 : case 0x77 : { length = ReadBlobMSBShort ( image ) ; for ( i = 0 ; i < ( ssize_t ) ( length - 2 ) ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; break ; } case 0x90 : case 0x91 : case 0x98 : case 0x99 : case 0x9a : case 0x9b : { PICTRectangle source , destination ; register unsigned char * p ; size_t j ; ssize_t bytes_per_line ; unsigned char * pixels ; bytes_per_line = 0 ; if ( ( code != 0x9a ) && ( code != 0x9b ) ) bytes_per_line = ( ssize_t ) ReadBlobMSBShort ( image ) ; else { ( void ) ReadBlobMSBShort ( image ) ; ( void ) ReadBlobMSBShort ( image ) ; ( void ) ReadBlobMSBShort ( image ) ; } if ( ReadRectangle ( image , & frame ) == MagickFalse ) ThrowPICTException ( CorruptImageError , "ImproperImageHeader" ) ; tile_image = CloneImage ( image , ( size_t ) ( frame . right - frame . left ) , ( size_t ) ( frame . bottom - frame . top ) , MagickTrue , exception ) ; if ( tile_image == ( Image * ) NULL ) ThrowPICTException ( CorruptImageError , "ImproperImageHeader" ) ; if ( ( code == 0x9a ) || ( code == 0x9b ) || ( ( bytes_per_line & 0x8000 ) != 0 ) ) { if ( ReadPixmap ( image , & pixmap ) == MagickFalse ) ThrowPICTException ( CorruptImageError , "ImproperImageHeader" ) ; tile_image -> depth = ( size_t ) pixmap . component_size ; tile_image -> alpha_trait = pixmap . component_count == 4 ? BlendPixelTrait : UndefinedPixelTrait ; tile_image -> resolution . x = ( double ) pixmap . horizontal_resolution ; tile_image -> resolution . y = ( double ) pixmap . vertical_resolution ; tile_image -> units = PixelsPerInchResolution ; if ( tile_image -> alpha_trait != UndefinedPixelTrait ) ( void ) SetImageAlpha ( tile_image , OpaqueAlpha , exception ) ; } if ( ( code != 0x9a ) && ( code != 0x9b ) ) { tile_image -> colors = 2 ; if ( ( bytes_per_line & 0x8000 ) != 0 ) { ( void ) ReadBlobMSBLong ( image ) ; flags = ( ssize_t ) ReadBlobMSBShort ( image ) ; tile_image -> colors = 1UL * ReadBlobMSBShort ( image ) + 1 ; } status = AcquireImageColormap ( tile_image , tile_image -> colors , exception ) ; if ( status == MagickFalse ) ThrowPICTException ( ResourceLimitError , "MemoryAllocationFailed" ) ; if ( ( bytes_per_line & 0x8000 ) != 0 ) { for ( i = 0 ; i < ( ssize_t ) tile_image -> colors ; i ++ ) { j = ReadBlobMSBShort ( image ) % tile_image -> colors ; if ( ( flags & 0x8000 ) != 0 ) j = ( size_t ) i ; tile_image -> colormap [ j ] . red = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ; tile_image -> colormap [ j ] . green = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ; tile_image -> colormap [ j ] . blue = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ; } } else { for ( i = 0 ; i < ( ssize_t ) tile_image -> colors ; i ++ ) { tile_image -> colormap [ i ] . red = ( Quantum ) ( QuantumRange - tile_image -> colormap [ i ] . red ) ; tile_image -> colormap [ i ] . green = ( Quantum ) ( QuantumRange - tile_image -> colormap [ i ] . green ) ; tile_image -> colormap [ i ] . blue = ( Quantum ) ( QuantumRange - tile_image -> colormap [ i ] . blue ) ; } } } if ( EOFBlob ( image ) != MagickFalse ) ThrowPICTException ( CorruptImageError , "InsufficientImageDataInFile" ) ; if ( ReadRectangle ( image , & source ) == MagickFalse ) ThrowPICTException ( CorruptImageError , "ImproperImageHeader" ) ; if ( ReadRectangle ( image , & destination ) == MagickFalse ) ThrowPICTException ( CorruptImageError , "ImproperImageHeader" ) ; ( void ) ReadBlobMSBShort ( image ) ; if ( ( code == 0x91 ) || ( code == 0x99 ) || ( code == 0x9b ) ) { length = ReadBlobMSBShort ( image ) ; for ( i = 0 ; i < ( ssize_t ) ( length - 2 ) ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; } if ( ( code != 0x9a ) && ( code != 0x9b ) && ( bytes_per_line & 0x8000 ) == 0 ) pixels = DecodeImage ( image , tile_image , ( size_t ) bytes_per_line , 1 , & extent ) ; else pixels = DecodeImage ( image , tile_image , ( size_t ) bytes_per_line , ( unsigned int ) pixmap . bits_per_pixel , & extent ) ; if ( pixels == ( unsigned char * ) NULL ) ThrowPICTException ( CorruptImageError , "UnableToUncompressImage" ) ; p = pixels ; for ( y = 0 ; y < ( ssize_t ) tile_image -> rows ; y ++ ) { if ( p > ( pixels + extent + image -> columns ) ) { pixels = ( unsigned char * ) RelinquishMagickMemory ( pixels ) ; ThrowPICTException ( CorruptImageError , "NotEnoughPixelData" ) ; } q = QueueAuthenticPixels ( tile_image , 0 , y , tile_image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) tile_image -> columns ; x ++ ) { if ( tile_image -> storage_class == PseudoClass ) { index = ( Quantum ) ConstrainColormapIndex ( tile_image , ( ssize_t ) * p , exception ) ; SetPixelIndex ( tile_image , index , q ) ; SetPixelRed ( tile_image , tile_image -> colormap [ ( ssize_t ) index ] . red , q ) ; SetPixelGreen ( tile_image , tile_image -> colormap [ ( ssize_t ) index ] . green , q ) ; SetPixelBlue ( tile_image , tile_image -> colormap [ ( ssize_t ) index ] . blue , q ) ; } else { if ( pixmap . bits_per_pixel == 16 ) { i = ( ssize_t ) ( * p ++ ) ; j = ( size_t ) ( * p ) ; SetPixelRed ( tile_image , ScaleCharToQuantum ( ( unsigned char ) ( ( i & 0x7c ) << 1 ) ) , q ) ; SetPixelGreen ( tile_image , ScaleCharToQuantum ( ( unsigned char ) ( ( ( i & 0x03 ) << 6 ) | ( ( j & 0xe0 ) >> 2 ) ) ) , q ) ; SetPixelBlue ( tile_image , ScaleCharToQuantum ( ( unsigned char ) ( ( j & 0x1f ) << 3 ) ) , q ) ; } else if ( tile_image -> alpha_trait == UndefinedPixelTrait ) { if ( p > ( pixels + extent + 2 * image -> columns ) ) ThrowPICTException ( CorruptImageError , "NotEnoughPixelData" ) ; SetPixelRed ( tile_image , ScaleCharToQuantum ( * p ) , q ) ; SetPixelGreen ( tile_image , ScaleCharToQuantum ( * ( p + tile_image -> columns ) ) , q ) ; SetPixelBlue ( tile_image , ScaleCharToQuantum ( * ( p + 2 * tile_image -> columns ) ) , q ) ; } else { if ( p > ( pixels + extent + 3 * image -> columns ) ) ThrowPICTException ( CorruptImageError , "NotEnoughPixelData" ) ; SetPixelAlpha ( tile_image , ScaleCharToQuantum ( * p ) , q ) ; SetPixelRed ( tile_image , ScaleCharToQuantum ( * ( p + tile_image -> columns ) ) , q ) ; SetPixelGreen ( tile_image , ScaleCharToQuantum ( * ( p + 2 * tile_image -> columns ) ) , q ) ; SetPixelBlue ( tile_image , ScaleCharToQuantum ( * ( p + 3 * tile_image -> columns ) ) , q ) ; } } p ++ ; q += GetPixelChannels ( tile_image ) ; } if ( SyncAuthenticPixels ( tile_image , exception ) == MagickFalse ) break ; if ( ( tile_image -> storage_class == DirectClass ) && ( pixmap . bits_per_pixel != 16 ) ) { p += ( pixmap . component_count - 1 ) * tile_image -> columns ; if ( p < pixels ) break ; } status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , tile_image -> rows ) ; if ( status == MagickFalse ) break ; } pixels = ( unsigned char * ) RelinquishMagickMemory ( pixels ) ; if ( ( jpeg == MagickFalse ) && ( EOFBlob ( image ) == MagickFalse ) ) if ( ( code == 0x9a ) || ( code == 0x9b ) || ( ( bytes_per_line & 0x8000 ) != 0 ) ) ( void ) CompositeImage ( image , tile_image , CopyCompositeOp , MagickTrue , ( ssize_t ) destination . left , ( ssize_t ) destination . top , exception ) ; tile_image = DestroyImage ( tile_image ) ; break ; } case 0xa1 : { unsigned char * info ; size_t type ; type = ReadBlobMSBShort ( image ) ; length = ReadBlobMSBShort ( image ) ; if ( length == 0 ) break ; ( void ) ReadBlobMSBLong ( image ) ; length -= MagickMin ( length , 4 ) ; if ( length == 0 ) break ; info = ( unsigned char * ) AcquireQuantumMemory ( length , sizeof ( * info ) ) ; if ( info == ( unsigned char * ) NULL ) break ; count = ReadBlob ( image , length , info ) ; if ( count != ( ssize_t ) length ) { info = ( unsigned char * ) RelinquishMagickMemory ( info ) ; ThrowPICTException ( ResourceLimitError , "UnableToReadImageData" ) ; } switch ( type ) { case 0xe0 : { profile = BlobToStringInfo ( ( const void * ) NULL , length ) ; SetStringInfoDatum ( profile , info ) ; status = SetImageProfile ( image , "icc" , profile , exception ) ; profile = DestroyStringInfo ( profile ) ; if ( status == MagickFalse ) { info = ( unsigned char * ) RelinquishMagickMemory ( info ) ; ThrowPICTException ( ResourceLimitError , "MemoryAllocationFailed" ) ; } break ; } case 0x1f2 : { profile = BlobToStringInfo ( ( const void * ) NULL , length ) ; SetStringInfoDatum ( profile , info ) ; status = SetImageProfile ( image , "iptc" , profile , exception ) ; if ( status == MagickFalse ) { info = ( unsigned char * ) RelinquishMagickMemory ( info ) ; ThrowPICTException ( ResourceLimitError , "MemoryAllocationFailed" ) ; } profile = DestroyStringInfo ( profile ) ; break ; } default : break ; } info = ( unsigned char * ) RelinquishMagickMemory ( info ) ; break ; } default : { if ( codes [ code ] . length == - 1 ) ( void ) ReadBlobMSBShort ( image ) ; else for ( i = 0 ; i < ( ssize_t ) codes [ code ] . length ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; } } } if ( code == 0xc00 ) { for ( i = 0 ; i < 24 ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; continue ; } if ( ( ( code >= 0xb0 ) && ( code <= 0xcf ) ) || ( ( code >= 0x8000 ) && ( code <= 0x80ff ) ) ) continue ; if ( code == 0x8200 ) { char filename [ MaxTextExtent ] ; FILE * file ; int unique_file ; jpeg = MagickTrue ; read_info = CloneImageInfo ( image_info ) ; SetImageInfoBlob ( read_info , ( void * ) NULL , 0 ) ; file = ( FILE * ) NULL ; unique_file = AcquireUniqueFileResource ( filename ) ; ( void ) FormatLocaleString ( read_info -> filename , MaxTextExtent , "jpeg:%s" , filename ) ; if ( unique_file != - 1 ) file = fdopen ( unique_file , "wb" ) ; if ( ( unique_file == - 1 ) || ( file == ( FILE * ) NULL ) ) { ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; ( void ) CopyMagickString ( image -> filename , read_info -> filename , MagickPathExtent ) ; ThrowPICTException ( FileOpenError , "UnableToCreateTemporaryFile" ) ; } length = ReadBlobMSBLong ( image ) ; if ( length > 154 ) { for ( i = 0 ; i < 6 ; i ++ ) ( void ) ReadBlobMSBLong ( image ) ; if ( ReadRectangle ( image , & frame ) == MagickFalse ) { ( void ) fclose ( file ) ; ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; ThrowPICTException ( CorruptImageError , "ImproperImageHeader" ) ; } for ( i = 0 ; i < 122 ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; for ( i = 0 ; i < ( ssize_t ) ( length - 154 ) ; i ++ ) { c = ReadBlobByte ( image ) ; if ( c == EOF ) break ; <S2SV_StartBug> ( void ) fputc ( c , file ) ; <S2SV_EndBug> } } ( void ) fclose ( file ) ; ( void ) close ( unique_file ) ; tile_image = ReadImage ( read_info , exception ) ; ( void ) RelinquishUniqueFileResource ( filename ) ; read_info = DestroyImageInfo ( read_info ) ; if ( tile_image == ( Image * ) NULL ) continue ; ( void ) FormatLocaleString ( geometry , MagickPathExtent , "%.20gx%.20g" , ( double ) MagickMax ( image -> columns , tile_image -> columns ) , ( double ) MagickMax ( image -> rows , tile_image -> rows ) ) ; ( void ) SetImageExtent ( image , MagickMax ( image -> columns , tile_image -> columns ) , MagickMax ( image -> rows , tile_image -> rows ) , exception ) ; ( void ) TransformImageColorspace ( image , tile_image -> colorspace , exception ) ; ( void ) CompositeImage ( image , tile_image , CopyCompositeOp , MagickTrue , ( ssize_t ) frame . left , ( ssize_t ) frame . right , exception ) ; image -> compression = tile_image -> compression ; tile_image = DestroyImage ( tile_image ) ; continue ; } if ( ( code == 0xff ) || ( code == 0xffff ) ) break ; if ( ( ( code >= 0xd0 ) && ( code <= 0xfe ) ) || ( ( code >= 0x8100 ) && ( code <= 0xffff ) ) ) { length = ReadBlobMSBShort ( image ) ; for ( i = 0 ; i < ( ssize_t ) length ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; continue ; } if ( ( code >= 0x100 ) && ( code <= 0x7fff ) ) { length = ( size_t ) ( ( code >> 7 ) & 0xff ) ; for ( i = 0 ; i < ( ssize_t ) length ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; continue ; } } ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
CWE-20 static Image * ReadPWPImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char filename [ MagickPathExtent ] ; FILE * file ; Image * image , * next_image , * pwp_image ; ImageInfo * read_info ; int c , unique_file ; MagickBooleanType status ; register Image * p ; register ssize_t i ; size_t filesize , length ; ssize_t count ; unsigned char magick [ MagickPathExtent ] ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImage ( image ) ; return ( ( Image * ) NULL ) ; } pwp_image = image ; memset ( magick , 0 , sizeof ( magick ) ) ; count = ReadBlob ( pwp_image , 5 , magick ) ; if ( ( count != 5 ) || ( LocaleNCompare ( ( char * ) magick , "SFW95" , 5 ) != 0 ) ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; read_info = CloneImageInfo ( image_info ) ; ( void ) SetImageInfoProgressMonitor ( read_info , ( MagickProgressMonitor ) NULL , ( void * ) NULL ) ; SetImageInfoBlob ( read_info , ( void * ) NULL , 0 ) ; unique_file = AcquireUniqueFileResource ( filename ) ; ( void ) FormatLocaleString ( read_info -> filename , MagickPathExtent , "sfw:%s" , filename ) ; for ( ; ; ) { ( void ) memset ( magick , 0 , sizeof ( magick ) ) ; for ( c = ReadBlobByte ( pwp_image ) ; c != EOF ; c = ReadBlobByte ( pwp_image ) ) { for ( i = 0 ; i < 17 ; i ++ ) magick [ i ] = magick [ i + 1 ] ; magick [ 17 ] = ( unsigned char ) c ; if ( LocaleNCompare ( ( char * ) ( magick + 12 ) , "SFW94A" , 6 ) == 0 ) break ; } if ( c == EOF ) { ( void ) RelinquishUniqueFileResource ( filename ) ; read_info = DestroyImageInfo ( read_info ) ; ThrowReaderException ( CorruptImageError , "UnexpectedEndOfFile" ) ; } if ( LocaleNCompare ( ( char * ) ( magick + 12 ) , "SFW94A" , 6 ) != 0 ) { ( void ) RelinquishUniqueFileResource ( filename ) ; read_info = DestroyImageInfo ( read_info ) ; ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; } file = ( FILE * ) NULL ; if ( unique_file != - 1 ) file = fdopen ( unique_file , "wb" ) ; if ( ( unique_file == - 1 ) || ( file == ( FILE * ) NULL ) ) { ( void ) RelinquishUniqueFileResource ( filename ) ; read_info = DestroyImageInfo ( read_info ) ; ThrowFileException ( exception , FileOpenError , "UnableToWriteFile" , image -> filename ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } length = fwrite ( "SFW94A" , 1 , 6 , file ) ; ( void ) length ; filesize = 65535UL * magick [ 2 ] + 256L * magick [ 1 ] + magick [ 0 ] ; for ( i = 0 ; i < ( ssize_t ) filesize ; i ++ ) { c = ReadBlobByte ( pwp_image ) ; if ( c == EOF ) break ; <S2SV_StartBug> ( void ) fputc ( c , file ) ; <S2SV_EndBug> } ( void ) fclose ( file ) ; if ( c == EOF ) { ( void ) RelinquishUniqueFileResource ( filename ) ; read_info = DestroyImageInfo ( read_info ) ; ThrowReaderException ( CorruptImageError , "UnexpectedEndOfFile" ) ; } next_image = ReadImage ( read_info , exception ) ; if ( next_image == ( Image * ) NULL ) break ; ( void ) FormatLocaleString ( next_image -> filename , MagickPathExtent , "slide_%02ld.sfw" , ( long ) next_image -> scene ) ; if ( image == ( Image * ) NULL ) image = next_image ; else { for ( p = image ; p -> next != ( Image * ) NULL ; p = GetNextImageInList ( p ) ) ; next_image -> previous = p ; next_image -> scene = p -> scene + 1 ; p -> next = next_image ; } if ( image_info -> number_scenes != 0 ) if ( next_image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( pwp_image ) , GetBlobSize ( pwp_image ) ) ; if ( status == MagickFalse ) break ; } if ( unique_file != - 1 ) ( void ) close ( unique_file ) ; ( void ) RelinquishUniqueFileResource ( filename ) ; read_info = DestroyImageInfo ( read_info ) ; if ( image != ( Image * ) NULL ) { if ( EOFBlob ( image ) != MagickFalse ) { char * message ; message = GetExceptionMessage ( errno ) ; ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , CorruptImageError , "UnexpectedEndOfFile" , "`%s\':<S2SV_blank>%s" , image -> filename , message ) ; message = DestroyString ( message ) ; } ( void ) CloseBlob ( image ) ; } return ( GetFirstImageInList ( image ) ) ; }
CWE-399 static Image * ReadSIXELImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char * sixel_buffer ; Image * image ; MagickBooleanType status ; register char * p ; register ssize_t x ; register Quantum * q ; size_t length ; ssize_t i , j , y ; unsigned char * sixel_pixels , * sixel_palette ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } length = MagickPathExtent ; sixel_buffer = ( char * ) AcquireQuantumMemory ( ( size_t ) length + MagickPathExtent , sizeof ( * sixel_buffer ) ) ; p = sixel_buffer ; if ( sixel_buffer != ( char * ) NULL ) while ( ReadBlobString ( image , p ) != ( char * ) NULL ) { if ( ( * p == '#' ) && ( ( p == sixel_buffer ) || ( * ( p - 1 ) == '\\n' ) ) ) continue ; if ( ( * p == '}' ) && ( * ( p + 1 ) == ';' ) ) break ; p += strlen ( p ) ; if ( ( size_t ) ( p - sixel_buffer + MagickPathExtent + 1 ) < length ) continue ; length <<= 1 ; sixel_buffer = ( char * ) ResizeQuantumMemory ( sixel_buffer , length + MagickPathExtent + 1 , sizeof ( * sixel_buffer ) ) ; if ( sixel_buffer == ( char * ) NULL ) break ; p = sixel_buffer + strlen ( sixel_buffer ) ; } if ( sixel_buffer == ( char * ) NULL ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; sixel_buffer [ length ] = '\\0' ; if ( sixel_decode ( image , ( unsigned char * ) sixel_buffer , & sixel_pixels , & image -> columns , & image -> rows , & sixel_palette , & image -> colors , exception ) == MagickFalse ) { <S2SV_StartBug> sixel_buffer = ( char * ) RelinquishMagickMemory ( sixel_buffer ) ; <S2SV_EndBug> ThrowReaderException ( CorruptImageError , "CorruptImage" ) ; } sixel_buffer = ( char * ) RelinquishMagickMemory ( sixel_buffer ) ; image -> depth = 24 ; image -> storage_class = PseudoClass ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) { sixel_pixels = ( unsigned char * ) RelinquishMagickMemory ( sixel_pixels ) ; sixel_palette = ( unsigned char * ) RelinquishMagickMemory ( sixel_palette ) ; return ( DestroyImageList ( image ) ) ; } if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) { sixel_pixels = ( unsigned char * ) RelinquishMagickMemory ( sixel_pixels ) ; sixel_palette = ( unsigned char * ) RelinquishMagickMemory ( sixel_palette ) ; ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; } for ( i = 0 ; i < ( ssize_t ) image -> colors ; ++ i ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( sixel_palette [ i * 4 + 0 ] ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( sixel_palette [ i * 4 + 1 ] ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( sixel_palette [ i * 4 + 2 ] ) ; } j = 0 ; if ( image_info -> ping == MagickFalse ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { j = ( ssize_t ) sixel_pixels [ y * image -> columns + x ] ; SetPixelIndex ( image , j , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } if ( y < ( ssize_t ) image -> rows ) { sixel_pixels = ( unsigned char * ) RelinquishMagickMemory ( sixel_pixels ) ; sixel_palette = ( unsigned char * ) RelinquishMagickMemory ( sixel_palette ) ; ThrowReaderException ( CorruptImageError , "NotEnoughPixelData" ) ; } } sixel_pixels = ( unsigned char * ) RelinquishMagickMemory ( sixel_pixels ) ; sixel_palette = ( unsigned char * ) RelinquishMagickMemory ( sixel_palette ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
CWE-119 <S2SV_StartBug> static PixelChannels * * AcquirePixelThreadSet ( const Image * image ) <S2SV_EndBug> { PixelChannels * * pixels ; register ssize_t i ; size_t <S2SV_StartBug> number_threads ; <S2SV_EndBug> number_threads = ( size_t ) GetMagickResourceLimit ( ThreadResource ) ; pixels = ( PixelChannels * * ) AcquireQuantumMemory ( number_threads , sizeof ( * pixels ) ) ; if ( pixels == ( PixelChannels * * ) NULL ) return ( ( PixelChannels * * ) NULL ) ; ( void ) memset ( pixels , 0 , number_threads * sizeof ( * pixels ) ) ; <S2SV_StartBug> for ( i = 0 ; i < ( ssize_t ) number_threads ; i ++ ) <S2SV_EndBug> { register ssize_t j ; <S2SV_StartBug> pixels [ i ] = ( PixelChannels * ) AcquireQuantumMemory ( image -> columns , <S2SV_EndBug> sizeof ( * * pixels ) ) ; if ( pixels [ i ] == ( PixelChannels * ) NULL ) return ( DestroyPixelThreadSet ( pixels ) ) ; <S2SV_StartBug> for ( j = 0 ; j < ( ssize_t ) image -> columns ; j ++ ) <S2SV_EndBug> { register ssize_t k ; for ( k = 0 ; k < MaxPixelChannels ; k ++ ) pixels [ i ] [ j ] . channel [ k ] = 0.0 ; } } return ( pixels ) ; }
CWE-20 static Image * ReadPICTImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { <S2SV_StartBug> # define ThrowPICTException ( exception , message ) { if ( tile_image != ( Image * ) NULL ) tile_image = DestroyImage ( tile_image ) ; if ( read_info != ( ImageInfo * ) NULL ) read_info = DestroyImageInfo ( read_info ) ; ThrowReaderException ( ( exception ) , ( message ) ) ; } <S2SV_EndBug> char geometry [ MagickPathExtent ] , header_ole [ 4 ] ; Image * image , * tile_image ; ImageInfo * read_info ; int c , code ; MagickBooleanType jpeg , status ; PICTRectangle frame ; PICTPixmap pixmap ; Quantum index ; register Quantum * q ; register ssize_t i , x ; size_t extent , length ; ssize_t count , flags , j , version , y ; StringInfo * profile ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } read_info = ( ImageInfo * ) NULL ; tile_image = ( Image * ) NULL ; pixmap . bits_per_pixel = 0 ; pixmap . component_count = 0 ; header_ole [ 0 ] = ReadBlobByte ( image ) ; header_ole [ 1 ] = ReadBlobByte ( image ) ; header_ole [ 2 ] = ReadBlobByte ( image ) ; header_ole [ 3 ] = ReadBlobByte ( image ) ; if ( ! ( ( header_ole [ 0 ] == 0x50 ) && ( header_ole [ 1 ] == 0x49 ) && ( header_ole [ 2 ] == 0x43 ) && ( header_ole [ 3 ] == 0x54 ) ) ) for ( i = 0 ; i < 508 ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; ( void ) ReadBlobMSBShort ( image ) ; if ( ReadRectangle ( image , & frame ) == MagickFalse ) ThrowPICTException ( CorruptImageError , "ImproperImageHeader" ) ; while ( ( c = ReadBlobByte ( image ) ) == 0 ) ; if ( c != 0x11 ) ThrowPICTException ( CorruptImageError , "ImproperImageHeader" ) ; version = ( ssize_t ) ReadBlobByte ( image ) ; if ( version == 2 ) { c = ReadBlobByte ( image ) ; if ( c != 0xff ) ThrowPICTException ( CorruptImageError , "ImproperImageHeader" ) ; } else if ( version != 1 ) ThrowPICTException ( CorruptImageError , "ImproperImageHeader" ) ; if ( ( frame . left < 0 ) || ( frame . right < 0 ) || ( frame . top < 0 ) || ( frame . bottom < 0 ) || ( frame . left >= frame . right ) || ( frame . top >= frame . bottom ) ) ThrowPICTException ( CorruptImageError , "ImproperImageHeader" ) ; flags = 0 ; image -> depth = 8 ; image -> columns = ( size_t ) ( frame . right - frame . left ) ; image -> rows = ( size_t ) ( frame . bottom - frame . top ) ; image -> resolution . x = DefaultResolution ; image -> resolution . y = DefaultResolution ; image -> units = UndefinedResolution ; if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status != MagickFalse ) status = ResetImagePixels ( image , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; jpeg = MagickFalse ; for ( code = 0 ; EOFBlob ( image ) == MagickFalse ; ) { if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; if ( ( version == 1 ) || ( ( TellBlob ( image ) % 2 ) != 0 ) ) code = ReadBlobByte ( image ) ; if ( version == 2 ) code = ReadBlobMSBSignedShort ( image ) ; if ( code < 0 ) break ; if ( code == 0 ) continue ; if ( code > 0xa1 ) { if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "%04X:" , code ) ; } else { if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "<S2SV_blank><S2SV_blank>%04X<S2SV_blank>%s:<S2SV_blank>%s" , code , codes [ code ] . name , codes [ code ] . description ) ; switch ( code ) { case 0x01 : { length = ReadBlobMSBShort ( image ) ; <S2SV_StartBug> if ( length != 0x000a ) <S2SV_EndBug> { for ( i = 0 ; i < ( ssize_t ) ( length - 2 ) ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; break ; } if ( ReadRectangle ( image , & frame ) == MagickFalse ) ThrowPICTException ( CorruptImageError , "ImproperImageHeader" ) ; if ( ( ( frame . left & 0x8000 ) != 0 ) || ( ( frame . top & 0x8000 ) != 0 ) ) break ; image -> columns = ( size_t ) ( frame . right - frame . left ) ; image -> rows = ( size_t ) ( frame . bottom - frame . top ) ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status != MagickFalse ) status = ResetImagePixels ( image , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; break ; } case 0x12 : case 0x13 : case 0x14 : { ssize_t pattern ; size_t height , width ; pattern = ( ssize_t ) ReadBlobMSBShort ( image ) ; for ( i = 0 ; i < 8 ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; if ( pattern == 2 ) { for ( i = 0 ; i < 5 ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; break ; } if ( pattern != 1 ) ThrowPICTException ( CorruptImageError , "UnknownPatternType" ) ; length = ReadBlobMSBShort ( image ) ; <S2SV_StartBug> if ( ReadRectangle ( image , & frame ) == MagickFalse ) <S2SV_EndBug> ThrowPICTException ( CorruptImageError , "ImproperImageHeader" ) ; if ( ReadPixmap ( image , & pixmap ) == MagickFalse ) ThrowPICTException ( CorruptImageError , "ImproperImageHeader" ) ; image -> depth = ( size_t ) pixmap . component_size ; image -> resolution . x = 1.0 * pixmap . horizontal_resolution ; image -> resolution . y = 1.0 * pixmap . vertical_resolution ; image -> units = PixelsPerInchResolution ; ( void ) ReadBlobMSBLong ( image ) ; flags = ( ssize_t ) ReadBlobMSBShort ( image ) ; <S2SV_StartBug> length = ReadBlobMSBShort ( image ) ; <S2SV_EndBug> for ( i = 0 ; i <= ( ssize_t ) length ; i ++ ) ( void ) ReadBlobMSBLong ( image ) ; width = ( size_t ) ( frame . bottom - frame . top ) ; height = ( size_t ) ( frame . right - frame . left ) ; if ( pixmap . bits_per_pixel <= 8 ) length &= 0x7fff ; if ( pixmap . bits_per_pixel == 16 ) width <<= 1 ; if ( length == 0 ) length = width ; if ( length < 8 ) { for ( i = 0 ; i < ( ssize_t ) ( length * height ) ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; } else for ( i = 0 ; i < ( ssize_t ) height ; i ++ ) { if ( EOFBlob ( image ) != MagickFalse ) break ; if ( length > 200 ) { for ( j = 0 ; j < ( ssize_t ) ReadBlobMSBShort ( image ) ; j ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; } else for ( j = 0 ; j < ( ssize_t ) ReadBlobByte ( image ) ; j ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; } break ; } case 0x1b : { image -> background_color . red = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ; image -> background_color . green = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ; image -> background_color . blue = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ; break ; } case 0x70 : case 0x71 : case 0x72 : case 0x73 : case 0x74 : case 0x75 : case 0x76 : case 0x77 : { <S2SV_StartBug> length = ReadBlobMSBShort ( image ) ; <S2SV_EndBug> for ( i = 0 ; i < ( ssize_t ) ( length - 2 ) ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; break ; } case 0x90 : case 0x91 : case 0x98 : case 0x99 : case 0x9a : case 0x9b : { PICTRectangle source , destination ; register unsigned char * p ; size_t j ; ssize_t bytes_per_line ; unsigned char * pixels ; bytes_per_line = 0 ; if ( ( code != 0x9a ) && ( code != 0x9b ) ) bytes_per_line = ( ssize_t ) ReadBlobMSBShort ( image ) ; else { ( void ) ReadBlobMSBShort ( image ) ; ( void ) ReadBlobMSBShort ( image ) ; ( void ) ReadBlobMSBShort ( image ) ; } if ( ReadRectangle ( image , & frame ) == MagickFalse ) ThrowPICTException ( CorruptImageError , "ImproperImageHeader" ) ; tile_image = CloneImage ( image , ( size_t ) ( frame . right - frame . left ) , ( size_t ) ( frame . bottom - frame . top ) , MagickTrue , exception ) ; if ( tile_image == ( Image * ) NULL ) ThrowPICTException ( CorruptImageError , "ImproperImageHeader" ) ; if ( ( code == 0x9a ) || ( code == 0x9b ) || ( ( bytes_per_line & 0x8000 ) != 0 ) ) { if ( ReadPixmap ( image , & pixmap ) == MagickFalse ) ThrowPICTException ( CorruptImageError , "ImproperImageHeader" ) ; tile_image -> depth = ( size_t ) pixmap . component_size ; tile_image -> alpha_trait = pixmap . component_count == 4 ? BlendPixelTrait : UndefinedPixelTrait ; tile_image -> resolution . x = ( double ) pixmap . horizontal_resolution ; tile_image -> resolution . y = ( double ) pixmap . vertical_resolution ; tile_image -> units = PixelsPerInchResolution ; if ( tile_image -> alpha_trait != UndefinedPixelTrait ) ( void ) SetImageAlpha ( tile_image , OpaqueAlpha , exception ) ; } if ( ( code != 0x9a ) && ( code != 0x9b ) ) { tile_image -> colors = 2 ; if ( ( bytes_per_line & 0x8000 ) != 0 ) { ( void ) ReadBlobMSBLong ( image ) ; flags = ( ssize_t ) ReadBlobMSBShort ( image ) ; tile_image -> colors = 1UL * ReadBlobMSBShort ( image ) + 1 ; } status = AcquireImageColormap ( tile_image , tile_image -> colors , exception ) ; if ( status == MagickFalse ) ThrowPICTException ( ResourceLimitError , "MemoryAllocationFailed" ) ; if ( ( bytes_per_line & 0x8000 ) != 0 ) { for ( i = 0 ; i < ( ssize_t ) tile_image -> colors ; i ++ ) { j = ReadBlobMSBShort ( image ) % tile_image -> colors ; if ( ( flags & 0x8000 ) != 0 ) j = ( size_t ) i ; tile_image -> colormap [ j ] . red = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ; tile_image -> colormap [ j ] . green = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ; tile_image -> colormap [ j ] . blue = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ; } } else { for ( i = 0 ; i < ( ssize_t ) tile_image -> colors ; i ++ ) { tile_image -> colormap [ i ] . red = ( Quantum ) ( QuantumRange - tile_image -> colormap [ i ] . red ) ; tile_image -> colormap [ i ] . green = ( Quantum ) ( QuantumRange - tile_image -> colormap [ i ] . green ) ; tile_image -> colormap [ i ] . blue = ( Quantum ) ( QuantumRange - tile_image -> colormap [ i ] . blue ) ; } } } if ( EOFBlob ( image ) != MagickFalse ) ThrowPICTException ( CorruptImageError , "InsufficientImageDataInFile" ) ; if ( ReadRectangle ( image , & source ) == MagickFalse ) ThrowPICTException ( CorruptImageError , "ImproperImageHeader" ) ; if ( ReadRectangle ( image , & destination ) == MagickFalse ) ThrowPICTException ( CorruptImageError , "ImproperImageHeader" ) ; ( void ) ReadBlobMSBShort ( image ) ; if ( ( code == 0x91 ) || ( code == 0x99 ) || ( code == 0x9b ) ) { <S2SV_StartBug> length = ReadBlobMSBShort ( image ) ; <S2SV_EndBug> for ( i = 0 ; i < ( ssize_t ) ( length - 2 ) ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; } if ( ( code != 0x9a ) && ( code != 0x9b ) && ( bytes_per_line & 0x8000 ) == 0 ) pixels = DecodeImage ( image , tile_image , ( size_t ) bytes_per_line , 1 , & extent ) ; else pixels = DecodeImage ( image , tile_image , ( size_t ) bytes_per_line , ( unsigned int ) pixmap . bits_per_pixel , & extent ) ; if ( pixels == ( unsigned char * ) NULL ) ThrowPICTException ( CorruptImageError , "UnableToUncompressImage" ) ; p = pixels ; for ( y = 0 ; y < ( ssize_t ) tile_image -> rows ; y ++ ) { if ( p > ( pixels + extent + image -> columns ) ) { pixels = ( unsigned char * ) RelinquishMagickMemory ( pixels ) ; ThrowPICTException ( CorruptImageError , "NotEnoughPixelData" ) ; } q = QueueAuthenticPixels ( tile_image , 0 , y , tile_image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) tile_image -> columns ; x ++ ) { if ( tile_image -> storage_class == PseudoClass ) { index = ( Quantum ) ConstrainColormapIndex ( tile_image , ( ssize_t ) * p , exception ) ; SetPixelIndex ( tile_image , index , q ) ; SetPixelRed ( tile_image , tile_image -> colormap [ ( ssize_t ) index ] . red , q ) ; SetPixelGreen ( tile_image , tile_image -> colormap [ ( ssize_t ) index ] . green , q ) ; SetPixelBlue ( tile_image , tile_image -> colormap [ ( ssize_t ) index ] . blue , q ) ; } else { if ( pixmap . bits_per_pixel == 16 ) { i = ( ssize_t ) ( * p ++ ) ; j = ( size_t ) ( * p ) ; SetPixelRed ( tile_image , ScaleCharToQuantum ( ( unsigned char ) ( ( i & 0x7c ) << 1 ) ) , q ) ; SetPixelGreen ( tile_image , ScaleCharToQuantum ( ( unsigned char ) ( ( ( i & 0x03 ) << 6 ) | ( ( j & 0xe0 ) >> 2 ) ) ) , q ) ; SetPixelBlue ( tile_image , ScaleCharToQuantum ( ( unsigned char ) ( ( j & 0x1f ) << 3 ) ) , q ) ; } else if ( tile_image -> alpha_trait == UndefinedPixelTrait ) { if ( p > ( pixels + extent + 2 * image -> columns ) ) ThrowPICTException ( CorruptImageError , "NotEnoughPixelData" ) ; SetPixelRed ( tile_image , ScaleCharToQuantum ( * p ) , q ) ; SetPixelGreen ( tile_image , ScaleCharToQuantum ( * ( p + tile_image -> columns ) ) , q ) ; SetPixelBlue ( tile_image , ScaleCharToQuantum ( * ( p + 2 * tile_image -> columns ) ) , q ) ; } else { if ( p > ( pixels + extent + 3 * image -> columns ) ) ThrowPICTException ( CorruptImageError , "NotEnoughPixelData" ) ; SetPixelAlpha ( tile_image , ScaleCharToQuantum ( * p ) , q ) ; SetPixelRed ( tile_image , ScaleCharToQuantum ( * ( p + tile_image -> columns ) ) , q ) ; SetPixelGreen ( tile_image , ScaleCharToQuantum ( * ( p + 2 * tile_image -> columns ) ) , q ) ; SetPixelBlue ( tile_image , ScaleCharToQuantum ( * ( p + 3 * tile_image -> columns ) ) , q ) ; } } p ++ ; q += GetPixelChannels ( tile_image ) ; } if ( SyncAuthenticPixels ( tile_image , exception ) == MagickFalse ) break ; if ( ( tile_image -> storage_class == DirectClass ) && ( pixmap . bits_per_pixel != 16 ) ) { p += ( pixmap . component_count - 1 ) * tile_image -> columns ; if ( p < pixels ) break ; } status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , tile_image -> rows ) ; if ( status == MagickFalse ) break ; } pixels = ( unsigned char * ) RelinquishMagickMemory ( pixels ) ; if ( ( jpeg == MagickFalse ) && ( EOFBlob ( image ) == MagickFalse ) ) if ( ( code == 0x9a ) || ( code == 0x9b ) || ( ( bytes_per_line & 0x8000 ) != 0 ) ) ( void ) CompositeImage ( image , tile_image , CopyCompositeOp , MagickTrue , ( ssize_t ) destination . left , ( ssize_t ) destination . top , exception ) ; tile_image = DestroyImage ( tile_image ) ; break ; } case 0xa1 : { unsigned char * info ; size_t type ; type = ReadBlobMSBShort ( image ) ; length = ReadBlobMSBShort ( image ) ; <S2SV_StartBug> if ( length == 0 ) <S2SV_EndBug> break ; ( void ) ReadBlobMSBLong ( image ) ; length -= MagickMin ( length , 4 ) ; if ( length == 0 ) break ; info = ( unsigned char * ) AcquireQuantumMemory ( length , sizeof ( * info ) ) ; if ( info == ( unsigned char * ) NULL ) break ; count = ReadBlob ( image , length , info ) ; if ( count != ( ssize_t ) length ) { info = ( unsigned char * ) RelinquishMagickMemory ( info ) ; ThrowPICTException ( ResourceLimitError , "UnableToReadImageData" ) ; } switch ( type ) { case 0xe0 : { profile = BlobToStringInfo ( ( const void * ) NULL , length ) ; SetStringInfoDatum ( profile , info ) ; status = SetImageProfile ( image , "icc" , profile , exception ) ; profile = DestroyStringInfo ( profile ) ; if ( status == MagickFalse ) { info = ( unsigned char * ) RelinquishMagickMemory ( info ) ; ThrowPICTException ( ResourceLimitError , "MemoryAllocationFailed" ) ; } break ; } case 0x1f2 : { profile = BlobToStringInfo ( ( const void * ) NULL , length ) ; SetStringInfoDatum ( profile , info ) ; status = SetImageProfile ( image , "iptc" , profile , exception ) ; if ( status == MagickFalse ) { info = ( unsigned char * ) RelinquishMagickMemory ( info ) ; ThrowPICTException ( ResourceLimitError , "MemoryAllocationFailed" ) ; } profile = DestroyStringInfo ( profile ) ; break ; } default : break ; } info = ( unsigned char * ) RelinquishMagickMemory ( info ) ; break ; } default : { if ( codes [ code ] . length == - 1 ) ( void ) ReadBlobMSBShort ( image ) ; else for ( i = 0 ; i < ( ssize_t ) codes [ code ] . length ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; } } } if ( code == 0xc00 ) { for ( i = 0 ; i < 24 ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; continue ; } if ( ( ( code >= 0xb0 ) && ( code <= 0xcf ) ) || ( ( code >= 0x8000 ) && ( code <= 0x80ff ) ) ) continue ; if ( code == 0x8200 ) { char filename [ MaxTextExtent ] ; FILE * file ; int unique_file ; jpeg = MagickTrue ; read_info = CloneImageInfo ( image_info ) ; SetImageInfoBlob ( read_info , ( void * ) NULL , 0 ) ; file = ( FILE * ) NULL ; unique_file = AcquireUniqueFileResource ( filename ) ; ( void ) FormatLocaleString ( read_info -> filename , MaxTextExtent , "jpeg:%s" , filename ) ; if ( unique_file != - 1 ) file = fdopen ( unique_file , "wb" ) ; if ( ( unique_file == - 1 ) || ( file == ( FILE * ) NULL ) ) { ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; ( void ) CopyMagickString ( image -> filename , read_info -> filename , MagickPathExtent ) ; ThrowPICTException ( FileOpenError , "UnableToCreateTemporaryFile" ) ; } length = ReadBlobMSBLong ( image ) ; <S2SV_StartBug> if ( length > 154 ) <S2SV_EndBug> { for ( i = 0 ; i < 6 ; i ++ ) ( void ) ReadBlobMSBLong ( image ) ; if ( ReadRectangle ( image , & frame ) == MagickFalse ) { ( void ) fclose ( file ) ; ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; ThrowPICTException ( CorruptImageError , "ImproperImageHeader" ) ; } for ( i = 0 ; i < 122 ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; for ( i = 0 ; i < ( ssize_t ) ( length - 154 ) ; i ++ ) { c = ReadBlobByte ( image ) ; if ( c == EOF ) break ; if ( fputc ( c , file ) != c ) break ; } } ( void ) fclose ( file ) ; ( void ) close ( unique_file ) ; tile_image = ReadImage ( read_info , exception ) ; ( void ) RelinquishUniqueFileResource ( filename ) ; read_info = DestroyImageInfo ( read_info ) ; if ( tile_image == ( Image * ) NULL ) continue ; ( void ) FormatLocaleString ( geometry , MagickPathExtent , "%.20gx%.20g" , ( double ) MagickMax ( image -> columns , tile_image -> columns ) , ( double ) MagickMax ( image -> rows , tile_image -> rows ) ) ; ( void ) SetImageExtent ( image , MagickMax ( image -> columns , tile_image -> columns ) , MagickMax ( image -> rows , tile_image -> rows ) , exception ) ; ( void ) TransformImageColorspace ( image , tile_image -> colorspace , exception ) ; ( void ) CompositeImage ( image , tile_image , CopyCompositeOp , MagickTrue , ( ssize_t ) frame . left , ( ssize_t ) frame . right , exception ) ; image -> compression = tile_image -> compression ; tile_image = DestroyImage ( tile_image ) ; continue ; } if ( ( code == 0xff ) || ( code == 0xffff ) ) break ; if ( ( ( code >= 0xd0 ) && ( code <= 0xfe ) ) || ( ( code >= 0x8100 ) && ( code <= 0xffff ) ) ) { length = ReadBlobMSBShort ( image ) ; <S2SV_StartBug> for ( i = 0 ; i < ( ssize_t ) length ; i ++ ) <S2SV_EndBug> if ( ReadBlobByte ( image ) == EOF ) break ; continue ; } if ( ( code >= 0x100 ) && ( code <= 0x7fff ) ) { length = ( size_t ) ( ( code >> 7 ) & 0xff ) ; <S2SV_StartBug> for ( i = 0 ; i < ( ssize_t ) length ; i ++ ) <S2SV_EndBug> if ( ReadBlobByte ( image ) == EOF ) break ; continue ; } } ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
CWE-119 static int format8BIM ( Image * ifile , Image * ofile ) { char temp [ MagickPathExtent ] ; unsigned int foundOSType ; int ID , resCount , i , c ; ssize_t count ; unsigned char * PString , * str ; resCount = 0 ; foundOSType = 0 ; ( void ) foundOSType ; c = ReadBlobByte ( ifile ) ; while ( c != EOF ) { if ( c == '8' ) { unsigned char buffer [ 5 ] ; buffer [ 0 ] = ( unsigned char ) c ; for ( i = 1 ; i < 4 ; i ++ ) { c = ReadBlobByte ( ifile ) ; if ( c == EOF ) return ( - 1 ) ; buffer [ i ] = ( unsigned char ) c ; } buffer [ 4 ] = 0 ; if ( strcmp ( ( const char * ) buffer , "8BIM" ) == 0 ) foundOSType = 1 ; else continue ; } else { c = ReadBlobByte ( ifile ) ; continue ; } ID = ReadBlobMSBSignedShort ( ifile ) ; if ( ID < 0 ) return ( - 1 ) ; { unsigned char plen ; c = ReadBlobByte ( ifile ) ; if ( c == EOF ) return ( - 1 ) ; plen = ( unsigned char ) c ; PString = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ( plen + MagickPathExtent ) , sizeof ( * PString ) ) ; if ( PString == ( unsigned char * ) NULL ) return 0 ; for ( i = 0 ; i < plen ; i ++ ) { c = ReadBlobByte ( ifile ) ; if ( c == EOF ) { PString = ( unsigned char * ) RelinquishMagickMemory ( PString ) ; return - 1 ; } PString [ i ] = ( unsigned char ) c ; } PString [ plen ] = 0 ; if ( ( plen & 0x01 ) == 0 ) { c = ReadBlobByte ( ifile ) ; if ( c == EOF ) { PString = ( unsigned char * ) RelinquishMagickMemory ( PString ) ; return - 1 ; } } } count = ( ssize_t ) ReadBlobMSBSignedLong ( ifile ) ; if ( ( count < 0 ) || ( count > GetBlobSize ( ifile ) ) ) { PString = ( unsigned char * ) RelinquishMagickMemory ( PString ) ; return - 1 ; } <S2SV_StartBug> str = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) count , sizeof ( * str ) ) ; <S2SV_EndBug> if ( str == ( unsigned char * ) NULL ) { PString = ( unsigned char * ) RelinquishMagickMemory ( PString ) ; return 0 ; } for ( i = 0 ; i < ( ssize_t ) count ; i ++ ) { c = ReadBlobByte ( ifile ) ; if ( c == EOF ) { str = ( unsigned char * ) RelinquishMagickMemory ( str ) ; PString = ( unsigned char * ) RelinquishMagickMemory ( PString ) ; return - 1 ; } str [ i ] = ( unsigned char ) c ; } if ( ID != THUMBNAIL_ID ) { if ( strlen ( ( const char * ) PString ) > 0 ) ( void ) FormatLocaleString ( temp , MagickPathExtent , "8BIM#%d#%s=" , ID , PString ) ; else ( void ) FormatLocaleString ( temp , MagickPathExtent , "8BIM#%d=" , ID ) ; ( void ) WriteBlobString ( ofile , temp ) ; if ( ID == IPTC_ID ) { formatString ( ofile , "IPTC" , 4 ) ; formatIPTCfromBuffer ( ofile , ( char * ) str , ( ssize_t ) count ) ; } else formatString ( ofile , ( char * ) str , ( ssize_t ) count ) ; } str = ( unsigned char * ) RelinquishMagickMemory ( str ) ; PString = ( unsigned char * ) RelinquishMagickMemory ( PString ) ; resCount ++ ; c = ReadBlobByte ( ifile ) ; } return resCount ; }
CWE-787 <S2SV_StartBug> static void InsertRow ( Image * image , ssize_t depth , unsigned char * p , ssize_t y , <S2SV_EndBug> ExceptionInfo * exception ) { <S2SV_StartBug> size_t bit ; ssize_t x ; <S2SV_EndBug> <S2SV_StartBug> register Quantum * q ; <S2SV_EndBug> Quantum index ; index = 0 ; <S2SV_StartBug> switch ( depth ) <S2SV_EndBug> { case 1 : { <S2SV_StartBug> q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; <S2SV_EndBug> if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) { for ( bit = 0 ; bit < 8 ; bit ++ ) { <S2SV_StartBug> index = ( Quantum ) ( ( ( ( * p ) & ( 0x80 >> bit ) ) != 0 ) ? 0x01 : 0x00 ) ; <S2SV_EndBug> SetPixelIndex ( image , index , q ) ; <S2SV_StartBug> q += GetPixelChannels ( image ) ; <S2SV_EndBug> } p ++ ; } if ( ( image -> columns % 8 ) != 0 ) { <S2SV_StartBug> for ( bit = 0 ; bit < ( image -> columns % 8 ) ; bit ++ ) <S2SV_EndBug> { <S2SV_StartBug> index = ( Quantum ) ( ( ( ( * p ) & ( 0x80 >> bit ) ) != 0 ) ? 0x01 : 0x00 ) ; <S2SV_EndBug> SetPixelIndex ( image , index , q ) ; <S2SV_StartBug> q += GetPixelChannels ( image ) ; <S2SV_EndBug> } p ++ ; } <S2SV_StartBug> ( void ) SyncAuthenticPixels ( image , exception ) ; <S2SV_EndBug> break ; } case 2 : { <S2SV_StartBug> q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; <S2SV_EndBug> <S2SV_StartBug> if ( q == ( Quantum * ) NULL ) <S2SV_EndBug> break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 1 ) ; x += 2 ) { <S2SV_StartBug> index = ConstrainColormapIndex ( image , ( * p >> 6 ) & 0x3 , exception ) ; <S2SV_EndBug> SetPixelIndex ( image , index , q ) ; <S2SV_StartBug> q += GetPixelChannels ( image ) ; <S2SV_EndBug> <S2SV_StartBug> index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x3 , exception ) ; <S2SV_EndBug> SetPixelIndex ( image , index , q ) ; <S2SV_StartBug> q += GetPixelChannels ( image ) ; <S2SV_EndBug> index = ConstrainColormapIndex ( image , ( * p >> 2 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; index = ConstrainColormapIndex ( image , ( * p ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; p ++ ; } if ( ( image -> columns % 4 ) != 0 ) { index = ConstrainColormapIndex ( image , ( * p >> 6 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; if ( ( image -> columns % 4 ) >= 1 ) { index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; if ( ( image -> columns % 4 ) >= 2 ) { index = ConstrainColormapIndex ( image , ( * p >> 2 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; } } p ++ ; } ( void ) SyncAuthenticPixels ( image , exception ) ; break ; } case 4 : { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 1 ) ; x += 2 ) { index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0xf , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; index = ConstrainColormapIndex ( image , ( * p ) & 0xf , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; p ++ ; } if ( ( image -> columns % 2 ) != 0 ) { <S2SV_StartBug> index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0xf , exception ) ; <S2SV_EndBug> SetPixelIndex ( image , index , q ) ; <S2SV_StartBug> q += GetPixelChannels ( image ) ; <S2SV_EndBug> <S2SV_StartBug> p ++ ; <S2SV_EndBug> } ( void ) SyncAuthenticPixels ( image , exception ) ; break ; } case 8 : { <S2SV_StartBug> q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; <S2SV_EndBug> <S2SV_StartBug> if ( q == ( Quantum * ) NULL ) <S2SV_EndBug> break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { <S2SV_StartBug> index = ConstrainColormapIndex ( image , * p , exception ) ; <S2SV_EndBug> SetPixelIndex ( image , index , q ) ; p ++ ; q += GetPixelChannels ( image ) ; } ( void ) SyncAuthenticPixels ( image , exception ) ; break ; } } }
CWE-20 static Image * ReadCUTImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { <S2SV_StartBug> # define ThrowCUTReaderException ( severity , tag ) { if ( palette != NULL ) palette = DestroyImage ( palette ) ; if ( clone_info != NULL ) clone_info = DestroyImageInfo ( clone_info ) ; ThrowReaderException ( severity , tag ) ; } <S2SV_EndBug> Image * image , * palette ; ImageInfo * clone_info ; MagickBooleanType status ; MagickOffsetType offset ; size_t EncodedByte ; unsigned char RunCount , RunValue , RunCountMasked ; CUTHeader Header ; CUTPalHeader PalHeader ; ssize_t depth ; ssize_t i , j ; ssize_t ldblk ; unsigned char * BImgBuff = NULL , * ptrB ; register Quantum * q ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } palette = NULL ; clone_info = NULL ; Header . Width = ReadBlobLSBShort ( image ) ; Header . Height = ReadBlobLSBShort ( image ) ; Header . Reserved = ReadBlobLSBShort ( image ) ; if ( Header . Width == 0 || Header . Height == 0 || Header . Reserved != 0 ) CUT_KO : ThrowCUTReaderException ( CorruptImageError , "ImproperImageHeader" ) ; EncodedByte = ReadBlobLSBShort ( image ) ; RunCount = ( unsigned char ) ReadBlobByte ( image ) ; RunCountMasked = RunCount & 0x7F ; ldblk = 0 ; while ( ( int ) RunCountMasked != 0 ) { i = 1 ; if ( ( int ) RunCount < 0x80 ) i = ( ssize_t ) RunCountMasked ; offset = SeekBlob ( image , TellBlob ( image ) + i , SEEK_SET ) ; if ( offset < 0 ) ThrowCUTReaderException ( CorruptImageError , "ImproperImageHeader" ) ; if ( EOFBlob ( image ) != MagickFalse ) goto CUT_KO ; EncodedByte -= i + 1 ; ldblk += ( ssize_t ) RunCountMasked ; RunCount = ( unsigned char ) ReadBlobByte ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) goto CUT_KO ; RunCountMasked = RunCount & 0x7F ; } if ( EncodedByte != 1 ) goto CUT_KO ; i = 0 ; if ( ldblk == ( int ) Header . Width ) i = 8 ; if ( 2 * ldblk == ( int ) Header . Width ) i = 4 ; if ( 8 * ldblk == ( int ) Header . Width ) i = 1 ; if ( i == 0 ) goto CUT_KO ; depth = i ; image -> columns = Header . Width ; image -> rows = Header . Height ; image -> depth = 8 ; image -> colors = ( size_t ) ( GetQuantumRange ( 1UL * i ) + 1 ) ; if ( image_info -> ping != MagickFalse ) goto Finish ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; if ( ( clone_info = CloneImageInfo ( image_info ) ) == NULL ) goto NoPalette ; i = ( ssize_t ) strlen ( clone_info -> filename ) ; j = i ; while ( -- i > 0 ) { if ( clone_info -> filename [ i ] == '.' ) { break ; } if ( clone_info -> filename [ i ] == '/' || clone_info -> filename [ i ] == '\\\\' || clone_info -> filename [ i ] == ':' ) { i = j ; break ; } } ( void ) CopyMagickString ( clone_info -> filename + i , ".PAL" , ( size_t ) ( MagickPathExtent - i ) ) ; if ( ( clone_info -> file = fopen_utf8 ( clone_info -> filename , "rb" ) ) == NULL ) { ( void ) CopyMagickString ( clone_info -> filename + i , ".pal" , ( size_t ) ( MagickPathExtent - i ) ) ; if ( ( clone_info -> file = fopen_utf8 ( clone_info -> filename , "rb" ) ) == NULL ) { clone_info -> filename [ i ] = '\\0' ; if ( ( clone_info -> file = fopen_utf8 ( clone_info -> filename , "rb" ) ) == NULL ) { clone_info = DestroyImageInfo ( clone_info ) ; clone_info = NULL ; goto NoPalette ; } } } if ( ( palette = AcquireImage ( clone_info , exception ) ) == NULL ) goto NoPalette ; status = OpenBlob ( clone_info , palette , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { ErasePalette : palette = DestroyImage ( palette ) ; palette = NULL ; goto NoPalette ; } if ( palette != NULL ) { ( void ) ReadBlob ( palette , 2 , ( unsigned char * ) PalHeader . FileId ) ; if ( strncmp ( PalHeader . FileId , "AH" , 2 ) != 0 ) goto ErasePalette ; PalHeader . Version = ReadBlobLSBShort ( palette ) ; PalHeader . Size = ReadBlobLSBShort ( palette ) ; PalHeader . FileType = ( char ) ReadBlobByte ( palette ) ; PalHeader . SubType = ( char ) ReadBlobByte ( palette ) ; PalHeader . BoardID = ReadBlobLSBShort ( palette ) ; PalHeader . GraphicsMode = ReadBlobLSBShort ( palette ) ; PalHeader . MaxIndex = ReadBlobLSBShort ( palette ) ; PalHeader . MaxRed = ReadBlobLSBShort ( palette ) ; PalHeader . MaxGreen = ReadBlobLSBShort ( palette ) ; PalHeader . MaxBlue = ReadBlobLSBShort ( palette ) ; ( void ) ReadBlob ( palette , 20 , ( unsigned char * ) PalHeader . PaletteId ) ; if ( EOFBlob ( image ) ) ThrowCUTReaderException ( CorruptImageError , "UnexpectedEndOfFile" ) ; if ( PalHeader . MaxIndex < 1 ) goto ErasePalette ; image -> colors = PalHeader . MaxIndex + 1 ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) goto NoMemory ; if ( PalHeader . MaxRed == 0 ) PalHeader . MaxRed = ( unsigned int ) QuantumRange ; if ( PalHeader . MaxGreen == 0 ) PalHeader . MaxGreen = ( unsigned int ) QuantumRange ; if ( PalHeader . MaxBlue == 0 ) PalHeader . MaxBlue = ( unsigned int ) QuantumRange ; for ( i = 0 ; i <= ( int ) PalHeader . MaxIndex ; i ++ ) { j = ( ssize_t ) TellBlob ( palette ) ; if ( ( j % 512 ) > 512 - 6 ) { j = ( ( j / 512 ) + 1 ) * 512 ; offset = SeekBlob ( palette , j , SEEK_SET ) ; if ( offset < 0 ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; } image -> colormap [ i ] . red = ( Quantum ) ReadBlobLSBShort ( palette ) ; if ( QuantumRange != ( Quantum ) PalHeader . MaxRed ) { image -> colormap [ i ] . red = ClampToQuantum ( ( ( double ) image -> colormap [ i ] . red * QuantumRange + ( PalHeader . MaxRed >> 1 ) ) / PalHeader . MaxRed ) ; } image -> colormap [ i ] . green = ( Quantum ) ReadBlobLSBShort ( palette ) ; if ( QuantumRange != ( Quantum ) PalHeader . MaxGreen ) { image -> colormap [ i ] . green = ClampToQuantum ( ( ( double ) image -> colormap [ i ] . green * QuantumRange + ( PalHeader . MaxGreen >> 1 ) ) / PalHeader . MaxGreen ) ; } image -> colormap [ i ] . blue = ( Quantum ) ReadBlobLSBShort ( palette ) ; if ( QuantumRange != ( Quantum ) PalHeader . MaxBlue ) { image -> colormap [ i ] . blue = ClampToQuantum ( ( ( double ) image -> colormap [ i ] . blue * QuantumRange + ( PalHeader . MaxBlue >> 1 ) ) / PalHeader . MaxBlue ) ; } } if ( EOFBlob ( image ) ) ThrowCUTReaderException ( CorruptImageError , "UnexpectedEndOfFile" ) ; } NoPalette : if ( palette == NULL ) { image -> colors = 256 ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) { NoMemory : ThrowCUTReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; } for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( unsigned char ) i ) ; } } BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ldblk , sizeof ( * BImgBuff ) ) ; if ( BImgBuff == NULL ) goto NoMemory ; <S2SV_StartBug> offset = SeekBlob ( image , 6 , SEEK_SET ) ; <S2SV_EndBug> if ( offset < 0 ) { if ( palette != NULL ) palette = DestroyImage ( palette ) ; if ( clone_info != NULL ) clone_info = DestroyImageInfo ( clone_info ) ; BImgBuff = ( unsigned char * ) RelinquishMagickMemory ( BImgBuff ) ; ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; } for ( i = 0 ; i < ( int ) Header . Height ; i ++ ) { EncodedByte = ReadBlobLSBShort ( image ) ; ptrB = BImgBuff ; j = ldblk ; RunCount = ( unsigned char ) ReadBlobByte ( image ) ; RunCountMasked = RunCount & 0x7F ; while ( ( int ) RunCountMasked != 0 ) { if ( ( ssize_t ) RunCountMasked > j ) { RunCountMasked = ( unsigned char ) j ; if ( j == 0 ) { break ; } } if ( ( int ) RunCount > 0x80 ) { RunValue = ( unsigned char ) ReadBlobByte ( image ) ; ( void ) memset ( ptrB , ( int ) RunValue , ( size_t ) RunCountMasked ) ; } else { ( void ) ReadBlob ( image , ( size_t ) RunCountMasked , ptrB ) ; } ptrB += ( int ) RunCountMasked ; j -= ( int ) RunCountMasked ; if ( EOFBlob ( image ) != MagickFalse ) goto Finish ; RunCount = ( unsigned char ) ReadBlobByte ( image ) ; RunCountMasked = RunCount & 0x7F ; } InsertRow ( image , depth , BImgBuff , i , exception ) ; } ( void ) SyncImage ( image , exception ) ; if ( palette == NULL ) { if ( ( image -> storage_class == PseudoClass ) && ( SetImageGray ( image , exception ) != MagickFalse ) ) { if ( GetCutColors ( image , exception ) == 2 ) { for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { register Quantum sample ; sample = ScaleCharToQuantum ( ( unsigned char ) i ) ; if ( image -> colormap [ i ] . red != sample ) goto Finish ; if ( image -> colormap [ i ] . green != sample ) goto Finish ; if ( image -> colormap [ i ] . blue != sample ) goto Finish ; } image -> colormap [ 1 ] . red = image -> colormap [ 1 ] . green = image -> colormap [ 1 ] . blue = QuantumRange ; for ( i = 0 ; i < ( ssize_t ) image -> rows ; i ++ ) { q = QueueAuthenticPixels ( image , 0 , i , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( j = 0 ; j < ( ssize_t ) image -> columns ; j ++ ) { if ( GetPixelRed ( image , q ) == ScaleCharToQuantum ( 1 ) ) { SetPixelRed ( image , QuantumRange , q ) ; SetPixelGreen ( image , QuantumRange , q ) ; SetPixelBlue ( image , QuantumRange , q ) ; } q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) goto Finish ; } } } } Finish : if ( BImgBuff != NULL ) BImgBuff = ( unsigned char * ) RelinquishMagickMemory ( BImgBuff ) ; if ( palette != NULL ) palette = DestroyImage ( palette ) ; if ( clone_info != NULL ) clone_info = DestroyImageInfo ( clone_info ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowFileException ( exception , CorruptImageError , "UnexpectedEndOfFile" , image -> filename ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
CWE-835 static Image * ReadBMPImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { BMPInfo bmp_info ; Image * image ; MagickBooleanType status ; MagickOffsetType offset , start_position ; MemoryInfo * pixel_info ; Quantum index ; register Quantum * q ; register ssize_t i , x ; register unsigned char * p ; size_t bit , bytes_per_line , length ; ssize_t count , y ; unsigned char magick [ 12 ] , * pixels ; unsigned int blue , green , offset_bits , red ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) memset ( & bmp_info , 0 , sizeof ( bmp_info ) ) ; bmp_info . ba_offset = 0 ; start_position = 0 ; offset_bits = 0 ; count = ReadBlob ( image , 2 , magick ) ; if ( count != 2 ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; do { PixelInfo quantum_bits ; PixelPacket shift ; start_position = TellBlob ( image ) - 2 ; bmp_info . ba_offset = 0 ; while ( LocaleNCompare ( ( char * ) magick , "BA" , 2 ) == 0 ) { bmp_info . file_size = ReadBlobLSBLong ( image ) ; bmp_info . ba_offset = ReadBlobLSBLong ( image ) ; bmp_info . offset_bits = ReadBlobLSBLong ( image ) ; count = ReadBlob ( image , 2 , magick ) ; if ( count != 2 ) break ; } if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "<S2SV_blank><S2SV_blank>Magick:<S2SV_blank>%c%c" , magick [ 0 ] , magick [ 1 ] ) ; if ( ( count != 2 ) || ( ( LocaleNCompare ( ( char * ) magick , "BM" , 2 ) != 0 ) && ( LocaleNCompare ( ( char * ) magick , "CI" , 2 ) != 0 ) ) ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; bmp_info . file_size = ReadBlobLSBLong ( image ) ; ( void ) ReadBlobLSBLong ( image ) ; bmp_info . offset_bits = ReadBlobLSBLong ( image ) ; bmp_info . size = ReadBlobLSBLong ( image ) ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "<S2SV_blank><S2SV_blank>BMP<S2SV_blank>size:<S2SV_blank>%u" , bmp_info . size ) ; if ( bmp_info . size == 12 ) { ( void ) CopyMagickString ( image -> magick , "BMP2" , MagickPathExtent ) ; bmp_info . width = ( ssize_t ) ( ( short ) ReadBlobLSBShort ( image ) ) ; bmp_info . height = ( ssize_t ) ( ( short ) ReadBlobLSBShort ( image ) ) ; bmp_info . planes = ReadBlobLSBShort ( image ) ; bmp_info . bits_per_pixel = ReadBlobLSBShort ( image ) ; bmp_info . x_pixels = 0 ; bmp_info . y_pixels = 0 ; bmp_info . number_colors = 0 ; bmp_info . compression = BI_RGB ; bmp_info . image_size = 0 ; bmp_info . alpha_mask = 0 ; if ( image -> debug != MagickFalse ) { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "<S2SV_blank><S2SV_blank>Format:<S2SV_blank>OS/2<S2SV_blank>Bitmap" ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "<S2SV_blank><S2SV_blank>Geometry:<S2SV_blank>%.20gx%.20g" , ( double ) bmp_info . width , ( double ) bmp_info . height ) ; } } else { if ( bmp_info . size < 40 ) ThrowReaderException ( CorruptImageError , "NonOS2HeaderSizeError" ) ; bmp_info . width = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; bmp_info . height = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; bmp_info . planes = ReadBlobLSBShort ( image ) ; bmp_info . bits_per_pixel = ReadBlobLSBShort ( image ) ; bmp_info . compression = ReadBlobLSBLong ( image ) ; bmp_info . image_size = ReadBlobLSBLong ( image ) ; bmp_info . x_pixels = ReadBlobLSBLong ( image ) ; bmp_info . y_pixels = ReadBlobLSBLong ( image ) ; bmp_info . number_colors = ReadBlobLSBLong ( image ) ; <S2SV_StartBug> if ( bmp_info . number_colors > GetBlobSize ( image ) ) <S2SV_EndBug> ThrowReaderException ( CorruptImageError , "InsufficientImageDataInFile" ) ; bmp_info . colors_important = ReadBlobLSBLong ( image ) ; if ( image -> debug != MagickFalse ) { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "<S2SV_blank><S2SV_blank>Format:<S2SV_blank>MS<S2SV_blank>Windows<S2SV_blank>bitmap" ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "<S2SV_blank><S2SV_blank>Geometry:<S2SV_blank>%.20gx%.20g" , ( double ) bmp_info . width , ( double ) bmp_info . height ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "<S2SV_blank><S2SV_blank>Bits<S2SV_blank>per<S2SV_blank>pixel:<S2SV_blank>%.20g" , ( double ) bmp_info . bits_per_pixel ) ; switch ( bmp_info . compression ) { case BI_RGB : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_RGB" ) ; break ; } case BI_RLE4 : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_RLE4" ) ; break ; } case BI_RLE8 : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_RLE8" ) ; break ; } case BI_BITFIELDS : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_BITFIELDS" ) ; break ; } case BI_PNG : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_PNG" ) ; break ; } case BI_JPEG : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_JPEG" ) ; break ; } default : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>UNKNOWN<S2SV_blank>(%u)" , bmp_info . compression ) ; } } ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "<S2SV_blank><S2SV_blank>Number<S2SV_blank>of<S2SV_blank>colors:<S2SV_blank>%u" , bmp_info . number_colors ) ; } bmp_info . red_mask = ReadBlobLSBLong ( image ) ; bmp_info . green_mask = ReadBlobLSBLong ( image ) ; bmp_info . blue_mask = ReadBlobLSBLong ( image ) ; if ( bmp_info . size > 40 ) { double gamma ; bmp_info . alpha_mask = ReadBlobLSBLong ( image ) ; bmp_info . colorspace = ReadBlobLSBSignedLong ( image ) ; # define BMP_DENOM ( ( double ) 0x40000000 ) bmp_info . red_primary . x = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . red_primary . y = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . red_primary . z = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . green_primary . x = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . green_primary . y = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . green_primary . z = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . blue_primary . x = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . blue_primary . y = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . blue_primary . z = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; gamma = bmp_info . red_primary . x + bmp_info . red_primary . y + bmp_info . red_primary . z ; gamma = PerceptibleReciprocal ( gamma ) ; bmp_info . red_primary . x *= gamma ; bmp_info . red_primary . y *= gamma ; image -> chromaticity . red_primary . x = bmp_info . red_primary . x ; image -> chromaticity . red_primary . y = bmp_info . red_primary . y ; gamma = bmp_info . green_primary . x + bmp_info . green_primary . y + bmp_info . green_primary . z ; gamma = PerceptibleReciprocal ( gamma ) ; bmp_info . green_primary . x *= gamma ; bmp_info . green_primary . y *= gamma ; image -> chromaticity . green_primary . x = bmp_info . green_primary . x ; image -> chromaticity . green_primary . y = bmp_info . green_primary . y ; gamma = bmp_info . blue_primary . x + bmp_info . blue_primary . y + bmp_info . blue_primary . z ; gamma = PerceptibleReciprocal ( gamma ) ; bmp_info . blue_primary . x *= gamma ; bmp_info . blue_primary . y *= gamma ; image -> chromaticity . blue_primary . x = bmp_info . blue_primary . x ; image -> chromaticity . blue_primary . y = bmp_info . blue_primary . y ; bmp_info . gamma_scale . x = ( double ) ReadBlobLSBLong ( image ) / 0x10000 ; bmp_info . gamma_scale . y = ( double ) ReadBlobLSBLong ( image ) / 0x10000 ; bmp_info . gamma_scale . z = ( double ) ReadBlobLSBLong ( image ) / 0x10000 ; image -> gamma = ( bmp_info . gamma_scale . x + bmp_info . gamma_scale . y + bmp_info . gamma_scale . z ) / 3.0 ; } else ( void ) CopyMagickString ( image -> magick , "BMP3" , MagickPathExtent ) ; if ( bmp_info . size > 108 ) { size_t intent ; intent = ReadBlobLSBLong ( image ) ; switch ( ( int ) intent ) { case LCS_GM_BUSINESS : { image -> rendering_intent = SaturationIntent ; break ; } case LCS_GM_GRAPHICS : { image -> rendering_intent = RelativeIntent ; break ; } case LCS_GM_IMAGES : { image -> rendering_intent = PerceptualIntent ; break ; } case LCS_GM_ABS_COLORIMETRIC : { image -> rendering_intent = AbsoluteIntent ; break ; } } ( void ) ReadBlobLSBLong ( image ) ; ( void ) ReadBlobLSBLong ( image ) ; ( void ) ReadBlobLSBLong ( image ) ; } } if ( ( MagickSizeType ) bmp_info . file_size > GetBlobSize ( image ) ) ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , CorruptImageError , "LengthAndFilesizeDoNotMatch" , "`%s\'" , image -> filename ) ; else if ( ( MagickSizeType ) bmp_info . file_size < GetBlobSize ( image ) ) ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , CorruptImageWarning , "LengthAndFilesizeDoNotMatch" , "`%s\'" , image -> filename ) ; if ( bmp_info . width <= 0 ) ThrowReaderException ( CorruptImageError , "NegativeOrZeroImageSize" ) ; if ( bmp_info . height == 0 ) ThrowReaderException ( CorruptImageError , "NegativeOrZeroImageSize" ) ; if ( bmp_info . planes != 1 ) ThrowReaderException ( CorruptImageError , "StaticPlanesValueNotEqualToOne" ) ; if ( ( bmp_info . bits_per_pixel != 1 ) && ( bmp_info . bits_per_pixel != 4 ) && ( bmp_info . bits_per_pixel != 8 ) && ( bmp_info . bits_per_pixel != 16 ) && ( bmp_info . bits_per_pixel != 24 ) && ( bmp_info . bits_per_pixel != 32 ) ) ThrowReaderException ( CorruptImageError , "UnrecognizedBitsPerPixel" ) ; if ( bmp_info . bits_per_pixel < 16 && bmp_info . number_colors > ( 1U << bmp_info . bits_per_pixel ) ) ThrowReaderException ( CorruptImageError , "UnrecognizedNumberOfColors" ) ; if ( ( bmp_info . compression == 1 ) && ( bmp_info . bits_per_pixel != 8 ) ) ThrowReaderException ( CorruptImageError , "UnrecognizedBitsPerPixel" ) ; if ( ( bmp_info . compression == 2 ) && ( bmp_info . bits_per_pixel != 4 ) ) ThrowReaderException ( CorruptImageError , "UnrecognizedBitsPerPixel" ) ; if ( ( bmp_info . compression == 3 ) && ( bmp_info . bits_per_pixel < 16 ) ) ThrowReaderException ( CorruptImageError , "UnrecognizedBitsPerPixel" ) ; switch ( bmp_info . compression ) { case BI_RGB : image -> compression = NoCompression ; break ; case BI_RLE8 : case BI_RLE4 : image -> compression = RLECompression ; break ; case BI_BITFIELDS : break ; case BI_JPEG : ThrowReaderException ( CoderError , "JPEGCompressNotSupported" ) ; case BI_PNG : ThrowReaderException ( CoderError , "PNGCompressNotSupported" ) ; default : ThrowReaderException ( CorruptImageError , "UnrecognizedImageCompression" ) ; } image -> columns = ( size_t ) MagickAbsoluteValue ( bmp_info . width ) ; image -> rows = ( size_t ) MagickAbsoluteValue ( bmp_info . height ) ; image -> depth = bmp_info . bits_per_pixel <= 8 ? bmp_info . bits_per_pixel : 8 ; image -> alpha_trait = ( ( bmp_info . alpha_mask != 0 ) && ( bmp_info . compression == BI_BITFIELDS ) ) ? BlendPixelTrait : UndefinedPixelTrait ; if ( bmp_info . bits_per_pixel < 16 ) { size_t one ; image -> storage_class = PseudoClass ; image -> colors = bmp_info . number_colors ; one = 1 ; if ( image -> colors == 0 ) image -> colors = one << bmp_info . bits_per_pixel ; } image -> resolution . x = ( double ) bmp_info . x_pixels / 100.0 ; image -> resolution . y = ( double ) bmp_info . y_pixels / 100.0 ; image -> units = PixelsPerCentimeterResolution ; if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; if ( image -> storage_class == PseudoClass ) { unsigned char * bmp_colormap ; size_t packet_size ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "<S2SV_blank><S2SV_blank>Reading<S2SV_blank>colormap<S2SV_blank>of<S2SV_blank>%.20g<S2SV_blank>colors" , ( double ) image -> colors ) ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; bmp_colormap = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) image -> colors , 4 * sizeof ( * bmp_colormap ) ) ; if ( bmp_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; if ( ( bmp_info . size == 12 ) || ( bmp_info . size == 64 ) ) packet_size = 3 ; else packet_size = 4 ; offset = SeekBlob ( image , start_position + 14 + bmp_info . size , SEEK_SET ) ; if ( offset < 0 ) { bmp_colormap = ( unsigned char * ) RelinquishMagickMemory ( bmp_colormap ) ; ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; } count = ReadBlob ( image , packet_size * image -> colors , bmp_colormap ) ; if ( count != ( ssize_t ) ( packet_size * image -> colors ) ) { bmp_colormap = ( unsigned char * ) RelinquishMagickMemory ( bmp_colormap ) ; ThrowReaderException ( CorruptImageError , "InsufficientImageDataInFile" ) ; } p = bmp_colormap ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( * p ++ ) ; image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( * p ++ ) ; image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( * p ++ ) ; if ( packet_size == 4 ) p ++ ; } bmp_colormap = ( unsigned char * ) RelinquishMagickMemory ( bmp_colormap ) ; } if ( bmp_info . offset_bits == offset_bits ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; offset_bits = bmp_info . offset_bits ; offset = SeekBlob ( image , start_position + bmp_info . offset_bits , SEEK_SET ) ; if ( offset < 0 ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; if ( bmp_info . compression == BI_RLE4 ) bmp_info . bits_per_pixel <<= 1 ; bytes_per_line = 4 * ( ( image -> columns * bmp_info . bits_per_pixel + 31 ) / 32 ) ; length = ( size_t ) bytes_per_line * image -> rows ; if ( ( bmp_info . compression == BI_RGB ) || ( bmp_info . compression == BI_BITFIELDS ) ) { if ( ( MagickSizeType ) length > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , "InsufficientImageDataInFile" ) ; pixel_info = AcquireVirtualMemory ( image -> rows , MagickMax ( bytes_per_line , image -> columns + 256UL ) * sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "<S2SV_blank><S2SV_blank>Reading<S2SV_blank>pixels<S2SV_blank>(%.20g<S2SV_blank>bytes)" , ( double ) length ) ; count = ReadBlob ( image , length , pixels ) ; if ( count != ( ssize_t ) length ) { pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , "InsufficientImageDataInFile" ) ; } } else { pixel_info = AcquireVirtualMemory ( image -> rows , MagickMax ( bytes_per_line , image -> columns + 256UL ) * sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; status = DecodeImage ( image , bmp_info . compression , pixels , image -> columns * image -> rows ) ; if ( status == MagickFalse ) { pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , "UnableToRunlengthDecodeImage" ) ; } } if ( bmp_info . compression == BI_RGB ) { if ( ( image -> alpha_trait == UndefinedPixelTrait ) && ( bmp_info . size == 40 ) && ( bmp_info . bits_per_pixel == 32 ) ) { bytes_per_line = 4 * ( image -> columns ) ; for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( * ( p + 3 ) != 0 ) { image -> alpha_trait = BlendPixelTrait ; y = - 1 ; break ; } p += 4 ; } } } bmp_info . alpha_mask = image -> alpha_trait != UndefinedPixelTrait ? 0xff000000U : 0U ; bmp_info . red_mask = 0x00ff0000U ; bmp_info . green_mask = 0x0000ff00U ; bmp_info . blue_mask = 0x000000ffU ; if ( bmp_info . bits_per_pixel == 16 ) { bmp_info . red_mask = 0x00007c00U ; bmp_info . green_mask = 0x000003e0U ; bmp_info . blue_mask = 0x0000001fU ; } } ( void ) memset ( & shift , 0 , sizeof ( shift ) ) ; ( void ) memset ( & quantum_bits , 0 , sizeof ( quantum_bits ) ) ; if ( ( bmp_info . bits_per_pixel == 16 ) || ( bmp_info . bits_per_pixel == 32 ) ) { register unsigned int sample ; if ( bmp_info . red_mask != 0 ) while ( ( ( bmp_info . red_mask << shift . red ) & 0x80000000UL ) == 0 ) { shift . red ++ ; if ( shift . red >= 32U ) break ; } if ( bmp_info . green_mask != 0 ) while ( ( ( bmp_info . green_mask << shift . green ) & 0x80000000UL ) == 0 ) { shift . green ++ ; if ( shift . green >= 32U ) break ; } if ( bmp_info . blue_mask != 0 ) while ( ( ( bmp_info . blue_mask << shift . blue ) & 0x80000000UL ) == 0 ) { shift . blue ++ ; if ( shift . blue >= 32U ) break ; } if ( bmp_info . alpha_mask != 0 ) while ( ( ( bmp_info . alpha_mask << shift . alpha ) & 0x80000000UL ) == 0 ) { shift . alpha ++ ; if ( shift . alpha >= 32U ) break ; } sample = shift . red ; while ( ( ( bmp_info . red_mask << sample ) & 0x80000000UL ) != 0 ) { sample ++ ; if ( sample >= 32U ) break ; } quantum_bits . red = ( MagickRealType ) ( sample - shift . red ) ; sample = shift . green ; while ( ( ( bmp_info . green_mask << sample ) & 0x80000000UL ) != 0 ) { sample ++ ; if ( sample >= 32U ) break ; } quantum_bits . green = ( MagickRealType ) ( sample - shift . green ) ; sample = shift . blue ; while ( ( ( bmp_info . blue_mask << sample ) & 0x80000000UL ) != 0 ) { sample ++ ; if ( sample >= 32U ) break ; } quantum_bits . blue = ( MagickRealType ) ( sample - shift . blue ) ; sample = shift . alpha ; while ( ( ( bmp_info . alpha_mask << sample ) & 0x80000000UL ) != 0 ) { sample ++ ; if ( sample >= 32U ) break ; } quantum_bits . alpha = ( MagickRealType ) ( sample - shift . alpha ) ; } switch ( bmp_info . bits_per_pixel ) { case 1 : { for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) { for ( bit = 0 ; bit < 8 ; bit ++ ) { index = ( Quantum ) ( ( ( * p ) & ( 0x80 >> bit ) ) != 0 ? 0x01 : 0x00 ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( image -> columns % 8 ) != 0 ) { for ( bit = 0 ; bit < ( image -> columns % 8 ) ; bit ++ ) { index = ( Quantum ) ( ( ( * p ) & ( 0x80 >> bit ) ) != 0 ? 0x01 : 0x00 ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image , exception ) ; break ; } case 4 : { for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 1 ) ; x += 2 ) { ValidateColormapValue ( image , ( ssize_t ) ( ( * p >> 4 ) & 0x0f ) , & index , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; ValidateColormapValue ( image , ( ssize_t ) ( * p & 0x0f ) , & index , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; p ++ ; } if ( ( image -> columns % 2 ) != 0 ) { ValidateColormapValue ( image , ( ssize_t ) ( ( * p >> 4 ) & 0xf ) , & index , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; p ++ ; x ++ ; } if ( x < ( ssize_t ) image -> columns ) break ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image , exception ) ; break ; } case 8 : { if ( ( bmp_info . compression == BI_RLE8 ) || ( bmp_info . compression == BI_RLE4 ) ) bytes_per_line = image -> columns ; for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = ( ssize_t ) image -> columns ; x != 0 ; -- x ) { ValidateColormapValue ( image , ( ssize_t ) * p ++ , & index , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; offset = ( MagickOffsetType ) ( image -> rows - y - 1 ) ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image , exception ) ; break ; } case 16 : { unsigned int alpha , pixel ; if ( ( bmp_info . compression != BI_RGB ) && ( bmp_info . compression != BI_BITFIELDS ) ) { pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , "UnrecognizedImageCompression" ) ; } bytes_per_line = 2 * ( image -> columns + image -> columns % 2 ) ; image -> storage_class = DirectClass ; for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { pixel = ( unsigned int ) ( * p ++ ) ; pixel |= ( * p ++ ) << 8 ; red = ( ( pixel & bmp_info . red_mask ) << shift . red ) >> 16 ; if ( quantum_bits . red == 5 ) red |= ( ( red & 0xe000 ) >> 5 ) ; if ( quantum_bits . red <= 8 ) red |= ( ( red & 0xff00 ) >> 8 ) ; green = ( ( pixel & bmp_info . green_mask ) << shift . green ) >> 16 ; if ( quantum_bits . green == 5 ) green |= ( ( green & 0xe000 ) >> 5 ) ; if ( quantum_bits . green == 6 ) green |= ( ( green & 0xc000 ) >> 6 ) ; if ( quantum_bits . green <= 8 ) green |= ( ( green & 0xff00 ) >> 8 ) ; blue = ( ( pixel & bmp_info . blue_mask ) << shift . blue ) >> 16 ; if ( quantum_bits . blue == 5 ) blue |= ( ( blue & 0xe000 ) >> 5 ) ; if ( quantum_bits . blue <= 8 ) blue |= ( ( blue & 0xff00 ) >> 8 ) ; SetPixelRed ( image , ScaleShortToQuantum ( ( unsigned short ) red ) , q ) ; SetPixelGreen ( image , ScaleShortToQuantum ( ( unsigned short ) green ) , q ) ; SetPixelBlue ( image , ScaleShortToQuantum ( ( unsigned short ) blue ) , q ) ; SetPixelAlpha ( image , OpaqueAlpha , q ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) { alpha = ( ( pixel & bmp_info . alpha_mask ) << shift . alpha ) >> 16 ; if ( quantum_bits . alpha <= 8 ) alpha |= ( ( alpha & 0xff00 ) >> 8 ) ; SetPixelAlpha ( image , ScaleShortToQuantum ( ( unsigned short ) alpha ) , q ) ; } q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; offset = ( MagickOffsetType ) ( image -> rows - y - 1 ) ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } break ; } case 24 : { bytes_per_line = 4 * ( ( image -> columns * 24 + 31 ) / 32 ) ; for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelAlpha ( image , OpaqueAlpha , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; offset = ( MagickOffsetType ) ( image -> rows - y - 1 ) ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } break ; } case 32 : { if ( ( bmp_info . compression != BI_RGB ) && ( bmp_info . compression != BI_BITFIELDS ) ) { pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , "UnrecognizedImageCompression" ) ; } bytes_per_line = 4 * ( image -> columns ) ; for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { unsigned int alpha , pixel ; p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { pixel = ( unsigned int ) ( * p ++ ) ; pixel |= ( ( unsigned int ) * p ++ << 8 ) ; pixel |= ( ( unsigned int ) * p ++ << 16 ) ; pixel |= ( ( unsigned int ) * p ++ << 24 ) ; red = ( ( pixel & bmp_info . red_mask ) << shift . red ) >> 16 ; if ( quantum_bits . red == 8 ) red |= ( red >> 8 ) ; green = ( ( pixel & bmp_info . green_mask ) << shift . green ) >> 16 ; if ( quantum_bits . green == 8 ) green |= ( green >> 8 ) ; blue = ( ( pixel & bmp_info . blue_mask ) << shift . blue ) >> 16 ; if ( quantum_bits . blue == 8 ) blue |= ( blue >> 8 ) ; SetPixelRed ( image , ScaleShortToQuantum ( ( unsigned short ) red ) , q ) ; SetPixelGreen ( image , ScaleShortToQuantum ( ( unsigned short ) green ) , q ) ; SetPixelBlue ( image , ScaleShortToQuantum ( ( unsigned short ) blue ) , q ) ; SetPixelAlpha ( image , OpaqueAlpha , q ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) { alpha = ( ( pixel & bmp_info . alpha_mask ) << shift . alpha ) >> 16 ; if ( quantum_bits . alpha == 8 ) alpha |= ( alpha >> 8 ) ; SetPixelAlpha ( image , ScaleShortToQuantum ( ( unsigned short ) alpha ) , q ) ; } q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; offset = ( MagickOffsetType ) ( image -> rows - y - 1 ) ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } break ; } default : { pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; } } pixel_info = RelinquishVirtualMemory ( pixel_info ) ; if ( y > 0 ) break ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , "UnexpectedEndOfFile" , image -> filename ) ; break ; } if ( bmp_info . height < 0 ) { Image * flipped_image ; flipped_image = FlipImage ( image , exception ) ; if ( flipped_image != ( Image * ) NULL ) { DuplicateBlob ( flipped_image , image ) ; ReplaceImageInList ( & image , flipped_image ) ; image = flipped_image ; } } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; <S2SV_StartBug> * magick = '\\0' ; <S2SV_EndBug> <S2SV_StartBug> if ( bmp_info . ba_offset != 0 ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> offset = SeekBlob ( image , ( MagickOffsetType ) bmp_info . ba_offset , SEEK_SET ) ; <S2SV_StartBug> if ( offset < 0 ) <S2SV_EndBug> ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; <S2SV_StartBug> } <S2SV_EndBug> count = ReadBlob ( image , 2 , magick ) ; if ( ( count == 2 ) && ( IsBMP ( magick , 2 ) != MagickFalse ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { status = MagickFalse ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( IsBMP ( magick , 2 ) != MagickFalse ) ; ( void ) CloseBlob ( image ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; return ( GetFirstImageInList ( image ) ) ; }
CWE-400 static Image * ReadCINImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define MonoColorType 1 # define RGBColorType 3 char property [ MagickPathExtent ] ; CINInfo cin ; const unsigned char * pixels ; Image * image ; MagickBooleanType status ; MagickOffsetType offset ; QuantumInfo * quantum_info ; QuantumType quantum_type ; register ssize_t i ; register Quantum * q ; size_t length ; ssize_t count , y ; unsigned char magick [ 4 ] ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } offset = 0 ; count = ReadBlob ( image , 4 , magick ) ; offset += count ; if ( ( count != 4 ) || ( ( LocaleNCompare ( ( char * ) magick , "\\200\\052\\137\\327" , 4 ) != 0 ) ) ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; memset ( & cin , 0 , sizeof ( cin ) ) ; image -> endian = ( magick [ 0 ] == 0x80 ) && ( magick [ 1 ] == 0x2a ) && ( magick [ 2 ] == 0x5f ) && ( magick [ 3 ] == 0xd7 ) ? MSBEndian : LSBEndian ; cin . file . image_offset = ReadBlobLong ( image ) ; offset += 4 ; cin . file . generic_length = ReadBlobLong ( image ) ; offset += 4 ; cin . file . industry_length = ReadBlobLong ( image ) ; offset += 4 ; cin . file . user_length = ReadBlobLong ( image ) ; offset += 4 ; cin . file . file_size = ReadBlobLong ( image ) ; offset += 4 ; offset += ReadBlob ( image , sizeof ( cin . file . version ) , ( unsigned char * ) cin . file . version ) ; ( void ) CopyMagickString ( property , cin . file . version , sizeof ( cin . file . version ) ) ; ( void ) SetImageProperty ( image , "dpx:file.version" , property , exception ) ; offset += ReadBlob ( image , sizeof ( cin . file . filename ) , ( unsigned char * ) cin . file . filename ) ; ( void ) CopyMagickString ( property , cin . file . filename , sizeof ( cin . file . filename ) ) ; ( void ) SetImageProperty ( image , "dpx:file.filename" , property , exception ) ; offset += ReadBlob ( image , sizeof ( cin . file . create_date ) , ( unsigned char * ) cin . file . create_date ) ; ( void ) CopyMagickString ( property , cin . file . create_date , sizeof ( cin . file . create_date ) ) ; ( void ) SetImageProperty ( image , "dpx:file.create_date" , property , exception ) ; offset += ReadBlob ( image , sizeof ( cin . file . create_time ) , ( unsigned char * ) cin . file . create_time ) ; ( void ) CopyMagickString ( property , cin . file . create_time , sizeof ( cin . file . create_time ) ) ; ( void ) SetImageProperty ( image , "dpx:file.create_time" , property , exception ) ; offset += ReadBlob ( image , sizeof ( cin . file . reserve ) , ( unsigned char * ) cin . file . reserve ) ; cin . image . orientation = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; if ( cin . image . orientation != ( unsigned char ) ( ~ 0 ) ) ( void ) FormatImageProperty ( image , "dpx:image.orientation" , "%d" , cin . image . orientation ) ; switch ( cin . image . orientation ) { default : case 0 : image -> orientation = TopLeftOrientation ; break ; case 1 : image -> orientation = TopRightOrientation ; break ; case 2 : image -> orientation = BottomLeftOrientation ; break ; case 3 : image -> orientation = BottomRightOrientation ; break ; case 4 : image -> orientation = LeftTopOrientation ; break ; case 5 : image -> orientation = RightTopOrientation ; break ; case 6 : image -> orientation = LeftBottomOrientation ; break ; case 7 : image -> orientation = RightBottomOrientation ; break ; } cin . image . number_channels = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; offset += ReadBlob ( image , sizeof ( cin . image . reserve1 ) , ( unsigned char * ) cin . image . reserve1 ) ; for ( i = 0 ; i < 8 ; i ++ ) { cin . image . channel [ i ] . designator [ 0 ] = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; cin . image . channel [ i ] . designator [ 1 ] = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; cin . image . channel [ i ] . bits_per_pixel = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; cin . image . channel [ i ] . reserve = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; cin . image . channel [ i ] . pixels_per_line = ReadBlobLong ( image ) ; offset += 4 ; cin . image . channel [ i ] . lines_per_image = ReadBlobLong ( image ) ; offset += 4 ; cin . image . channel [ i ] . min_data = ReadBlobFloat ( image ) ; offset += 4 ; cin . image . channel [ i ] . min_quantity = ReadBlobFloat ( image ) ; offset += 4 ; cin . image . channel [ i ] . max_data = ReadBlobFloat ( image ) ; offset += 4 ; cin . image . channel [ i ] . max_quantity = ReadBlobFloat ( image ) ; offset += 4 ; } cin . image . white_point [ 0 ] = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . image . white_point [ 0 ] ) != MagickFalse ) image -> chromaticity . white_point . x = cin . image . white_point [ 0 ] ; cin . image . white_point [ 1 ] = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . image . white_point [ 1 ] ) != MagickFalse ) image -> chromaticity . white_point . y = cin . image . white_point [ 1 ] ; cin . image . red_primary_chromaticity [ 0 ] = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . image . red_primary_chromaticity [ 0 ] ) != MagickFalse ) image -> chromaticity . red_primary . x = cin . image . red_primary_chromaticity [ 0 ] ; cin . image . red_primary_chromaticity [ 1 ] = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . image . red_primary_chromaticity [ 1 ] ) != MagickFalse ) image -> chromaticity . red_primary . y = cin . image . red_primary_chromaticity [ 1 ] ; cin . image . green_primary_chromaticity [ 0 ] = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . image . green_primary_chromaticity [ 0 ] ) != MagickFalse ) image -> chromaticity . red_primary . x = cin . image . green_primary_chromaticity [ 0 ] ; cin . image . green_primary_chromaticity [ 1 ] = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . image . green_primary_chromaticity [ 1 ] ) != MagickFalse ) image -> chromaticity . green_primary . y = cin . image . green_primary_chromaticity [ 1 ] ; cin . image . blue_primary_chromaticity [ 0 ] = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . image . blue_primary_chromaticity [ 0 ] ) != MagickFalse ) image -> chromaticity . blue_primary . x = cin . image . blue_primary_chromaticity [ 0 ] ; cin . image . blue_primary_chromaticity [ 1 ] = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . image . blue_primary_chromaticity [ 1 ] ) != MagickFalse ) image -> chromaticity . blue_primary . y = cin . image . blue_primary_chromaticity [ 1 ] ; offset += ReadBlob ( image , sizeof ( cin . image . label ) , ( unsigned char * ) cin . image . label ) ; ( void ) CopyMagickString ( property , cin . image . label , sizeof ( cin . image . label ) ) ; ( void ) SetImageProperty ( image , "dpx:image.label" , property , exception ) ; offset += ReadBlob ( image , sizeof ( cin . image . reserve ) , ( unsigned char * ) cin . image . reserve ) ; cin . data_format . interleave = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; cin . data_format . packing = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; cin . data_format . sign = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; cin . data_format . sense = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; cin . data_format . line_pad = ReadBlobLong ( image ) ; offset += 4 ; cin . data_format . channel_pad = ReadBlobLong ( image ) ; offset += 4 ; offset += ReadBlob ( image , sizeof ( cin . data_format . reserve ) , ( unsigned char * ) cin . data_format . reserve ) ; cin . origination . x_offset = ReadBlobSignedLong ( image ) ; offset += 4 ; if ( ( size_t ) cin . origination . x_offset != ~ 0UL ) ( void ) FormatImageProperty ( image , "dpx:origination.x_offset" , "%.20g" , ( double ) cin . origination . x_offset ) ; cin . origination . y_offset = ( ssize_t ) ReadBlobLong ( image ) ; offset += 4 ; if ( ( size_t ) cin . origination . y_offset != ~ 0UL ) ( void ) FormatImageProperty ( image , "dpx:origination.y_offset" , "%.20g" , ( double ) cin . origination . y_offset ) ; offset += ReadBlob ( image , sizeof ( cin . origination . filename ) , ( unsigned char * ) cin . origination . filename ) ; ( void ) CopyMagickString ( property , cin . origination . filename , sizeof ( cin . origination . filename ) ) ; ( void ) SetImageProperty ( image , "dpx:origination.filename" , property , exception ) ; offset += ReadBlob ( image , sizeof ( cin . origination . create_date ) , ( unsigned char * ) cin . origination . create_date ) ; ( void ) CopyMagickString ( property , cin . origination . create_date , sizeof ( cin . origination . create_date ) ) ; ( void ) SetImageProperty ( image , "dpx:origination.create_date" , property , exception ) ; offset += ReadBlob ( image , sizeof ( cin . origination . create_time ) , ( unsigned char * ) cin . origination . create_time ) ; ( void ) CopyMagickString ( property , cin . origination . create_time , sizeof ( cin . origination . create_time ) ) ; ( void ) SetImageProperty ( image , "dpx:origination.create_time" , property , exception ) ; offset += ReadBlob ( image , sizeof ( cin . origination . device ) , ( unsigned char * ) cin . origination . device ) ; ( void ) CopyMagickString ( property , cin . origination . device , sizeof ( cin . origination . device ) ) ; ( void ) SetImageProperty ( image , "dpx:origination.device" , property , exception ) ; offset += ReadBlob ( image , sizeof ( cin . origination . model ) , ( unsigned char * ) cin . origination . model ) ; ( void ) CopyMagickString ( property , cin . origination . model , sizeof ( cin . origination . model ) ) ; ( void ) SetImageProperty ( image , "dpx:origination.model" , property , exception ) ; ( void ) memset ( cin . origination . serial , 0 , sizeof ( cin . origination . serial ) ) ; offset += ReadBlob ( image , sizeof ( cin . origination . serial ) , ( unsigned char * ) cin . origination . serial ) ; ( void ) CopyMagickString ( property , cin . origination . serial , sizeof ( cin . origination . serial ) ) ; ( void ) SetImageProperty ( image , "dpx:origination.serial" , property , exception ) ; cin . origination . x_pitch = ReadBlobFloat ( image ) ; offset += 4 ; cin . origination . y_pitch = ReadBlobFloat ( image ) ; offset += 4 ; cin . origination . gamma = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . origination . gamma ) != MagickFalse ) image -> gamma = cin . origination . gamma ; offset += ReadBlob ( image , sizeof ( cin . origination . reserve ) , ( unsigned char * ) cin . origination . reserve ) ; if ( ( cin . file . image_offset > 2048 ) && ( cin . file . user_length != 0 ) ) { int c ; cin . film . id = ReadBlobByte ( image ) ; offset ++ ; c = cin . film . id ; if ( c != ~ 0 ) ( void ) FormatImageProperty ( image , "dpx:film.id" , "%d" , cin . film . id ) ; cin . film . type = ReadBlobByte ( image ) ; offset ++ ; c = cin . film . type ; if ( c != ~ 0 ) ( void ) FormatImageProperty ( image , "dpx:film.type" , "%d" , cin . film . type ) ; cin . film . offset = ReadBlobByte ( image ) ; offset ++ ; c = cin . film . offset ; if ( c != ~ 0 ) ( void ) FormatImageProperty ( image , "dpx:film.offset" , "%d" , cin . film . offset ) ; cin . film . reserve1 = ReadBlobByte ( image ) ; offset ++ ; cin . film . prefix = ReadBlobLong ( image ) ; offset += 4 ; if ( cin . film . prefix != ~ 0UL ) ( void ) FormatImageProperty ( image , "dpx:film.prefix" , "%.20g" , ( double ) cin . film . prefix ) ; cin . film . count = ReadBlobLong ( image ) ; offset += 4 ; offset += ReadBlob ( image , sizeof ( cin . film . format ) , ( unsigned char * ) cin . film . format ) ; ( void ) CopyMagickString ( property , cin . film . format , sizeof ( cin . film . format ) ) ; ( void ) SetImageProperty ( image , "dpx:film.format" , property , exception ) ; cin . film . frame_position = ReadBlobLong ( image ) ; offset += 4 ; if ( cin . film . frame_position != ~ 0UL ) ( void ) FormatImageProperty ( image , "dpx:film.frame_position" , "%.20g" , ( double ) cin . film . frame_position ) ; cin . film . frame_rate = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . film . frame_rate ) != MagickFalse ) ( void ) FormatImageProperty ( image , "dpx:film.frame_rate" , "%g" , cin . film . frame_rate ) ; offset += ReadBlob ( image , sizeof ( cin . film . frame_id ) , ( unsigned char * ) cin . film . frame_id ) ; ( void ) CopyMagickString ( property , cin . film . frame_id , sizeof ( cin . film . frame_id ) ) ; ( void ) SetImageProperty ( image , "dpx:film.frame_id" , property , exception ) ; offset += ReadBlob ( image , sizeof ( cin . film . slate_info ) , ( unsigned char * ) cin . film . slate_info ) ; ( void ) CopyMagickString ( property , cin . film . slate_info , sizeof ( cin . film . slate_info ) ) ; ( void ) SetImageProperty ( image , "dpx:film.slate_info" , property , exception ) ; offset += ReadBlob ( image , sizeof ( cin . film . reserve ) , ( unsigned char * ) cin . film . reserve ) ; } if ( ( cin . file . image_offset > 2048 ) && ( cin . file . user_length != 0 ) ) { StringInfo * profile ; if ( cin . file . user_length > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , "InsufficientImageDataInFile" ) ; profile = BlobToStringInfo ( ( const unsigned char * ) NULL , cin . file . user_length ) ; if ( profile == ( StringInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; offset += ReadBlob ( image , GetStringInfoLength ( profile ) , GetStringInfoDatum ( profile ) ) ; ( void ) SetImageProfile ( image , "dpx:user.data" , profile , exception ) ; profile = DestroyStringInfo ( profile ) ; } image -> depth = cin . image . channel [ 0 ] . bits_per_pixel ; image -> columns = cin . image . channel [ 0 ] . pixels_per_line ; image -> rows = cin . image . channel [ 0 ] . lines_per_image ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( image ) ; } <S2SV_StartBug> for ( ; offset < ( MagickOffsetType ) cin . file . image_offset ; offset ++ ) <S2SV_EndBug> { int c ; c = ReadBlobByte ( image ) ; if ( c == EOF ) break ; } if ( offset < ( MagickOffsetType ) cin . file . image_offset ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; ( void ) SetImageBackgroundColor ( image , exception ) ; quantum_info = AcquireQuantumInfo ( image_info , image ) ; if ( quantum_info == ( QuantumInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; quantum_info -> quantum = 32 ; quantum_info -> pack = MagickFalse ; quantum_type = RGBQuantum ; length = GetQuantumExtent ( image , quantum_info , quantum_type ) ; length = GetBytesPerRow ( image -> columns , 3 , image -> depth , MagickTrue ) ; if ( cin . image . number_channels == 1 ) { quantum_type = GrayQuantum ; length = GetBytesPerRow ( image -> columns , 1 , image -> depth , MagickTrue ) ; } for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; pixels = ( const unsigned char * ) ReadBlobStream ( image , length , GetQuantumPixels ( quantum_info ) , & count ) ; if ( ( size_t ) count != length ) break ; ( void ) ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , quantum_type , pixels , exception ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } SetQuantumImageType ( image , quantum_type ) ; quantum_info = DestroyQuantumInfo ( quantum_info ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowFileException ( exception , CorruptImageError , "UnexpectedEndOfFile" , image -> filename ) ; SetImageColorspace ( image , LogColorspace , exception ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
CWE-770 static Image * ReadBMPImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { BMPInfo bmp_info ; Image * image ; MagickBooleanType status ; MagickOffsetType offset , start_position ; MemoryInfo * pixel_info ; Quantum index ; register Quantum * q ; register ssize_t i , x ; register unsigned char * p ; size_t bit , bytes_per_line , length ; ssize_t count , y ; unsigned char magick [ 12 ] , * pixels ; unsigned int blue , green , offset_bits , red ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) memset ( & bmp_info , 0 , sizeof ( bmp_info ) ) ; bmp_info . ba_offset = 0 ; start_position = 0 ; offset_bits = 0 ; count = ReadBlob ( image , 2 , magick ) ; if ( count != 2 ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; do { PixelInfo quantum_bits ; PixelPacket shift ; if ( bmp_info . ba_offset == 0 ) start_position = TellBlob ( image ) - 2 ; bmp_info . ba_offset = 0 ; while ( LocaleNCompare ( ( char * ) magick , "BA" , 2 ) == 0 ) { bmp_info . file_size = ReadBlobLSBLong ( image ) ; bmp_info . ba_offset = ReadBlobLSBLong ( image ) ; bmp_info . offset_bits = ReadBlobLSBLong ( image ) ; count = ReadBlob ( image , 2 , magick ) ; if ( count != 2 ) break ; } if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "<S2SV_blank><S2SV_blank>Magick:<S2SV_blank>%c%c" , magick [ 0 ] , magick [ 1 ] ) ; if ( ( count != 2 ) || ( ( LocaleNCompare ( ( char * ) magick , "BM" , 2 ) != 0 ) && ( LocaleNCompare ( ( char * ) magick , "CI" , 2 ) != 0 ) ) ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; bmp_info . file_size = ReadBlobLSBLong ( image ) ; ( void ) ReadBlobLSBLong ( image ) ; bmp_info . offset_bits = ReadBlobLSBLong ( image ) ; bmp_info . size = ReadBlobLSBLong ( image ) ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "<S2SV_blank><S2SV_blank>BMP<S2SV_blank>size:<S2SV_blank>%u" , bmp_info . size ) ; if ( bmp_info . size == 12 ) { ( void ) CopyMagickString ( image -> magick , "BMP2" , MagickPathExtent ) ; bmp_info . width = ( ssize_t ) ( ( short ) ReadBlobLSBShort ( image ) ) ; bmp_info . height = ( ssize_t ) ( ( short ) ReadBlobLSBShort ( image ) ) ; bmp_info . planes = ReadBlobLSBShort ( image ) ; bmp_info . bits_per_pixel = ReadBlobLSBShort ( image ) ; bmp_info . x_pixels = 0 ; bmp_info . y_pixels = 0 ; bmp_info . number_colors = 0 ; bmp_info . compression = BI_RGB ; bmp_info . image_size = 0 ; bmp_info . alpha_mask = 0 ; if ( image -> debug != MagickFalse ) { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "<S2SV_blank><S2SV_blank>Format:<S2SV_blank>OS/2<S2SV_blank>Bitmap" ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "<S2SV_blank><S2SV_blank>Geometry:<S2SV_blank>%.20gx%.20g" , ( double ) bmp_info . width , ( double ) bmp_info . height ) ; } } else { if ( bmp_info . size < 40 ) ThrowReaderException ( CorruptImageError , "NonOS2HeaderSizeError" ) ; bmp_info . width = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; bmp_info . height = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; bmp_info . planes = ReadBlobLSBShort ( image ) ; bmp_info . bits_per_pixel = ReadBlobLSBShort ( image ) ; bmp_info . compression = ReadBlobLSBLong ( image ) ; bmp_info . image_size = ReadBlobLSBLong ( image ) ; bmp_info . x_pixels = ReadBlobLSBLong ( image ) ; bmp_info . y_pixels = ReadBlobLSBLong ( image ) ; <S2SV_StartBug> bmp_info . number_colors = ReadBlobLSBLong ( image ) ; <S2SV_EndBug> bmp_info . colors_important = ReadBlobLSBLong ( image ) ; if ( image -> debug != MagickFalse ) { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "<S2SV_blank><S2SV_blank>Format:<S2SV_blank>MS<S2SV_blank>Windows<S2SV_blank>bitmap" ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "<S2SV_blank><S2SV_blank>Geometry:<S2SV_blank>%.20gx%.20g" , ( double ) bmp_info . width , ( double ) bmp_info . height ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "<S2SV_blank><S2SV_blank>Bits<S2SV_blank>per<S2SV_blank>pixel:<S2SV_blank>%.20g" , ( double ) bmp_info . bits_per_pixel ) ; switch ( bmp_info . compression ) { case BI_RGB : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_RGB" ) ; break ; } case BI_RLE4 : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_RLE4" ) ; break ; } case BI_RLE8 : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_RLE8" ) ; break ; } case BI_BITFIELDS : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_BITFIELDS" ) ; break ; } case BI_PNG : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_PNG" ) ; break ; } case BI_JPEG : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_JPEG" ) ; break ; } default : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>UNKNOWN<S2SV_blank>(%u)" , bmp_info . compression ) ; } } ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "<S2SV_blank><S2SV_blank>Number<S2SV_blank>of<S2SV_blank>colors:<S2SV_blank>%u" , bmp_info . number_colors ) ; } bmp_info . red_mask = ReadBlobLSBLong ( image ) ; bmp_info . green_mask = ReadBlobLSBLong ( image ) ; bmp_info . blue_mask = ReadBlobLSBLong ( image ) ; if ( bmp_info . size > 40 ) { double gamma ; bmp_info . alpha_mask = ReadBlobLSBLong ( image ) ; bmp_info . colorspace = ReadBlobLSBSignedLong ( image ) ; # define BMP_DENOM ( ( double ) 0x40000000 ) bmp_info . red_primary . x = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . red_primary . y = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . red_primary . z = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . green_primary . x = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . green_primary . y = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . green_primary . z = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . blue_primary . x = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . blue_primary . y = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . blue_primary . z = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; gamma = bmp_info . red_primary . x + bmp_info . red_primary . y + bmp_info . red_primary . z ; gamma = PerceptibleReciprocal ( gamma ) ; bmp_info . red_primary . x *= gamma ; bmp_info . red_primary . y *= gamma ; image -> chromaticity . red_primary . x = bmp_info . red_primary . x ; image -> chromaticity . red_primary . y = bmp_info . red_primary . y ; gamma = bmp_info . green_primary . x + bmp_info . green_primary . y + bmp_info . green_primary . z ; gamma = PerceptibleReciprocal ( gamma ) ; bmp_info . green_primary . x *= gamma ; bmp_info . green_primary . y *= gamma ; image -> chromaticity . green_primary . x = bmp_info . green_primary . x ; image -> chromaticity . green_primary . y = bmp_info . green_primary . y ; gamma = bmp_info . blue_primary . x + bmp_info . blue_primary . y + bmp_info . blue_primary . z ; gamma = PerceptibleReciprocal ( gamma ) ; bmp_info . blue_primary . x *= gamma ; bmp_info . blue_primary . y *= gamma ; image -> chromaticity . blue_primary . x = bmp_info . blue_primary . x ; image -> chromaticity . blue_primary . y = bmp_info . blue_primary . y ; bmp_info . gamma_scale . x = ( double ) ReadBlobLSBLong ( image ) / 0x10000 ; bmp_info . gamma_scale . y = ( double ) ReadBlobLSBLong ( image ) / 0x10000 ; bmp_info . gamma_scale . z = ( double ) ReadBlobLSBLong ( image ) / 0x10000 ; image -> gamma = ( bmp_info . gamma_scale . x + bmp_info . gamma_scale . y + bmp_info . gamma_scale . z ) / 3.0 ; } else ( void ) CopyMagickString ( image -> magick , "BMP3" , MagickPathExtent ) ; if ( bmp_info . size > 108 ) { size_t intent ; intent = ReadBlobLSBLong ( image ) ; switch ( ( int ) intent ) { case LCS_GM_BUSINESS : { image -> rendering_intent = SaturationIntent ; break ; } case LCS_GM_GRAPHICS : { image -> rendering_intent = RelativeIntent ; break ; } case LCS_GM_IMAGES : { image -> rendering_intent = PerceptualIntent ; break ; } case LCS_GM_ABS_COLORIMETRIC : { image -> rendering_intent = AbsoluteIntent ; break ; } } ( void ) ReadBlobLSBLong ( image ) ; ( void ) ReadBlobLSBLong ( image ) ; ( void ) ReadBlobLSBLong ( image ) ; } } if ( ( MagickSizeType ) bmp_info . file_size > GetBlobSize ( image ) ) ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , CorruptImageError , "LengthAndFilesizeDoNotMatch" , "`%s\'" , image -> filename ) ; else if ( ( MagickSizeType ) bmp_info . file_size < GetBlobSize ( image ) ) ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , CorruptImageWarning , "LengthAndFilesizeDoNotMatch" , "`%s\'" , image -> filename ) ; if ( bmp_info . width <= 0 ) ThrowReaderException ( CorruptImageError , "NegativeOrZeroImageSize" ) ; if ( bmp_info . height == 0 ) ThrowReaderException ( CorruptImageError , "NegativeOrZeroImageSize" ) ; if ( bmp_info . planes != 1 ) ThrowReaderException ( CorruptImageError , "StaticPlanesValueNotEqualToOne" ) ; if ( ( bmp_info . bits_per_pixel != 1 ) && ( bmp_info . bits_per_pixel != 4 ) && ( bmp_info . bits_per_pixel != 8 ) && ( bmp_info . bits_per_pixel != 16 ) && ( bmp_info . bits_per_pixel != 24 ) && ( bmp_info . bits_per_pixel != 32 ) ) ThrowReaderException ( CorruptImageError , "UnrecognizedBitsPerPixel" ) ; if ( bmp_info . bits_per_pixel < 16 && bmp_info . number_colors > ( 1U << bmp_info . bits_per_pixel ) ) ThrowReaderException ( CorruptImageError , "UnrecognizedNumberOfColors" ) ; if ( ( bmp_info . compression == 1 ) && ( bmp_info . bits_per_pixel != 8 ) ) ThrowReaderException ( CorruptImageError , "UnrecognizedBitsPerPixel" ) ; if ( ( bmp_info . compression == 2 ) && ( bmp_info . bits_per_pixel != 4 ) ) ThrowReaderException ( CorruptImageError , "UnrecognizedBitsPerPixel" ) ; if ( ( bmp_info . compression == 3 ) && ( bmp_info . bits_per_pixel < 16 ) ) ThrowReaderException ( CorruptImageError , "UnrecognizedBitsPerPixel" ) ; switch ( bmp_info . compression ) { case BI_RGB : image -> compression = NoCompression ; break ; case BI_RLE8 : case BI_RLE4 : image -> compression = RLECompression ; break ; case BI_BITFIELDS : break ; case BI_JPEG : ThrowReaderException ( CoderError , "JPEGCompressNotSupported" ) ; case BI_PNG : ThrowReaderException ( CoderError , "PNGCompressNotSupported" ) ; default : ThrowReaderException ( CorruptImageError , "UnrecognizedImageCompression" ) ; } image -> columns = ( size_t ) MagickAbsoluteValue ( bmp_info . width ) ; image -> rows = ( size_t ) MagickAbsoluteValue ( bmp_info . height ) ; image -> depth = bmp_info . bits_per_pixel <= 8 ? bmp_info . bits_per_pixel : 8 ; image -> alpha_trait = ( ( bmp_info . alpha_mask != 0 ) && ( bmp_info . compression == BI_BITFIELDS ) ) ? BlendPixelTrait : UndefinedPixelTrait ; if ( bmp_info . bits_per_pixel < 16 ) { size_t one ; image -> storage_class = PseudoClass ; image -> colors = bmp_info . number_colors ; one = 1 ; if ( image -> colors == 0 ) image -> colors = one << bmp_info . bits_per_pixel ; } image -> resolution . x = ( double ) bmp_info . x_pixels / 100.0 ; image -> resolution . y = ( double ) bmp_info . y_pixels / 100.0 ; image -> units = PixelsPerCentimeterResolution ; if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; if ( image -> storage_class == PseudoClass ) { unsigned char * bmp_colormap ; size_t packet_size ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "<S2SV_blank><S2SV_blank>Reading<S2SV_blank>colormap<S2SV_blank>of<S2SV_blank>%.20g<S2SV_blank>colors" , ( double ) image -> colors ) ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; bmp_colormap = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) image -> colors , 4 * sizeof ( * bmp_colormap ) ) ; if ( bmp_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; if ( ( bmp_info . size == 12 ) || ( bmp_info . size == 64 ) ) packet_size = 3 ; else packet_size = 4 ; offset = SeekBlob ( image , start_position + 14 + bmp_info . size , SEEK_SET ) ; if ( offset < 0 ) { bmp_colormap = ( unsigned char * ) RelinquishMagickMemory ( bmp_colormap ) ; ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; } count = ReadBlob ( image , packet_size * image -> colors , bmp_colormap ) ; if ( count != ( ssize_t ) ( packet_size * image -> colors ) ) { bmp_colormap = ( unsigned char * ) RelinquishMagickMemory ( bmp_colormap ) ; ThrowReaderException ( CorruptImageError , "InsufficientImageDataInFile" ) ; } p = bmp_colormap ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( * p ++ ) ; image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( * p ++ ) ; image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( * p ++ ) ; if ( packet_size == 4 ) p ++ ; } bmp_colormap = ( unsigned char * ) RelinquishMagickMemory ( bmp_colormap ) ; } if ( bmp_info . offset_bits == offset_bits ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; offset_bits = bmp_info . offset_bits ; offset = SeekBlob ( image , start_position + bmp_info . offset_bits , SEEK_SET ) ; if ( offset < 0 ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; if ( bmp_info . compression == BI_RLE4 ) bmp_info . bits_per_pixel <<= 1 ; bytes_per_line = 4 * ( ( image -> columns * bmp_info . bits_per_pixel + 31 ) / 32 ) ; length = ( size_t ) bytes_per_line * image -> rows ; if ( ( ( MagickSizeType ) length / 8 ) > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , "InsufficientImageDataInFile" ) ; if ( ( bmp_info . compression == BI_RGB ) || ( bmp_info . compression == BI_BITFIELDS ) ) { pixel_info = AcquireVirtualMemory ( image -> rows , MagickMax ( bytes_per_line , image -> columns + 256UL ) * sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "<S2SV_blank><S2SV_blank>Reading<S2SV_blank>pixels<S2SV_blank>(%.20g<S2SV_blank>bytes)" , ( double ) length ) ; count = ReadBlob ( image , length , pixels ) ; if ( count != ( ssize_t ) length ) { pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , "InsufficientImageDataInFile" ) ; } } else { pixel_info = AcquireVirtualMemory ( image -> rows , MagickMax ( bytes_per_line , image -> columns + 256UL ) * sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; status = DecodeImage ( image , bmp_info . compression , pixels , image -> columns * image -> rows ) ; if ( status == MagickFalse ) { pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , "UnableToRunlengthDecodeImage" ) ; } } if ( bmp_info . compression == BI_RGB ) { if ( ( image -> alpha_trait == UndefinedPixelTrait ) && ( bmp_info . size == 40 ) && ( bmp_info . bits_per_pixel == 32 ) ) { bytes_per_line = 4 * ( image -> columns ) ; for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( * ( p + 3 ) != 0 ) { image -> alpha_trait = BlendPixelTrait ; y = - 1 ; break ; } p += 4 ; } } } bmp_info . alpha_mask = image -> alpha_trait != UndefinedPixelTrait ? 0xff000000U : 0U ; bmp_info . red_mask = 0x00ff0000U ; bmp_info . green_mask = 0x0000ff00U ; bmp_info . blue_mask = 0x000000ffU ; if ( bmp_info . bits_per_pixel == 16 ) { bmp_info . red_mask = 0x00007c00U ; bmp_info . green_mask = 0x000003e0U ; bmp_info . blue_mask = 0x0000001fU ; } } ( void ) memset ( & shift , 0 , sizeof ( shift ) ) ; ( void ) memset ( & quantum_bits , 0 , sizeof ( quantum_bits ) ) ; if ( ( bmp_info . bits_per_pixel == 16 ) || ( bmp_info . bits_per_pixel == 32 ) ) { register unsigned int sample ; if ( bmp_info . red_mask != 0 ) while ( ( ( bmp_info . red_mask << shift . red ) & 0x80000000UL ) == 0 ) { shift . red ++ ; if ( shift . red >= 32U ) break ; } if ( bmp_info . green_mask != 0 ) while ( ( ( bmp_info . green_mask << shift . green ) & 0x80000000UL ) == 0 ) { shift . green ++ ; if ( shift . green >= 32U ) break ; } if ( bmp_info . blue_mask != 0 ) while ( ( ( bmp_info . blue_mask << shift . blue ) & 0x80000000UL ) == 0 ) { shift . blue ++ ; if ( shift . blue >= 32U ) break ; } if ( bmp_info . alpha_mask != 0 ) while ( ( ( bmp_info . alpha_mask << shift . alpha ) & 0x80000000UL ) == 0 ) { shift . alpha ++ ; if ( shift . alpha >= 32U ) break ; } sample = shift . red ; while ( ( ( bmp_info . red_mask << sample ) & 0x80000000UL ) != 0 ) { sample ++ ; if ( sample >= 32U ) break ; } quantum_bits . red = ( MagickRealType ) ( sample - shift . red ) ; sample = shift . green ; while ( ( ( bmp_info . green_mask << sample ) & 0x80000000UL ) != 0 ) { sample ++ ; if ( sample >= 32U ) break ; } quantum_bits . green = ( MagickRealType ) ( sample - shift . green ) ; sample = shift . blue ; while ( ( ( bmp_info . blue_mask << sample ) & 0x80000000UL ) != 0 ) { sample ++ ; if ( sample >= 32U ) break ; } quantum_bits . blue = ( MagickRealType ) ( sample - shift . blue ) ; sample = shift . alpha ; while ( ( ( bmp_info . alpha_mask << sample ) & 0x80000000UL ) != 0 ) { sample ++ ; if ( sample >= 32U ) break ; } quantum_bits . alpha = ( MagickRealType ) ( sample - shift . alpha ) ; } switch ( bmp_info . bits_per_pixel ) { case 1 : { for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) { for ( bit = 0 ; bit < 8 ; bit ++ ) { index = ( Quantum ) ( ( ( * p ) & ( 0x80 >> bit ) ) != 0 ? 0x01 : 0x00 ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( image -> columns % 8 ) != 0 ) { for ( bit = 0 ; bit < ( image -> columns % 8 ) ; bit ++ ) { index = ( Quantum ) ( ( ( * p ) & ( 0x80 >> bit ) ) != 0 ? 0x01 : 0x00 ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image , exception ) ; break ; } case 4 : { for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 1 ) ; x += 2 ) { ValidateColormapValue ( image , ( ssize_t ) ( ( * p >> 4 ) & 0x0f ) , & index , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; ValidateColormapValue ( image , ( ssize_t ) ( * p & 0x0f ) , & index , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; p ++ ; } if ( ( image -> columns % 2 ) != 0 ) { ValidateColormapValue ( image , ( ssize_t ) ( ( * p >> 4 ) & 0xf ) , & index , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; p ++ ; x ++ ; } if ( x < ( ssize_t ) image -> columns ) break ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image , exception ) ; break ; } case 8 : { if ( ( bmp_info . compression == BI_RLE8 ) || ( bmp_info . compression == BI_RLE4 ) ) bytes_per_line = image -> columns ; for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = ( ssize_t ) image -> columns ; x != 0 ; -- x ) { ValidateColormapValue ( image , ( ssize_t ) * p ++ , & index , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; offset = ( MagickOffsetType ) ( image -> rows - y - 1 ) ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image , exception ) ; break ; } case 16 : { unsigned int alpha , pixel ; if ( ( bmp_info . compression != BI_RGB ) && ( bmp_info . compression != BI_BITFIELDS ) ) { pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , "UnrecognizedImageCompression" ) ; } bytes_per_line = 2 * ( image -> columns + image -> columns % 2 ) ; image -> storage_class = DirectClass ; for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { pixel = ( unsigned int ) ( * p ++ ) ; pixel |= ( * p ++ ) << 8 ; red = ( ( pixel & bmp_info . red_mask ) << shift . red ) >> 16 ; if ( quantum_bits . red == 5 ) red |= ( ( red & 0xe000 ) >> 5 ) ; if ( quantum_bits . red <= 8 ) red |= ( ( red & 0xff00 ) >> 8 ) ; green = ( ( pixel & bmp_info . green_mask ) << shift . green ) >> 16 ; if ( quantum_bits . green == 5 ) green |= ( ( green & 0xe000 ) >> 5 ) ; if ( quantum_bits . green == 6 ) green |= ( ( green & 0xc000 ) >> 6 ) ; if ( quantum_bits . green <= 8 ) green |= ( ( green & 0xff00 ) >> 8 ) ; blue = ( ( pixel & bmp_info . blue_mask ) << shift . blue ) >> 16 ; if ( quantum_bits . blue == 5 ) blue |= ( ( blue & 0xe000 ) >> 5 ) ; if ( quantum_bits . blue <= 8 ) blue |= ( ( blue & 0xff00 ) >> 8 ) ; SetPixelRed ( image , ScaleShortToQuantum ( ( unsigned short ) red ) , q ) ; SetPixelGreen ( image , ScaleShortToQuantum ( ( unsigned short ) green ) , q ) ; SetPixelBlue ( image , ScaleShortToQuantum ( ( unsigned short ) blue ) , q ) ; SetPixelAlpha ( image , OpaqueAlpha , q ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) { alpha = ( ( pixel & bmp_info . alpha_mask ) << shift . alpha ) >> 16 ; if ( quantum_bits . alpha <= 8 ) alpha |= ( ( alpha & 0xff00 ) >> 8 ) ; SetPixelAlpha ( image , ScaleShortToQuantum ( ( unsigned short ) alpha ) , q ) ; } q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; offset = ( MagickOffsetType ) ( image -> rows - y - 1 ) ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } break ; } case 24 : { bytes_per_line = 4 * ( ( image -> columns * 24 + 31 ) / 32 ) ; for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelAlpha ( image , OpaqueAlpha , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; offset = ( MagickOffsetType ) ( image -> rows - y - 1 ) ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } break ; } case 32 : { if ( ( bmp_info . compression != BI_RGB ) && ( bmp_info . compression != BI_BITFIELDS ) ) { pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , "UnrecognizedImageCompression" ) ; } bytes_per_line = 4 * ( image -> columns ) ; for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { unsigned int alpha , pixel ; p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { pixel = ( unsigned int ) ( * p ++ ) ; pixel |= ( ( unsigned int ) * p ++ << 8 ) ; pixel |= ( ( unsigned int ) * p ++ << 16 ) ; pixel |= ( ( unsigned int ) * p ++ << 24 ) ; red = ( ( pixel & bmp_info . red_mask ) << shift . red ) >> 16 ; if ( quantum_bits . red == 8 ) red |= ( red >> 8 ) ; green = ( ( pixel & bmp_info . green_mask ) << shift . green ) >> 16 ; if ( quantum_bits . green == 8 ) green |= ( green >> 8 ) ; blue = ( ( pixel & bmp_info . blue_mask ) << shift . blue ) >> 16 ; if ( quantum_bits . blue == 8 ) blue |= ( blue >> 8 ) ; SetPixelRed ( image , ScaleShortToQuantum ( ( unsigned short ) red ) , q ) ; SetPixelGreen ( image , ScaleShortToQuantum ( ( unsigned short ) green ) , q ) ; SetPixelBlue ( image , ScaleShortToQuantum ( ( unsigned short ) blue ) , q ) ; SetPixelAlpha ( image , OpaqueAlpha , q ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) { alpha = ( ( pixel & bmp_info . alpha_mask ) << shift . alpha ) >> 16 ; if ( quantum_bits . alpha == 8 ) alpha |= ( alpha >> 8 ) ; SetPixelAlpha ( image , ScaleShortToQuantum ( ( unsigned short ) alpha ) , q ) ; } q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; offset = ( MagickOffsetType ) ( image -> rows - y - 1 ) ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } break ; } default : { pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; } } pixel_info = RelinquishVirtualMemory ( pixel_info ) ; if ( y > 0 ) break ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , "UnexpectedEndOfFile" , image -> filename ) ; break ; } if ( bmp_info . height < 0 ) { Image * flipped_image ; flipped_image = FlipImage ( image , exception ) ; if ( flipped_image != ( Image * ) NULL ) { DuplicateBlob ( flipped_image , image ) ; ReplaceImageInList ( & image , flipped_image ) ; image = flipped_image ; } } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; * magick = '\\0' ; if ( bmp_info . ba_offset != 0 ) { offset = SeekBlob ( image , ( MagickOffsetType ) bmp_info . ba_offset , SEEK_SET ) ; if ( offset < 0 ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; } count = ReadBlob ( image , 2 , magick ) ; if ( ( count == 2 ) && ( IsBMP ( magick , 2 ) != MagickFalse ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { status = MagickFalse ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( IsBMP ( magick , 2 ) != MagickFalse ) ; ( void ) CloseBlob ( image ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; return ( GetFirstImageInList ( image ) ) ; }
CWE-416 static Image * ReadMATImageV4 ( const ImageInfo * image_info , Image * image , ExceptionInfo * exception ) { typedef struct { unsigned char Type [ 4 ] ; unsigned int nRows ; unsigned int nCols ; unsigned int imagf ; unsigned int nameLen ; } MAT4_HDR ; long ldblk ; EndianType endian ; Image * rotated_image ; MagickBooleanType status ; MAT4_HDR HDR ; QuantumInfo * quantum_info ; QuantumFormatType format_type ; register ssize_t i ; ssize_t count , y ; unsigned char * pixels ; unsigned int depth ; quantum_info = ( QuantumInfo * ) NULL ; ( void ) SeekBlob ( image , 0 , SEEK_SET ) ; status = MagickTrue ; while ( EOFBlob ( image ) == MagickFalse ) { ldblk = ReadBlobLSBLong ( image ) ; <S2SV_StartBug> if ( ( ldblk > 9999 ) || ( ldblk < 0 ) ) <S2SV_EndBug> break ; HDR . Type [ 3 ] = ldblk % 10 ; ldblk /= 10 ; HDR . Type [ 2 ] = ldblk % 10 ; ldblk /= 10 ; HDR . Type [ 1 ] = ldblk % 10 ; ldblk /= 10 ; HDR . Type [ 0 ] = ldblk ; if ( HDR . Type [ 3 ] != 0 ) break ; if ( HDR . Type [ 2 ] != 0 ) break ; if ( HDR . Type [ 0 ] == 0 ) { HDR . nRows = ReadBlobLSBLong ( image ) ; HDR . nCols = ReadBlobLSBLong ( image ) ; HDR . imagf = ReadBlobLSBLong ( image ) ; HDR . nameLen = ReadBlobLSBLong ( image ) ; endian = LSBEndian ; } else { HDR . nRows = ReadBlobMSBLong ( image ) ; HDR . nCols = ReadBlobMSBLong ( image ) ; HDR . imagf = ReadBlobMSBLong ( image ) ; HDR . nameLen = ReadBlobMSBLong ( image ) ; endian = MSBEndian ; } if ( ( HDR . imagf != 0 ) && ( HDR . imagf != 1 ) ) break ; if ( HDR . nameLen > 0xFFFF ) return ( DestroyImageList ( image ) ) ; for ( i = 0 ; i < ( ssize_t ) HDR . nameLen ; i ++ ) { int byte ; byte = ReadBlobByte ( image ) ; if ( byte == EOF ) { ThrowFileException ( exception , CorruptImageError , "UnexpectedEndOfFile" , image -> filename ) ; break ; } } image -> columns = ( size_t ) HDR . nRows ; image -> rows = ( size_t ) HDR . nCols ; if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) return ( DestroyImageList ( image ) ) ; if ( image_info -> ping != MagickFalse ) { Swap ( image -> columns , image -> rows ) ; if ( HDR . imagf == 1 ) ldblk *= 2 ; SeekBlob ( image , HDR . nCols * ldblk , SEEK_CUR ) ; if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) return ( image -> previous == ( Image * ) NULL ? DestroyImageList ( image ) : image ) ; goto skip_reading_current ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; ( void ) SetImageBackgroundColor ( image , exception ) ; ( void ) SetImageColorspace ( image , GRAYColorspace , exception ) ; quantum_info = AcquireQuantumInfo ( image_info , image ) ; if ( quantum_info == ( QuantumInfo * ) NULL ) return ( DestroyImageList ( image ) ) ; switch ( HDR . Type [ 1 ] ) { case 0 : format_type = FloatingPointQuantumFormat ; depth = 64 ; break ; case 1 : format_type = FloatingPointQuantumFormat ; depth = 32 ; break ; case 2 : format_type = UnsignedQuantumFormat ; depth = 16 ; break ; case 3 : format_type = SignedQuantumFormat ; depth = 16 ; break ; case 4 : format_type = UnsignedQuantumFormat ; depth = 8 ; break ; default : format_type = UnsignedQuantumFormat ; depth = 8 ; break ; } image -> depth = depth ; if ( HDR . Type [ 0 ] != 0 ) SetQuantumEndian ( image , quantum_info , MSBEndian ) ; status = SetQuantumFormat ( image , quantum_info , format_type ) ; status = SetQuantumDepth ( image , quantum_info , depth ) ; status = SetQuantumEndian ( image , quantum_info , endian ) ; SetQuantumScale ( quantum_info , 1.0 ) ; pixels = ( unsigned char * ) GetQuantumPixels ( quantum_info ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { register Quantum * magick_restrict q ; count = ReadBlob ( image , depth / 8 * image -> columns , ( char * ) pixels ) ; if ( count == - 1 ) break ; q = QueueAuthenticPixels ( image , 0 , image -> rows - y - 1 , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; ( void ) ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , GrayQuantum , pixels , exception ) ; if ( ( HDR . Type [ 1 ] == 2 ) || ( HDR . Type [ 1 ] == 3 ) ) FixSignedValues ( image , q , ( int ) image -> columns ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } if ( HDR . imagf == 1 ) for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { count = ReadBlob ( image , depth / 8 * image -> columns , ( char * ) pixels ) ; if ( count == - 1 ) break ; if ( HDR . Type [ 1 ] == 0 ) InsertComplexDoubleRow ( image , ( double * ) pixels , y , 0 , 0 , exception ) ; else InsertComplexFloatRow ( image , ( float * ) pixels , y , 0 , 0 , exception ) ; } if ( quantum_info != ( QuantumInfo * ) NULL ) quantum_info = DestroyQuantumInfo ( quantum_info ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , "UnexpectedEndOfFile" , image -> filename ) ; break ; } rotated_image = RotateImage ( image , 90.0 , exception ) ; if ( rotated_image != ( Image * ) NULL ) { rotated_image -> page . x = 0 ; rotated_image -> page . y = 0 ; rotated_image -> colors = image -> colors ; DestroyBlob ( rotated_image ) ; rotated_image -> blob = ReferenceBlob ( image -> blob ) ; AppendImageToList ( & image , rotated_image ) ; DeleteImageFromList ( & image ) ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; skip_reading_current : AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { status = MagickFalse ; break ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } ( void ) CloseBlob ( image ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; return ( GetFirstImageInList ( image ) ) ; }
CWE-416 static Image * ReadMATImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image , * image2 = NULL , * rotated_image ; register Quantum * q ; unsigned int status ; MATHeader MATLAB_HDR ; size_t size ; size_t CellType ; QuantumInfo * quantum_info ; ImageInfo * clone_info ; int i ; ssize_t ldblk ; unsigned char * BImgBuff = NULL ; double MinVal , MaxVal ; unsigned z , z2 ; unsigned Frames ; int logging ; int sample_size ; MagickOffsetType filepos = 0x80 ; unsigned int ( * ReadBlobXXXLong ) ( Image * image ) ; unsigned short ( * ReadBlobXXXShort ) ( Image * image ) ; void ( * ReadBlobDoublesXXX ) ( Image * image , size_t len , double * data ) ; void ( * ReadBlobFloatsXXX ) ( Image * image , size_t len , float * data ) ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; logging = LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "enter" ) ; image = AcquireImage ( image_info , exception ) ; image2 = ( Image * ) NULL ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } quantum_info = ( QuantumInfo * ) NULL ; clone_info = ( ImageInfo * ) NULL ; if ( ReadBlob ( image , 124 , ( unsigned char * ) & MATLAB_HDR . identific ) != 124 ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; if ( strncmp ( MATLAB_HDR . identific , "MATLAB" , 6 ) != 0 ) { image = ReadMATImageV4 ( image_info , image , exception ) ; if ( image == NULL ) { if ( ( image != image2 ) && ( image2 != ( Image * ) NULL ) ) image2 = DestroyImage ( image2 ) ; if ( clone_info != ( ImageInfo * ) NULL ) clone_info = DestroyImageInfo ( clone_info ) ; return ( ( Image * ) NULL ) ; } goto END_OF_READING ; } MATLAB_HDR . Version = ReadBlobLSBShort ( image ) ; if ( ReadBlob ( image , 2 , ( unsigned char * ) & MATLAB_HDR . EndianIndicator ) != 2 ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "<S2SV_blank><S2SV_blank>Endian<S2SV_blank>%c%c" , MATLAB_HDR . EndianIndicator [ 0 ] , MATLAB_HDR . EndianIndicator [ 1 ] ) ; if ( ! strncmp ( MATLAB_HDR . EndianIndicator , "IM" , 2 ) ) { ReadBlobXXXLong = ReadBlobLSBLong ; ReadBlobXXXShort = ReadBlobLSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesLSB ; ReadBlobFloatsXXX = ReadBlobFloatsLSB ; image -> endian = LSBEndian ; } else if ( ! strncmp ( MATLAB_HDR . EndianIndicator , "MI" , 2 ) ) { ReadBlobXXXLong = ReadBlobMSBLong ; ReadBlobXXXShort = ReadBlobMSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesMSB ; ReadBlobFloatsXXX = ReadBlobFloatsMSB ; image -> endian = MSBEndian ; } else { MATLAB_KO : if ( ( image != image2 ) && ( image2 != ( Image * ) NULL ) ) image2 = DestroyImage ( image2 ) ; if ( clone_info != ( ImageInfo * ) NULL ) clone_info = DestroyImageInfo ( clone_info ) ; ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; } filepos = TellBlob ( image ) ; <S2SV_StartBug> while ( ! EOFBlob ( image ) ) <S2SV_EndBug> { Frames = 1 ; <S2SV_StartBug> if ( filepos != ( unsigned int ) filepos ) <S2SV_EndBug> break ; if ( SeekBlob ( image , filepos , SEEK_SET ) != filepos ) break ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; MATLAB_HDR . ObjectSize = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; <S2SV_StartBug> if ( ( MagickSizeType ) ( MATLAB_HDR . ObjectSize + filepos ) > GetBlobSize ( image ) ) <S2SV_EndBug> goto MATLAB_KO ; filepos += ( MagickOffsetType ) MATLAB_HDR . ObjectSize + 4 + 4 ; if ( clone_info != ( ImageInfo * ) NULL ) clone_info = DestroyImageInfo ( clone_info ) ; clone_info = CloneImageInfo ( image_info ) ; if ( ( image != image2 ) && ( image2 != ( Image * ) NULL ) ) image2 = DestroyImage ( image2 ) ; image2 = image ; # if defined ( MAGICKCORE_ZLIB_DELEGATE ) if ( MATLAB_HDR . DataType == miCOMPRESSED ) { image2 = decompress_block ( image , & MATLAB_HDR . ObjectSize , clone_info , exception ) ; if ( image2 == NULL ) continue ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image2 ) ; } # endif if ( MATLAB_HDR . DataType != miMATRIX ) { clone_info = DestroyImageInfo ( clone_info ) ; # if defined ( MAGICKCORE_ZLIB_DELEGATE ) if ( image2 != image ) DeleteImageFromList ( & image2 ) ; # endif continue ; } MATLAB_HDR . unknown1 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown2 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown5 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . StructureClass = MATLAB_HDR . unknown5 & 0xFF ; MATLAB_HDR . StructureFlag = ( MATLAB_HDR . unknown5 >> 8 ) & 0xFF ; MATLAB_HDR . unknown3 = ReadBlobXXXLong ( image2 ) ; if ( image != image2 ) MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . DimFlag = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeX = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeY = ReadBlobXXXLong ( image2 ) ; switch ( MATLAB_HDR . DimFlag ) { case 8 : z2 = z = 1 ; break ; case 12 : z2 = z = ReadBlobXXXLong ( image2 ) ; ( void ) ReadBlobXXXLong ( image2 ) ; if ( z != 3 ) { if ( clone_info != ( ImageInfo * ) NULL ) clone_info = DestroyImageInfo ( clone_info ) ; if ( ( image != image2 ) && ( image2 != ( Image * ) NULL ) ) image2 = DestroyImage ( image2 ) ; ThrowReaderException ( CoderError , "MultidimensionalMatricesAreNotSupported" ) ; } break ; case 16 : z2 = z = ReadBlobXXXLong ( image2 ) ; if ( z != 3 && z != 1 ) { if ( clone_info != ( ImageInfo * ) NULL ) clone_info = DestroyImageInfo ( clone_info ) ; if ( ( image != image2 ) && ( image2 != ( Image * ) NULL ) ) image2 = DestroyImage ( image2 ) ; ThrowReaderException ( CoderError , "MultidimensionalMatricesAreNotSupported" ) ; } Frames = ReadBlobXXXLong ( image2 ) ; if ( Frames == 0 ) { if ( clone_info != ( ImageInfo * ) NULL ) clone_info = DestroyImageInfo ( clone_info ) ; if ( ( image != image2 ) && ( image2 != ( Image * ) NULL ) ) image2 = DestroyImage ( image2 ) ; ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; } if ( AcquireMagickResource ( ListLengthResource , Frames ) == MagickFalse ) { if ( clone_info != ( ImageInfo * ) NULL ) clone_info = DestroyImageInfo ( clone_info ) ; if ( ( image != image2 ) && ( image2 != ( Image * ) NULL ) ) image2 = DestroyImage ( image2 ) ; ThrowReaderException ( ResourceLimitError , "ListLengthExceedsLimit" ) ; } break ; default : if ( clone_info != ( ImageInfo * ) NULL ) clone_info = DestroyImageInfo ( clone_info ) ; if ( ( image != image2 ) && ( image2 != ( Image * ) NULL ) ) image2 = DestroyImage ( image2 ) ; ThrowReaderException ( CoderError , "MultidimensionalMatricesAreNotSupported" ) ; } MATLAB_HDR . Flag1 = ReadBlobXXXShort ( image2 ) ; MATLAB_HDR . NameFlag = ReadBlobXXXShort ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "MATLAB_HDR.StructureClass<S2SV_blank>%d" , MATLAB_HDR . StructureClass ) ; if ( MATLAB_HDR . StructureClass != mxCHAR_CLASS && MATLAB_HDR . StructureClass != mxSINGLE_CLASS && MATLAB_HDR . StructureClass != mxDOUBLE_CLASS && MATLAB_HDR . StructureClass != mxINT8_CLASS && MATLAB_HDR . StructureClass != mxUINT8_CLASS && MATLAB_HDR . StructureClass != mxINT16_CLASS && MATLAB_HDR . StructureClass != mxUINT16_CLASS && MATLAB_HDR . StructureClass != mxINT32_CLASS && MATLAB_HDR . StructureClass != mxUINT32_CLASS && MATLAB_HDR . StructureClass != mxINT64_CLASS && MATLAB_HDR . StructureClass != mxUINT64_CLASS ) { if ( ( image2 != ( Image * ) NULL ) && ( image2 != image ) ) { CloseBlob ( image2 ) ; DeleteImageFromList ( & image2 ) ; } if ( clone_info != ( ImageInfo * ) NULL ) clone_info = DestroyImageInfo ( clone_info ) ; ThrowReaderException ( CoderError , "UnsupportedCellTypeInTheMatrix" ) ; } switch ( MATLAB_HDR . NameFlag ) { case 0 : size = ReadBlobXXXLong ( image2 ) ; size = 4 * ( ( ( size_t ) size + 3 + 1 ) / 4 ) ; ( void ) SeekBlob ( image2 , size , SEEK_CUR ) ; break ; case 1 : case 2 : case 3 : case 4 : ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; break ; default : goto MATLAB_KO ; } CellType = ReadBlobXXXLong ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "MATLAB_HDR.CellType:<S2SV_blank>%.20g" , ( double ) CellType ) ; if ( ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) != 4 ) goto MATLAB_KO ; NEXT_FRAME : switch ( CellType ) { case miINT8 : case miUINT8 : sample_size = 8 ; if ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) image -> depth = 1 ; else image -> depth = 8 ; ldblk = ( ssize_t ) MATLAB_HDR . SizeX ; break ; case miINT16 : case miUINT16 : sample_size = 16 ; image -> depth = 16 ; ldblk = ( ssize_t ) ( 2 * MATLAB_HDR . SizeX ) ; break ; case miINT32 : case miUINT32 : sample_size = 32 ; image -> depth = 32 ; ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miINT64 : case miUINT64 : sample_size = 64 ; image -> depth = 64 ; ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; case miSINGLE : sample_size = 32 ; image -> depth = 32 ; ( void ) SetImageOption ( clone_info , "quantum:format" , "floating-point" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miDOUBLE : sample_size = 64 ; image -> depth = 64 ; ( void ) SetImageOption ( clone_info , "quantum:format" , "floating-point" ) ; DisableMSCWarning ( 4127 ) if ( sizeof ( double ) != 8 ) RestoreMSCWarning { if ( clone_info != ( ImageInfo * ) NULL ) clone_info = DestroyImageInfo ( clone_info ) ; if ( ( image != image2 ) && ( image2 != ( Image * ) NULL ) ) image2 = DestroyImage ( image2 ) ; ThrowReaderException ( CoderError , "IncompatibleSizeOfDouble" ) ; } if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; default : if ( ( image != image2 ) && ( image2 != ( Image * ) NULL ) ) image2 = DestroyImage ( image2 ) ; if ( clone_info ) clone_info = DestroyImageInfo ( clone_info ) ; ThrowReaderException ( CoderError , "UnsupportedCellTypeInTheMatrix" ) ; } ( void ) sample_size ; image -> columns = MATLAB_HDR . SizeX ; image -> rows = MATLAB_HDR . SizeY ; image -> colors = GetQuantumRange ( image -> depth ) ; if ( image -> columns == 0 || image -> rows == 0 ) goto MATLAB_KO ; if ( ( unsigned int ) ldblk * MATLAB_HDR . SizeY > MATLAB_HDR . ObjectSize ) goto MATLAB_KO ; if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) { image -> type = GrayscaleType ; SetImageColorspace ( image , GRAYColorspace , exception ) ; } if ( image_info -> ping ) { size_t temp = image -> columns ; image -> columns = image -> rows ; image -> rows = temp ; goto done_reading ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) { if ( clone_info != ( ImageInfo * ) NULL ) clone_info = DestroyImageInfo ( clone_info ) ; if ( ( image != image2 ) && ( image2 != ( Image * ) NULL ) ) image2 = DestroyImage ( image2 ) ; return ( DestroyImageList ( image ) ) ; } ( void ) SetImageBackgroundColor ( image , exception ) ; quantum_info = AcquireQuantumInfo ( clone_info , image ) ; if ( quantum_info == ( QuantumInfo * ) NULL ) { if ( clone_info != ( ImageInfo * ) NULL ) clone_info = DestroyImageInfo ( clone_info ) ; if ( ( image != image2 ) && ( image2 != ( Image * ) NULL ) ) image2 = DestroyImage ( image2 ) ; ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; } BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ( ldblk ) , sizeof ( double ) ) ; if ( BImgBuff == NULL ) { if ( clone_info != ( ImageInfo * ) NULL ) clone_info = DestroyImageInfo ( clone_info ) ; if ( ( image != image2 ) && ( image2 != ( Image * ) NULL ) ) image2 = DestroyImage ( image2 ) ; if ( quantum_info != ( QuantumInfo * ) NULL ) quantum_info = DestroyQuantumInfo ( quantum_info ) ; ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; } ( void ) memset ( BImgBuff , 0 , ldblk * sizeof ( double ) ) ; MinVal = 0 ; MaxVal = 0 ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & quantum_info -> minimum , & quantum_info -> maximum ) ; } if ( z == 1 ) z = 0 ; do { for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { q = GetAuthenticPixels ( image , 0 , MATLAB_HDR . SizeY - i - 1 , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "<S2SV_blank><S2SV_blank>MAT<S2SV_blank>set<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>returns<S2SV_blank>unexpected<S2SV_blank>NULL<S2SV_blank>on<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u." , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto done_reading ; } if ( ReadBlob ( image2 , ldblk , ( unsigned char * ) BImgBuff ) != ( ssize_t ) ldblk ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , <S2SV_StartBug> "<S2SV_blank><S2SV_blank>MAT<S2SV_blank>cannot<S2SV_blank>read<S2SV_blank>scanrow<S2SV_blank>%u<S2SV_blank>from<S2SV_blank>a<S2SV_blank>file." , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; <S2SV_EndBug> goto ExitLoop ; } if ( ( CellType == miINT8 || CellType == miUINT8 ) && ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) ) { FixLogical ( ( unsigned char * ) BImgBuff , ldblk ) ; if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) { ImportQuantumPixelsFailed : if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>ImportQuantumPixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; break ; } } else { if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) goto ImportQuantumPixelsFailed ; if ( z <= 1 && ( CellType == miINT8 || CellType == miINT16 || CellType == miINT32 || CellType == miINT64 ) ) FixSignedValues ( image , q , MATLAB_HDR . SizeX ) ; } if ( ! SyncAuthenticPixels ( image , exception ) ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>sync<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } } } while ( z -- >= 2 ) ; ExitLoop : if ( i != ( long ) MATLAB_HDR . SizeY ) goto END_OF_READING ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { CellType = ReadBlobXXXLong ( image2 ) ; i = ReadBlobXXXLong ( image2 ) ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & MinVal , & MaxVal ) ; } if ( CellType == miDOUBLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobDoublesXXX ( image2 , ldblk , ( double * ) BImgBuff ) ; if ( EOFBlob ( image ) != MagickFalse ) break ; InsertComplexDoubleRow ( image , ( double * ) BImgBuff , i , MinVal , MaxVal , exception ) ; } if ( CellType == miSINGLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobFloatsXXX ( image2 , ldblk , ( float * ) BImgBuff ) ; if ( EOFBlob ( image ) != MagickFalse ) break ; InsertComplexFloatRow ( image , ( float * ) BImgBuff , i , MinVal , MaxVal , exception ) ; } } if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) image -> type = GrayscaleType ; if ( image -> depth == 1 ) image -> type = BilevelType ; if ( image2 == image ) image2 = NULL ; rotated_image = RotateImage ( image , 90.0 , exception ) ; if ( rotated_image != ( Image * ) NULL ) { rotated_image -> page . x = 0 ; rotated_image -> page . y = 0 ; rotated_image -> colors = image -> colors ; DestroyBlob ( rotated_image ) ; rotated_image -> blob = ReferenceBlob ( image -> blob ) ; AppendImageToList ( & image , rotated_image ) ; DeleteImageFromList ( & image ) ; } done_reading : if ( image2 != NULL ) if ( image2 != image ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } } } if ( EOFBlob ( image ) != MagickFalse ) break ; AcquireNextImage ( image_info , image , exception ) ; if ( image -> next == ( Image * ) NULL ) break ; image = SyncNextImageInList ( image ) ; image -> columns = image -> rows = 0 ; image -> colors = 0 ; RelinquishMagickMemory ( BImgBuff ) ; BImgBuff = NULL ; if ( quantum_info != ( QuantumInfo * ) NULL ) quantum_info = DestroyQuantumInfo ( quantum_info ) ; if ( -- Frames > 0 ) { z = z2 ; if ( image2 == NULL ) image2 = image ; if ( ! EOFBlob ( image ) && TellBlob ( image ) < filepos ) goto NEXT_FRAME ; } if ( ( image2 != NULL ) && ( image2 != image ) ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } } } if ( clone_info ) clone_info = DestroyImageInfo ( clone_info ) ; } END_OF_READING : RelinquishMagickMemory ( BImgBuff ) ; if ( quantum_info != ( QuantumInfo * ) NULL ) quantum_info = DestroyQuantumInfo ( quantum_info ) ; CloseBlob ( image ) ; { Image * p ; ssize_t scene = 0 ; p = image ; image = NULL ; while ( p != ( Image * ) NULL ) { Image * tmp = p ; if ( ( p -> rows == 0 ) || ( p -> columns == 0 ) ) { p = p -> previous ; if ( tmp == image2 ) image2 = ( Image * ) NULL ; DeleteImageFromList ( & tmp ) ; } else { image = p ; p = p -> previous ; } } for ( p = image ; p != ( Image * ) NULL ; p = p -> next ) p -> scene = scene ++ ; } if ( clone_info != NULL ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } DestroyImageInfo ( clone_info ) ; clone_info = NULL ; } if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "return" ) ; if ( ( image != image2 ) && ( image2 != ( Image * ) NULL ) ) image2 = DestroyImage ( image2 ) ; if ( image == ( Image * ) NULL ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) return ( image ) ; }
CWE-399 static Image * ReadBMPImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { BMPInfo bmp_info ; Image * image ; MagickBooleanType status ; MagickOffsetType offset , profile_data , profile_size , start_position ; MemoryInfo * pixel_info ; Quantum index ; register Quantum * q ; register ssize_t i , x ; register unsigned char * p ; size_t bit , bytes_per_line , length ; ssize_t count , y ; unsigned char magick [ 12 ] , * pixels ; unsigned int blue , green , offset_bits , red ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) memset ( & bmp_info , 0 , sizeof ( bmp_info ) ) ; bmp_info . ba_offset = 0 ; start_position = 0 ; offset_bits = 0 ; count = ReadBlob ( image , 2 , magick ) ; if ( count != 2 ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; do { PixelInfo quantum_bits ; PixelPacket shift ; start_position = TellBlob ( image ) - 2 ; bmp_info . ba_offset = 0 ; while ( LocaleNCompare ( ( char * ) magick , "BA" , 2 ) == 0 ) { bmp_info . file_size = ReadBlobLSBLong ( image ) ; bmp_info . ba_offset = ReadBlobLSBLong ( image ) ; bmp_info . offset_bits = ReadBlobLSBLong ( image ) ; count = ReadBlob ( image , 2 , magick ) ; if ( count != 2 ) break ; } if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "<S2SV_blank><S2SV_blank>Magick:<S2SV_blank>%c%c" , magick [ 0 ] , magick [ 1 ] ) ; if ( ( count != 2 ) || ( ( LocaleNCompare ( ( char * ) magick , "BM" , 2 ) != 0 ) && ( LocaleNCompare ( ( char * ) magick , "CI" , 2 ) != 0 ) ) ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; bmp_info . file_size = ReadBlobLSBLong ( image ) ; ( void ) ReadBlobLSBLong ( image ) ; bmp_info . offset_bits = ReadBlobLSBLong ( image ) ; bmp_info . size = ReadBlobLSBLong ( image ) ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "<S2SV_blank><S2SV_blank>BMP<S2SV_blank>size:<S2SV_blank>%u" , bmp_info . size ) ; profile_data = 0 ; profile_size = 0 ; if ( bmp_info . size == 12 ) { ( void ) CopyMagickString ( image -> magick , "BMP2" , MagickPathExtent ) ; bmp_info . width = ( ssize_t ) ( ( short ) ReadBlobLSBShort ( image ) ) ; bmp_info . height = ( ssize_t ) ( ( short ) ReadBlobLSBShort ( image ) ) ; bmp_info . planes = ReadBlobLSBShort ( image ) ; bmp_info . bits_per_pixel = ReadBlobLSBShort ( image ) ; bmp_info . x_pixels = 0 ; bmp_info . y_pixels = 0 ; bmp_info . number_colors = 0 ; bmp_info . compression = BI_RGB ; bmp_info . image_size = 0 ; bmp_info . alpha_mask = 0 ; if ( image -> debug != MagickFalse ) { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "<S2SV_blank><S2SV_blank>Format:<S2SV_blank>OS/2<S2SV_blank>Bitmap" ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "<S2SV_blank><S2SV_blank>Geometry:<S2SV_blank>%.20gx%.20g" , ( double ) bmp_info . width , ( double ) bmp_info . height ) ; } } else { if ( bmp_info . size < 40 ) ThrowReaderException ( CorruptImageError , "NonOS2HeaderSizeError" ) ; bmp_info . width = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; bmp_info . height = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; bmp_info . planes = ReadBlobLSBShort ( image ) ; bmp_info . bits_per_pixel = ReadBlobLSBShort ( image ) ; bmp_info . compression = ReadBlobLSBLong ( image ) ; bmp_info . image_size = ReadBlobLSBLong ( image ) ; bmp_info . x_pixels = ReadBlobLSBLong ( image ) ; bmp_info . y_pixels = ReadBlobLSBLong ( image ) ; bmp_info . number_colors = ReadBlobLSBLong ( image ) ; if ( ( MagickSizeType ) bmp_info . number_colors > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , "InsufficientImageDataInFile" ) ; bmp_info . colors_important = ReadBlobLSBLong ( image ) ; if ( image -> debug != MagickFalse ) { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "<S2SV_blank><S2SV_blank>Format:<S2SV_blank>MS<S2SV_blank>Windows<S2SV_blank>bitmap" ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "<S2SV_blank><S2SV_blank>Geometry:<S2SV_blank>%.20gx%.20g" , ( double ) bmp_info . width , ( double ) bmp_info . height ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "<S2SV_blank><S2SV_blank>Bits<S2SV_blank>per<S2SV_blank>pixel:<S2SV_blank>%.20g" , ( double ) bmp_info . bits_per_pixel ) ; switch ( bmp_info . compression ) { case BI_RGB : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_RGB" ) ; break ; } case BI_RLE4 : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_RLE4" ) ; break ; } case BI_RLE8 : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_RLE8" ) ; break ; } case BI_BITFIELDS : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_BITFIELDS" ) ; break ; } case BI_PNG : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_PNG" ) ; break ; } case BI_JPEG : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_JPEG" ) ; break ; } default : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>UNKNOWN<S2SV_blank>(%u)" , bmp_info . compression ) ; } } ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "<S2SV_blank><S2SV_blank>Number<S2SV_blank>of<S2SV_blank>colors:<S2SV_blank>%u" , bmp_info . number_colors ) ; } bmp_info . red_mask = ReadBlobLSBLong ( image ) ; bmp_info . green_mask = ReadBlobLSBLong ( image ) ; bmp_info . blue_mask = ReadBlobLSBLong ( image ) ; if ( bmp_info . size > 40 ) { double gamma ; bmp_info . alpha_mask = ReadBlobLSBLong ( image ) ; bmp_info . colorspace = ReadBlobLSBSignedLong ( image ) ; # define BMP_DENOM ( ( double ) 0x40000000 ) bmp_info . red_primary . x = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . red_primary . y = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . red_primary . z = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . green_primary . x = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . green_primary . y = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . green_primary . z = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . blue_primary . x = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . blue_primary . y = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . blue_primary . z = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; gamma = bmp_info . red_primary . x + bmp_info . red_primary . y + bmp_info . red_primary . z ; gamma = PerceptibleReciprocal ( gamma ) ; bmp_info . red_primary . x *= gamma ; bmp_info . red_primary . y *= gamma ; image -> chromaticity . red_primary . x = bmp_info . red_primary . x ; image -> chromaticity . red_primary . y = bmp_info . red_primary . y ; gamma = bmp_info . green_primary . x + bmp_info . green_primary . y + bmp_info . green_primary . z ; gamma = PerceptibleReciprocal ( gamma ) ; bmp_info . green_primary . x *= gamma ; bmp_info . green_primary . y *= gamma ; image -> chromaticity . green_primary . x = bmp_info . green_primary . x ; image -> chromaticity . green_primary . y = bmp_info . green_primary . y ; gamma = bmp_info . blue_primary . x + bmp_info . blue_primary . y + bmp_info . blue_primary . z ; gamma = PerceptibleReciprocal ( gamma ) ; bmp_info . blue_primary . x *= gamma ; bmp_info . blue_primary . y *= gamma ; image -> chromaticity . blue_primary . x = bmp_info . blue_primary . x ; image -> chromaticity . blue_primary . y = bmp_info . blue_primary . y ; bmp_info . gamma_scale . x = ( double ) ReadBlobLSBLong ( image ) / 0x10000 ; bmp_info . gamma_scale . y = ( double ) ReadBlobLSBLong ( image ) / 0x10000 ; bmp_info . gamma_scale . z = ( double ) ReadBlobLSBLong ( image ) / 0x10000 ; image -> gamma = ( bmp_info . gamma_scale . x + bmp_info . gamma_scale . y + bmp_info . gamma_scale . z ) / 3.0 ; } else ( void ) CopyMagickString ( image -> magick , "BMP3" , MagickPathExtent ) ; if ( bmp_info . size > 108 ) { size_t intent ; intent = ReadBlobLSBLong ( image ) ; switch ( ( int ) intent ) { case LCS_GM_BUSINESS : { image -> rendering_intent = SaturationIntent ; break ; } case LCS_GM_GRAPHICS : { image -> rendering_intent = RelativeIntent ; break ; } case LCS_GM_IMAGES : { image -> rendering_intent = PerceptualIntent ; break ; } case LCS_GM_ABS_COLORIMETRIC : { image -> rendering_intent = AbsoluteIntent ; break ; } } profile_data = ( MagickOffsetType ) ReadBlobLSBLong ( image ) ; profile_size = ( MagickOffsetType ) ReadBlobLSBLong ( image ) ; ( void ) ReadBlobLSBLong ( image ) ; } } if ( ( MagickSizeType ) bmp_info . file_size > GetBlobSize ( image ) ) ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , CorruptImageError , "LengthAndFilesizeDoNotMatch" , "`%s\'" , image -> filename ) ; else if ( ( MagickSizeType ) bmp_info . file_size < GetBlobSize ( image ) ) ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , CorruptImageWarning , "LengthAndFilesizeDoNotMatch" , "`%s\'" , image -> filename ) ; if ( bmp_info . width <= 0 ) ThrowReaderException ( CorruptImageError , "NegativeOrZeroImageSize" ) ; if ( bmp_info . height == 0 ) ThrowReaderException ( CorruptImageError , "NegativeOrZeroImageSize" ) ; if ( bmp_info . planes != 1 ) ThrowReaderException ( CorruptImageError , "StaticPlanesValueNotEqualToOne" ) ; if ( ( bmp_info . bits_per_pixel != 1 ) && ( bmp_info . bits_per_pixel != 4 ) && ( bmp_info . bits_per_pixel != 8 ) && ( bmp_info . bits_per_pixel != 16 ) && ( bmp_info . bits_per_pixel != 24 ) && ( bmp_info . bits_per_pixel != 32 ) ) ThrowReaderException ( CorruptImageError , "UnsupportedBitsPerPixel" ) ; if ( bmp_info . bits_per_pixel < 16 && bmp_info . number_colors > ( 1U << bmp_info . bits_per_pixel ) ) ThrowReaderException ( CorruptImageError , "UnrecognizedNumberOfColors" ) ; if ( ( bmp_info . compression == 1 ) && ( bmp_info . bits_per_pixel != 8 ) ) ThrowReaderException ( CorruptImageError , "UnsupportedBitsPerPixel" ) ; if ( ( bmp_info . compression == 2 ) && ( bmp_info . bits_per_pixel != 4 ) ) ThrowReaderException ( CorruptImageError , "UnsupportedBitsPerPixel" ) ; if ( ( bmp_info . compression == 3 ) && ( bmp_info . bits_per_pixel < 16 ) ) ThrowReaderException ( CorruptImageError , "UnsupportedBitsPerPixel" ) ; switch ( bmp_info . compression ) { case BI_RGB : image -> compression = NoCompression ; break ; case BI_RLE8 : case BI_RLE4 : image -> compression = RLECompression ; break ; case BI_BITFIELDS : break ; case BI_JPEG : ThrowReaderException ( CoderError , "JPEGCompressNotSupported" ) ; case BI_PNG : ThrowReaderException ( CoderError , "PNGCompressNotSupported" ) ; default : ThrowReaderException ( CorruptImageError , "UnrecognizedImageCompression" ) ; } image -> columns = ( size_t ) MagickAbsoluteValue ( bmp_info . width ) ; image -> rows = ( size_t ) MagickAbsoluteValue ( bmp_info . height ) ; image -> depth = bmp_info . bits_per_pixel <= 8 ? bmp_info . bits_per_pixel : 8 ; image -> alpha_trait = ( ( bmp_info . alpha_mask != 0 ) && ( bmp_info . compression == BI_BITFIELDS ) ) ? BlendPixelTrait : UndefinedPixelTrait ; if ( bmp_info . bits_per_pixel < 16 ) { size_t one ; image -> storage_class = PseudoClass ; image -> colors = bmp_info . number_colors ; one = 1 ; if ( image -> colors == 0 ) image -> colors = one << bmp_info . bits_per_pixel ; } image -> resolution . x = ( double ) bmp_info . x_pixels / 100.0 ; image -> resolution . y = ( double ) bmp_info . y_pixels / 100.0 ; image -> units = PixelsPerCentimeterResolution ; if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; if ( image -> storage_class == PseudoClass ) { unsigned char * bmp_colormap ; size_t packet_size ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "<S2SV_blank><S2SV_blank>Reading<S2SV_blank>colormap<S2SV_blank>of<S2SV_blank>%.20g<S2SV_blank>colors" , ( double ) image -> colors ) ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; bmp_colormap = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) image -> colors , 4 * sizeof ( * bmp_colormap ) ) ; if ( bmp_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; if ( ( bmp_info . size == 12 ) || ( bmp_info . size == 64 ) ) packet_size = 3 ; else packet_size = 4 ; offset = SeekBlob ( image , start_position + 14 + bmp_info . size , SEEK_SET ) ; if ( offset < 0 ) { bmp_colormap = ( unsigned char * ) RelinquishMagickMemory ( bmp_colormap ) ; ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; } count = ReadBlob ( image , packet_size * image -> colors , bmp_colormap ) ; if ( count != ( ssize_t ) ( packet_size * image -> colors ) ) { bmp_colormap = ( unsigned char * ) RelinquishMagickMemory ( bmp_colormap ) ; ThrowReaderException ( CorruptImageError , "InsufficientImageDataInFile" ) ; } p = bmp_colormap ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( * p ++ ) ; image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( * p ++ ) ; image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( * p ++ ) ; if ( packet_size == 4 ) p ++ ; } bmp_colormap = ( unsigned char * ) RelinquishMagickMemory ( bmp_colormap ) ; } if ( bmp_info . offset_bits == offset_bits ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; offset_bits = bmp_info . offset_bits ; offset = SeekBlob ( image , start_position + bmp_info . offset_bits , SEEK_SET ) ; if ( offset < 0 ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; if ( bmp_info . compression == BI_RLE4 ) bmp_info . bits_per_pixel <<= 1 ; bytes_per_line = 4 * ( ( image -> columns * bmp_info . bits_per_pixel + 31 ) / 32 ) ; length = ( size_t ) bytes_per_line * image -> rows ; if ( ( MagickSizeType ) ( length / 256 ) > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , "InsufficientImageDataInFile" ) ; if ( ( bmp_info . compression == BI_RGB ) || ( bmp_info . compression == BI_BITFIELDS ) ) { pixel_info = AcquireVirtualMemory ( image -> rows , MagickMax ( bytes_per_line , image -> columns + 256UL ) * sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "<S2SV_blank><S2SV_blank>Reading<S2SV_blank>pixels<S2SV_blank>(%.20g<S2SV_blank>bytes)" , ( double ) length ) ; count = ReadBlob ( image , length , pixels ) ; if ( count != ( ssize_t ) length ) { pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , "InsufficientImageDataInFile" ) ; } } else { pixel_info = AcquireVirtualMemory ( image -> rows , MagickMax ( bytes_per_line , image -> columns + 256UL ) * sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; status = DecodeImage ( image , bmp_info . compression , pixels , image -> columns * image -> rows ) ; if ( status == MagickFalse ) { pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , "UnableToRunlengthDecodeImage" ) ; } } if ( bmp_info . compression == BI_RGB ) { if ( ( image -> alpha_trait == UndefinedPixelTrait ) && ( bmp_info . size == 40 ) && ( bmp_info . bits_per_pixel == 32 ) ) { bytes_per_line = 4 * ( image -> columns ) ; for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( * ( p + 3 ) != 0 ) { image -> alpha_trait = BlendPixelTrait ; y = - 1 ; break ; } p += 4 ; } } } bmp_info . alpha_mask = image -> alpha_trait != UndefinedPixelTrait ? 0xff000000U : 0U ; bmp_info . red_mask = 0x00ff0000U ; bmp_info . green_mask = 0x0000ff00U ; bmp_info . blue_mask = 0x000000ffU ; if ( bmp_info . bits_per_pixel == 16 ) { bmp_info . red_mask = 0x00007c00U ; bmp_info . green_mask = 0x000003e0U ; bmp_info . blue_mask = 0x0000001fU ; } } ( void ) memset ( & shift , 0 , sizeof ( shift ) ) ; ( void ) memset ( & quantum_bits , 0 , sizeof ( quantum_bits ) ) ; if ( ( bmp_info . bits_per_pixel == 16 ) || ( bmp_info . bits_per_pixel == 32 ) ) { register unsigned int sample ; if ( bmp_info . red_mask != 0 ) while ( ( ( bmp_info . red_mask << shift . red ) & 0x80000000UL ) == 0 ) { shift . red ++ ; if ( shift . red >= 32U ) break ; } if ( bmp_info . green_mask != 0 ) while ( ( ( bmp_info . green_mask << shift . green ) & 0x80000000UL ) == 0 ) { shift . green ++ ; if ( shift . green >= 32U ) break ; } if ( bmp_info . blue_mask != 0 ) while ( ( ( bmp_info . blue_mask << shift . blue ) & 0x80000000UL ) == 0 ) { shift . blue ++ ; if ( shift . blue >= 32U ) break ; } if ( bmp_info . alpha_mask != 0 ) while ( ( ( bmp_info . alpha_mask << shift . alpha ) & 0x80000000UL ) == 0 ) { shift . alpha ++ ; if ( shift . alpha >= 32U ) break ; } sample = shift . red ; while ( ( ( bmp_info . red_mask << sample ) & 0x80000000UL ) != 0 ) { sample ++ ; if ( sample >= 32U ) break ; } quantum_bits . red = ( MagickRealType ) ( sample - shift . red ) ; sample = shift . green ; while ( ( ( bmp_info . green_mask << sample ) & 0x80000000UL ) != 0 ) { sample ++ ; if ( sample >= 32U ) break ; } quantum_bits . green = ( MagickRealType ) ( sample - shift . green ) ; sample = shift . blue ; while ( ( ( bmp_info . blue_mask << sample ) & 0x80000000UL ) != 0 ) { sample ++ ; if ( sample >= 32U ) break ; } quantum_bits . blue = ( MagickRealType ) ( sample - shift . blue ) ; sample = shift . alpha ; while ( ( ( bmp_info . alpha_mask << sample ) & 0x80000000UL ) != 0 ) { sample ++ ; if ( sample >= 32U ) break ; } quantum_bits . alpha = ( MagickRealType ) ( sample - shift . alpha ) ; } switch ( bmp_info . bits_per_pixel ) { case 1 : { for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) { for ( bit = 0 ; bit < 8 ; bit ++ ) { index = ( Quantum ) ( ( ( * p ) & ( 0x80 >> bit ) ) != 0 ? 0x01 : 0x00 ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( image -> columns % 8 ) != 0 ) { for ( bit = 0 ; bit < ( image -> columns % 8 ) ; bit ++ ) { index = ( Quantum ) ( ( ( * p ) & ( 0x80 >> bit ) ) != 0 ? 0x01 : 0x00 ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image , exception ) ; break ; } case 4 : { for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 1 ) ; x += 2 ) { ValidateColormapValue ( image , ( ssize_t ) ( ( * p >> 4 ) & 0x0f ) , & index , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; ValidateColormapValue ( image , ( ssize_t ) ( * p & 0x0f ) , & index , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; p ++ ; } if ( ( image -> columns % 2 ) != 0 ) { ValidateColormapValue ( image , ( ssize_t ) ( ( * p >> 4 ) & 0xf ) , & index , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; p ++ ; x ++ ; } if ( x < ( ssize_t ) image -> columns ) break ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image , exception ) ; break ; } case 8 : { if ( ( bmp_info . compression == BI_RLE8 ) || ( bmp_info . compression == BI_RLE4 ) ) bytes_per_line = image -> columns ; for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = ( ssize_t ) image -> columns ; x != 0 ; -- x ) { ValidateColormapValue ( image , ( ssize_t ) * p ++ , & index , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; offset = ( MagickOffsetType ) ( image -> rows - y - 1 ) ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image , exception ) ; break ; } case 16 : { unsigned int alpha , pixel ; if ( ( bmp_info . compression != BI_RGB ) && ( bmp_info . compression != BI_BITFIELDS ) ) { pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , "UnrecognizedImageCompression" ) ; } bytes_per_line = 2 * ( image -> columns + image -> columns % 2 ) ; image -> storage_class = DirectClass ; for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { pixel = ( unsigned int ) ( * p ++ ) ; pixel |= ( * p ++ ) << 8 ; red = ( ( pixel & bmp_info . red_mask ) << shift . red ) >> 16 ; if ( quantum_bits . red == 5 ) red |= ( ( red & 0xe000 ) >> 5 ) ; if ( quantum_bits . red <= 8 ) red |= ( ( red & 0xff00 ) >> 8 ) ; green = ( ( pixel & bmp_info . green_mask ) << shift . green ) >> 16 ; if ( quantum_bits . green == 5 ) green |= ( ( green & 0xe000 ) >> 5 ) ; if ( quantum_bits . green == 6 ) green |= ( ( green & 0xc000 ) >> 6 ) ; if ( quantum_bits . green <= 8 ) green |= ( ( green & 0xff00 ) >> 8 ) ; blue = ( ( pixel & bmp_info . blue_mask ) << shift . blue ) >> 16 ; if ( quantum_bits . blue == 5 ) blue |= ( ( blue & 0xe000 ) >> 5 ) ; if ( quantum_bits . blue <= 8 ) blue |= ( ( blue & 0xff00 ) >> 8 ) ; SetPixelRed ( image , ScaleShortToQuantum ( ( unsigned short ) red ) , q ) ; SetPixelGreen ( image , ScaleShortToQuantum ( ( unsigned short ) green ) , q ) ; SetPixelBlue ( image , ScaleShortToQuantum ( ( unsigned short ) blue ) , q ) ; SetPixelAlpha ( image , OpaqueAlpha , q ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) { alpha = ( ( pixel & bmp_info . alpha_mask ) << shift . alpha ) >> 16 ; if ( quantum_bits . alpha <= 8 ) alpha |= ( ( alpha & 0xff00 ) >> 8 ) ; SetPixelAlpha ( image , ScaleShortToQuantum ( ( unsigned short ) alpha ) , q ) ; } q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; offset = ( MagickOffsetType ) ( image -> rows - y - 1 ) ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } break ; } case 24 : { bytes_per_line = 4 * ( ( image -> columns * 24 + 31 ) / 32 ) ; for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelAlpha ( image , OpaqueAlpha , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; offset = ( MagickOffsetType ) ( image -> rows - y - 1 ) ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } break ; } case 32 : { if ( ( bmp_info . compression != BI_RGB ) && ( bmp_info . compression != BI_BITFIELDS ) ) { pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , "UnrecognizedImageCompression" ) ; } bytes_per_line = 4 * ( image -> columns ) ; for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { unsigned int alpha , pixel ; p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { pixel = ( unsigned int ) ( * p ++ ) ; pixel |= ( ( unsigned int ) * p ++ << 8 ) ; pixel |= ( ( unsigned int ) * p ++ << 16 ) ; pixel |= ( ( unsigned int ) * p ++ << 24 ) ; red = ( ( pixel & bmp_info . red_mask ) << shift . red ) >> 16 ; if ( quantum_bits . red == 8 ) red |= ( red >> 8 ) ; green = ( ( pixel & bmp_info . green_mask ) << shift . green ) >> 16 ; if ( quantum_bits . green == 8 ) green |= ( green >> 8 ) ; blue = ( ( pixel & bmp_info . blue_mask ) << shift . blue ) >> 16 ; if ( quantum_bits . blue == 8 ) blue |= ( blue >> 8 ) ; SetPixelRed ( image , ScaleShortToQuantum ( ( unsigned short ) red ) , q ) ; SetPixelGreen ( image , ScaleShortToQuantum ( ( unsigned short ) green ) , q ) ; SetPixelBlue ( image , ScaleShortToQuantum ( ( unsigned short ) blue ) , q ) ; SetPixelAlpha ( image , OpaqueAlpha , q ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) { alpha = ( ( pixel & bmp_info . alpha_mask ) << shift . alpha ) >> 16 ; if ( quantum_bits . alpha == 8 ) alpha |= ( alpha >> 8 ) ; SetPixelAlpha ( image , ScaleShortToQuantum ( ( unsigned short ) alpha ) , q ) ; } q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; offset = ( MagickOffsetType ) ( image -> rows - y - 1 ) ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } break ; } default : { pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; } } pixel_info = RelinquishVirtualMemory ( pixel_info ) ; if ( y > 0 ) break ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , "UnexpectedEndOfFile" , image -> filename ) ; break ; } if ( bmp_info . height < 0 ) { Image * flipped_image ; flipped_image = FlipImage ( image , exception ) ; if ( flipped_image != ( Image * ) NULL ) { DuplicateBlob ( flipped_image , image ) ; ReplaceImageInList ( & image , flipped_image ) ; image = flipped_image ; } } if ( ( bmp_info . colorspace == 0x4D424544L ) && ( profile_data > 0 ) && ( profile_size > 0 ) ) { StringInfo * profile ; unsigned char * datum ; offset = start_position + 14 + profile_data ; if ( ( offset < TellBlob ( image ) ) || ( SeekBlob ( image , offset , SEEK_SET ) != offset ) || ( GetBlobSize ( image ) < ( MagickSizeType ) ( offset + profile_size ) ) ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; profile = AcquireStringInfo ( ( size_t ) profile_size ) ; if ( profile == ( StringInfo * ) NULL ) ThrowReaderException ( CorruptImageError , "MemoryAllocationFailed" ) ; datum = GetStringInfoDatum ( profile ) ; if ( ReadBlob ( image , ( size_t ) profile_size , datum ) == ( ssize_t ) profile_size ) { MagickOffsetType profile_size_orig ; profile_size_orig = ( MagickOffsetType ) datum [ 0 ] << 24 ; profile_size_orig |= ( MagickOffsetType ) datum [ 1 ] << 16 ; profile_size_orig |= ( MagickOffsetType ) datum [ 2 ] << 8 ; profile_size_orig |= ( MagickOffsetType ) datum [ 3 ] ; if ( profile_size_orig < profile_size ) SetStringInfoLength ( profile , ( size_t ) profile_size_orig ) ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "Profile:<S2SV_blank>ICC,<S2SV_blank>%u<S2SV_blank>bytes" , ( unsigned int ) profile_size_orig ) ; ( void ) SetImageProfile ( image , "icc" , profile , exception ) ; } profile = DestroyStringInfo ( profile ) ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; offset = ( MagickOffsetType ) bmp_info . ba_offset ; if ( offset != 0 ) if ( ( offset < TellBlob ( image ) ) || ( SeekBlob ( image , offset , SEEK_SET ) != offset ) ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; * magick = '\\0' ; count = ReadBlob ( image , 2 , magick ) ; if ( ( count == 2 ) && ( IsBMP ( magick , 2 ) != MagickFalse ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { status = MagickFalse ; <S2SV_StartBug> return ( ( Image * ) NULL ) ; <S2SV_EndBug> } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( IsBMP ( magick , 2 ) != MagickFalse ) ; ( void ) CloseBlob ( image ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; return ( GetFirstImageInList ( image ) ) ; }
CWE-399 static Image * ReadVIFFImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define VFF_CM_genericRGB 15 # define VFF_CM_ntscRGB 1 # define VFF_CM_NONE 0 # define VFF_DEP_DECORDER 0x4 # define VFF_DEP_NSORDER 0x8 # define VFF_DES_RAW 0 # define VFF_LOC_IMPLICIT 1 # define VFF_MAPTYP_NONE 0 # define VFF_MAPTYP_1_BYTE 1 # define VFF_MAPTYP_2_BYTE 2 # define VFF_MAPTYP_4_BYTE 4 # define VFF_MAPTYP_FLOAT 5 # define VFF_MAPTYP_DOUBLE 7 # define VFF_MS_NONE 0 # define VFF_MS_ONEPERBAND 1 # define VFF_MS_SHARED 3 # define VFF_TYP_BIT 0 # define VFF_TYP_1_BYTE 1 # define VFF_TYP_2_BYTE 2 # define VFF_TYP_4_BYTE 4 # define VFF_TYP_FLOAT 5 # define VFF_TYP_DOUBLE 9 typedef struct _ViffInfo { unsigned char identifier , file_type , release , version , machine_dependency , reserve [ 3 ] ; char comment [ 512 ] ; unsigned int rows , columns , subrows ; int x_offset , y_offset ; float x_bits_per_pixel , y_bits_per_pixel ; unsigned int location_type , location_dimension , number_of_images , number_data_bands , data_storage_type , data_encode_scheme , map_scheme , map_storage_type , map_rows , map_columns , map_subrows , map_enable , maps_per_cycle , color_space_model ; } ViffInfo ; double min_value , scale_factor , value ; Image * image ; int bit ; MagickBooleanType status ; MagickSizeType number_pixels ; register ssize_t x ; register Quantum * q ; register ssize_t i ; register unsigned char * p ; size_t bytes_per_pixel , max_packets , quantum ; ssize_t count , y ; unsigned char * pixels ; unsigned long lsb_first ; ViffInfo viff_info ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } count = ReadBlob ( image , 1 , & viff_info . identifier ) ; do { if ( ( count != 1 ) || ( ( unsigned char ) viff_info . identifier != 0xab ) ) ThrowReaderException ( CorruptImageError , "NotAVIFFImage" ) ; ( void ) ReadBlob ( image , sizeof ( viff_info . file_type ) , & viff_info . file_type ) ; ( void ) ReadBlob ( image , sizeof ( viff_info . release ) , & viff_info . release ) ; ( void ) ReadBlob ( image , sizeof ( viff_info . version ) , & viff_info . version ) ; ( void ) ReadBlob ( image , sizeof ( viff_info . machine_dependency ) , & viff_info . machine_dependency ) ; ( void ) ReadBlob ( image , sizeof ( viff_info . reserve ) , viff_info . reserve ) ; count = ReadBlob ( image , 512 , ( unsigned char * ) viff_info . comment ) ; if ( count != 512 ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; viff_info . comment [ 511 ] = '\\0' ; if ( strlen ( viff_info . comment ) > 4 ) ( void ) SetImageProperty ( image , "comment" , viff_info . comment , exception ) ; if ( ( viff_info . machine_dependency == VFF_DEP_DECORDER ) || ( viff_info . machine_dependency == VFF_DEP_NSORDER ) ) image -> endian = LSBEndian ; else image -> endian = MSBEndian ; viff_info . rows = ReadBlobLong ( image ) ; viff_info . columns = ReadBlobLong ( image ) ; viff_info . subrows = ReadBlobLong ( image ) ; viff_info . x_offset = ReadBlobSignedLong ( image ) ; viff_info . y_offset = ReadBlobSignedLong ( image ) ; viff_info . x_bits_per_pixel = ( float ) ReadBlobLong ( image ) ; viff_info . y_bits_per_pixel = ( float ) ReadBlobLong ( image ) ; viff_info . location_type = ReadBlobLong ( image ) ; viff_info . location_dimension = ReadBlobLong ( image ) ; viff_info . number_of_images = ReadBlobLong ( image ) ; viff_info . number_data_bands = ReadBlobLong ( image ) ; viff_info . data_storage_type = ReadBlobLong ( image ) ; viff_info . data_encode_scheme = ReadBlobLong ( image ) ; viff_info . map_scheme = ReadBlobLong ( image ) ; viff_info . map_storage_type = ReadBlobLong ( image ) ; viff_info . map_rows = ReadBlobLong ( image ) ; viff_info . map_columns = ReadBlobLong ( image ) ; viff_info . map_subrows = ReadBlobLong ( image ) ; viff_info . map_enable = ReadBlobLong ( image ) ; viff_info . maps_per_cycle = ReadBlobLong ( image ) ; viff_info . color_space_model = ReadBlobLong ( image ) ; for ( i = 0 ; i < 420 ; i ++ ) ( void ) ReadBlobByte ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowReaderException ( CorruptImageError , "UnexpectedEndOfFile" ) ; number_pixels = ( MagickSizeType ) viff_info . columns * viff_info . rows ; if ( number_pixels > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , "InsufficientImageDataInFile" ) ; if ( number_pixels != ( size_t ) number_pixels ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; if ( number_pixels == 0 ) ThrowReaderException ( CoderError , "ImageColumnOrRowSizeIsNotSupported" ) ; image -> columns = viff_info . rows ; image -> rows = viff_info . columns ; image -> depth = viff_info . x_bits_per_pixel <= 8 ? 8UL : MAGICKCORE_QUANTUM_DEPTH ; image -> alpha_trait = viff_info . number_data_bands == 4 ? BlendPixelTrait : UndefinedPixelTrait ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; ( void ) SetImageBackgroundColor ( image , exception ) ; if ( ( viff_info . number_data_bands < 1 ) || ( viff_info . number_data_bands > 4 ) ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; if ( ( viff_info . data_storage_type != VFF_TYP_BIT ) && ( viff_info . data_storage_type != VFF_TYP_1_BYTE ) && ( viff_info . data_storage_type != VFF_TYP_2_BYTE ) && ( viff_info . data_storage_type != VFF_TYP_4_BYTE ) && ( viff_info . data_storage_type != VFF_TYP_FLOAT ) && ( viff_info . data_storage_type != VFF_TYP_DOUBLE ) ) ThrowReaderException ( CoderError , "DataStorageTypeIsNotSupported" ) ; if ( viff_info . data_encode_scheme != VFF_DES_RAW ) ThrowReaderException ( CoderError , "DataEncodingSchemeIsNotSupported" ) ; if ( ( viff_info . map_storage_type != VFF_MAPTYP_NONE ) && ( viff_info . map_storage_type != VFF_MAPTYP_1_BYTE ) && ( viff_info . map_storage_type != VFF_MAPTYP_2_BYTE ) && ( viff_info . map_storage_type != VFF_MAPTYP_4_BYTE ) && ( viff_info . map_storage_type != VFF_MAPTYP_FLOAT ) && ( viff_info . map_storage_type != VFF_MAPTYP_DOUBLE ) ) ThrowReaderException ( CoderError , "MapStorageTypeIsNotSupported" ) ; if ( ( viff_info . color_space_model != VFF_CM_NONE ) && ( viff_info . color_space_model != VFF_CM_ntscRGB ) && ( viff_info . color_space_model != VFF_CM_genericRGB ) ) ThrowReaderException ( CoderError , "ColorspaceModelIsNotSupported" ) ; if ( viff_info . location_type != VFF_LOC_IMPLICIT ) ThrowReaderException ( CoderError , "LocationTypeIsNotSupported" ) ; if ( viff_info . number_of_images != 1 ) ThrowReaderException ( CoderError , "NumberOfImagesIsNotSupported" ) ; if ( viff_info . map_rows == 0 ) viff_info . map_scheme = VFF_MS_NONE ; switch ( ( int ) viff_info . map_scheme ) { case VFF_MS_NONE : { if ( viff_info . number_data_bands < 3 ) { if ( viff_info . data_storage_type == VFF_TYP_BIT ) image -> colors = 2 ; else if ( viff_info . data_storage_type == VFF_MAPTYP_1_BYTE ) image -> colors = 256UL ; else image -> colors = image -> depth <= 8 ? 256UL : 65536UL ; status = AcquireImageColormap ( image , image -> colors , exception ) ; if ( status == MagickFalse ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; } break ; } case VFF_MS_ONEPERBAND : case VFF_MS_SHARED : { unsigned char * viff_colormap ; switch ( ( int ) viff_info . map_storage_type ) { case VFF_MAPTYP_1_BYTE : bytes_per_pixel = 1 ; break ; case VFF_MAPTYP_2_BYTE : bytes_per_pixel = 2 ; break ; case VFF_MAPTYP_4_BYTE : bytes_per_pixel = 4 ; break ; case VFF_MAPTYP_FLOAT : bytes_per_pixel = 4 ; break ; case VFF_MAPTYP_DOUBLE : bytes_per_pixel = 8 ; break ; default : bytes_per_pixel = 1 ; break ; } image -> colors = viff_info . map_columns ; if ( ( MagickSizeType ) ( viff_info . map_rows * image -> colors ) > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , "InsufficientImageDataInFile" ) ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; if ( ( MagickSizeType ) viff_info . map_rows > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , "InsufficientImageDataInFile" ) ; if ( ( MagickSizeType ) viff_info . map_rows > ( viff_info . map_rows * bytes_per_pixel * sizeof ( * viff_colormap ) ) ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; viff_colormap = ( unsigned char * ) AcquireQuantumMemory ( image -> colors , viff_info . map_rows * bytes_per_pixel * sizeof ( * viff_colormap ) ) ; if ( viff_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; count = ReadBlob ( image , bytes_per_pixel * image -> colors * viff_info . map_rows , viff_colormap ) ; lsb_first = 1 ; if ( * ( char * ) & lsb_first && ( ( viff_info . machine_dependency != VFF_DEP_DECORDER ) && ( viff_info . machine_dependency != VFF_DEP_NSORDER ) ) ) switch ( ( int ) viff_info . map_storage_type ) { case VFF_MAPTYP_2_BYTE : { MSBOrderShort ( viff_colormap , ( bytes_per_pixel * image -> colors * viff_info . map_rows ) ) ; break ; } case VFF_MAPTYP_4_BYTE : case VFF_MAPTYP_FLOAT : { MSBOrderLong ( viff_colormap , ( bytes_per_pixel * image -> colors * viff_info . map_rows ) ) ; break ; } default : break ; } for ( i = 0 ; i < ( ssize_t ) ( viff_info . map_rows * image -> colors ) ; i ++ ) { switch ( ( int ) viff_info . map_storage_type ) { case VFF_MAPTYP_2_BYTE : value = 1.0 * ( ( short * ) viff_colormap ) [ i ] ; break ; case VFF_MAPTYP_4_BYTE : value = 1.0 * ( ( int * ) viff_colormap ) [ i ] ; break ; case VFF_MAPTYP_FLOAT : value = ( ( float * ) viff_colormap ) [ i ] ; break ; case VFF_MAPTYP_DOUBLE : value = ( ( double * ) viff_colormap ) [ i ] ; break ; default : value = 1.0 * viff_colormap [ i ] ; break ; } if ( i < ( ssize_t ) image -> colors ) { image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) value ) ; image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) value ) ; image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) value ) ; } else if ( i < ( ssize_t ) ( 2 * image -> colors ) ) image -> colormap [ i % image -> colors ] . green = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) value ) ; else if ( i < ( ssize_t ) ( 3 * image -> colors ) ) image -> colormap [ i % image -> colors ] . blue = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) value ) ; } viff_colormap = ( unsigned char * ) RelinquishMagickMemory ( viff_colormap ) ; break ; } default : ThrowReaderException ( CoderError , "ColormapTypeNotSupported" ) ; } if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; if ( viff_info . data_storage_type == VFF_TYP_BIT ) { image -> colors = 2 ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; image -> colorspace = GRAYColorspace ; } switch ( ( int ) viff_info . data_storage_type ) { case VFF_TYP_2_BYTE : bytes_per_pixel = 2 ; break ; case VFF_TYP_4_BYTE : bytes_per_pixel = 4 ; break ; case VFF_TYP_FLOAT : bytes_per_pixel = 4 ; break ; case VFF_TYP_DOUBLE : bytes_per_pixel = 8 ; break ; default : bytes_per_pixel = 1 ; break ; } if ( viff_info . data_storage_type == VFF_TYP_BIT ) { if ( HeapOverflowSanityCheck ( ( image -> columns + 7UL ) >> 3UL , image -> rows ) != MagickFalse ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; max_packets = ( ( image -> columns + 7UL ) >> 3UL ) * image -> rows ; } else { if ( HeapOverflowSanityCheck ( ( size_t ) number_pixels , viff_info . number_data_bands ) != MagickFalse ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; max_packets = ( size_t ) ( number_pixels * viff_info . number_data_bands ) ; } if ( ( MagickSizeType ) ( bytes_per_pixel * max_packets ) > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; pixels = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) MagickMax ( number_pixels , max_packets ) , bytes_per_pixel * sizeof ( * pixels ) ) ; if ( pixels == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; ( void ) memset ( pixels , 0 , MagickMax ( number_pixels , max_packets ) * bytes_per_pixel * sizeof ( * pixels ) ) ; count = ReadBlob ( image , bytes_per_pixel * max_packets , pixels ) ; lsb_first = 1 ; if ( * ( char * ) & lsb_first && ( ( viff_info . machine_dependency != VFF_DEP_DECORDER ) && ( viff_info . machine_dependency != VFF_DEP_NSORDER ) ) ) switch ( ( int ) viff_info . data_storage_type ) { case VFF_TYP_2_BYTE : { MSBOrderShort ( pixels , bytes_per_pixel * max_packets ) ; break ; } case VFF_TYP_4_BYTE : case VFF_TYP_FLOAT : { MSBOrderLong ( pixels , bytes_per_pixel * max_packets ) ; break ; } default : break ; } min_value = 0.0 ; scale_factor = 1.0 ; if ( ( viff_info . data_storage_type != VFF_TYP_1_BYTE ) && ( viff_info . map_scheme == VFF_MS_NONE ) ) { double max_value ; switch ( ( int ) viff_info . data_storage_type ) { case VFF_TYP_2_BYTE : value = 1.0 * ( ( short * ) pixels ) [ 0 ] ; break ; case VFF_TYP_4_BYTE : value = 1.0 * ( ( int * ) pixels ) [ 0 ] ; break ; case VFF_TYP_FLOAT : value = ( ( float * ) pixels ) [ 0 ] ; break ; case VFF_TYP_DOUBLE : value = ( ( double * ) pixels ) [ 0 ] ; break ; default : value = 1.0 * pixels [ 0 ] ; break ; } max_value = value ; min_value = value ; for ( i = 0 ; i < ( ssize_t ) max_packets ; i ++ ) { switch ( ( int ) viff_info . data_storage_type ) { case VFF_TYP_2_BYTE : value = 1.0 * ( ( short * ) pixels ) [ i ] ; break ; case VFF_TYP_4_BYTE : value = 1.0 * ( ( int * ) pixels ) [ i ] ; break ; case VFF_TYP_FLOAT : value = ( ( float * ) pixels ) [ i ] ; break ; case VFF_TYP_DOUBLE : value = ( ( double * ) pixels ) [ i ] ; break ; default : value = 1.0 * pixels [ i ] ; break ; } if ( value > max_value ) max_value = value ; else if ( value < min_value ) min_value = value ; } if ( ( min_value == 0 ) && ( max_value == 0 ) ) scale_factor = 0 ; else if ( min_value == max_value ) { scale_factor = ( double ) QuantumRange / min_value ; min_value = 0 ; } else scale_factor = ( double ) QuantumRange / ( max_value - min_value ) ; } p = ( unsigned char * ) pixels ; for ( i = 0 ; i < ( ssize_t ) max_packets ; i ++ ) { switch ( ( int ) viff_info . data_storage_type ) { case VFF_TYP_2_BYTE : value = 1.0 * ( ( short * ) pixels ) [ i ] ; break ; case VFF_TYP_4_BYTE : value = 1.0 * ( ( int * ) pixels ) [ i ] ; break ; case VFF_TYP_FLOAT : value = ( ( float * ) pixels ) [ i ] ; break ; case VFF_TYP_DOUBLE : value = ( ( double * ) pixels ) [ i ] ; break ; default : value = 1.0 * pixels [ i ] ; break ; } if ( viff_info . map_scheme == VFF_MS_NONE ) { value = ( value - min_value ) * scale_factor ; if ( value > QuantumRange ) value = QuantumRange ; else if ( value < 0 ) value = 0 ; } * p = ( unsigned char ) ( ( Quantum ) value ) ; p ++ ; } p = ( unsigned char * ) pixels ; if ( viff_info . data_storage_type == VFF_TYP_BIT ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) ( image -> columns - 7 ) ; x += 8 ) { for ( bit = 0 ; bit < 8 ; bit ++ ) { quantum = ( size_t ) ( ( * p ) & ( 0x01 << bit ) ? 0 : 1 ) ; SetPixelRed ( image , quantum == 0 ? 0 : QuantumRange , q ) ; SetPixelGreen ( image , quantum == 0 ? 0 : QuantumRange , q ) ; SetPixelBlue ( image , quantum == 0 ? 0 : QuantumRange , q ) ; if ( image -> storage_class == PseudoClass ) SetPixelIndex ( image , ( Quantum ) quantum , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( image -> columns % 8 ) != 0 ) { for ( bit = 0 ; bit < ( int ) ( image -> columns % 8 ) ; bit ++ ) { quantum = ( size_t ) ( ( * p ) & ( 0x01 << bit ) ? 0 : 1 ) ; SetPixelRed ( image , quantum == 0 ? 0 : QuantumRange , q ) ; SetPixelGreen ( image , quantum == 0 ? 0 : QuantumRange , q ) ; SetPixelBlue ( image , quantum == 0 ? 0 : QuantumRange , q ) ; if ( image -> storage_class == PseudoClass ) SetPixelIndex ( image , ( Quantum ) quantum , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else if ( image -> storage_class == PseudoClass ) for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelIndex ( image , * p ++ , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } else { number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( image , ScaleCharToQuantum ( * p ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * ( p + number_pixels ) ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * ( p + 2 * number_pixels ) ) , q ) ; if ( image -> colors != 0 ) { ssize_t index ; index = ( ssize_t ) GetPixelRed ( image , q ) ; SetPixelRed ( image , ClampToQuantum ( image -> colormap [ ConstrainColormapIndex ( image , index , exception ) ] . red ) , q ) ; index = ( ssize_t ) GetPixelGreen ( image , q ) ; SetPixelGreen ( image , ClampToQuantum ( image -> colormap [ ConstrainColormapIndex ( image , index , exception ) ] . green ) , q ) ; index = ( ssize_t ) GetPixelBlue ( image , q ) ; SetPixelBlue ( image , ClampToQuantum ( image -> colormap [ ConstrainColormapIndex ( image , index , exception ) ] . blue ) , q ) ; } SetPixelAlpha ( image , image -> alpha_trait != UndefinedPixelTrait ? ScaleCharToQuantum ( * ( p + number_pixels * 3 ) ) : OpaqueAlpha , q ) ; p ++ ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } pixels = ( unsigned char * ) RelinquishMagickMemory ( pixels ) ; if ( image -> storage_class == PseudoClass ) ( void ) SyncImage ( image , exception ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , "UnexpectedEndOfFile" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; count = ReadBlob ( image , 1 , & viff_info . identifier ) ; if ( ( count == 1 ) && ( viff_info . identifier == 0xab ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { <S2SV_StartBug> image = DestroyImageList ( image ) ; <S2SV_EndBug> return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( ( count != 0 ) && ( viff_info . identifier == 0xab ) ) ; ( void ) CloseBlob ( image ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; return ( GetFirstImageInList ( image ) ) ; }
CWE-119 static MagickBooleanType EncodeImage ( const ImageInfo * image_info , Image * image , const size_t data_size ) { # define MaxCode ( number_bits ) ( ( one << ( number_bits ) ) - 1 ) # define MaxHashTable 5003 # define MaxGIFBits 12UL # define MaxGIFTable ( 1UL << MaxGIFBits ) <S2SV_StartBug> # define GIFOutputCode ( code ) { if ( bits > 0 ) datum |= ( size_t ) ( code ) << bits ; else datum = ( size_t ) ( code ) ; bits += number_bits ; while ( bits >= 8 ) { packet [ length ++ ] = ( unsigned char ) ( datum & 0xff ) ; if ( length >= 254 ) { ( void ) WriteBlobByte ( image , ( unsigned char ) length ) ; ( void ) WriteBlob ( image , length , packet ) ; length = 0 ; } datum >>= 8 ; bits -= 8 ; } if ( free_code > max_code ) { number_bits ++ ; if ( number_bits == MaxGIFBits ) max_code = MaxGIFTable ; else max_code = MaxCode ( number_bits ) ; } } <S2SV_EndBug> IndexPacket index ; short * hash_code , * hash_prefix , waiting_code ; size_t bits , clear_code , datum , end_of_information_code , free_code , length , max_code , next_pixel , number_bits , one , pass ; ssize_t displacement , offset , k , y ; unsigned char * packet , * hash_suffix ; assert ( image != ( Image * ) NULL ) ; one = 1 ; packet = ( unsigned char * ) AcquireQuantumMemory ( 256 , sizeof ( * packet ) ) ; hash_code = ( short * ) AcquireQuantumMemory ( MaxHashTable , sizeof ( * hash_code ) ) ; hash_prefix = ( short * ) AcquireQuantumMemory ( MaxHashTable , sizeof ( * hash_prefix ) ) ; hash_suffix = ( unsigned char * ) AcquireQuantumMemory ( MaxHashTable , sizeof ( * hash_suffix ) ) ; if ( ( packet == ( unsigned char * ) NULL ) || ( hash_code == ( short * ) NULL ) || ( hash_prefix == ( short * ) NULL ) || ( hash_suffix == ( unsigned char * ) NULL ) ) { if ( packet != ( unsigned char * ) NULL ) packet = ( unsigned char * ) RelinquishMagickMemory ( packet ) ; if ( hash_code != ( short * ) NULL ) hash_code = ( short * ) RelinquishMagickMemory ( hash_code ) ; if ( hash_prefix != ( short * ) NULL ) hash_prefix = ( short * ) RelinquishMagickMemory ( hash_prefix ) ; if ( hash_suffix != ( unsigned char * ) NULL ) hash_suffix = ( unsigned char * ) RelinquishMagickMemory ( hash_suffix ) ; return ( MagickFalse ) ; } ( void ) memset ( packet , 0 , 256 * sizeof ( * packet ) ) ; ( void ) memset ( hash_code , 0 , MaxHashTable * sizeof ( * hash_code ) ) ; ( void ) memset ( hash_prefix , 0 , MaxHashTable * sizeof ( * hash_prefix ) ) ; ( void ) memset ( hash_suffix , 0 , MaxHashTable * sizeof ( * hash_suffix ) ) ; number_bits = data_size ; max_code = MaxCode ( number_bits ) ; clear_code = ( ( short ) one << ( data_size - 1 ) ) ; end_of_information_code = clear_code + 1 ; free_code = clear_code + 2 ; length = 0 ; datum = 0 ; bits = 0 ; GIFOutputCode ( clear_code ) ; offset = 0 ; pass = 0 ; waiting_code = 0 ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { register const IndexPacket * magick_restrict indexes ; register const PixelPacket * magick_restrict p ; register ssize_t x ; p = GetVirtualPixels ( image , 0 , offset , image -> columns , 1 , & image -> exception ) ; if ( p == ( const PixelPacket * ) NULL ) break ; indexes = GetVirtualIndexQueue ( image ) ; if ( y == 0 ) { waiting_code = ( short ) ( * indexes ) ; p ++ ; } for ( x = ( ssize_t ) ( y == 0 ? 1 : 0 ) ; x < ( ssize_t ) image -> columns ; x ++ ) { <S2SV_StartBug> index = ( IndexPacket ) ( ( size_t ) GetPixelIndex ( indexes + x ) & 0xff ) ; <S2SV_EndBug> p ++ ; k = ( ssize_t ) ( ( ( size_t ) index << ( MaxGIFBits - 8 ) ) + waiting_code ) ; if ( k >= MaxHashTable ) k -= MaxHashTable ; <S2SV_StartBug> next_pixel = MagickFalse ; <S2SV_EndBug> displacement = 1 ; if ( hash_code [ k ] > 0 ) { if ( ( hash_prefix [ k ] == waiting_code ) && ( hash_suffix [ k ] == ( unsigned char ) index ) ) { waiting_code = hash_code [ k ] ; continue ; } if ( k != 0 ) displacement = MaxHashTable - k ; for ( ; ; ) { k -= displacement ; if ( k < 0 ) k += MaxHashTable ; if ( hash_code [ k ] == 0 ) break ; if ( ( hash_prefix [ k ] == waiting_code ) && ( hash_suffix [ k ] == ( unsigned char ) index ) ) { waiting_code = hash_code [ k ] ; next_pixel = MagickTrue ; break ; } } if ( next_pixel != MagickFalse ) continue ; } GIFOutputCode ( waiting_code ) ; if ( free_code < MaxGIFTable ) { hash_code [ k ] = ( short ) free_code ++ ; hash_prefix [ k ] = waiting_code ; hash_suffix [ k ] = ( unsigned char ) index ; } else { for ( k = 0 ; k < MaxHashTable ; k ++ ) hash_code [ k ] = 0 ; free_code = clear_code + 2 ; GIFOutputCode ( clear_code ) ; number_bits = data_size ; max_code = MaxCode ( number_bits ) ; } waiting_code = ( short ) index ; } if ( image_info -> interlace == NoInterlace ) offset ++ ; else switch ( pass ) { case 0 : default : { offset += 8 ; if ( offset >= ( ssize_t ) image -> rows ) { pass ++ ; offset = 4 ; } break ; } case 1 : { offset += 8 ; if ( offset >= ( ssize_t ) image -> rows ) { pass ++ ; offset = 2 ; } break ; } case 2 : { offset += 4 ; if ( offset >= ( ssize_t ) image -> rows ) { pass ++ ; offset = 1 ; } break ; } case 3 : { offset += 2 ; break ; } } } GIFOutputCode ( waiting_code ) ; GIFOutputCode ( end_of_information_code ) ; if ( bits > 0 ) { packet [ length ++ ] = ( unsigned char ) ( datum & 0xff ) ; if ( length >= 254 ) { ( void ) WriteBlobByte ( image , ( unsigned char ) length ) ; ( void ) WriteBlob ( image , length , packet ) ; length = 0 ; } } if ( length > 0 ) { ( void ) WriteBlobByte ( image , ( unsigned char ) length ) ; ( void ) WriteBlob ( image , length , packet ) ; } hash_suffix = ( unsigned char * ) RelinquishMagickMemory ( hash_suffix ) ; hash_prefix = ( short * ) RelinquishMagickMemory ( hash_prefix ) ; hash_code = ( short * ) RelinquishMagickMemory ( hash_code ) ; packet = ( unsigned char * ) RelinquishMagickMemory ( packet ) ; return ( MagickTrue ) ; }
CWE-20 static Image * ReadCUTImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { <S2SV_StartBug> # define ThrowCUTReaderException ( severity , tag ) { if ( palette != NULL ) palette = DestroyImage ( palette ) ; if ( clone_info != NULL ) clone_info = DestroyImageInfo ( clone_info ) ; ThrowReaderException ( severity , tag ) ; } <S2SV_EndBug> Image * image , * palette ; ImageInfo * clone_info ; MagickBooleanType status ; MagickOffsetType offset ; size_t EncodedByte ; unsigned char RunCount , RunValue , RunCountMasked ; CUTHeader Header ; CUTPalHeader PalHeader ; ssize_t depth ; ssize_t i , j ; ssize_t ldblk ; unsigned char * BImgBuff = NULL , * ptrB ; PixelPacket * q ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } palette = NULL ; clone_info = NULL ; Header . Width = ReadBlobLSBShort ( image ) ; Header . Height = ReadBlobLSBShort ( image ) ; Header . Reserved = ReadBlobLSBShort ( image ) ; if ( Header . Width == 0 || Header . Height == 0 || Header . Reserved != 0 ) CUT_KO : ThrowCUTReaderException ( CorruptImageError , "ImproperImageHeader" ) ; EncodedByte = ReadBlobLSBShort ( image ) ; RunCount = ( unsigned char ) ReadBlobByte ( image ) ; RunCountMasked = RunCount & 0x7F ; ldblk = 0 ; while ( ( int ) RunCountMasked != 0 ) { i = 1 ; if ( ( int ) RunCount < 0x80 ) i = ( ssize_t ) RunCountMasked ; offset = SeekBlob ( image , TellBlob ( image ) + i , SEEK_SET ) ; if ( offset < 0 ) ThrowCUTReaderException ( CorruptImageError , "ImproperImageHeader" ) ; if ( EOFBlob ( image ) != MagickFalse ) goto CUT_KO ; EncodedByte -= i + 1 ; ldblk += ( ssize_t ) RunCountMasked ; RunCount = ( unsigned char ) ReadBlobByte ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) goto CUT_KO ; RunCountMasked = RunCount & 0x7F ; } if ( EncodedByte != 1 ) goto CUT_KO ; i = 0 ; if ( ldblk == ( int ) Header . Width ) i = 8 ; if ( 2 * ldblk == ( int ) Header . Width ) i = 4 ; if ( 8 * ldblk == ( int ) Header . Width ) i = 1 ; if ( i == 0 ) goto CUT_KO ; depth = i ; image -> columns = Header . Width ; image -> rows = Header . Height ; image -> depth = 8 ; image -> colors = ( size_t ) ( GetQuantumRange ( 1UL * i ) + 1 ) ; if ( image_info -> ping != MagickFalse ) goto Finish ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } if ( ( clone_info = CloneImageInfo ( image_info ) ) == NULL ) goto NoPalette ; i = ( ssize_t ) strlen ( clone_info -> filename ) ; j = i ; while ( -- i > 0 ) { if ( clone_info -> filename [ i ] == '.' ) { break ; } if ( clone_info -> filename [ i ] == '/' || clone_info -> filename [ i ] == '\\\\' || clone_info -> filename [ i ] == ':' ) { i = j ; break ; } } ( void ) CopyMagickString ( clone_info -> filename + i , ".PAL" , ( size_t ) ( MaxTextExtent - i ) ) ; if ( ( clone_info -> file = fopen_utf8 ( clone_info -> filename , "rb" ) ) == NULL ) { ( void ) CopyMagickString ( clone_info -> filename + i , ".pal" , ( size_t ) ( MaxTextExtent - i ) ) ; if ( ( clone_info -> file = fopen_utf8 ( clone_info -> filename , "rb" ) ) == NULL ) { clone_info -> filename [ i ] = '\\0' ; if ( ( clone_info -> file = fopen_utf8 ( clone_info -> filename , "rb" ) ) == NULL ) { clone_info = DestroyImageInfo ( clone_info ) ; clone_info = NULL ; goto NoPalette ; } } } if ( ( palette = AcquireImage ( clone_info ) ) == NULL ) goto NoPalette ; status = OpenBlob ( clone_info , palette , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { ErasePalette : palette = DestroyImage ( palette ) ; palette = NULL ; goto NoPalette ; } if ( palette != NULL ) { ( void ) ReadBlob ( palette , 2 , ( unsigned char * ) PalHeader . FileId ) ; if ( strncmp ( PalHeader . FileId , "AH" , 2 ) != 0 ) goto ErasePalette ; PalHeader . Version = ReadBlobLSBShort ( palette ) ; PalHeader . Size = ReadBlobLSBShort ( palette ) ; PalHeader . FileType = ( char ) ReadBlobByte ( palette ) ; PalHeader . SubType = ( char ) ReadBlobByte ( palette ) ; PalHeader . BoardID = ReadBlobLSBShort ( palette ) ; PalHeader . GraphicsMode = ReadBlobLSBShort ( palette ) ; PalHeader . MaxIndex = ReadBlobLSBShort ( palette ) ; PalHeader . MaxRed = ReadBlobLSBShort ( palette ) ; PalHeader . MaxGreen = ReadBlobLSBShort ( palette ) ; PalHeader . MaxBlue = ReadBlobLSBShort ( palette ) ; ( void ) ReadBlob ( palette , 20 , ( unsigned char * ) PalHeader . PaletteId ) ; if ( EOFBlob ( image ) ) ThrowCUTReaderException ( CorruptImageError , "UnexpectedEndOfFile" ) ; if ( PalHeader . MaxIndex < 1 ) goto ErasePalette ; image -> colors = PalHeader . MaxIndex + 1 ; if ( AcquireImageColormap ( image , image -> colors ) == MagickFalse ) goto NoMemory ; if ( PalHeader . MaxRed == 0 ) PalHeader . MaxRed = ( unsigned int ) QuantumRange ; if ( PalHeader . MaxGreen == 0 ) PalHeader . MaxGreen = ( unsigned int ) QuantumRange ; if ( PalHeader . MaxBlue == 0 ) PalHeader . MaxBlue = ( unsigned int ) QuantumRange ; for ( i = 0 ; i <= ( int ) PalHeader . MaxIndex ; i ++ ) { j = ( ssize_t ) TellBlob ( palette ) ; if ( ( j % 512 ) > 512 - 6 ) { j = ( ( j / 512 ) + 1 ) * 512 ; offset = SeekBlob ( palette , j , SEEK_SET ) ; if ( offset < 0 ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; } image -> colormap [ i ] . red = ( Quantum ) ReadBlobLSBShort ( palette ) ; if ( QuantumRange != ( Quantum ) PalHeader . MaxRed ) { image -> colormap [ i ] . red = ClampToQuantum ( ( ( double ) image -> colormap [ i ] . red * QuantumRange + ( PalHeader . MaxRed >> 1 ) ) / PalHeader . MaxRed ) ; } image -> colormap [ i ] . green = ( Quantum ) ReadBlobLSBShort ( palette ) ; if ( QuantumRange != ( Quantum ) PalHeader . MaxGreen ) { image -> colormap [ i ] . green = ClampToQuantum ( ( ( double ) image -> colormap [ i ] . green * QuantumRange + ( PalHeader . MaxGreen >> 1 ) ) / PalHeader . MaxGreen ) ; } image -> colormap [ i ] . blue = ( Quantum ) ReadBlobLSBShort ( palette ) ; if ( QuantumRange != ( Quantum ) PalHeader . MaxBlue ) { image -> colormap [ i ] . blue = ClampToQuantum ( ( ( double ) image -> colormap [ i ] . blue * QuantumRange + ( PalHeader . MaxBlue >> 1 ) ) / PalHeader . MaxBlue ) ; } } if ( EOFBlob ( image ) ) ThrowCUTReaderException ( CorruptImageError , "UnexpectedEndOfFile" ) ; } NoPalette : if ( palette == NULL ) { image -> colors = 256 ; if ( AcquireImageColormap ( image , image -> colors ) == MagickFalse ) { NoMemory : ThrowCUTReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; } for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( unsigned char ) i ) ; } } BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ldblk , sizeof ( * BImgBuff ) ) ; if ( BImgBuff == NULL ) goto NoMemory ; <S2SV_StartBug> offset = SeekBlob ( image , 6 , SEEK_SET ) ; <S2SV_EndBug> if ( offset < 0 ) { if ( palette != NULL ) palette = DestroyImage ( palette ) ; if ( clone_info != NULL ) clone_info = DestroyImageInfo ( clone_info ) ; BImgBuff = ( unsigned char * ) RelinquishMagickMemory ( BImgBuff ) ; ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; } for ( i = 0 ; i < ( int ) Header . Height ; i ++ ) { EncodedByte = ReadBlobLSBShort ( image ) ; ptrB = BImgBuff ; j = ldblk ; RunCount = ( unsigned char ) ReadBlobByte ( image ) ; RunCountMasked = RunCount & 0x7F ; while ( ( int ) RunCountMasked != 0 ) { if ( ( ssize_t ) RunCountMasked > j ) { RunCountMasked = ( unsigned char ) j ; if ( j == 0 ) { break ; } } if ( ( int ) RunCount > 0x80 ) { RunValue = ( unsigned char ) ReadBlobByte ( image ) ; ( void ) memset ( ptrB , ( int ) RunValue , ( size_t ) RunCountMasked ) ; } else { ( void ) ReadBlob ( image , ( size_t ) RunCountMasked , ptrB ) ; } ptrB += ( int ) RunCountMasked ; j -= ( int ) RunCountMasked ; if ( EOFBlob ( image ) != MagickFalse ) goto Finish ; RunCount = ( unsigned char ) ReadBlobByte ( image ) ; RunCountMasked = RunCount & 0x7F ; } InsertRow ( depth , BImgBuff , i , image ) ; } ( void ) SyncImage ( image ) ; if ( palette == NULL ) { if ( ( image -> storage_class == PseudoClass ) && ( SetImageGray ( image , & image -> exception ) != MagickFalse ) ) { if ( GetCutColors ( image ) == 2 ) { for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { register Quantum sample ; sample = ScaleCharToQuantum ( ( unsigned char ) i ) ; if ( image -> colormap [ i ] . red != sample ) goto Finish ; if ( image -> colormap [ i ] . green != sample ) goto Finish ; if ( image -> colormap [ i ] . blue != sample ) goto Finish ; } image -> colormap [ 1 ] . red = image -> colormap [ 1 ] . green = image -> colormap [ 1 ] . blue = QuantumRange ; for ( i = 0 ; i < ( ssize_t ) image -> rows ; i ++ ) { q = QueueAuthenticPixels ( image , 0 , i , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( j = 0 ; j < ( ssize_t ) image -> columns ; j ++ ) { if ( GetPixelRed ( q ) == ScaleCharToQuantum ( 1 ) ) { SetPixelRed ( q , QuantumRange ) ; SetPixelGreen ( q , QuantumRange ) ; SetPixelBlue ( q , QuantumRange ) ; } q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) goto Finish ; } } } } Finish : if ( BImgBuff != NULL ) BImgBuff = ( unsigned char * ) RelinquishMagickMemory ( BImgBuff ) ; if ( palette != NULL ) palette = DestroyImage ( palette ) ; if ( clone_info != NULL ) clone_info = DestroyImageInfo ( clone_info ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowFileException ( exception , CorruptImageError , "UnexpectedEndOfFile" , image -> filename ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
CWE-119 <S2SV_StartBug> static MagickPixelPacket * * AcquirePixelThreadSet ( const Image * image ) <S2SV_EndBug> { MagickPixelPacket * * pixels ; register ssize_t i , j ; size_t <S2SV_StartBug> number_threads ; <S2SV_EndBug> number_threads = ( size_t ) GetMagickResourceLimit ( ThreadResource ) ; pixels = ( MagickPixelPacket * * ) AcquireQuantumMemory ( number_threads , sizeof ( * pixels ) ) ; if ( pixels == ( MagickPixelPacket * * ) NULL ) return ( ( MagickPixelPacket * * ) NULL ) ; ( void ) memset ( pixels , 0 , number_threads * sizeof ( * pixels ) ) ; <S2SV_StartBug> for ( i = 0 ; i < ( ssize_t ) number_threads ; i ++ ) <S2SV_EndBug> { <S2SV_StartBug> pixels [ i ] = ( MagickPixelPacket * ) AcquireQuantumMemory ( image -> columns , <S2SV_EndBug> sizeof ( * * pixels ) ) ; if ( pixels [ i ] == ( MagickPixelPacket * ) NULL ) return ( DestroyPixelThreadSet ( pixels ) ) ; <S2SV_StartBug> for ( j = 0 ; j < ( ssize_t ) image -> columns ; j ++ ) <S2SV_EndBug> <S2SV_StartBug> GetMagickPixelPacket ( image , & pixels [ i ] [ j ] ) ; <S2SV_EndBug> } return ( pixels ) ; }
CWE-399 static Image * ReadPSImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define BoundingBox "BoundingBox:" # define BeginDocument "BeginDocument:" # define BeginXMPPacket "<?xpacket<S2SV_blank>begin=" # define EndXMPPacket "<?xpacket<S2SV_blank>end=" # define ICCProfile "BeginICCProfile:" # define CMYKCustomColor "CMYKCustomColor:" # define CMYKProcessColor "CMYKProcessColor:" # define DocumentMedia "DocumentMedia:" # define DocumentCustomColors "DocumentCustomColors:" # define DocumentProcessColors "DocumentProcessColors:" # define EndDocument "EndDocument:" # define HiResBoundingBox "HiResBoundingBox:" # define ImageData "ImageData:" # define PageBoundingBox "PageBoundingBox:" # define LanguageLevel "LanguageLevel:" # define PageMedia "PageMedia:" # define Pages "Pages:" # define PhotoshopProfile "BeginPhotoshop:" # define PostscriptLevel "!PS-" # define RenderPostscriptText "<S2SV_blank><S2SV_blank>Rendering<S2SV_blank>Postscript...<S2SV_blank><S2SV_blank>" # define SpotColor "+<S2SV_blank>" char command [ MaxTextExtent ] , * density , filename [ MaxTextExtent ] , geometry [ MaxTextExtent ] , input_filename [ MaxTextExtent ] , message [ MaxTextExtent ] , * options , postscript_filename [ MaxTextExtent ] ; const char * option ; const DelegateInfo * delegate_info ; GeometryInfo geometry_info ; Image * image , * next , * postscript_image ; ImageInfo * read_info ; int c , file ; MagickBooleanType cmyk , fitPage , skip , status ; MagickStatusType flags ; PointInfo delta , resolution ; RectangleInfo page ; register char * p ; register ssize_t i ; SegmentInfo bounds , hires_bounds ; short int hex_digits [ 256 ] ; size_t length , priority ; ssize_t count ; StringInfo * profile ; unsigned long columns , extent , language_level , pages , rows , scene , spotcolor ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } status = AcquireUniqueSymbolicLink ( image_info -> filename , input_filename ) ; if ( status == MagickFalse ) { ThrowFileException ( exception , FileOpenError , "UnableToCreateTemporaryFile" , image_info -> filename ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) memset ( hex_digits , 0 , sizeof ( hex_digits ) ) ; hex_digits [ ( int ) '0' ] = 0 ; hex_digits [ ( int ) '1' ] = 1 ; hex_digits [ ( int ) '2' ] = 2 ; hex_digits [ ( int ) '3' ] = 3 ; hex_digits [ ( int ) '4' ] = 4 ; hex_digits [ ( int ) '5' ] = 5 ; hex_digits [ ( int ) '6' ] = 6 ; hex_digits [ ( int ) '7' ] = 7 ; hex_digits [ ( int ) '8' ] = 8 ; hex_digits [ ( int ) '9' ] = 9 ; hex_digits [ ( int ) 'a' ] = 10 ; hex_digits [ ( int ) 'b' ] = 11 ; hex_digits [ ( int ) 'c' ] = 12 ; hex_digits [ ( int ) 'd' ] = 13 ; hex_digits [ ( int ) 'e' ] = 14 ; hex_digits [ ( int ) 'f' ] = 15 ; hex_digits [ ( int ) 'A' ] = 10 ; hex_digits [ ( int ) 'B' ] = 11 ; hex_digits [ ( int ) 'C' ] = 12 ; hex_digits [ ( int ) 'D' ] = 13 ; hex_digits [ ( int ) 'E' ] = 14 ; hex_digits [ ( int ) 'F' ] = 15 ; delta . x = DefaultResolution ; delta . y = DefaultResolution ; if ( ( image -> x_resolution == 0.0 ) || ( image -> y_resolution == 0.0 ) ) { flags = ParseGeometry ( PSDensityGeometry , & geometry_info ) ; image -> x_resolution = geometry_info . rho ; image -> y_resolution = geometry_info . sigma ; if ( ( flags & SigmaValue ) == 0 ) image -> y_resolution = image -> x_resolution ; } if ( image_info -> density != ( char * ) NULL ) { flags = ParseGeometry ( image_info -> density , & geometry_info ) ; image -> x_resolution = geometry_info . rho ; image -> y_resolution = geometry_info . sigma ; if ( ( flags & SigmaValue ) == 0 ) image -> y_resolution = image -> x_resolution ; } ( void ) ParseAbsoluteGeometry ( PSPageGeometry , & page ) ; if ( image_info -> page != ( char * ) NULL ) ( void ) ParseAbsoluteGeometry ( image_info -> page , & page ) ; resolution . x = image -> x_resolution ; resolution . y = image -> y_resolution ; page . width = ( size_t ) ceil ( ( double ) ( page . width * resolution . x / delta . x ) - 0.5 ) ; page . height = ( size_t ) ceil ( ( double ) ( page . height * resolution . y / delta . y ) - 0.5 ) ; ( void ) memset ( & bounds , 0 , sizeof ( bounds ) ) ; ( void ) memset ( command , 0 , sizeof ( command ) ) ; cmyk = image_info -> colorspace == CMYKColorspace ? MagickTrue : MagickFalse ; ( void ) memset ( & hires_bounds , 0 , sizeof ( hires_bounds ) ) ; priority = 0 ; columns = 0 ; rows = 0 ; extent = 0 ; spotcolor = 0 ; language_level = 1 ; skip = MagickFalse ; pages = ( ~ 0UL ) ; p = command ; for ( c = ReadBlobByte ( image ) ; c != EOF ; c = ReadBlobByte ( image ) ) { * p ++ = ( char ) c ; if ( ( strchr ( "\\n\\r%" , c ) == ( char * ) NULL ) && ( ( size_t ) ( p - command ) < ( MaxTextExtent - 1 ) ) ) continue ; * p = '\\0' ; p = command ; if ( LocaleNCompare ( BeginDocument , command , strlen ( BeginDocument ) ) == 0 ) skip = MagickTrue ; if ( LocaleNCompare ( EndDocument , command , strlen ( EndDocument ) ) == 0 ) skip = MagickFalse ; if ( skip != MagickFalse ) continue ; if ( LocaleNCompare ( PostscriptLevel , command , strlen ( PostscriptLevel ) ) == 0 ) { ( void ) SetImageProperty ( image , "ps:Level" , command + 4 ) ; if ( GlobExpression ( command , "*EPSF-*" , MagickTrue ) != MagickFalse ) pages = 1 ; } if ( LocaleNCompare ( LanguageLevel , command , strlen ( LanguageLevel ) ) == 0 ) ( void ) sscanf ( command , LanguageLevel "<S2SV_blank>%lu" , & language_level ) ; if ( LocaleNCompare ( Pages , command , strlen ( Pages ) ) == 0 ) ( void ) sscanf ( command , Pages "<S2SV_blank>%lu" , & pages ) ; if ( LocaleNCompare ( ImageData , command , strlen ( ImageData ) ) == 0 ) ( void ) sscanf ( command , ImageData "<S2SV_blank>%lu<S2SV_blank>%lu" , & columns , & rows ) ; length = strlen ( DocumentProcessColors ) ; if ( LocaleNCompare ( DocumentProcessColors , command , length ) == 0 ) { if ( ( GlobExpression ( command , "*Cyan*" , MagickTrue ) != MagickFalse ) || ( GlobExpression ( command , "*Magenta*" , MagickTrue ) != MagickFalse ) || ( GlobExpression ( command , "*Yellow*" , MagickTrue ) != MagickFalse ) ) cmyk = MagickTrue ; } if ( LocaleNCompare ( CMYKCustomColor , command , strlen ( CMYKCustomColor ) ) == 0 ) cmyk = MagickTrue ; if ( LocaleNCompare ( CMYKProcessColor , command , strlen ( CMYKProcessColor ) ) == 0 ) cmyk = MagickTrue ; length = strlen ( DocumentCustomColors ) ; if ( ( LocaleNCompare ( DocumentCustomColors , command , length ) == 0 ) || ( LocaleNCompare ( CMYKCustomColor , command , strlen ( CMYKCustomColor ) ) == 0 ) || ( LocaleNCompare ( SpotColor , command , strlen ( SpotColor ) ) == 0 ) ) { char property [ MaxTextExtent ] , * value ; register char * p ; ( void ) FormatLocaleString ( property , MaxTextExtent , "ps:SpotColor-%.20g" , ( double ) ( spotcolor ++ ) ) ; for ( p = command ; * p != '\\0' ; p ++ ) if ( isspace ( ( int ) ( unsigned char ) * p ) != 0 ) break ; value = ConstantString ( p ) ; ( void ) SubstituteString ( & value , "(" , "" ) ; ( void ) SubstituteString ( & value , ")" , "" ) ; ( void ) StripString ( value ) ; if ( * value != '\\0' ) ( void ) SetImageProperty ( image , property , value ) ; value = DestroyString ( value ) ; continue ; } if ( image_info -> page != ( char * ) NULL ) continue ; count = 0 ; i = 0 ; if ( LocaleNCompare ( BoundingBox , command , strlen ( BoundingBox ) ) == 0 ) { count = ( ssize_t ) sscanf ( command , BoundingBox "<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf" , & bounds . x1 , & bounds . y1 , & bounds . x2 , & bounds . y2 ) ; i = 2 ; } if ( LocaleNCompare ( DocumentMedia , command , strlen ( DocumentMedia ) ) == 0 ) { count = ( ssize_t ) sscanf ( command , DocumentMedia "<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf" , & bounds . x1 , & bounds . y1 , & bounds . x2 , & bounds . y2 ) ; i = 1 ; } if ( LocaleNCompare ( HiResBoundingBox , command , strlen ( HiResBoundingBox ) ) == 0 ) { count = ( ssize_t ) sscanf ( command , HiResBoundingBox "<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf" , & bounds . x1 , & bounds . y1 , & bounds . x2 , & bounds . y2 ) ; i = 3 ; } if ( LocaleNCompare ( PageBoundingBox , command , strlen ( PageBoundingBox ) ) == 0 ) { count = ( ssize_t ) sscanf ( command , PageBoundingBox "<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf" , & bounds . x1 , & bounds . y1 , & bounds . x2 , & bounds . y2 ) ; i = 1 ; } if ( LocaleNCompare ( PageMedia , command , strlen ( PageMedia ) ) == 0 ) { count = ( ssize_t ) sscanf ( command , PageMedia "<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf" , & bounds . x1 , & bounds . y1 , & bounds . x2 , & bounds . y2 ) ; i = 1 ; } if ( ( count != 4 ) || ( i < ( ssize_t ) priority ) ) continue ; if ( ( fabs ( bounds . x2 - bounds . x1 ) <= fabs ( hires_bounds . x2 - hires_bounds . x1 ) ) || ( fabs ( bounds . y2 - bounds . y1 ) <= fabs ( hires_bounds . y2 - hires_bounds . y1 ) ) ) if ( i == ( ssize_t ) priority ) continue ; hires_bounds = bounds ; priority = ( size_t ) i ; } if ( ( fabs ( hires_bounds . x2 - hires_bounds . x1 ) >= MagickEpsilon ) && ( fabs ( hires_bounds . y2 - hires_bounds . y1 ) >= MagickEpsilon ) ) { ( void ) FormatLocaleString ( geometry , MaxTextExtent , "%gx%g%+.15g%+.15g" , hires_bounds . x2 - hires_bounds . x1 , hires_bounds . y2 - hires_bounds . y1 , hires_bounds . x1 , hires_bounds . y1 ) ; ( void ) SetImageProperty ( image , "ps:HiResBoundingBox" , geometry ) ; page . width = ( size_t ) ceil ( ( double ) ( ( hires_bounds . x2 - hires_bounds . x1 ) * resolution . x / delta . x ) - 0.5 ) ; page . height = ( size_t ) ceil ( ( double ) ( ( hires_bounds . y2 - hires_bounds . y1 ) * resolution . y / delta . y ) - 0.5 ) ; } fitPage = MagickFalse ; option = GetImageOption ( image_info , "eps:fit-page" ) ; if ( option != ( char * ) NULL ) { char * geometry ; MagickStatusType flags ; geometry = GetPageGeometry ( option ) ; flags = ParseMetaGeometry ( geometry , & page . x , & page . y , & page . width , & page . height ) ; if ( flags == NoValue ) { ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , OptionError , <S2SV_StartBug> "InvalidGeometry" , "`%s\'" , option ) ; <S2SV_EndBug> image = DestroyImage ( image ) ; return ( ( Image * ) NULL ) ; } page . width = ( size_t ) ceil ( ( double ) ( page . width * image -> x_resolution / delta . x ) - 0.5 ) ; page . height = ( size_t ) ceil ( ( double ) ( page . height * image -> y_resolution / delta . y ) - 0.5 ) ; geometry = DestroyString ( geometry ) ; fitPage = MagickTrue ; } if ( IssRGBCompatibleColorspace ( image_info -> colorspace ) != MagickFalse ) cmyk = MagickFalse ; file = AcquireUniqueFileResource ( postscript_filename ) ; if ( file == - 1 ) { ThrowFileException ( & image -> exception , FileOpenError , "UnableToOpenFile" , image_info -> filename ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) CopyMagickString ( command , "/setpagedevice<S2SV_blank>{pop}<S2SV_blank>bind<S2SV_blank>1<S2SV_blank>index<S2SV_blank>where<S2SV_blank>{" "dup<S2SV_blank>wcheck<S2SV_blank>{3<S2SV_blank>1<S2SV_blank>roll<S2SV_blank>put}<S2SV_blank>{pop<S2SV_blank>def}<S2SV_blank>ifelse}<S2SV_blank>{def}<S2SV_blank>ifelse\\n" "<</UseCIEColor<S2SV_blank>true>>setpagedevice\\n" , MaxTextExtent ) ; count = write ( file , command , ( unsigned int ) strlen ( command ) ) ; if ( image_info -> page == ( char * ) NULL ) { char translate_geometry [ MaxTextExtent ] ; ( void ) FormatLocaleString ( translate_geometry , MaxTextExtent , "%g<S2SV_blank>%g<S2SV_blank>translate\\n" , - hires_bounds . x1 , - hires_bounds . y1 ) ; count = write ( file , translate_geometry , ( unsigned int ) strlen ( translate_geometry ) ) ; } file = close ( file ) - 1 ; if ( image_info -> monochrome != MagickFalse ) delegate_info = GetDelegateInfo ( "ps:mono" , ( char * ) NULL , exception ) ; else if ( cmyk != MagickFalse ) delegate_info = GetDelegateInfo ( "ps:cmyk" , ( char * ) NULL , exception ) ; else delegate_info = GetDelegateInfo ( "ps:alpha" , ( char * ) NULL , exception ) ; if ( delegate_info == ( const DelegateInfo * ) NULL ) { ( void ) RelinquishUniqueFileResource ( postscript_filename ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } density = AcquireString ( "" ) ; options = AcquireString ( "" ) ; ( void ) FormatLocaleString ( density , MaxTextExtent , "%gx%g" , resolution . x , resolution . y ) ; ( void ) FormatLocaleString ( options , MaxTextExtent , "-g%.20gx%.20g<S2SV_blank>" , ( double ) page . width , ( double ) page . height ) ; read_info = CloneImageInfo ( image_info ) ; * read_info -> magick = '\\0' ; if ( read_info -> number_scenes != 0 ) { char pages [ MaxTextExtent ] ; ( void ) FormatLocaleString ( pages , MaxTextExtent , "-dFirstPage=%.20g<S2SV_blank>" "-dLastPage=%.20g<S2SV_blank>" , ( double ) read_info -> scene + 1 , ( double ) ( read_info -> scene + read_info -> number_scenes ) ) ; ( void ) ConcatenateMagickString ( options , pages , MaxTextExtent ) ; read_info -> number_scenes = 0 ; if ( read_info -> scenes != ( char * ) NULL ) * read_info -> scenes = '\\0' ; } if ( * image_info -> magick == 'E' ) { option = GetImageOption ( image_info , "eps:use-cropbox" ) ; if ( ( option == ( const char * ) NULL ) || ( IsStringTrue ( option ) != MagickFalse ) ) ( void ) ConcatenateMagickString ( options , "-dEPSCrop<S2SV_blank>" , MaxTextExtent ) ; if ( fitPage != MagickFalse ) ( void ) ConcatenateMagickString ( options , "-dEPSFitPage<S2SV_blank>" , MaxTextExtent ) ; } ( void ) CopyMagickString ( filename , read_info -> filename , MaxTextExtent ) ; ( void ) AcquireUniqueFilename ( filename ) ; ( void ) RelinquishUniqueFileResource ( filename ) ; ( void ) ConcatenateMagickString ( filename , "%d" , MaxTextExtent ) ; ( void ) FormatLocaleString ( command , MaxTextExtent , GetDelegateCommands ( delegate_info ) , read_info -> antialias != MagickFalse ? 4 : 1 , read_info -> antialias != MagickFalse ? 4 : 1 , density , options , filename , postscript_filename , input_filename ) ; options = DestroyString ( options ) ; density = DestroyString ( density ) ; * message = '\\0' ; status = InvokePostscriptDelegate ( read_info -> verbose , command , message , exception ) ; ( void ) InterpretImageFilename ( image_info , image , filename , 1 , read_info -> filename ) ; if ( ( status == MagickFalse ) || ( IsPostscriptRendered ( read_info -> filename ) == MagickFalse ) ) { ( void ) ConcatenateMagickString ( command , "<S2SV_blank>-c<S2SV_blank>showpage" , MaxTextExtent ) ; status = InvokePostscriptDelegate ( read_info -> verbose , command , message , exception ) ; } ( void ) RelinquishUniqueFileResource ( postscript_filename ) ; ( void ) RelinquishUniqueFileResource ( input_filename ) ; postscript_image = ( Image * ) NULL ; if ( status == MagickFalse ) for ( i = 1 ; ; i ++ ) { ( void ) InterpretImageFilename ( image_info , image , filename , ( int ) i , read_info -> filename ) ; if ( IsPostscriptRendered ( read_info -> filename ) == MagickFalse ) break ; ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; } else for ( i = 1 ; ; i ++ ) { ( void ) InterpretImageFilename ( image_info , image , filename , ( int ) i , read_info -> filename ) ; if ( IsPostscriptRendered ( read_info -> filename ) == MagickFalse ) break ; read_info -> blob = NULL ; read_info -> length = 0 ; next = ReadImage ( read_info , exception ) ; ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; if ( next == ( Image * ) NULL ) break ; AppendImageToList ( & postscript_image , next ) ; } ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; read_info = DestroyImageInfo ( read_info ) ; if ( postscript_image == ( Image * ) NULL ) { if ( * message != '\\0' ) ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , DelegateError , "PostscriptDelegateFailed" , "`%s\'" , message ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } if ( LocaleCompare ( postscript_image -> magick , "BMP" ) == 0 ) { Image * cmyk_image ; cmyk_image = ConsolidateCMYKImages ( postscript_image , exception ) ; if ( cmyk_image != ( Image * ) NULL ) { postscript_image = DestroyImageList ( postscript_image ) ; postscript_image = cmyk_image ; } } ( void ) SeekBlob ( image , 0 , SEEK_SET ) ; for ( c = ReadBlobByte ( image ) ; c != EOF ; c = ReadBlobByte ( image ) ) { * p ++ = ( char ) c ; if ( ( strchr ( "\\n\\r%" , c ) == ( char * ) NULL ) && ( ( size_t ) ( p - command ) < ( MaxTextExtent - 1 ) ) ) continue ; * p = '\\0' ; p = command ; if ( LocaleNCompare ( BeginDocument , command , strlen ( BeginDocument ) ) == 0 ) skip = MagickTrue ; if ( LocaleNCompare ( EndDocument , command , strlen ( EndDocument ) ) == 0 ) skip = MagickFalse ; if ( skip != MagickFalse ) continue ; if ( LocaleNCompare ( PostscriptLevel , command , strlen ( PostscriptLevel ) ) == 0 ) { ( void ) SetImageProperty ( image , "ps:Level" , command + 4 ) ; if ( GlobExpression ( command , "*EPSF-*" , MagickTrue ) != MagickFalse ) pages = 1 ; } if ( LocaleNCompare ( LanguageLevel , command , strlen ( LanguageLevel ) ) == 0 ) ( void ) sscanf ( command , LanguageLevel "<S2SV_blank>%lu" , & language_level ) ; if ( LocaleNCompare ( Pages , command , strlen ( Pages ) ) == 0 ) ( void ) sscanf ( command , Pages "<S2SV_blank>%lu" , & pages ) ; if ( LocaleNCompare ( ImageData , command , strlen ( ImageData ) ) == 0 ) ( void ) sscanf ( command , ImageData "<S2SV_blank>%lu<S2SV_blank>%lu" , & columns , & rows ) ; if ( LocaleNCompare ( ICCProfile , command , strlen ( ICCProfile ) ) == 0 ) { unsigned char * datum ; profile = AcquireStringInfo ( MaxTextExtent ) ; datum = GetStringInfoDatum ( profile ) ; for ( i = 0 ; ( c = ProfileInteger ( image , hex_digits ) ) != EOF ; i ++ ) { if ( i >= ( ssize_t ) GetStringInfoLength ( profile ) ) { SetStringInfoLength ( profile , ( size_t ) i << 1 ) ; datum = GetStringInfoDatum ( profile ) ; } datum [ i ] = ( unsigned char ) c ; } SetStringInfoLength ( profile , ( size_t ) i + 1 ) ; ( void ) SetImageProfile ( image , "icc" , profile ) ; profile = DestroyStringInfo ( profile ) ; continue ; } if ( LocaleNCompare ( PhotoshopProfile , command , strlen ( PhotoshopProfile ) ) == 0 ) { unsigned char * p ; count = ( ssize_t ) sscanf ( command , PhotoshopProfile "<S2SV_blank>%lu" , & extent ) ; if ( count != 1 ) continue ; length = extent ; if ( ( MagickSizeType ) length > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , "InsufficientImageDataInFile" ) ; profile = BlobToStringInfo ( ( const void * ) NULL , length ) ; if ( profile != ( StringInfo * ) NULL ) { p = GetStringInfoDatum ( profile ) ; for ( i = 0 ; i < ( ssize_t ) length ; i ++ ) * p ++ = ( unsigned char ) ProfileInteger ( image , hex_digits ) ; ( void ) SetImageProfile ( image , "8bim" , profile ) ; profile = DestroyStringInfo ( profile ) ; } continue ; } if ( LocaleNCompare ( BeginXMPPacket , command , strlen ( BeginXMPPacket ) ) == 0 ) { register size_t i ; p = command ; profile = StringToStringInfo ( command ) ; for ( i = GetStringInfoLength ( profile ) - 1 ; c != EOF ; i ++ ) { SetStringInfoLength ( profile , ( size_t ) ( i + 1 ) ) ; c = ReadBlobByte ( image ) ; GetStringInfoDatum ( profile ) [ i ] = ( unsigned char ) c ; * p ++ = ( char ) c ; if ( ( strchr ( "\\n\\r%" , c ) == ( char * ) NULL ) && ( ( size_t ) ( p - command ) < ( MaxTextExtent - 1 ) ) ) continue ; * p = '\\0' ; p = command ; if ( LocaleNCompare ( EndXMPPacket , command , strlen ( EndXMPPacket ) ) == 0 ) break ; } SetStringInfoLength ( profile , ( size_t ) i ) ; ( void ) SetImageProfile ( image , "xmp" , profile ) ; profile = DestroyStringInfo ( profile ) ; continue ; } } ( void ) CloseBlob ( image ) ; if ( image_info -> number_scenes != 0 ) { Image * clone_image ; register ssize_t i ; for ( i = 0 ; i < ( ssize_t ) image_info -> scene ; i ++ ) { clone_image = CloneImage ( postscript_image , 1 , 1 , MagickTrue , exception ) ; if ( clone_image != ( Image * ) NULL ) PrependImageToList ( & postscript_image , clone_image ) ; } } do { ( void ) CopyMagickString ( postscript_image -> filename , filename , MaxTextExtent ) ; ( void ) CopyMagickString ( postscript_image -> magick , image -> magick , MaxTextExtent ) ; if ( columns != 0 ) postscript_image -> magick_columns = columns ; if ( rows != 0 ) postscript_image -> magick_rows = rows ; postscript_image -> page = page ; ( void ) CloneImageProfiles ( postscript_image , image ) ; ( void ) CloneImageProperties ( postscript_image , image ) ; next = SyncNextImageInList ( postscript_image ) ; if ( next != ( Image * ) NULL ) postscript_image = next ; } while ( next != ( Image * ) NULL ) ; image = DestroyImageList ( image ) ; scene = 0 ; for ( next = GetFirstImageInList ( postscript_image ) ; next != ( Image * ) NULL ; ) { next -> scene = scene ++ ; next = GetNextImageInList ( next ) ; } return ( GetFirstImageInList ( postscript_image ) ) ; }
CWE-119 static MagickPixelPacket * * AcquirePixelThreadSet ( const Image * images ) { const Image * next ; MagickPixelPacket * * pixels ; register ssize_t i , j ; size_t columns , <S2SV_StartBug> number_threads ; <S2SV_EndBug> <S2SV_StartBug> number_threads = ( size_t ) GetMagickResourceLimit ( ThreadResource ) ; <S2SV_EndBug> <S2SV_StartBug> pixels = ( MagickPixelPacket * * ) AcquireQuantumMemory ( number_threads , <S2SV_EndBug> sizeof ( * pixels ) ) ; if ( pixels == ( MagickPixelPacket * * ) NULL ) return ( ( MagickPixelPacket * * ) NULL ) ; <S2SV_StartBug> ( void ) memset ( pixels , 0 , number_threads * sizeof ( * pixels ) ) ; <S2SV_EndBug> columns = images -> columns ; for ( next = images ; next != ( Image * ) NULL ; next = next -> next ) columns = MagickMax ( next -> columns , columns ) ; <S2SV_StartBug> for ( i = 0 ; i < ( ssize_t ) number_threads ; i ++ ) <S2SV_EndBug> { pixels [ i ] = ( MagickPixelPacket * ) AcquireQuantumMemory ( columns , sizeof ( * * pixels ) ) ; if ( pixels [ i ] == ( MagickPixelPacket * ) NULL ) return ( DestroyPixelThreadSet ( pixels ) ) ; for ( j = 0 ; j < ( ssize_t ) columns ; j ++ ) GetMagickPixelPacket ( images , & pixels [ i ] [ j ] ) ; } return ( pixels ) ; }
CWE-732 static M_bool M_fs_check_overwrite_allowed ( const char * p1 , const char * p2 , M_uint32 mode ) { M_fs_info_t * info = NULL ; char * pold = NULL ; char * pnew = NULL ; M_fs_type_t type ; M_bool ret = M_TRUE ; if ( mode & M_FS_FILE_MODE_OVERWRITE ) return M_TRUE ; if ( M_fs_info ( & info , p1 , M_FS_PATH_INFO_FLAGS_BASIC ) != M_FS_ERROR_SUCCESS ) return M_FALSE ; type = M_fs_info_get_type ( info ) ; M_fs_info_destroy ( info ) ; if ( type != M_FS_TYPE_DIR ) { if ( M_fs_perms_can_access ( p2 , M_FS_PERMS_MODE_NONE ) == M_FS_ERROR_SUCCESS ) { ret = M_FALSE ; goto done ; } } pold = M_fs_path_basename ( p1 , M_FS_SYSTEM_AUTO ) ; pnew = M_fs_path_join ( p2 , pnew , M_FS_SYSTEM_AUTO ) ; if ( M_fs_perms_can_access ( pnew , M_FS_PERMS_MODE_NONE ) == M_FS_ERROR_SUCCESS ) { ret = M_FALSE ; goto done ; } done : M_free ( pnew ) ; M_free ( pold ) ; return ret ; }
CWE-732 static M_fs_error_t M_fs_copy_file ( const char * path_old , const char * path_new , M_fs_file_mode_t mode , M_fs_progress_cb_t cb , M_fs_progress_flags_t progress_flags , M_fs_progress_t * progress , const M_fs_perms_t * perms ) { M_fs_file_t * fd_old ; M_fs_file_t * fd_new ; M_fs_info_t * info = NULL ; unsigned char temp [ M_FS_BUF_SIZE ] ; size_t read_len ; size_t wrote_len ; size_t wrote_total = 0 ; size_t offset ; M_fs_error_t res ; <S2SV_StartBug> if ( M_fs_perms_can_access ( path_new , M_FS_PERMS_MODE_NONE ) == M_FS_ERROR_SUCCESS ) { <S2SV_EndBug> res = M_fs_delete ( path_new , M_FALSE , NULL , M_FS_PROGRESS_NOEXTRA ) ; if ( res != M_FS_ERROR_SUCCESS ) { return res ; } } res = M_fs_file_open ( & fd_old , path_old , M_FS_BUF_SIZE , M_FS_FILE_MODE_READ | M_FS_FILE_MODE_NOCREATE , NULL ) ; if ( res != M_FS_ERROR_SUCCESS ) { return res ; } if ( perms == NULL && mode & M_FS_FILE_MODE_PRESERVE_PERMS ) { res = M_fs_info_file ( & info , fd_old , M_FS_PATH_INFO_FLAGS_NONE ) ; if ( res != M_FS_ERROR_SUCCESS ) { M_fs_file_close ( fd_old ) ; return res ; } perms = M_fs_info_get_perms ( info ) ; } res = M_fs_file_open ( & fd_new , path_new , M_FS_BUF_SIZE , M_FS_FILE_MODE_WRITE | M_FS_FILE_MODE_OVERWRITE , perms ) ; M_fs_info_destroy ( info ) ; if ( res != M_FS_ERROR_SUCCESS ) { M_fs_file_close ( fd_old ) ; return res ; } while ( ( res = M_fs_file_read ( fd_old , temp , sizeof ( temp ) , & read_len , M_FS_FILE_RW_NORMAL ) ) == M_FS_ERROR_SUCCESS && read_len != 0 ) { offset = 0 ; while ( offset < read_len ) { res = M_fs_file_write ( fd_new , temp + offset , read_len - offset , & wrote_len , M_FS_FILE_RW_NORMAL ) ; offset += wrote_len ; wrote_total += wrote_len ; if ( cb ) { M_fs_progress_set_result ( progress , res ) ; if ( progress_flags & M_FS_PROGRESS_SIZE_TOTAL ) { M_fs_progress_set_size_total_progess ( progress , M_fs_progress_get_size_total_progess ( progress ) + wrote_len ) ; } if ( progress_flags & M_FS_PROGRESS_SIZE_CUR ) { M_fs_progress_set_size_current_progress ( progress , wrote_total ) ; } if ( progress_flags & M_FS_PROGRESS_COUNT ) { M_fs_progress_set_count ( progress , M_fs_progress_get_count ( progress ) + 1 ) ; } if ( ! cb ( progress ) ) { res = M_FS_ERROR_CANCELED ; } } if ( res != M_FS_ERROR_SUCCESS ) { break ; } } if ( res != M_FS_ERROR_SUCCESS ) { break ; } } M_fs_file_close ( fd_old ) ; M_fs_file_close ( fd_new ) ; if ( res != M_FS_ERROR_SUCCESS ) { return res ; } return M_FS_ERROR_SUCCESS ; }
CWE-119 TEE_Result syscall_asymm_operate ( unsigned long state , const struct utee_attribute * usr_params , size_t num_params , const void * src_data , size_t src_len , void * dst_data , uint64_t * dst_len ) { TEE_Result res ; struct tee_cryp_state * cs ; struct tee_ta_session * sess ; uint64_t dlen64 ; size_t dlen ; struct tee_obj * o ; void * label = NULL ; size_t label_len = 0 ; size_t n ; int salt_len ; TEE_Attribute * params = NULL ; struct user_ta_ctx * utc ; res = tee_ta_get_current_session ( & sess ) ; if ( res != TEE_SUCCESS ) return res ; utc = to_user_ta_ctx ( sess -> ctx ) ; res = tee_svc_cryp_get_state ( sess , tee_svc_uref_to_vaddr ( state ) , & cs ) ; if ( res != TEE_SUCCESS ) return res ; res = tee_mmu_check_access_rights ( utc , TEE_MEMORY_ACCESS_READ | TEE_MEMORY_ACCESS_ANY_OWNER , ( uaddr_t ) src_data , src_len ) ; if ( res != TEE_SUCCESS ) return res ; res = tee_svc_copy_from_user ( & dlen64 , dst_len , sizeof ( dlen64 ) ) ; if ( res != TEE_SUCCESS ) return res ; dlen = dlen64 ; res = tee_mmu_check_access_rights ( utc , TEE_MEMORY_ACCESS_READ | TEE_MEMORY_ACCESS_WRITE | TEE_MEMORY_ACCESS_ANY_OWNER , ( uaddr_t ) dst_data , dlen ) ; if ( res != TEE_SUCCESS ) return res ; <S2SV_StartBug> params = malloc ( sizeof ( TEE_Attribute ) * num_params ) ; <S2SV_EndBug> if ( ! params ) return TEE_ERROR_OUT_OF_MEMORY ; res = copy_in_attrs ( utc , usr_params , num_params , params ) ; if ( res != TEE_SUCCESS ) goto out ; res = tee_obj_get ( utc , cs -> key1 , & o ) ; if ( res != TEE_SUCCESS ) goto out ; if ( ( o -> info . handleFlags & TEE_HANDLE_FLAG_INITIALIZED ) == 0 ) { res = TEE_ERROR_GENERIC ; goto out ; } switch ( cs -> algo ) { case TEE_ALG_RSA_NOPAD : if ( cs -> mode == TEE_MODE_ENCRYPT ) { res = crypto_acipher_rsanopad_encrypt ( o -> attr , src_data , src_len , dst_data , & dlen ) ; } else if ( cs -> mode == TEE_MODE_DECRYPT ) { res = crypto_acipher_rsanopad_decrypt ( o -> attr , src_data , src_len , dst_data , & dlen ) ; } else { res = TEE_ERROR_GENERIC ; } break ; case TEE_ALG_RSAES_PKCS1_V1_5 : case TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA1 : case TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA224 : case TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA256 : case TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA384 : case TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA512 : for ( n = 0 ; n < num_params ; n ++ ) { if ( params [ n ] . attributeID == TEE_ATTR_RSA_OAEP_LABEL ) { label = params [ n ] . content . ref . buffer ; label_len = params [ n ] . content . ref . length ; break ; } } if ( cs -> mode == TEE_MODE_ENCRYPT ) { res = crypto_acipher_rsaes_encrypt ( cs -> algo , o -> attr , label , label_len , src_data , src_len , dst_data , & dlen ) ; } else if ( cs -> mode == TEE_MODE_DECRYPT ) { res = crypto_acipher_rsaes_decrypt ( cs -> algo , o -> attr , label , label_len , src_data , src_len , dst_data , & dlen ) ; } else { res = TEE_ERROR_BAD_PARAMETERS ; } break ; # if defined ( CFG_CRYPTO_RSASSA_NA1 ) case TEE_ALG_RSASSA_PKCS1_V1_5 : # endif case TEE_ALG_RSASSA_PKCS1_V1_5_MD5 : case TEE_ALG_RSASSA_PKCS1_V1_5_SHA1 : case TEE_ALG_RSASSA_PKCS1_V1_5_SHA224 : case TEE_ALG_RSASSA_PKCS1_V1_5_SHA256 : case TEE_ALG_RSASSA_PKCS1_V1_5_SHA384 : case TEE_ALG_RSASSA_PKCS1_V1_5_SHA512 : case TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA1 : case TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA224 : case TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA256 : case TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA384 : case TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA512 : if ( cs -> mode != TEE_MODE_SIGN ) { res = TEE_ERROR_BAD_PARAMETERS ; break ; } salt_len = pkcs1_get_salt_len ( params , num_params , src_len ) ; res = crypto_acipher_rsassa_sign ( cs -> algo , o -> attr , salt_len , src_data , src_len , dst_data , & dlen ) ; break ; case TEE_ALG_DSA_SHA1 : case TEE_ALG_DSA_SHA224 : case TEE_ALG_DSA_SHA256 : res = crypto_acipher_dsa_sign ( cs -> algo , o -> attr , src_data , src_len , dst_data , & dlen ) ; break ; case TEE_ALG_ECDSA_P192 : case TEE_ALG_ECDSA_P224 : case TEE_ALG_ECDSA_P256 : case TEE_ALG_ECDSA_P384 : case TEE_ALG_ECDSA_P521 : res = crypto_acipher_ecc_sign ( cs -> algo , o -> attr , src_data , src_len , dst_data , & dlen ) ; break ; default : res = TEE_ERROR_BAD_PARAMETERS ; break ; } out : free ( params ) ; if ( res == TEE_SUCCESS || res == TEE_ERROR_SHORT_BUFFER ) { TEE_Result res2 ; dlen64 = dlen ; res2 = tee_svc_copy_to_user ( dst_len , & dlen64 , sizeof ( * dst_len ) ) ; if ( res2 != TEE_SUCCESS ) return res2 ; } return res ; }
CWE-119 TEE_Result syscall_asymm_verify ( unsigned long state , const struct utee_attribute * usr_params , size_t num_params , const void * data , size_t data_len , const void * sig , size_t sig_len ) { TEE_Result res ; struct tee_cryp_state * cs ; struct tee_ta_session * sess ; struct tee_obj * o ; size_t hash_size ; int salt_len = 0 ; TEE_Attribute * params = NULL ; uint32_t hash_algo ; struct user_ta_ctx * utc ; res = tee_ta_get_current_session ( & sess ) ; if ( res != TEE_SUCCESS ) return res ; utc = to_user_ta_ctx ( sess -> ctx ) ; res = tee_svc_cryp_get_state ( sess , tee_svc_uref_to_vaddr ( state ) , & cs ) ; if ( res != TEE_SUCCESS ) return res ; if ( cs -> mode != TEE_MODE_VERIFY ) return TEE_ERROR_BAD_PARAMETERS ; res = tee_mmu_check_access_rights ( utc , TEE_MEMORY_ACCESS_READ | TEE_MEMORY_ACCESS_ANY_OWNER , ( uaddr_t ) data , data_len ) ; if ( res != TEE_SUCCESS ) return res ; res = tee_mmu_check_access_rights ( utc , TEE_MEMORY_ACCESS_READ | TEE_MEMORY_ACCESS_ANY_OWNER , ( uaddr_t ) sig , sig_len ) ; if ( res != TEE_SUCCESS ) return res ; <S2SV_StartBug> params = malloc ( sizeof ( TEE_Attribute ) * num_params ) ; <S2SV_EndBug> if ( ! params ) return TEE_ERROR_OUT_OF_MEMORY ; res = copy_in_attrs ( utc , usr_params , num_params , params ) ; if ( res != TEE_SUCCESS ) goto out ; res = tee_obj_get ( utc , cs -> key1 , & o ) ; if ( res != TEE_SUCCESS ) goto out ; if ( ( o -> info . handleFlags & TEE_HANDLE_FLAG_INITIALIZED ) == 0 ) { res = TEE_ERROR_BAD_PARAMETERS ; goto out ; } switch ( TEE_ALG_GET_MAIN_ALG ( cs -> algo ) ) { case TEE_MAIN_ALGO_RSA : if ( cs -> algo != TEE_ALG_RSASSA_PKCS1_V1_5 ) { hash_algo = TEE_DIGEST_HASH_TO_ALGO ( cs -> algo ) ; res = tee_hash_get_digest_size ( hash_algo , & hash_size ) ; if ( res != TEE_SUCCESS ) break ; if ( data_len != hash_size ) { res = TEE_ERROR_BAD_PARAMETERS ; break ; } salt_len = pkcs1_get_salt_len ( params , num_params , hash_size ) ; } res = crypto_acipher_rsassa_verify ( cs -> algo , o -> attr , salt_len , data , data_len , sig , sig_len ) ; break ; case TEE_MAIN_ALGO_DSA : hash_algo = TEE_DIGEST_HASH_TO_ALGO ( cs -> algo ) ; res = tee_hash_get_digest_size ( hash_algo , & hash_size ) ; if ( res != TEE_SUCCESS ) break ; if ( data_len > hash_size ) { res = TEE_ERROR_BAD_PARAMETERS ; break ; } res = crypto_acipher_dsa_verify ( cs -> algo , o -> attr , data , data_len , sig , sig_len ) ; break ; case TEE_MAIN_ALGO_ECDSA : res = crypto_acipher_ecc_verify ( cs -> algo , o -> attr , data , data_len , sig , sig_len ) ; break ; default : res = TEE_ERROR_NOT_SUPPORTED ; } out : free ( params ) ; return res ; }
CWE-189 static struct mobj * alloc_ta_mem ( size_t size ) { # ifdef CFG_PAGED_USER_TA return mobj_paged_alloc ( size ) ; # else struct mobj * mobj = mobj_mm_alloc ( mobj_sec_ddr , size , & tee_mm_sec_ddr ) ; <S2SV_StartBug> if ( mobj ) <S2SV_EndBug> <S2SV_StartBug> memset ( mobj_get_va ( mobj , 0 ) , 0 , size ) ; <S2SV_EndBug> return mobj ; # endif }
CWE-20 TEE_Result tee_mmu_check_access_rights ( const struct user_ta_ctx * utc , uint32_t flags , uaddr_t uaddr , size_t len ) { uaddr_t a ; <S2SV_StartBug> size_t addr_incr = MIN ( CORE_MMU_USER_CODE_SIZE , <S2SV_EndBug> CORE_MMU_USER_PARAM_SIZE ) ; <S2SV_StartBug> if ( ADD_OVERFLOW ( uaddr , len , & a ) ) <S2SV_EndBug> return TEE_ERROR_ACCESS_DENIED ; if ( ( flags & TEE_MEMORY_ACCESS_NONSECURE ) && ( flags & TEE_MEMORY_ACCESS_SECURE ) ) return TEE_ERROR_ACCESS_DENIED ; if ( ! ( flags & TEE_MEMORY_ACCESS_ANY_OWNER ) && ! tee_mmu_is_vbuf_inside_ta_private ( utc , ( void * ) uaddr , len ) ) return TEE_ERROR_ACCESS_DENIED ; <S2SV_StartBug> for ( a = uaddr ; a < ( uaddr + len ) ; a += addr_incr ) { <S2SV_EndBug> uint32_t attr ; TEE_Result res ; res = tee_mmu_user_va2pa_attr ( utc , ( void * ) a , NULL , & attr ) ; if ( res != TEE_SUCCESS ) return res ; if ( ( flags & TEE_MEMORY_ACCESS_NONSECURE ) && ( attr & TEE_MATTR_SECURE ) ) return TEE_ERROR_ACCESS_DENIED ; if ( ( flags & TEE_MEMORY_ACCESS_SECURE ) && ! ( attr & TEE_MATTR_SECURE ) ) return TEE_ERROR_ACCESS_DENIED ; if ( ( flags & TEE_MEMORY_ACCESS_WRITE ) && ! ( attr & TEE_MATTR_UW ) ) return TEE_ERROR_ACCESS_DENIED ; if ( ( flags & TEE_MEMORY_ACCESS_READ ) && ! ( attr & TEE_MATTR_UR ) ) return TEE_ERROR_ACCESS_DENIED ; } return TEE_SUCCESS ; }
CWE-119 TEE_Result syscall_cryp_derive_key ( unsigned long state , const struct utee_attribute * usr_params , unsigned long param_count , unsigned long derived_key ) { TEE_Result res = TEE_ERROR_NOT_SUPPORTED ; struct tee_ta_session * sess ; struct tee_obj * ko ; struct tee_obj * so ; struct tee_cryp_state * cs ; struct tee_cryp_obj_secret * sk ; const struct tee_cryp_obj_type_props * type_props ; TEE_Attribute * params = NULL ; struct user_ta_ctx * utc ; res = tee_ta_get_current_session ( & sess ) ; if ( res != TEE_SUCCESS ) return res ; utc = to_user_ta_ctx ( sess -> ctx ) ; res = tee_svc_cryp_get_state ( sess , tee_svc_uref_to_vaddr ( state ) , & cs ) ; if ( res != TEE_SUCCESS ) return res ; <S2SV_StartBug> params = malloc ( sizeof ( TEE_Attribute ) * param_count ) ; <S2SV_EndBug> if ( ! params ) return TEE_ERROR_OUT_OF_MEMORY ; res = copy_in_attrs ( utc , usr_params , param_count , params ) ; if ( res != TEE_SUCCESS ) goto out ; res = tee_obj_get ( utc , cs -> key1 , & ko ) ; if ( res != TEE_SUCCESS ) goto out ; res = tee_obj_get ( utc , tee_svc_uref_to_vaddr ( derived_key ) , & so ) ; if ( res != TEE_SUCCESS ) goto out ; sk = so -> attr ; type_props = tee_svc_find_type_props ( so -> info . objectType ) ; if ( ! type_props ) { res = TEE_ERROR_NOT_SUPPORTED ; goto out ; } if ( cs -> algo == TEE_ALG_DH_DERIVE_SHARED_SECRET ) { size_t alloc_size ; struct bignum * pub ; struct bignum * ss ; if ( param_count != 1 || params [ 0 ] . attributeID != TEE_ATTR_DH_PUBLIC_VALUE ) { res = TEE_ERROR_BAD_PARAMETERS ; goto out ; } alloc_size = params [ 0 ] . content . ref . length * 8 ; pub = crypto_bignum_allocate ( alloc_size ) ; ss = crypto_bignum_allocate ( alloc_size ) ; if ( pub && ss ) { crypto_bignum_bin2bn ( params [ 0 ] . content . ref . buffer , params [ 0 ] . content . ref . length , pub ) ; res = crypto_acipher_dh_shared_secret ( ko -> attr , pub , ss ) ; if ( res == TEE_SUCCESS ) { sk -> key_size = crypto_bignum_num_bytes ( ss ) ; crypto_bignum_bn2bin ( ss , ( uint8_t * ) ( sk + 1 ) ) ; so -> info . handleFlags |= TEE_HANDLE_FLAG_INITIALIZED ; set_attribute ( so , type_props , TEE_ATTR_SECRET_VALUE ) ; } } else { res = TEE_ERROR_OUT_OF_MEMORY ; } crypto_bignum_free ( pub ) ; crypto_bignum_free ( ss ) ; } else if ( TEE_ALG_GET_MAIN_ALG ( cs -> algo ) == TEE_MAIN_ALGO_ECDH ) { size_t alloc_size ; struct ecc_public_key key_public ; uint8_t * pt_secret ; unsigned long pt_secret_len ; if ( param_count != 2 || params [ 0 ] . attributeID != TEE_ATTR_ECC_PUBLIC_VALUE_X || params [ 1 ] . attributeID != TEE_ATTR_ECC_PUBLIC_VALUE_Y ) { res = TEE_ERROR_BAD_PARAMETERS ; goto out ; } switch ( cs -> algo ) { case TEE_ALG_ECDH_P192 : alloc_size = 192 ; break ; case TEE_ALG_ECDH_P224 : alloc_size = 224 ; break ; case TEE_ALG_ECDH_P256 : alloc_size = 256 ; break ; case TEE_ALG_ECDH_P384 : alloc_size = 384 ; break ; case TEE_ALG_ECDH_P521 : alloc_size = 521 ; break ; default : res = TEE_ERROR_NOT_IMPLEMENTED ; goto out ; } res = crypto_acipher_alloc_ecc_public_key ( & key_public , alloc_size ) ; if ( res != TEE_SUCCESS ) goto out ; key_public . curve = ( ( struct ecc_keypair * ) ko -> attr ) -> curve ; crypto_bignum_bin2bn ( params [ 0 ] . content . ref . buffer , params [ 0 ] . content . ref . length , key_public . x ) ; crypto_bignum_bin2bn ( params [ 1 ] . content . ref . buffer , params [ 1 ] . content . ref . length , key_public . y ) ; pt_secret = ( uint8_t * ) ( sk + 1 ) ; pt_secret_len = sk -> alloc_size ; res = crypto_acipher_ecc_shared_secret ( ko -> attr , & key_public , pt_secret , & pt_secret_len ) ; if ( res == TEE_SUCCESS ) { sk -> key_size = pt_secret_len ; so -> info . handleFlags |= TEE_HANDLE_FLAG_INITIALIZED ; set_attribute ( so , type_props , TEE_ATTR_SECRET_VALUE ) ; } crypto_acipher_free_ecc_public_key ( & key_public ) ; } # if defined ( CFG_CRYPTO_HKDF ) else if ( TEE_ALG_GET_MAIN_ALG ( cs -> algo ) == TEE_MAIN_ALGO_HKDF ) { void * salt , * info ; size_t salt_len , info_len , okm_len ; uint32_t hash_id = TEE_ALG_GET_DIGEST_HASH ( cs -> algo ) ; struct tee_cryp_obj_secret * ik = ko -> attr ; const uint8_t * ikm = ( const uint8_t * ) ( ik + 1 ) ; res = get_hkdf_params ( params , param_count , & salt , & salt_len , & info , & info_len , & okm_len ) ; if ( res != TEE_SUCCESS ) goto out ; if ( okm_len > ik -> alloc_size ) { res = TEE_ERROR_BAD_PARAMETERS ; goto out ; } res = tee_cryp_hkdf ( hash_id , ikm , ik -> key_size , salt , salt_len , info , info_len , ( uint8_t * ) ( sk + 1 ) , okm_len ) ; if ( res == TEE_SUCCESS ) { sk -> key_size = okm_len ; so -> info . handleFlags |= TEE_HANDLE_FLAG_INITIALIZED ; set_attribute ( so , type_props , TEE_ATTR_SECRET_VALUE ) ; } } # endif # if defined ( CFG_CRYPTO_CONCAT_KDF ) else if ( TEE_ALG_GET_MAIN_ALG ( cs -> algo ) == TEE_MAIN_ALGO_CONCAT_KDF ) { void * info ; size_t info_len , derived_key_len ; uint32_t hash_id = TEE_ALG_GET_DIGEST_HASH ( cs -> algo ) ; struct tee_cryp_obj_secret * ss = ko -> attr ; const uint8_t * shared_secret = ( const uint8_t * ) ( ss + 1 ) ; res = get_concat_kdf_params ( params , param_count , & info , & info_len , & derived_key_len ) ; if ( res != TEE_SUCCESS ) goto out ; if ( derived_key_len > ss -> alloc_size ) { res = TEE_ERROR_BAD_PARAMETERS ; goto out ; } res = tee_cryp_concat_kdf ( hash_id , shared_secret , ss -> key_size , info , info_len , ( uint8_t * ) ( sk + 1 ) , derived_key_len ) ; if ( res == TEE_SUCCESS ) { sk -> key_size = derived_key_len ; so -> info . handleFlags |= TEE_HANDLE_FLAG_INITIALIZED ; set_attribute ( so , type_props , TEE_ATTR_SECRET_VALUE ) ; } } # endif # if defined ( CFG_CRYPTO_PBKDF2 ) else if ( TEE_ALG_GET_MAIN_ALG ( cs -> algo ) == TEE_MAIN_ALGO_PBKDF2 ) { void * salt ; size_t salt_len , iteration_count , derived_key_len ; uint32_t hash_id = TEE_ALG_GET_DIGEST_HASH ( cs -> algo ) ; struct tee_cryp_obj_secret * ss = ko -> attr ; const uint8_t * password = ( const uint8_t * ) ( ss + 1 ) ; res = get_pbkdf2_params ( params , param_count , & salt , & salt_len , & derived_key_len , & iteration_count ) ; if ( res != TEE_SUCCESS ) goto out ; if ( derived_key_len > ss -> alloc_size ) { res = TEE_ERROR_BAD_PARAMETERS ; goto out ; } res = tee_cryp_pbkdf2 ( hash_id , password , ss -> key_size , salt , salt_len , iteration_count , ( uint8_t * ) ( sk + 1 ) , derived_key_len ) ; if ( res == TEE_SUCCESS ) { sk -> key_size = derived_key_len ; so -> info . handleFlags |= TEE_HANDLE_FLAG_INITIALIZED ; set_attribute ( so , type_props , TEE_ATTR_SECRET_VALUE ) ; } } # endif else res = TEE_ERROR_NOT_SUPPORTED ; out : free ( params ) ; return res ; }
CWE-119 TEE_Result syscall_obj_generate_key ( unsigned long obj , unsigned long key_size , const struct utee_attribute * usr_params , unsigned long param_count ) { TEE_Result res ; struct tee_ta_session * sess ; const struct tee_cryp_obj_type_props * type_props ; struct tee_obj * o ; struct tee_cryp_obj_secret * key ; size_t byte_size ; TEE_Attribute * params = NULL ; res = tee_ta_get_current_session ( & sess ) ; if ( res != TEE_SUCCESS ) return res ; res = tee_obj_get ( to_user_ta_ctx ( sess -> ctx ) , tee_svc_uref_to_vaddr ( obj ) , & o ) ; if ( res != TEE_SUCCESS ) return res ; if ( ( o -> info . handleFlags & TEE_HANDLE_FLAG_PERSISTENT ) != 0 ) return TEE_ERROR_BAD_STATE ; if ( ( o -> info . handleFlags & TEE_HANDLE_FLAG_INITIALIZED ) != 0 ) return TEE_ERROR_BAD_STATE ; type_props = tee_svc_find_type_props ( o -> info . objectType ) ; if ( ! type_props ) return TEE_ERROR_NOT_SUPPORTED ; if ( key_size % type_props -> quanta != 0 ) return TEE_ERROR_NOT_SUPPORTED ; if ( key_size < type_props -> min_size ) return TEE_ERROR_NOT_SUPPORTED ; if ( key_size > type_props -> max_size ) return TEE_ERROR_NOT_SUPPORTED ; <S2SV_StartBug> params = malloc ( sizeof ( TEE_Attribute ) * param_count ) ; <S2SV_EndBug> if ( ! params ) return TEE_ERROR_OUT_OF_MEMORY ; res = copy_in_attrs ( to_user_ta_ctx ( sess -> ctx ) , usr_params , param_count , params ) ; if ( res != TEE_SUCCESS ) goto out ; res = tee_svc_cryp_check_attr ( ATTR_USAGE_GENERATE_KEY , type_props , params , param_count ) ; if ( res != TEE_SUCCESS ) goto out ; switch ( o -> info . objectType ) { case TEE_TYPE_AES : case TEE_TYPE_DES : case TEE_TYPE_DES3 : case TEE_TYPE_HMAC_MD5 : case TEE_TYPE_HMAC_SHA1 : case TEE_TYPE_HMAC_SHA224 : case TEE_TYPE_HMAC_SHA256 : case TEE_TYPE_HMAC_SHA384 : case TEE_TYPE_HMAC_SHA512 : case TEE_TYPE_GENERIC_SECRET : byte_size = key_size / 8 ; if ( o -> info . objectType == TEE_TYPE_DES || o -> info . objectType == TEE_TYPE_DES3 ) { byte_size = ( key_size + key_size / 7 ) / 8 ; } key = ( struct tee_cryp_obj_secret * ) o -> attr ; if ( byte_size > key -> alloc_size ) { res = TEE_ERROR_EXCESS_DATA ; goto out ; } res = crypto_rng_read ( ( void * ) ( key + 1 ) , byte_size ) ; if ( res != TEE_SUCCESS ) goto out ; key -> key_size = byte_size ; o -> have_attrs = ( 1 << type_props -> num_type_attrs ) - 1 ; break ; case TEE_TYPE_RSA_KEYPAIR : res = tee_svc_obj_generate_key_rsa ( o , type_props , key_size , params , param_count ) ; if ( res != TEE_SUCCESS ) goto out ; break ; case TEE_TYPE_DSA_KEYPAIR : res = tee_svc_obj_generate_key_dsa ( o , type_props , key_size ) ; if ( res != TEE_SUCCESS ) goto out ; break ; case TEE_TYPE_DH_KEYPAIR : res = tee_svc_obj_generate_key_dh ( o , type_props , key_size , params , param_count ) ; if ( res != TEE_SUCCESS ) goto out ; break ; case TEE_TYPE_ECDSA_KEYPAIR : case TEE_TYPE_ECDH_KEYPAIR : res = tee_svc_obj_generate_key_ecc ( o , type_props , key_size , params , param_count ) ; if ( res != TEE_SUCCESS ) goto out ; break ; default : res = TEE_ERROR_BAD_FORMAT ; } out : free ( params ) ; if ( res == TEE_SUCCESS ) { o -> info . keySize = key_size ; o -> info . handleFlags |= TEE_HANDLE_FLAG_INITIALIZED ; } return res ; }
CWE-119 TEE_Result syscall_cryp_obj_populate ( unsigned long obj , struct utee_attribute * usr_attrs , unsigned long attr_count ) { TEE_Result res ; struct tee_ta_session * sess ; struct tee_obj * o ; const struct tee_cryp_obj_type_props * type_props ; TEE_Attribute * attrs = NULL ; res = tee_ta_get_current_session ( & sess ) ; if ( res != TEE_SUCCESS ) return res ; res = tee_obj_get ( to_user_ta_ctx ( sess -> ctx ) , tee_svc_uref_to_vaddr ( obj ) , & o ) ; if ( res != TEE_SUCCESS ) return res ; if ( ( o -> info . handleFlags & TEE_HANDLE_FLAG_PERSISTENT ) != 0 ) return TEE_ERROR_BAD_PARAMETERS ; if ( ( o -> info . handleFlags & TEE_HANDLE_FLAG_INITIALIZED ) != 0 ) return TEE_ERROR_BAD_PARAMETERS ; type_props = tee_svc_find_type_props ( o -> info . objectType ) ; if ( ! type_props ) return TEE_ERROR_NOT_IMPLEMENTED ; <S2SV_StartBug> attrs = malloc ( sizeof ( TEE_Attribute ) * attr_count ) ; <S2SV_EndBug> if ( ! attrs ) return TEE_ERROR_OUT_OF_MEMORY ; res = copy_in_attrs ( to_user_ta_ctx ( sess -> ctx ) , usr_attrs , attr_count , attrs ) ; if ( res != TEE_SUCCESS ) goto out ; res = tee_svc_cryp_check_attr ( ATTR_USAGE_POPULATE , type_props , attrs , attr_count ) ; if ( res != TEE_SUCCESS ) goto out ; res = tee_svc_cryp_obj_populate_type ( o , type_props , attrs , attr_count ) ; if ( res == TEE_SUCCESS ) o -> info . handleFlags |= TEE_HANDLE_FLAG_INITIALIZED ; out : free ( attrs ) ; return res ; }
CWE-119 static TEE_Result tee_svc_copy_param ( struct tee_ta_session * sess , struct tee_ta_session * called_sess , struct utee_params * callee_params , struct tee_ta_param * param , void * tmp_buf_va [ TEE_NUM_PARAMS ] , struct mobj * * mobj_tmp ) { size_t n ; TEE_Result res ; size_t req_mem = 0 ; size_t s ; uint8_t * dst = 0 ; bool ta_private_memref [ TEE_NUM_PARAMS ] ; struct user_ta_ctx * utc = to_user_ta_ctx ( sess -> ctx ) ; void * va ; size_t dst_offs ; if ( ! callee_params ) { memset ( param , 0 , sizeof ( * param ) ) ; } else { res = tee_mmu_check_access_rights ( utc , TEE_MEMORY_ACCESS_READ | TEE_MEMORY_ACCESS_ANY_OWNER , ( uaddr_t ) callee_params , sizeof ( struct utee_params ) ) ; if ( res != TEE_SUCCESS ) return res ; <S2SV_StartBug> utee_param_to_param ( param , callee_params ) ; <S2SV_EndBug> } if ( called_sess && is_pseudo_ta_ctx ( called_sess -> ctx ) ) { return TEE_SUCCESS ; } for ( n = 0 ; n < TEE_NUM_PARAMS ; n ++ ) { ta_private_memref [ n ] = false ; switch ( TEE_PARAM_TYPE_GET ( param -> types , n ) ) { case TEE_PARAM_TYPE_MEMREF_INPUT : case TEE_PARAM_TYPE_MEMREF_OUTPUT : case TEE_PARAM_TYPE_MEMREF_INOUT : va = ( void * ) param -> u [ n ] . mem . offs ; s = param -> u [ n ] . mem . size ; if ( ! va ) { if ( s ) return TEE_ERROR_BAD_PARAMETERS ; break ; } if ( tee_mmu_is_vbuf_inside_ta_private ( utc , va , s ) ) { s = ROUNDUP ( s , sizeof ( uint32_t ) ) ; if ( ADD_OVERFLOW ( req_mem , s , & req_mem ) ) return TEE_ERROR_BAD_PARAMETERS ; ta_private_memref [ n ] = true ; break ; } res = tee_mmu_vbuf_to_mobj_offs ( utc , va , s , & param -> u [ n ] . mem . mobj , & param -> u [ n ] . mem . offs ) ; if ( res != TEE_SUCCESS ) return res ; break ; default : break ; } } if ( req_mem == 0 ) return TEE_SUCCESS ; res = alloc_temp_sec_mem ( req_mem , mobj_tmp , & dst ) ; if ( res != TEE_SUCCESS ) return res ; dst_offs = 0 ; for ( n = 0 ; n < TEE_NUM_PARAMS ; n ++ ) { if ( ! ta_private_memref [ n ] ) continue ; s = ROUNDUP ( param -> u [ n ] . mem . size , sizeof ( uint32_t ) ) ; switch ( TEE_PARAM_TYPE_GET ( param -> types , n ) ) { case TEE_PARAM_TYPE_MEMREF_INPUT : case TEE_PARAM_TYPE_MEMREF_INOUT : va = ( void * ) param -> u [ n ] . mem . offs ; if ( va ) { res = tee_svc_copy_from_user ( dst , va , param -> u [ n ] . mem . size ) ; if ( res != TEE_SUCCESS ) return res ; param -> u [ n ] . mem . offs = dst_offs ; param -> u [ n ] . mem . mobj = * mobj_tmp ; tmp_buf_va [ n ] = dst ; dst += s ; dst_offs += s ; } break ; case TEE_PARAM_TYPE_MEMREF_OUTPUT : va = ( void * ) param -> u [ n ] . mem . offs ; if ( va ) { param -> u [ n ] . mem . offs = dst_offs ; param -> u [ n ] . mem . mobj = * mobj_tmp ; tmp_buf_va [ n ] = dst ; dst += s ; dst_offs += s ; } break ; default : continue ; } } return TEE_SUCCESS ; }
CWE-119 <S2SV_StartBug> static void utee_param_to_param ( struct tee_ta_param * p , struct utee_params * up ) <S2SV_EndBug> { size_t n ; uint32_t types = up -> types ; p -> types = types ; for ( n = 0 ; n < TEE_NUM_PARAMS ; n ++ ) { uintptr_t a = up -> vals [ n * 2 ] ; size_t b = up -> vals [ n * 2 + 1 ] ; <S2SV_StartBug> switch ( TEE_PARAM_TYPE_GET ( types , n ) ) { <S2SV_EndBug> <S2SV_StartBug> case TEE_PARAM_TYPE_MEMREF_INPUT : <S2SV_EndBug> case TEE_PARAM_TYPE_MEMREF_OUTPUT : case TEE_PARAM_TYPE_MEMREF_INOUT : p -> u [ n ] . mem . mobj = & mobj_virt ; p -> u [ n ] . mem . offs = a ; p -> u [ n ] . mem . size = b ; <S2SV_StartBug> break ; <S2SV_EndBug> case TEE_PARAM_TYPE_VALUE_INPUT : case TEE_PARAM_TYPE_VALUE_INOUT : p -> u [ n ] . val . a = a ; p -> u [ n ] . val . b = b ; break ; default : memset ( & p -> u [ n ] , 0 , sizeof ( p -> u [ n ] ) ) ; break ; } <S2SV_StartBug> } <S2SV_EndBug> }
CWE-119 static TEE_Result set_rmem_param ( const struct optee_msg_param_rmem * rmem , struct param_mem * mem ) <S2SV_StartBug> { <S2SV_EndBug> uint64_t shm_ref = READ_ONCE ( rmem -> shm_ref ) ; mem -> mobj = mobj_reg_shm_get_by_cookie ( shm_ref ) ; if ( ! mem -> mobj ) return TEE_ERROR_BAD_PARAMETERS ; mem -> offs = READ_ONCE ( rmem -> offs ) ; mem -> size = READ_ONCE ( rmem -> size ) ; <S2SV_StartBug> return TEE_SUCCESS ; <S2SV_EndBug> }
CWE-119 static int cac_get_serial_nr_from_CUID ( sc_card_t * card , sc_serial_number_t * serial ) { cac_private_data_t * priv = CAC_DATA ( card ) ; SC_FUNC_CALLED ( card -> ctx , SC_LOG_DEBUG_NORMAL ) ; if ( card -> serialnr . len ) { * serial = card -> serialnr ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_NORMAL , SC_SUCCESS ) ; } if ( priv -> cac_id_len ) { serial -> len = MIN ( priv -> cac_id_len , SC_MAX_SERIALNR ) ; <S2SV_StartBug> memcpy ( serial -> value , priv -> cac_id , priv -> cac_id_len ) ; <S2SV_EndBug> SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_NORMAL , SC_SUCCESS ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_NORMAL , SC_ERROR_FILE_NOT_FOUND ) ; }
CWE-119 static int muscle_list_files ( sc_card_t * card , u8 * buf , size_t bufLen ) { muscle_private_t * priv = MUSCLE_DATA ( card ) ; mscfs_t * fs = priv -> fs ; int x ; int count = 0 ; mscfs_check_cache ( priv -> fs ) ; for ( x = 0 ; x < fs -> cache . size ; x ++ ) { u8 * oid = fs -> cache . array [ x ] . objectId . id ; <S2SV_StartBug> sc_debug ( card -> ctx , SC_LOG_DEBUG_NORMAL , <S2SV_EndBug> "FILE:<S2SV_blank>%02X%02X%02X%02X\\n" , oid [ 0 ] , oid [ 1 ] , oid [ 2 ] , oid [ 3 ] ) ; if ( 0 == memcmp ( fs -> currentPath , oid , 2 ) ) { buf [ 0 ] = oid [ 2 ] ; buf [ 1 ] = oid [ 3 ] ; if ( buf [ 0 ] == 0x00 && buf [ 1 ] == 0x00 ) continue ; buf += 2 ; count += 2 ; <S2SV_StartBug> } <S2SV_EndBug> } return count ; }
CWE-119 static int tcos_select_file ( sc_card_t * card , const sc_path_t * in_path , sc_file_t * * file_out ) { sc_context_t * ctx ; sc_apdu_t apdu ; sc_file_t * file = NULL ; u8 buf [ SC_MAX_APDU_BUFFER_SIZE ] , pathbuf [ SC_MAX_PATH_SIZE ] , * path = pathbuf ; unsigned int i ; int r , pathlen ; assert ( card != NULL && in_path != NULL ) ; ctx = card -> ctx ; memcpy ( path , in_path -> value , in_path -> len ) ; pathlen = in_path -> len ; sc_format_apdu ( card , & apdu , SC_APDU_CASE_4_SHORT , 0xA4 , 0 , 0x04 ) ; switch ( in_path -> type ) { case SC_PATH_TYPE_FILE_ID : if ( pathlen != 2 ) return SC_ERROR_INVALID_ARGUMENTS ; case SC_PATH_TYPE_FROM_CURRENT : apdu . p1 = 9 ; break ; case SC_PATH_TYPE_DF_NAME : apdu . p1 = 4 ; break ; case SC_PATH_TYPE_PATH : apdu . p1 = 8 ; if ( pathlen >= 2 && memcmp ( path , "\\x3F\\x00" , 2 ) == 0 ) path += 2 , pathlen -= 2 ; if ( pathlen == 0 ) apdu . p1 = 0 ; break ; case SC_PATH_TYPE_PARENT : apdu . p1 = 3 ; pathlen = 0 ; break ; default : SC_FUNC_RETURN ( ctx , SC_LOG_DEBUG_VERBOSE , SC_ERROR_INVALID_ARGUMENTS ) ; } if ( pathlen == 0 ) apdu . cse = SC_APDU_CASE_2_SHORT ; apdu . lc = pathlen ; apdu . data = path ; apdu . datalen = pathlen ; if ( file_out != NULL ) { apdu . resp = buf ; apdu . resplen = sizeof ( buf ) ; apdu . le = 256 ; } else { apdu . resplen = 0 ; apdu . le = 0 ; apdu . p2 = 0x0C ; apdu . cse = ( pathlen == 0 ) ? SC_APDU_CASE_1 : SC_APDU_CASE_3_SHORT ; } r = sc_transmit_apdu ( card , & apdu ) ; SC_TEST_RET ( ctx , SC_LOG_DEBUG_NORMAL , r , "APDU<S2SV_blank>transmit<S2SV_blank>failed" ) ; r = sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ; if ( r || file_out == NULL ) SC_FUNC_RETURN ( ctx , SC_LOG_DEBUG_VERBOSE , r ) ; if ( apdu . resplen < 1 || apdu . resp [ 0 ] != 0x62 ) { sc_debug ( ctx , SC_LOG_DEBUG_NORMAL , "received<S2SV_blank>invalid<S2SV_blank>template<S2SV_blank>%02X\\n" , apdu . resp [ 0 ] ) ; SC_FUNC_RETURN ( ctx , SC_LOG_DEBUG_VERBOSE , SC_ERROR_UNKNOWN_DATA_RECEIVED ) ; } file = sc_file_new ( ) ; if ( file == NULL ) SC_FUNC_RETURN ( ctx , SC_LOG_DEBUG_NORMAL , SC_ERROR_OUT_OF_MEMORY ) ; * file_out = file ; file -> path = * in_path ; for ( i = 2 ; i + 1 < apdu . resplen && i + 1 + apdu . resp [ i + 1 ] < apdu . resplen ; i += 2 + apdu . resp [ i + 1 ] ) { <S2SV_StartBug> int j , len = apdu . resp [ i + 1 ] ; <S2SV_EndBug> unsigned char type = apdu . resp [ i ] , * d = apdu . resp + i + 2 ; switch ( type ) { case 0x80 : case 0x81 : file -> size = 0 ; for ( j = 0 ; j < len ; ++ j ) file -> size = ( file -> size << 8 ) | d [ j ] ; break ; case 0x82 : file -> shareable = ( d [ 0 ] & 0x40 ) ? 1 : 0 ; file -> ef_structure = d [ 0 ] & 7 ; switch ( ( d [ 0 ] >> 3 ) & 7 ) { case 0 : file -> type = SC_FILE_TYPE_WORKING_EF ; break ; case 7 : file -> type = SC_FILE_TYPE_DF ; break ; default : sc_debug ( ctx , SC_LOG_DEBUG_NORMAL , "invalid<S2SV_blank>file<S2SV_blank>type<S2SV_blank>%02X<S2SV_blank>in<S2SV_blank>file<S2SV_blank>descriptor\\n" , d [ 0 ] ) ; SC_FUNC_RETURN ( ctx , SC_LOG_DEBUG_VERBOSE , SC_ERROR_UNKNOWN_DATA_RECEIVED ) ; } break ; case 0x83 : file -> id = ( d [ 0 ] << 8 ) | d [ 1 ] ; break ; case 0x84 : <S2SV_StartBug> memcpy ( file -> name , d , len ) ; <S2SV_EndBug> <S2SV_StartBug> file -> namelen = len ; <S2SV_EndBug> break ; case 0x86 : sc_file_set_sec_attr ( file , d , len ) ; break ; default : if ( len > 0 ) sc_file_set_prop_attr ( file , d , len ) ; } } file -> magic = SC_FILE_MAGIC ; parse_sec_attr ( card , file , file -> sec_attr , file -> sec_attr_len ) ; return 0 ; }
CWE-119 static int sc_pkcs15emu_esteid_init ( sc_pkcs15_card_t * p15card ) { sc_card_t * card = p15card -> card ; unsigned char buff [ 128 ] ; int r , i ; size_t field_length = 0 , modulus_length = 0 ; sc_path_t tmppath ; set_string ( & p15card -> tokeninfo -> label , "ID-kaart" ) ; set_string ( & p15card -> tokeninfo -> manufacturer_id , "AS<S2SV_blank>Sertifitseerimiskeskus" ) ; sc_format_path ( "3f00eeee5044" , & tmppath ) ; r = sc_select_file ( card , & tmppath , NULL ) ; SC_TEST_RET ( card -> ctx , SC_LOG_DEBUG_NORMAL , r , "select<S2SV_blank>esteid<S2SV_blank>PD<S2SV_blank>failed" ) ; r = sc_read_record ( card , SC_ESTEID_PD_DOCUMENT_NR , buff , sizeof ( buff ) , SC_RECORD_BY_REC_NR ) ; SC_TEST_RET ( card -> ctx , SC_LOG_DEBUG_NORMAL , r , "read<S2SV_blank>document<S2SV_blank>number<S2SV_blank>failed" ) ; <S2SV_StartBug> buff [ r ] = '\\0' ; <S2SV_EndBug> set_string ( & p15card -> tokeninfo -> serial_number , ( const char * ) buff ) ; p15card -> tokeninfo -> flags = SC_PKCS15_TOKEN_PRN_GENERATION | SC_PKCS15_TOKEN_EID_COMPLIANT | SC_PKCS15_TOKEN_READONLY ; for ( i = 0 ; i < 2 ; i ++ ) { static const char * esteid_cert_names [ 2 ] = { "Isikutuvastus" , "Allkirjastamine" } ; static char const * esteid_cert_paths [ 2 ] = { "3f00eeeeaace" , "3f00eeeeddce" } ; static int esteid_cert_ids [ 2 ] = { 1 , 2 } ; struct sc_pkcs15_cert_info cert_info ; struct sc_pkcs15_object cert_obj ; memset ( & cert_info , 0 , sizeof ( cert_info ) ) ; memset ( & cert_obj , 0 , sizeof ( cert_obj ) ) ; cert_info . id . value [ 0 ] = esteid_cert_ids [ i ] ; cert_info . id . len = 1 ; sc_format_path ( esteid_cert_paths [ i ] , & cert_info . path ) ; strlcpy ( cert_obj . label , esteid_cert_names [ i ] , sizeof ( cert_obj . label ) ) ; r = sc_pkcs15emu_add_x509_cert ( p15card , & cert_obj , & cert_info ) ; if ( r < 0 ) return SC_ERROR_INTERNAL ; if ( i == 0 ) { sc_pkcs15_cert_t * cert = NULL ; r = sc_pkcs15_read_certificate ( p15card , & cert_info , & cert ) ; if ( r < 0 ) return SC_ERROR_INTERNAL ; if ( cert -> key -> algorithm == SC_ALGORITHM_EC ) field_length = cert -> key -> u . ec . params . field_length ; else modulus_length = cert -> key -> u . rsa . modulus . len * 8 ; if ( r == SC_SUCCESS ) { static const struct sc_object_id cn_oid = { { 2 , 5 , 4 , 3 , - 1 } } ; u8 * cn_name = NULL ; size_t cn_len = 0 ; sc_pkcs15_get_name_from_dn ( card -> ctx , cert -> subject , cert -> subject_len , & cn_oid , & cn_name , & cn_len ) ; if ( cn_len > 0 ) { char * token_name = malloc ( cn_len + 1 ) ; if ( token_name ) { memcpy ( token_name , cn_name , cn_len ) ; token_name [ cn_len ] = '\\0' ; set_string ( & p15card -> tokeninfo -> label , ( const char * ) token_name ) ; free ( token_name ) ; } } free ( cn_name ) ; sc_pkcs15_free_certificate ( cert ) ; } } } sc_format_path ( "3f000016" , & tmppath ) ; r = sc_select_file ( card , & tmppath , NULL ) ; if ( r < 0 ) return SC_ERROR_INTERNAL ; for ( i = 0 ; i < 3 ; i ++ ) { unsigned char tries_left ; static const char * esteid_pin_names [ 3 ] = { "PIN1" , "PIN2" , "PUK" } ; static const int esteid_pin_min [ 3 ] = { 4 , 5 , 8 } ; static const int esteid_pin_ref [ 3 ] = { 1 , 2 , 0 } ; static const int esteid_pin_authid [ 3 ] = { 1 , 2 , 3 } ; static const int esteid_pin_flags [ 3 ] = { 0 , 0 , SC_PKCS15_PIN_FLAG_UNBLOCKING_PIN } ; struct sc_pkcs15_auth_info pin_info ; struct sc_pkcs15_object pin_obj ; memset ( & pin_info , 0 , sizeof ( pin_info ) ) ; memset ( & pin_obj , 0 , sizeof ( pin_obj ) ) ; r = sc_read_record ( card , i + 1 , buff , sizeof ( buff ) , SC_RECORD_BY_REC_NR ) ; if ( r < 0 ) return SC_ERROR_INTERNAL ; tries_left = buff [ 5 ] ; pin_info . auth_id . len = 1 ; pin_info . auth_id . value [ 0 ] = esteid_pin_authid [ i ] ; pin_info . auth_type = SC_PKCS15_PIN_AUTH_TYPE_PIN ; pin_info . attrs . pin . reference = esteid_pin_ref [ i ] ; pin_info . attrs . pin . flags = esteid_pin_flags [ i ] ; pin_info . attrs . pin . type = SC_PKCS15_PIN_TYPE_ASCII_NUMERIC ; pin_info . attrs . pin . min_length = esteid_pin_min [ i ] ; pin_info . attrs . pin . stored_length = 12 ; pin_info . attrs . pin . max_length = 12 ; pin_info . attrs . pin . pad_char = '\\0' ; pin_info . tries_left = ( int ) tries_left ; pin_info . max_tries = 3 ; strlcpy ( pin_obj . label , esteid_pin_names [ i ] , sizeof ( pin_obj . label ) ) ; pin_obj . flags = esteid_pin_flags [ i ] ; if ( i < 2 ) { pin_obj . auth_id . len = 1 ; pin_obj . auth_id . value [ 0 ] = 3 ; } r = sc_pkcs15emu_add_pin_obj ( p15card , & pin_obj , & pin_info ) ; if ( r < 0 ) return SC_ERROR_INTERNAL ; } for ( i = 0 ; i < 2 ; i ++ ) { static int prkey_pin [ 2 ] = { 1 , 2 } ; static const char * prkey_name [ 2 ] = { "Isikutuvastus" , "Allkirjastamine" } ; struct sc_pkcs15_prkey_info prkey_info ; struct sc_pkcs15_object prkey_obj ; memset ( & prkey_info , 0 , sizeof ( prkey_info ) ) ; memset ( & prkey_obj , 0 , sizeof ( prkey_obj ) ) ; prkey_info . id . len = 1 ; prkey_info . id . value [ 0 ] = prkey_pin [ i ] ; prkey_info . native = 1 ; prkey_info . key_reference = i + 1 ; prkey_info . field_length = field_length ; prkey_info . modulus_length = modulus_length ; if ( i == 1 ) prkey_info . usage = SC_PKCS15_PRKEY_USAGE_NONREPUDIATION ; else if ( field_length > 0 ) prkey_info . usage = SC_PKCS15_PRKEY_USAGE_SIGN | SC_PKCS15_PRKEY_USAGE_DERIVE ; else prkey_info . usage = SC_PKCS15_PRKEY_USAGE_SIGN | SC_PKCS15_PRKEY_USAGE_ENCRYPT | SC_PKCS15_PRKEY_USAGE_DECRYPT ; strlcpy ( prkey_obj . label , prkey_name [ i ] , sizeof ( prkey_obj . label ) ) ; prkey_obj . auth_id . len = 1 ; prkey_obj . auth_id . value [ 0 ] = prkey_pin [ i ] ; prkey_obj . user_consent = 0 ; prkey_obj . flags = SC_PKCS15_CO_FLAG_PRIVATE ; if ( field_length > 0 ) r = sc_pkcs15emu_add_ec_prkey ( p15card , & prkey_obj , & prkey_info ) ; else r = sc_pkcs15emu_add_rsa_prkey ( p15card , & prkey_obj , & prkey_info ) ; if ( r < 0 ) return SC_ERROR_INTERNAL ; } return SC_SUCCESS ; }
CWE-119 static int gemsafe_get_cert_len ( sc_card_t * card ) { int r ; u8 ibuf [ GEMSAFE_MAX_OBJLEN ] ; u8 * iptr ; struct sc_path path ; struct sc_file * file ; size_t objlen , certlen ; unsigned int ind , i = 0 ; sc_format_path ( GEMSAFE_PATH , & path ) ; r = sc_select_file ( card , & path , & file ) ; if ( r != SC_SUCCESS || ! file ) return SC_ERROR_INTERNAL ; r = sc_read_binary ( card , 0 , ibuf , GEMSAFE_READ_QUANTUM , 0 ) ; if ( r < 0 ) return SC_ERROR_INTERNAL ; objlen = ( ( ( size_t ) ibuf [ 0 ] ) << 8 ) | ibuf [ 1 ] ; sc_log ( card -> ctx , "Stored<S2SV_blank>object<S2SV_blank>is<S2SV_blank>of<S2SV_blank>size:<S2SV_blank>%" SC_FORMAT_LEN_SIZE_T "u" , objlen ) ; if ( objlen < 1 || objlen > GEMSAFE_MAX_OBJLEN ) { sc_log ( card -> ctx , "Invalid<S2SV_blank>object<S2SV_blank>size:<S2SV_blank>%" SC_FORMAT_LEN_SIZE_T "u" , objlen ) ; return SC_ERROR_INTERNAL ; } ind = 2 ; <S2SV_StartBug> while ( ibuf [ ind ] == 0x01 ) { <S2SV_EndBug> if ( ibuf [ ind + 1 ] == 0xFE ) { gemsafe_prkeys [ i ] . ref = ibuf [ ind + 4 ] ; sc_log ( card -> ctx , "Key<S2SV_blank>container<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>allocated<S2SV_blank>and<S2SV_blank>uses<S2SV_blank>key_ref<S2SV_blank>%d" , i + 1 , gemsafe_prkeys [ i ] . ref ) ; ind += 9 ; } else { gemsafe_prkeys [ i ] . label = NULL ; gemsafe_cert [ i ] . label = NULL ; sc_log ( card -> ctx , "Key<S2SV_blank>container<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>unallocated" , i + 1 ) ; ind += 8 ; } i ++ ; } for ( ; i < gemsafe_cert_max ; i ++ ) { gemsafe_prkeys [ i ] . label = NULL ; gemsafe_cert [ i ] . label = NULL ; } iptr = ibuf + GEMSAFE_READ_QUANTUM ; while ( ( size_t ) ( iptr - ibuf ) < objlen ) { r = sc_read_binary ( card , iptr - ibuf , iptr , MIN ( GEMSAFE_READ_QUANTUM , objlen - ( iptr - ibuf ) ) , 0 ) ; if ( r < 0 ) { sc_log ( card -> ctx , "Could<S2SV_blank>not<S2SV_blank>read<S2SV_blank>cert<S2SV_blank>object" ) ; return SC_ERROR_INTERNAL ; } iptr += GEMSAFE_READ_QUANTUM ; } i = 0 ; while ( ind < objlen - 1 ) { if ( ibuf [ ind ] == 0x30 && ibuf [ ind + 1 ] == 0x82 ) { while ( i < gemsafe_cert_max && gemsafe_cert [ i ] . label == NULL ) i ++ ; if ( i == gemsafe_cert_max ) { sc_log ( card -> ctx , "Warning:<S2SV_blank>Found<S2SV_blank>orphaned<S2SV_blank>certificate<S2SV_blank>at<S2SV_blank>offset<S2SV_blank>%d" , ind ) ; return SC_SUCCESS ; } if ( ind + 3 >= sizeof ibuf ) return SC_ERROR_INVALID_DATA ; certlen = ( ( ( ( size_t ) ibuf [ ind + 2 ] ) << 8 ) | ibuf [ ind + 3 ] ) + 4 ; sc_log ( card -> ctx , "Found<S2SV_blank>certificate<S2SV_blank>of<S2SV_blank>key<S2SV_blank>container<S2SV_blank>%d<S2SV_blank>at<S2SV_blank>offset<S2SV_blank>%d,<S2SV_blank>len<S2SV_blank>%" SC_FORMAT_LEN_SIZE_T "u" , i + 1 , ind , certlen ) ; gemsafe_cert [ i ] . index = ind ; gemsafe_cert [ i ] . count = certlen ; ind += certlen ; i ++ ; } else ind ++ ; } for ( ; i < gemsafe_cert_max ; i ++ ) { if ( gemsafe_cert [ i ] . label ) { sc_log ( card -> ctx , "Warning:<S2SV_blank>Certificate<S2SV_blank>of<S2SV_blank>key<S2SV_blank>container<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>missing" , i + 1 ) ; gemsafe_prkeys [ i ] . label = NULL ; gemsafe_cert [ i ] . label = NULL ; } } return SC_SUCCESS ; }
CWE-119 static int sc_pkcs15emu_sc_hsm_init ( sc_pkcs15_card_t * p15card ) { sc_card_t * card = p15card -> card ; sc_hsm_private_data_t * priv = ( sc_hsm_private_data_t * ) card -> drv_data ; sc_file_t * file = NULL ; sc_path_t path ; u8 filelist [ MAX_EXT_APDU_LENGTH ] ; int filelistlength ; int r , i ; sc_cvc_t devcert ; struct sc_app_info * appinfo ; struct sc_pkcs15_auth_info pin_info ; struct sc_pkcs15_object pin_obj ; struct sc_pin_cmd_data pindata ; u8 efbin [ 1024 ] ; u8 * ptr ; size_t len ; LOG_FUNC_CALLED ( card -> ctx ) ; appinfo = calloc ( 1 , sizeof ( struct sc_app_info ) ) ; if ( appinfo == NULL ) { LOG_FUNC_RETURN ( card -> ctx , SC_ERROR_OUT_OF_MEMORY ) ; } appinfo -> aid = sc_hsm_aid ; appinfo -> ddo . aid = sc_hsm_aid ; p15card -> app = appinfo ; sc_path_set ( & path , SC_PATH_TYPE_DF_NAME , sc_hsm_aid . value , sc_hsm_aid . len , 0 , 0 ) ; r = sc_select_file ( card , & path , & file ) ; LOG_TEST_RET ( card -> ctx , r , "Could<S2SV_blank>not<S2SV_blank>select<S2SV_blank>SmartCard-HSM<S2SV_blank>application" ) ; p15card -> card -> version . hw_major = 24 ; p15card -> card -> version . hw_minor = 13 ; if ( file && file -> prop_attr && file -> prop_attr_len >= 2 ) { p15card -> card -> version . fw_major = file -> prop_attr [ file -> prop_attr_len - 2 ] ; p15card -> card -> version . fw_minor = file -> prop_attr [ file -> prop_attr_len - 1 ] ; } sc_file_free ( file ) ; if ( priv -> EF_C_DevAut && priv -> EF_C_DevAut_len ) { ptr = priv -> EF_C_DevAut ; len = priv -> EF_C_DevAut_len ; } else { len = sizeof efbin ; r = read_file ( p15card , ( u8 * ) "\\x2F\\x02" , efbin , & len , 1 ) ; LOG_TEST_RET ( card -> ctx , r , "Skipping<S2SV_blank>optional<S2SV_blank>EF.C_DevAut" ) ; <S2SV_StartBug> ptr = realloc ( priv -> EF_C_DevAut , len ) ; <S2SV_EndBug> if ( ptr ) { memcpy ( ptr , efbin , len ) ; priv -> EF_C_DevAut = ptr ; <S2SV_StartBug> priv -> EF_C_DevAut_len = len ; <S2SV_EndBug> } ptr = efbin ; } memset ( & devcert , 0 , sizeof ( devcert ) ) ; r = sc_pkcs15emu_sc_hsm_decode_cvc ( p15card , ( const u8 * * ) & ptr , & len , & devcert ) ; LOG_TEST_RET ( card -> ctx , r , "Could<S2SV_blank>not<S2SV_blank>decode<S2SV_blank>EF.C_DevAut" ) ; sc_pkcs15emu_sc_hsm_read_tokeninfo ( p15card ) ; if ( p15card -> tokeninfo -> label == NULL ) { if ( p15card -> card -> type == SC_CARD_TYPE_SC_HSM_GOID || p15card -> card -> type == SC_CARD_TYPE_SC_HSM_SOC ) { p15card -> tokeninfo -> label = strdup ( "GoID" ) ; } else { p15card -> tokeninfo -> label = strdup ( "SmartCard-HSM" ) ; } if ( p15card -> tokeninfo -> label == NULL ) LOG_FUNC_RETURN ( card -> ctx , SC_ERROR_OUT_OF_MEMORY ) ; } if ( ( p15card -> tokeninfo -> manufacturer_id != NULL ) && ! strcmp ( "(unknown)" , p15card -> tokeninfo -> manufacturer_id ) ) { free ( p15card -> tokeninfo -> manufacturer_id ) ; p15card -> tokeninfo -> manufacturer_id = NULL ; } if ( p15card -> tokeninfo -> manufacturer_id == NULL ) { if ( p15card -> card -> type == SC_CARD_TYPE_SC_HSM_GOID || p15card -> card -> type == SC_CARD_TYPE_SC_HSM_SOC ) { p15card -> tokeninfo -> manufacturer_id = strdup ( "Bundesdruckerei<S2SV_blank>GmbH" ) ; } else { p15card -> tokeninfo -> manufacturer_id = strdup ( "www.CardContact.de" ) ; } if ( p15card -> tokeninfo -> manufacturer_id == NULL ) LOG_FUNC_RETURN ( card -> ctx , SC_ERROR_OUT_OF_MEMORY ) ; } appinfo -> label = strdup ( p15card -> tokeninfo -> label ) ; if ( appinfo -> label == NULL ) LOG_FUNC_RETURN ( card -> ctx , SC_ERROR_OUT_OF_MEMORY ) ; len = strnlen ( devcert . chr , sizeof devcert . chr ) ; assert ( len >= 8 ) ; len -= 5 ; p15card -> tokeninfo -> serial_number = calloc ( len + 1 , 1 ) ; if ( p15card -> tokeninfo -> serial_number == NULL ) LOG_FUNC_RETURN ( card -> ctx , SC_ERROR_OUT_OF_MEMORY ) ; memcpy ( p15card -> tokeninfo -> serial_number , devcert . chr , len ) ; * ( p15card -> tokeninfo -> serial_number + len ) = 0 ; sc_hsm_set_serialnr ( card , p15card -> tokeninfo -> serial_number ) ; sc_pkcs15emu_sc_hsm_free_cvc ( & devcert ) ; memset ( & pin_info , 0 , sizeof ( pin_info ) ) ; memset ( & pin_obj , 0 , sizeof ( pin_obj ) ) ; pin_info . auth_id . len = 1 ; pin_info . auth_id . value [ 0 ] = 1 ; pin_info . path . aid = sc_hsm_aid ; pin_info . auth_type = SC_PKCS15_PIN_AUTH_TYPE_PIN ; pin_info . attrs . pin . reference = 0x81 ; pin_info . attrs . pin . flags = SC_PKCS15_PIN_FLAG_LOCAL | SC_PKCS15_PIN_FLAG_INITIALIZED | SC_PKCS15_PIN_FLAG_EXCHANGE_REF_DATA ; pin_info . attrs . pin . type = SC_PKCS15_PIN_TYPE_ASCII_NUMERIC ; pin_info . attrs . pin . min_length = 6 ; pin_info . attrs . pin . stored_length = 0 ; pin_info . attrs . pin . max_length = 15 ; pin_info . attrs . pin . pad_char = '\\0' ; pin_info . tries_left = 3 ; pin_info . max_tries = 3 ; pin_obj . auth_id . len = 1 ; pin_obj . auth_id . value [ 0 ] = 2 ; strlcpy ( pin_obj . label , "UserPIN" , sizeof ( pin_obj . label ) ) ; pin_obj . flags = SC_PKCS15_CO_FLAG_PRIVATE | SC_PKCS15_CO_FLAG_MODIFIABLE ; r = sc_pkcs15emu_add_pin_obj ( p15card , & pin_obj , & pin_info ) ; if ( r < 0 ) LOG_FUNC_RETURN ( card -> ctx , r ) ; memset ( & pin_info , 0 , sizeof ( pin_info ) ) ; memset ( & pin_obj , 0 , sizeof ( pin_obj ) ) ; pin_info . auth_id . len = 1 ; pin_info . auth_id . value [ 0 ] = 2 ; pin_info . path . aid = sc_hsm_aid ; pin_info . auth_type = SC_PKCS15_PIN_AUTH_TYPE_PIN ; pin_info . attrs . pin . reference = 0x88 ; pin_info . attrs . pin . flags = SC_PKCS15_PIN_FLAG_LOCAL | SC_PKCS15_PIN_FLAG_INITIALIZED | SC_PKCS15_PIN_FLAG_UNBLOCK_DISABLED | SC_PKCS15_PIN_FLAG_SO_PIN ; pin_info . attrs . pin . type = SC_PKCS15_PIN_TYPE_BCD ; pin_info . attrs . pin . min_length = 16 ; pin_info . attrs . pin . stored_length = 0 ; pin_info . attrs . pin . max_length = 16 ; pin_info . attrs . pin . pad_char = '\\0' ; pin_info . tries_left = 15 ; pin_info . max_tries = 15 ; strlcpy ( pin_obj . label , "SOPIN" , sizeof ( pin_obj . label ) ) ; pin_obj . flags = SC_PKCS15_CO_FLAG_PRIVATE ; r = sc_pkcs15emu_add_pin_obj ( p15card , & pin_obj , & pin_info ) ; if ( r < 0 ) LOG_FUNC_RETURN ( card -> ctx , r ) ; if ( card -> type == SC_CARD_TYPE_SC_HSM_SOC || card -> type == SC_CARD_TYPE_SC_HSM_GOID ) { r = SC_SUCCESS ; } else { memset ( & pindata , 0 , sizeof ( pindata ) ) ; pindata . cmd = SC_PIN_CMD_GET_INFO ; pindata . pin_type = SC_AC_CHV ; pindata . pin_reference = 0x85 ; r = sc_pin_cmd ( card , & pindata , NULL ) ; } if ( r == SC_ERROR_DATA_OBJECT_NOT_FOUND ) { memset ( & pindata , 0 , sizeof ( pindata ) ) ; pindata . cmd = SC_PIN_CMD_GET_INFO ; pindata . pin_type = SC_AC_CHV ; pindata . pin_reference = 0x86 ; r = sc_pin_cmd ( card , & pindata , NULL ) ; } if ( ( r != SC_ERROR_DATA_OBJECT_NOT_FOUND ) && ( r != SC_ERROR_INCORRECT_PARAMETERS ) ) card -> caps |= SC_CARD_CAP_PROTECTED_AUTHENTICATION_PATH ; filelistlength = sc_list_files ( card , filelist , sizeof ( filelist ) ) ; LOG_TEST_RET ( card -> ctx , filelistlength , "Could<S2SV_blank>not<S2SV_blank>enumerate<S2SV_blank>file<S2SV_blank>and<S2SV_blank>key<S2SV_blank>identifier" ) ; for ( i = 0 ; i < filelistlength ; i += 2 ) { switch ( filelist [ i ] ) { case KEY_PREFIX : r = sc_pkcs15emu_sc_hsm_add_prkd ( p15card , filelist [ i + 1 ] ) ; break ; case DCOD_PREFIX : r = sc_pkcs15emu_sc_hsm_add_dcod ( p15card , filelist [ i + 1 ] ) ; break ; case CD_PREFIX : r = sc_pkcs15emu_sc_hsm_add_cd ( p15card , filelist [ i + 1 ] ) ; break ; } if ( r != SC_SUCCESS ) { sc_log ( card -> ctx , "Error<S2SV_blank>%d<S2SV_blank>adding<S2SV_blank>elements<S2SV_blank>to<S2SV_blank>framework" , r ) ; } } LOG_FUNC_RETURN ( card -> ctx , SC_SUCCESS ) ; }
CWE-119 int sc_file_set_sec_attr ( sc_file_t * file , const u8 * sec_attr , size_t sec_attr_len ) { u8 * tmp ; if ( ! sc_file_valid ( file ) ) { return SC_ERROR_INVALID_ARGUMENTS ; } <S2SV_StartBug> if ( sec_attr == NULL ) { <S2SV_EndBug> if ( file -> sec_attr != NULL ) free ( file -> sec_attr ) ; file -> sec_attr = NULL ; file -> sec_attr_len = 0 ; return 0 ; } tmp = ( u8 * ) realloc ( file -> sec_attr , sec_attr_len ) ; if ( ! tmp ) { if ( file -> sec_attr ) free ( file -> sec_attr ) ; file -> sec_attr = NULL ; file -> sec_attr_len = 0 ; return SC_ERROR_OUT_OF_MEMORY ; } file -> sec_attr = tmp ; memcpy ( file -> sec_attr , sec_attr , sec_attr_len ) ; file -> sec_attr_len = sec_attr_len ; return 0 ; }
CWE-119 static int read_private_key ( RSA * rsa ) { int r ; sc_path_t path ; sc_file_t * file ; const sc_acl_entry_t * e ; u8 buf [ 2048 ] , * p = buf ; size_t bufsize , keysize ; r = select_app_df ( ) ; if ( r ) return 1 ; sc_format_path ( "I0012" , & path ) ; r = sc_select_file ( card , & path , & file ) ; if ( r ) { fprintf ( stderr , "Unable<S2SV_blank>to<S2SV_blank>select<S2SV_blank>private<S2SV_blank>key<S2SV_blank>file:<S2SV_blank>%s\\n" , sc_strerror ( r ) ) ; return 2 ; } e = sc_file_get_acl_entry ( file , SC_AC_OP_READ ) ; if ( e == NULL || e -> method == SC_AC_NEVER ) return 10 ; <S2SV_StartBug> bufsize = file -> size ; <S2SV_EndBug> sc_file_free ( file ) ; r = sc_read_binary ( card , 0 , buf , bufsize , 0 ) ; if ( r < 0 ) { fprintf ( stderr , "Unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>private<S2SV_blank>key<S2SV_blank>file:<S2SV_blank>%s\\n" , sc_strerror ( r ) ) ; return 2 ; } bufsize = r ; do { if ( bufsize < 4 ) return 3 ; keysize = ( p [ 0 ] << 8 ) | p [ 1 ] ; if ( keysize == 0 ) break ; if ( keysize < 3 ) return 3 ; if ( p [ 2 ] == opt_key_num ) break ; p += keysize ; bufsize -= keysize ; } while ( 1 ) ; if ( keysize == 0 ) { printf ( "Key<S2SV_blank>number<S2SV_blank>%d<S2SV_blank>not<S2SV_blank>found.\\n" , opt_key_num ) ; return 2 ; } return parse_private_key ( p , keysize , rsa ) ; }
CWE-119 static int read_public_key ( RSA * rsa ) { int r ; sc_path_t path ; sc_file_t * file ; u8 buf [ 2048 ] , * p = buf ; size_t bufsize , keysize ; r = select_app_df ( ) ; if ( r ) return 1 ; sc_format_path ( "I1012" , & path ) ; r = sc_select_file ( card , & path , & file ) ; if ( r ) { fprintf ( stderr , "Unable<S2SV_blank>to<S2SV_blank>select<S2SV_blank>public<S2SV_blank>key<S2SV_blank>file:<S2SV_blank>%s\\n" , sc_strerror ( r ) ) ; return 2 ; } <S2SV_StartBug> bufsize = file -> size ; <S2SV_EndBug> sc_file_free ( file ) ; r = sc_read_binary ( card , 0 , buf , bufsize , 0 ) ; if ( r < 0 ) { fprintf ( stderr , "Unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>public<S2SV_blank>key<S2SV_blank>file:<S2SV_blank>%s\\n" , sc_strerror ( r ) ) ; return 2 ; } bufsize = r ; do { if ( bufsize < 4 ) return 3 ; keysize = ( p [ 0 ] << 8 ) | p [ 1 ] ; if ( keysize == 0 ) break ; if ( keysize < 3 ) return 3 ; if ( p [ 2 ] == opt_key_num ) break ; p += keysize ; bufsize -= keysize ; } while ( 1 ) ; if ( keysize == 0 ) { printf ( "Key<S2SV_blank>number<S2SV_blank>%d<S2SV_blank>not<S2SV_blank>found.\\n" , opt_key_num ) ; return 2 ; } return parse_public_key ( p , keysize , rsa ) ; }
CWE-119 int read_file ( struct sc_card * card , char * str_path , unsigned char * * data , size_t * data_len ) { struct sc_path path ; struct sc_file * file ; unsigned char * p ; int ok = 0 ; int r ; size_t len ; sc_format_path ( str_path , & path ) ; if ( SC_SUCCESS != sc_select_file ( card , & path , & file ) ) { goto err ; } <S2SV_StartBug> len = file ? file -> size : 4096 ; <S2SV_EndBug> p = realloc ( * data , len ) ; if ( ! p ) { goto err ; } * data = p ; * data_len = len ; r = sc_read_binary ( card , 0 , p , len , 0 ) ; if ( r < 0 ) goto err ; * data_len = r ; ok = 1 ; err : sc_file_free ( file ) ; return ok ; }
CWE-119 const char * util_acl_to_str ( const sc_acl_entry_t * e ) { static char line [ 80 ] , buf [ 20 ] ; unsigned int acl ; if ( e == NULL ) return "N/A" ; line [ 0 ] = 0 ; while ( e != NULL ) { acl = e -> method ; switch ( acl ) { case SC_AC_UNKNOWN : return "N/A" ; case SC_AC_NEVER : return "NEVR" ; case SC_AC_NONE : return "NONE" ; case SC_AC_CHV : strcpy ( buf , "CHV" ) ; if ( e -> key_ref != SC_AC_KEY_REF_NONE ) sprintf ( buf + 3 , "%d" , e -> key_ref ) ; break ; case SC_AC_TERM : strcpy ( buf , "TERM" ) ; break ; case SC_AC_PRO : strcpy ( buf , "PROT" ) ; break ; case SC_AC_AUT : strcpy ( buf , "AUTH" ) ; if ( e -> key_ref != SC_AC_KEY_REF_NONE ) sprintf ( buf + 4 , "%d" , e -> key_ref ) ; break ; case SC_AC_SEN : strcpy ( buf , "Sec.Env.<S2SV_blank>" ) ; if ( e -> key_ref != SC_AC_KEY_REF_NONE ) sprintf ( buf + 3 , "#%d" , e -> key_ref ) ; break ; case SC_AC_SCB : strcpy ( buf , "Sec.ControlByte<S2SV_blank>" ) ; if ( e -> key_ref != SC_AC_KEY_REF_NONE ) sprintf ( buf + 3 , "Ox%X" , e -> key_ref ) ; break ; case SC_AC_IDA : strcpy ( buf , "PKCS#15<S2SV_blank>AuthID<S2SV_blank>" ) ; if ( e -> key_ref != SC_AC_KEY_REF_NONE ) sprintf ( buf + 3 , "#%d" , e -> key_ref ) ; break ; default : strcpy ( buf , "????" ) ; break ; } <S2SV_StartBug> strcat ( line , buf ) ; <S2SV_EndBug> <S2SV_StartBug> strcat ( line , "<S2SV_blank>" ) ; <S2SV_EndBug> e = e -> next ; } <S2SV_StartBug> line [ strlen ( line ) - 1 ] = 0 ; <S2SV_EndBug> return line ; }
CWE-119 static int decode_bit_string ( const u8 * inbuf , size_t inlen , void * outbuf , size_t outlen , int invert ) { const u8 * in = inbuf ; u8 * out = ( u8 * ) outbuf ; <S2SV_StartBug> int zero_bits = * in & 0x07 ; <S2SV_EndBug> <S2SV_StartBug> size_t octets_left = inlen - 1 ; <S2SV_EndBug> <S2SV_StartBug> int i , count = 0 ; <S2SV_EndBug> memset ( outbuf , 0 , outlen ) ; in ++ ; if ( outlen < octets_left ) return SC_ERROR_BUFFER_TOO_SMALL ; if ( inlen < 1 ) return SC_ERROR_INVALID_ASN1_OBJECT ; while ( octets_left ) { int bits_to_go ; * out = 0 ; if ( octets_left == 1 ) bits_to_go = 8 - zero_bits ; else bits_to_go = 8 ; if ( invert ) for ( i = 0 ; i < bits_to_go ; i ++ ) { * out |= ( ( * in >> ( 7 - i ) ) & 1 ) << i ; } else { * out = * in ; } out ++ ; in ++ ; octets_left -- ; count ++ ; } return ( count * 8 ) - zero_bits ; }
CWE-119 static int asn1_decode_entry ( sc_context_t * ctx , struct sc_asn1_entry * entry , const u8 * obj , size_t objlen , int depth ) { void * parm = entry -> parm ; int ( * callback_func ) ( sc_context_t * nctx , void * arg , const u8 * nobj , size_t nobjlen , int ndepth ) ; size_t * len = ( size_t * ) entry -> arg ; int r = 0 ; callback_func = parm ; sc_debug ( ctx , SC_LOG_DEBUG_ASN1 , "%*.*sdecoding<S2SV_blank>\'%s\',<S2SV_blank>raw<S2SV_blank>data:%s%s\\n" , depth , depth , "" , entry -> name , sc_dump_hex ( obj , objlen > 16 ? 16 : objlen ) , objlen > 16 ? "..." : "" ) ; switch ( entry -> type ) { case SC_ASN1_STRUCT : if ( parm != NULL ) r = asn1_decode ( ctx , ( struct sc_asn1_entry * ) parm , obj , objlen , NULL , NULL , 0 , depth + 1 ) ; break ; case SC_ASN1_NULL : break ; case SC_ASN1_BOOLEAN : if ( parm != NULL ) { if ( objlen != 1 ) { sc_debug ( ctx , SC_LOG_DEBUG_ASN1 , "invalid<S2SV_blank>ASN.1<S2SV_blank>object<S2SV_blank>length:<S2SV_blank>%" SC_FORMAT_LEN_SIZE_T "u\\n" , objlen ) ; r = SC_ERROR_INVALID_ASN1_OBJECT ; } else * ( ( int * ) parm ) = obj [ 0 ] ? 1 : 0 ; } break ; case SC_ASN1_INTEGER : case SC_ASN1_ENUMERATED : if ( parm != NULL ) { r = sc_asn1_decode_integer ( obj , objlen , ( int * ) entry -> parm ) ; sc_debug ( ctx , SC_LOG_DEBUG_ASN1 , "%*.*sdecoding<S2SV_blank>\'%s\'<S2SV_blank>returned<S2SV_blank>%d\\n" , depth , depth , "" , entry -> name , * ( ( int * ) entry -> parm ) ) ; } break ; case SC_ASN1_BIT_STRING_NI : case SC_ASN1_BIT_STRING : if ( parm != NULL ) { int invert = entry -> type == SC_ASN1_BIT_STRING ? 1 : 0 ; assert ( len != NULL ) ; if ( objlen < 1 ) { r = SC_ERROR_INVALID_ASN1_OBJECT ; break ; } if ( entry -> flags & SC_ASN1_ALLOC ) { u8 * * buf = ( u8 * * ) parm ; * buf = malloc ( objlen - 1 ) ; if ( * buf == NULL ) { r = SC_ERROR_OUT_OF_MEMORY ; break ; } * len = objlen - 1 ; parm = * buf ; } r = decode_bit_string ( obj , objlen , ( u8 * ) parm , * len , invert ) ; if ( r >= 0 ) { * len = r ; r = 0 ; } } break ; case SC_ASN1_BIT_FIELD : if ( parm != NULL ) r = decode_bit_field ( obj , objlen , ( u8 * ) parm , * len ) ; break ; case SC_ASN1_OCTET_STRING : if ( parm != NULL ) { size_t c ; assert ( len != NULL ) ; if ( ( entry -> flags & SC_ASN1_UNSIGNED ) <S2SV_StartBug> && obj [ 0 ] == 0x00 && objlen > 1 ) { <S2SV_EndBug> objlen -- ; obj ++ ; } if ( entry -> flags & SC_ASN1_ALLOC ) { u8 * * buf = ( u8 * * ) parm ; * buf = malloc ( objlen ) ; if ( * buf == NULL ) { r = SC_ERROR_OUT_OF_MEMORY ; break ; } c = * len = objlen ; parm = * buf ; } else c = objlen > * len ? * len : objlen ; memcpy ( parm , obj , c ) ; * len = c ; } break ; case SC_ASN1_GENERALIZEDTIME : if ( parm != NULL ) { size_t c ; assert ( len != NULL ) ; if ( entry -> flags & SC_ASN1_ALLOC ) { u8 * * buf = ( u8 * * ) parm ; * buf = malloc ( objlen ) ; if ( * buf == NULL ) { r = SC_ERROR_OUT_OF_MEMORY ; break ; } c = * len = objlen ; parm = * buf ; } else c = objlen > * len ? * len : objlen ; memcpy ( parm , obj , c ) ; * len = c ; } break ; case SC_ASN1_OBJECT : if ( parm != NULL ) r = sc_asn1_decode_object_id ( obj , objlen , ( struct sc_object_id * ) parm ) ; break ; case SC_ASN1_PRINTABLESTRING : case SC_ASN1_UTF8STRING : if ( parm != NULL ) { assert ( len != NULL ) ; if ( entry -> flags & SC_ASN1_ALLOC ) { u8 * * buf = ( u8 * * ) parm ; * buf = malloc ( objlen + 1 ) ; if ( * buf == NULL ) { r = SC_ERROR_OUT_OF_MEMORY ; break ; } * len = objlen + 1 ; parm = * buf ; } r = sc_asn1_decode_utf8string ( obj , objlen , ( u8 * ) parm , len ) ; if ( entry -> flags & SC_ASN1_ALLOC ) { * len -= 1 ; } } break ; case SC_ASN1_PATH : if ( entry -> parm != NULL ) r = asn1_decode_path ( ctx , obj , objlen , ( sc_path_t * ) parm , depth ) ; break ; case SC_ASN1_PKCS15_ID : if ( entry -> parm != NULL ) { struct sc_pkcs15_id * id = ( struct sc_pkcs15_id * ) parm ; size_t c = objlen > sizeof ( id -> value ) ? sizeof ( id -> value ) : objlen ; memcpy ( id -> value , obj , c ) ; id -> len = c ; } break ; case SC_ASN1_PKCS15_OBJECT : if ( entry -> parm != NULL ) r = asn1_decode_p15_object ( ctx , obj , objlen , ( struct sc_asn1_pkcs15_object * ) parm , depth ) ; break ; case SC_ASN1_ALGORITHM_ID : if ( entry -> parm != NULL ) r = sc_asn1_decode_algorithm_id ( ctx , obj , objlen , ( struct sc_algorithm_id * ) parm , depth ) ; break ; case SC_ASN1_SE_INFO : if ( entry -> parm != NULL ) r = asn1_decode_se_info ( ctx , obj , objlen , ( sc_pkcs15_sec_env_info_t * * * ) entry -> parm , len , depth ) ; break ; case SC_ASN1_CALLBACK : if ( entry -> parm != NULL ) r = callback_func ( ctx , entry -> arg , obj , objlen , depth ) ; break ; default : sc_debug ( ctx , SC_LOG_DEBUG_ASN1 , "invalid<S2SV_blank>ASN.1<S2SV_blank>type:<S2SV_blank>%d\\n" , entry -> type ) ; return SC_ERROR_INVALID_ASN1_OBJECT ; } if ( r ) { sc_debug ( ctx , SC_LOG_DEBUG_ASN1 , "decoding<S2SV_blank>of<S2SV_blank>ASN.1<S2SV_blank>object<S2SV_blank>\'%s\'<S2SV_blank>failed:<S2SV_blank>%s\\n" , entry -> name , sc_strerror ( r ) ) ; return r ; } entry -> flags |= SC_ASN1_PRESENT ; return 0 ; }
CWE-119 static int key_verify ( pam_handle_t * pamh , int flags , PKCS11_KEY * authkey ) { int ok = 0 ; unsigned char challenge [ 30 ] ; <S2SV_StartBug> unsigned char signature [ 256 ] ; <S2SV_EndBug> <S2SV_StartBug> unsigned int siglen = sizeof signature ; <S2SV_EndBug> const EVP_MD * md = EVP_sha1 ( ) ; EVP_MD_CTX * md_ctx = EVP_MD_CTX_new ( ) ; EVP_PKEY * privkey = PKCS11_get_private_key ( authkey ) ; EVP_PKEY * pubkey = PKCS11_get_public_key ( authkey ) ; <S2SV_StartBug> if ( 1 != randomize ( pamh , challenge , sizeof challenge ) ) { <S2SV_EndBug> goto err ; } if ( NULL == pubkey || NULL == privkey || NULL == md_ctx || NULL == md || ! EVP_SignInit ( md_ctx , md ) || ! EVP_SignUpdate ( md_ctx , challenge , sizeof challenge ) || ! EVP_SignFinal ( md_ctx , signature , & siglen , privkey ) || ! EVP_MD_CTX_reset ( md_ctx ) || ! EVP_VerifyInit ( md_ctx , md ) || ! EVP_VerifyUpdate ( md_ctx , challenge , sizeof challenge ) || 1 != EVP_VerifyFinal ( md_ctx , signature , siglen , pubkey ) ) { pam_syslog ( pamh , LOG_DEBUG , "Error<S2SV_blank>verifying<S2SV_blank>key:<S2SV_blank>%s\\n" , ERR_reason_error_string ( ERR_get_error ( ) ) ) ; prompt ( flags , pamh , PAM_ERROR_MSG , NULL , _ ( "Error<S2SV_blank>verifying<S2SV_blank>key" ) ) ; goto err ; } ok = 1 ; <S2SV_StartBug> err : <S2SV_EndBug> if ( NULL != pubkey ) EVP_PKEY_free ( pubkey ) ; if ( NULL != privkey ) EVP_PKEY_free ( privkey ) ; if ( NULL != md_ctx ) { EVP_MD_CTX_free ( md_ctx ) ; } return ok ; }
CWE-415 static BOOL GetStartupData ( HANDLE pipe , STARTUP_DATA * sud ) { size_t size , len ; <S2SV_StartBug> BOOL ret = FALSE ; <S2SV_EndBug> WCHAR * data = NULL ; DWORD bytes , read ; bytes = PeekNamedPipeAsync ( pipe , 1 , & exit_event ) ; if ( bytes == 0 ) { MsgToEventLog ( M_SYSERR , TEXT ( "PeekNamedPipeAsync<S2SV_blank>failed" ) ) ; ReturnLastError ( pipe , L"PeekNamedPipeAsync" ) ; <S2SV_StartBug> goto out ; <S2SV_EndBug> } size = bytes / sizeof ( * data ) ; if ( size == 0 ) { MsgToEventLog ( M_SYSERR , TEXT ( "malformed<S2SV_blank>startup<S2SV_blank>data:<S2SV_blank>1<S2SV_blank>byte<S2SV_blank>received" ) ) ; ReturnError ( pipe , ERROR_STARTUP_DATA , L"GetStartupData" , 1 , & exit_event ) ; <S2SV_StartBug> goto out ; <S2SV_EndBug> } data = malloc ( bytes ) ; if ( data == NULL ) { MsgToEventLog ( M_SYSERR , TEXT ( "malloc<S2SV_blank>failed" ) ) ; ReturnLastError ( pipe , L"malloc" ) ; <S2SV_StartBug> goto out ; <S2SV_EndBug> } read = ReadPipeAsync ( pipe , data , bytes , 1 , & exit_event ) ; if ( bytes != read ) { MsgToEventLog ( M_SYSERR , TEXT ( "ReadPipeAsync<S2SV_blank>failed" ) ) ; ReturnLastError ( pipe , L"ReadPipeAsync" ) ; <S2SV_StartBug> goto out ; <S2SV_EndBug> } if ( data [ size - 1 ] != 0 ) { MsgToEventLog ( M_ERR , TEXT ( "Startup<S2SV_blank>data<S2SV_blank>is<S2SV_blank>not<S2SV_blank>NULL<S2SV_blank>terminated" ) ) ; ReturnError ( pipe , ERROR_STARTUP_DATA , L"GetStartupData" , 1 , & exit_event ) ; <S2SV_StartBug> goto out ; <S2SV_EndBug> } sud -> directory = data ; len = wcslen ( sud -> directory ) + 1 ; size -= len ; if ( size <= 0 ) { MsgToEventLog ( M_ERR , TEXT ( "Startup<S2SV_blank>data<S2SV_blank>ends<S2SV_blank>at<S2SV_blank>working<S2SV_blank>directory" ) ) ; ReturnError ( pipe , ERROR_STARTUP_DATA , L"GetStartupData" , 1 , & exit_event ) ; <S2SV_StartBug> goto out ; <S2SV_EndBug> } sud -> options = sud -> directory + len ; len = wcslen ( sud -> options ) + 1 ; size -= len ; if ( size <= 0 ) { MsgToEventLog ( M_ERR , TEXT ( "Startup<S2SV_blank>data<S2SV_blank>ends<S2SV_blank>at<S2SV_blank>command<S2SV_blank>line<S2SV_blank>options" ) ) ; ReturnError ( pipe , ERROR_STARTUP_DATA , L"GetStartupData" , 1 , & exit_event ) ; <S2SV_StartBug> goto out ; <S2SV_EndBug> } sud -> std_input = sud -> options + len ; <S2SV_StartBug> data = NULL ; <S2SV_EndBug> <S2SV_StartBug> ret = TRUE ; <S2SV_EndBug> out : free ( data ) ; <S2SV_StartBug> return ret ; <S2SV_EndBug> }
CWE-119 static void t1_check_unusual_charstring ( void ) { char * p = strstr ( t1_line_array , charstringname ) + strlen ( charstringname ) ; int i ; if ( sscanf ( p , "%i" , & i ) != 1 ) { strcpy ( t1_buf_array , t1_line_array ) ; * ( strend ( t1_buf_array ) - 1 ) = '<S2SV_blank>' ; t1_getline ( ) ; <S2SV_StartBug> strcat ( t1_buf_array , t1_line_array ) ; <S2SV_EndBug> strcpy ( t1_line_array , t1_buf_array ) ; t1_line_ptr = eol ( t1_line_array ) ; } }
CWE-119 static void t1_check_unusual_charstring ( void ) { char * p = strstr ( t1_line_array , charstringname ) + strlen ( charstringname ) ; int i ; if ( sscanf ( p , "%i" , & i ) != 1 ) { strcpy ( t1_buf_array , t1_line_array ) ; t1_getline ( ) ; <S2SV_StartBug> strcat ( t1_buf_array , t1_line_array ) ; <S2SV_EndBug> strcpy ( t1_line_array , t1_buf_array ) ; t1_line_ptr = eol ( t1_line_array ) ; } }
CWE-119 static void t1_check_unusual_charstring ( void ) { char * p = strstr ( t1_line_array , charstringname ) + strlen ( charstringname ) ; int i ; if ( sscanf ( p , "%i" , & i ) != 1 ) { strcpy ( t1_buf_array , t1_line_array ) ; * ( strend ( t1_buf_array ) - 1 ) = '<S2SV_blank>' ; t1_getline ( ) ; <S2SV_StartBug> strcat ( t1_buf_array , t1_line_array ) ; <S2SV_EndBug> strcpy ( t1_line_array , t1_buf_array ) ; t1_line_ptr = eol ( t1_line_array ) ; } }
CWE-601 int am_check_url ( request_rec * r , const char * url ) { const char * i ; for ( i = url ; * i ; i ++ ) { if ( * i >= 0 && * i < '<S2SV_blank>' ) { AM_LOG_RERROR ( APLOG_MARK , APLOG_ERR , HTTP_BAD_REQUEST , r , "Control<S2SV_blank>character<S2SV_blank>detected<S2SV_blank>in<S2SV_blank>URL." ) ; return HTTP_BAD_REQUEST ; } <S2SV_StartBug> } <S2SV_EndBug> return OK ; }
CWE-119 static int init_device ( u2fh_devs * devs , struct u2fdevice * dev ) { unsigned char resp [ 1024 ] ; unsigned char nonce [ 8 ] ; if ( obtain_nonce ( nonce ) != 0 ) { return U2FH_TRANSPORT_ERROR ; } size_t resplen = sizeof ( resp ) ; dev -> cid = CID_BROADCAST ; if ( u2fh_sendrecv ( devs , dev -> id , U2FHID_INIT , nonce , sizeof ( nonce ) , resp , & resplen ) == U2FH_OK ) { <S2SV_StartBug> U2FHID_INIT_RESP initresp ; <S2SV_EndBug> <S2SV_StartBug> if ( resplen > sizeof ( initresp ) ) <S2SV_EndBug> { return U2FH_MEMORY_ERROR ; } memcpy ( & initresp , resp , resplen ) ; <S2SV_StartBug> dev -> cid = initresp . cid ; <S2SV_EndBug> <S2SV_StartBug> dev -> versionInterface = initresp . versionInterface ; <S2SV_EndBug> <S2SV_StartBug> dev -> versionMajor = initresp . versionMajor ; <S2SV_EndBug> <S2SV_StartBug> dev -> versionMinor = initresp . versionMinor ; <S2SV_EndBug> <S2SV_StartBug> dev -> capFlags = initresp . capFlags ; <S2SV_EndBug> } else { return U2FH_TRANSPORT_ERROR ; } return U2FH_OK ; }
CWE-200 int pam_sm_authenticate ( pam_handle_t * pamh , int flags , int argc , const char * * argv ) { struct passwd * pw = NULL , pw_s ; const char * user = NULL ; cfg_t cfg_st ; cfg_t * cfg = & cfg_st ; char buffer [ BUFSIZE ] ; char * buf = NULL ; char * authfile_dir ; size_t authfile_dir_len ; int pgu_ret , gpn_ret ; int retval = PAM_IGNORE ; device_t * devices = NULL ; unsigned n_devices = 0 ; int openasuser ; int should_free_origin = 0 ; int should_free_appid = 0 ; int should_free_auth_file = 0 ; int should_free_authpending_file = 0 ; parse_cfg ( flags , argc , argv , cfg ) ; if ( ! cfg -> origin ) { strcpy ( buffer , DEFAULT_ORIGIN_PREFIX ) ; if ( gethostname ( buffer + strlen ( DEFAULT_ORIGIN_PREFIX ) , BUFSIZE - strlen ( DEFAULT_ORIGIN_PREFIX ) ) == - 1 ) { DBG ( "Unable<S2SV_blank>to<S2SV_blank>get<S2SV_blank>host<S2SV_blank>name" ) ; goto done ; } DBG ( "Origin<S2SV_blank>not<S2SV_blank>specified,<S2SV_blank>using<S2SV_blank>\\"%s\\"" , buffer ) ; cfg -> origin = strdup ( buffer ) ; if ( ! cfg -> origin ) { DBG ( "Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory" ) ; goto done ; } else { should_free_origin = 1 ; } } if ( ! cfg -> appid ) { DBG ( "Appid<S2SV_blank>not<S2SV_blank>specified,<S2SV_blank>using<S2SV_blank>the<S2SV_blank>same<S2SV_blank>value<S2SV_blank>of<S2SV_blank>origin<S2SV_blank>(%s)" , cfg -> origin ) ; cfg -> appid = strdup ( cfg -> origin ) ; if ( ! cfg -> appid ) { DBG ( "Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory" ) goto done ; } else { should_free_appid = 1 ; } } if ( cfg -> max_devs == 0 ) { DBG ( "Maximum<S2SV_blank>devices<S2SV_blank>number<S2SV_blank>not<S2SV_blank>set.<S2SV_blank>Using<S2SV_blank>default<S2SV_blank>(%d)" , MAX_DEVS ) ; cfg -> max_devs = MAX_DEVS ; } devices = malloc ( sizeof ( device_t ) * cfg -> max_devs ) ; if ( ! devices ) { DBG ( "Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory" ) ; retval = PAM_IGNORE ; goto done ; } pgu_ret = pam_get_user ( pamh , & user , NULL ) ; if ( pgu_ret != PAM_SUCCESS || user == NULL ) { DBG ( "Unable<S2SV_blank>to<S2SV_blank>access<S2SV_blank>user<S2SV_blank>%s" , user ) ; retval = PAM_CONV_ERR ; goto done ; } DBG ( "Requesting<S2SV_blank>authentication<S2SV_blank>for<S2SV_blank>user<S2SV_blank>%s" , user ) ; gpn_ret = getpwnam_r ( user , & pw_s , buffer , sizeof ( buffer ) , & pw ) ; if ( gpn_ret != 0 || pw == NULL || pw -> pw_dir == NULL || pw -> pw_dir [ 0 ] != '/' ) { DBG ( "Unable<S2SV_blank>to<S2SV_blank>retrieve<S2SV_blank>credentials<S2SV_blank>for<S2SV_blank>user<S2SV_blank>%s,<S2SV_blank>(%s)" , user , strerror ( errno ) ) ; retval = PAM_USER_UNKNOWN ; goto done ; } DBG ( "Found<S2SV_blank>user<S2SV_blank>%s" , user ) ; DBG ( "Home<S2SV_blank>directory<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>%s" , user , pw -> pw_dir ) ; if ( ! cfg -> auth_file ) { buf = NULL ; authfile_dir = secure_getenv ( DEFAULT_AUTHFILE_DIR_VAR ) ; if ( ! authfile_dir ) { DBG ( "Variable<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>set.<S2SV_blank>Using<S2SV_blank>default<S2SV_blank>value<S2SV_blank>($HOME/.config/)" , DEFAULT_AUTHFILE_DIR_VAR ) ; authfile_dir_len = strlen ( pw -> pw_dir ) + strlen ( "/.config" ) + strlen ( DEFAULT_AUTHFILE ) + 1 ; buf = malloc ( sizeof ( char ) * ( authfile_dir_len ) ) ; if ( ! buf ) { DBG ( "Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory" ) ; retval = PAM_IGNORE ; goto done ; } snprintf ( buf , authfile_dir_len , "%s/.config%s" , pw -> pw_dir , DEFAULT_AUTHFILE ) ; } else { DBG ( "Variable<S2SV_blank>%s<S2SV_blank>set<S2SV_blank>to<S2SV_blank>%s" , DEFAULT_AUTHFILE_DIR_VAR , authfile_dir ) ; authfile_dir_len = strlen ( authfile_dir ) + strlen ( DEFAULT_AUTHFILE ) + 1 ; buf = malloc ( sizeof ( char ) * ( authfile_dir_len ) ) ; if ( ! buf ) { DBG ( "Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory" ) ; retval = PAM_IGNORE ; goto done ; } snprintf ( buf , authfile_dir_len , "%s%s" , authfile_dir , DEFAULT_AUTHFILE ) ; } DBG ( "Using<S2SV_blank>default<S2SV_blank>authentication<S2SV_blank>file<S2SV_blank>%s" , buf ) ; cfg -> auth_file = buf ; should_free_auth_file = 1 ; buf = NULL ; } else { DBG ( "Using<S2SV_blank>authentication<S2SV_blank>file<S2SV_blank>%s" , cfg -> auth_file ) ; } openasuser = geteuid ( ) == 0 && cfg -> openasuser ; if ( openasuser ) { if ( seteuid ( pw_s . pw_uid ) ) { DBG ( "Unable<S2SV_blank>to<S2SV_blank>switch<S2SV_blank>user<S2SV_blank>to<S2SV_blank>uid<S2SV_blank>%i" , pw_s . pw_uid ) ; retval = PAM_IGNORE ; goto done ; } DBG ( "Switched<S2SV_blank>to<S2SV_blank>uid<S2SV_blank>%i" , pw_s . pw_uid ) ; } retval = get_devices_from_authfile ( cfg -> auth_file , user , cfg -> max_devs , cfg -> debug , cfg -> debug_file , devices , & n_devices ) ; if ( openasuser ) { if ( seteuid ( 0 ) ) { DBG ( "Unable<S2SV_blank>to<S2SV_blank>switch<S2SV_blank>back<S2SV_blank>to<S2SV_blank>uid<S2SV_blank>0" ) ; retval = PAM_IGNORE ; goto done ; } DBG ( "Switched<S2SV_blank>back<S2SV_blank>to<S2SV_blank>uid<S2SV_blank>0" ) ; } if ( retval != 1 ) { n_devices = 0 ; } if ( n_devices == 0 ) { if ( cfg -> nouserok ) { DBG ( "Found<S2SV_blank>no<S2SV_blank>devices<S2SV_blank>but<S2SV_blank>nouserok<S2SV_blank>specified.<S2SV_blank>Skipping<S2SV_blank>authentication" ) ; retval = PAM_SUCCESS ; goto done ; } else if ( retval != 1 ) { DBG ( "Unable<S2SV_blank>to<S2SV_blank>get<S2SV_blank>devices<S2SV_blank>from<S2SV_blank>file<S2SV_blank>%s" , cfg -> auth_file ) ; retval = PAM_AUTHINFO_UNAVAIL ; goto done ; } else { DBG ( "Found<S2SV_blank>no<S2SV_blank>devices.<S2SV_blank>Aborting." ) ; retval = PAM_AUTHINFO_UNAVAIL ; goto done ; } } if ( ! cfg -> authpending_file ) { int actual_size = snprintf ( buffer , BUFSIZE , DEFAULT_AUTHPENDING_FILE_PATH , getuid ( ) ) ; if ( actual_size >= 0 && actual_size < BUFSIZE ) { cfg -> authpending_file = strdup ( buffer ) ; } if ( ! cfg -> authpending_file ) { DBG ( "Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>the<S2SV_blank>authpending_file,<S2SV_blank>touch<S2SV_blank>request<S2SV_blank>notifications<S2SV_blank>will<S2SV_blank>not<S2SV_blank>be<S2SV_blank>emitted" ) ; } else { should_free_authpending_file = 1 ; } } else { if ( strlen ( cfg -> authpending_file ) == 0 ) { DBG ( "authpending_file<S2SV_blank>is<S2SV_blank>set<S2SV_blank>to<S2SV_blank>an<S2SV_blank>empty<S2SV_blank>value,<S2SV_blank>touch<S2SV_blank>request<S2SV_blank>notifications<S2SV_blank>will<S2SV_blank>be<S2SV_blank>disabled" ) ; cfg -> authpending_file = NULL ; } } int authpending_file_descriptor = - 1 ; if ( cfg -> authpending_file ) { DBG ( "Using<S2SV_blank>file<S2SV_blank>\'%s\'<S2SV_blank>for<S2SV_blank>emitting<S2SV_blank>touch<S2SV_blank>request<S2SV_blank>notifications" , cfg -> authpending_file ) ; <S2SV_StartBug> authpending_file_descriptor = open ( cfg -> authpending_file , O_RDONLY | O_CREAT , 0664 ) ; <S2SV_EndBug> if ( authpending_file_descriptor < 0 ) { DBG ( "Unable<S2SV_blank>to<S2SV_blank>emit<S2SV_blank>\'authentication<S2SV_blank>started\'<S2SV_blank>notification<S2SV_blank>by<S2SV_blank>opening<S2SV_blank>the<S2SV_blank>file<S2SV_blank>\'%s\',<S2SV_blank>(%s)" , cfg -> authpending_file , strerror ( errno ) ) ; } } if ( cfg -> manual == 0 ) { if ( cfg -> interactive ) { converse ( pamh , PAM_PROMPT_ECHO_ON , cfg -> prompt != NULL ? cfg -> prompt : DEFAULT_PROMPT ) ; } retval = do_authentication ( cfg , devices , n_devices , pamh ) ; } else { retval = do_manual_authentication ( cfg , devices , n_devices , pamh ) ; } if ( authpending_file_descriptor >= 0 ) { if ( close ( authpending_file_descriptor ) < 0 ) { DBG ( "Unable<S2SV_blank>to<S2SV_blank>emit<S2SV_blank>\'authentication<S2SV_blank>stopped\'<S2SV_blank>notification<S2SV_blank>by<S2SV_blank>closing<S2SV_blank>the<S2SV_blank>file<S2SV_blank>\'%s\',<S2SV_blank>(%s)" , cfg -> authpending_file , strerror ( errno ) ) ; } } if ( retval != 1 ) { DBG ( "do_authentication<S2SV_blank>returned<S2SV_blank>%d" , retval ) ; retval = PAM_AUTH_ERR ; goto done ; } retval = PAM_SUCCESS ; done : free_devices ( devices , n_devices ) ; if ( buf ) { free ( buf ) ; buf = NULL ; } if ( should_free_origin ) { free ( ( char * ) cfg -> origin ) ; cfg -> origin = NULL ; } if ( should_free_appid ) { free ( ( char * ) cfg -> appid ) ; cfg -> appid = NULL ; } if ( should_free_auth_file ) { free ( ( char * ) cfg -> auth_file ) ; cfg -> auth_file = NULL ; } if ( should_free_authpending_file ) { free ( ( char * ) cfg -> authpending_file ) ; cfg -> authpending_file = NULL ; } if ( cfg -> alwaysok && retval != PAM_SUCCESS ) { DBG ( "alwaysok<S2SV_blank>needed<S2SV_blank>(otherwise<S2SV_blank>return<S2SV_blank>with<S2SV_blank>%d)" , retval ) ; retval = PAM_SUCCESS ; } DBG ( "done.<S2SV_blank>[%s]" , pam_strerror ( pamh , retval ) ) ; <S2SV_StartBug> return retval ; <S2SV_EndBug> }
CWE-200 static void parse_cfg ( int flags , int argc , const char * * argv , cfg_t * cfg ) { <S2SV_StartBug> int i ; <S2SV_EndBug> memset ( cfg , 0 , sizeof ( cfg_t ) ) ; cfg -> debug_file = stderr ; for ( i = 0 ; i < argc ; i ++ ) { if ( strncmp ( argv [ i ] , "max_devices=" , 12 ) == 0 ) sscanf ( argv [ i ] , "max_devices=%u" , & cfg -> max_devs ) ; if ( strcmp ( argv [ i ] , "manual" ) == 0 ) cfg -> manual = 1 ; if ( strcmp ( argv [ i ] , "debug" ) == 0 ) cfg -> debug = 1 ; if ( strcmp ( argv [ i ] , "nouserok" ) == 0 ) cfg -> nouserok = 1 ; if ( strcmp ( argv [ i ] , "openasuser" ) == 0 ) cfg -> openasuser = 1 ; if ( strcmp ( argv [ i ] , "alwaysok" ) == 0 ) cfg -> alwaysok = 1 ; if ( strcmp ( argv [ i ] , "interactive" ) == 0 ) cfg -> interactive = 1 ; if ( strcmp ( argv [ i ] , "cue" ) == 0 ) cfg -> cue = 1 ; if ( strcmp ( argv [ i ] , "nodetect" ) == 0 ) cfg -> nodetect = 1 ; if ( strncmp ( argv [ i ] , "authfile=" , 9 ) == 0 ) cfg -> auth_file = argv [ i ] + 9 ; if ( strncmp ( argv [ i ] , "authpending_file=" , 17 ) == 0 ) cfg -> authpending_file = argv [ i ] + 17 ; if ( strncmp ( argv [ i ] , "origin=" , 7 ) == 0 ) cfg -> origin = argv [ i ] + 7 ; if ( strncmp ( argv [ i ] , "appid=" , 6 ) == 0 ) cfg -> appid = argv [ i ] + 6 ; if ( strncmp ( argv [ i ] , "prompt=" , 7 ) == 0 ) cfg -> prompt = argv [ i ] + 7 ; if ( strncmp ( argv [ i ] , "debug_file=" , 11 ) == 0 ) { const char * filename = argv [ i ] + 11 ; if ( strncmp ( filename , "stdout" , 6 ) == 0 ) { cfg -> debug_file = stdout ; } else if ( strncmp ( filename , "stderr" , 6 ) == 0 ) { cfg -> debug_file = stderr ; } else if ( strncmp ( filename , "syslog" , 6 ) == 0 ) { cfg -> debug_file = ( FILE * ) - 1 ; } else { <S2SV_StartBug> struct stat st ; <S2SV_EndBug> FILE * file ; <S2SV_StartBug> if ( lstat ( filename , & st ) == 0 ) { <S2SV_EndBug> if ( S_ISREG ( st . st_mode ) ) { <S2SV_StartBug> file = fopen ( filename , "a" ) ; <S2SV_EndBug> if ( file != NULL ) { cfg -> debug_file = file ; <S2SV_StartBug> } <S2SV_EndBug> } } } } } if ( cfg -> debug ) { D ( cfg -> debug_file , "called." ) ; D ( cfg -> debug_file , "flags<S2SV_blank>%d<S2SV_blank>argc<S2SV_blank>%d" , flags , argc ) ; for ( i = 0 ; i < argc ; i ++ ) { D ( cfg -> debug_file , "argv[%d]=%s" , i , argv [ i ] ) ; } D ( cfg -> debug_file , "max_devices=%d" , cfg -> max_devs ) ; D ( cfg -> debug_file , "debug=%d" , cfg -> debug ) ; D ( cfg -> debug_file , "interactive=%d" , cfg -> interactive ) ; D ( cfg -> debug_file , "cue=%d" , cfg -> cue ) ; D ( cfg -> debug_file , "nodetect=%d" , cfg -> nodetect ) ; D ( cfg -> debug_file , "manual=%d" , cfg -> manual ) ; D ( cfg -> debug_file , "nouserok=%d" , cfg -> nouserok ) ; D ( cfg -> debug_file , "openasuser=%d" , cfg -> openasuser ) ; D ( cfg -> debug_file , "alwaysok=%d" , cfg -> alwaysok ) ; D ( cfg -> debug_file , "authfile=%s" , cfg -> auth_file ? cfg -> auth_file : "(null)" ) ; D ( cfg -> debug_file , "authpending_file=%s" , cfg -> authpending_file ? cfg -> authpending_file : "(null)" ) ; D ( cfg -> debug_file , "origin=%s" , cfg -> origin ? cfg -> origin : "(null)" ) ; D ( cfg -> debug_file , "appid=%s" , cfg -> appid ? cfg -> appid : "(null)" ) ; D ( cfg -> debug_file , "prompt=%s" , cfg -> prompt ? cfg -> prompt : "(null)" ) ; } <S2SV_StartBug> } <S2SV_EndBug>
CWE-200 int get_devices_from_authfile ( const char * authfile , const char * username , unsigned max_devs , int verbose , FILE * debug_file , device_t * devices , unsigned * n_devs ) { char * buf = NULL ; char * s_user , * s_token ; int retval = 0 ; int fd = - 1 ; struct stat st ; struct passwd * pw = NULL , pw_s ; char buffer [ BUFSIZE ] ; int gpu_ret ; FILE * opwfile = NULL ; unsigned i , j ; * n_devs = 0 ; <S2SV_StartBug> fd = open ( authfile , O_RDONLY , 0 ) ; <S2SV_EndBug> if ( fd < 0 ) { if ( verbose ) D ( debug_file , "Cannot<S2SV_blank>open<S2SV_blank>file:<S2SV_blank>%s<S2SV_blank>(%s)" , authfile , strerror ( errno ) ) ; goto err ; } if ( fstat ( fd , & st ) < 0 ) { if ( verbose ) D ( debug_file , "Cannot<S2SV_blank>stat<S2SV_blank>file:<S2SV_blank>%s<S2SV_blank>(%s)" , authfile , strerror ( errno ) ) ; goto err ; } if ( ! S_ISREG ( st . st_mode ) ) { if ( verbose ) D ( debug_file , "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>regular<S2SV_blank>file" , authfile ) ; goto err ; } if ( st . st_size == 0 ) { if ( verbose ) D ( debug_file , "File<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>empty" , authfile ) ; goto err ; } gpu_ret = getpwuid_r ( st . st_uid , & pw_s , buffer , sizeof ( buffer ) , & pw ) ; if ( gpu_ret != 0 || pw == NULL ) { D ( debug_file , "Unable<S2SV_blank>to<S2SV_blank>retrieve<S2SV_blank>credentials<S2SV_blank>for<S2SV_blank>uid<S2SV_blank>%u,<S2SV_blank>(%s)" , st . st_uid , strerror ( errno ) ) ; goto err ; } if ( strcmp ( pw -> pw_name , username ) != 0 && strcmp ( pw -> pw_name , "root" ) != 0 ) { if ( strcmp ( username , "root" ) != 0 ) { D ( debug_file , "The<S2SV_blank>owner<S2SV_blank>of<S2SV_blank>the<S2SV_blank>authentication<S2SV_blank>file<S2SV_blank>is<S2SV_blank>neither<S2SV_blank>%s<S2SV_blank>nor<S2SV_blank>root" , username ) ; } else { D ( debug_file , "The<S2SV_blank>owner<S2SV_blank>of<S2SV_blank>the<S2SV_blank>authentication<S2SV_blank>file<S2SV_blank>is<S2SV_blank>not<S2SV_blank>root" ) ; } goto err ; } opwfile = fdopen ( fd , "r" ) ; if ( opwfile == NULL ) { if ( verbose ) D ( debug_file , "fdopen:<S2SV_blank>%s" , strerror ( errno ) ) ; <S2SV_StartBug> goto err ; <S2SV_EndBug> } buf = malloc ( sizeof ( char ) * ( DEVSIZE * max_devs ) ) ; if ( ! buf ) { if ( verbose ) D ( debug_file , "Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory" ) ; goto err ; } retval = - 2 ; while ( fgets ( buf , ( int ) ( DEVSIZE * ( max_devs - 1 ) ) , opwfile ) ) { char * saveptr = NULL ; if ( buf [ strlen ( buf ) - 1 ] == '\\n' ) buf [ strlen ( buf ) - 1 ] = '\\0' ; if ( verbose ) D ( debug_file , "Authorization<S2SV_blank>line:<S2SV_blank>%s" , buf ) ; s_user = strtok_r ( buf , ":" , & saveptr ) ; if ( s_user && strcmp ( username , s_user ) == 0 ) { if ( verbose ) D ( debug_file , "Matched<S2SV_blank>user:<S2SV_blank>%s" , s_user ) ; retval = - 1 ; for ( i = 0 ; i < * n_devs ; i ++ ) { free ( devices [ i ] . keyHandle ) ; free ( devices [ i ] . publicKey ) ; devices [ i ] . keyHandle = NULL ; devices [ i ] . publicKey = NULL ; } * n_devs = 0 ; i = 0 ; while ( ( s_token = strtok_r ( NULL , "," , & saveptr ) ) ) { devices [ i ] . keyHandle = NULL ; devices [ i ] . publicKey = NULL ; if ( ( * n_devs ) ++ > MAX_DEVS - 1 ) { * n_devs = MAX_DEVS ; if ( verbose ) D ( debug_file , "Found<S2SV_blank>more<S2SV_blank>than<S2SV_blank>%d<S2SV_blank>devices,<S2SV_blank>ignoring<S2SV_blank>the<S2SV_blank>remaining<S2SV_blank>ones" , MAX_DEVS ) ; break ; } if ( verbose ) D ( debug_file , "KeyHandle<S2SV_blank>for<S2SV_blank>device<S2SV_blank>number<S2SV_blank>%d:<S2SV_blank>%s" , i + 1 , s_token ) ; devices [ i ] . keyHandle = strdup ( s_token ) ; if ( ! devices [ i ] . keyHandle ) { if ( verbose ) D ( debug_file , "Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>keyHandle<S2SV_blank>number<S2SV_blank>%d" , i ) ; goto err ; } s_token = strtok_r ( NULL , ":" , & saveptr ) ; if ( ! s_token ) { if ( verbose ) D ( debug_file , "Unable<S2SV_blank>to<S2SV_blank>retrieve<S2SV_blank>publicKey<S2SV_blank>number<S2SV_blank>%d" , i + 1 ) ; goto err ; } if ( verbose ) D ( debug_file , "publicKey<S2SV_blank>for<S2SV_blank>device<S2SV_blank>number<S2SV_blank>%d:<S2SV_blank>%s" , i + 1 , s_token ) ; if ( strlen ( s_token ) % 2 != 0 ) { if ( verbose ) D ( debug_file , "Length<S2SV_blank>of<S2SV_blank>key<S2SV_blank>number<S2SV_blank>%d<S2SV_blank>not<S2SV_blank>even" , i + 1 ) ; goto err ; } devices [ i ] . key_len = strlen ( s_token ) / 2 ; if ( verbose ) D ( debug_file , "Length<S2SV_blank>of<S2SV_blank>key<S2SV_blank>number<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>%zu" , i + 1 , devices [ i ] . key_len ) ; devices [ i ] . publicKey = malloc ( ( sizeof ( unsigned char ) * devices [ i ] . key_len ) ) ; if ( ! devices [ i ] . publicKey ) { if ( verbose ) D ( debug_file , "Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>publicKey<S2SV_blank>number<S2SV_blank>%d" , i ) ; goto err ; } for ( j = 0 ; j < devices [ i ] . key_len ; j ++ ) { unsigned int x ; if ( sscanf ( & s_token [ 2 * j ] , "%2x" , & x ) != 1 ) { if ( verbose ) D ( debug_file , "Invalid<S2SV_blank>hex<S2SV_blank>number<S2SV_blank>in<S2SV_blank>key" ) ; goto err ; } devices [ i ] . publicKey [ j ] = ( unsigned char ) x ; } i ++ ; } } } if ( verbose ) D ( debug_file , "Found<S2SV_blank>%d<S2SV_blank>device(s)<S2SV_blank>for<S2SV_blank>user<S2SV_blank>%s" , * n_devs , username ) ; retval = 1 ; goto out ; err : for ( i = 0 ; i < * n_devs ; i ++ ) { free ( devices [ i ] . keyHandle ) ; free ( devices [ i ] . publicKey ) ; devices [ i ] . keyHandle = NULL ; devices [ i ] . publicKey = NULL ; } * n_devs = 0 ; out : if ( buf ) { free ( buf ) ; buf = NULL ; } if ( opwfile ) fclose ( opwfile ) ; <S2SV_StartBug> else if ( fd >= 0 ) <S2SV_EndBug> close ( fd ) ; return retval ; }
CWE-200 int pam_sm_authenticate ( pam_handle_t * pamh , int flags , int argc , const char * * argv ) { struct passwd * pw = NULL , pw_s ; const char * user = NULL ; cfg_t cfg_st ; cfg_t * cfg = & cfg_st ; char buffer [ BUFSIZE ] ; char * buf = NULL ; char * authfile_dir ; size_t authfile_dir_len ; int pgu_ret , gpn_ret ; int retval = PAM_IGNORE ; device_t * devices = NULL ; unsigned n_devices = 0 ; <S2SV_StartBug> int openasuser ; <S2SV_EndBug> int should_free_origin = 0 ; int should_free_appid = 0 ; int should_free_auth_file = 0 ; <S2SV_StartBug> int should_free_authpending_file = 0 ; <S2SV_EndBug> parse_cfg ( flags , argc , argv , cfg ) ; if ( ! cfg -> origin ) { strcpy ( buffer , DEFAULT_ORIGIN_PREFIX ) ; if ( gethostname ( buffer + strlen ( DEFAULT_ORIGIN_PREFIX ) , BUFSIZE - strlen ( DEFAULT_ORIGIN_PREFIX ) ) == - 1 ) { DBG ( "Unable<S2SV_blank>to<S2SV_blank>get<S2SV_blank>host<S2SV_blank>name" ) ; goto done ; } DBG ( "Origin<S2SV_blank>not<S2SV_blank>specified,<S2SV_blank>using<S2SV_blank>\\"%s\\"" , buffer ) ; cfg -> origin = strdup ( buffer ) ; if ( ! cfg -> origin ) { DBG ( "Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory" ) ; goto done ; } else { should_free_origin = 1 ; } } if ( ! cfg -> appid ) { DBG ( "Appid<S2SV_blank>not<S2SV_blank>specified,<S2SV_blank>using<S2SV_blank>the<S2SV_blank>same<S2SV_blank>value<S2SV_blank>of<S2SV_blank>origin<S2SV_blank>(%s)" , cfg -> origin ) ; cfg -> appid = strdup ( cfg -> origin ) ; if ( ! cfg -> appid ) { DBG ( "Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory" ) goto done ; } else { should_free_appid = 1 ; } } if ( cfg -> max_devs == 0 ) { DBG ( "Maximum<S2SV_blank>devices<S2SV_blank>number<S2SV_blank>not<S2SV_blank>set.<S2SV_blank>Using<S2SV_blank>default<S2SV_blank>(%d)" , MAX_DEVS ) ; cfg -> max_devs = MAX_DEVS ; } devices = malloc ( sizeof ( device_t ) * cfg -> max_devs ) ; if ( ! devices ) { DBG ( "Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory" ) ; retval = PAM_IGNORE ; goto done ; } pgu_ret = pam_get_user ( pamh , & user , NULL ) ; if ( pgu_ret != PAM_SUCCESS || user == NULL ) { DBG ( "Unable<S2SV_blank>to<S2SV_blank>access<S2SV_blank>user<S2SV_blank>%s" , user ) ; retval = PAM_CONV_ERR ; goto done ; } DBG ( "Requesting<S2SV_blank>authentication<S2SV_blank>for<S2SV_blank>user<S2SV_blank>%s" , user ) ; gpn_ret = getpwnam_r ( user , & pw_s , buffer , sizeof ( buffer ) , & pw ) ; if ( gpn_ret != 0 || pw == NULL || pw -> pw_dir == NULL || pw -> pw_dir [ 0 ] != '/' ) { DBG ( "Unable<S2SV_blank>to<S2SV_blank>retrieve<S2SV_blank>credentials<S2SV_blank>for<S2SV_blank>user<S2SV_blank>%s,<S2SV_blank>(%s)" , user , strerror ( errno ) ) ; retval = PAM_USER_UNKNOWN ; goto done ; } DBG ( "Found<S2SV_blank>user<S2SV_blank>%s" , user ) ; DBG ( "Home<S2SV_blank>directory<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>%s" , user , pw -> pw_dir ) ; if ( ! cfg -> auth_file ) { buf = NULL ; authfile_dir = secure_getenv ( DEFAULT_AUTHFILE_DIR_VAR ) ; if ( ! authfile_dir ) { DBG ( "Variable<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>set.<S2SV_blank>Using<S2SV_blank>default<S2SV_blank>value<S2SV_blank>($HOME/.config/)" , DEFAULT_AUTHFILE_DIR_VAR ) ; authfile_dir_len = strlen ( pw -> pw_dir ) + strlen ( "/.config" ) + strlen ( DEFAULT_AUTHFILE ) + 1 ; buf = malloc ( sizeof ( char ) * ( authfile_dir_len ) ) ; if ( ! buf ) { DBG ( "Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory" ) ; retval = PAM_IGNORE ; goto done ; } <S2SV_StartBug> snprintf ( buf , authfile_dir_len , <S2SV_EndBug> "%s/.config%s" , pw -> pw_dir , DEFAULT_AUTHFILE ) ; } else { DBG ( "Variable<S2SV_blank>%s<S2SV_blank>set<S2SV_blank>to<S2SV_blank>%s" , DEFAULT_AUTHFILE_DIR_VAR , authfile_dir ) ; authfile_dir_len = strlen ( authfile_dir ) + strlen ( DEFAULT_AUTHFILE ) + 1 ; buf = malloc ( sizeof ( char ) * ( authfile_dir_len ) ) ; if ( ! buf ) { DBG ( "Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory" ) ; retval = PAM_IGNORE ; goto done ; } snprintf ( buf , authfile_dir_len , "%s%s" , authfile_dir , DEFAULT_AUTHFILE ) ; <S2SV_StartBug> } <S2SV_EndBug> DBG ( "Using<S2SV_blank>default<S2SV_blank>authentication<S2SV_blank>file<S2SV_blank>%s" , buf ) ; <S2SV_StartBug> cfg -> auth_file = buf ; <S2SV_EndBug> should_free_auth_file = 1 ; buf = NULL ; } else { DBG ( "Using<S2SV_blank>authentication<S2SV_blank>file<S2SV_blank>%s" , cfg -> auth_file ) ; } <S2SV_StartBug> openasuser = geteuid ( ) == 0 && cfg -> openasuser ; <S2SV_EndBug> <S2SV_StartBug> if ( openasuser ) { <S2SV_EndBug> <S2SV_StartBug> if ( seteuid ( pw_s . pw_uid ) ) { <S2SV_EndBug> <S2SV_StartBug> DBG ( "Unable<S2SV_blank>to<S2SV_blank>switch<S2SV_blank>user<S2SV_blank>to<S2SV_blank>uid<S2SV_blank>%i" , pw_s . pw_uid ) ; <S2SV_EndBug> retval = PAM_IGNORE ; goto done ; } <S2SV_StartBug> DBG ( "Switched<S2SV_blank>to<S2SV_blank>uid<S2SV_blank>%i" , pw_s . pw_uid ) ; <S2SV_EndBug> } retval = get_devices_from_authfile ( cfg -> auth_file , user , cfg -> max_devs , cfg -> debug , cfg -> debug_file , devices , & n_devices ) ; if ( openasuser ) { <S2SV_StartBug> if ( seteuid ( 0 ) ) { <S2SV_EndBug> DBG ( "Unable<S2SV_blank>to<S2SV_blank>switch<S2SV_blank>back<S2SV_blank>to<S2SV_blank>uid<S2SV_blank>0" ) ; retval = PAM_IGNORE ; goto done ; } <S2SV_StartBug> DBG ( "Switched<S2SV_blank>back<S2SV_blank>to<S2SV_blank>uid<S2SV_blank>0" ) ; <S2SV_EndBug> } if ( retval != 1 ) { n_devices = 0 ; } if ( n_devices == 0 ) { if ( cfg -> nouserok ) { DBG ( "Found<S2SV_blank>no<S2SV_blank>devices<S2SV_blank>but<S2SV_blank>nouserok<S2SV_blank>specified.<S2SV_blank>Skipping<S2SV_blank>authentication" ) ; retval = PAM_SUCCESS ; goto done ; } else if ( retval != 1 ) { DBG ( "Unable<S2SV_blank>to<S2SV_blank>get<S2SV_blank>devices<S2SV_blank>from<S2SV_blank>file<S2SV_blank>%s" , cfg -> auth_file ) ; retval = PAM_AUTHINFO_UNAVAIL ; goto done ; } else { DBG ( "Found<S2SV_blank>no<S2SV_blank>devices.<S2SV_blank>Aborting." ) ; retval = PAM_AUTHINFO_UNAVAIL ; goto done ; } } if ( ! cfg -> authpending_file ) { int actual_size = snprintf ( buffer , BUFSIZE , DEFAULT_AUTHPENDING_FILE_PATH , getuid ( ) ) ; if ( actual_size >= 0 && actual_size < BUFSIZE ) { cfg -> authpending_file = strdup ( buffer ) ; } if ( ! cfg -> authpending_file ) { DBG ( "Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>the<S2SV_blank>authpending_file,<S2SV_blank>touch<S2SV_blank>request<S2SV_blank>notifications<S2SV_blank>will<S2SV_blank>not<S2SV_blank>be<S2SV_blank>emitted" ) ; } else { should_free_authpending_file = 1 ; } } else { if ( strlen ( cfg -> authpending_file ) == 0 ) { DBG ( "authpending_file<S2SV_blank>is<S2SV_blank>set<S2SV_blank>to<S2SV_blank>an<S2SV_blank>empty<S2SV_blank>value,<S2SV_blank>touch<S2SV_blank>request<S2SV_blank>notifications<S2SV_blank>will<S2SV_blank>be<S2SV_blank>disabled" ) ; cfg -> authpending_file = NULL ; } } int authpending_file_descriptor = - 1 ; if ( cfg -> authpending_file ) { DBG ( "Using<S2SV_blank>file<S2SV_blank>\'%s\'<S2SV_blank>for<S2SV_blank>emitting<S2SV_blank>touch<S2SV_blank>request<S2SV_blank>notifications" , cfg -> authpending_file ) ; authpending_file_descriptor = open ( cfg -> authpending_file , O_RDONLY | O_CREAT | O_CLOEXEC | O_NOFOLLOW | O_NOCTTY , 0664 ) ; if ( authpending_file_descriptor < 0 ) { DBG ( "Unable<S2SV_blank>to<S2SV_blank>emit<S2SV_blank>\'authentication<S2SV_blank>started\'<S2SV_blank>notification<S2SV_blank>by<S2SV_blank>opening<S2SV_blank>the<S2SV_blank>file<S2SV_blank>\'%s\',<S2SV_blank>(%s)" , cfg -> authpending_file , strerror ( errno ) ) ; } } if ( cfg -> manual == 0 ) { if ( cfg -> interactive ) { converse ( pamh , PAM_PROMPT_ECHO_ON , cfg -> prompt != NULL ? cfg -> prompt : DEFAULT_PROMPT ) ; } retval = do_authentication ( cfg , devices , n_devices , pamh ) ; } else { retval = do_manual_authentication ( cfg , devices , n_devices , pamh ) ; } if ( authpending_file_descriptor >= 0 ) { if ( close ( authpending_file_descriptor ) < 0 ) { DBG ( "Unable<S2SV_blank>to<S2SV_blank>emit<S2SV_blank>\'authentication<S2SV_blank>stopped\'<S2SV_blank>notification<S2SV_blank>by<S2SV_blank>closing<S2SV_blank>the<S2SV_blank>file<S2SV_blank>\'%s\',<S2SV_blank>(%s)" , cfg -> authpending_file , strerror ( errno ) ) ; } } if ( retval != 1 ) { DBG ( "do_authentication<S2SV_blank>returned<S2SV_blank>%d" , retval ) ; retval = PAM_AUTH_ERR ; goto done ; } retval = PAM_SUCCESS ; done : free_devices ( devices , n_devices ) ; if ( buf ) { free ( buf ) ; buf = NULL ; } if ( should_free_origin ) { free ( ( char * ) cfg -> origin ) ; cfg -> origin = NULL ; } if ( should_free_appid ) { free ( ( char * ) cfg -> appid ) ; cfg -> appid = NULL ; } if ( should_free_auth_file ) { free ( ( char * ) cfg -> auth_file ) ; cfg -> auth_file = NULL ; } if ( should_free_authpending_file ) { free ( ( char * ) cfg -> authpending_file ) ; cfg -> authpending_file = NULL ; } if ( cfg -> alwaysok && retval != PAM_SUCCESS ) { DBG ( "alwaysok<S2SV_blank>needed<S2SV_blank>(otherwise<S2SV_blank>return<S2SV_blank>with<S2SV_blank>%d)" , retval ) ; retval = PAM_SUCCESS ; } DBG ( "done.<S2SV_blank>[%s]" , pam_strerror ( pamh , retval ) ) ; if ( cfg -> is_custom_debug_file ) { fclose ( cfg -> debug_file ) ; } return retval ; }
CWE-200 int check_user_token ( const char * authfile , const char * username , const char * otp_id , int verbose , FILE * debug_file ) { char buf [ 1024 ] ; char * s_user , * s_token ; int retval = AUTH_ERROR ; int fd ; struct stat st ; FILE * opwfile ; fd = open ( authfile , O_RDONLY , 0 ) ; if ( fd < 0 ) { if ( verbose ) D ( debug_file , "Cannot<S2SV_blank>open<S2SV_blank>file:<S2SV_blank>%s<S2SV_blank>(%s)" , authfile , strerror ( errno ) ) ; return retval ; } if ( fstat ( fd , & st ) < 0 ) { if ( verbose ) D ( debug_file , "Cannot<S2SV_blank>stat<S2SV_blank>file:<S2SV_blank>%s<S2SV_blank>(%s)" , authfile , strerror ( errno ) ) ; close ( fd ) ; return retval ; } if ( ! S_ISREG ( st . st_mode ) ) { if ( verbose ) D ( debug_file , "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>regular<S2SV_blank>file" , authfile ) ; close ( fd ) ; return retval ; } opwfile = fdopen ( fd , "r" ) ; if ( opwfile == NULL ) { if ( verbose ) D ( debug_file , "fdopen:<S2SV_blank>%s" , strerror ( errno ) ) ; close ( fd ) ; return retval ; } retval = AUTH_NO_TOKENS ; while ( fgets ( buf , 1024 , opwfile ) ) { char * saveptr = NULL ; if ( buf [ strlen ( buf ) - 1 ] == '\\n' ) buf [ strlen ( buf ) - 1 ] = '\\0' ; if ( buf [ 0 ] == '#' ) { if ( verbose ) D ( debug_file , "Skipping<S2SV_blank>comment<S2SV_blank>line:<S2SV_blank>%s" , buf ) ; continue ; } if ( verbose ) D ( debug_file , "Authorization<S2SV_blank>line:<S2SV_blank>%s" , buf ) ; s_user = strtok_r ( buf , ":" , & saveptr ) ; if ( s_user && strcmp ( username , s_user ) == 0 ) { if ( verbose ) D ( debug_file , "Matched<S2SV_blank>user:<S2SV_blank>%s" , s_user ) ; retval = AUTH_NOT_FOUND ; do { s_token = strtok_r ( NULL , ":" , & saveptr ) ; if ( verbose ) D ( debug_file , "Authorization<S2SV_blank>token:<S2SV_blank>%s" , s_token ) ; if ( s_token && otp_id && strcmp ( otp_id , s_token ) == 0 ) { if ( verbose ) D ( debug_file , "Match<S2SV_blank>user/token<S2SV_blank>as<S2SV_blank>%s/%s" , username , otp_id ) ; <S2SV_StartBug> return AUTH_FOUND ; <S2SV_EndBug> } } while ( s_token != NULL ) ; } } fclose ( opwfile ) ; return retval ; }
CWE-59 static bool parse_cmdline ( int argc , char * * argv ) { int c ; bool reopen_log = false ; int signum ; struct utsname uname_buf ; int longindex ; int curind ; bool bad_option = false ; unsigned facility ; mode_t new_umask_val ; struct option long_options [ ] = { { "use-file" , required_argument , NULL , 'f' } , # if defined _WITH_VRRP_ && defined _WITH_LVS_ { "vrrp" , no_argument , NULL , 'P' } , { "check" , no_argument , NULL , 'C' } , # endif # ifdef _WITH_BFD_ { "no_bfd" , no_argument , NULL , 'B' } , # endif { "all" , no_argument , NULL , 3 } , { "log-console" , no_argument , NULL , 'l' } , { "log-detail" , no_argument , NULL , 'D' } , { "log-facility" , required_argument , NULL , 'S' } , { "log-file" , optional_argument , NULL , 'g' } , { "flush-log-file" , no_argument , NULL , 2 } , { "no-syslog" , no_argument , NULL , 'G' } , { "umask" , required_argument , NULL , 'u' } , # ifdef _WITH_VRRP_ { "release-vips" , no_argument , NULL , 'X' } , { "dont-release-vrrp" , no_argument , NULL , 'V' } , # endif # ifdef _WITH_LVS_ { "dont-release-ipvs" , no_argument , NULL , 'I' } , # endif { "dont-respawn" , no_argument , NULL , 'R' } , { "dont-fork" , no_argument , NULL , 'n' } , { "dump-conf" , no_argument , NULL , 'd' } , { "pid" , required_argument , NULL , 'p' } , # ifdef _WITH_VRRP_ { "vrrp_pid" , required_argument , NULL , 'r' } , # endif # ifdef _WITH_LVS_ { "checkers_pid" , required_argument , NULL , 'c' } , { "address-monitoring" , no_argument , NULL , 'a' } , # endif # ifdef _WITH_BFD_ { "bfd_pid" , required_argument , NULL , 'b' } , # endif # ifdef _WITH_SNMP_ { "snmp" , no_argument , NULL , 'x' } , { "snmp-agent-socket" , required_argument , NULL , 'A' } , # endif { "core-dump" , no_argument , NULL , 'm' } , { "core-dump-pattern" , optional_argument , NULL , 'M' } , # ifdef _MEM_CHECK_LOG_ { "mem-check-log" , no_argument , NULL , 'L' } , # endif # if HAVE_DECL_CLONE_NEWNET { "namespace" , required_argument , NULL , 's' } , # endif { "config-id" , required_argument , NULL , 'i' } , { "signum" , required_argument , NULL , 4 } , { "config-test" , optional_argument , NULL , 't' } , # ifdef _WITH_PERF_ { "perf" , optional_argument , NULL , 5 } , # endif # ifdef WITH_DEBUG_OPTIONS { "debug" , optional_argument , NULL , 6 } , # endif { "version" , no_argument , NULL , 'v' } , { "help" , no_argument , NULL , 'h' } , { NULL , 0 , NULL , 0 } } ; curind = optind ; while ( longindex = - 1 , ( c = getopt_long ( argc , argv , ":vhlndu:DRS:f:p:i:mM::g::Gt::" # if defined _WITH_VRRP_ && defined _WITH_LVS_ "PC" # endif # ifdef _WITH_VRRP_ "r:VX" # endif # ifdef _WITH_LVS_ "ac:I" # endif # ifdef _WITH_BFD_ "Bb:" # endif # ifdef _WITH_SNMP_ "xA:" # endif # ifdef _MEM_CHECK_LOG_ "L" # endif # if HAVE_DECL_CLONE_NEWNET "s:" # endif , long_options , & longindex ) ) != - 1 ) { if ( longindex >= 0 && long_options [ longindex ] . has_arg == required_argument && optarg && ! optarg [ 0 ] ) { c = ':' ; optarg = NULL ; } switch ( c ) { case 'v' : fprintf ( stderr , "%s" , version_string ) ; # ifdef GIT_COMMIT fprintf ( stderr , ",<S2SV_blank>git<S2SV_blank>commit<S2SV_blank>%s" , GIT_COMMIT ) ; # endif fprintf ( stderr , "\\n\\n%s\\n\\n" , COPYRIGHT_STRING ) ; fprintf ( stderr , "Built<S2SV_blank>with<S2SV_blank>kernel<S2SV_blank>headers<S2SV_blank>for<S2SV_blank>Linux<S2SV_blank>%d.%d.%d\\n" , ( LINUX_VERSION_CODE >> 16 ) & 0xff , ( LINUX_VERSION_CODE >> 8 ) & 0xff , ( LINUX_VERSION_CODE ) & 0xff ) ; uname ( & uname_buf ) ; fprintf ( stderr , "Running<S2SV_blank>on<S2SV_blank>%s<S2SV_blank>%s<S2SV_blank>%s\\n\\n" , uname_buf . sysname , uname_buf . release , uname_buf . version ) ; fprintf ( stderr , "configure<S2SV_blank>options:<S2SV_blank>%s\\n\\n" , KEEPALIVED_CONFIGURE_OPTIONS ) ; fprintf ( stderr , "Config<S2SV_blank>options:<S2SV_blank>%s\\n\\n" , CONFIGURATION_OPTIONS ) ; fprintf ( stderr , "System<S2SV_blank>options:<S2SV_blank>%s\\n" , SYSTEM_OPTIONS ) ; exit ( 0 ) ; break ; case 'h' : usage ( argv [ 0 ] ) ; exit ( 0 ) ; break ; case 'l' : __set_bit ( LOG_CONSOLE_BIT , & debug ) ; reopen_log = true ; break ; case 'n' : __set_bit ( DONT_FORK_BIT , & debug ) ; break ; case 'd' : __set_bit ( DUMP_CONF_BIT , & debug ) ; break ; # ifdef _WITH_VRRP_ case 'V' : __set_bit ( DONT_RELEASE_VRRP_BIT , & debug ) ; break ; # endif # ifdef _WITH_LVS_ case 'I' : __set_bit ( DONT_RELEASE_IPVS_BIT , & debug ) ; break ; # endif case 'D' : if ( __test_bit ( LOG_DETAIL_BIT , & debug ) ) __set_bit ( LOG_EXTRA_DETAIL_BIT , & debug ) ; else __set_bit ( LOG_DETAIL_BIT , & debug ) ; break ; case 'R' : __set_bit ( DONT_RESPAWN_BIT , & debug ) ; break ; # ifdef _WITH_VRRP_ case 'X' : __set_bit ( RELEASE_VIPS_BIT , & debug ) ; break ; # endif case 'S' : if ( ! read_unsigned ( optarg , & facility , 0 , LOG_FACILITY_MAX , false ) ) fprintf ( stderr , "Invalid<S2SV_blank>log<S2SV_blank>facility<S2SV_blank>\'%s\'\\n" , optarg ) ; else { log_facility = LOG_FACILITY [ facility ] . facility ; reopen_log = true ; } break ; case 'g' : if ( optarg && optarg [ 0 ] ) log_file_name = optarg ; else log_file_name = "/tmp/keepalived.log" ; open_log_file ( log_file_name , NULL , NULL , NULL ) ; break ; case 'G' : __set_bit ( NO_SYSLOG_BIT , & debug ) ; reopen_log = true ; break ; case 'u' : new_umask_val = set_umask ( optarg ) ; if ( umask_cmdline ) umask_val = new_umask_val ; break ; case 't' : __set_bit ( CONFIG_TEST_BIT , & debug ) ; __set_bit ( DONT_RESPAWN_BIT , & debug ) ; __set_bit ( DONT_FORK_BIT , & debug ) ; __set_bit ( NO_SYSLOG_BIT , & debug ) ; if ( optarg && optarg [ 0 ] ) { <S2SV_StartBug> int fd = open ( optarg , O_WRONLY | O_APPEND | O_CREAT , S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH ) ; <S2SV_EndBug> if ( fd == - 1 ) { fprintf ( stderr , "Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>config-test<S2SV_blank>log<S2SV_blank>file<S2SV_blank>%s\\n" , optarg ) ; exit ( EXIT_FAILURE ) ; } dup2 ( fd , STDERR_FILENO ) ; close ( fd ) ; } break ; case 'f' : conf_file = optarg ; break ; case 2 : set_flush_log_file ( ) ; break ; # if defined _WITH_VRRP_ && defined _WITH_LVS_ case 'P' : __clear_bit ( DAEMON_CHECKERS , & daemon_mode ) ; break ; case 'C' : __clear_bit ( DAEMON_VRRP , & daemon_mode ) ; break ; # endif # ifdef _WITH_BFD_ case 'B' : __clear_bit ( DAEMON_BFD , & daemon_mode ) ; break ; # endif case 'p' : main_pidfile = optarg ; break ; # ifdef _WITH_LVS_ case 'c' : checkers_pidfile = optarg ; break ; case 'a' : __set_bit ( LOG_ADDRESS_CHANGES , & debug ) ; break ; # endif # ifdef _WITH_VRRP_ case 'r' : vrrp_pidfile = optarg ; break ; # endif # ifdef _WITH_BFD_ case 'b' : bfd_pidfile = optarg ; break ; # endif # ifdef _WITH_SNMP_ case 'x' : snmp = 1 ; break ; case 'A' : snmp_socket = optarg ; break ; # endif case 'M' : set_core_dump_pattern = true ; if ( optarg && optarg [ 0 ] ) core_dump_pattern = optarg ; case 'm' : create_core_dump = true ; break ; # ifdef _MEM_CHECK_LOG_ case 'L' : __set_bit ( MEM_CHECK_LOG_BIT , & debug ) ; break ; # endif # if HAVE_DECL_CLONE_NEWNET case 's' : override_namespace = MALLOC ( strlen ( optarg ) + 1 ) ; strcpy ( override_namespace , optarg ) ; break ; # endif case 'i' : FREE_PTR ( config_id ) ; config_id = MALLOC ( strlen ( optarg ) + 1 ) ; strcpy ( config_id , optarg ) ; break ; case 4 : signum = get_signum ( optarg ) ; if ( signum == - 1 ) { fprintf ( stderr , "Unknown<S2SV_blank>sigfunc<S2SV_blank>%s\\n" , optarg ) ; exit ( 1 ) ; } printf ( "%d\\n" , signum ) ; exit ( 0 ) ; break ; case 3 : __set_bit ( RUN_ALL_CHILDREN , & daemon_mode ) ; # ifdef _WITH_VRRP_ __set_bit ( DAEMON_VRRP , & daemon_mode ) ; # endif # ifdef _WITH_LVS_ __set_bit ( DAEMON_CHECKERS , & daemon_mode ) ; # endif # ifdef _WITH_BFD_ __set_bit ( DAEMON_BFD , & daemon_mode ) ; # endif break ; # ifdef _WITH_PERF_ case 5 : if ( optarg && optarg [ 0 ] ) { if ( ! strcmp ( optarg , "run" ) ) perf_run = PERF_RUN ; else if ( ! strcmp ( optarg , "all" ) ) perf_run = PERF_ALL ; else if ( ! strcmp ( optarg , "end" ) ) perf_run = PERF_END ; else log_message ( LOG_INFO , "Unknown<S2SV_blank>perf<S2SV_blank>start<S2SV_blank>point<S2SV_blank>%s" , optarg ) ; } else perf_run = PERF_RUN ; break ; # endif # ifdef WITH_DEBUG_OPTIONS case 6 : set_debug_options ( optarg && optarg [ 0 ] ? optarg : NULL ) ; break ; # endif case '?' : if ( optopt && argv [ curind ] [ 1 ] != '-' ) fprintf ( stderr , "Unknown<S2SV_blank>option<S2SV_blank>-%c\\n" , optopt ) ; else fprintf ( stderr , "Unknown<S2SV_blank>option<S2SV_blank>%s\\n" , argv [ curind ] ) ; bad_option = true ; break ; case ':' : if ( optopt && argv [ curind ] [ 1 ] != '-' ) fprintf ( stderr , "Missing<S2SV_blank>parameter<S2SV_blank>for<S2SV_blank>option<S2SV_blank>-%c\\n" , optopt ) ; else fprintf ( stderr , "Missing<S2SV_blank>parameter<S2SV_blank>for<S2SV_blank>option<S2SV_blank>--%s\\n" , long_options [ longindex ] . name ) ; bad_option = true ; break ; default : exit ( 1 ) ; break ; } curind = optind ; } if ( optind < argc ) { printf ( "Unexpected<S2SV_blank>argument(s):<S2SV_blank>" ) ; while ( optind < argc ) printf ( "%s<S2SV_blank>" , argv [ optind ++ ] ) ; printf ( "\\n" ) ; } if ( bad_option ) exit ( 1 ) ; return reopen_log ; }
CWE-59 int pidfile_write ( const char * pid_file , int pid ) { FILE * pidfile = NULL ; <S2SV_StartBug> int pidfd = creat ( pid_file , S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH ) ; <S2SV_EndBug> if ( pidfd != - 1 ) pidfile = fdopen ( pidfd , "w" ) ; if ( ! pidfile ) { log_message ( LOG_INFO , "pidfile_write<S2SV_blank>:<S2SV_blank>Cannot<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>pidfile" , pid_file ) ; return 0 ; } fprintf ( pidfile , "%d\\n" , pid ) ; fclose ( pidfile ) ; return 1 ; }
CWE-59 static gchar * read_file ( gchar * filepath ) { FILE * f ; size_t length ; gchar * ret = NULL ; <S2SV_StartBug> f = fopen ( filepath , "rb" ) ; <S2SV_EndBug> if ( f ) { fseek ( f , 0 , SEEK_END ) ; length = ( size_t ) ftell ( f ) ; fseek ( f , 0 , SEEK_SET ) ; ret = MALLOC ( length + 1 ) ; if ( ret ) { if ( fread ( ret , length , 1 , f ) != 1 ) { log_message ( LOG_INFO , "Failed<S2SV_blank>to<S2SV_blank>read<S2SV_blank>all<S2SV_blank>of<S2SV_blank>%s" , filepath ) ; } ret [ length ] = '\\0' ; } else log_message ( LOG_INFO , "Unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>Dbus<S2SV_blank>file<S2SV_blank>%s" , filepath ) ; fclose ( f ) ; } return ret ; }
CWE-59 void vrrp_print_json ( void ) { FILE * file ; element e ; struct json_object * array ; if ( LIST_ISEMPTY ( vrrp_data -> vrrp ) ) return ; <S2SV_StartBug> file = fopen ( "/tmp/keepalived.json" , "w" ) ; <S2SV_EndBug> if ( ! file ) { log_message ( LOG_INFO , "Can\'t<S2SV_blank>open<S2SV_blank>/tmp/keepalived.json<S2SV_blank>(%d:<S2SV_blank>%s)" , errno , strerror ( errno ) ) ; return ; } array = json_object_new_array ( ) ; for ( e = LIST_HEAD ( vrrp_data -> vrrp ) ; e ; ELEMENT_NEXT ( e ) ) { struct json_object * instance_json , * json_stats , * json_data , * vips , * evips , * track_ifp , * track_script ; # ifdef _HAVE_FIB_ROUTING_ struct json_object * vroutes , * vrules ; # endif element f ; vrrp_t * vrrp = ELEMENT_DATA ( e ) ; instance_json = json_object_new_object ( ) ; json_stats = json_object_new_object ( ) ; json_data = json_object_new_object ( ) ; vips = json_object_new_array ( ) ; evips = json_object_new_array ( ) ; track_ifp = json_object_new_array ( ) ; track_script = json_object_new_array ( ) ; # ifdef _HAVE_FIB_ROUTING_ vroutes = json_object_new_array ( ) ; vrules = json_object_new_array ( ) ; # endif json_object_object_add ( json_data , "iname" , json_object_new_string ( vrrp -> iname ) ) ; json_object_object_add ( json_data , "dont_track_primary" , json_object_new_int ( vrrp -> dont_track_primary ) ) ; json_object_object_add ( json_data , "skip_check_adv_addr" , json_object_new_int ( vrrp -> skip_check_adv_addr ) ) ; json_object_object_add ( json_data , "strict_mode" , json_object_new_int ( ( int ) vrrp -> strict_mode ) ) ; # ifdef _HAVE_VRRP_VMAC_ json_object_object_add ( json_data , "vmac_ifname" , json_object_new_string ( vrrp -> vmac_ifname ) ) ; # endif if ( ! LIST_ISEMPTY ( vrrp -> track_ifp ) ) { for ( f = LIST_HEAD ( vrrp -> track_ifp ) ; f ; ELEMENT_NEXT ( f ) ) { interface_t * ifp = ELEMENT_DATA ( f ) ; json_object_array_add ( track_ifp , json_object_new_string ( ifp -> ifname ) ) ; } } json_object_object_add ( json_data , "track_ifp" , track_ifp ) ; if ( ! LIST_ISEMPTY ( vrrp -> track_script ) ) { for ( f = LIST_HEAD ( vrrp -> track_script ) ; f ; ELEMENT_NEXT ( f ) ) { tracked_sc_t * tsc = ELEMENT_DATA ( f ) ; vrrp_script_t * vscript = tsc -> scr ; json_object_array_add ( track_script , json_object_new_string ( cmd_str ( & vscript -> script ) ) ) ; } } json_object_object_add ( json_data , "track_script" , track_script ) ; json_object_object_add ( json_data , "ifp_ifname" , json_object_new_string ( vrrp -> ifp -> ifname ) ) ; json_object_object_add ( json_data , "master_priority" , json_object_new_int ( vrrp -> master_priority ) ) ; json_object_object_add ( json_data , "last_transition" , json_object_new_double ( timeval_to_double ( & vrrp -> last_transition ) ) ) ; json_object_object_add ( json_data , "garp_delay" , json_object_new_double ( vrrp -> garp_delay / TIMER_HZ_FLOAT ) ) ; json_object_object_add ( json_data , "garp_refresh" , json_object_new_int ( ( int ) vrrp -> garp_refresh . tv_sec ) ) ; json_object_object_add ( json_data , "garp_rep" , json_object_new_int ( ( int ) vrrp -> garp_rep ) ) ; json_object_object_add ( json_data , "garp_refresh_rep" , json_object_new_int ( ( int ) vrrp -> garp_refresh_rep ) ) ; json_object_object_add ( json_data , "garp_lower_prio_delay" , json_object_new_int ( ( int ) ( vrrp -> garp_lower_prio_delay / TIMER_HZ ) ) ) ; json_object_object_add ( json_data , "garp_lower_prio_rep" , json_object_new_int ( ( int ) vrrp -> garp_lower_prio_rep ) ) ; json_object_object_add ( json_data , "lower_prio_no_advert" , json_object_new_int ( ( int ) vrrp -> lower_prio_no_advert ) ) ; json_object_object_add ( json_data , "higher_prio_send_advert" , json_object_new_int ( ( int ) vrrp -> higher_prio_send_advert ) ) ; json_object_object_add ( json_data , "vrid" , json_object_new_int ( vrrp -> vrid ) ) ; json_object_object_add ( json_data , "base_priority" , json_object_new_int ( vrrp -> base_priority ) ) ; json_object_object_add ( json_data , "effective_priority" , json_object_new_int ( vrrp -> effective_priority ) ) ; json_object_object_add ( json_data , "vipset" , json_object_new_boolean ( vrrp -> vipset ) ) ; if ( ! LIST_ISEMPTY ( vrrp -> vip ) ) { for ( f = LIST_HEAD ( vrrp -> vip ) ; f ; ELEMENT_NEXT ( f ) ) { ip_address_t * vip = ELEMENT_DATA ( f ) ; char ipaddr [ INET6_ADDRSTRLEN ] ; inet_ntop ( vrrp -> family , & ( vip -> u . sin . sin_addr . s_addr ) , ipaddr , INET6_ADDRSTRLEN ) ; json_object_array_add ( vips , json_object_new_string ( ipaddr ) ) ; } } json_object_object_add ( json_data , "vips" , vips ) ; if ( ! LIST_ISEMPTY ( vrrp -> evip ) ) { for ( f = LIST_HEAD ( vrrp -> evip ) ; f ; ELEMENT_NEXT ( f ) ) { ip_address_t * evip = ELEMENT_DATA ( f ) ; char ipaddr [ INET6_ADDRSTRLEN ] ; inet_ntop ( vrrp -> family , & ( evip -> u . sin . sin_addr . s_addr ) , ipaddr , INET6_ADDRSTRLEN ) ; json_object_array_add ( evips , json_object_new_string ( ipaddr ) ) ; } } json_object_object_add ( json_data , "evips" , evips ) ; json_object_object_add ( json_data , "promote_secondaries" , json_object_new_boolean ( vrrp -> promote_secondaries ) ) ; # ifdef _HAVE_FIB_ROUTING_ if ( ! LIST_ISEMPTY ( vrrp -> vroutes ) ) { for ( f = LIST_HEAD ( vrrp -> vroutes ) ; f ; ELEMENT_NEXT ( f ) ) { ip_route_t * route = ELEMENT_DATA ( f ) ; char * buf = MALLOC ( ROUTE_BUF_SIZE ) ; format_iproute ( route , buf , ROUTE_BUF_SIZE ) ; json_object_array_add ( vroutes , json_object_new_string ( buf ) ) ; } } json_object_object_add ( json_data , "vroutes" , vroutes ) ; if ( ! LIST_ISEMPTY ( vrrp -> vrules ) ) { for ( f = LIST_HEAD ( vrrp -> vrules ) ; f ; ELEMENT_NEXT ( f ) ) { ip_rule_t * rule = ELEMENT_DATA ( f ) ; char * buf = MALLOC ( RULE_BUF_SIZE ) ; format_iprule ( rule , buf , RULE_BUF_SIZE ) ; json_object_array_add ( vrules , json_object_new_string ( buf ) ) ; } } json_object_object_add ( json_data , "vrules" , vrules ) ; # endif json_object_object_add ( json_data , "adver_int" , json_object_new_double ( vrrp -> adver_int / TIMER_HZ_FLOAT ) ) ; json_object_object_add ( json_data , "master_adver_int" , json_object_new_double ( vrrp -> master_adver_int / TIMER_HZ_FLOAT ) ) ; json_object_object_add ( json_data , "accept" , json_object_new_int ( ( int ) vrrp -> accept ) ) ; json_object_object_add ( json_data , "nopreempt" , json_object_new_boolean ( vrrp -> nopreempt ) ) ; json_object_object_add ( json_data , "preempt_delay" , json_object_new_int ( ( int ) ( vrrp -> preempt_delay / TIMER_HZ ) ) ) ; json_object_object_add ( json_data , "state" , json_object_new_int ( vrrp -> state ) ) ; json_object_object_add ( json_data , "wantstate" , json_object_new_int ( vrrp -> wantstate ) ) ; json_object_object_add ( json_data , "version" , json_object_new_int ( vrrp -> version ) ) ; if ( vrrp -> script_backup ) json_object_object_add ( json_data , "script_backup" , json_object_new_string ( cmd_str ( vrrp -> script_backup ) ) ) ; if ( vrrp -> script_master ) json_object_object_add ( json_data , "script_master" , json_object_new_string ( cmd_str ( vrrp -> script_master ) ) ) ; if ( vrrp -> script_fault ) json_object_object_add ( json_data , "script_fault" , json_object_new_string ( cmd_str ( vrrp -> script_fault ) ) ) ; if ( vrrp -> script_stop ) json_object_object_add ( json_data , "script_stop" , json_object_new_string ( cmd_str ( vrrp -> script_stop ) ) ) ; if ( vrrp -> script ) json_object_object_add ( json_data , "script" , json_object_new_string ( cmd_str ( vrrp -> script ) ) ) ; if ( vrrp -> script_master_rx_lower_pri ) json_object_object_add ( json_data , "script_master_rx_lower_pri" , json_object_new_string ( cmd_str ( vrrp -> script_master_rx_lower_pri ) ) ) ; json_object_object_add ( json_data , "smtp_alert" , json_object_new_boolean ( vrrp -> smtp_alert ) ) ; # ifdef _WITH_VRRP_AUTH_ if ( vrrp -> auth_type ) { json_object_object_add ( json_data , "auth_type" , json_object_new_int ( vrrp -> auth_type ) ) ; if ( vrrp -> auth_type != VRRP_AUTH_AH ) { char auth_data [ sizeof ( vrrp -> auth_data ) + 1 ] ; memcpy ( auth_data , vrrp -> auth_data , sizeof ( vrrp -> auth_data ) ) ; auth_data [ sizeof ( vrrp -> auth_data ) ] = '\\0' ; json_object_object_add ( json_data , "auth_data" , json_object_new_string ( auth_data ) ) ; } } else json_object_object_add ( json_data , "auth_type" , json_object_new_int ( 0 ) ) ; # endif json_object_object_add ( json_stats , "advert_rcvd" , json_object_new_int64 ( ( int64_t ) vrrp -> stats -> advert_rcvd ) ) ; json_object_object_add ( json_stats , "advert_sent" , json_object_new_int64 ( vrrp -> stats -> advert_sent ) ) ; json_object_object_add ( json_stats , "become_master" , json_object_new_int64 ( vrrp -> stats -> become_master ) ) ; json_object_object_add ( json_stats , "release_master" , json_object_new_int64 ( vrrp -> stats -> release_master ) ) ; json_object_object_add ( json_stats , "packet_len_err" , json_object_new_int64 ( ( int64_t ) vrrp -> stats -> packet_len_err ) ) ; json_object_object_add ( json_stats , "advert_interval_err" , json_object_new_int64 ( ( int64_t ) vrrp -> stats -> advert_interval_err ) ) ; json_object_object_add ( json_stats , "ip_ttl_err" , json_object_new_int64 ( ( int64_t ) vrrp -> stats -> ip_ttl_err ) ) ; json_object_object_add ( json_stats , "invalid_type_rcvd" , json_object_new_int64 ( ( int64_t ) vrrp -> stats -> invalid_type_rcvd ) ) ; json_object_object_add ( json_stats , "addr_list_err" , json_object_new_int64 ( ( int64_t ) vrrp -> stats -> addr_list_err ) ) ; json_object_object_add ( json_stats , "invalid_authtype" , json_object_new_int64 ( vrrp -> stats -> invalid_authtype ) ) ; # ifdef _WITH_VRRP_AUTH_ json_object_object_add ( json_stats , "authtype_mismatch" , json_object_new_int64 ( vrrp -> stats -> authtype_mismatch ) ) ; json_object_object_add ( json_stats , "auth_failure" , json_object_new_int64 ( vrrp -> stats -> auth_failure ) ) ; # endif json_object_object_add ( json_stats , "pri_zero_rcvd" , json_object_new_int64 ( ( int64_t ) vrrp -> stats -> pri_zero_rcvd ) ) ; json_object_object_add ( json_stats , "pri_zero_sent" , json_object_new_int64 ( ( int64_t ) vrrp -> stats -> pri_zero_sent ) ) ; json_object_object_add ( instance_json , "data" , json_data ) ; json_object_object_add ( instance_json , "stats" , json_stats ) ; json_object_array_add ( array , instance_json ) ; } fprintf ( file , "%s" , json_object_to_json_string ( array ) ) ; fclose ( file ) ; }
CWE-59 static void vrrp_tfile_end_handler ( void ) { vrrp_tracked_file_t * tfile = LIST_TAIL_DATA ( vrrp_data -> vrrp_track_files ) ; struct stat statb ; FILE * tf ; int ret ; if ( ! tfile -> file_path ) { report_config_error ( CONFIG_GENERAL_ERROR , "No<S2SV_blank>file<S2SV_blank>set<S2SV_blank>for<S2SV_blank>track_file<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>removing" , tfile -> fname ) ; free_list_element ( vrrp_data -> vrrp_track_files , vrrp_data -> vrrp_track_files -> tail ) ; return ; } if ( track_file_init == TRACK_FILE_NO_INIT ) return ; ret = stat ( tfile -> file_path , & statb ) ; if ( ! ret ) { if ( track_file_init == TRACK_FILE_CREATE ) { return ; } if ( ( statb . st_mode & S_IFMT ) != S_IFREG ) { report_config_error ( CONFIG_GENERAL_ERROR , "Cannot<S2SV_blank>initialise<S2SV_blank>track<S2SV_blank>file<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>it<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>regular<S2SV_blank>file" , tfile -> fname ) ; return ; } if ( reload ) return ; } if ( ! __test_bit ( CONFIG_TEST_BIT , & debug ) ) { <S2SV_StartBug> if ( ( tf = fopen ( tfile -> file_path , "w" ) ) ) { <S2SV_EndBug> fprintf ( tf , "%d\\n" , track_file_init_value ) ; fclose ( tf ) ; } else report_config_error ( CONFIG_GENERAL_ERROR , "Unable<S2SV_blank>to<S2SV_blank>initialise<S2SV_blank>track<S2SV_blank>file<S2SV_blank>%s" , tfile -> fname ) ; } }
CWE-59 void vrrp_print_data ( void ) { <S2SV_StartBug> FILE * file = fopen ( dump_file , "w" ) ; <S2SV_EndBug> if ( ! file ) { log_message ( LOG_INFO , "Can\'t<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>(%d:<S2SV_blank>%s)" , dump_file , errno , strerror ( errno ) ) ; return ; } dump_data_vrrp ( file ) ; fclose ( file ) ; }
CWE-59 void vrrp_print_stats ( void ) { <S2SV_StartBug> FILE * file ; <S2SV_EndBug> <S2SV_StartBug> file = fopen ( stats_file , "w" ) ; <S2SV_EndBug> if ( ! file ) { log_message ( LOG_INFO , "Can\'t<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>(%d:<S2SV_blank>%s)" , stats_file , errno , strerror ( errno ) ) ; return ; } list l = vrrp_data -> vrrp ; element e ; vrrp_t * vrrp ; <S2SV_StartBug> for ( e = LIST_HEAD ( l ) ; e ; ELEMENT_NEXT ( e ) ) { <S2SV_EndBug> vrrp = ELEMENT_DATA ( e ) ; fprintf ( file , "VRRP<S2SV_blank>Instance:<S2SV_blank>%s\\n" , vrrp -> iname ) ; fprintf ( file , "<S2SV_blank><S2SV_blank>Advertisements:\\n" ) ; fprintf ( file , "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Received:<S2SV_blank>%" PRIu64 "\\n" , vrrp -> stats -> advert_rcvd ) ; fprintf ( file , "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Sent:<S2SV_blank>%d\\n" , vrrp -> stats -> advert_sent ) ; fprintf ( file , "<S2SV_blank><S2SV_blank>Became<S2SV_blank>master:<S2SV_blank>%d\\n" , vrrp -> stats -> become_master ) ; fprintf ( file , "<S2SV_blank><S2SV_blank>Released<S2SV_blank>master:<S2SV_blank>%d\\n" , vrrp -> stats -> release_master ) ; fprintf ( file , "<S2SV_blank><S2SV_blank>Packet<S2SV_blank>Errors:\\n" ) ; fprintf ( file , "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Length:<S2SV_blank>%" PRIu64 "\\n" , vrrp -> stats -> packet_len_err ) ; fprintf ( file , "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>TTL:<S2SV_blank>%" PRIu64 "\\n" , vrrp -> stats -> ip_ttl_err ) ; fprintf ( file , "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Invalid<S2SV_blank>Type:<S2SV_blank>%" PRIu64 "\\n" , vrrp -> stats -> invalid_type_rcvd ) ; fprintf ( file , "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Advertisement<S2SV_blank>Interval:<S2SV_blank>%" PRIu64 "\\n" , vrrp -> stats -> advert_interval_err ) ; fprintf ( file , "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Address<S2SV_blank>List:<S2SV_blank>%" PRIu64 "\\n" , vrrp -> stats -> addr_list_err ) ; fprintf ( file , "<S2SV_blank><S2SV_blank>Authentication<S2SV_blank>Errors:\\n" ) ; fprintf ( file , "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Invalid<S2SV_blank>Type:<S2SV_blank>%d\\n" , vrrp -> stats -> invalid_authtype ) ; # ifdef _WITH_VRRP_AUTH_ fprintf ( file , "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Type<S2SV_blank>Mismatch:<S2SV_blank>%d\\n" , vrrp -> stats -> authtype_mismatch ) ; fprintf ( file , "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Failure:<S2SV_blank>%d\\n" , vrrp -> stats -> auth_failure ) ; # endif fprintf ( file , "<S2SV_blank><S2SV_blank>Priority<S2SV_blank>Zero:\\n" ) ; fprintf ( file , "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Received:<S2SV_blank>%" PRIu64 "\\n" , vrrp -> stats -> pri_zero_rcvd ) ; fprintf ( file , "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Sent:<S2SV_blank>%" PRIu64 "\\n" , vrrp -> stats -> pri_zero_sent ) ; } fclose ( file ) ; }
CWE-59 void open_log_file ( const char * name , const char * prog , const char * namespace , const char * instance ) { char * file_name ; if ( log_file ) { fclose ( log_file ) ; log_file = NULL ; } if ( ! name ) return ; file_name = make_file_name ( name , prog , namespace , instance ) ; <S2SV_StartBug> log_file = fopen ( file_name , "a" ) ; <S2SV_EndBug> if ( log_file ) { int n = fileno ( log_file ) ; fcntl ( n , F_SETFD , FD_CLOEXEC | fcntl ( n , F_GETFD ) ) ; fcntl ( n , F_SETFL , O_NONBLOCK | fcntl ( n , F_GETFL ) ) ; } FREE ( file_name ) ; }
CWE-59 static void fifo_open ( notify_fifo_t * fifo , int ( * script_exit ) ( thread_t * ) , const char * type ) { int ret ; int sav_errno ; if ( fifo -> name ) { sav_errno = 0 ; if ( ! ( ret = mkfifo ( fifo -> name , S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH ) ) ) fifo -> created_fifo = true ; else { sav_errno = errno ; if ( sav_errno != EEXIST ) log_message ( LOG_INFO , "Unable<S2SV_blank>to<S2SV_blank>create<S2SV_blank>%snotify<S2SV_blank>fifo<S2SV_blank>%s" , type , fifo -> name ) ; } if ( ! sav_errno || sav_errno == EEXIST ) { if ( fifo -> script ) notify_fifo_exec ( master , script_exit , fifo , fifo -> script ) ; <S2SV_StartBug> if ( ( fifo -> fd = open ( fifo -> name , O_RDWR | O_CLOEXEC | O_NONBLOCK ) ) == - 1 ) { <S2SV_EndBug> log_message ( LOG_INFO , "Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%snotify<S2SV_blank>fifo<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>errno<S2SV_blank>%d" , type , fifo -> name , errno ) ; if ( fifo -> created_fifo ) { unlink ( fifo -> name ) ; fifo -> created_fifo = false ; } } } if ( fifo -> fd == - 1 ) { FREE ( fifo -> name ) ; fifo -> name = NULL ; } } }
CWE-200 static mode_t set_umask ( const char * optarg ) { long umask_long ; mode_t umask_val ; char * endptr ; umask_long = strtoll ( optarg , & endptr , 0 ) ; if ( * endptr || umask_long < 0 || umask_long & ~ 0777L ) { fprintf ( stderr , "Invalid<S2SV_blank>--umask<S2SV_blank>option<S2SV_blank>%s" , optarg ) ; <S2SV_StartBug> return ; <S2SV_EndBug> } umask_val = umask_long & 0777 ; umask ( umask_val ) ; umask_cmdline = true ; return umask_val ; }
CWE-200 void dump_global_data ( FILE * fp , data_t * data ) { # ifdef _WITH_VRRP_ char buf [ 64 ] ; # endif if ( ! data ) return ; conf_write ( fp , "------<<S2SV_blank>Global<S2SV_blank>definitions<S2SV_blank>>------" ) ; # if HAVE_DECL_CLONE_NEWNET conf_write ( fp , "<S2SV_blank>Network<S2SV_blank>namespace<S2SV_blank>=<S2SV_blank>%s" , data -> network_namespace ? data -> network_namespace : "(default)" ) ; # endif if ( data -> instance_name ) conf_write ( fp , "<S2SV_blank>Instance<S2SV_blank>name<S2SV_blank>=<S2SV_blank>%s" , data -> instance_name ) ; if ( data -> router_id ) conf_write ( fp , "<S2SV_blank>Router<S2SV_blank>ID<S2SV_blank>=<S2SV_blank>%s" , data -> router_id ) ; if ( data -> smtp_server . ss_family ) { conf_write ( fp , "<S2SV_blank>Smtp<S2SV_blank>server<S2SV_blank>=<S2SV_blank>%s" , inet_sockaddrtos ( & data -> smtp_server ) ) ; conf_write ( fp , "<S2SV_blank>Smtp<S2SV_blank>server<S2SV_blank>port<S2SV_blank>=<S2SV_blank>%u" , ntohs ( inet_sockaddrport ( & data -> smtp_server ) ) ) ; } if ( data -> smtp_helo_name ) conf_write ( fp , "<S2SV_blank>Smtp<S2SV_blank>HELO<S2SV_blank>name<S2SV_blank>=<S2SV_blank>%s" , data -> smtp_helo_name ) ; if ( data -> smtp_connection_to ) conf_write ( fp , "<S2SV_blank>Smtp<S2SV_blank>server<S2SV_blank>connection<S2SV_blank>timeout<S2SV_blank>=<S2SV_blank>%lu" , data -> smtp_connection_to / TIMER_HZ ) ; if ( data -> email_from ) { conf_write ( fp , "<S2SV_blank>Email<S2SV_blank>notification<S2SV_blank>from<S2SV_blank>=<S2SV_blank>%s" , data -> email_from ) ; dump_list ( fp , data -> email ) ; } conf_write ( fp , "<S2SV_blank>Default<S2SV_blank>smtp_alert<S2SV_blank>=<S2SV_blank>%s" , data -> smtp_alert == - 1 ? "unset" : data -> smtp_alert ? "on" : "off" ) ; # ifdef _WITH_VRRP_ conf_write ( fp , "<S2SV_blank>Default<S2SV_blank>smtp_alert_vrrp<S2SV_blank>=<S2SV_blank>%s" , data -> smtp_alert_vrrp == - 1 ? "unset" : data -> smtp_alert_vrrp ? "on" : "off" ) ; # endif # ifdef _WITH_LVS_ conf_write ( fp , "<S2SV_blank>Default<S2SV_blank>smtp_alert_checker<S2SV_blank>=<S2SV_blank>%s" , data -> smtp_alert_checker == - 1 ? "unset" : data -> smtp_alert_checker ? "on" : "off" ) ; # endif # ifdef _WITH_VRRP_ conf_write ( fp , "<S2SV_blank>Dynamic<S2SV_blank>interfaces<S2SV_blank>=<S2SV_blank>%s" , data -> dynamic_interfaces ? "true" : "false" ) ; if ( data -> dynamic_interfaces ) conf_write ( fp , "<S2SV_blank>Allow<S2SV_blank>interface<S2SV_blank>changes<S2SV_blank>=<S2SV_blank>%s" , data -> allow_if_changes ? "true" : "false" ) ; if ( data -> no_email_faults ) conf_write ( fp , "<S2SV_blank>Send<S2SV_blank>emails<S2SV_blank>for<S2SV_blank>fault<S2SV_blank>transitions<S2SV_blank>=<S2SV_blank>off" ) ; # endif # ifdef _WITH_LVS_ if ( data -> lvs_tcp_timeout ) conf_write ( fp , "<S2SV_blank>LVS<S2SV_blank>TCP<S2SV_blank>timeout<S2SV_blank>=<S2SV_blank>%d" , data -> lvs_tcp_timeout ) ; if ( data -> lvs_tcpfin_timeout ) conf_write ( fp , "<S2SV_blank>LVS<S2SV_blank>TCP<S2SV_blank>FIN<S2SV_blank>timeout<S2SV_blank>=<S2SV_blank>%d" , data -> lvs_tcpfin_timeout ) ; if ( data -> lvs_udp_timeout ) conf_write ( fp , "<S2SV_blank>LVS<S2SV_blank>TCP<S2SV_blank>timeout<S2SV_blank>=<S2SV_blank>%d" , data -> lvs_udp_timeout ) ; # ifdef _WITH_VRRP_ # ifndef _DEBUG_ if ( prog_type == PROG_TYPE_VRRP ) # endif conf_write ( fp , "<S2SV_blank>Default<S2SV_blank>interface<S2SV_blank>=<S2SV_blank>%s" , data -> default_ifp ? data -> default_ifp -> ifname : DFLT_INT ) ; if ( data -> lvs_syncd . vrrp ) { conf_write ( fp , "<S2SV_blank>LVS<S2SV_blank>syncd<S2SV_blank>vrrp<S2SV_blank>instance<S2SV_blank>=<S2SV_blank>%s" , data -> lvs_syncd . vrrp -> iname ) ; if ( data -> lvs_syncd . ifname ) conf_write ( fp , "<S2SV_blank>LVS<S2SV_blank>syncd<S2SV_blank>interface<S2SV_blank>=<S2SV_blank>%s" , data -> lvs_syncd . ifname ) ; conf_write ( fp , "<S2SV_blank>LVS<S2SV_blank>syncd<S2SV_blank>syncid<S2SV_blank>=<S2SV_blank>%u" , data -> lvs_syncd . syncid ) ; # ifdef _HAVE_IPVS_SYNCD_ATTRIBUTES_ if ( data -> lvs_syncd . sync_maxlen ) conf_write ( fp , "<S2SV_blank>LVS<S2SV_blank>syncd<S2SV_blank>maxlen<S2SV_blank>=<S2SV_blank>%u" , data -> lvs_syncd . sync_maxlen ) ; if ( data -> lvs_syncd . mcast_group . ss_family != AF_UNSPEC ) conf_write ( fp , "<S2SV_blank>LVS<S2SV_blank>mcast<S2SV_blank>group<S2SV_blank>%s" , inet_sockaddrtos ( & data -> lvs_syncd . mcast_group ) ) ; if ( data -> lvs_syncd . mcast_port ) conf_write ( fp , "<S2SV_blank>LVS<S2SV_blank>syncd<S2SV_blank>mcast<S2SV_blank>port<S2SV_blank>=<S2SV_blank>%d" , data -> lvs_syncd . mcast_port ) ; if ( data -> lvs_syncd . mcast_ttl ) conf_write ( fp , "<S2SV_blank>LVS<S2SV_blank>syncd<S2SV_blank>mcast<S2SV_blank>ttl<S2SV_blank>=<S2SV_blank>%u" , data -> lvs_syncd . mcast_ttl ) ; # endif } # endif conf_write ( fp , "<S2SV_blank>LVS<S2SV_blank>flush<S2SV_blank>=<S2SV_blank>%s" , data -> lvs_flush ? "true" : "false" ) ; # endif if ( data -> notify_fifo . name ) { conf_write ( fp , "<S2SV_blank>Global<S2SV_blank>notify<S2SV_blank>fifo<S2SV_blank>=<S2SV_blank>%s" , data -> notify_fifo . name ) ; if ( data -> notify_fifo . script ) conf_write ( fp , "<S2SV_blank>Global<S2SV_blank>notify<S2SV_blank>fifo<S2SV_blank>script<S2SV_blank>=<S2SV_blank>%s,<S2SV_blank>uid:gid<S2SV_blank>%d:%d" , cmd_str ( data -> notify_fifo . script ) , data -> notify_fifo . script -> uid , data -> notify_fifo . script -> gid ) ; } # ifdef _WITH_VRRP_ if ( data -> vrrp_notify_fifo . name ) { conf_write ( fp , "<S2SV_blank>VRRP<S2SV_blank>notify<S2SV_blank>fifo<S2SV_blank>=<S2SV_blank>%s" , data -> vrrp_notify_fifo . name ) ; if ( data -> vrrp_notify_fifo . script ) conf_write ( fp , "<S2SV_blank>VRRP<S2SV_blank>notify<S2SV_blank>fifo<S2SV_blank>script<S2SV_blank>=<S2SV_blank>%s,<S2SV_blank>uid:gid<S2SV_blank>%d:%d" , cmd_str ( data -> vrrp_notify_fifo . script ) , data -> vrrp_notify_fifo . script -> uid , data -> vrrp_notify_fifo . script -> gid ) ; } # endif # ifdef _WITH_LVS_ if ( data -> lvs_notify_fifo . name ) { conf_write ( fp , "<S2SV_blank>LVS<S2SV_blank>notify<S2SV_blank>fifo<S2SV_blank>=<S2SV_blank>%s" , data -> lvs_notify_fifo . name ) ; if ( data -> lvs_notify_fifo . script ) conf_write ( fp , "<S2SV_blank>LVS<S2SV_blank>notify<S2SV_blank>fifo<S2SV_blank>script<S2SV_blank>=<S2SV_blank>%s,<S2SV_blank>uid:gid<S2SV_blank>%d:%d" , cmd_str ( data -> lvs_notify_fifo . script ) , data -> lvs_notify_fifo . script -> uid , data -> lvs_notify_fifo . script -> gid ) ; } # endif # ifdef _WITH_VRRP_ if ( data -> vrrp_mcast_group4 . sin_family ) { conf_write ( fp , "<S2SV_blank>VRRP<S2SV_blank>IPv4<S2SV_blank>mcast<S2SV_blank>group<S2SV_blank>=<S2SV_blank>%s" , inet_sockaddrtos ( ( struct sockaddr_storage * ) & data -> vrrp_mcast_group4 ) ) ; } if ( data -> vrrp_mcast_group6 . sin6_family ) { conf_write ( fp , "<S2SV_blank>VRRP<S2SV_blank>IPv6<S2SV_blank>mcast<S2SV_blank>group<S2SV_blank>=<S2SV_blank>%s" , inet_sockaddrtos ( ( struct sockaddr_storage * ) & data -> vrrp_mcast_group6 ) ) ; } conf_write ( fp , "<S2SV_blank>Gratuitous<S2SV_blank>ARP<S2SV_blank>delay<S2SV_blank>=<S2SV_blank>%u" , data -> vrrp_garp_delay / TIMER_HZ ) ; conf_write ( fp , "<S2SV_blank>Gratuitous<S2SV_blank>ARP<S2SV_blank>repeat<S2SV_blank>=<S2SV_blank>%u" , data -> vrrp_garp_rep ) ; conf_write ( fp , "<S2SV_blank>Gratuitous<S2SV_blank>ARP<S2SV_blank>refresh<S2SV_blank>timer<S2SV_blank>=<S2SV_blank>%lu" , data -> vrrp_garp_refresh . tv_sec ) ; conf_write ( fp , "<S2SV_blank>Gratuitous<S2SV_blank>ARP<S2SV_blank>refresh<S2SV_blank>repeat<S2SV_blank>=<S2SV_blank>%d" , data -> vrrp_garp_refresh_rep ) ; conf_write ( fp , "<S2SV_blank>Gratuitous<S2SV_blank>ARP<S2SV_blank>lower<S2SV_blank>priority<S2SV_blank>delay<S2SV_blank>=<S2SV_blank>%d" , data -> vrrp_garp_lower_prio_delay == PARAMETER_UNSET ? PARAMETER_UNSET : data -> vrrp_garp_lower_prio_delay / TIMER_HZ ) ; conf_write ( fp , "<S2SV_blank>Gratuitous<S2SV_blank>ARP<S2SV_blank>lower<S2SV_blank>priority<S2SV_blank>repeat<S2SV_blank>=<S2SV_blank>%d" , data -> vrrp_garp_lower_prio_rep ) ; conf_write ( fp , "<S2SV_blank>Send<S2SV_blank>advert<S2SV_blank>after<S2SV_blank>receive<S2SV_blank>lower<S2SV_blank>priority<S2SV_blank>advert<S2SV_blank>=<S2SV_blank>%s" , data -> vrrp_lower_prio_no_advert ? "false" : "true" ) ; conf_write ( fp , "<S2SV_blank>Send<S2SV_blank>advert<S2SV_blank>after<S2SV_blank>receive<S2SV_blank>higher<S2SV_blank>priority<S2SV_blank>advert<S2SV_blank>=<S2SV_blank>%s" , data -> vrrp_higher_prio_send_advert ? "true" : "false" ) ; conf_write ( fp , "<S2SV_blank>Gratuitous<S2SV_blank>ARP<S2SV_blank>interval<S2SV_blank>=<S2SV_blank>%d" , data -> vrrp_garp_interval ) ; conf_write ( fp , "<S2SV_blank>Gratuitous<S2SV_blank>NA<S2SV_blank>interval<S2SV_blank>=<S2SV_blank>%d" , data -> vrrp_gna_interval ) ; conf_write ( fp , "<S2SV_blank>VRRP<S2SV_blank>default<S2SV_blank>protocol<S2SV_blank>version<S2SV_blank>=<S2SV_blank>%d" , data -> vrrp_version ) ; if ( data -> vrrp_iptables_inchain [ 0 ] ) conf_write ( fp , "<S2SV_blank>Iptables<S2SV_blank>input<S2SV_blank>chain<S2SV_blank>=<S2SV_blank>%s" , data -> vrrp_iptables_inchain ) ; if ( data -> vrrp_iptables_outchain [ 0 ] ) conf_write ( fp , "<S2SV_blank>Iptables<S2SV_blank>output<S2SV_blank>chain<S2SV_blank>=<S2SV_blank>%s" , data -> vrrp_iptables_outchain ) ; # ifdef _HAVE_LIBIPSET_ conf_write ( fp , "<S2SV_blank>Using<S2SV_blank>ipsets<S2SV_blank>=<S2SV_blank>%s" , data -> using_ipsets ? "true" : "false" ) ; if ( data -> vrrp_ipset_address [ 0 ] ) conf_write ( fp , "<S2SV_blank>ipset<S2SV_blank>IPv4<S2SV_blank>address<S2SV_blank>set<S2SV_blank>=<S2SV_blank>%s" , data -> vrrp_ipset_address ) ; if ( data -> vrrp_ipset_address6 [ 0 ] ) conf_write ( fp , "<S2SV_blank>ipset<S2SV_blank>IPv6<S2SV_blank>address<S2SV_blank>set<S2SV_blank>=<S2SV_blank>%s" , data -> vrrp_ipset_address6 ) ; if ( data -> vrrp_ipset_address_iface6 [ 0 ] ) conf_write ( fp , "<S2SV_blank>ipset<S2SV_blank>IPv6<S2SV_blank>address,iface<S2SV_blank>set<S2SV_blank>=<S2SV_blank>%s" , data -> vrrp_ipset_address_iface6 ) ; # endif conf_write ( fp , "<S2SV_blank>VRRP<S2SV_blank>check<S2SV_blank>unicast_src<S2SV_blank>=<S2SV_blank>%s" , data -> vrrp_check_unicast_src ? "true" : "false" ) ; conf_write ( fp , "<S2SV_blank>VRRP<S2SV_blank>skip<S2SV_blank>check<S2SV_blank>advert<S2SV_blank>addresses<S2SV_blank>=<S2SV_blank>%s" , data -> vrrp_skip_check_adv_addr ? "true" : "false" ) ; conf_write ( fp , "<S2SV_blank>VRRP<S2SV_blank>strict<S2SV_blank>mode<S2SV_blank>=<S2SV_blank>%s" , data -> vrrp_strict ? "true" : "false" ) ; conf_write ( fp , "<S2SV_blank>VRRP<S2SV_blank>process<S2SV_blank>priority<S2SV_blank>=<S2SV_blank>%d" , data -> vrrp_process_priority ) ; conf_write ( fp , "<S2SV_blank>VRRP<S2SV_blank>don\'t<S2SV_blank>swap<S2SV_blank>=<S2SV_blank>%s" , data -> vrrp_no_swap ? "true" : "false" ) ; # ifdef _HAVE_SCHED_RT_ conf_write ( fp , "<S2SV_blank>VRRP<S2SV_blank>realtime<S2SV_blank>priority<S2SV_blank>=<S2SV_blank>%u" , data -> vrrp_realtime_priority ) ; # if HAVE_DECL_RLIMIT_RTTIME conf_write ( fp , "<S2SV_blank>VRRP<S2SV_blank>realtime<S2SV_blank>limit<S2SV_blank>=<S2SV_blank>%lu" , data -> vrrp_rlimit_rt ) ; # endif # endif # endif # ifdef _WITH_LVS_ conf_write ( fp , "<S2SV_blank>Checker<S2SV_blank>process<S2SV_blank>priority<S2SV_blank>=<S2SV_blank>%d" , data -> checker_process_priority ) ; conf_write ( fp , "<S2SV_blank>Checker<S2SV_blank>don\'t<S2SV_blank>swap<S2SV_blank>=<S2SV_blank>%s" , data -> checker_no_swap ? "true" : "false" ) ; # ifdef _HAVE_SCHED_RT_ conf_write ( fp , "<S2SV_blank>Checker<S2SV_blank>realtime<S2SV_blank>priority<S2SV_blank>=<S2SV_blank>%u" , data -> checker_realtime_priority ) ; # if HAVE_DECL_RLIMIT_RTTIME conf_write ( fp , "<S2SV_blank>Checker<S2SV_blank>realtime<S2SV_blank>limit<S2SV_blank>=<S2SV_blank>%lu" , data -> checker_rlimit_rt ) ; # endif # endif # endif # ifdef _WITH_BFD_ conf_write ( fp , "<S2SV_blank>BFD<S2SV_blank>process<S2SV_blank>priority<S2SV_blank>=<S2SV_blank>%d" , data -> bfd_process_priority ) ; conf_write ( fp , "<S2SV_blank>BFD<S2SV_blank>don\'t<S2SV_blank>swap<S2SV_blank>=<S2SV_blank>%s" , data -> bfd_no_swap ? "true" : "false" ) ; # ifdef _HAVE_SCHED_RT_ conf_write ( fp , "<S2SV_blank>BFD<S2SV_blank>realtime<S2SV_blank>priority<S2SV_blank>=<S2SV_blank>%u" , data -> bfd_realtime_priority ) ; # if HAVE_DECL_RLIMIT_RTTIME conf_write ( fp , "<S2SV_blank>BFD<S2SV_blank>realtime<S2SV_blank>limit<S2SV_blank>=<S2SV_blank>%lu" , data -> bfd_rlimit_rt ) ; # endif # endif # endif # ifdef _WITH_SNMP_VRRP_ conf_write ( fp , "<S2SV_blank>SNMP<S2SV_blank>vrrp<S2SV_blank>%s" , data -> enable_snmp_vrrp ? "enabled" : "disabled" ) ; # endif # ifdef _WITH_SNMP_CHECKER_ conf_write ( fp , "<S2SV_blank>SNMP<S2SV_blank>checker<S2SV_blank>%s" , data -> enable_snmp_checker ? "enabled" : "disabled" ) ; # endif # ifdef _WITH_SNMP_RFCV2_ conf_write ( fp , "<S2SV_blank>SNMP<S2SV_blank>RFCv2<S2SV_blank>%s" , data -> enable_snmp_rfcv2 ? "enabled" : "disabled" ) ; # endif # ifdef _WITH_SNMP_RFCV3_ conf_write ( fp , "<S2SV_blank>SNMP<S2SV_blank>RFCv3<S2SV_blank>%s" , data -> enable_snmp_rfcv3 ? "enabled" : "disabled" ) ; # endif # ifdef _WITH_SNMP_ conf_write ( fp , "<S2SV_blank>SNMP<S2SV_blank>traps<S2SV_blank>%s" , data -> enable_traps ? "enabled" : "disabled" ) ; conf_write ( fp , "<S2SV_blank>SNMP<S2SV_blank>socket<S2SV_blank>=<S2SV_blank>%s" , data -> snmp_socket ? data -> snmp_socket : "default<S2SV_blank>(unix:/var/agentx/master)" ) ; # endif # ifdef _WITH_DBUS_ conf_write ( fp , "<S2SV_blank>DBus<S2SV_blank>%s" , data -> enable_dbus ? "enabled" : "disabled" ) ; conf_write ( fp , "<S2SV_blank>DBus<S2SV_blank>service<S2SV_blank>name<S2SV_blank>=<S2SV_blank>%s" , data -> dbus_service_name ? data -> dbus_service_name : "" ) ; # endif conf_write ( fp , "<S2SV_blank>Script<S2SV_blank>security<S2SV_blank>%s" , script_security ? "enabled" : "disabled" ) ; conf_write ( fp , "<S2SV_blank>Default<S2SV_blank>script<S2SV_blank>uid:gid<S2SV_blank>%d:%d" , default_script_uid , default_script_gid ) ; # ifdef _WITH_VRRP_ conf_write ( fp , "<S2SV_blank>vrrp_netlink_cmd_rcv_bufs<S2SV_blank>=<S2SV_blank>%u" , global_data -> vrrp_netlink_cmd_rcv_bufs ) ; conf_write ( fp , "<S2SV_blank>vrrp_netlink_cmd_rcv_bufs_force<S2SV_blank>=<S2SV_blank>%u" , global_data -> vrrp_netlink_cmd_rcv_bufs_force ) ; conf_write ( fp , "<S2SV_blank>vrrp_netlink_monitor_rcv_bufs<S2SV_blank>=<S2SV_blank>%u" , global_data -> vrrp_netlink_monitor_rcv_bufs ) ; conf_write ( fp , "<S2SV_blank>vrrp_netlink_monitor_rcv_bufs_force<S2SV_blank>=<S2SV_blank>%u" , global_data -> vrrp_netlink_monitor_rcv_bufs_force ) ; # endif # ifdef _WITH_LVS_ conf_write ( fp , "<S2SV_blank>lvs_netlink_cmd_rcv_bufs<S2SV_blank>=<S2SV_blank>%u" , global_data -> lvs_netlink_cmd_rcv_bufs ) ; conf_write ( fp , "<S2SV_blank>lvs_netlink_cmd_rcv_bufs_force<S2SV_blank>=<S2SV_blank>%u" , global_data -> lvs_netlink_cmd_rcv_bufs_force ) ; conf_write ( fp , "<S2SV_blank>lvs_netlink_monitor_rcv_bufs<S2SV_blank>=<S2SV_blank>%u" , global_data -> lvs_netlink_monitor_rcv_bufs ) ; conf_write ( fp , "<S2SV_blank>lvs_netlink_monitor_rcv_bufs_force<S2SV_blank>=<S2SV_blank>%u" , global_data -> lvs_netlink_monitor_rcv_bufs_force ) ; conf_write ( fp , "<S2SV_blank>rs_init_notifies<S2SV_blank>=<S2SV_blank>%u" , global_data -> rs_init_notifies ) ; conf_write ( fp , "<S2SV_blank>no_checker_emails<S2SV_blank>=<S2SV_blank>%u" , global_data -> no_checker_emails ) ; # endif # ifdef _WITH_VRRP_ buf [ 0 ] = '\\0' ; if ( global_data -> vrrp_rx_bufs_policy & RX_BUFS_POLICY_MTU ) strcpy ( buf , "<S2SV_blank>rx_bufs_policy<S2SV_blank>=<S2SV_blank>MTU" ) ; else if ( global_data -> vrrp_rx_bufs_policy & RX_BUFS_POLICY_ADVERT ) strcpy ( buf , "<S2SV_blank>rx_bufs_policy<S2SV_blank>=<S2SV_blank>ADVERT" ) ; else if ( global_data -> vrrp_rx_bufs_policy & RX_BUFS_SIZE ) sprintf ( buf , "<S2SV_blank>rx_bufs_size<S2SV_blank>=<S2SV_blank>%lu" , global_data -> vrrp_rx_bufs_size ) ; if ( buf [ 0 ] ) conf_write ( fp , "%s" , buf ) ; conf_write ( fp , "<S2SV_blank>rx_bufs_multiples<S2SV_blank>=<S2SV_blank>%u" , global_data -> vrrp_rx_bufs_multiples ) ; <S2SV_StartBug> # endif <S2SV_EndBug> }
CWE-200 void init_global_keywords ( bool global_active ) { install_keyword_root ( "linkbeat_use_polling" , use_polling_handler , global_active ) ; # if HAVE_DECL_CLONE_NEWNET install_keyword_root ( "net_namespace" , & net_namespace_handler , global_active ) ; install_keyword_root ( "namespace_with_ipsets" , & namespace_ipsets_handler , global_active ) ; # endif install_keyword_root ( "use_pid_dir" , & use_pid_dir_handler , global_active ) ; install_keyword_root ( "instance" , & instance_handler , global_active ) ; install_keyword_root ( "child_wait_time" , & child_wait_handler , global_active ) ; install_keyword_root ( "global_defs" , NULL , global_active ) ; install_keyword ( "router_id" , & routerid_handler ) ; install_keyword ( "notification_email_from" , & emailfrom_handler ) ; install_keyword ( "smtp_server" , & smtpserver_handler ) ; install_keyword ( "smtp_helo_name" , & smtphelo_handler ) ; install_keyword ( "smtp_connect_timeout" , & smtpto_handler ) ; install_keyword ( "notification_email" , & email_handler ) ; install_keyword ( "smtp_alert" , & smtp_alert_handler ) ; # ifdef _WITH_VRRP_ install_keyword ( "smtp_alert_vrrp" , & smtp_alert_vrrp_handler ) ; # endif # ifdef _WITH_LVS_ install_keyword ( "smtp_alert_checker" , & smtp_alert_checker_handler ) ; # endif # ifdef _WITH_VRRP_ install_keyword ( "dynamic_interfaces" , & dynamic_interfaces_handler ) ; install_keyword ( "no_email_faults" , & no_email_faults_handler ) ; install_keyword ( "default_interface" , & default_interface_handler ) ; # endif # ifdef _WITH_LVS_ install_keyword ( "lvs_timeouts" , & lvs_timeouts ) ; install_keyword ( "lvs_flush" , & lvs_flush_handler ) ; # ifdef _WITH_VRRP_ install_keyword ( "lvs_sync_daemon" , & lvs_syncd_handler ) ; # endif # endif # ifdef _WITH_VRRP_ install_keyword ( "vrrp_mcast_group4" , & vrrp_mcast_group4_handler ) ; install_keyword ( "vrrp_mcast_group6" , & vrrp_mcast_group6_handler ) ; install_keyword ( "vrrp_garp_master_delay" , & vrrp_garp_delay_handler ) ; install_keyword ( "vrrp_garp_master_repeat" , & vrrp_garp_rep_handler ) ; install_keyword ( "vrrp_garp_master_refresh" , & vrrp_garp_refresh_handler ) ; install_keyword ( "vrrp_garp_master_refresh_repeat" , & vrrp_garp_refresh_rep_handler ) ; install_keyword ( "vrrp_garp_lower_prio_delay" , & vrrp_garp_lower_prio_delay_handler ) ; install_keyword ( "vrrp_garp_lower_prio_repeat" , & vrrp_garp_lower_prio_rep_handler ) ; install_keyword ( "vrrp_garp_interval" , & vrrp_garp_interval_handler ) ; install_keyword ( "vrrp_gna_interval" , & vrrp_gna_interval_handler ) ; install_keyword ( "vrrp_lower_prio_no_advert" , & vrrp_lower_prio_no_advert_handler ) ; install_keyword ( "vrrp_higher_prio_send_advert" , & vrrp_higher_prio_send_advert_handler ) ; install_keyword ( "vrrp_version" , & vrrp_version_handler ) ; install_keyword ( "vrrp_iptables" , & vrrp_iptables_handler ) ; # ifdef _HAVE_LIBIPSET_ install_keyword ( "vrrp_ipsets" , & vrrp_ipsets_handler ) ; # endif install_keyword ( "vrrp_check_unicast_src" , & vrrp_check_unicast_src_handler ) ; install_keyword ( "vrrp_skip_check_adv_addr" , & vrrp_check_adv_addr_handler ) ; install_keyword ( "vrrp_strict" , & vrrp_strict_handler ) ; install_keyword ( "vrrp_priority" , & vrrp_prio_handler ) ; install_keyword ( "vrrp_no_swap" , & vrrp_no_swap_handler ) ; # ifdef _HAVE_SCHED_RT_ install_keyword ( "vrrp_rt_priority" , & vrrp_rt_priority_handler ) ; # if HAVE_DECL_RLIMIT_RTTIME == 1 install_keyword ( "vrrp_rlimit_rtime" , & vrrp_rt_rlimit_handler ) ; # endif # endif # endif install_keyword ( "notify_fifo" , & global_notify_fifo ) ; install_keyword ( "notify_fifo_script" , & global_notify_fifo_script ) ; # ifdef _WITH_VRRP_ install_keyword ( "vrrp_notify_fifo" , & vrrp_notify_fifo ) ; install_keyword ( "vrrp_notify_fifo_script" , & vrrp_notify_fifo_script ) ; # endif # ifdef _WITH_LVS_ install_keyword ( "lvs_notify_fifo" , & lvs_notify_fifo ) ; install_keyword ( "lvs_notify_fifo_script" , & lvs_notify_fifo_script ) ; install_keyword ( "checker_priority" , & checker_prio_handler ) ; install_keyword ( "checker_no_swap" , & checker_no_swap_handler ) ; # ifdef _HAVE_SCHED_RT_ install_keyword ( "checker_rt_priority" , & checker_rt_priority_handler ) ; # if HAVE_DECL_RLIMIT_RTTIME == 1 install_keyword ( "checker_rlimit_rtime" , & checker_rt_rlimit_handler ) ; # endif # endif # endif # ifdef _WITH_BFD_ install_keyword ( "bfd_priority" , & bfd_prio_handler ) ; install_keyword ( "bfd_no_swap" , & bfd_no_swap_handler ) ; # ifdef _HAVE_SCHED_RT_ install_keyword ( "bfd_rt_priority" , & bfd_rt_priority_handler ) ; # if HAVE_DECL_RLIMIT_RTTIME == 1 install_keyword ( "bfd_rlimit_rtime" , & bfd_rt_rlimit_handler ) ; # endif # endif # endif # ifdef _WITH_SNMP_ install_keyword ( "snmp_socket" , & snmp_socket_handler ) ; install_keyword ( "enable_traps" , & trap_handler ) ; # ifdef _WITH_SNMP_VRRP_ install_keyword ( "enable_snmp_vrrp" , & snmp_vrrp_handler ) ; install_keyword ( "enable_snmp_keepalived" , & snmp_vrrp_handler ) ; # endif # ifdef _WITH_SNMP_RFC_ install_keyword ( "enable_snmp_rfc" , & snmp_rfc_handler ) ; # endif # ifdef _WITH_SNMP_RFCV2_ install_keyword ( "enable_snmp_rfcv2" , & snmp_rfcv2_handler ) ; # endif # ifdef _WITH_SNMP_RFCV3_ install_keyword ( "enable_snmp_rfcv3" , & snmp_rfcv3_handler ) ; # endif # ifdef _WITH_SNMP_CHECKER_ install_keyword ( "enable_snmp_checker" , & snmp_checker_handler ) ; # endif # endif # ifdef _WITH_DBUS_ install_keyword ( "enable_dbus" , & enable_dbus_handler ) ; install_keyword ( "dbus_service_name" , & dbus_service_name_handler ) ; # endif install_keyword ( "script_user" , & script_user_handler ) ; install_keyword ( "enable_script_security" , & script_security_handler ) ; # ifdef _WITH_VRRP_ install_keyword ( "vrrp_netlink_cmd_rcv_bufs" , & vrrp_netlink_cmd_rcv_bufs_handler ) ; install_keyword ( "vrrp_netlink_cmd_rcv_bufs_force" , & vrrp_netlink_cmd_rcv_bufs_force_handler ) ; install_keyword ( "vrrp_netlink_monitor_rcv_bufs" , & vrrp_netlink_monitor_rcv_bufs_handler ) ; install_keyword ( "vrrp_netlink_monitor_rcv_bufs_force" , & vrrp_netlink_monitor_rcv_bufs_force_handler ) ; # endif # ifdef _WITH_LVS_ install_keyword ( "lvs_netlink_cmd_rcv_bufs" , & lvs_netlink_cmd_rcv_bufs_handler ) ; install_keyword ( "lvs_netlink_cmd_rcv_bufs_force" , & lvs_netlink_cmd_rcv_bufs_force_handler ) ; install_keyword ( "lvs_netlink_monitor_rcv_bufs" , & lvs_netlink_monitor_rcv_bufs_handler ) ; install_keyword ( "lvs_netlink_monitor_rcv_bufs_force" , & lvs_netlink_monitor_rcv_bufs_force_handler ) ; # endif # ifdef _WITH_LVS_ install_keyword ( "rs_init_notifies" , & rs_init_notifies_handler ) ; install_keyword ( "no_checker_emails" , & no_checker_emails_handler ) ; # endif # ifdef _WITH_VRRP_ install_keyword ( "vrrp_rx_bufs_policy" , & vrrp_rx_bufs_policy_handler ) ; install_keyword ( "vrrp_rx_bufs_multiplier" , & vrrp_rx_bufs_multiplier_handler ) ; # endif <S2SV_StartBug> } <S2SV_EndBug>
CWE-200 int keepalived_main ( int argc , char * * argv ) { bool report_stopped = true ; struct utsname uname_buf ; char * end ; set_time_now ( ) ; save_cmd_line_options ( argc , argv ) ; debug = 0 ; # ifndef _DEBUG_ prog_type = PROG_TYPE_PARENT ; # endif # ifdef _WITH_VRRP_ __set_bit ( DAEMON_VRRP , & daemon_mode ) ; # endif # ifdef _WITH_LVS_ __set_bit ( DAEMON_CHECKERS , & daemon_mode ) ; # endif # ifdef _WITH_BFD_ __set_bit ( DAEMON_BFD , & daemon_mode ) ; <S2SV_StartBug> # endif <S2SV_EndBug> openlog ( PACKAGE_NAME , LOG_PID , log_facility ) ; # ifdef _MEM_CHECK_ mem_log_init ( PACKAGE_NAME , "Parent<S2SV_blank>process" ) ; # endif if ( uname ( & uname_buf ) ) log_message ( LOG_INFO , "Unable<S2SV_blank>to<S2SV_blank>get<S2SV_blank>uname()<S2SV_blank>information<S2SV_blank>-<S2SV_blank>error<S2SV_blank>%d" , errno ) ; else { os_major = ( unsigned ) strtoul ( uname_buf . release , & end , 10 ) ; if ( * end != '.' ) os_major = 0 ; else { os_minor = ( unsigned ) strtoul ( end + 1 , & end , 10 ) ; if ( * end != '.' ) os_major = 0 ; else { if ( ! isdigit ( end [ 1 ] ) ) os_major = 0 ; else os_release = ( unsigned ) strtoul ( end + 1 , & end , 10 ) ; } } if ( ! os_major ) log_message ( LOG_INFO , "Unable<S2SV_blank>to<S2SV_blank>parse<S2SV_blank>kernel<S2SV_blank>version<S2SV_blank>%s" , uname_buf . release ) ; if ( ! config_id ) { end = strchrnul ( uname_buf . nodename , '.' ) ; config_id = MALLOC ( ( size_t ) ( end - uname_buf . nodename ) + 1 ) ; strncpy ( config_id , uname_buf . nodename , ( size_t ) ( end - uname_buf . nodename ) ) ; config_id [ end - uname_buf . nodename ] = '\\0' ; } } if ( parse_cmdline ( argc , argv ) ) { closelog ( ) ; if ( ! __test_bit ( NO_SYSLOG_BIT , & debug ) ) openlog ( PACKAGE_NAME , LOG_PID | ( ( __test_bit ( LOG_CONSOLE_BIT , & debug ) ) ? LOG_CONS : 0 ) , log_facility ) ; } if ( __test_bit ( LOG_CONSOLE_BIT , & debug ) ) enable_console_log ( ) ; # ifdef GIT_COMMIT log_message ( LOG_INFO , "Starting<S2SV_blank>%s,<S2SV_blank>git<S2SV_blank>commit<S2SV_blank>%s" , version_string , GIT_COMMIT ) ; # else log_message ( LOG_INFO , "Starting<S2SV_blank>%s" , version_string ) ; # endif core_dump_init ( ) ; if ( os_major ) { if ( KERNEL_VERSION ( os_major , os_minor , os_release ) < LINUX_VERSION_CODE ) { log_message ( LOG_INFO , "WARNING<S2SV_blank>-<S2SV_blank>keepalived<S2SV_blank>was<S2SV_blank>build<S2SV_blank>for<S2SV_blank>newer<S2SV_blank>Linux<S2SV_blank>%d.%d.%d,<S2SV_blank>running<S2SV_blank>on<S2SV_blank>%s<S2SV_blank>%s<S2SV_blank>%s" , ( LINUX_VERSION_CODE >> 16 ) & 0xff , ( LINUX_VERSION_CODE >> 8 ) & 0xff , ( LINUX_VERSION_CODE ) & 0xff , uname_buf . sysname , uname_buf . release , uname_buf . version ) ; } else { log_message ( LOG_INFO , "Running<S2SV_blank>on<S2SV_blank>%s<S2SV_blank>%s<S2SV_blank>%s<S2SV_blank>(built<S2SV_blank>for<S2SV_blank>Linux<S2SV_blank>%d.%d.%d)" , uname_buf . sysname , uname_buf . release , uname_buf . version , ( LINUX_VERSION_CODE >> 16 ) & 0xff , ( LINUX_VERSION_CODE >> 8 ) & 0xff , ( LINUX_VERSION_CODE ) & 0xff ) ; } } # ifndef _DEBUG_ log_command_line ( 0 ) ; # endif if ( ! check_conf_file ( conf_file ) ) { if ( __test_bit ( CONFIG_TEST_BIT , & debug ) ) config_test_exit ( ) ; goto end ; } global_data = alloc_global_data ( ) ; <S2SV_StartBug> read_config_file ( ) ; <S2SV_EndBug> init_global_data ( global_data , NULL ) ; # if HAVE_DECL_CLONE_NEWNET if ( override_namespace ) { if ( global_data -> network_namespace ) { log_message ( LOG_INFO , "Overriding<S2SV_blank>config<S2SV_blank>net_namespace<S2SV_blank>\'%s\'<S2SV_blank>with<S2SV_blank>command<S2SV_blank>line<S2SV_blank>namespace<S2SV_blank>\'%s\'" , global_data -> network_namespace , override_namespace ) ; FREE ( global_data -> network_namespace ) ; } global_data -> network_namespace = override_namespace ; override_namespace = NULL ; } # endif if ( ! __test_bit ( CONFIG_TEST_BIT , & debug ) && ( global_data -> instance_name # if HAVE_DECL_CLONE_NEWNET || global_data -> network_namespace # endif ) ) { if ( ( syslog_ident = make_syslog_ident ( PACKAGE_NAME ) ) ) { log_message ( LOG_INFO , "Changing<S2SV_blank>syslog<S2SV_blank>ident<S2SV_blank>to<S2SV_blank>%s" , syslog_ident ) ; closelog ( ) ; openlog ( syslog_ident , LOG_PID | ( ( __test_bit ( LOG_CONSOLE_BIT , & debug ) ) ? LOG_CONS : 0 ) , log_facility ) ; } else log_message ( LOG_INFO , "Unable<S2SV_blank>to<S2SV_blank>change<S2SV_blank>syslog<S2SV_blank>ident" ) ; use_pid_dir = true ; open_log_file ( log_file_name , NULL , # if HAVE_DECL_CLONE_NEWNET global_data -> network_namespace , # else NULL , # endif global_data -> instance_name ) ; } set_child_finder_name ( find_keepalived_child_name ) ; if ( ! __test_bit ( CONFIG_TEST_BIT , & debug ) ) { if ( use_pid_dir ) { create_pid_dir ( ) ; } } # if HAVE_DECL_CLONE_NEWNET if ( global_data -> network_namespace ) { if ( global_data -> network_namespace && ! set_namespaces ( global_data -> network_namespace ) ) { log_message ( LOG_ERR , "Unable<S2SV_blank>to<S2SV_blank>set<S2SV_blank>network<S2SV_blank>namespace<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>exiting" , global_data -> network_namespace ) ; goto end ; } } # endif if ( ! __test_bit ( CONFIG_TEST_BIT , & debug ) ) { if ( global_data -> instance_name ) { if ( ! main_pidfile && ( main_pidfile = make_pidfile_name ( KEEPALIVED_PID_DIR KEEPALIVED_PID_FILE , global_data -> instance_name , PID_EXTENSION ) ) ) free_main_pidfile = true ; # ifdef _WITH_LVS_ if ( ! checkers_pidfile && ( checkers_pidfile = make_pidfile_name ( KEEPALIVED_PID_DIR CHECKERS_PID_FILE , global_data -> instance_name , PID_EXTENSION ) ) ) free_checkers_pidfile = true ; # endif # ifdef _WITH_VRRP_ if ( ! vrrp_pidfile && ( vrrp_pidfile = make_pidfile_name ( KEEPALIVED_PID_DIR VRRP_PID_FILE , global_data -> instance_name , PID_EXTENSION ) ) ) free_vrrp_pidfile = true ; # endif # ifdef _WITH_BFD_ if ( ! bfd_pidfile && ( bfd_pidfile = make_pidfile_name ( KEEPALIVED_PID_DIR VRRP_PID_FILE , global_data -> instance_name , PID_EXTENSION ) ) ) free_bfd_pidfile = true ; # endif } if ( use_pid_dir ) { if ( ! main_pidfile ) main_pidfile = KEEPALIVED_PID_DIR KEEPALIVED_PID_FILE PID_EXTENSION ; # ifdef _WITH_LVS_ if ( ! checkers_pidfile ) checkers_pidfile = KEEPALIVED_PID_DIR CHECKERS_PID_FILE PID_EXTENSION ; # endif # ifdef _WITH_VRRP_ if ( ! vrrp_pidfile ) vrrp_pidfile = KEEPALIVED_PID_DIR VRRP_PID_FILE PID_EXTENSION ; # endif # ifdef _WITH_BFD_ if ( ! bfd_pidfile ) bfd_pidfile = KEEPALIVED_PID_DIR BFD_PID_FILE PID_EXTENSION ; # endif } else { if ( ! main_pidfile ) main_pidfile = PID_DIR KEEPALIVED_PID_FILE PID_EXTENSION ; # ifdef _WITH_LVS_ if ( ! checkers_pidfile ) checkers_pidfile = PID_DIR CHECKERS_PID_FILE PID_EXTENSION ; # endif # ifdef _WITH_VRRP_ if ( ! vrrp_pidfile ) vrrp_pidfile = PID_DIR VRRP_PID_FILE PID_EXTENSION ; # endif # ifdef _WITH_BFD_ if ( ! bfd_pidfile ) bfd_pidfile = PID_DIR BFD_PID_FILE PID_EXTENSION ; # endif } if ( keepalived_running ( daemon_mode ) ) { log_message ( LOG_INFO , "daemon<S2SV_blank>is<S2SV_blank>already<S2SV_blank>running" ) ; report_stopped = false ; goto end ; } } if ( ! __test_bit ( DONT_FORK_BIT , & debug ) && xdaemon ( false , false , true ) > 0 ) { closelog ( ) ; FREE_PTR ( config_id ) ; FREE_PTR ( orig_core_dump_pattern ) ; close_std_fd ( ) ; exit ( 0 ) ; } <S2SV_StartBug> umask ( 0 ) ; <S2SV_EndBug> # ifdef _MEM_CHECK_ enable_mem_log_termination ( ) ; # endif if ( __test_bit ( CONFIG_TEST_BIT , & debug ) ) { validate_config ( ) ; config_test_exit ( ) ; } if ( ! pidfile_write ( main_pidfile , getpid ( ) ) ) goto end ; master = thread_make_master ( ) ; signal_init ( ) ; if ( ! start_keepalived ( ) ) log_message ( LOG_INFO , "Warning<S2SV_blank>-<S2SV_blank>keepalived<S2SV_blank>has<S2SV_blank>no<S2SV_blank>configuration<S2SV_blank>to<S2SV_blank>run" ) ; initialise_debug_options ( ) ; # ifdef THREAD_DUMP register_parent_thread_addresses ( ) ; # endif launch_thread_scheduler ( master ) ; stop_keepalived ( ) ; # ifdef THREAD_DUMP deregister_thread_addresses ( ) ; # endif end : if ( report_stopped ) { # ifdef GIT_COMMIT log_message ( LOG_INFO , "Stopped<S2SV_blank>%s,<S2SV_blank>git<S2SV_blank>commit<S2SV_blank>%s" , version_string , GIT_COMMIT ) ; # else log_message ( LOG_INFO , "Stopped<S2SV_blank>%s" , version_string ) ; # endif } # if HAVE_DECL_CLONE_NEWNET if ( global_data && global_data -> network_namespace ) clear_namespaces ( ) ; # endif if ( use_pid_dir ) remove_pid_dir ( ) ; if ( orig_core_dump_pattern ) update_core_dump_pattern ( orig_core_dump_pattern ) ; free_parent_mallocs_startup ( false ) ; free_parent_mallocs_exit ( ) ; free_global_data ( global_data ) ; closelog ( ) ; # ifndef _MEM_CHECK_LOG_ FREE_PTR ( syslog_ident ) ; # else if ( syslog_ident ) free ( syslog_ident ) ; # endif close_std_fd ( ) ; exit ( KEEPALIVED_EXIT_OK ) ; }
CWE-200 static bool parse_cmdline ( int argc , char * * argv ) { int c ; bool reopen_log = false ; int signum ; struct utsname uname_buf ; int longindex ; int curind ; bool bad_option = false ; <S2SV_StartBug> unsigned facility ; <S2SV_EndBug> struct option long_options [ ] = { { "use-file" , required_argument , NULL , 'f' } , # if defined _WITH_VRRP_ && defined _WITH_LVS_ { "vrrp" , no_argument , NULL , 'P' } , { "check" , no_argument , NULL , 'C' } , # endif # ifdef _WITH_BFD_ { "no_bfd" , no_argument , NULL , 'B' } , # endif { "all" , no_argument , NULL , 3 } , { "log-console" , no_argument , NULL , 'l' } , { "log-detail" , no_argument , NULL , 'D' } , { "log-facility" , required_argument , NULL , 'S' } , { "log-file" , optional_argument , NULL , 'g' } , { "flush-log-file" , no_argument , NULL , 2 } , { "no-syslog" , no_argument , NULL , 'G' } , <S2SV_StartBug> # ifdef _WITH_VRRP_ <S2SV_EndBug> { "release-vips" , no_argument , NULL , 'X' } , { "dont-release-vrrp" , no_argument , NULL , 'V' } , # endif # ifdef _WITH_LVS_ { "dont-release-ipvs" , no_argument , NULL , 'I' } , # endif { "dont-respawn" , no_argument , NULL , 'R' } , { "dont-fork" , no_argument , NULL , 'n' } , { "dump-conf" , no_argument , NULL , 'd' } , { "pid" , required_argument , NULL , 'p' } , # ifdef _WITH_VRRP_ { "vrrp_pid" , required_argument , NULL , 'r' } , # endif # ifdef _WITH_LVS_ { "checkers_pid" , required_argument , NULL , 'c' } , { "address-monitoring" , no_argument , NULL , 'a' } , # endif # ifdef _WITH_BFD_ { "bfd_pid" , required_argument , NULL , 'b' } , # endif # ifdef _WITH_SNMP_ { "snmp" , no_argument , NULL , 'x' } , { "snmp-agent-socket" , required_argument , NULL , 'A' } , # endif { "core-dump" , no_argument , NULL , 'm' } , { "core-dump-pattern" , optional_argument , NULL , 'M' } , # ifdef _MEM_CHECK_LOG_ { "mem-check-log" , no_argument , NULL , 'L' } , # endif # if HAVE_DECL_CLONE_NEWNET { "namespace" , required_argument , NULL , 's' } , # endif { "config-id" , required_argument , NULL , 'i' } , { "signum" , required_argument , NULL , 4 } , { "config-test" , optional_argument , NULL , 't' } , # ifdef _WITH_PERF_ { "perf" , optional_argument , NULL , 5 } , # endif # ifdef WITH_DEBUG_OPTIONS { "debug" , optional_argument , NULL , 6 } , # endif { "version" , no_argument , NULL , 'v' } , { "help" , no_argument , NULL , 'h' } , { NULL , 0 , NULL , 0 } } ; curind = optind ; <S2SV_StartBug> while ( longindex = - 1 , ( c = getopt_long ( argc , argv , ":vhlndDRS:f:p:i:mM::g::Gt::" <S2SV_EndBug> # if defined _WITH_VRRP_ && defined _WITH_LVS_ "PC" # endif # ifdef _WITH_VRRP_ "r:VX" # endif # ifdef _WITH_LVS_ "ac:I" # endif # ifdef _WITH_BFD_ "Bb:" # endif # ifdef _WITH_SNMP_ "xA:" # endif # ifdef _MEM_CHECK_LOG_ "L" # endif # if HAVE_DECL_CLONE_NEWNET "s:" # endif , long_options , & longindex ) ) != - 1 ) { if ( longindex >= 0 && long_options [ longindex ] . has_arg == required_argument && optarg && ! optarg [ 0 ] ) { c = ':' ; optarg = NULL ; } switch ( c ) { case 'v' : fprintf ( stderr , "%s" , version_string ) ; # ifdef GIT_COMMIT fprintf ( stderr , ",<S2SV_blank>git<S2SV_blank>commit<S2SV_blank>%s" , GIT_COMMIT ) ; # endif fprintf ( stderr , "\\n\\n%s\\n\\n" , COPYRIGHT_STRING ) ; fprintf ( stderr , "Built<S2SV_blank>with<S2SV_blank>kernel<S2SV_blank>headers<S2SV_blank>for<S2SV_blank>Linux<S2SV_blank>%d.%d.%d\\n" , ( LINUX_VERSION_CODE >> 16 ) & 0xff , ( LINUX_VERSION_CODE >> 8 ) & 0xff , ( LINUX_VERSION_CODE ) & 0xff ) ; uname ( & uname_buf ) ; fprintf ( stderr , "Running<S2SV_blank>on<S2SV_blank>%s<S2SV_blank>%s<S2SV_blank>%s\\n\\n" , uname_buf . sysname , uname_buf . release , uname_buf . version ) ; fprintf ( stderr , "configure<S2SV_blank>options:<S2SV_blank>%s\\n\\n" , KEEPALIVED_CONFIGURE_OPTIONS ) ; fprintf ( stderr , "Config<S2SV_blank>options:<S2SV_blank>%s\\n\\n" , CONFIGURATION_OPTIONS ) ; fprintf ( stderr , "System<S2SV_blank>options:<S2SV_blank>%s\\n" , SYSTEM_OPTIONS ) ; exit ( 0 ) ; break ; case 'h' : usage ( argv [ 0 ] ) ; exit ( 0 ) ; break ; case 'l' : __set_bit ( LOG_CONSOLE_BIT , & debug ) ; reopen_log = true ; break ; case 'n' : __set_bit ( DONT_FORK_BIT , & debug ) ; break ; case 'd' : __set_bit ( DUMP_CONF_BIT , & debug ) ; break ; # ifdef _WITH_VRRP_ case 'V' : __set_bit ( DONT_RELEASE_VRRP_BIT , & debug ) ; break ; # endif # ifdef _WITH_LVS_ case 'I' : __set_bit ( DONT_RELEASE_IPVS_BIT , & debug ) ; break ; # endif case 'D' : if ( __test_bit ( LOG_DETAIL_BIT , & debug ) ) __set_bit ( LOG_EXTRA_DETAIL_BIT , & debug ) ; else __set_bit ( LOG_DETAIL_BIT , & debug ) ; break ; case 'R' : __set_bit ( DONT_RESPAWN_BIT , & debug ) ; break ; # ifdef _WITH_VRRP_ case 'X' : __set_bit ( RELEASE_VIPS_BIT , & debug ) ; break ; # endif case 'S' : if ( ! read_unsigned ( optarg , & facility , 0 , LOG_FACILITY_MAX , false ) ) fprintf ( stderr , "Invalid<S2SV_blank>log<S2SV_blank>facility<S2SV_blank>\'%s\'\\n" , optarg ) ; else { log_facility = LOG_FACILITY [ facility ] . facility ; reopen_log = true ; } break ; case 'g' : if ( optarg && optarg [ 0 ] ) log_file_name = optarg ; else log_file_name = "/tmp/keepalived.log" ; open_log_file ( log_file_name , NULL , NULL , NULL ) ; break ; case 'G' : __set_bit ( NO_SYSLOG_BIT , & debug ) ; reopen_log = true ; break ; <S2SV_StartBug> case 't' : <S2SV_EndBug> __set_bit ( CONFIG_TEST_BIT , & debug ) ; __set_bit ( DONT_RESPAWN_BIT , & debug ) ; __set_bit ( DONT_FORK_BIT , & debug ) ; __set_bit ( NO_SYSLOG_BIT , & debug ) ; if ( optarg && optarg [ 0 ] ) { int fd = open ( optarg , O_WRONLY | O_APPEND | O_CREAT , S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH ) ; if ( fd == - 1 ) { fprintf ( stderr , "Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>config-test<S2SV_blank>log<S2SV_blank>file<S2SV_blank>%s\\n" , optarg ) ; exit ( EXIT_FAILURE ) ; } dup2 ( fd , STDERR_FILENO ) ; close ( fd ) ; } break ; case 'f' : conf_file = optarg ; break ; case 2 : set_flush_log_file ( ) ; break ; # if defined _WITH_VRRP_ && defined _WITH_LVS_ case 'P' : __clear_bit ( DAEMON_CHECKERS , & daemon_mode ) ; break ; case 'C' : __clear_bit ( DAEMON_VRRP , & daemon_mode ) ; break ; # endif # ifdef _WITH_BFD_ case 'B' : __clear_bit ( DAEMON_BFD , & daemon_mode ) ; break ; # endif case 'p' : main_pidfile = optarg ; break ; # ifdef _WITH_LVS_ case 'c' : checkers_pidfile = optarg ; break ; case 'a' : __set_bit ( LOG_ADDRESS_CHANGES , & debug ) ; break ; # endif # ifdef _WITH_VRRP_ case 'r' : vrrp_pidfile = optarg ; break ; # endif # ifdef _WITH_BFD_ case 'b' : bfd_pidfile = optarg ; break ; # endif # ifdef _WITH_SNMP_ case 'x' : snmp = 1 ; break ; case 'A' : snmp_socket = optarg ; break ; # endif case 'M' : set_core_dump_pattern = true ; if ( optarg && optarg [ 0 ] ) core_dump_pattern = optarg ; case 'm' : create_core_dump = true ; break ; # ifdef _MEM_CHECK_LOG_ case 'L' : __set_bit ( MEM_CHECK_LOG_BIT , & debug ) ; break ; # endif # if HAVE_DECL_CLONE_NEWNET case 's' : override_namespace = MALLOC ( strlen ( optarg ) + 1 ) ; strcpy ( override_namespace , optarg ) ; break ; # endif case 'i' : FREE_PTR ( config_id ) ; config_id = MALLOC ( strlen ( optarg ) + 1 ) ; strcpy ( config_id , optarg ) ; break ; case 4 : signum = get_signum ( optarg ) ; if ( signum == - 1 ) { fprintf ( stderr , "Unknown<S2SV_blank>sigfunc<S2SV_blank>%s\\n" , optarg ) ; exit ( 1 ) ; } printf ( "%d\\n" , signum ) ; exit ( 0 ) ; break ; case 3 : __set_bit ( RUN_ALL_CHILDREN , & daemon_mode ) ; # ifdef _WITH_VRRP_ __set_bit ( DAEMON_VRRP , & daemon_mode ) ; # endif # ifdef _WITH_LVS_ __set_bit ( DAEMON_CHECKERS , & daemon_mode ) ; # endif # ifdef _WITH_BFD_ __set_bit ( DAEMON_BFD , & daemon_mode ) ; # endif break ; # ifdef _WITH_PERF_ case 5 : if ( optarg && optarg [ 0 ] ) { if ( ! strcmp ( optarg , "run" ) ) perf_run = PERF_RUN ; else if ( ! strcmp ( optarg , "all" ) ) perf_run = PERF_ALL ; else if ( ! strcmp ( optarg , "end" ) ) perf_run = PERF_END ; else log_message ( LOG_INFO , "Unknown<S2SV_blank>perf<S2SV_blank>start<S2SV_blank>point<S2SV_blank>%s" , optarg ) ; } else perf_run = PERF_RUN ; break ; # endif # ifdef WITH_DEBUG_OPTIONS case 6 : set_debug_options ( optarg && optarg [ 0 ] ? optarg : NULL ) ; break ; # endif case '?' : if ( optopt && argv [ curind ] [ 1 ] != '-' ) fprintf ( stderr , "Unknown<S2SV_blank>option<S2SV_blank>-%c\\n" , optopt ) ; else fprintf ( stderr , "Unknown<S2SV_blank>option<S2SV_blank>%s\\n" , argv [ curind ] ) ; bad_option = true ; break ; case ':' : if ( optopt && argv [ curind ] [ 1 ] != '-' ) fprintf ( stderr , "Missing<S2SV_blank>parameter<S2SV_blank>for<S2SV_blank>option<S2SV_blank>-%c\\n" , optopt ) ; else fprintf ( stderr , "Missing<S2SV_blank>parameter<S2SV_blank>for<S2SV_blank>option<S2SV_blank>--%s\\n" , long_options [ longindex ] . name ) ; bad_option = true ; break ; default : exit ( 1 ) ; break ; } curind = optind ; } if ( optind < argc ) { printf ( "Unexpected<S2SV_blank>argument(s):<S2SV_blank>" ) ; while ( optind < argc ) printf ( "%s<S2SV_blank>" , argv [ optind ++ ] ) ; printf ( "\\n" ) ; } if ( bad_option ) exit ( 1 ) ; return reopen_log ; }
CWE-200 static void usage ( const char * prog ) { fprintf ( stderr , "Usage:<S2SV_blank>%s<S2SV_blank>[OPTION...]\\n" , prog ) ; fprintf ( stderr , "<S2SV_blank><S2SV_blank>-f,<S2SV_blank>--use-file=FILE<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Use<S2SV_blank>the<S2SV_blank>specified<S2SV_blank>configuration<S2SV_blank>file\\n" ) ; # if defined _WITH_VRRP_ && defined _WITH_LVS_ fprintf ( stderr , "<S2SV_blank><S2SV_blank>-P,<S2SV_blank>--vrrp<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Only<S2SV_blank>run<S2SV_blank>with<S2SV_blank>VRRP<S2SV_blank>subsystem\\n" ) ; fprintf ( stderr , "<S2SV_blank><S2SV_blank>-C,<S2SV_blank>--check<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Only<S2SV_blank>run<S2SV_blank>with<S2SV_blank>Health-checker<S2SV_blank>subsystem\\n" ) ; # endif # ifdef _WITH_BFD_ fprintf ( stderr , "<S2SV_blank><S2SV_blank>-B,<S2SV_blank>--no_bfd<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Don\'t<S2SV_blank>run<S2SV_blank>BFD<S2SV_blank>subsystem\\n" ) ; # endif fprintf ( stderr , "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>--all<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Force<S2SV_blank>all<S2SV_blank>child<S2SV_blank>processes<S2SV_blank>to<S2SV_blank>run,<S2SV_blank>even<S2SV_blank>if<S2SV_blank>have<S2SV_blank>no<S2SV_blank>configuration\\n" ) ; fprintf ( stderr , "<S2SV_blank><S2SV_blank>-l,<S2SV_blank>--log-console<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Log<S2SV_blank>messages<S2SV_blank>to<S2SV_blank>local<S2SV_blank>console\\n" ) ; fprintf ( stderr , "<S2SV_blank><S2SV_blank>-D,<S2SV_blank>--log-detail<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Detailed<S2SV_blank>log<S2SV_blank>messages\\n" ) ; fprintf ( stderr , "<S2SV_blank><S2SV_blank>-S,<S2SV_blank>--log-facility=[0-7]<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Set<S2SV_blank>syslog<S2SV_blank>facility<S2SV_blank>to<S2SV_blank>LOG_LOCAL[0-7]\\n" ) ; fprintf ( stderr , "<S2SV_blank><S2SV_blank>-g,<S2SV_blank>--log-file=FILE<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Also<S2SV_blank>log<S2SV_blank>to<S2SV_blank>FILE<S2SV_blank>(default<S2SV_blank>/tmp/keepalived.log)\\n" ) ; fprintf ( stderr , "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>--flush-log-file<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flush<S2SV_blank>log<S2SV_blank>file<S2SV_blank>on<S2SV_blank>write\\n" ) ; fprintf ( stderr , "<S2SV_blank><S2SV_blank>-G,<S2SV_blank>--no-syslog<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Don\'t<S2SV_blank>log<S2SV_blank>via<S2SV_blank>syslog\\n" ) ; <S2SV_StartBug> # ifdef _WITH_VRRP_ <S2SV_EndBug> fprintf ( stderr , "<S2SV_blank><S2SV_blank>-X,<S2SV_blank>--release-vips<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Drop<S2SV_blank>VIP<S2SV_blank>on<S2SV_blank>transition<S2SV_blank>from<S2SV_blank>signal.\\n" ) ; fprintf ( stderr , "<S2SV_blank><S2SV_blank>-V,<S2SV_blank>--dont-release-vrrp<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Don\'t<S2SV_blank>remove<S2SV_blank>VRRP<S2SV_blank>VIPs<S2SV_blank>and<S2SV_blank>VROUTEs<S2SV_blank>on<S2SV_blank>daemon<S2SV_blank>stop\\n" ) ; # endif # ifdef _WITH_LVS_ fprintf ( stderr , "<S2SV_blank><S2SV_blank>-I,<S2SV_blank>--dont-release-ipvs<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Don\'t<S2SV_blank>remove<S2SV_blank>IPVS<S2SV_blank>topology<S2SV_blank>on<S2SV_blank>daemon<S2SV_blank>stop\\n" ) ; # endif fprintf ( stderr , "<S2SV_blank><S2SV_blank>-R,<S2SV_blank>--dont-respawn<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Don\'t<S2SV_blank>respawn<S2SV_blank>child<S2SV_blank>processes\\n" ) ; fprintf ( stderr , "<S2SV_blank><S2SV_blank>-n,<S2SV_blank>--dont-fork<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Don\'t<S2SV_blank>fork<S2SV_blank>the<S2SV_blank>daemon<S2SV_blank>process\\n" ) ; fprintf ( stderr , "<S2SV_blank><S2SV_blank>-d,<S2SV_blank>--dump-conf<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Dump<S2SV_blank>the<S2SV_blank>configuration<S2SV_blank>data\\n" ) ; fprintf ( stderr , "<S2SV_blank><S2SV_blank>-p,<S2SV_blank>--pid=FILE<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Use<S2SV_blank>specified<S2SV_blank>pidfile<S2SV_blank>for<S2SV_blank>parent<S2SV_blank>process\\n" ) ; # ifdef _WITH_VRRP_ fprintf ( stderr , "<S2SV_blank><S2SV_blank>-r,<S2SV_blank>--vrrp_pid=FILE<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Use<S2SV_blank>specified<S2SV_blank>pidfile<S2SV_blank>for<S2SV_blank>VRRP<S2SV_blank>child<S2SV_blank>process\\n" ) ; # endif # ifdef _WITH_LVS_ fprintf ( stderr , "<S2SV_blank><S2SV_blank>-c,<S2SV_blank>--checkers_pid=FILE<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Use<S2SV_blank>specified<S2SV_blank>pidfile<S2SV_blank>for<S2SV_blank>checkers<S2SV_blank>child<S2SV_blank>process\\n" ) ; fprintf ( stderr , "<S2SV_blank><S2SV_blank>-a,<S2SV_blank>--address-monitoring<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Report<S2SV_blank>all<S2SV_blank>address<S2SV_blank>additions/deletions<S2SV_blank>notified<S2SV_blank>via<S2SV_blank>netlink\\n" ) ; # endif # ifdef _WITH_BFD_ fprintf ( stderr , "<S2SV_blank><S2SV_blank>-b,<S2SV_blank>--bfd_pid=FILE<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Use<S2SV_blank>specified<S2SV_blank>pidfile<S2SV_blank>for<S2SV_blank>BFD<S2SV_blank>child<S2SV_blank>process\\n" ) ; # endif # ifdef _WITH_SNMP_ fprintf ( stderr , "<S2SV_blank><S2SV_blank>-x,<S2SV_blank>--snmp<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Enable<S2SV_blank>SNMP<S2SV_blank>subsystem\\n" ) ; fprintf ( stderr , "<S2SV_blank><S2SV_blank>-A,<S2SV_blank>--snmp-agent-socket=FILE<S2SV_blank>Use<S2SV_blank>the<S2SV_blank>specified<S2SV_blank>socket<S2SV_blank>for<S2SV_blank>master<S2SV_blank>agent\\n" ) ; # endif # if HAVE_DECL_CLONE_NEWNET fprintf ( stderr , "<S2SV_blank><S2SV_blank>-s,<S2SV_blank>--namespace=NAME<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Run<S2SV_blank>in<S2SV_blank>network<S2SV_blank>namespace<S2SV_blank>NAME<S2SV_blank>(overrides<S2SV_blank>config)\\n" ) ; # endif fprintf ( stderr , "<S2SV_blank><S2SV_blank>-m,<S2SV_blank>--core-dump<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Produce<S2SV_blank>core<S2SV_blank>dump<S2SV_blank>if<S2SV_blank>terminate<S2SV_blank>abnormally\\n" ) ; fprintf ( stderr , "<S2SV_blank><S2SV_blank>-M,<S2SV_blank>--core-dump-pattern=PATN<S2SV_blank>Also<S2SV_blank>set<S2SV_blank>/proc/sys/kernel/core_pattern<S2SV_blank>to<S2SV_blank>PATN<S2SV_blank>(default<S2SV_blank>\'core\')\\n" ) ; # ifdef _MEM_CHECK_LOG_ fprintf ( stderr , "<S2SV_blank><S2SV_blank>-L,<S2SV_blank>--mem-check-log<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Log<S2SV_blank>malloc/frees<S2SV_blank>to<S2SV_blank>syslog\\n" ) ; # endif fprintf ( stderr , "<S2SV_blank><S2SV_blank>-i,<S2SV_blank>--config-id<S2SV_blank>id<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Skip<S2SV_blank>any<S2SV_blank>configuration<S2SV_blank>lines<S2SV_blank>beginning<S2SV_blank>\'@\'<S2SV_blank>that<S2SV_blank>don\'t<S2SV_blank>match<S2SV_blank>id\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>or<S2SV_blank>any<S2SV_blank>lines<S2SV_blank>beginning<S2SV_blank>@^<S2SV_blank>that<S2SV_blank>do<S2SV_blank>match.\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>The<S2SV_blank>config-id<S2SV_blank>defaults<S2SV_blank>to<S2SV_blank>the<S2SV_blank>node<S2SV_blank>name<S2SV_blank>if<S2SV_blank>option<S2SV_blank>not<S2SV_blank>used\\n" ) ; fprintf ( stderr , "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>--signum=SIGFUNC<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Return<S2SV_blank>signal<S2SV_blank>number<S2SV_blank>for<S2SV_blank>STOP,<S2SV_blank>RELOAD,<S2SV_blank>DATA,<S2SV_blank>STATS" # ifdef _WITH_JSON_ ",<S2SV_blank>JSON" # endif "\\n" ) ; fprintf ( stderr , "<S2SV_blank><S2SV_blank>-t,<S2SV_blank>--config-test[=LOG_FILE]<S2SV_blank>Check<S2SV_blank>the<S2SV_blank>configuration<S2SV_blank>for<S2SV_blank>obvious<S2SV_blank>errors,<S2SV_blank>output<S2SV_blank>to\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>stderr<S2SV_blank>by<S2SV_blank>default\\n" ) ; # ifdef _WITH_PERF_ fprintf ( stderr , "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>--perf[=PERF_TYPE]<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Collect<S2SV_blank>perf<S2SV_blank>data,<S2SV_blank>PERF_TYPE=all,<S2SV_blank>run(default)<S2SV_blank>or<S2SV_blank>end\\n" ) ; # endif # ifdef WITH_DEBUG_OPTIONS fprintf ( stderr , "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>--debug[=...]<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Enable<S2SV_blank>debug<S2SV_blank>options.<S2SV_blank>p,<S2SV_blank>b,<S2SV_blank>c,<S2SV_blank>v<S2SV_blank>specify<S2SV_blank>parent,<S2SV_blank>bfd,<S2SV_blank>checker<S2SV_blank>and<S2SV_blank>vrrp<S2SV_blank>processes\\n" ) ; # ifdef _TIMER_CHECK_ fprintf ( stderr , "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>T<S2SV_blank>-<S2SV_blank>timer<S2SV_blank>debug\\n" ) ; # endif # ifdef _SMTP_ALERT_DEBUG_ fprintf ( stderr , "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>M<S2SV_blank>-<S2SV_blank>email<S2SV_blank>alert<S2SV_blank>debug\\n" ) ; # endif # ifdef _EPOLL_DEBUG_ fprintf ( stderr , "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>E<S2SV_blank>-<S2SV_blank>epoll<S2SV_blank>debug\\n" ) ; # endif # ifdef _EPOLL_THREAD_DUMP_ fprintf ( stderr , "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>D<S2SV_blank>-<S2SV_blank>epoll<S2SV_blank>thread<S2SV_blank>dump<S2SV_blank>debug\\n" ) ; # endif # ifdef _VRRP_FD_DEBUG fprintf ( stderr , "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>F<S2SV_blank>-<S2SV_blank>vrrp<S2SV_blank>fd<S2SV_blank>dump<S2SV_blank>debug\\n" ) ; # endif # ifdef _REGEX_DEBUG_ fprintf ( stderr , "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>R<S2SV_blank>-<S2SV_blank>regex<S2SV_blank>debug\\n" ) ; # endif # ifdef _WITH_REGEX_TIMERS_ fprintf ( stderr , "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>X<S2SV_blank>-<S2SV_blank>regex<S2SV_blank>timers\\n" ) ; # endif # ifdef _TSM_DEBUG_ fprintf ( stderr , "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>S<S2SV_blank>-<S2SV_blank>TSM<S2SV_blank>debug\\n" ) ; # endif # ifdef _NETLINK_TIMERS_ fprintf ( stderr , "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>N<S2SV_blank>-<S2SV_blank>netlink<S2SV_blank>timer<S2SV_blank>debug\\n" ) ; # endif fprintf ( stderr , "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Example<S2SV_blank>--debug=TpMEvcp\\n" ) ; # endif fprintf ( stderr , "<S2SV_blank><S2SV_blank>-v,<S2SV_blank>--version<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Display<S2SV_blank>the<S2SV_blank>version<S2SV_blank>number\\n" ) ; fprintf ( stderr , "<S2SV_blank><S2SV_blank>-h,<S2SV_blank>--help<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Display<S2SV_blank>this<S2SV_blank>help<S2SV_blank>message\\n" ) ; }
CWE-772 LPSTR tr_esc_str ( LPCSTR arg , bool format ) { <S2SV_StartBug> LPSTR tmp = NULL ; <S2SV_EndBug> size_t cs = 0 , x , ds , len ; size_t s ; if ( NULL == arg ) return NULL ; s = strlen ( arg ) ; while ( ( s > 0 ) && isspace ( arg [ s - 1 ] ) ) s -- ; ds = s + 1 ; if ( s ) <S2SV_StartBug> tmp = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ; <S2SV_EndBug> if ( NULL == tmp ) { fprintf ( stderr , "Could<S2SV_blank>not<S2SV_blank>allocate<S2SV_blank>string<S2SV_blank>buffer.\\n" ) ; exit ( - 2 ) ; } memset ( tmp , 0 , ds * sizeof ( CHAR ) ) ; for ( x = 0 ; x < s ; x ++ ) { switch ( arg [ x ] ) { case '<' : len = format ? 13 : 4 ; ds += len - 1 ; <S2SV_StartBug> tmp = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ; <S2SV_EndBug> if ( NULL == tmp ) { fprintf ( stderr , "Could<S2SV_blank>not<S2SV_blank>reallocate<S2SV_blank>string<S2SV_blank>buffer.\\n" ) ; exit ( - 3 ) ; } if ( format ) strncpy ( & tmp [ cs ] , "<replaceable>" , len ) ; else strncpy ( & tmp [ cs ] , "&lt;" , len ) ; cs += len ; break ; case '>' : len = format ? 14 : 4 ; ds += len - 1 ; <S2SV_StartBug> tmp = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ; <S2SV_EndBug> if ( NULL == tmp ) { fprintf ( stderr , "Could<S2SV_blank>not<S2SV_blank>reallocate<S2SV_blank>string<S2SV_blank>buffer.\\n" ) ; exit ( - 4 ) ; } if ( format ) strncpy ( & tmp [ cs ] , "</replaceable>" , len ) ; else strncpy ( & tmp [ cs ] , "&lt;" , len ) ; cs += len ; break ; case '\\'' : ds += 5 ; <S2SV_StartBug> tmp = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ; <S2SV_EndBug> if ( NULL == tmp ) { fprintf ( stderr , "Could<S2SV_blank>not<S2SV_blank>reallocate<S2SV_blank>string<S2SV_blank>buffer.\\n" ) ; exit ( - 5 ) ; } tmp [ cs ++ ] = '&' ; tmp [ cs ++ ] = 'a' ; tmp [ cs ++ ] = 'p' ; tmp [ cs ++ ] = 'o' ; tmp [ cs ++ ] = 's' ; tmp [ cs ++ ] = ';' ; break ; case \'"\' : ds += 5 ; <S2SV_StartBug> tmp = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ; <S2SV_EndBug> if ( NULL == tmp ) { fprintf ( stderr , "Could<S2SV_blank>not<S2SV_blank>reallocate<S2SV_blank>string<S2SV_blank>buffer.\\n" ) ; exit ( - 6 ) ; } tmp [ cs ++ ] = '&' ; tmp [ cs ++ ] = 'q' ; tmp [ cs ++ ] = 'u' ; tmp [ cs ++ ] = 'o' ; tmp [ cs ++ ] = 't' ; tmp [ cs ++ ] = ';' ; break ; case '&' : ds += 4 ; <S2SV_StartBug> tmp = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( NULL == tmp ) <S2SV_EndBug> { fprintf ( stderr , "Could<S2SV_blank>not<S2SV_blank>reallocate<S2SV_blank>string<S2SV_blank>buffer.\\n" ) ; exit ( - 7 ) ; } tmp [ cs ++ ] = '&' ; tmp [ cs ++ ] = 'a' ; tmp [ cs ++ ] = 'm' ; tmp [ cs ++ ] = 'p' ; tmp [ cs ++ ] = ';' ; break ; default : tmp [ cs ++ ] = arg [ x ] ; break ; } tmp [ ds - 1 ] = '\\0' ; } return tmp ; }
CWE-190 static int b_unpack ( lua_State * L ) { Header h ; const char * fmt = luaL_checkstring ( L , 1 ) ; size_t ld ; const char * data = luaL_checklstring ( L , 2 , & ld ) ; size_t pos = luaL_optinteger ( L , 3 , 1 ) - 1 ; <S2SV_StartBug> defaultoptions ( & h ) ; <S2SV_EndBug> lua_settop ( L , 2 ) ; while ( * fmt ) { int opt = * fmt ++ ; size_t size = optsize ( L , opt , & fmt ) ; pos += gettoalign ( pos , & h , opt , size ) ; luaL_argcheck ( L , pos + size <= ld , 2 , "data<S2SV_blank>string<S2SV_blank>too<S2SV_blank>short" ) ; <S2SV_StartBug> luaL_checkstack ( L , 1 , "too<S2SV_blank>many<S2SV_blank>results" ) ; <S2SV_EndBug> switch ( opt ) { case 'b' : case 'B' : case 'h' : case 'H' : case 'l' : case 'L' : case 'T' : case 'i' : case 'I' : { int issigned = islower ( opt ) ; lua_Number res = getinteger ( data + pos , h . endian , issigned , size ) ; <S2SV_StartBug> lua_pushnumber ( L , res ) ; <S2SV_EndBug> break ; } case 'x' : { break ; } case 'f' : { float f ; memcpy ( & f , data + pos , size ) ; correctbytes ( ( char * ) & f , sizeof ( f ) , h . endian ) ; <S2SV_StartBug> lua_pushnumber ( L , f ) ; <S2SV_EndBug> break ; } case 'd' : { double d ; memcpy ( & d , data + pos , size ) ; correctbytes ( ( char * ) & d , sizeof ( d ) , h . endian ) ; <S2SV_StartBug> lua_pushnumber ( L , d ) ; <S2SV_EndBug> break ; } case 'c' : { if ( size == 0 ) { <S2SV_StartBug> if ( ! lua_isnumber ( L , - 1 ) ) <S2SV_EndBug> <S2SV_StartBug> luaL_error ( L , "format<S2SV_blank>`c0\'<S2SV_blank>needs<S2SV_blank>a<S2SV_blank>previous<S2SV_blank>size" ) ; <S2SV_EndBug> size = lua_tonumber ( L , - 1 ) ; <S2SV_StartBug> lua_pop ( L , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> luaL_argcheck ( L , pos + size <= ld , 2 , "data<S2SV_blank>string<S2SV_blank>too<S2SV_blank>short" ) ; <S2SV_EndBug> } <S2SV_StartBug> lua_pushlstring ( L , data + pos , size ) ; <S2SV_EndBug> break ; } case 's' : { const char * e = ( const char * ) memchr ( data + pos , '\\0' , ld - pos ) ; if ( e == NULL ) luaL_error ( L , "unfinished<S2SV_blank>string<S2SV_blank>in<S2SV_blank>data" ) ; size = ( e - ( data + pos ) ) + 1 ; <S2SV_StartBug> lua_pushlstring ( L , data + pos , size - 1 ) ; <S2SV_EndBug> break ; } default : controloptions ( L , opt , & fmt , & h ) ; } pos += size ; } lua_pushinteger ( L , pos + 1 ) ; <S2SV_StartBug> return lua_gettop ( L ) - 2 ; <S2SV_EndBug> }
CWE-190 static void controloptions ( lua_State * L , int opt , const char * * fmt , Header * h ) { switch ( opt ) { case '<S2SV_blank>' : return ; case '>' : h -> endian = BIG ; return ; case '<' : h -> endian = LITTLE ; return ; case '!' : { <S2SV_StartBug> int a = getnum ( L , fmt , MAXALIGN ) ; <S2SV_EndBug> if ( ! isp2 ( a ) ) luaL_error ( L , "alignment<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>power<S2SV_blank>of<S2SV_blank>2" , a ) ; h -> align = a ; return ; } default : { const char * msg = lua_pushfstring ( L , "invalid<S2SV_blank>format<S2SV_blank>option<S2SV_blank>\'%c\'" , opt ) ; luaL_argerror ( L , 1 , msg ) ; } } }
CWE-190 <S2SV_StartBug> static int getnum ( lua_State * L , const char * * fmt , int df ) { <S2SV_EndBug> if ( ! isdigit ( * * fmt ) ) return df ; else { int a = 0 ; do { <S2SV_StartBug> if ( a > ( INT_MAX / 10 ) || a * 10 > ( INT_MAX - ( * * fmt - '0' ) ) ) <S2SV_EndBug> luaL_error ( L , "integral<S2SV_blank>size<S2SV_blank>overflow" ) ; a = a * 10 + * ( ( * fmt ) ++ ) - '0' ; } while ( isdigit ( * * fmt ) ) ; return a ; } }
CWE-190 static size_t optsize ( lua_State * L , char opt , const char * * fmt ) { switch ( opt ) { case 'B' : case 'b' : return sizeof ( char ) ; case 'H' : case 'h' : return sizeof ( short ) ; case 'L' : case 'l' : return sizeof ( long ) ; case 'T' : return sizeof ( size_t ) ; case 'f' : return sizeof ( float ) ; case 'd' : return sizeof ( double ) ; case 'x' : return 1 ; <S2SV_StartBug> case 'c' : return getnum ( L , fmt , 1 ) ; <S2SV_EndBug> case 'i' : case 'I' : { <S2SV_StartBug> int sz = getnum ( L , fmt , sizeof ( int ) ) ; <S2SV_EndBug> if ( sz > MAXINTSIZE ) luaL_error ( L , "integral<S2SV_blank>size<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>limit<S2SV_blank>of<S2SV_blank>%d" , sz , MAXINTSIZE ) ; return sz ; } default : return 0 ; } }
CWE-119 int mp_pack ( lua_State * L ) { int nargs = lua_gettop ( L ) ; int i ; mp_buf * buf ; if ( nargs == 0 ) <S2SV_StartBug> return luaL_argerror ( L , 0 , "MessagePack<S2SV_blank>pack<S2SV_blank>needs<S2SV_blank>input." ) ; <S2SV_EndBug> buf = mp_buf_new ( L ) ; for ( i = 1 ; i <= nargs ; i ++ ) { lua_pushvalue ( L , i ) ; mp_encode_lua_type ( L , buf , 0 ) ; lua_pushlstring ( L , ( char * ) buf -> b , buf -> len ) ; buf -> free += buf -> len ; buf -> len = 0 ; } mp_buf_free ( L , buf ) ; lua_concat ( L , nargs ) ; return 1 ; }
CWE-119 void mp_decode_to_lua_array ( lua_State * L , mp_cur * c , size_t len ) { assert ( len <= UINT_MAX ) ; int index = 1 ; <S2SV_StartBug> lua_newtable ( L ) ; <S2SV_EndBug> while ( len -- ) { lua_pushnumber ( L , index ++ ) ; mp_decode_to_lua_type ( L , c ) ; if ( c -> err ) return ; lua_settable ( L , - 3 ) ; } }
CWE-119 void mp_encode_lua_table_as_array ( lua_State * L , mp_buf * buf , int level ) { # if LUA_VERSION_NUM < 502 size_t len = lua_objlen ( L , - 1 ) , j ; # else size_t len = lua_rawlen ( L , - 1 ) , j ; # endif mp_encode_array ( L , buf , len ) ; <S2SV_StartBug> for ( j = 1 ; j <= len ; j ++ ) { <S2SV_EndBug> lua_pushnumber ( L , j ) ; lua_gettable ( L , - 2 ) ; mp_encode_lua_type ( L , buf , level + 1 ) ; } }
CWE-119 void mp_encode_lua_table_as_map ( lua_State * L , mp_buf * buf , int level ) { <S2SV_StartBug> size_t len = 0 ; <S2SV_EndBug> lua_pushnil ( L ) ; while ( lua_next ( L , - 2 ) ) { lua_pop ( L , 1 ) ; len ++ ; } mp_encode_map ( L , buf , len ) ; lua_pushnil ( L ) ; while ( lua_next ( L , - 2 ) ) { lua_pushvalue ( L , - 2 ) ; mp_encode_lua_type ( L , buf , level + 1 ) ; mp_encode_lua_type ( L , buf , level + 1 ) ; } }
CWE-119 int mp_pack ( lua_State * L ) { int nargs = lua_gettop ( L ) ; int i ; mp_buf * buf ; if ( nargs == 0 ) return luaL_argerror ( L , 0 , "MessagePack<S2SV_blank>pack<S2SV_blank>needs<S2SV_blank>input." ) ; if ( ! lua_checkstack ( L , nargs ) ) return luaL_argerror ( L , 0 , "Too<S2SV_blank>many<S2SV_blank>arguments<S2SV_blank>for<S2SV_blank>MessagePack<S2SV_blank>pack." ) ; buf = mp_buf_new ( L ) ; for ( i = 1 ; i <= nargs ; i ++ ) { <S2SV_StartBug> lua_pushvalue ( L , i ) ; <S2SV_EndBug> mp_encode_lua_type ( L , buf , 0 ) ; lua_pushlstring ( L , ( char * ) buf -> b , buf -> len ) ; buf -> free += buf -> len ; buf -> len = 0 ; } mp_buf_free ( L , buf ) ; lua_concat ( L , nargs ) ; return 1 ; }
CWE-119 int mp_unpack_full ( lua_State * L , int limit , int offset ) { size_t len ; const char * s ; mp_cur c ; int cnt ; int decode_all = ( ! limit && ! offset ) ; s = luaL_checklstring ( L , 1 , & len ) ; if ( offset < 0 || limit < 0 ) return luaL_error ( L , "Invalid<S2SV_blank>request<S2SV_blank>to<S2SV_blank>unpack<S2SV_blank>with<S2SV_blank>offset<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>and<S2SV_blank>limit<S2SV_blank>of<S2SV_blank>%d." , offset , len ) ; else if ( offset > len ) return luaL_error ( L , "Start<S2SV_blank>offset<S2SV_blank>%d<S2SV_blank>greater<S2SV_blank>than<S2SV_blank>input<S2SV_blank>length<S2SV_blank>%d." , offset , len ) ; if ( decode_all ) limit = INT_MAX ; mp_cur_init ( & c , ( const unsigned char * ) s + offset , len - offset ) ; for ( cnt = 0 ; c . left > 0 && cnt < limit ; cnt ++ ) { mp_decode_to_lua_type ( L , & c ) ; if ( c . err == MP_CUR_ERROR_EOF ) { return luaL_error ( L , "Missing<S2SV_blank>bytes<S2SV_blank>in<S2SV_blank>input." ) ; } else if ( c . err == MP_CUR_ERROR_BADFMT ) { return luaL_error ( L , "Bad<S2SV_blank>data<S2SV_blank>format<S2SV_blank>in<S2SV_blank>input." ) ; } } if ( ! decode_all ) { int offset = len - c . left ; <S2SV_StartBug> lua_pushinteger ( L , c . left == 0 ? - 1 : offset ) ; <S2SV_EndBug> lua_insert ( L , 2 ) ; cnt += 1 ; } return cnt ; }
CWE-119 static void cliRefreshPrompt ( void ) { <S2SV_StartBug> int len ; <S2SV_EndBug> if ( config . eval_ldb ) return ; <S2SV_StartBug> if ( config . hostsocket != NULL ) <S2SV_EndBug> <S2SV_StartBug> len = snprintf ( config . prompt , sizeof ( config . prompt ) , "redis<S2SV_blank>%s" , <S2SV_EndBug> config . hostsocket ) ; else len = anetFormatAddr ( config . prompt , sizeof ( config . prompt ) , config . hostip , config . hostport ) ; if ( config . dbnum != 0 ) len += snprintf ( config . prompt + len , sizeof ( config . prompt ) - len , "[%d]" , config . dbnum ) ; snprintf ( config . prompt + len , sizeof ( config . prompt ) - len , "><S2SV_blank>" ) ; }
CWE-704 void xgroupCommand ( client * c ) { const char * help [ ] = { "CREATE<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><key><S2SV_blank><groupname><S2SV_blank><id<S2SV_blank>or<S2SV_blank>$><S2SV_blank><S2SV_blank>--<S2SV_blank>Create<S2SV_blank>a<S2SV_blank>new<S2SV_blank>consumer<S2SV_blank>group." , "SETID<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><key><S2SV_blank><groupname><S2SV_blank><id<S2SV_blank>or<S2SV_blank>$><S2SV_blank><S2SV_blank>--<S2SV_blank>Set<S2SV_blank>the<S2SV_blank>current<S2SV_blank>group<S2SV_blank>ID." , "DELGROUP<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><key><S2SV_blank><groupname><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>--<S2SV_blank>Remove<S2SV_blank>the<S2SV_blank>specified<S2SV_blank>group." , "DELCONSUMER<S2SV_blank><key><S2SV_blank><groupname><S2SV_blank><consumer><S2SV_blank>--<S2SV_blank>Remove<S2SV_blank>the<S2SV_blank>specified<S2SV_blank>conusmer." , "HELP<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>--<S2SV_blank>Prints<S2SV_blank>this<S2SV_blank>help." , NULL } ; stream * s = NULL ; sds grpname = NULL ; streamCG * cg = NULL ; char * opt = c -> argv [ 1 ] -> ptr ; if ( c -> argc >= 4 ) { robj * o = lookupKeyWriteOrReply ( c , c -> argv [ 2 ] , shared . nokeyerr ) ; <S2SV_StartBug> if ( o == NULL ) return ; <S2SV_EndBug> s = o -> ptr ; grpname = c -> argv [ 3 ] -> ptr ; if ( ( cg = streamLookupCG ( s , grpname ) ) == NULL && ( ! strcasecmp ( opt , "SETID" ) || ! strcasecmp ( opt , "DELCONSUMER" ) ) ) { addReplyErrorFormat ( c , "-NOGROUP<S2SV_blank>No<S2SV_blank>such<S2SV_blank>consumer<S2SV_blank>group<S2SV_blank>\'%s\'<S2SV_blank>" "for<S2SV_blank>key<S2SV_blank>name<S2SV_blank>\'%s\'" , ( char * ) grpname , ( char * ) c -> argv [ 2 ] -> ptr ) ; return ; } } if ( ! strcasecmp ( opt , "CREATE" ) && c -> argc == 5 ) { streamID id ; if ( ! strcmp ( c -> argv [ 4 ] -> ptr , "$" ) ) { id = s -> last_id ; } else if ( streamParseIDOrReply ( c , c -> argv [ 4 ] , & id , 0 ) != C_OK ) { return ; } streamCG * cg = streamCreateCG ( s , grpname , sdslen ( grpname ) , & id ) ; if ( cg ) { addReply ( c , shared . ok ) ; server . dirty ++ ; } else { addReplySds ( c , sdsnew ( "-BUSYGROUP<S2SV_blank>Consumer<S2SV_blank>Group<S2SV_blank>name<S2SV_blank>already<S2SV_blank>exists\\r\\n" ) ) ; } } else if ( ! strcasecmp ( opt , "SETID" ) && c -> argc == 5 ) { streamID id ; if ( ! strcmp ( c -> argv [ 4 ] -> ptr , "$" ) ) { id = s -> last_id ; } else if ( streamParseIDOrReply ( c , c -> argv [ 4 ] , & id , 0 ) != C_OK ) { return ; } cg -> last_id = id ; addReply ( c , shared . ok ) ; } else if ( ! strcasecmp ( opt , "DESTROY" ) && c -> argc == 4 ) { if ( cg ) { raxRemove ( s -> cgroups , ( unsigned char * ) grpname , sdslen ( grpname ) , NULL ) ; streamFreeCG ( cg ) ; addReply ( c , shared . cone ) ; } else { addReply ( c , shared . czero ) ; } } else if ( ! strcasecmp ( opt , "DELCONSUMER" ) && c -> argc == 5 ) { long long pending = streamDelConsumer ( cg , c -> argv [ 4 ] -> ptr ) ; addReplyLongLong ( c , pending ) ; server . dirty ++ ; } else if ( ! strcasecmp ( opt , "HELP" ) ) { addReplyHelp ( c , help ) ; } else { addReply ( c , shared . syntaxerr ) ; } }
CWE-190 static int b_unpack ( lua_State * L ) { Header h ; const char * fmt = luaL_checkstring ( L , 1 ) ; size_t ld ; const char * data = luaL_checklstring ( L , 2 , & ld ) ; <S2SV_StartBug> size_t pos = luaL_optinteger ( L , 3 , 1 ) - 1 ; <S2SV_EndBug> int n = 0 ; defaultoptions ( & h ) ; while ( * fmt ) { int opt = * fmt ++ ; size_t size = optsize ( L , opt , & fmt ) ; pos += gettoalign ( pos , & h , opt , size ) ; <S2SV_StartBug> luaL_argcheck ( L , pos + size <= ld , 2 , "data<S2SV_blank>string<S2SV_blank>too<S2SV_blank>short" ) ; <S2SV_EndBug> luaL_checkstack ( L , 2 , "too<S2SV_blank>many<S2SV_blank>results" ) ; switch ( opt ) { case 'b' : case 'B' : case 'h' : case 'H' : case 'l' : case 'L' : case 'T' : case 'i' : case 'I' : { int issigned = islower ( opt ) ; lua_Number res = getinteger ( data + pos , h . endian , issigned , size ) ; lua_pushnumber ( L , res ) ; n ++ ; break ; } case 'x' : { break ; } case 'f' : { float f ; memcpy ( & f , data + pos , size ) ; correctbytes ( ( char * ) & f , sizeof ( f ) , h . endian ) ; lua_pushnumber ( L , f ) ; n ++ ; break ; } case 'd' : { double d ; memcpy ( & d , data + pos , size ) ; correctbytes ( ( char * ) & d , sizeof ( d ) , h . endian ) ; lua_pushnumber ( L , d ) ; n ++ ; break ; } case 'c' : { if ( size == 0 ) { if ( n == 0 || ! lua_isnumber ( L , - 1 ) ) luaL_error ( L , "format<S2SV_blank>\'c0\'<S2SV_blank>needs<S2SV_blank>a<S2SV_blank>previous<S2SV_blank>size" ) ; size = lua_tonumber ( L , - 1 ) ; lua_pop ( L , 1 ) ; n -- ; luaL_argcheck ( L , size <= ld && pos <= ld - size , 2 , "data<S2SV_blank>string<S2SV_blank>too<S2SV_blank>short" ) ; } lua_pushlstring ( L , data + pos , size ) ; n ++ ; break ; } case 's' : { const char * e = ( const char * ) memchr ( data + pos , '\\0' , ld - pos ) ; if ( e == NULL ) luaL_error ( L , "unfinished<S2SV_blank>string<S2SV_blank>in<S2SV_blank>data" ) ; size = ( e - ( data + pos ) ) + 1 ; lua_pushlstring ( L , data + pos , size - 1 ) ; n ++ ; break ; } default : controloptions ( L , opt , & fmt , & h ) ; } pos += size ; } lua_pushinteger ( L , pos + 1 ) ; return n + 1 ; }
CWE-20 static cupsd_job_t * add_job ( cupsd_client_t * con , cupsd_printer_t * printer , mime_type_t * filetype ) { http_status_t status ; ipp_attribute_t * attr , * auth_info ; const char * mandatory ; const char * val ; int priority ; cupsd_job_t * job ; char job_uri [ HTTP_MAX_URI ] ; int kbytes ; int i ; int lowerpagerange ; int exact ; ipp_attribute_t * media_col , * media_margin ; ipp_t * unsup_col ; static const char * const readonly [ ] = { "date-time-at-completed" , "date-time-at-creation" , "date-time-at-processing" , "job-detailed-status-messages" , "job-document-access-errors" , "job-id" , "job-impressions-completed" , "job-k-octets-completed" , "job-media-sheets-completed" , "job-pages-completed" , "job-printer-up-time" , "job-printer-uri" , "job-state" , "job-state-message" , "job-state-reasons" , "job-uri" , "number-of-documents" , "number-of-intervening-jobs" , "output-device-assigned" , "time-at-completed" , "time-at-creation" , "time-at-processing" } ; cupsdLogMessage ( CUPSD_LOG_DEBUG2 , "add_job(%p[%d],<S2SV_blank>%p(%s),<S2SV_blank>%p(%s/%s))" , con , con -> number , printer , printer -> name , filetype , filetype ? filetype -> super : "none" , filetype ? filetype -> type : "none" ) ; if ( ! printer -> shared && _cups_strcasecmp ( con -> http -> hostname , "localhost" ) && _cups_strcasecmp ( con -> http -> hostname , ServerName ) ) { send_ipp_status ( con , IPP_NOT_AUTHORIZED , _ ( "The<S2SV_blank>printer<S2SV_blank>or<S2SV_blank>class<S2SV_blank>is<S2SV_blank>not<S2SV_blank>shared." ) ) ; return ( NULL ) ; } auth_info = ippFindAttribute ( con -> request , "auth-info" , IPP_TAG_TEXT ) ; if ( ( status = cupsdCheckPolicy ( printer -> op_policy_ptr , con , NULL ) ) != HTTP_OK ) { send_http_error ( con , status , printer ) ; return ( NULL ) ; } else if ( printer -> num_auth_info_required == 1 && ! strcmp ( printer -> auth_info_required [ 0 ] , "negotiate" ) && ! con -> username [ 0 ] ) { send_http_error ( con , HTTP_UNAUTHORIZED , printer ) ; return ( NULL ) ; } # ifdef HAVE_SSL else if ( auth_info && ! con -> http -> tls && ! httpAddrLocalhost ( con -> http -> hostaddr ) ) { send_http_error ( con , HTTP_UPGRADE_REQUIRED , printer ) ; return ( NULL ) ; } # endif if ( ! printer -> accepting ) { send_ipp_status ( con , IPP_NOT_ACCEPTING , _ ( "Destination<S2SV_blank>\\"%s\\"<S2SV_blank>is<S2SV_blank>not<S2SV_blank>accepting<S2SV_blank>jobs." ) , printer -> name ) ; return ( NULL ) ; } for ( i = 0 ; i < ( int ) ( sizeof ( readonly ) / sizeof ( readonly [ 0 ] ) ) ; i ++ ) { if ( ( attr = ippFindAttribute ( con -> request , readonly [ i ] , IPP_TAG_ZERO ) ) != NULL ) { ippDeleteAttribute ( con -> request , attr ) ; if ( StrictConformance ) { send_ipp_status ( con , IPP_BAD_REQUEST , _ ( "The<S2SV_blank>\'%s\'<S2SV_blank>Job<S2SV_blank>Status<S2SV_blank>attribute<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>supplied<S2SV_blank>in<S2SV_blank>a<S2SV_blank>job<S2SV_blank>creation<S2SV_blank>request." ) , readonly [ i ] ) ; return ( NULL ) ; } cupsdLogMessage ( CUPSD_LOG_INFO , "Unexpected<S2SV_blank>\'%s\'<S2SV_blank>Job<S2SV_blank>Status<S2SV_blank>attribute<S2SV_blank>in<S2SV_blank>a<S2SV_blank>job<S2SV_blank>creation<S2SV_blank>request." , readonly [ i ] ) ; } } if ( printer -> pc ) { for ( mandatory = ( char * ) cupsArrayFirst ( printer -> pc -> mandatory ) ; mandatory ; mandatory = ( char * ) cupsArrayNext ( printer -> pc -> mandatory ) ) { if ( ! ippFindAttribute ( con -> request , mandatory , IPP_TAG_ZERO ) ) { send_ipp_status ( con , IPP_CONFLICT , _ ( "The<S2SV_blank>\\"%s\\"<S2SV_blank>attribute<S2SV_blank>is<S2SV_blank>required<S2SV_blank>for<S2SV_blank>print<S2SV_blank>jobs." ) , mandatory ) ; return ( NULL ) ; } } } if ( filetype && printer -> filetypes && ! cupsArrayFind ( printer -> filetypes , filetype ) ) { char mimetype [ MIME_MAX_SUPER + MIME_MAX_TYPE + 2 ] ; snprintf ( mimetype , sizeof ( mimetype ) , "%s/%s" , filetype -> super , filetype -> type ) ; send_ipp_status ( con , IPP_DOCUMENT_FORMAT , _ ( "Unsupported<S2SV_blank>format<S2SV_blank>\\"%s\\"." ) , mimetype ) ; ippAddString ( con -> response , IPP_TAG_UNSUPPORTED_GROUP , IPP_TAG_MIMETYPE , "document-format" , NULL , mimetype ) ; return ( NULL ) ; } if ( ( attr = ippFindAttribute ( con -> request , "copies" , IPP_TAG_INTEGER ) ) != NULL ) { if ( attr -> values [ 0 ] . integer < 1 || attr -> values [ 0 ] . integer > MaxCopies ) { send_ipp_status ( con , IPP_ATTRIBUTES , _ ( "Bad<S2SV_blank>copies<S2SV_blank>value<S2SV_blank>%d." ) , attr -> values [ 0 ] . integer ) ; ippAddInteger ( con -> response , IPP_TAG_UNSUPPORTED_GROUP , IPP_TAG_INTEGER , "copies" , attr -> values [ 0 ] . integer ) ; return ( NULL ) ; } } if ( ( attr = ippFindAttribute ( con -> request , "job-sheets" , IPP_TAG_ZERO ) ) != NULL ) { if ( attr -> value_tag != IPP_TAG_KEYWORD && attr -> value_tag != IPP_TAG_NAME ) { send_ipp_status ( con , IPP_BAD_REQUEST , _ ( "Bad<S2SV_blank>job-sheets<S2SV_blank>value<S2SV_blank>type." ) ) ; return ( NULL ) ; } if ( attr -> num_values > 2 ) { send_ipp_status ( con , IPP_BAD_REQUEST , _ ( "Too<S2SV_blank>many<S2SV_blank>job-sheets<S2SV_blank>values<S2SV_blank>(%d<S2SV_blank>><S2SV_blank>2)." ) , attr -> num_values ) ; return ( NULL ) ; } for ( i = 0 ; i < attr -> num_values ; i ++ ) if ( strcmp ( attr -> values [ i ] . string . text , "none" ) && ! cupsdFindBanner ( attr -> values [ i ] . string . text ) ) { send_ipp_status ( con , IPP_BAD_REQUEST , _ ( "Bad<S2SV_blank>job-sheets<S2SV_blank>value<S2SV_blank>\\"%s\\"." ) , attr -> values [ i ] . string . text ) ; return ( NULL ) ; } } if ( ( attr = ippFindAttribute ( con -> request , "number-up" , IPP_TAG_INTEGER ) ) != NULL ) { if ( attr -> values [ 0 ] . integer != 1 && attr -> values [ 0 ] . integer != 2 && attr -> values [ 0 ] . integer != 4 && attr -> values [ 0 ] . integer != 6 && attr -> values [ 0 ] . integer != 9 && attr -> values [ 0 ] . integer != 16 ) { send_ipp_status ( con , IPP_ATTRIBUTES , _ ( "Bad<S2SV_blank>number-up<S2SV_blank>value<S2SV_blank>%d." ) , attr -> values [ 0 ] . integer ) ; ippAddInteger ( con -> response , IPP_TAG_UNSUPPORTED_GROUP , IPP_TAG_INTEGER , "number-up" , attr -> values [ 0 ] . integer ) ; return ( NULL ) ; } } if ( ( attr = ippFindAttribute ( con -> request , "page-ranges" , IPP_TAG_RANGE ) ) != NULL ) { for ( i = 0 , lowerpagerange = 1 ; i < attr -> num_values ; i ++ ) { if ( attr -> values [ i ] . range . lower < lowerpagerange || attr -> values [ i ] . range . lower > attr -> values [ i ] . range . upper ) { send_ipp_status ( con , IPP_BAD_REQUEST , _ ( "Bad<S2SV_blank>page-ranges<S2SV_blank>values<S2SV_blank>%d-%d." ) , attr -> values [ i ] . range . lower , attr -> values [ i ] . range . upper ) ; return ( NULL ) ; } lowerpagerange = attr -> values [ i ] . range . upper + 1 ; } } if ( ! ippFindAttribute ( con -> request , "PageRegion" , IPP_TAG_ZERO ) && ! ippFindAttribute ( con -> request , "PageSize" , IPP_TAG_ZERO ) && _ppdCacheGetPageSize ( printer -> pc , con -> request , NULL , & exact ) ) { if ( ! exact && ( media_col = ippFindAttribute ( con -> request , "media-col" , IPP_TAG_BEGIN_COLLECTION ) ) != NULL ) { send_ipp_status ( con , IPP_OK_SUBST , _ ( "Unsupported<S2SV_blank>margins." ) ) ; unsup_col = ippNew ( ) ; if ( ( media_margin = ippFindAttribute ( media_col -> values [ 0 ] . collection , "media-bottom-margin" , IPP_TAG_INTEGER ) ) != NULL ) ippAddInteger ( unsup_col , IPP_TAG_ZERO , IPP_TAG_INTEGER , "media-bottom-margin" , media_margin -> values [ 0 ] . integer ) ; if ( ( media_margin = ippFindAttribute ( media_col -> values [ 0 ] . collection , "media-left-margin" , IPP_TAG_INTEGER ) ) != NULL ) ippAddInteger ( unsup_col , IPP_TAG_ZERO , IPP_TAG_INTEGER , "media-left-margin" , media_margin -> values [ 0 ] . integer ) ; if ( ( media_margin = ippFindAttribute ( media_col -> values [ 0 ] . collection , "media-right-margin" , IPP_TAG_INTEGER ) ) != NULL ) ippAddInteger ( unsup_col , IPP_TAG_ZERO , IPP_TAG_INTEGER , "media-right-margin" , media_margin -> values [ 0 ] . integer ) ; if ( ( media_margin = ippFindAttribute ( media_col -> values [ 0 ] . collection , "media-top-margin" , IPP_TAG_INTEGER ) ) != NULL ) ippAddInteger ( unsup_col , IPP_TAG_ZERO , IPP_TAG_INTEGER , "media-top-margin" , media_margin -> values [ 0 ] . integer ) ; ippAddCollection ( con -> response , IPP_TAG_UNSUPPORTED_GROUP , "media-col" , unsup_col ) ; ippDelete ( unsup_col ) ; } } if ( MaxJobs && cupsArrayCount ( Jobs ) >= MaxJobs ) cupsdCleanJobs ( ) ; if ( MaxJobs && cupsArrayCount ( Jobs ) >= MaxJobs ) { send_ipp_status ( con , IPP_NOT_POSSIBLE , _ ( "Too<S2SV_blank>many<S2SV_blank>active<S2SV_blank>jobs." ) ) ; return ( NULL ) ; } if ( ( i = check_quotas ( con , printer ) ) < 0 ) { send_ipp_status ( con , IPP_NOT_POSSIBLE , _ ( "Quota<S2SV_blank>limit<S2SV_blank>reached." ) ) ; return ( NULL ) ; } else if ( i == 0 ) { send_ipp_status ( con , IPP_NOT_AUTHORIZED , _ ( "Not<S2SV_blank>allowed<S2SV_blank>to<S2SV_blank>print." ) ) ; return ( NULL ) ; } if ( ( attr = ippFindAttribute ( con -> request , "job-priority" , IPP_TAG_INTEGER ) ) != NULL ) priority = attr -> values [ 0 ] . integer ; else { if ( ( val = cupsGetOption ( "job-priority" , printer -> num_options , printer -> options ) ) != NULL ) priority = atoi ( val ) ; else priority = 50 ; ippAddInteger ( con -> request , IPP_TAG_JOB , IPP_TAG_INTEGER , "job-priority" , priority ) ; } if ( ( attr = ippFindAttribute ( con -> request , "job-name" , IPP_TAG_ZERO ) ) == NULL ) ippAddString ( con -> request , IPP_TAG_JOB , IPP_TAG_NAME , "job-name" , NULL , "Untitled" ) ; else if ( ( attr -> value_tag != IPP_TAG_NAME && attr -> value_tag != IPP_TAG_NAMELANG ) || attr -> num_values != 1 ) { send_ipp_status ( con , IPP_ATTRIBUTES , _ ( "Bad<S2SV_blank>job-name<S2SV_blank>value:<S2SV_blank>Wrong<S2SV_blank>type<S2SV_blank>or<S2SV_blank>count." ) ) ; if ( ( attr = ippCopyAttribute ( con -> response , attr , 0 ) ) != NULL ) attr -> group_tag = IPP_TAG_UNSUPPORTED_GROUP ; return ( NULL ) ; } else if ( ! ippValidateAttribute ( attr ) ) { send_ipp_status ( con , IPP_ATTRIBUTES , _ ( "Bad<S2SV_blank>job-name<S2SV_blank>value:<S2SV_blank>%s" ) , cupsLastErrorString ( ) ) ; if ( ( attr = ippCopyAttribute ( con -> response , attr , 0 ) ) != NULL ) attr -> group_tag = IPP_TAG_UNSUPPORTED_GROUP ; return ( NULL ) ; } <S2SV_StartBug> if ( ( job = cupsdAddJob ( priority , printer -> name ) ) == NULL ) <S2SV_EndBug> { send_ipp_status ( con , IPP_INTERNAL_ERROR , _ ( "Unable<S2SV_blank>to<S2SV_blank>add<S2SV_blank>job<S2SV_blank>for<S2SV_blank>destination<S2SV_blank>\\"%s\\"." ) , printer -> name ) ; return ( NULL ) ; } job -> dtype = printer -> type & ( CUPS_PRINTER_CLASS | CUPS_PRINTER_REMOTE ) ; job -> attrs = con -> request ; job -> dirty = 1 ; con -> request = ippNewRequest ( job -> attrs -> request . op . operation_id ) ; cupsdMarkDirty ( CUPSD_DIRTY_JOBS ) ; add_job_uuid ( job ) ; <S2SV_StartBug> apply_printer_defaults ( printer , job ) ; <S2SV_EndBug> attr = ippFindAttribute ( job -> attrs , "requesting-user-name" , IPP_TAG_NAME ) ; if ( con -> username [ 0 ] ) { cupsdSetString ( & job -> username , con -> username ) ; if ( attr ) ippSetString ( job -> attrs , & attr , 0 , con -> username ) ; } else if ( attr ) { cupsdLogMessage ( CUPSD_LOG_DEBUG , "add_job:<S2SV_blank>requesting-user-name=\\"%s\\"" , attr -> values [ 0 ] . string . text ) ; cupsdSetString ( & job -> username , attr -> values [ 0 ] . string . text ) ; } else cupsdSetString ( & job -> username , "anonymous" ) ; if ( ! attr ) ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_NAME , "job-originating-user-name" , NULL , job -> username ) ; else { ippSetGroupTag ( job -> attrs , & attr , IPP_TAG_JOB ) ; ippSetName ( job -> attrs , & attr , "job-originating-user-name" ) ; } if ( con -> username [ 0 ] || auth_info ) { save_auth_info ( con , job , auth_info ) ; if ( auth_info ) ippDeleteAttribute ( job -> attrs , auth_info ) ; } if ( ( attr = ippFindAttribute ( con -> request , "job-name" , IPP_TAG_NAME ) ) != NULL ) cupsdSetString ( & ( job -> name ) , attr -> values [ 0 ] . string . text ) ; if ( ( attr = ippFindAttribute ( job -> attrs , "job-originating-host-name" , IPP_TAG_ZERO ) ) != NULL ) { if ( attr -> value_tag != IPP_TAG_NAME || attr -> num_values != 1 || strcmp ( con -> http -> hostname , "localhost" ) ) { ippDeleteAttribute ( job -> attrs , attr ) ; ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_NAME , "job-originating-host-name" , NULL , con -> http -> hostname ) ; } else ippSetGroupTag ( job -> attrs , & attr , IPP_TAG_JOB ) ; } else { ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_NAME , "job-originating-host-name" , NULL , con -> http -> hostname ) ; } ippAddOutOfBand ( job -> attrs , IPP_TAG_JOB , IPP_TAG_NOVALUE , "date-time-at-completed" ) ; ippAddDate ( job -> attrs , IPP_TAG_JOB , "date-time-at-creation" , ippTimeToDate ( time ( NULL ) ) ) ; ippAddOutOfBand ( job -> attrs , IPP_TAG_JOB , IPP_TAG_NOVALUE , "date-time-at-processing" ) ; ippAddOutOfBand ( job -> attrs , IPP_TAG_JOB , IPP_TAG_NOVALUE , "time-at-completed" ) ; ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "time-at-creation" , time ( NULL ) ) ; ippAddOutOfBand ( job -> attrs , IPP_TAG_JOB , IPP_TAG_NOVALUE , "time-at-processing" ) ; ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "job-id" , job -> id ) ; job -> state = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_ENUM , "job-state" , IPP_JOB_STOPPED ) ; job -> state_value = ( ipp_jstate_t ) job -> state -> values [ 0 ] . integer ; job -> reasons = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , "job-state-reasons" , NULL , "job-incoming" ) ; job -> impressions = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "job-impressions-completed" , 0 ) ; job -> sheets = ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "job-media-sheets-completed" , 0 ) ; ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_URI , "job-printer-uri" , NULL , printer -> uri ) ; if ( ( attr = ippFindAttribute ( job -> attrs , "job-k-octets" , IPP_TAG_INTEGER ) ) != NULL ) attr -> values [ 0 ] . integer = 0 ; else ippAddInteger ( job -> attrs , IPP_TAG_JOB , IPP_TAG_INTEGER , "job-k-octets" , 0 ) ; if ( ( attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_KEYWORD ) ) == NULL ) attr = ippFindAttribute ( job -> attrs , "job-hold-until" , IPP_TAG_NAME ) ; if ( ! attr ) { if ( ( val = cupsGetOption ( "job-hold-until" , printer -> num_options , printer -> options ) ) == NULL ) val = "no-hold" ; attr = ippAddString ( job -> attrs , IPP_TAG_JOB , IPP_TAG_KEYWORD , "job-hold-until" , NULL , val ) ; } if ( printer -> holding_new_jobs ) { if ( attr && strcmp ( attr -> values [ 0 ] . string . text , "no-hold" ) ) cupsdSetJobHoldUntil ( job , ippGetString ( attr , 0 , NULL ) , 0 ) ; else cupsdSetJobHoldUntil ( job , "indefinite" , 0 ) ; job -> state -> values [ 0 ] . integer = IPP_JOB_HELD ; job -> state_value = IPP_JOB_HELD ; ippSetString ( job -> attrs , & job -> reasons , 0 , "job-held-on-create" ) ; } else if ( attr && strcmp ( attr -> values [ 0 ] . string . text , "no-hold" ) ) { cupsdSetJobHoldUntil ( job , attr -> values [ 0 ] . string . text , 0 ) ; job -> state -> values [ 0 ] . integer = IPP_JOB_HELD ; job -> state_value = IPP_JOB_HELD ; ippSetString ( job -> attrs , & job -> reasons , 0 , "job-hold-until-specified" ) ; } else if ( job -> attrs -> request . op . operation_id == IPP_CREATE_JOB ) { job -> hold_until = time ( NULL ) + MultipleOperationTimeout ; job -> state -> values [ 0 ] . integer = IPP_JOB_HELD ; job -> state_value = IPP_JOB_HELD ; } else { job -> state -> values [ 0 ] . integer = IPP_JOB_PENDING ; job -> state_value = IPP_JOB_PENDING ; ippSetString ( job -> attrs , & job -> reasons , 0 , "none" ) ; } if ( ! ( printer -> type & CUPS_PRINTER_REMOTE ) || Classification ) { if ( ( attr = ippFindAttribute ( job -> attrs , "job-sheets" , IPP_TAG_ZERO ) ) == NULL ) { cupsdLogMessage ( CUPSD_LOG_DEBUG , "Adding<S2SV_blank>default<S2SV_blank>job-sheets<S2SV_blank>values<S2SV_blank>\\"%s,%s\\"..." , printer -> job_sheets [ 0 ] , printer -> job_sheets [ 1 ] ) ; attr = ippAddStrings ( job -> attrs , IPP_TAG_JOB , IPP_TAG_NAME , "job-sheets" , 2 , NULL , NULL ) ; ippSetString ( job -> attrs , & attr , 0 , printer -> job_sheets [ 0 ] ) ; ippSetString ( job -> attrs , & attr , 1 , printer -> job_sheets [ 1 ] ) ; } job -> job_sheets = attr ; if ( Classification ) { cupsdLogMessage ( CUPSD_LOG_INFO , "Classification=\\"%s\\",<S2SV_blank>ClassifyOverride=%d" , Classification ? Classification : "(null)" , ClassifyOverride ) ; if ( ClassifyOverride ) { if ( ! strcmp ( attr -> values [ 0 ] . string . text , "none" ) && ( attr -> num_values == 1 || ! strcmp ( attr -> values [ 1 ] . string . text , "none" ) ) ) { ippSetString ( job -> attrs , & attr , 0 , Classification ) ; cupsdLogJob ( job , CUPSD_LOG_NOTICE , "CLASSIFICATION<S2SV_blank>FORCED<S2SV_blank>" "job-sheets=\\"%s,none\\",<S2SV_blank>" "job-originating-user-name=\\"%s\\"" , Classification , job -> username ) ; } else if ( attr -> num_values == 2 && strcmp ( attr -> values [ 0 ] . string . text , attr -> values [ 1 ] . string . text ) && strcmp ( attr -> values [ 0 ] . string . text , "none" ) && strcmp ( attr -> values [ 1 ] . string . text , "none" ) ) { ippSetString ( job -> attrs , & attr , 1 , attr -> values [ 0 ] . string . text ) ; cupsdLogJob ( job , CUPSD_LOG_NOTICE , "CLASSIFICATION<S2SV_blank>FORCED<S2SV_blank>" "job-sheets=\\"%s,%s\\",<S2SV_blank>" "job-originating-user-name=\\"%s\\"" , attr -> values [ 0 ] . string . text , attr -> values [ 1 ] . string . text , job -> username ) ; } else if ( strcmp ( attr -> values [ 0 ] . string . text , Classification ) && strcmp ( attr -> values [ 0 ] . string . text , "none" ) && ( attr -> num_values == 1 || ( strcmp ( attr -> values [ 1 ] . string . text , Classification ) && strcmp ( attr -> values [ 1 ] . string . text , "none" ) ) ) ) { if ( attr -> num_values == 1 ) cupsdLogJob ( job , CUPSD_LOG_NOTICE , "CLASSIFICATION<S2SV_blank>OVERRIDDEN<S2SV_blank>" "job-sheets=\\"%s\\",<S2SV_blank>" "job-originating-user-name=\\"%s\\"" , attr -> values [ 0 ] . string . text , job -> username ) ; else cupsdLogJob ( job , CUPSD_LOG_NOTICE , "CLASSIFICATION<S2SV_blank>OVERRIDDEN<S2SV_blank>" "job-sheets=\\"%s,%s\\",fffff<S2SV_blank>" "job-originating-user-name=\\"%s\\"" , attr -> values [ 0 ] . string . text , attr -> values [ 1 ] . string . text , job -> username ) ; } } else if ( strcmp ( attr -> values [ 0 ] . string . text , Classification ) && ( attr -> num_values == 1 || strcmp ( attr -> values [ 1 ] . string . text , Classification ) ) ) { if ( attr -> num_values > 1 && ! strcmp ( attr -> values [ 0 ] . string . text , attr -> values [ 1 ] . string . text ) ) { ippSetString ( job -> attrs , & attr , 0 , Classification ) ; ippSetString ( job -> attrs , & attr , 1 , Classification ) ; } else { if ( attr -> num_values == 1 || strcmp ( attr -> values [ 0 ] . string . text , "none" ) ) ippSetString ( job -> attrs , & attr , 0 , Classification ) ; if ( attr -> num_values > 1 && strcmp ( attr -> values [ 1 ] . string . text , "none" ) ) ippSetString ( job -> attrs , & attr , 1 , Classification ) ; } if ( attr -> num_values > 1 ) cupsdLogJob ( job , CUPSD_LOG_NOTICE , "CLASSIFICATION<S2SV_blank>FORCED<S2SV_blank>" "job-sheets=\\"%s,%s\\",<S2SV_blank>" "job-originating-user-name=\\"%s\\"" , attr -> values [ 0 ] . string . text , attr -> values [ 1 ] . string . text , job -> username ) ; else cupsdLogJob ( job , CUPSD_LOG_NOTICE , "CLASSIFICATION<S2SV_blank>FORCED<S2SV_blank>" "job-sheets=\\"%s\\",<S2SV_blank>" "job-originating-user-name=\\"%s\\"" , Classification , job -> username ) ; } } if ( ! ( printer -> type & CUPS_PRINTER_REMOTE ) ) { cupsdLogJob ( job , CUPSD_LOG_INFO , "Adding<S2SV_blank>start<S2SV_blank>banner<S2SV_blank>page<S2SV_blank>\\"%s\\"." , attr -> values [ 0 ] . string . text ) ; if ( ( kbytes = copy_banner ( con , job , attr -> values [ 0 ] . string . text ) ) < 0 ) { cupsdSetJobState ( job , IPP_JOB_ABORTED , CUPSD_JOB_PURGE , "Aborting<S2SV_blank>job<S2SV_blank>because<S2SV_blank>the<S2SV_blank>start<S2SV_blank>banner<S2SV_blank>could<S2SV_blank>not<S2SV_blank>be<S2SV_blank>" "copied." ) ; return ( NULL ) ; } cupsdUpdateQuota ( printer , job -> username , 0 , kbytes ) ; } } else if ( ( attr = ippFindAttribute ( job -> attrs , "job-sheets" , IPP_TAG_ZERO ) ) != NULL ) job -> job_sheets = attr ; httpAssembleURIf ( HTTP_URI_CODING_ALL , job_uri , sizeof ( job_uri ) , "ipp" , NULL , con -> clientname , con -> clientport , "/jobs/%d" , job -> id ) ; ippAddString ( con -> response , IPP_TAG_JOB , IPP_TAG_URI , "job-uri" , NULL , job_uri ) ; ippAddInteger ( con -> response , IPP_TAG_JOB , IPP_TAG_INTEGER , "job-id" , job -> id ) ; ippAddInteger ( con -> response , IPP_TAG_JOB , IPP_TAG_ENUM , "job-state" , job -> state_value ) ; ippAddString ( con -> response , IPP_TAG_JOB , IPP_TAG_TEXT , "job-state-message" , NULL , "" ) ; ippAddString ( con -> response , IPP_TAG_JOB , IPP_TAG_KEYWORD , "job-state-reasons" , NULL , job -> reasons -> values [ 0 ] . string . text ) ; con -> response -> request . status . status_code = IPP_OK ; add_job_subscriptions ( con , job ) ; for ( attr = job -> attrs -> attrs -> next -> next ; attr ; attr = attr -> next ) attr -> group_tag = IPP_TAG_JOB ; cupsdAddEvent ( CUPSD_EVENT_JOB_CREATED , printer , job , "Job<S2SV_blank>created." ) ; return ( job ) ; }
CWE-290 static int valid_host ( cupsd_client_t * con ) { cupsd_alias_t * a ; cupsd_netif_t * netif ; const char * end ; char * ptr ; strlcpy ( con -> clientname , httpGetField ( con -> http , HTTP_FIELD_HOST ) , sizeof ( con -> clientname ) ) ; if ( ( ptr = strrchr ( con -> clientname , ':' ) ) != NULL && ! strchr ( ptr , ']' ) ) { * ptr ++ = '\\0' ; con -> clientport = atoi ( ptr ) ; } else con -> clientport = con -> serverport ; if ( httpAddrLocalhost ( httpGetAddress ( con -> http ) ) ) { return ( ! _cups_strcasecmp ( con -> clientname , "localhost" ) || ! _cups_strcasecmp ( con -> clientname , "localhost." ) || <S2SV_StartBug> # ifdef __linux <S2SV_EndBug> ! _cups_strcasecmp ( con -> clientname , "localhost.localdomain" ) || # endif ! strcmp ( con -> clientname , "127.0.0.1" ) || ! strcmp ( con -> clientname , "[::1]" ) ) ; } # if defined ( HAVE_DNSSD ) || defined ( HAVE_AVAHI ) if ( ( end = strrchr ( con -> clientname , '.' ) ) != NULL && end > con -> clientname && ! end [ 1 ] ) { for ( end -- ; end > con -> clientname && * end != '.' ; end -- ) ; } if ( end && ( ! _cups_strcasecmp ( end , ".local" ) || ! _cups_strcasecmp ( end , ".local." ) ) ) return ( 1 ) ; # endif if ( isdigit ( con -> clientname [ 0 ] & 255 ) || con -> clientname [ 0 ] == '[' ) { http_addrlist_t * addrlist ; if ( ( addrlist = httpAddrGetList ( con -> clientname , AF_UNSPEC , NULL ) ) != NULL ) { httpAddrFreeList ( addrlist ) ; return ( 1 ) ; } } for ( a = ( cupsd_alias_t * ) cupsArrayFirst ( ServerAlias ) ; a ; a = ( cupsd_alias_t * ) cupsArrayNext ( ServerAlias ) ) { if ( ! strcmp ( a -> name , "*" ) ) return ( 1 ) ; if ( ! _cups_strncasecmp ( con -> clientname , a -> name , a -> namelen ) ) { end = con -> clientname + a -> namelen ; if ( ! * end || ( * end == '.' && ! end [ 1 ] ) ) return ( 1 ) ; } } # if defined ( HAVE_DNSSD ) || defined ( HAVE_AVAHI ) for ( a = ( cupsd_alias_t * ) cupsArrayFirst ( DNSSDAlias ) ; a ; a = ( cupsd_alias_t * ) cupsArrayNext ( DNSSDAlias ) ) { if ( ! strcmp ( a -> name , "*" ) ) return ( 1 ) ; if ( ! _cups_strncasecmp ( con -> clientname , a -> name , a -> namelen ) ) { end = con -> clientname + a -> namelen ; if ( ! * end || ( * end == '.' && ! end [ 1 ] ) ) return ( 1 ) ; } } # endif for ( netif = ( cupsd_netif_t * ) cupsArrayFirst ( NetIFList ) ; netif ; netif = ( cupsd_netif_t * ) cupsArrayNext ( NetIFList ) ) { if ( ! _cups_strncasecmp ( con -> clientname , netif -> hostname , netif -> hostlen ) ) { end = con -> clientname + netif -> hostlen ; if ( ! * end || ( * end == '.' && ! end [ 1 ] ) ) return ( 1 ) ; } } return ( 0 ) ; }
CWE-400 static void Rp_test ( js_State * J ) { js_Regexp * re ; const char * text ; <S2SV_StartBug> int opts ; <S2SV_EndBug> Resub m ; re = js_toregexp ( J , 0 ) ; text = js_tostring ( J , 1 ) ; opts = 0 ; if ( re -> flags & JS_REGEXP_G ) { if ( re -> last > strlen ( text ) ) { re -> last = 0 ; js_pushboolean ( J , 0 ) ; return ; } if ( re -> last > 0 ) { text += re -> last ; opts |= REG_NOTBOL ; } } <S2SV_StartBug> if ( ! js_regexec ( re -> prog , text , & m , opts ) ) { <S2SV_EndBug> if ( re -> flags & JS_REGEXP_G ) re -> last = re -> last + ( m . sub [ 0 ] . ep - text ) ; js_pushboolean ( J , 1 ) ; return ; } if ( re -> flags & JS_REGEXP_G ) re -> last = 0 ; js_pushboolean ( J , 0 ) ; }
CWE-400 void js_RegExp_prototype_exec ( js_State * J , js_Regexp * re , const char * text ) { <S2SV_StartBug> int i ; <S2SV_EndBug> int opts ; Resub m ; opts = 0 ; if ( re -> flags & JS_REGEXP_G ) { if ( re -> last > strlen ( text ) ) { re -> last = 0 ; js_pushnull ( J ) ; return ; } if ( re -> last > 0 ) { text += re -> last ; opts |= REG_NOTBOL ; } } <S2SV_StartBug> if ( ! js_regexec ( re -> prog , text , & m , opts ) ) { <S2SV_EndBug> js_newarray ( J ) ; js_pushstring ( J , text ) ; js_setproperty ( J , - 2 , "input" ) ; js_pushnumber ( J , js_utfptrtoidx ( text , m . sub [ 0 ] . sp ) ) ; js_setproperty ( J , - 2 , "index" ) ; for ( i = 0 ; i < m . nsub ; ++ i ) { js_pushlstring ( J , m . sub [ i ] . sp , m . sub [ i ] . ep - m . sub [ i ] . sp ) ; js_setindex ( J , - 2 , i ) ; } if ( re -> flags & JS_REGEXP_G ) re -> last = re -> last + ( m . sub [ 0 ] . ep - text ) ; return ; } if ( re -> flags & JS_REGEXP_G ) re -> last = 0 ; js_pushnull ( J ) ; }
CWE-400 static void Sp_match ( js_State * J ) { js_Regexp * re ; const char * text ; int len ; const char * a , * b , * c , * e ; Resub m ; text = checkstring ( J , 0 ) ; if ( js_isregexp ( J , 1 ) ) js_copy ( J , 1 ) ; else if ( js_isundefined ( J , 1 ) ) js_newregexp ( J , "" , 0 ) ; else js_newregexp ( J , js_tostring ( J , 1 ) , 0 ) ; re = js_toregexp ( J , - 1 ) ; if ( ! ( re -> flags & JS_REGEXP_G ) ) { js_RegExp_prototype_exec ( J , re , text ) ; return ; } re -> last = 0 ; js_newarray ( J ) ; len = 0 ; a = text ; e = text + strlen ( text ) ; while ( a <= e ) { <S2SV_StartBug> if ( js_regexec ( re -> prog , a , & m , a > text ? REG_NOTBOL : 0 ) ) <S2SV_EndBug> break ; b = m . sub [ 0 ] . sp ; c = m . sub [ 0 ] . ep ; js_pushlstring ( J , b , c - b ) ; js_setindex ( J , - 2 , len ++ ) ; a = c ; if ( c - b == 0 ) ++ a ; } if ( len == 0 ) { js_pop ( J , 1 ) ; js_pushnull ( J ) ; } }
CWE-400 static void Sp_replace_regexp ( js_State * J ) { js_Regexp * re ; const char * source , * s , * r ; js_Buffer * sb = NULL ; int n , x ; Resub m ; source = checkstring ( J , 0 ) ; re = js_toregexp ( J , 1 ) ; <S2SV_StartBug> if ( js_regexec ( re -> prog , source , & m , 0 ) ) { <S2SV_EndBug> js_copy ( J , 0 ) ; return ; } re -> last = 0 ; loop : s = m . sub [ 0 ] . sp ; n = m . sub [ 0 ] . ep - m . sub [ 0 ] . sp ; if ( js_iscallable ( J , 2 ) ) { js_copy ( J , 2 ) ; js_pushundefined ( J ) ; for ( x = 0 ; m . sub [ x ] . sp ; ++ x ) js_pushlstring ( J , m . sub [ x ] . sp , m . sub [ x ] . ep - m . sub [ x ] . sp ) ; js_pushnumber ( J , s - source ) ; js_copy ( J , 0 ) ; js_call ( J , 2 + x ) ; r = js_tostring ( J , - 1 ) ; js_putm ( J , & sb , source , s ) ; js_puts ( J , & sb , r ) ; js_pop ( J , 1 ) ; } else { r = js_tostring ( J , 2 ) ; js_putm ( J , & sb , source , s ) ; while ( * r ) { if ( * r == '$' ) { switch ( * ( ++ r ) ) { case 0 : -- r ; case '$' : js_putc ( J , & sb , '$' ) ; break ; case '`' : js_putm ( J , & sb , source , s ) ; break ; case '\\'' : js_puts ( J , & sb , s + n ) ; break ; case '&' : js_putm ( J , & sb , s , s + n ) ; break ; case '0' : case '1' : case '2' : case '3' : case '4' : case '5' : case '6' : case '7' : case '8' : case '9' : x = * r - '0' ; if ( r [ 1 ] >= '0' && r [ 1 ] <= '9' ) x = x * 10 + * ( ++ r ) - '0' ; if ( x > 0 && x < m . nsub ) { js_putm ( J , & sb , m . sub [ x ] . sp , m . sub [ x ] . ep ) ; } else { js_putc ( J , & sb , '$' ) ; if ( x > 10 ) { js_putc ( J , & sb , '0' + x / 10 ) ; js_putc ( J , & sb , '0' + x % 10 ) ; } else { js_putc ( J , & sb , '0' + x ) ; } } break ; default : js_putc ( J , & sb , '$' ) ; js_putc ( J , & sb , * r ) ; break ; } ++ r ; } else { js_putc ( J , & sb , * r ++ ) ; } } } if ( re -> flags & JS_REGEXP_G ) { source = m . sub [ 0 ] . ep ; if ( n == 0 ) { if ( * source ) js_putc ( J , & sb , * source ++ ) ; else goto end ; } <S2SV_StartBug> if ( ! js_regexec ( re -> prog , source , & m , REG_NOTBOL ) ) <S2SV_EndBug> goto loop ; } end : js_puts ( J , & sb , s + n ) ; js_putc ( J , & sb , 0 ) ; if ( js_try ( J ) ) { js_free ( J , sb ) ; js_throw ( J ) ; } js_pushstring ( J , sb ? sb -> s : "" ) ; js_endtry ( J ) ; js_free ( J , sb ) ; }
CWE-400 static void Sp_search ( js_State * J ) { js_Regexp * re ; const char * text ; Resub m ; text = checkstring ( J , 0 ) ; if ( js_isregexp ( J , 1 ) ) js_copy ( J , 1 ) ; else if ( js_isundefined ( J , 1 ) ) js_newregexp ( J , "" , 0 ) ; else js_newregexp ( J , js_tostring ( J , 1 ) , 0 ) ; re = js_toregexp ( J , - 1 ) ; <S2SV_StartBug> if ( ! js_regexec ( re -> prog , text , & m , 0 ) ) <S2SV_EndBug> js_pushnumber ( J , js_utfptrtoidx ( text , m . sub [ 0 ] . sp ) ) ; else js_pushnumber ( J , - 1 ) ; }
CWE-400 static void Sp_split_regexp ( js_State * J ) { js_Regexp * re ; const char * text ; int limit , len , k ; const char * p , * a , * b , * c , * e ; Resub m ; text = checkstring ( J , 0 ) ; re = js_toregexp ( J , 1 ) ; limit = js_isdefined ( J , 2 ) ? js_tointeger ( J , 2 ) : 1 << 30 ; js_newarray ( J ) ; len = 0 ; e = text + strlen ( text ) ; if ( e == text ) { <S2SV_StartBug> if ( js_regexec ( re -> prog , text , & m , 0 ) ) { <S2SV_EndBug> if ( len == limit ) return ; js_pushliteral ( J , "" ) ; js_setindex ( J , - 2 , 0 ) ; } return ; } p = a = text ; while ( a < e ) { <S2SV_StartBug> if ( js_regexec ( re -> prog , a , & m , a > text ? REG_NOTBOL : 0 ) ) <S2SV_EndBug> break ; b = m . sub [ 0 ] . sp ; c = m . sub [ 0 ] . ep ; if ( b == p ) { ++ a ; continue ; } if ( len == limit ) return ; js_pushlstring ( J , p , b - p ) ; js_setindex ( J , - 2 , len ++ ) ; for ( k = 1 ; k < m . nsub ; ++ k ) { if ( len == limit ) return ; js_pushlstring ( J , m . sub [ k ] . sp , m . sub [ k ] . ep - m . sub [ k ] . sp ) ; js_setindex ( J , - 2 , len ++ ) ; } a = p = c ; } if ( len == limit ) return ; js_pushstring ( J , p ) ; js_setindex ( J , - 2 , len ) ; }
CWE-400 <S2SV_StartBug> static int match ( Reinst * pc , const char * sp , const char * bol , int flags , Resub * out ) <S2SV_EndBug> { Resub scratch ; <S2SV_StartBug> int i ; <S2SV_EndBug> Rune c ; <S2SV_StartBug> for ( ; ; ) { <S2SV_EndBug> switch ( pc -> opcode ) { case I_END : <S2SV_StartBug> return 1 ; <S2SV_EndBug> case I_JUMP : pc = pc -> x ; break ; case I_SPLIT : scratch = * out ; <S2SV_StartBug> if ( match ( pc -> x , sp , bol , flags , & scratch ) ) { <S2SV_EndBug> * out = scratch ; <S2SV_StartBug> return 1 ; <S2SV_EndBug> } pc = pc -> y ; break ; case I_PLA : <S2SV_StartBug> if ( ! match ( pc -> x , sp , bol , flags , out ) ) <S2SV_EndBug> return 0 ; pc = pc -> y ; break ; case I_NLA : scratch = * out ; <S2SV_StartBug> if ( match ( pc -> x , sp , bol , flags , & scratch ) ) <S2SV_EndBug> return 0 ; pc = pc -> y ; break ; case I_ANYNL : sp += chartorune ( & c , sp ) ; if ( c == 0 ) <S2SV_StartBug> return 0 ; <S2SV_EndBug> pc = pc + 1 ; break ; case I_ANY : sp += chartorune ( & c , sp ) ; if ( c == 0 ) <S2SV_StartBug> return 0 ; <S2SV_EndBug> if ( isnewline ( c ) ) <S2SV_StartBug> return 0 ; <S2SV_EndBug> pc = pc + 1 ; break ; case I_CHAR : sp += chartorune ( & c , sp ) ; if ( c == 0 ) <S2SV_StartBug> return 0 ; <S2SV_EndBug> if ( flags & REG_ICASE ) c = canon ( c ) ; if ( c != pc -> c ) <S2SV_StartBug> return 0 ; <S2SV_EndBug> pc = pc + 1 ; break ; case I_CCLASS : sp += chartorune ( & c , sp ) ; if ( c == 0 ) <S2SV_StartBug> return 0 ; <S2SV_EndBug> if ( flags & REG_ICASE ) { if ( ! incclasscanon ( pc -> cc , canon ( c ) ) ) <S2SV_StartBug> return 0 ; <S2SV_EndBug> } else { if ( ! incclass ( pc -> cc , c ) ) <S2SV_StartBug> return 0 ; <S2SV_EndBug> } pc = pc + 1 ; break ; case I_NCCLASS : sp += chartorune ( & c , sp ) ; if ( c == 0 ) <S2SV_StartBug> return 0 ; <S2SV_EndBug> if ( flags & REG_ICASE ) { if ( incclasscanon ( pc -> cc , canon ( c ) ) ) <S2SV_StartBug> return 0 ; <S2SV_EndBug> } else { if ( incclass ( pc -> cc , c ) ) <S2SV_StartBug> return 0 ; <S2SV_EndBug> } pc = pc + 1 ; break ; case I_REF : i = out -> sub [ pc -> n ] . ep - out -> sub [ pc -> n ] . sp ; if ( flags & REG_ICASE ) { if ( strncmpcanon ( sp , out -> sub [ pc -> n ] . sp , i ) ) <S2SV_StartBug> return 0 ; <S2SV_EndBug> } else { if ( strncmp ( sp , out -> sub [ pc -> n ] . sp , i ) ) <S2SV_StartBug> return 0 ; <S2SV_EndBug> } if ( i > 0 ) sp += i ; pc = pc + 1 ; break ; case I_BOL : if ( sp == bol && ! ( flags & REG_NOTBOL ) ) { pc = pc + 1 ; break ; } if ( flags & REG_NEWLINE ) { if ( sp > bol && isnewline ( sp [ - 1 ] ) ) { pc = pc + 1 ; break ; } } <S2SV_StartBug> return 0 ; <S2SV_EndBug> case I_EOL : if ( * sp == 0 ) { pc = pc + 1 ; break ; } if ( flags & REG_NEWLINE ) { if ( isnewline ( * sp ) ) { pc = pc + 1 ; break ; } } <S2SV_StartBug> return 0 ; <S2SV_EndBug> case I_WORD : i = sp > bol && iswordchar ( sp [ - 1 ] ) ; i ^= iswordchar ( sp [ 0 ] ) ; if ( ! i ) <S2SV_StartBug> return 0 ; <S2SV_EndBug> pc = pc + 1 ; break ; case I_NWORD : i = sp > bol && iswordchar ( sp [ - 1 ] ) ; i ^= iswordchar ( sp [ 0 ] ) ; if ( i ) <S2SV_StartBug> return 0 ; <S2SV_EndBug> pc = pc + 1 ; break ; case I_LPAR : out -> sub [ pc -> n ] . sp = sp ; pc = pc + 1 ; break ; case I_RPAR : out -> sub [ pc -> n ] . ep = sp ; pc = pc + 1 ; break ; default : <S2SV_StartBug> return 0 ; <S2SV_EndBug> } } }
CWE-400 int regexec ( Reprog * prog , const char * sp , Resub * sub , int eflags ) { Resub scratch ; int i ; if ( ! sub ) sub = & scratch ; sub -> nsub = prog -> nsub ; for ( i = 0 ; i < MAXSUB ; ++ i ) sub -> sub [ i ] . sp = sub -> sub [ i ] . ep = NULL ; <S2SV_StartBug> return ! match ( prog -> start , sp , sp , prog -> flags | eflags , sub ) ; <S2SV_EndBug> }
CWE-119 static void ctrycatchfinally ( JF , js_Ast * trystm , js_Ast * catchvar , js_Ast * catchstm , js_Ast * finallystm ) { int L1 , L2 , L3 ; L1 = emitjump ( J , F , OP_TRY ) ; { L2 = emitjump ( J , F , OP_TRY ) ; { cstm ( J , F , finallystm ) ; emit ( J , F , OP_THROW ) ; } label ( J , F , L2 ) ; if ( F -> strict ) { checkfutureword ( J , F , catchvar ) ; if ( ! strcmp ( catchvar -> string , "arguments" ) ) jsC_error ( J , catchvar , "redefining<S2SV_blank>\'arguments\'<S2SV_blank>is<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>in<S2SV_blank>strict<S2SV_blank>mode" ) ; if ( ! strcmp ( catchvar -> string , "eval" ) ) jsC_error ( J , catchvar , "redefining<S2SV_blank>\'eval\'<S2SV_blank>is<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>in<S2SV_blank>strict<S2SV_blank>mode" ) ; } emitline ( J , F , catchvar ) ; emitstring ( J , F , OP_CATCH , catchvar -> string ) ; cstm ( J , F , catchstm ) ; emit ( J , F , OP_ENDCATCH ) ; <S2SV_StartBug> L3 = emitjump ( J , F , OP_JUMP ) ; <S2SV_EndBug> } label ( J , F , L1 ) ; cstm ( J , F , trystm ) ; emit ( J , F , OP_ENDTRY ) ; label ( J , F , L3 ) ; cstm ( J , F , finallystm ) ; }
CWE-119 static void Np_toString ( js_State * J ) { <S2SV_StartBug> char buf [ 32 ] ; <S2SV_EndBug> js_Object * self = js_toobject ( J , 0 ) ; int radix = js_isundefined ( J , 1 ) ? 10 : js_tointeger ( J , 1 ) ; if ( self -> type != JS_CNUMBER ) js_typeerror ( J , "not<S2SV_blank>a<S2SV_blank>number" ) ; if ( radix == 10 ) { js_pushstring ( J , jsV_numbertostring ( J , buf , self -> u . number ) ) ; return ; } if ( radix < 2 || radix > 36 ) js_rangeerror ( J , "invalid<S2SV_blank>radix" ) ; { static const char digits [ ] = "0123456789abcdefghijklmnopqrstuvwxyz" ; <S2SV_StartBug> char buf [ 100 ] ; <S2SV_EndBug> double number = self -> u . number ; int sign = self -> u . number < 0 ; js_Buffer * sb = NULL ; uint64_t u , limit = ( ( uint64_t ) 1 << 52 ) ; int ndigits , exp , point ; if ( number == 0 ) { js_pushstring ( J , "0" ) ; return ; } if ( isnan ( number ) ) { js_pushstring ( J , "NaN" ) ; return ; } if ( isinf ( number ) ) { js_pushstring ( J , sign ? "-Infinity" : "Infinity" ) ; return ; } if ( sign ) number = - number ; exp = 0 ; while ( number * pow ( radix , exp ) > limit ) -- exp ; while ( number * pow ( radix , exp + 1 ) < limit ) ++ exp ; u = number * pow ( radix , exp ) + 0.5 ; while ( u > 0 && ( u % radix ) == 0 ) { u /= radix ; -- exp ; } ndigits = 0 ; while ( u > 0 ) { buf [ ndigits ++ ] = digits [ u % radix ] ; u /= radix ; } point = ndigits - exp ; if ( js_try ( J ) ) { js_free ( J , sb ) ; js_throw ( J ) ; } if ( sign ) js_putc ( J , & sb , '-' ) ; if ( point <= 0 ) { js_putc ( J , & sb , '0' ) ; js_putc ( J , & sb , '.' ) ; while ( point ++ < 0 ) js_putc ( J , & sb , '0' ) ; while ( ndigits -- > 0 ) js_putc ( J , & sb , buf [ ndigits ] ) ; } else { while ( ndigits -- > 0 ) { js_putc ( J , & sb , buf [ ndigits ] ) ; if ( -- point == 0 && ndigits > 0 ) js_putc ( J , & sb , '.' ) ; } while ( point -- > 0 ) js_putc ( J , & sb , '0' ) ; } js_putc ( J , & sb , 0 ) ; js_pushstring ( J , sb -> s ) ; js_endtry ( J ) ; js_free ( J , sb ) ; } }
CWE-119 static void numtostr ( js_State * J , const char * fmt , int w , double n ) { <S2SV_StartBug> char buf [ 32 ] , * e ; <S2SV_EndBug> sprintf ( buf , fmt , w , n ) ; e = strchr ( buf , 'e' ) ; if ( e ) { int exp = atoi ( e + 1 ) ; sprintf ( e , "e%+d" , exp ) ; } js_pushstring ( J , buf ) ; }
CWE-190 static void addArgumentToVtab ( Parse * pParse ) { if ( pParse -> sArg . z && pParse -> pNewTable ) { const char * z = ( const char * ) pParse -> sArg . z ; int n = pParse -> sArg . n ; sqlite3 * db = pParse -> db ; <S2SV_StartBug> addModuleArgument ( db , pParse -> pNewTable , sqlite3DbStrNDup ( db , z , n ) ) ; <S2SV_EndBug> } }
CWE-190 <S2SV_StartBug> static void addModuleArgument ( sqlite3 * db , Table * pTable , char * zArg ) { <S2SV_EndBug> <S2SV_StartBug> int nBytes = sizeof ( char * ) * ( 2 + pTable -> nModuleArg ) ; <S2SV_EndBug> <S2SV_StartBug> char * * azModuleArg ; <S2SV_EndBug> azModuleArg = sqlite3DbRealloc ( db , pTable -> azModuleArg , nBytes ) ; if ( azModuleArg == 0 ) { sqlite3DbFree ( db , zArg ) ; } else { int i = pTable -> nModuleArg ++ ; azModuleArg [ i ] = zArg ; azModuleArg [ i + 1 ] = 0 ; pTable -> azModuleArg = azModuleArg ; } }
CWE-190 static int growOpArray ( Vdbe * v , int nOp ) { VdbeOp * pNew ; Parse * p = v -> pParse ; # ifdef SQLITE_TEST_REALLOC_STRESS <S2SV_StartBug> int nNew = ( v -> nOpAlloc >= 512 ? v -> nOpAlloc * 2 : v -> nOpAlloc + nOp ) ; <S2SV_EndBug> # else <S2SV_StartBug> int nNew = ( v -> nOpAlloc ? v -> nOpAlloc * 2 : ( int ) ( 1024 / sizeof ( Op ) ) ) ; <S2SV_EndBug> UNUSED_PARAMETER ( nOp ) ; # endif if ( nNew > p -> db -> aLimit [ SQLITE_LIMIT_VDBE_OP ] ) { sqlite3OomFault ( p -> db ) ; return SQLITE_NOMEM ; } assert ( nOp <= ( 1024 / sizeof ( Op ) ) ) ; assert ( nNew >= ( v -> nOpAlloc + nOp ) ) ; pNew = sqlite3DbRealloc ( p -> db , v -> aOp , nNew * sizeof ( Op ) ) ; if ( pNew ) { p -> szOpAlloc = sqlite3DbMallocSize ( p -> db , pNew ) ; v -> nOpAlloc = p -> szOpAlloc / sizeof ( Op ) ; v -> aOp = pNew ; } return ( pNew ? SQLITE_OK : SQLITE_NOMEM_BKPT ) ; }
CWE-190 static int growVTrans ( sqlite3 * db ) { const int ARRAY_INCR = 5 ; if ( ( db -> nVTrans % ARRAY_INCR ) == 0 ) { VTable * * aVTrans ; <S2SV_StartBug> int nBytes = sizeof ( sqlite3_vtab * ) * ( db -> nVTrans + ARRAY_INCR ) ; <S2SV_EndBug> aVTrans = sqlite3DbRealloc ( db , ( void * ) db -> aVTrans , nBytes ) ; if ( ! aVTrans ) { return SQLITE_NOMEM_BKPT ; } memset ( & aVTrans [ db -> nVTrans ] , 0 , sizeof ( sqlite3_vtab * ) * ARRAY_INCR ) ; db -> aVTrans = aVTrans ; } return SQLITE_OK ; }
CWE-190 static int setupLookaside ( sqlite3 * db , void * pBuf , int sz , int cnt ) { # ifndef SQLITE_OMIT_LOOKASIDE void * pStart ; if ( sqlite3LookasideUsed ( db , 0 ) > 0 ) { return SQLITE_BUSY ; } if ( db -> lookaside . bMalloced ) { sqlite3_free ( db -> lookaside . pStart ) ; } sz = ROUNDDOWN8 ( sz ) ; if ( sz <= ( int ) sizeof ( LookasideSlot * ) ) sz = 0 ; if ( cnt < 0 ) cnt = 0 ; if ( sz == 0 || cnt == 0 ) { sz = 0 ; pStart = 0 ; } else if ( pBuf == 0 ) { sqlite3BeginBenignMalloc ( ) ; <S2SV_StartBug> pStart = sqlite3Malloc ( sz * cnt ) ; <S2SV_EndBug> sqlite3EndBenignMalloc ( ) ; if ( pStart ) cnt = sqlite3MallocSize ( pStart ) / sz ; } else { pStart = pBuf ; } db -> lookaside . pStart = pStart ; db -> lookaside . pInit = 0 ; db -> lookaside . pFree = 0 ; db -> lookaside . sz = ( u16 ) sz ; if ( pStart ) { int i ; LookasideSlot * p ; assert ( sz > ( int ) sizeof ( LookasideSlot * ) ) ; db -> lookaside . nSlot = cnt ; p = ( LookasideSlot * ) pStart ; for ( i = cnt - 1 ; i >= 0 ; i -- ) { p -> pNext = db -> lookaside . pInit ; db -> lookaside . pInit = p ; p = ( LookasideSlot * ) & ( ( u8 * ) p ) [ sz ] ; } db -> lookaside . pEnd = p ; db -> lookaside . bDisable = 0 ; db -> lookaside . bMalloced = pBuf == 0 ? 1 : 0 ; } else { db -> lookaside . pStart = db ; db -> lookaside . pEnd = db ; db -> lookaside . bDisable = 1 ; db -> lookaside . bMalloced = 0 ; db -> lookaside . nSlot = 0 ; } # endif return SQLITE_OK ; }
CWE-190 SQLITE_PRIVATE void * sqlite3ArrayAllocate ( sqlite3 * db , void * pArray , int szEntry , int * pnEntry , int * pIdx ) { char * z ; <S2SV_StartBug> int n = * pnEntry ; <S2SV_EndBug> if ( ( n & ( n - 1 ) ) == 0 ) { <S2SV_StartBug> int sz = ( n == 0 ) ? 1 : 2 * n ; <S2SV_EndBug> void * pNew = sqlite3DbRealloc ( db , pArray , sz * szEntry ) ; if ( pNew == 0 ) { * pIdx = - 1 ; return pArray ; } pArray = pNew ; } z = ( char * ) pArray ; memset ( & z [ n * szEntry ] , 0 , szEntry ) ; * pIdx = n ; ++ * pnEntry ; return pArray ; }
CWE-190 SQLITE_PRIVATE ExprList * sqlite3ExprListAppend ( Parse * pParse , ExprList * pList , Expr * pExpr ) { struct ExprList_item * pItem ; sqlite3 * db = pParse -> db ; assert ( db != 0 ) ; if ( pList == 0 ) { pList = sqlite3DbMallocRawNN ( db , sizeof ( ExprList ) ) ; if ( pList == 0 ) { goto no_mem ; } pList -> nExpr = 0 ; } else if ( ( pList -> nExpr & ( pList -> nExpr - 1 ) ) == 0 ) { ExprList * pNew ; pNew = sqlite3DbRealloc ( db , pList , <S2SV_StartBug> sizeof ( * pList ) + ( 2 * pList -> nExpr - 1 ) * sizeof ( pList -> a [ 0 ] ) ) ; <S2SV_EndBug> if ( pNew == 0 ) { goto no_mem ; } pList = pNew ; } pItem = & pList -> a [ pList -> nExpr ++ ] ; assert ( offsetof ( struct ExprList_item , zName ) == sizeof ( pItem -> pExpr ) ) ; assert ( offsetof ( struct ExprList_item , pExpr ) == 0 ) ; memset ( & pItem -> zName , 0 , sizeof ( * pItem ) - offsetof ( struct ExprList_item , zName ) ) ; pItem -> pExpr = pExpr ; return pList ; no_mem : sqlite3ExprDelete ( db , pExpr ) ; sqlite3ExprListDelete ( db , pList ) ; return 0 ; }
CWE-190 SQLITE_PRIVATE SrcList * sqlite3SrcListEnlarge ( Parse * pParse , SrcList * pSrc , int nExtra , int iStart ) { int i ; assert ( iStart >= 0 ) ; assert ( nExtra >= 1 ) ; assert ( pSrc != 0 ) ; assert ( iStart <= pSrc -> nSrc ) ; if ( ( u32 ) pSrc -> nSrc + nExtra > pSrc -> nAlloc ) { SrcList * pNew ; <S2SV_StartBug> int nAlloc = pSrc -> nSrc * 2 + nExtra ; <S2SV_EndBug> sqlite3 * db = pParse -> db ; if ( pSrc -> nSrc + nExtra >= SQLITE_MAX_SRCLIST ) { sqlite3ErrorMsg ( pParse , "too<S2SV_blank>many<S2SV_blank>FROM<S2SV_blank>clause<S2SV_blank>terms,<S2SV_blank>max:<S2SV_blank>%d" , SQLITE_MAX_SRCLIST ) ; return 0 ; } if ( nAlloc > SQLITE_MAX_SRCLIST ) nAlloc = SQLITE_MAX_SRCLIST ; pNew = sqlite3DbRealloc ( db , pSrc , sizeof ( * pSrc ) + ( nAlloc - 1 ) * sizeof ( pSrc -> a [ 0 ] ) ) ; if ( pNew == 0 ) { assert ( db -> mallocFailed ) ; return 0 ; } pSrc = pNew ; pSrc -> nAlloc = nAlloc ; } for ( i = pSrc -> nSrc - 1 ; i >= iStart ; i -- ) { pSrc -> a [ i + nExtra ] = pSrc -> a [ i ] ; } pSrc -> nSrc += nExtra ; memset ( & pSrc -> a [ iStart ] , 0 , sizeof ( pSrc -> a [ 0 ] ) * nExtra ) ; for ( i = iStart ; i < iStart + nExtra ; i ++ ) { pSrc -> a [ i ] . iCursor = - 1 ; } return pSrc ; }
CWE-190 SQLITE_PRIVATE VList * sqlite3VListAdd ( sqlite3 * db , VList * pIn , const char * zName , int nName , int iVal ) { int nInt ; char * z ; int i ; nInt = nName / 4 + 3 ; assert ( pIn == 0 || pIn [ 0 ] >= 3 ) ; if ( pIn == 0 || pIn [ 1 ] + nInt > pIn [ 0 ] ) { <S2SV_StartBug> int nAlloc = ( pIn ? pIn [ 0 ] * 2 : 10 ) + nInt ; <S2SV_EndBug> VList * pOut = sqlite3DbRealloc ( db , pIn , nAlloc * sizeof ( int ) ) ; if ( pOut == 0 ) return pIn ; if ( pIn == 0 ) pOut [ 1 ] = 2 ; pIn = pOut ; pIn [ 0 ] = nAlloc ; } i = pIn [ 1 ] ; pIn [ i ] = iVal ; pIn [ i + 1 ] = nInt ; z = ( char * ) & pIn [ i + 2 ] ; pIn [ 1 ] = i + nInt ; assert ( pIn [ 1 ] <= pIn [ 0 ] ) ; memcpy ( z , zName , nName ) ; z [ nName ] = 0 ; return pIn ; }
CWE-190 SQLITE_PRIVATE int sqlite3VdbeSorterWrite ( const VdbeCursor * pCsr , Mem * pVal ) { VdbeSorter * pSorter ; int rc = SQLITE_OK ; SorterRecord * pNew ; int bFlush ; int nReq ; int nPMA ; int t ; assert ( pCsr -> eCurType == CURTYPE_SORTER ) ; pSorter = pCsr -> uc . pSorter ; getVarint32 ( ( const u8 * ) & pVal -> z [ 1 ] , t ) ; if ( t > 0 && t < 10 && t != 7 ) { pSorter -> typeMask &= SORTER_TYPE_INTEGER ; } else if ( t > 10 && ( t & 0x01 ) ) { pSorter -> typeMask &= SORTER_TYPE_TEXT ; } else { pSorter -> typeMask = 0 ; } assert ( pSorter ) ; nReq = pVal -> n + sizeof ( SorterRecord ) ; nPMA = pVal -> n + sqlite3VarintLen ( pVal -> n ) ; if ( pSorter -> mxPmaSize ) { if ( pSorter -> list . aMemory ) { bFlush = pSorter -> iMemory && ( pSorter -> iMemory + nReq ) > pSorter -> mxPmaSize ; } else { bFlush = ( ( pSorter -> list . szPMA > pSorter -> mxPmaSize ) || ( pSorter -> list . szPMA > pSorter -> mnPmaSize && sqlite3HeapNearlyFull ( ) ) ) ; } if ( bFlush ) { rc = vdbeSorterFlushPMA ( pSorter ) ; pSorter -> list . szPMA = 0 ; pSorter -> iMemory = 0 ; assert ( rc != SQLITE_OK || pSorter -> list . pList == 0 ) ; } } pSorter -> list . szPMA += nPMA ; if ( nPMA > pSorter -> mxKeysize ) { pSorter -> mxKeysize = nPMA ; } if ( pSorter -> list . aMemory ) { int nMin = pSorter -> iMemory + nReq ; if ( nMin > pSorter -> nMemory ) { u8 * aNew ; int iListOff = ( u8 * ) pSorter -> list . pList - pSorter -> list . aMemory ; <S2SV_StartBug> int nNew = pSorter -> nMemory * 2 ; <S2SV_EndBug> while ( nNew < nMin ) nNew = nNew * 2 ; if ( nNew > pSorter -> mxPmaSize ) nNew = pSorter -> mxPmaSize ; if ( nNew < nMin ) nNew = nMin ; aNew = sqlite3Realloc ( pSorter -> list . aMemory , nNew ) ; if ( ! aNew ) return SQLITE_NOMEM_BKPT ; pSorter -> list . pList = ( SorterRecord * ) & aNew [ iListOff ] ; pSorter -> list . aMemory = aNew ; pSorter -> nMemory = nNew ; } pNew = ( SorterRecord * ) & pSorter -> list . aMemory [ pSorter -> iMemory ] ; pSorter -> iMemory += ROUND8 ( nReq ) ; if ( pSorter -> list . pList ) { pNew -> u . iNext = ( int ) ( ( u8 * ) ( pSorter -> list . pList ) - pSorter -> list . aMemory ) ; } } else { pNew = ( SorterRecord * ) sqlite3Malloc ( nReq ) ; if ( pNew == 0 ) { return SQLITE_NOMEM_BKPT ; } pNew -> u . pNext = pSorter -> list . pList ; } memcpy ( SRVAL ( pNew ) , pVal -> z , pVal -> n ) ; pNew -> nVal = pVal -> n ; pSorter -> list . pList = pNew ; return rc ; }
CWE-190 SQLITE_PRIVATE void sqlite3VtabBeginParse ( Parse * pParse , Token * pName1 , Token * pName2 , Token * pModuleName , int ifNotExists ) { Table * pTable ; sqlite3 * db ; sqlite3StartTable ( pParse , pName1 , pName2 , 0 , 0 , 1 , ifNotExists ) ; pTable = pParse -> pNewTable ; if ( pTable == 0 ) return ; assert ( 0 == pTable -> pIndex ) ; db = pParse -> db ; assert ( pTable -> nModuleArg == 0 ) ; <S2SV_StartBug> addModuleArgument ( db , pTable , sqlite3NameFromToken ( db , pModuleName ) ) ; <S2SV_EndBug> <S2SV_StartBug> addModuleArgument ( db , pTable , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> addModuleArgument ( db , pTable , sqlite3DbStrDup ( db , pTable -> zName ) ) ; <S2SV_EndBug> assert ( ( pParse -> sNameToken . z == pName2 -> z && pName2 -> z != 0 ) || ( pParse -> sNameToken . z == pName1 -> z && pName2 -> z == 0 ) ) ; pParse -> sNameToken . n = ( int ) ( & pModuleName -> z [ pModuleName -> n ] - pParse -> sNameToken . z ) ; # ifndef SQLITE_OMIT_AUTHORIZATION if ( pTable -> azModuleArg ) { int iDb = sqlite3SchemaToIndex ( db , pTable -> pSchema ) ; assert ( iDb >= 0 ) ; sqlite3AuthCheck ( pParse , SQLITE_CREATE_VTABLE , pTable -> zName , pTable -> azModuleArg [ 0 ] , pParse -> db -> aDb [ iDb ] . zDbSName ) ; } # endif }
CWE-190 SQLITE_PRIVATE int sqlite3VtabEponymousTableInit ( Parse * pParse , Module * pMod ) { const sqlite3_module * pModule = pMod -> pModule ; Table * pTab ; char * zErr = 0 ; int rc ; sqlite3 * db = pParse -> db ; if ( pMod -> pEpoTab ) return 1 ; if ( pModule -> xCreate != 0 && pModule -> xCreate != pModule -> xConnect ) return 0 ; pTab = sqlite3DbMallocZero ( db , sizeof ( Table ) ) ; if ( pTab == 0 ) return 0 ; pTab -> zName = sqlite3DbStrDup ( db , pMod -> zName ) ; if ( pTab -> zName == 0 ) { sqlite3DbFree ( db , pTab ) ; return 0 ; } pMod -> pEpoTab = pTab ; pTab -> nTabRef = 1 ; pTab -> pSchema = db -> aDb [ 0 ] . pSchema ; assert ( pTab -> nModuleArg == 0 ) ; pTab -> iPKey = - 1 ; <S2SV_StartBug> addModuleArgument ( db , pTab , sqlite3DbStrDup ( db , pTab -> zName ) ) ; <S2SV_EndBug> <S2SV_StartBug> addModuleArgument ( db , pTab , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> addModuleArgument ( db , pTab , sqlite3DbStrDup ( db , pTab -> zName ) ) ; <S2SV_EndBug> rc = vtabCallConstructor ( db , pTab , pMod , pModule -> xConnect , & zErr ) ; if ( rc ) { sqlite3ErrorMsg ( pParse , "%s" , zErr ) ; sqlite3DbFree ( db , zErr ) ; sqlite3VtabEponymousTableClear ( db , pMod ) ; return 0 ; } return 1 ; }
CWE-190 SQLITE_PRIVATE With * sqlite3WithAdd ( Parse * pParse , With * pWith , Token * pName , ExprList * pArglist , Select * pQuery ) { sqlite3 * db = pParse -> db ; With * pNew ; char * zName ; zName = sqlite3NameFromToken ( pParse -> db , pName ) ; if ( zName && pWith ) { int i ; for ( i = 0 ; i < pWith -> nCte ; i ++ ) { if ( sqlite3StrICmp ( zName , pWith -> a [ i ] . zName ) == 0 ) { sqlite3ErrorMsg ( pParse , "duplicate<S2SV_blank>WITH<S2SV_blank>table<S2SV_blank>name:<S2SV_blank>%s" , zName ) ; } } } if ( pWith ) { <S2SV_StartBug> int nByte = sizeof ( * pWith ) + ( sizeof ( pWith -> a [ 1 ] ) * pWith -> nCte ) ; <S2SV_EndBug> pNew = sqlite3DbRealloc ( db , pWith , nByte ) ; } else { pNew = sqlite3DbMallocZero ( db , sizeof ( * pWith ) ) ; } assert ( ( pNew != 0 && zName != 0 ) || db -> mallocFailed ) ; if ( db -> mallocFailed ) { sqlite3ExprListDelete ( db , pArglist ) ; sqlite3SelectDelete ( db , pQuery ) ; sqlite3DbFree ( db , zName ) ; pNew = pWith ; } else { pNew -> a [ pNew -> nCte ] . pSelect = pQuery ; pNew -> a [ pNew -> nCte ] . pCols = pArglist ; pNew -> a [ pNew -> nCte ] . zName = zName ; pNew -> a [ pNew -> nCte ] . zCteErr = 0 ; pNew -> nCte ++ ; } return pNew ; }
CWE-190 static int vdbePmaReadBlob ( PmaReader * p , int nByte , u8 * * ppOut ) { int iBuf ; int nAvail ; if ( p -> aMap ) { * ppOut = & p -> aMap [ p -> iReadOff ] ; p -> iReadOff += nByte ; return SQLITE_OK ; } assert ( p -> aBuffer ) ; iBuf = p -> iReadOff % p -> nBuffer ; if ( iBuf == 0 ) { int nRead ; int rc ; if ( ( p -> iEof - p -> iReadOff ) > ( i64 ) p -> nBuffer ) { nRead = p -> nBuffer ; } else { nRead = ( int ) ( p -> iEof - p -> iReadOff ) ; } assert ( nRead > 0 ) ; rc = sqlite3OsRead ( p -> pFd , p -> aBuffer , nRead , p -> iReadOff ) ; assert ( rc != SQLITE_IOERR_SHORT_READ ) ; if ( rc != SQLITE_OK ) return rc ; } nAvail = p -> nBuffer - iBuf ; if ( nByte <= nAvail ) { * ppOut = & p -> aBuffer [ iBuf ] ; p -> iReadOff += nByte ; } else { int nRem ; if ( p -> nAlloc < nByte ) { u8 * aNew ; <S2SV_StartBug> int nNew = MAX ( 128 , p -> nAlloc * 2 ) ; <S2SV_EndBug> while ( nByte > nNew ) nNew = nNew * 2 ; aNew = sqlite3Realloc ( p -> aAlloc , nNew ) ; if ( ! aNew ) return SQLITE_NOMEM_BKPT ; p -> nAlloc = nNew ; p -> aAlloc = aNew ; } memcpy ( p -> aAlloc , & p -> aBuffer [ iBuf ] , nAvail ) ; p -> iReadOff += nAvail ; nRem = nByte - nAvail ; while ( nRem > 0 ) { int rc ; int nCopy ; u8 * aNext ; nCopy = nRem ; if ( nRem > p -> nBuffer ) nCopy = p -> nBuffer ; rc = vdbePmaReadBlob ( p , nCopy , & aNext ) ; if ( rc != SQLITE_OK ) return rc ; assert ( aNext != p -> aAlloc ) ; memcpy ( & p -> aAlloc [ nByte - nRem ] , aNext , nCopy ) ; nRem -= nCopy ; } * ppOut = p -> aAlloc ; } return SQLITE_OK ; }
CWE-190 static MatchinfoBuffer * fts3MIBufferNew ( int nElem , const char * zMatchinfo ) { MatchinfoBuffer * pRet ; <S2SV_StartBug> int nByte = sizeof ( u32 ) * ( 2 * nElem + 1 ) + sizeof ( MatchinfoBuffer ) ; <S2SV_EndBug> <S2SV_StartBug> int nStr = ( int ) strlen ( zMatchinfo ) ; <S2SV_EndBug> <S2SV_StartBug> pRet = sqlite3_malloc ( nByte + nStr + 1 ) ; <S2SV_EndBug> if ( pRet ) { memset ( pRet , 0 , nByte ) ; pRet -> aMatchinfo [ 0 ] = ( u8 * ) ( & pRet -> aMatchinfo [ 1 ] ) - ( u8 * ) pRet ; pRet -> aMatchinfo [ 1 + nElem ] = pRet -> aMatchinfo [ 0 ] + sizeof ( u32 ) * ( nElem + 1 ) ; pRet -> nElem = nElem ; pRet -> zMatchinfo = ( ( char * ) pRet ) + nByte ; memcpy ( pRet -> zMatchinfo , zMatchinfo , nStr + 1 ) ; pRet -> aRef [ 0 ] = 1 ; } return pRet ; }
CWE-190 static int fts3tokFilterMethod ( sqlite3_vtab_cursor * pCursor , int idxNum , const char * idxStr , int nVal , sqlite3_value * * apVal ) { int rc = SQLITE_ERROR ; Fts3tokCursor * pCsr = ( Fts3tokCursor * ) pCursor ; Fts3tokTable * pTab = ( Fts3tokTable * ) ( pCursor -> pVtab ) ; UNUSED_PARAMETER ( idxStr ) ; UNUSED_PARAMETER ( nVal ) ; fts3tokResetCursor ( pCsr ) ; if ( idxNum == 1 ) { const char * zByte = ( const char * ) sqlite3_value_text ( apVal [ 0 ] ) ; int nByte = sqlite3_value_bytes ( apVal [ 0 ] ) ; <S2SV_StartBug> pCsr -> zInput = sqlite3_malloc ( nByte + 1 ) ; <S2SV_EndBug> if ( pCsr -> zInput == 0 ) { rc = SQLITE_NOMEM ; } else { memcpy ( pCsr -> zInput , zByte , nByte ) ; pCsr -> zInput [ nByte ] = 0 ; rc = pTab -> pMod -> xOpen ( pTab -> pTok , pCsr -> zInput , nByte , & pCsr -> pCsr ) ; if ( rc == SQLITE_OK ) { pCsr -> pCsr -> pTokenizer = pTab -> pTok ; } } } if ( rc != SQLITE_OK ) return rc ; return fts3tokNextMethod ( pCursor ) ; }
CWE-190 int sqlite3Fts3InitTokenizer ( Fts3Hash * pHash , const char * zArg , sqlite3_tokenizer * * ppTok , char * * pzErr ) { int rc ; char * z = ( char * ) zArg ; int n = 0 ; char * zCopy ; char * zEnd ; sqlite3_tokenizer_module * m ; zCopy = sqlite3_mprintf ( "%s" , zArg ) ; if ( ! zCopy ) return SQLITE_NOMEM ; zEnd = & zCopy [ strlen ( zCopy ) ] ; z = ( char * ) sqlite3Fts3NextToken ( zCopy , & n ) ; if ( z == 0 ) { assert ( n == 0 ) ; z = zCopy ; } z [ n ] = '\\0' ; sqlite3Fts3Dequote ( z ) ; m = ( sqlite3_tokenizer_module * ) sqlite3Fts3HashFind ( pHash , z , ( int ) strlen ( z ) + 1 ) ; if ( ! m ) { sqlite3Fts3ErrMsg ( pzErr , "unknown<S2SV_blank>tokenizer:<S2SV_blank>%s" , z ) ; rc = SQLITE_ERROR ; } else { char const * * aArg = 0 ; int iArg = 0 ; z = & z [ n + 1 ] ; while ( z < zEnd && ( NULL != ( z = ( char * ) sqlite3Fts3NextToken ( z , & n ) ) ) ) { <S2SV_StartBug> int nNew = sizeof ( char * ) * ( iArg + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> char const * * aNew = ( const char * * ) sqlite3_realloc ( ( void * ) aArg , nNew ) ; <S2SV_EndBug> if ( ! aNew ) { sqlite3_free ( zCopy ) ; sqlite3_free ( ( void * ) aArg ) ; return SQLITE_NOMEM ; } aArg = aNew ; aArg [ iArg ++ ] = z ; z [ n ] = '\\0' ; sqlite3Fts3Dequote ( z ) ; z = & z [ n + 1 ] ; } rc = m -> xCreate ( iArg , aArg , ppTok ) ; assert ( rc != SQLITE_OK || * ppTok ) ; if ( rc != SQLITE_OK ) { sqlite3Fts3ErrMsg ( pzErr , "unknown<S2SV_blank>tokenizer" ) ; } else { ( * ppTok ) -> pModule = m ; } sqlite3_free ( ( void * ) aArg ) ; } sqlite3_free ( zCopy ) ; return rc ; }
CWE-119 void TEMPLATE ( process_block_dec ) ( decoder_info_t * decoder_info , int size , int yposY , int xposY , int sub ) { int width = decoder_info -> width ; int height = decoder_info -> height ; stream_t * stream = decoder_info -> stream ; frame_type_t frame_type = decoder_info -> frame_info . frame_type ; int split_flag = 0 ; if ( yposY >= height || xposY >= width ) return ; int decode_this_size = ( yposY + size <= height ) && ( xposY + size <= width ) ; int decode_rectangular_size = ! decode_this_size && frame_type != I_FRAME ; int bit_start = stream -> bitcnt ; int mode = MODE_SKIP ; block_context_t block_context ; TEMPLATE ( find_block_contexts ) ( yposY , xposY , height , width , size , decoder_info -> deblock_data , & block_context , decoder_info -> use_block_contexts ) ; decoder_info -> block_context = & block_context ; split_flag = decode_super_mode ( decoder_info , size , decode_this_size ) ; mode = decoder_info -> mode ; if ( size == ( 1 << decoder_info -> log2_sb_size ) && ( split_flag || mode != MODE_SKIP ) && decoder_info -> max_delta_qp > 0 ) { int delta_qp = read_delta_qp ( stream ) ; int prev_qp ; if ( yposY == 0 && xposY == 0 ) prev_qp = decoder_info -> frame_info . qp ; else prev_qp = decoder_info -> frame_info . qpb ; decoder_info -> frame_info . qpb = prev_qp + delta_qp ; } decoder_info -> bit_count . super_mode [ decoder_info -> bit_count . stat_frame_type ] += ( stream -> bitcnt - bit_start ) ; <S2SV_StartBug> if ( split_flag ) { <S2SV_EndBug> int new_size = size / 2 ; TEMPLATE ( process_block_dec ) ( decoder_info , new_size , yposY + 0 * new_size , xposY + 0 * new_size , sub ) ; TEMPLATE ( process_block_dec ) ( decoder_info , new_size , yposY + 1 * new_size , xposY + 0 * new_size , sub ) ; TEMPLATE ( process_block_dec ) ( decoder_info , new_size , yposY + 0 * new_size , xposY + 1 * new_size , sub ) ; TEMPLATE ( process_block_dec ) ( decoder_info , new_size , yposY + 1 * new_size , xposY + 1 * new_size , sub ) ; } else if ( decode_this_size || decode_rectangular_size ) { decode_block ( decoder_info , size , yposY , xposY , sub ) ; } }
CWE-119 void read_sequence_header ( decoder_info_t * decoder_info , stream_t * stream ) { decoder_info -> width = get_flc ( 16 , stream ) ; decoder_info -> height = get_flc ( 16 , stream ) ; <S2SV_StartBug> decoder_info -> log2_sb_size = get_flc ( 3 , stream ) ; <S2SV_EndBug> decoder_info -> pb_split = get_flc ( 1 , stream ) ; decoder_info -> tb_split_enable = get_flc ( 1 , stream ) ; decoder_info -> max_num_ref = get_flc ( 2 , stream ) + 1 ; decoder_info -> interp_ref = get_flc ( 2 , stream ) ; decoder_info -> max_delta_qp = get_flc ( 1 , stream ) ; decoder_info -> deblocking = get_flc ( 1 , stream ) ; decoder_info -> clpf = get_flc ( 1 , stream ) ; decoder_info -> use_block_contexts = get_flc ( 1 , stream ) ; decoder_info -> bipred = get_flc ( 2 , stream ) ; decoder_info -> qmtx = get_flc ( 1 , stream ) ; if ( decoder_info -> qmtx ) { decoder_info -> qmtx_offset = get_flc ( 6 , stream ) - 32 ; } decoder_info -> subsample = get_flc ( 2 , stream ) ; decoder_info -> subsample = ( decoder_info -> subsample & 1 ) * 20 + ( decoder_info -> subsample & 2 ) * 22 + ( ( decoder_info -> subsample & 3 ) == 3 ) * 2 + 400 ; decoder_info -> num_reorder_pics = get_flc ( 4 , stream ) ; if ( decoder_info -> subsample != 400 ) { decoder_info -> cfl_intra = get_flc ( 1 , stream ) ; decoder_info -> cfl_inter = get_flc ( 1 , stream ) ; } decoder_info -> bitdepth = get_flc ( 1 , stream ) ? 10 : 8 ; if ( decoder_info -> bitdepth == 10 ) decoder_info -> bitdepth += 2 * get_flc ( 1 , stream ) ; decoder_info -> input_bitdepth = get_flc ( 1 , stream ) ? 10 : 8 ; if ( decoder_info -> input_bitdepth == 10 ) decoder_info -> input_bitdepth += 2 * get_flc ( 1 , stream ) ; }
CWE-125 static void send_ssi_file ( struct mg_connection * conn , const char * path , struct mg_file * filep , int include_level ) { char buf [ MG_BUF_LEN ] ; int ch , offset , len , in_tag , in_ssi_tag ; if ( include_level > 10 ) { mg_cry_internal ( conn , "SSI<S2SV_blank>#include<S2SV_blank>level<S2SV_blank>is<S2SV_blank>too<S2SV_blank>deep<S2SV_blank>(%s)" , path ) ; return ; } in_tag = in_ssi_tag = len = offset = 0 ; while ( ( ch = mg_fgetc ( filep , offset ++ ) ) != EOF ) { if ( in_tag ) { if ( ch == '>' ) { buf [ len ++ ] = '>' ; if ( in_ssi_tag ) { buf [ len ] = 0 ; <S2SV_StartBug> if ( ! memcmp ( buf + 5 , "include" , 7 ) ) { <S2SV_EndBug> do_ssi_include ( conn , path , buf + 12 , include_level + 1 ) ; # if ! defined ( NO_POPEN ) <S2SV_StartBug> } else if ( ! memcmp ( buf + 5 , "exec" , 4 ) ) { <S2SV_EndBug> do_ssi_exec ( conn , buf + 9 ) ; # endif } else { mg_cry_internal ( conn , "%s:<S2SV_blank>unknown<S2SV_blank>SSI<S2SV_blank>" "command:<S2SV_blank>\\"%s\\"" , path , buf ) ; } len = 0 ; in_ssi_tag = in_tag = 0 ; } else { ( void ) mg_write ( conn , buf , ( size_t ) len ) ; len = 0 ; in_tag = 0 ; } } else { buf [ len ++ ] = ( char ) ( ch & 0xff ) ; if ( ( len == 5 ) && ! memcmp ( buf , "<!--#" , 5 ) ) { in_ssi_tag = 1 ; } if ( ( len + 2 ) > ( int ) sizeof ( buf ) ) { mg_cry_internal ( conn , "%s:<S2SV_blank>tag<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large" , path ) ; return ; } } } else { if ( ch == '<' ) { in_tag = 1 ; if ( len > 0 ) { ( void ) mg_write ( conn , buf , ( size_t ) len ) ; } len = 1 ; buf [ 0 ] = '<' ; } else { buf [ len ++ ] = ( char ) ( ch & 0xff ) ; if ( len == ( int ) sizeof ( buf ) ) { mg_write ( conn , buf , ( size_t ) len ) ; len = 0 ; } } } } if ( len > 0 ) { mg_write ( conn , buf , ( size_t ) len ) ; } }
CWE-119 static void test_function ( char * ( * my_asnprintf ) ( char * , size_t * , const char * , ... ) ) { char buf [ 8 ] ; int size ; for ( size = 0 ; size <= 8 ; size ++ ) { size_t length = size ; char * result = my_asnprintf ( NULL , & length , "%d" , 12345 ) ; ASSERT ( result != NULL ) ; ASSERT ( strcmp ( result , "12345" ) == 0 ) ; ASSERT ( length == 5 ) ; free ( result ) ; } for ( size = 0 ; size <= 8 ; size ++ ) { size_t length ; char * result ; memcpy ( buf , "DEADBEEF" , 8 ) ; length = size ; result = my_asnprintf ( buf , & length , "%d" , 12345 ) ; ASSERT ( result != NULL ) ; ASSERT ( strcmp ( result , "12345" ) == 0 ) ; ASSERT ( length == 5 ) ; <S2SV_StartBug> if ( size < 6 ) <S2SV_EndBug> ASSERT ( result != buf ) ; ASSERT ( memcmp ( buf + size , & "DEADBEEF" [ size ] , 8 - size ) == 0 ) ; if ( result != buf ) free ( result ) ; } <S2SV_StartBug> } <S2SV_EndBug>
CWE-119 static int dprintf_formatf ( void * data , int ( * stream ) ( int , FILE * ) , const char * format , va_list ap_save ) { const char * digits = lower_digits ; char * f ; int done = 0 ; long param ; long param_num = 0 ; va_stack_t vto [ MAX_PARAMETERS ] ; char * endpos [ MAX_PARAMETERS ] ; char * * end ; char work [ BUFFSIZE ] ; va_stack_t * p ; char * workend = & work [ sizeof ( work ) - 2 ] ; if ( dprintf_Pass1 ( format , vto , endpos , ap_save ) ) return - 1 ; end = & endpos [ 0 ] ; f = ( char * ) format ; while ( * f != '\\0' ) { int is_alt ; long width ; long prec ; int is_neg ; long base ; mp_uintmax_t num ; mp_intmax_t signed_num ; char * w ; if ( * f != '%' ) { do { OUTCHAR ( * f ) ; } while ( * ++ f && ( '%' != * f ) ) ; continue ; } ++ f ; if ( * f == '%' ) { ++ f ; OUTCHAR ( '%' ) ; continue ; } param = dprintf_DollarString ( f , & f ) ; if ( ! param ) param = param_num ; else -- param ; param_num ++ ; p = & vto [ param ] ; if ( p -> flags & FLAGS_WIDTHPARAM ) { width = ( long ) vto [ p -> width ] . data . num . as_signed ; param_num ++ ; if ( width < 0 ) { width = - width ; p -> flags |= FLAGS_LEFT ; p -> flags &= ~ FLAGS_PAD_NIL ; } } else width = p -> width ; if ( p -> flags & FLAGS_PRECPARAM ) { prec = ( long ) vto [ p -> precision ] . data . num . as_signed ; param_num ++ ; if ( prec < 0 ) prec = - 1 ; } else if ( p -> flags & FLAGS_PREC ) prec = p -> precision ; else prec = - 1 ; is_alt = ( p -> flags & FLAGS_ALT ) ? 1 : 0 ; switch ( p -> type ) { case FORMAT_INT : num = p -> data . num . as_unsigned ; if ( p -> flags & FLAGS_CHAR ) { if ( ! ( p -> flags & FLAGS_LEFT ) ) while ( -- width > 0 ) OUTCHAR ( '<S2SV_blank>' ) ; OUTCHAR ( ( char ) num ) ; if ( p -> flags & FLAGS_LEFT ) while ( -- width > 0 ) OUTCHAR ( '<S2SV_blank>' ) ; break ; } if ( p -> flags & FLAGS_OCTAL ) { base = 8 ; goto unsigned_number ; } else if ( p -> flags & FLAGS_HEX ) { digits = ( p -> flags & FLAGS_UPPER ) ? upper_digits : lower_digits ; base = 16 ; goto unsigned_number ; } else if ( p -> flags & FLAGS_UNSIGNED ) { base = 10 ; goto unsigned_number ; } base = 10 ; is_neg = ( p -> data . num . as_signed < ( mp_intmax_t ) 0 ) ? 1 : 0 ; if ( is_neg ) { signed_num = p -> data . num . as_signed + ( mp_intmax_t ) 1 ; signed_num = - signed_num ; num = ( mp_uintmax_t ) signed_num ; num += ( mp_uintmax_t ) 1 ; } goto number ; unsigned_number : is_neg = 0 ; number : if ( prec == - 1 ) prec = 1 ; w = workend ; while ( num > 0 ) { * w -- = digits [ num % base ] ; num /= base ; } width -= ( long ) ( workend - w ) ; prec -= ( long ) ( workend - w ) ; if ( is_alt && base == 8 && prec <= 0 ) { * w -- = '0' ; -- width ; } if ( prec > 0 ) { width -= prec ; while ( prec -- > 0 ) * w -- = '0' ; } if ( is_alt && base == 16 ) width -= 2 ; if ( is_neg || ( p -> flags & FLAGS_SHOWSIGN ) || ( p -> flags & FLAGS_SPACE ) ) -- width ; if ( ! ( p -> flags & FLAGS_LEFT ) && ! ( p -> flags & FLAGS_PAD_NIL ) ) while ( width -- > 0 ) OUTCHAR ( '<S2SV_blank>' ) ; if ( is_neg ) OUTCHAR ( '-' ) ; else if ( p -> flags & FLAGS_SHOWSIGN ) OUTCHAR ( '+' ) ; else if ( p -> flags & FLAGS_SPACE ) OUTCHAR ( '<S2SV_blank>' ) ; if ( is_alt && base == 16 ) { OUTCHAR ( '0' ) ; if ( p -> flags & FLAGS_UPPER ) OUTCHAR ( 'X' ) ; else OUTCHAR ( 'x' ) ; } if ( ! ( p -> flags & FLAGS_LEFT ) && ( p -> flags & FLAGS_PAD_NIL ) ) while ( width -- > 0 ) OUTCHAR ( '0' ) ; while ( ++ w <= workend ) { OUTCHAR ( * w ) ; } if ( p -> flags & FLAGS_LEFT ) while ( width -- > 0 ) OUTCHAR ( '<S2SV_blank>' ) ; break ; case FORMAT_STRING : { static const char null [ ] = "(nil)" ; const char * str ; size_t len ; str = ( char * ) p -> data . str ; if ( str == NULL ) { if ( prec == - 1 || prec >= ( long ) sizeof ( null ) - 1 ) { str = null ; len = sizeof ( null ) - 1 ; p -> flags &= ( ~ FLAGS_ALT ) ; } else { str = "" ; len = 0 ; } } else if ( prec != - 1 ) len = ( size_t ) prec ; else len = strlen ( str ) ; width -= ( len > LONG_MAX ) ? LONG_MAX : ( long ) len ; if ( p -> flags & FLAGS_ALT ) OUTCHAR ( \'"\' ) ; if ( ! ( p -> flags & FLAGS_LEFT ) ) while ( width -- > 0 ) OUTCHAR ( '<S2SV_blank>' ) ; while ( ( len -- > 0 ) && * str ) OUTCHAR ( * str ++ ) ; if ( p -> flags & FLAGS_LEFT ) while ( width -- > 0 ) OUTCHAR ( '<S2SV_blank>' ) ; if ( p -> flags & FLAGS_ALT ) OUTCHAR ( \'"\' ) ; } break ; case FORMAT_PTR : { void * ptr ; ptr = ( void * ) p -> data . ptr ; if ( ptr != NULL ) { base = 16 ; digits = ( p -> flags & FLAGS_UPPER ) ? upper_digits : lower_digits ; is_alt = 1 ; num = ( size_t ) ptr ; is_neg = 0 ; goto number ; } else { static const char strnil [ ] = "(nil)" ; const char * point ; width -= ( long ) ( sizeof ( strnil ) - 1 ) ; if ( p -> flags & FLAGS_LEFT ) while ( width -- > 0 ) OUTCHAR ( '<S2SV_blank>' ) ; for ( point = strnil ; * point != '\\0' ; ++ point ) OUTCHAR ( * point ) ; if ( ! ( p -> flags & FLAGS_LEFT ) ) while ( width -- > 0 ) OUTCHAR ( '<S2SV_blank>' ) ; } } break ; case FORMAT_DOUBLE : { char formatbuf [ 32 ] = "%" ; char * fptr = & formatbuf [ 1 ] ; size_t left = sizeof ( formatbuf ) - strlen ( formatbuf ) ; int len ; width = - 1 ; if ( p -> flags & FLAGS_WIDTH ) width = p -> width ; else if ( p -> flags & FLAGS_WIDTHPARAM ) width = ( long ) vto [ p -> width ] . data . num . as_signed ; prec = - 1 ; if ( p -> flags & FLAGS_PREC ) prec = p -> precision ; else if ( p -> flags & FLAGS_PRECPARAM ) prec = ( long ) vto [ p -> precision ] . data . num . as_signed ; if ( p -> flags & FLAGS_LEFT ) * fptr ++ = '-' ; if ( p -> flags & FLAGS_SHOWSIGN ) * fptr ++ = '+' ; if ( p -> flags & FLAGS_SPACE ) * fptr ++ = '<S2SV_blank>' ; if ( p -> flags & FLAGS_ALT ) * fptr ++ = '#' ; * fptr = 0 ; if ( width >= 0 ) { <S2SV_StartBug> len = curl_msnprintf ( fptr , left , "%ld" , width ) ; <S2SV_EndBug> fptr += len ; left -= len ; } if ( prec >= 0 ) { <S2SV_StartBug> len = curl_msnprintf ( fptr , left , ".%ld" , prec ) ; <S2SV_EndBug> fptr += len ; } if ( p -> flags & FLAGS_LONG ) * fptr ++ = 'l' ; if ( p -> flags & FLAGS_FLOATE ) * fptr ++ = ( char ) ( ( p -> flags & FLAGS_UPPER ) ? 'E' : 'e' ) ; else if ( p -> flags & FLAGS_FLOATG ) * fptr ++ = ( char ) ( ( p -> flags & FLAGS_UPPER ) ? 'G' : 'g' ) ; else * fptr ++ = 'f' ; * fptr = 0 ; ( sprintf ) ( work , formatbuf , p -> data . dnum ) ; <S2SV_StartBug> for ( fptr = work ; * fptr ; fptr ++ ) <S2SV_EndBug> OUTCHAR ( * fptr ) ; } break ; case FORMAT_INTPTR : # ifdef HAVE_LONG_LONG_TYPE if ( p -> flags & FLAGS_LONGLONG ) * ( LONG_LONG_TYPE * ) p -> data . ptr = ( LONG_LONG_TYPE ) done ; else # endif if ( p -> flags & FLAGS_LONG ) * ( long * ) p -> data . ptr = ( long ) done ; else if ( ! ( p -> flags & FLAGS_SHORT ) ) * ( int * ) p -> data . ptr = ( int ) done ; else * ( short * ) p -> data . ptr = ( short ) done ; break ; default : break ; } f = * end ++ ; } return done ; }
CWE-119 int test ( char * URL ) { int errors = 0 ; ( void ) URL ; errors += test_weird_arguments ( ) ; errors += test_unsigned_short_formatting ( ) ; errors += test_signed_short_formatting ( ) ; errors += test_unsigned_int_formatting ( ) ; errors += test_signed_int_formatting ( ) ; errors += test_unsigned_long_formatting ( ) ; errors += test_signed_long_formatting ( ) ; errors += test_curl_off_t_formatting ( ) ; errors += test_string_formatting ( ) ; <S2SV_StartBug> if ( errors ) <S2SV_EndBug> return TEST_ERR_MAJOR_BAD ; else return 0 ; }
CWE-416 CURLcode Curl_close ( struct Curl_easy * data ) { struct Curl_multi * m ; if ( ! data ) return CURLE_OK ; Curl_expire_clear ( data ) ; m = data -> multi ; if ( m ) curl_multi_remove_handle ( data -> multi , data ) ; <S2SV_StartBug> if ( data -> multi_easy ) <S2SV_EndBug> <S2SV_StartBug> curl_multi_cleanup ( data -> multi_easy ) ; <S2SV_EndBug> Curl_llist_destroy ( & data -> state . timeoutlist , NULL ) ; data -> magic = 0 ; if ( data -> state . rangestringalloc ) free ( data -> state . range ) ; Curl_free_request_state ( data ) ; Curl_ssl_close_all ( data ) ; Curl_safefree ( data -> state . first_host ) ; Curl_safefree ( data -> state . scratch ) ; Curl_ssl_free_certinfo ( data ) ; free ( data -> req . newurl ) ; data -> req . newurl = NULL ; if ( data -> change . referer_alloc ) { Curl_safefree ( data -> change . referer ) ; data -> change . referer_alloc = FALSE ; } data -> change . referer = NULL ; Curl_up_free ( data ) ; Curl_safefree ( data -> state . buffer ) ; Curl_safefree ( data -> state . headerbuff ) ; Curl_safefree ( data -> state . ulbuf ) ; Curl_flush_cookies ( data , 1 ) ; Curl_digest_cleanup ( data ) ; Curl_safefree ( data -> info . contenttype ) ; Curl_safefree ( data -> info . wouldredirect ) ; Curl_resolver_cleanup ( data -> state . resolver ) ; Curl_http2_cleanup_dependencies ( data ) ; Curl_convert_close ( data ) ; if ( data -> share ) { Curl_share_lock ( data , CURL_LOCK_DATA_SHARE , CURL_LOCK_ACCESS_SINGLE ) ; data -> share -> dirty -- ; Curl_share_unlock ( data , CURL_LOCK_DATA_SHARE ) ; } Curl_wildcard_dtor ( & data -> wildcard ) ; Curl_freeset ( data ) ; free ( data ) ; return CURLE_OK ; }
CWE-119 CURLcode Curl_smtp_escape_eob ( struct connectdata * conn , const ssize_t nread ) { ssize_t i ; ssize_t si ; struct Curl_easy * data = conn -> data ; struct SMTP * smtp = data -> req . protop ; char * scratch = data -> state . scratch ; char * newscratch = NULL ; char * oldscratch = NULL ; size_t eob_sent ; if ( ! scratch || data -> set . crlf ) { oldscratch = scratch ; <S2SV_StartBug> scratch = newscratch = malloc ( 2 * data -> set . buffer_size ) ; <S2SV_EndBug> if ( ! newscratch ) { failf ( data , "Failed<S2SV_blank>to<S2SV_blank>alloc<S2SV_blank>scratch<S2SV_blank>buffer!" ) ; return CURLE_OUT_OF_MEMORY ; } <S2SV_StartBug> } <S2SV_EndBug> eob_sent = smtp -> eob ; for ( i = 0 , si = 0 ; i < nread ; i ++ ) { if ( SMTP_EOB [ smtp -> eob ] == data -> req . upload_fromhere [ i ] ) { smtp -> eob ++ ; if ( 2 == smtp -> eob || SMTP_EOB_LEN == smtp -> eob ) smtp -> trailing_crlf = TRUE ; else smtp -> trailing_crlf = FALSE ; } else if ( smtp -> eob ) { memcpy ( & scratch [ si ] , & SMTP_EOB [ eob_sent ] , smtp -> eob - eob_sent ) ; si += smtp -> eob - eob_sent ; if ( SMTP_EOB [ 0 ] == data -> req . upload_fromhere [ i ] ) smtp -> eob = 1 ; else smtp -> eob = 0 ; eob_sent = 0 ; smtp -> trailing_crlf = FALSE ; } if ( SMTP_EOB_FIND_LEN == smtp -> eob ) { memcpy ( & scratch [ si ] , & SMTP_EOB_REPL [ eob_sent ] , SMTP_EOB_REPL_LEN - eob_sent ) ; si += SMTP_EOB_REPL_LEN - eob_sent ; smtp -> eob = 0 ; eob_sent = 0 ; } else if ( ! smtp -> eob ) scratch [ si ++ ] = data -> req . upload_fromhere [ i ] ; } if ( smtp -> eob - eob_sent ) { memcpy ( & scratch [ si ] , & SMTP_EOB [ eob_sent ] , smtp -> eob - eob_sent ) ; si += smtp -> eob - eob_sent ; } if ( si != nread ) { data -> req . upload_fromhere = scratch ; data -> state . scratch = scratch ; free ( oldscratch ) ; data -> req . upload_present = si ; } else free ( newscratch ) ; return CURLE_OK ; }
CWE-125 static void voutf ( struct GlobalConfig * config , const char * prefix , const char * fmt , va_list ap ) { size_t width = ( 79 - strlen ( prefix ) ) ; if ( ! config -> mute ) { size_t len ; char * ptr ; char * print_buffer ; print_buffer = curlx_mvaprintf ( fmt , ap ) ; if ( ! print_buffer ) return ; len = strlen ( print_buffer ) ; ptr = print_buffer ; while ( len > 0 ) { fputs ( prefix , config -> errors ) ; if ( len > width ) { size_t cut = width - 1 ; while ( ! ISSPACE ( ptr [ cut ] ) && cut ) { cut -- ; } if ( 0 == cut ) cut = width - 1 ; ( void ) fwrite ( ptr , cut + 1 , 1 , config -> errors ) ; fputs ( "\\n" , config -> errors ) ; ptr += cut + 1 ; <S2SV_StartBug> len -= cut ; <S2SV_EndBug> } else { fputs ( ptr , config -> errors ) ; len = 0 ; } } curl_free ( print_buffer ) ; } }
CWE-119 CURLcode Curl_auth_create_plain_message ( struct Curl_easy * data , const char * userp , const char * passwdp , char * * outptr , size_t * outlen ) { CURLcode result ; char * plainauth ; size_t ulen ; size_t plen ; size_t plainlen ; * outlen = 0 ; * outptr = NULL ; ulen = strlen ( userp ) ; plen = strlen ( passwdp ) ; <S2SV_StartBug> if ( ( ulen > SIZE_T_MAX / 2 ) || ( plen > ( SIZE_T_MAX / 2 - 2 ) ) ) <S2SV_EndBug> return CURLE_OUT_OF_MEMORY ; plainlen = 2 * ulen + plen + 2 ; plainauth = malloc ( plainlen ) ; if ( ! plainauth ) return CURLE_OUT_OF_MEMORY ; memcpy ( plainauth , userp , ulen ) ; plainauth [ ulen ] = '\\0' ; memcpy ( plainauth + ulen + 1 , userp , ulen ) ; plainauth [ 2 * ulen + 1 ] = '\\0' ; memcpy ( plainauth + 2 * ulen + 2 , passwdp , plen ) ; result = Curl_base64_encode ( data , plainauth , plainlen , outptr , outlen ) ; free ( plainauth ) ; return result ; }
CWE-835 int WavpackSetConfiguration64 ( WavpackContext * wpc , WavpackConfig * config , int64_t total_samples , const unsigned char * chan_ids ) { uint32_t flags , bps = 0 ; uint32_t chan_mask = config -> channel_mask ; int num_chans = config -> num_channels ; <S2SV_StartBug> int i ; <S2SV_EndBug> wpc -> stream_version = ( config -> flags & CONFIG_COMPATIBLE_WRITE ) ? CUR_STREAM_VERS : MAX_STREAM_VERS ; if ( ( config -> qmode & QMODE_DSD_AUDIO ) && config -> bytes_per_sample == 1 && config -> bits_per_sample == 8 ) { # ifdef ENABLE_DSD wpc -> dsd_multiplier = 1 ; flags = DSD_FLAG ; for ( i = 14 ; i >= 0 ; -- i ) if ( config -> sample_rate % sample_rates [ i ] == 0 ) { int divisor = config -> sample_rate / sample_rates [ i ] ; if ( divisor && ( divisor & ( divisor - 1 ) ) == 0 ) { config -> sample_rate /= divisor ; wpc -> dsd_multiplier = divisor ; break ; } } if ( config -> flags & CONFIG_HYBRID_FLAG ) { strcpy ( wpc -> error_message , "hybrid<S2SV_blank>mode<S2SV_blank>not<S2SV_blank>available<S2SV_blank>for<S2SV_blank>DSD!" ) ; return FALSE ; } config -> flags &= ( CONFIG_HIGH_FLAG | CONFIG_MD5_CHECKSUM | CONFIG_PAIR_UNDEF_CHANS ) ; config -> float_norm_exp = config -> xmode = 0 ; # else strcpy ( wpc -> error_message , "libwavpack<S2SV_blank>not<S2SV_blank>configured<S2SV_blank>for<S2SV_blank>DSD!" ) ; return FALSE ; # endif } else flags = config -> bytes_per_sample - 1 ; wpc -> total_samples = total_samples ; wpc -> config . sample_rate = config -> sample_rate ; wpc -> config . num_channels = config -> num_channels ; wpc -> config . channel_mask = config -> channel_mask ; wpc -> config . bits_per_sample = config -> bits_per_sample ; wpc -> config . bytes_per_sample = config -> bytes_per_sample ; wpc -> config . block_samples = config -> block_samples ; wpc -> config . flags = config -> flags ; wpc -> config . qmode = config -> qmode ; if ( config -> flags & CONFIG_VERY_HIGH_FLAG ) wpc -> config . flags |= CONFIG_HIGH_FLAG ; for ( i = 0 ; i < 15 ; ++ i ) if ( wpc -> config . sample_rate == sample_rates [ i ] ) break ; flags |= i << SRATE_LSB ; if ( ! ( flags & DSD_FLAG ) ) { if ( config -> float_norm_exp ) { wpc -> config . float_norm_exp = config -> float_norm_exp ; wpc -> config . flags |= CONFIG_FLOAT_DATA ; flags |= FLOAT_DATA ; } else flags |= ( ( config -> bytes_per_sample * 8 ) - config -> bits_per_sample ) << SHIFT_LSB ; if ( config -> flags & CONFIG_HYBRID_FLAG ) { flags |= HYBRID_FLAG | HYBRID_BITRATE | HYBRID_BALANCE ; if ( ! ( wpc -> config . flags & CONFIG_SHAPE_OVERRIDE ) ) { wpc -> config . flags |= CONFIG_HYBRID_SHAPE | CONFIG_AUTO_SHAPING ; flags |= HYBRID_SHAPE | NEW_SHAPING ; } else if ( wpc -> config . flags & CONFIG_HYBRID_SHAPE ) { wpc -> config . shaping_weight = config -> shaping_weight ; flags |= HYBRID_SHAPE | NEW_SHAPING ; } if ( wpc -> config . flags & ( CONFIG_CROSS_DECORR | CONFIG_OPTIMIZE_WVC ) ) flags |= CROSS_DECORR ; if ( config -> flags & CONFIG_BITRATE_KBPS ) { bps = ( uint32_t ) floor ( config -> bitrate * 256000.0 / config -> sample_rate / config -> num_channels + 0.5 ) ; if ( bps > ( 64 << 8 ) ) bps = 64 << 8 ; } else bps = ( uint32_t ) floor ( config -> bitrate * 256.0 + 0.5 ) ; } else flags |= CROSS_DECORR ; if ( ! ( config -> flags & CONFIG_JOINT_OVERRIDE ) || ( config -> flags & CONFIG_JOINT_STEREO ) ) flags |= JOINT_STEREO ; if ( config -> flags & CONFIG_CREATE_WVC ) wpc -> wvc_flag = TRUE ; } if ( chan_ids ) { int lastchan = 0 , mask_copy = chan_mask ; if ( ( int ) strlen ( ( char * ) chan_ids ) > num_chans ) { strcpy ( wpc -> error_message , "chan_ids<S2SV_blank>longer<S2SV_blank>than<S2SV_blank>num<S2SV_blank>channels!" ) ; return FALSE ; } while ( * chan_ids ) if ( * chan_ids <= 32 && * chan_ids > lastchan && ( mask_copy & ( 1 << ( * chan_ids - 1 ) ) ) ) { mask_copy &= ~ ( 1 << ( * chan_ids - 1 ) ) ; lastchan = * chan_ids ++ ; } else break ; for ( i = 0 ; chan_ids [ i ] ; i ++ ) if ( chan_ids [ i ] != 0xff ) { wpc -> channel_identities = ( unsigned char * ) strdup ( ( char * ) chan_ids ) ; break ; } } for ( wpc -> current_stream = 0 ; num_chans ; wpc -> current_stream ++ ) { WavpackStream * wps = malloc ( sizeof ( WavpackStream ) ) ; unsigned char left_chan_id = 0 , right_chan_id = 0 ; int pos , chans = 1 ; wpc -> streams = realloc ( wpc -> streams , ( wpc -> current_stream + 1 ) * sizeof ( wpc -> streams [ 0 ] ) ) ; wpc -> streams [ wpc -> current_stream ] = wps ; CLEAR ( * wps ) ; if ( chan_mask ) for ( pos = 0 ; pos < 32 ; ++ pos ) if ( chan_mask & ( 1 << pos ) ) { if ( left_chan_id ) { right_chan_id = pos + 1 ; break ; } else { chan_mask &= ~ ( 1 << pos ) ; left_chan_id = pos + 1 ; } } while ( ! right_chan_id && chan_ids && * chan_ids ) if ( left_chan_id ) right_chan_id = * chan_ids ; else left_chan_id = * chan_ids ++ ; if ( ! left_chan_id ) left_chan_id = right_chan_id = 0xff ; else if ( ! right_chan_id ) right_chan_id = 0xff ; if ( num_chans >= 2 ) { if ( ( config -> flags & CONFIG_PAIR_UNDEF_CHANS ) && left_chan_id == 0xff && right_chan_id == 0xff ) chans = 2 ; else for ( i = 0 ; i < NUM_STEREO_PAIRS ; ++ i ) if ( ( left_chan_id == stereo_pairs [ i ] . a && right_chan_id == stereo_pairs [ i ] . b ) || ( left_chan_id == stereo_pairs [ i ] . b && right_chan_id == stereo_pairs [ i ] . a ) ) { if ( right_chan_id <= 32 && ( chan_mask & ( 1 << ( right_chan_id - 1 ) ) ) ) chan_mask &= ~ ( 1 << ( right_chan_id - 1 ) ) ; else if ( chan_ids && * chan_ids == right_chan_id ) chan_ids ++ ; chans = 2 ; break ; } } num_chans -= chans ; if ( num_chans && wpc -> current_stream == NEW_MAX_STREAMS - 1 ) break ; memcpy ( wps -> wphdr . ckID , "wvpk" , 4 ) ; wps -> wphdr . ckSize = sizeof ( WavpackHeader ) - 8 ; SET_TOTAL_SAMPLES ( wps -> wphdr , wpc -> total_samples ) ; wps -> wphdr . version = wpc -> stream_version ; wps -> wphdr . flags = flags ; wps -> bits = bps ; if ( ! wpc -> current_stream ) wps -> wphdr . flags |= INITIAL_BLOCK ; if ( ! num_chans ) wps -> wphdr . flags |= FINAL_BLOCK ; if ( chans == 1 ) { wps -> wphdr . flags &= ~ ( JOINT_STEREO | CROSS_DECORR | HYBRID_BALANCE ) ; wps -> wphdr . flags |= MONO_FLAG ; } } wpc -> num_streams = wpc -> current_stream ; wpc -> current_stream = 0 ; if ( num_chans ) { strcpy ( wpc -> error_message , "too<S2SV_blank>many<S2SV_blank>channels!" ) ; return FALSE ; } if ( config -> flags & CONFIG_EXTRA_MODE ) wpc -> config . xmode = config -> xmode ? config -> xmode : 1 ; return TRUE ; }
CWE-119 int ParseRiffHeaderConfig ( FILE * infile , char * infilename , char * fourcc , WavpackContext * wpc , WavpackConfig * config ) { <S2SV_StartBug> int is_rf64 = ! strncmp ( fourcc , "RF64" , 4 ) , got_ds64 = 0 ; <S2SV_EndBug> int64_t total_samples = 0 , infilesize ; RiffChunkHeader riff_chunk_header ; ChunkHeader chunk_header ; WaveHeader WaveHeader ; DS64Chunk ds64_chunk ; uint32_t bcount ; CLEAR ( WaveHeader ) ; CLEAR ( ds64_chunk ) ; infilesize = DoGetFileSize ( infile ) ; if ( ! is_rf64 && infilesize >= 4294967296LL && ! ( config -> qmode & QMODE_IGNORE_LENGTH ) ) { error_line ( "can\'t<S2SV_blank>handle<S2SV_blank>.WAV<S2SV_blank>files<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>4<S2SV_blank>GB<S2SV_blank>(non-standard)!" ) ; return WAVPACK_SOFT_ERROR ; } memcpy ( & riff_chunk_header , fourcc , 4 ) ; if ( ( ! DoReadFile ( infile , ( ( char * ) & riff_chunk_header ) + 4 , sizeof ( RiffChunkHeader ) - 4 , & bcount ) || bcount != sizeof ( RiffChunkHeader ) - 4 || strncmp ( riff_chunk_header . formType , "WAVE" , 4 ) ) ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & riff_chunk_header , sizeof ( RiffChunkHeader ) ) ) { error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } while ( 1 ) { if ( ! DoReadFile ( infile , & chunk_header , sizeof ( ChunkHeader ) , & bcount ) || bcount != sizeof ( ChunkHeader ) ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & chunk_header , sizeof ( ChunkHeader ) ) ) { error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackLittleEndianToNative ( & chunk_header , ChunkHeaderFormat ) ; if ( ! strncmp ( chunk_header . ckID , "ds64" , 4 ) ) { if ( chunk_header . ckSize < sizeof ( DS64Chunk ) || ! DoReadFile ( infile , & ds64_chunk , sizeof ( DS64Chunk ) , & bcount ) || bcount != sizeof ( DS64Chunk ) ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & ds64_chunk , sizeof ( DS64Chunk ) ) ) { error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } got_ds64 = 1 ; WavpackLittleEndianToNative ( & ds64_chunk , DS64ChunkFormat ) ; if ( debug_logging_mode ) error_line ( "DS64:<S2SV_blank>riffSize<S2SV_blank>=<S2SV_blank>%lld,<S2SV_blank>dataSize<S2SV_blank>=<S2SV_blank>%lld,<S2SV_blank>sampleCount<S2SV_blank>=<S2SV_blank>%lld,<S2SV_blank>table_length<S2SV_blank>=<S2SV_blank>%d" , ( long long ) ds64_chunk . riffSize64 , ( long long ) ds64_chunk . dataSize64 , ( long long ) ds64_chunk . sampleCount64 , ds64_chunk . tableLength ) ; if ( ds64_chunk . tableLength * sizeof ( CS64Chunk ) != chunk_header . ckSize - sizeof ( DS64Chunk ) ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } while ( ds64_chunk . tableLength -- ) { CS64Chunk cs64_chunk ; if ( ! DoReadFile ( infile , & cs64_chunk , sizeof ( CS64Chunk ) , & bcount ) || bcount != sizeof ( CS64Chunk ) || ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & cs64_chunk , sizeof ( CS64Chunk ) ) ) ) { error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } } } else if ( ! strncmp ( chunk_header . ckID , "fmt<S2SV_blank>" , 4 ) ) { <S2SV_StartBug> int supported = TRUE , format ; <S2SV_EndBug> if ( chunk_header . ckSize < 16 || chunk_header . ckSize > sizeof ( WaveHeader ) || ! DoReadFile ( infile , & WaveHeader , chunk_header . ckSize , & bcount ) || bcount != chunk_header . ckSize ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & WaveHeader , chunk_header . ckSize ) ) { error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackLittleEndianToNative ( & WaveHeader , WaveHeaderFormat ) ; if ( debug_logging_mode ) { error_line ( "format<S2SV_blank>tag<S2SV_blank>size<S2SV_blank>=<S2SV_blank>%d" , chunk_header . ckSize ) ; error_line ( "FormatTag<S2SV_blank>=<S2SV_blank>%x,<S2SV_blank>NumChannels<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>BitsPerSample<S2SV_blank>=<S2SV_blank>%d" , WaveHeader . FormatTag , WaveHeader . NumChannels , WaveHeader . BitsPerSample ) ; error_line ( "BlockAlign<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>SampleRate<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>BytesPerSecond<S2SV_blank>=<S2SV_blank>%d" , WaveHeader . BlockAlign , WaveHeader . SampleRate , WaveHeader . BytesPerSecond ) ; if ( chunk_header . ckSize > 16 ) error_line ( "cbSize<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>ValidBitsPerSample<S2SV_blank>=<S2SV_blank>%d" , WaveHeader . cbSize , WaveHeader . ValidBitsPerSample ) ; if ( chunk_header . ckSize > 20 ) error_line ( "ChannelMask<S2SV_blank>=<S2SV_blank>%x,<S2SV_blank>SubFormat<S2SV_blank>=<S2SV_blank>%d" , WaveHeader . ChannelMask , WaveHeader . SubFormat ) ; } if ( chunk_header . ckSize > 16 && WaveHeader . cbSize == 2 ) config -> qmode |= QMODE_ADOBE_MODE ; format = ( WaveHeader . FormatTag == 0xfffe && chunk_header . ckSize == 40 ) ? WaveHeader . SubFormat : WaveHeader . FormatTag ; config -> bits_per_sample = ( chunk_header . ckSize == 40 && WaveHeader . ValidBitsPerSample ) ? WaveHeader . ValidBitsPerSample : WaveHeader . BitsPerSample ; if ( format != 1 && format != 3 ) supported = FALSE ; if ( format == 3 && config -> bits_per_sample != 32 ) supported = FALSE ; if ( ! WaveHeader . NumChannels || WaveHeader . NumChannels > 256 || WaveHeader . BlockAlign / WaveHeader . NumChannels < ( config -> bits_per_sample + 7 ) / 8 || WaveHeader . BlockAlign / WaveHeader . NumChannels > 4 || WaveHeader . BlockAlign % WaveHeader . NumChannels ) supported = FALSE ; if ( config -> bits_per_sample < 1 || config -> bits_per_sample > 32 ) supported = FALSE ; if ( ! supported ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>an<S2SV_blank>unsupported<S2SV_blank>.WAV<S2SV_blank>format!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( chunk_header . ckSize < 40 ) { if ( ! config -> channel_mask && ! ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) { if ( WaveHeader . NumChannels <= 2 ) config -> channel_mask = 0x5 - WaveHeader . NumChannels ; else if ( WaveHeader . NumChannels <= 18 ) config -> channel_mask = ( 1 << WaveHeader . NumChannels ) - 1 ; else config -> channel_mask = 0x3ffff ; } } else if ( WaveHeader . ChannelMask && ( config -> channel_mask || ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) ) { error_line ( "this<S2SV_blank>WAV<S2SV_blank>file<S2SV_blank>already<S2SV_blank>has<S2SV_blank>channel<S2SV_blank>order<S2SV_blank>information!" ) ; return WAVPACK_SOFT_ERROR ; } else if ( WaveHeader . ChannelMask ) config -> channel_mask = WaveHeader . ChannelMask ; if ( format == 3 ) config -> float_norm_exp = 127 ; else if ( ( config -> qmode & QMODE_ADOBE_MODE ) && WaveHeader . BlockAlign / WaveHeader . NumChannels == 4 ) { if ( WaveHeader . BitsPerSample == 24 ) config -> float_norm_exp = 127 + 23 ; else if ( WaveHeader . BitsPerSample == 32 ) config -> float_norm_exp = 127 + 15 ; } if ( debug_logging_mode ) { if ( config -> float_norm_exp == 127 ) error_line ( "data<S2SV_blank>format:<S2SV_blank>normalized<S2SV_blank>32-bit<S2SV_blank>floating<S2SV_blank>point" ) ; else if ( config -> float_norm_exp ) error_line ( "data<S2SV_blank>format:<S2SV_blank>32-bit<S2SV_blank>floating<S2SV_blank>point<S2SV_blank>(Audition<S2SV_blank>%d:%d<S2SV_blank>float<S2SV_blank>type<S2SV_blank>1)" , config -> float_norm_exp - 126 , 150 - config -> float_norm_exp ) ; else error_line ( "data<S2SV_blank>format:<S2SV_blank>%d-bit<S2SV_blank>integers<S2SV_blank>stored<S2SV_blank>in<S2SV_blank>%d<S2SV_blank>byte(s)" , config -> bits_per_sample , WaveHeader . BlockAlign / WaveHeader . NumChannels ) ; } } else if ( ! strncmp ( chunk_header . ckID , "data" , 4 ) ) { int64_t data_chunk_size = ( got_ds64 && chunk_header . ckSize == ( uint32_t ) - 1 ) ? ds64_chunk . dataSize64 : chunk_header . ckSize ; if ( ! WaveHeader . NumChannels || ( is_rf64 && ! got_ds64 ) ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( infilesize && ! ( config -> qmode & QMODE_IGNORE_LENGTH ) && infilesize - data_chunk_size > 16777216 ) { error_line ( "this<S2SV_blank>.WAV<S2SV_blank>file<S2SV_blank>has<S2SV_blank>over<S2SV_blank>16<S2SV_blank>MB<S2SV_blank>of<S2SV_blank>extra<S2SV_blank>RIFF<S2SV_blank>data,<S2SV_blank>probably<S2SV_blank>is<S2SV_blank>corrupt!" ) ; return WAVPACK_SOFT_ERROR ; } if ( config -> qmode & QMODE_IGNORE_LENGTH ) { if ( infilesize && DoGetFilePosition ( infile ) != - 1 ) total_samples = ( infilesize - DoGetFilePosition ( infile ) ) / WaveHeader . BlockAlign ; else total_samples = - 1 ; } else { total_samples = data_chunk_size / WaveHeader . BlockAlign ; if ( got_ds64 && total_samples != ds64_chunk . sampleCount64 ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( ! total_samples ) { error_line ( "this<S2SV_blank>.WAV<S2SV_blank>file<S2SV_blank>has<S2SV_blank>no<S2SV_blank>audio<S2SV_blank>samples,<S2SV_blank>probably<S2SV_blank>is<S2SV_blank>corrupt!" ) ; return WAVPACK_SOFT_ERROR ; } if ( total_samples > MAX_WAVPACK_SAMPLES ) { error_line ( "%s<S2SV_blank>has<S2SV_blank>too<S2SV_blank>many<S2SV_blank>samples<S2SV_blank>for<S2SV_blank>WavPack!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } } config -> bytes_per_sample = WaveHeader . BlockAlign / WaveHeader . NumChannels ; config -> num_channels = WaveHeader . NumChannels ; config -> sample_rate = WaveHeader . SampleRate ; break ; } else { int bytes_to_copy = ( chunk_header . ckSize + 1 ) & ~ 1L ; char * buff ; if ( bytes_to_copy < 0 || bytes_to_copy > 4194304 ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } buff = malloc ( bytes_to_copy ) ; if ( debug_logging_mode ) error_line ( "extra<S2SV_blank>unknown<S2SV_blank>chunk<S2SV_blank>\\"%c%c%c%c\\"<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes" , chunk_header . ckID [ 0 ] , chunk_header . ckID [ 1 ] , chunk_header . ckID [ 2 ] , chunk_header . ckID [ 3 ] , chunk_header . ckSize ) ; if ( ! DoReadFile ( infile , buff , bytes_to_copy , & bcount ) || bcount != bytes_to_copy || ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , buff , bytes_to_copy ) ) ) { error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; free ( buff ) ; return WAVPACK_SOFT_ERROR ; } free ( buff ) ; } } if ( ! WavpackSetConfiguration64 ( wpc , config , total_samples , NULL ) ) { error_line ( "%s:<S2SV_blank>%s" , infilename , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } return WAVPACK_NO_ERROR ; }
CWE-119 int ParseWave64HeaderConfig ( FILE * infile , char * infilename , char * fourcc , WavpackContext * wpc , WavpackConfig * config ) { int64_t total_samples = 0 , infilesize ; Wave64ChunkHeader chunk_header ; Wave64FileHeader filehdr ; WaveHeader WaveHeader ; <S2SV_StartBug> uint32_t bcount ; <S2SV_EndBug> infilesize = DoGetFileSize ( infile ) ; memcpy ( & filehdr , fourcc , 4 ) ; if ( ! DoReadFile ( infile , ( ( char * ) & filehdr ) + 4 , sizeof ( Wave64FileHeader ) - 4 , & bcount ) || bcount != sizeof ( Wave64FileHeader ) - 4 || memcmp ( filehdr . ckID , riff_guid , sizeof ( riff_guid ) ) || memcmp ( filehdr . formType , wave_guid , sizeof ( wave_guid ) ) ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & filehdr , sizeof ( filehdr ) ) ) { error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } # if 1 WavpackLittleEndianToNative ( & filehdr , Wave64ChunkHeaderFormat ) ; if ( infilesize && ! ( config -> qmode & QMODE_IGNORE_LENGTH ) && filehdr . ckSize && filehdr . ckSize + 1 && filehdr . ckSize != infilesize ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } # endif while ( 1 ) { if ( ! DoReadFile ( infile , & chunk_header , sizeof ( Wave64ChunkHeader ) , & bcount ) || bcount != sizeof ( Wave64ChunkHeader ) ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & chunk_header , sizeof ( Wave64ChunkHeader ) ) ) { error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackLittleEndianToNative ( & chunk_header , Wave64ChunkHeaderFormat ) ; chunk_header . ckSize -= sizeof ( chunk_header ) ; if ( ! memcmp ( chunk_header . ckID , fmt_guid , sizeof ( fmt_guid ) ) ) { <S2SV_StartBug> int supported = TRUE , format ; <S2SV_EndBug> chunk_header . ckSize = ( chunk_header . ckSize + 7 ) & ~ 7L ; if ( chunk_header . ckSize < 16 || chunk_header . ckSize > sizeof ( WaveHeader ) || ! DoReadFile ( infile , & WaveHeader , ( uint32_t ) chunk_header . ckSize , & bcount ) || bcount != chunk_header . ckSize ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & WaveHeader , ( uint32_t ) chunk_header . ckSize ) ) { error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackLittleEndianToNative ( & WaveHeader , WaveHeaderFormat ) ; if ( debug_logging_mode ) { error_line ( "format<S2SV_blank>tag<S2SV_blank>size<S2SV_blank>=<S2SV_blank>%d" , chunk_header . ckSize ) ; error_line ( "FormatTag<S2SV_blank>=<S2SV_blank>%x,<S2SV_blank>NumChannels<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>BitsPerSample<S2SV_blank>=<S2SV_blank>%d" , WaveHeader . FormatTag , WaveHeader . NumChannels , WaveHeader . BitsPerSample ) ; error_line ( "BlockAlign<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>SampleRate<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>BytesPerSecond<S2SV_blank>=<S2SV_blank>%d" , WaveHeader . BlockAlign , WaveHeader . SampleRate , WaveHeader . BytesPerSecond ) ; if ( chunk_header . ckSize > 16 ) error_line ( "cbSize<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>ValidBitsPerSample<S2SV_blank>=<S2SV_blank>%d" , WaveHeader . cbSize , WaveHeader . ValidBitsPerSample ) ; if ( chunk_header . ckSize > 20 ) error_line ( "ChannelMask<S2SV_blank>=<S2SV_blank>%x,<S2SV_blank>SubFormat<S2SV_blank>=<S2SV_blank>%d" , WaveHeader . ChannelMask , WaveHeader . SubFormat ) ; } if ( chunk_header . ckSize > 16 && WaveHeader . cbSize == 2 ) config -> qmode |= QMODE_ADOBE_MODE ; format = ( WaveHeader . FormatTag == 0xfffe && chunk_header . ckSize == 40 ) ? WaveHeader . SubFormat : WaveHeader . FormatTag ; config -> bits_per_sample = ( chunk_header . ckSize == 40 && WaveHeader . ValidBitsPerSample ) ? WaveHeader . ValidBitsPerSample : WaveHeader . BitsPerSample ; if ( format != 1 && format != 3 ) supported = FALSE ; if ( format == 3 && config -> bits_per_sample != 32 ) supported = FALSE ; if ( ! WaveHeader . NumChannels || WaveHeader . NumChannels > 256 || WaveHeader . BlockAlign / WaveHeader . NumChannels < ( config -> bits_per_sample + 7 ) / 8 || WaveHeader . BlockAlign / WaveHeader . NumChannels > 4 || WaveHeader . BlockAlign % WaveHeader . NumChannels ) supported = FALSE ; if ( config -> bits_per_sample < 1 || config -> bits_per_sample > 32 ) supported = FALSE ; if ( ! supported ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>an<S2SV_blank>unsupported<S2SV_blank>.W64<S2SV_blank>format!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( chunk_header . ckSize < 40 ) { if ( ! config -> channel_mask && ! ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) { if ( WaveHeader . NumChannels <= 2 ) config -> channel_mask = 0x5 - WaveHeader . NumChannels ; else if ( WaveHeader . NumChannels <= 18 ) config -> channel_mask = ( 1 << WaveHeader . NumChannels ) - 1 ; else config -> channel_mask = 0x3ffff ; } } else if ( WaveHeader . ChannelMask && ( config -> channel_mask || ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) ) { error_line ( "this<S2SV_blank>W64<S2SV_blank>file<S2SV_blank>already<S2SV_blank>has<S2SV_blank>channel<S2SV_blank>order<S2SV_blank>information!" ) ; return WAVPACK_SOFT_ERROR ; } else if ( WaveHeader . ChannelMask ) config -> channel_mask = WaveHeader . ChannelMask ; if ( format == 3 ) config -> float_norm_exp = 127 ; else if ( ( config -> qmode & QMODE_ADOBE_MODE ) && WaveHeader . BlockAlign / WaveHeader . NumChannels == 4 ) { if ( WaveHeader . BitsPerSample == 24 ) config -> float_norm_exp = 127 + 23 ; else if ( WaveHeader . BitsPerSample == 32 ) config -> float_norm_exp = 127 + 15 ; } if ( debug_logging_mode ) { if ( config -> float_norm_exp == 127 ) error_line ( "data<S2SV_blank>format:<S2SV_blank>normalized<S2SV_blank>32-bit<S2SV_blank>floating<S2SV_blank>point" ) ; else error_line ( "data<S2SV_blank>format:<S2SV_blank>%d-bit<S2SV_blank>integers<S2SV_blank>stored<S2SV_blank>in<S2SV_blank>%d<S2SV_blank>byte(s)" , config -> bits_per_sample , WaveHeader . BlockAlign / WaveHeader . NumChannels ) ; } } else if ( ! memcmp ( chunk_header . ckID , data_guid , sizeof ( data_guid ) ) ) { if ( ! WaveHeader . NumChannels ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( ( config -> qmode & QMODE_IGNORE_LENGTH ) || chunk_header . ckSize <= 0 ) { config -> qmode |= QMODE_IGNORE_LENGTH ; if ( infilesize && DoGetFilePosition ( infile ) != - 1 ) total_samples = ( infilesize - DoGetFilePosition ( infile ) ) / WaveHeader . BlockAlign ; else total_samples = - 1 ; } else { if ( infilesize && infilesize - chunk_header . ckSize > 16777216 ) { error_line ( "this<S2SV_blank>.W64<S2SV_blank>file<S2SV_blank>has<S2SV_blank>over<S2SV_blank>16<S2SV_blank>MB<S2SV_blank>of<S2SV_blank>extra<S2SV_blank>RIFF<S2SV_blank>data,<S2SV_blank>probably<S2SV_blank>is<S2SV_blank>corrupt!" ) ; return WAVPACK_SOFT_ERROR ; } total_samples = chunk_header . ckSize / WaveHeader . BlockAlign ; if ( ! total_samples ) { error_line ( "this<S2SV_blank>.W64<S2SV_blank>file<S2SV_blank>has<S2SV_blank>no<S2SV_blank>audio<S2SV_blank>samples,<S2SV_blank>probably<S2SV_blank>is<S2SV_blank>corrupt!" ) ; return WAVPACK_SOFT_ERROR ; } if ( total_samples > MAX_WAVPACK_SAMPLES ) { error_line ( "%s<S2SV_blank>has<S2SV_blank>too<S2SV_blank>many<S2SV_blank>samples<S2SV_blank>for<S2SV_blank>WavPack!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } } config -> bytes_per_sample = WaveHeader . BlockAlign / WaveHeader . NumChannels ; config -> num_channels = WaveHeader . NumChannels ; config -> sample_rate = WaveHeader . SampleRate ; break ; } else { int bytes_to_copy = ( chunk_header . ckSize + 7 ) & ~ 7L ; char * buff ; if ( bytes_to_copy < 0 || bytes_to_copy > 4194304 ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } buff = malloc ( bytes_to_copy ) ; if ( debug_logging_mode ) error_line ( "extra<S2SV_blank>unknown<S2SV_blank>chunk<S2SV_blank>\\"%c%c%c%c\\"<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes" , chunk_header . ckID [ 0 ] , chunk_header . ckID [ 1 ] , chunk_header . ckID [ 2 ] , chunk_header . ckID [ 3 ] , chunk_header . ckSize ) ; if ( ! DoReadFile ( infile , buff , bytes_to_copy , & bcount ) || bcount != bytes_to_copy || ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , buff , bytes_to_copy ) ) ) { error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; free ( buff ) ; return WAVPACK_SOFT_ERROR ; } free ( buff ) ; } } if ( ! WavpackSetConfiguration64 ( wpc , config , total_samples , NULL ) ) { error_line ( "%s:<S2SV_blank>%s" , infilename , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } return WAVPACK_NO_ERROR ; }
CWE-665 int ParseWave64HeaderConfig ( FILE * infile , char * infilename , char * fourcc , WavpackContext * wpc , WavpackConfig * config ) { int64_t total_samples = 0 , infilesize ; Wave64ChunkHeader chunk_header ; Wave64FileHeader filehdr ; WaveHeader WaveHeader ; int format_chunk = 0 ; <S2SV_StartBug> uint32_t bcount ; <S2SV_EndBug> infilesize = DoGetFileSize ( infile ) ; memcpy ( & filehdr , fourcc , 4 ) ; if ( ! DoReadFile ( infile , ( ( char * ) & filehdr ) + 4 , sizeof ( Wave64FileHeader ) - 4 , & bcount ) || bcount != sizeof ( Wave64FileHeader ) - 4 || memcmp ( filehdr . ckID , riff_guid , sizeof ( riff_guid ) ) || memcmp ( filehdr . formType , wave_guid , sizeof ( wave_guid ) ) ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & filehdr , sizeof ( filehdr ) ) ) { error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } # if 1 WavpackLittleEndianToNative ( & filehdr , Wave64ChunkHeaderFormat ) ; if ( infilesize && ! ( config -> qmode & QMODE_IGNORE_LENGTH ) && filehdr . ckSize && filehdr . ckSize + 1 && filehdr . ckSize != infilesize ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } # endif while ( 1 ) { if ( ! DoReadFile ( infile , & chunk_header , sizeof ( Wave64ChunkHeader ) , & bcount ) || bcount != sizeof ( Wave64ChunkHeader ) ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & chunk_header , sizeof ( Wave64ChunkHeader ) ) ) { error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackLittleEndianToNative ( & chunk_header , Wave64ChunkHeaderFormat ) ; chunk_header . ckSize -= sizeof ( chunk_header ) ; if ( ! memcmp ( chunk_header . ckID , fmt_guid , sizeof ( fmt_guid ) ) ) { int supported = TRUE , format ; if ( format_chunk ++ ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } chunk_header . ckSize = ( chunk_header . ckSize + 7 ) & ~ 7L ; if ( chunk_header . ckSize < 16 || chunk_header . ckSize > sizeof ( WaveHeader ) || ! DoReadFile ( infile , & WaveHeader , ( uint32_t ) chunk_header . ckSize , & bcount ) || bcount != chunk_header . ckSize ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & WaveHeader , ( uint32_t ) chunk_header . ckSize ) ) { error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackLittleEndianToNative ( & WaveHeader , WaveHeaderFormat ) ; if ( debug_logging_mode ) { error_line ( "format<S2SV_blank>tag<S2SV_blank>size<S2SV_blank>=<S2SV_blank>%d" , chunk_header . ckSize ) ; error_line ( "FormatTag<S2SV_blank>=<S2SV_blank>%x,<S2SV_blank>NumChannels<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>BitsPerSample<S2SV_blank>=<S2SV_blank>%d" , WaveHeader . FormatTag , WaveHeader . NumChannels , WaveHeader . BitsPerSample ) ; error_line ( "BlockAlign<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>SampleRate<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>BytesPerSecond<S2SV_blank>=<S2SV_blank>%d" , WaveHeader . BlockAlign , WaveHeader . SampleRate , WaveHeader . BytesPerSecond ) ; if ( chunk_header . ckSize > 16 ) error_line ( "cbSize<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>ValidBitsPerSample<S2SV_blank>=<S2SV_blank>%d" , WaveHeader . cbSize , WaveHeader . ValidBitsPerSample ) ; if ( chunk_header . ckSize > 20 ) error_line ( "ChannelMask<S2SV_blank>=<S2SV_blank>%x,<S2SV_blank>SubFormat<S2SV_blank>=<S2SV_blank>%d" , WaveHeader . ChannelMask , WaveHeader . SubFormat ) ; } if ( chunk_header . ckSize > 16 && WaveHeader . cbSize == 2 ) config -> qmode |= QMODE_ADOBE_MODE ; format = ( WaveHeader . FormatTag == 0xfffe && chunk_header . ckSize == 40 ) ? WaveHeader . SubFormat : WaveHeader . FormatTag ; config -> bits_per_sample = ( chunk_header . ckSize == 40 && WaveHeader . ValidBitsPerSample ) ? WaveHeader . ValidBitsPerSample : WaveHeader . BitsPerSample ; if ( format != 1 && format != 3 ) supported = FALSE ; if ( format == 3 && config -> bits_per_sample != 32 ) supported = FALSE ; if ( ! WaveHeader . NumChannels || WaveHeader . NumChannels > 256 || WaveHeader . BlockAlign / WaveHeader . NumChannels < ( config -> bits_per_sample + 7 ) / 8 || WaveHeader . BlockAlign / WaveHeader . NumChannels > 4 || WaveHeader . BlockAlign % WaveHeader . NumChannels ) supported = FALSE ; if ( config -> bits_per_sample < 1 || config -> bits_per_sample > 32 ) supported = FALSE ; if ( ! supported ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>an<S2SV_blank>unsupported<S2SV_blank>.W64<S2SV_blank>format!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( chunk_header . ckSize < 40 ) { if ( ! config -> channel_mask && ! ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) { if ( WaveHeader . NumChannels <= 2 ) config -> channel_mask = 0x5 - WaveHeader . NumChannels ; else if ( WaveHeader . NumChannels <= 18 ) config -> channel_mask = ( 1 << WaveHeader . NumChannels ) - 1 ; else config -> channel_mask = 0x3ffff ; } } else if ( WaveHeader . ChannelMask && ( config -> channel_mask || ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) ) { error_line ( "this<S2SV_blank>W64<S2SV_blank>file<S2SV_blank>already<S2SV_blank>has<S2SV_blank>channel<S2SV_blank>order<S2SV_blank>information!" ) ; return WAVPACK_SOFT_ERROR ; } else if ( WaveHeader . ChannelMask ) config -> channel_mask = WaveHeader . ChannelMask ; if ( format == 3 ) config -> float_norm_exp = 127 ; else if ( ( config -> qmode & QMODE_ADOBE_MODE ) && WaveHeader . BlockAlign / WaveHeader . NumChannels == 4 ) { if ( WaveHeader . BitsPerSample == 24 ) config -> float_norm_exp = 127 + 23 ; else if ( WaveHeader . BitsPerSample == 32 ) config -> float_norm_exp = 127 + 15 ; } if ( debug_logging_mode ) { if ( config -> float_norm_exp == 127 ) error_line ( "data<S2SV_blank>format:<S2SV_blank>normalized<S2SV_blank>32-bit<S2SV_blank>floating<S2SV_blank>point" ) ; else error_line ( "data<S2SV_blank>format:<S2SV_blank>%d-bit<S2SV_blank>integers<S2SV_blank>stored<S2SV_blank>in<S2SV_blank>%d<S2SV_blank>byte(s)" , config -> bits_per_sample , WaveHeader . BlockAlign / WaveHeader . NumChannels ) ; } } else if ( ! memcmp ( chunk_header . ckID , data_guid , sizeof ( data_guid ) ) ) { if ( ! WaveHeader . NumChannels ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( ( config -> qmode & QMODE_IGNORE_LENGTH ) || chunk_header . ckSize <= 0 ) { config -> qmode |= QMODE_IGNORE_LENGTH ; if ( infilesize && DoGetFilePosition ( infile ) != - 1 ) total_samples = ( infilesize - DoGetFilePosition ( infile ) ) / WaveHeader . BlockAlign ; else total_samples = - 1 ; } else { if ( infilesize && infilesize - chunk_header . ckSize > 16777216 ) { error_line ( "this<S2SV_blank>.W64<S2SV_blank>file<S2SV_blank>has<S2SV_blank>over<S2SV_blank>16<S2SV_blank>MB<S2SV_blank>of<S2SV_blank>extra<S2SV_blank>RIFF<S2SV_blank>data,<S2SV_blank>probably<S2SV_blank>is<S2SV_blank>corrupt!" ) ; return WAVPACK_SOFT_ERROR ; } total_samples = chunk_header . ckSize / WaveHeader . BlockAlign ; if ( ! total_samples ) { error_line ( "this<S2SV_blank>.W64<S2SV_blank>file<S2SV_blank>has<S2SV_blank>no<S2SV_blank>audio<S2SV_blank>samples,<S2SV_blank>probably<S2SV_blank>is<S2SV_blank>corrupt!" ) ; return WAVPACK_SOFT_ERROR ; } if ( total_samples > MAX_WAVPACK_SAMPLES ) { error_line ( "%s<S2SV_blank>has<S2SV_blank>too<S2SV_blank>many<S2SV_blank>samples<S2SV_blank>for<S2SV_blank>WavPack!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } } config -> bytes_per_sample = WaveHeader . BlockAlign / WaveHeader . NumChannels ; config -> num_channels = WaveHeader . NumChannels ; config -> sample_rate = WaveHeader . SampleRate ; break ; } else { int bytes_to_copy = ( chunk_header . ckSize + 7 ) & ~ 7L ; char * buff ; if ( bytes_to_copy < 0 || bytes_to_copy > 4194304 ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } buff = malloc ( bytes_to_copy ) ; if ( debug_logging_mode ) error_line ( "extra<S2SV_blank>unknown<S2SV_blank>chunk<S2SV_blank>\\"%c%c%c%c\\"<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes" , chunk_header . ckID [ 0 ] , chunk_header . ckID [ 1 ] , chunk_header . ckID [ 2 ] , chunk_header . ckID [ 3 ] , chunk_header . ckSize ) ; if ( ! DoReadFile ( infile , buff , bytes_to_copy , & bcount ) || bcount != bytes_to_copy || ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , buff , bytes_to_copy ) ) ) { error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; free ( buff ) ; return WAVPACK_SOFT_ERROR ; } free ( buff ) ; } } if ( ! WavpackSetConfiguration64 ( wpc , config , total_samples , NULL ) ) { error_line ( "%s:<S2SV_blank>%s" , infilename , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } return WAVPACK_NO_ERROR ; }
CWE-125 int ParseDsdiffHeaderConfig ( FILE * infile , char * infilename , char * fourcc , WavpackContext * wpc , WavpackConfig * config ) { int64_t infilesize , total_samples ; DFFFileHeader dff_file_header ; DFFChunkHeader dff_chunk_header ; uint32_t bcount ; infilesize = DoGetFileSize ( infile ) ; memcpy ( & dff_file_header , fourcc , 4 ) ; if ( ( ! DoReadFile ( infile , ( ( char * ) & dff_file_header ) + 4 , sizeof ( DFFFileHeader ) - 4 , & bcount ) || bcount != sizeof ( DFFFileHeader ) - 4 ) || strncmp ( dff_file_header . formType , "DSD<S2SV_blank>" , 4 ) ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & dff_file_header , sizeof ( DFFFileHeader ) ) ) { error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } # if 1 WavpackBigEndianToNative ( & dff_file_header , DFFFileHeaderFormat ) ; if ( infilesize && ! ( config -> qmode & QMODE_IGNORE_LENGTH ) && dff_file_header . ckDataSize && dff_file_header . ckDataSize + 1 && dff_file_header . ckDataSize + 12 != infilesize ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file<S2SV_blank>(by<S2SV_blank>total<S2SV_blank>size)!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( debug_logging_mode ) error_line ( "file<S2SV_blank>header<S2SV_blank>indicated<S2SV_blank>length<S2SV_blank>=<S2SV_blank>%lld" , dff_file_header . ckDataSize ) ; # endif while ( 1 ) { if ( ! DoReadFile ( infile , & dff_chunk_header , sizeof ( DFFChunkHeader ) , & bcount ) || bcount != sizeof ( DFFChunkHeader ) ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & dff_chunk_header , sizeof ( DFFChunkHeader ) ) ) { error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackBigEndianToNative ( & dff_chunk_header , DFFChunkHeaderFormat ) ; if ( debug_logging_mode ) error_line ( "chunk<S2SV_blank>header<S2SV_blank>indicated<S2SV_blank>length<S2SV_blank>=<S2SV_blank>%lld" , dff_chunk_header . ckDataSize ) ; if ( ! strncmp ( dff_chunk_header . ckID , "FVER" , 4 ) ) { uint32_t version ; if ( dff_chunk_header . ckDataSize != sizeof ( version ) || ! DoReadFile ( infile , & version , sizeof ( version ) , & bcount ) || bcount != sizeof ( version ) ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & version , sizeof ( version ) ) ) { error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackBigEndianToNative ( & version , "L" ) ; if ( debug_logging_mode ) error_line ( "dsdiff<S2SV_blank>file<S2SV_blank>version<S2SV_blank>=<S2SV_blank>0x%08x" , version ) ; } else if ( ! strncmp ( dff_chunk_header . ckID , "PROP" , 4 ) ) { <S2SV_StartBug> char * prop_chunk = malloc ( ( size_t ) dff_chunk_header . ckDataSize ) ; <S2SV_EndBug> if ( ! DoReadFile ( infile , prop_chunk , ( uint32_t ) dff_chunk_header . ckDataSize , & bcount ) || bcount != dff_chunk_header . ckDataSize ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!" , infilename ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , prop_chunk , ( uint32_t ) dff_chunk_header . ckDataSize ) ) { error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } if ( ! strncmp ( prop_chunk , "SND<S2SV_blank>" , 4 ) ) { char * cptr = prop_chunk + 4 , * eptr = prop_chunk + dff_chunk_header . ckDataSize ; uint16_t numChannels , chansSpecified , chanMask = 0 ; uint32_t sampleRate ; while ( eptr - cptr >= sizeof ( dff_chunk_header ) ) { memcpy ( & dff_chunk_header , cptr , sizeof ( dff_chunk_header ) ) ; cptr += sizeof ( dff_chunk_header ) ; WavpackBigEndianToNative ( & dff_chunk_header , DFFChunkHeaderFormat ) ; if ( eptr - cptr >= dff_chunk_header . ckDataSize ) { if ( ! strncmp ( dff_chunk_header . ckID , "FS<S2SV_blank><S2SV_blank>" , 4 ) && dff_chunk_header . ckDataSize == 4 ) { memcpy ( & sampleRate , cptr , sizeof ( sampleRate ) ) ; WavpackBigEndianToNative ( & sampleRate , "L" ) ; cptr += dff_chunk_header . ckDataSize ; if ( debug_logging_mode ) error_line ( "got<S2SV_blank>sample<S2SV_blank>rate<S2SV_blank>of<S2SV_blank>%u<S2SV_blank>Hz" , sampleRate ) ; } else if ( ! strncmp ( dff_chunk_header . ckID , "CHNL" , 4 ) && dff_chunk_header . ckDataSize >= 2 ) { memcpy ( & numChannels , cptr , sizeof ( numChannels ) ) ; WavpackBigEndianToNative ( & numChannels , "S" ) ; cptr += sizeof ( numChannels ) ; chansSpecified = ( int ) ( dff_chunk_header . ckDataSize - sizeof ( numChannels ) ) / 4 ; while ( chansSpecified -- ) { if ( ! strncmp ( cptr , "SLFT" , 4 ) || ! strncmp ( cptr , "MLFT" , 4 ) ) chanMask |= 0x1 ; else if ( ! strncmp ( cptr , "SRGT" , 4 ) || ! strncmp ( cptr , "MRGT" , 4 ) ) chanMask |= 0x2 ; else if ( ! strncmp ( cptr , "LS<S2SV_blank><S2SV_blank>" , 4 ) ) chanMask |= 0x10 ; else if ( ! strncmp ( cptr , "RS<S2SV_blank><S2SV_blank>" , 4 ) ) chanMask |= 0x20 ; else if ( ! strncmp ( cptr , "C<S2SV_blank><S2SV_blank><S2SV_blank>" , 4 ) ) chanMask |= 0x4 ; else if ( ! strncmp ( cptr , "LFE<S2SV_blank>" , 4 ) ) chanMask |= 0x8 ; else if ( debug_logging_mode ) error_line ( "undefined<S2SV_blank>channel<S2SV_blank>ID<S2SV_blank>%c%c%c%c" , cptr [ 0 ] , cptr [ 1 ] , cptr [ 2 ] , cptr [ 3 ] ) ; cptr += 4 ; } if ( debug_logging_mode ) error_line ( "%d<S2SV_blank>channels,<S2SV_blank>mask<S2SV_blank>=<S2SV_blank>0x%08x" , numChannels , chanMask ) ; } else if ( ! strncmp ( dff_chunk_header . ckID , "CMPR" , 4 ) && dff_chunk_header . ckDataSize >= 4 ) { if ( strncmp ( cptr , "DSD<S2SV_blank>" , 4 ) ) { error_line ( "DSDIFF<S2SV_blank>files<S2SV_blank>must<S2SV_blank>be<S2SV_blank>uncompressed,<S2SV_blank>not<S2SV_blank>\\"%c%c%c%c\\"!" , cptr [ 0 ] , cptr [ 1 ] , cptr [ 2 ] , cptr [ 3 ] ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } cptr += dff_chunk_header . ckDataSize ; } else { if ( debug_logging_mode ) error_line ( "got<S2SV_blank>PROP/SND<S2SV_blank>chunk<S2SV_blank>type<S2SV_blank>\\"%c%c%c%c\\"<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes" , dff_chunk_header . ckID [ 0 ] , dff_chunk_header . ckID [ 1 ] , dff_chunk_header . ckID [ 2 ] , dff_chunk_header . ckID [ 3 ] , dff_chunk_header . ckDataSize ) ; cptr += dff_chunk_header . ckDataSize ; } } else { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!" , infilename ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } } if ( chanMask && ( config -> channel_mask || ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) ) { error_line ( "this<S2SV_blank>DSDIFF<S2SV_blank>file<S2SV_blank>already<S2SV_blank>has<S2SV_blank>channel<S2SV_blank>order<S2SV_blank>information!" ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } else if ( chanMask ) config -> channel_mask = chanMask ; config -> bits_per_sample = 8 ; config -> bytes_per_sample = 1 ; config -> num_channels = numChannels ; config -> sample_rate = sampleRate / 8 ; config -> qmode |= QMODE_DSD_MSB_FIRST ; } else if ( debug_logging_mode ) error_line ( "got<S2SV_blank>unknown<S2SV_blank>PROP<S2SV_blank>chunk<S2SV_blank>type<S2SV_blank>\\"%c%c%c%c\\"<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes" , prop_chunk [ 0 ] , prop_chunk [ 1 ] , prop_chunk [ 2 ] , prop_chunk [ 3 ] , dff_chunk_header . ckDataSize ) ; free ( prop_chunk ) ; } else if ( ! strncmp ( dff_chunk_header . ckID , "DSD<S2SV_blank>" , 4 ) ) { total_samples = dff_chunk_header . ckDataSize / config -> num_channels ; break ; } else { int bytes_to_copy = ( int ) ( ( ( dff_chunk_header . ckDataSize ) + 1 ) & ~ ( int64_t ) 1 ) ; char * buff = malloc ( bytes_to_copy ) ; if ( debug_logging_mode ) error_line ( "extra<S2SV_blank>unknown<S2SV_blank>chunk<S2SV_blank>\\"%c%c%c%c\\"<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes" , dff_chunk_header . ckID [ 0 ] , dff_chunk_header . ckID [ 1 ] , dff_chunk_header . ckID [ 2 ] , dff_chunk_header . ckID [ 3 ] , dff_chunk_header . ckDataSize ) ; if ( ! DoReadFile ( infile , buff , bytes_to_copy , & bcount ) || bcount != bytes_to_copy || ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , buff , bytes_to_copy ) ) ) { error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; free ( buff ) ; return WAVPACK_SOFT_ERROR ; } free ( buff ) ; } } if ( debug_logging_mode ) error_line ( "setting<S2SV_blank>configuration<S2SV_blank>with<S2SV_blank>%lld<S2SV_blank>samples" , total_samples ) ; if ( ! WavpackSetConfiguration64 ( wpc , config , total_samples , NULL ) ) { error_line ( "%s:<S2SV_blank>%s" , infilename , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } return WAVPACK_NO_ERROR ; }
CWE-369 int ParseDsdiffHeaderConfig ( FILE * infile , char * infilename , char * fourcc , WavpackContext * wpc , WavpackConfig * config ) { int64_t infilesize , total_samples ; DFFFileHeader dff_file_header ; DFFChunkHeader dff_chunk_header ; uint32_t bcount ; infilesize = DoGetFileSize ( infile ) ; memcpy ( & dff_file_header , fourcc , 4 ) ; if ( ( ! DoReadFile ( infile , ( ( char * ) & dff_file_header ) + 4 , sizeof ( DFFFileHeader ) - 4 , & bcount ) || bcount != sizeof ( DFFFileHeader ) - 4 ) || strncmp ( dff_file_header . formType , "DSD<S2SV_blank>" , 4 ) ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & dff_file_header , sizeof ( DFFFileHeader ) ) ) { error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } # if 1 WavpackBigEndianToNative ( & dff_file_header , DFFFileHeaderFormat ) ; if ( infilesize && ! ( config -> qmode & QMODE_IGNORE_LENGTH ) && dff_file_header . ckDataSize && dff_file_header . ckDataSize + 1 && dff_file_header . ckDataSize + 12 != infilesize ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file<S2SV_blank>(by<S2SV_blank>total<S2SV_blank>size)!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( debug_logging_mode ) error_line ( "file<S2SV_blank>header<S2SV_blank>indicated<S2SV_blank>length<S2SV_blank>=<S2SV_blank>%lld" , dff_file_header . ckDataSize ) ; # endif while ( 1 ) { if ( ! DoReadFile ( infile , & dff_chunk_header , sizeof ( DFFChunkHeader ) , & bcount ) || bcount != sizeof ( DFFChunkHeader ) ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & dff_chunk_header , sizeof ( DFFChunkHeader ) ) ) { error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackBigEndianToNative ( & dff_chunk_header , DFFChunkHeaderFormat ) ; if ( debug_logging_mode ) error_line ( "chunk<S2SV_blank>header<S2SV_blank>indicated<S2SV_blank>length<S2SV_blank>=<S2SV_blank>%lld" , dff_chunk_header . ckDataSize ) ; if ( ! strncmp ( dff_chunk_header . ckID , "FVER" , 4 ) ) { uint32_t version ; if ( dff_chunk_header . ckDataSize != sizeof ( version ) || ! DoReadFile ( infile , & version , sizeof ( version ) , & bcount ) || bcount != sizeof ( version ) ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & version , sizeof ( version ) ) ) { error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackBigEndianToNative ( & version , "L" ) ; if ( debug_logging_mode ) error_line ( "dsdiff<S2SV_blank>file<S2SV_blank>version<S2SV_blank>=<S2SV_blank>0x%08x" , version ) ; } else if ( ! strncmp ( dff_chunk_header . ckID , "PROP" , 4 ) ) { char * prop_chunk ; if ( dff_chunk_header . ckDataSize < 4 || dff_chunk_header . ckDataSize > 1024 ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( debug_logging_mode ) error_line ( "got<S2SV_blank>PROP<S2SV_blank>chunk<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>total" , ( int ) dff_chunk_header . ckDataSize ) ; prop_chunk = malloc ( ( size_t ) dff_chunk_header . ckDataSize ) ; if ( ! DoReadFile ( infile , prop_chunk , ( uint32_t ) dff_chunk_header . ckDataSize , & bcount ) || bcount != dff_chunk_header . ckDataSize ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!" , infilename ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , prop_chunk , ( uint32_t ) dff_chunk_header . ckDataSize ) ) { error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } if ( ! strncmp ( prop_chunk , "SND<S2SV_blank>" , 4 ) ) { char * cptr = prop_chunk + 4 , * eptr = prop_chunk + dff_chunk_header . ckDataSize ; <S2SV_StartBug> uint16_t numChannels , chansSpecified , chanMask = 0 ; <S2SV_EndBug> uint32_t sampleRate ; while ( eptr - cptr >= sizeof ( dff_chunk_header ) ) { memcpy ( & dff_chunk_header , cptr , sizeof ( dff_chunk_header ) ) ; cptr += sizeof ( dff_chunk_header ) ; WavpackBigEndianToNative ( & dff_chunk_header , DFFChunkHeaderFormat ) ; if ( dff_chunk_header . ckDataSize > 0 && dff_chunk_header . ckDataSize <= eptr - cptr ) { if ( ! strncmp ( dff_chunk_header . ckID , "FS<S2SV_blank><S2SV_blank>" , 4 ) && dff_chunk_header . ckDataSize == 4 ) { memcpy ( & sampleRate , cptr , sizeof ( sampleRate ) ) ; WavpackBigEndianToNative ( & sampleRate , "L" ) ; cptr += dff_chunk_header . ckDataSize ; if ( debug_logging_mode ) error_line ( "got<S2SV_blank>sample<S2SV_blank>rate<S2SV_blank>of<S2SV_blank>%u<S2SV_blank>Hz" , sampleRate ) ; } else if ( ! strncmp ( dff_chunk_header . ckID , "CHNL" , 4 ) && dff_chunk_header . ckDataSize >= 2 ) { memcpy ( & numChannels , cptr , sizeof ( numChannels ) ) ; WavpackBigEndianToNative ( & numChannels , "S" ) ; cptr += sizeof ( numChannels ) ; chansSpecified = ( int ) ( dff_chunk_header . ckDataSize - sizeof ( numChannels ) ) / 4 ; <S2SV_StartBug> if ( numChannels < chansSpecified || numChannels < 1 ) { <S2SV_EndBug> error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!" , infilename ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } while ( chansSpecified -- ) { if ( ! strncmp ( cptr , "SLFT" , 4 ) || ! strncmp ( cptr , "MLFT" , 4 ) ) chanMask |= 0x1 ; else if ( ! strncmp ( cptr , "SRGT" , 4 ) || ! strncmp ( cptr , "MRGT" , 4 ) ) chanMask |= 0x2 ; else if ( ! strncmp ( cptr , "LS<S2SV_blank><S2SV_blank>" , 4 ) ) chanMask |= 0x10 ; else if ( ! strncmp ( cptr , "RS<S2SV_blank><S2SV_blank>" , 4 ) ) chanMask |= 0x20 ; else if ( ! strncmp ( cptr , "C<S2SV_blank><S2SV_blank><S2SV_blank>" , 4 ) ) chanMask |= 0x4 ; else if ( ! strncmp ( cptr , "LFE<S2SV_blank>" , 4 ) ) chanMask |= 0x8 ; else if ( debug_logging_mode ) error_line ( "undefined<S2SV_blank>channel<S2SV_blank>ID<S2SV_blank>%c%c%c%c" , cptr [ 0 ] , cptr [ 1 ] , cptr [ 2 ] , cptr [ 3 ] ) ; cptr += 4 ; } if ( debug_logging_mode ) error_line ( "%d<S2SV_blank>channels,<S2SV_blank>mask<S2SV_blank>=<S2SV_blank>0x%08x" , numChannels , chanMask ) ; } else if ( ! strncmp ( dff_chunk_header . ckID , "CMPR" , 4 ) && dff_chunk_header . ckDataSize >= 4 ) { if ( strncmp ( cptr , "DSD<S2SV_blank>" , 4 ) ) { error_line ( "DSDIFF<S2SV_blank>files<S2SV_blank>must<S2SV_blank>be<S2SV_blank>uncompressed,<S2SV_blank>not<S2SV_blank>\\"%c%c%c%c\\"!" , cptr [ 0 ] , cptr [ 1 ] , cptr [ 2 ] , cptr [ 3 ] ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } cptr += dff_chunk_header . ckDataSize ; } else { if ( debug_logging_mode ) error_line ( "got<S2SV_blank>PROP/SND<S2SV_blank>chunk<S2SV_blank>type<S2SV_blank>\\"%c%c%c%c\\"<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes" , dff_chunk_header . ckID [ 0 ] , dff_chunk_header . ckID [ 1 ] , dff_chunk_header . ckID [ 2 ] , dff_chunk_header . ckID [ 3 ] , dff_chunk_header . ckDataSize ) ; cptr += dff_chunk_header . ckDataSize ; } } else { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!" , infilename ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } } if ( chanMask && ( config -> channel_mask || ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) ) { error_line ( "this<S2SV_blank>DSDIFF<S2SV_blank>file<S2SV_blank>already<S2SV_blank>has<S2SV_blank>channel<S2SV_blank>order<S2SV_blank>information!" ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } else if ( chanMask ) config -> channel_mask = chanMask ; config -> bits_per_sample = 8 ; config -> bytes_per_sample = 1 ; config -> num_channels = numChannels ; config -> sample_rate = sampleRate / 8 ; config -> qmode |= QMODE_DSD_MSB_FIRST ; } else if ( debug_logging_mode ) error_line ( "got<S2SV_blank>unknown<S2SV_blank>PROP<S2SV_blank>chunk<S2SV_blank>type<S2SV_blank>\\"%c%c%c%c\\"<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes" , prop_chunk [ 0 ] , prop_chunk [ 1 ] , prop_chunk [ 2 ] , prop_chunk [ 3 ] , dff_chunk_header . ckDataSize ) ; free ( prop_chunk ) ; } else if ( ! strncmp ( dff_chunk_header . ckID , "DSD<S2SV_blank>" , 4 ) ) { <S2SV_StartBug> total_samples = dff_chunk_header . ckDataSize / config -> num_channels ; <S2SV_EndBug> break ; } else { int bytes_to_copy = ( int ) ( ( ( dff_chunk_header . ckDataSize ) + 1 ) & ~ ( int64_t ) 1 ) ; char * buff ; if ( bytes_to_copy < 0 || bytes_to_copy > 4194304 ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } buff = malloc ( bytes_to_copy ) ; if ( debug_logging_mode ) error_line ( "extra<S2SV_blank>unknown<S2SV_blank>chunk<S2SV_blank>\\"%c%c%c%c\\"<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes" , dff_chunk_header . ckID [ 0 ] , dff_chunk_header . ckID [ 1 ] , dff_chunk_header . ckID [ 2 ] , dff_chunk_header . ckID [ 3 ] , dff_chunk_header . ckDataSize ) ; if ( ! DoReadFile ( infile , buff , bytes_to_copy , & bcount ) || bcount != bytes_to_copy || ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , buff , bytes_to_copy ) ) ) { error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; free ( buff ) ; return WAVPACK_SOFT_ERROR ; } free ( buff ) ; } } if ( debug_logging_mode ) error_line ( "setting<S2SV_blank>configuration<S2SV_blank>with<S2SV_blank>%lld<S2SV_blank>samples" , total_samples ) ; if ( ! WavpackSetConfiguration64 ( wpc , config , total_samples , NULL ) ) { error_line ( "%s:<S2SV_blank>%s" , infilename , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } return WAVPACK_NO_ERROR ; }
CWE-787 int ParseDsdiffHeaderConfig ( FILE * infile , char * infilename , char * fourcc , WavpackContext * wpc , WavpackConfig * config ) { int64_t infilesize , total_samples ; DFFFileHeader dff_file_header ; DFFChunkHeader dff_chunk_header ; uint32_t bcount ; infilesize = DoGetFileSize ( infile ) ; memcpy ( & dff_file_header , fourcc , 4 ) ; if ( ( ! DoReadFile ( infile , ( ( char * ) & dff_file_header ) + 4 , sizeof ( DFFFileHeader ) - 4 , & bcount ) || bcount != sizeof ( DFFFileHeader ) - 4 ) || strncmp ( dff_file_header . formType , "DSD<S2SV_blank>" , 4 ) ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & dff_file_header , sizeof ( DFFFileHeader ) ) ) { error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } # if 1 WavpackBigEndianToNative ( & dff_file_header , DFFFileHeaderFormat ) ; if ( infilesize && ! ( config -> qmode & QMODE_IGNORE_LENGTH ) && dff_file_header . ckDataSize && dff_file_header . ckDataSize + 1 && dff_file_header . ckDataSize + 12 != infilesize ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file<S2SV_blank>(by<S2SV_blank>total<S2SV_blank>size)!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( debug_logging_mode ) error_line ( "file<S2SV_blank>header<S2SV_blank>indicated<S2SV_blank>length<S2SV_blank>=<S2SV_blank>%lld" , dff_file_header . ckDataSize ) ; # endif while ( 1 ) { if ( ! DoReadFile ( infile , & dff_chunk_header , sizeof ( DFFChunkHeader ) , & bcount ) || bcount != sizeof ( DFFChunkHeader ) ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & dff_chunk_header , sizeof ( DFFChunkHeader ) ) ) { error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackBigEndianToNative ( & dff_chunk_header , DFFChunkHeaderFormat ) ; if ( debug_logging_mode ) error_line ( "chunk<S2SV_blank>header<S2SV_blank>indicated<S2SV_blank>length<S2SV_blank>=<S2SV_blank>%lld" , dff_chunk_header . ckDataSize ) ; if ( ! strncmp ( dff_chunk_header . ckID , "FVER" , 4 ) ) { uint32_t version ; if ( dff_chunk_header . ckDataSize != sizeof ( version ) || ! DoReadFile ( infile , & version , sizeof ( version ) , & bcount ) || bcount != sizeof ( version ) ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & version , sizeof ( version ) ) ) { error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackBigEndianToNative ( & version , "L" ) ; if ( debug_logging_mode ) error_line ( "dsdiff<S2SV_blank>file<S2SV_blank>version<S2SV_blank>=<S2SV_blank>0x%08x" , version ) ; } else if ( ! strncmp ( dff_chunk_header . ckID , "PROP" , 4 ) ) { char * prop_chunk ; if ( dff_chunk_header . ckDataSize < 4 || dff_chunk_header . ckDataSize > 1024 ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( debug_logging_mode ) error_line ( "got<S2SV_blank>PROP<S2SV_blank>chunk<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>total" , ( int ) dff_chunk_header . ckDataSize ) ; prop_chunk = malloc ( ( size_t ) dff_chunk_header . ckDataSize ) ; if ( ! DoReadFile ( infile , prop_chunk , ( uint32_t ) dff_chunk_header . ckDataSize , & bcount ) || bcount != dff_chunk_header . ckDataSize ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!" , infilename ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , prop_chunk , ( uint32_t ) dff_chunk_header . ckDataSize ) ) { error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } if ( ! strncmp ( prop_chunk , "SND<S2SV_blank>" , 4 ) ) { char * cptr = prop_chunk + 4 , * eptr = prop_chunk + dff_chunk_header . ckDataSize ; uint16_t numChannels , chansSpecified , chanMask = 0 ; uint32_t sampleRate ; while ( eptr - cptr >= sizeof ( dff_chunk_header ) ) { memcpy ( & dff_chunk_header , cptr , sizeof ( dff_chunk_header ) ) ; cptr += sizeof ( dff_chunk_header ) ; WavpackBigEndianToNative ( & dff_chunk_header , DFFChunkHeaderFormat ) ; if ( eptr - cptr >= dff_chunk_header . ckDataSize ) { if ( ! strncmp ( dff_chunk_header . ckID , "FS<S2SV_blank><S2SV_blank>" , 4 ) && dff_chunk_header . ckDataSize == 4 ) { memcpy ( & sampleRate , cptr , sizeof ( sampleRate ) ) ; WavpackBigEndianToNative ( & sampleRate , "L" ) ; cptr += dff_chunk_header . ckDataSize ; if ( debug_logging_mode ) error_line ( "got<S2SV_blank>sample<S2SV_blank>rate<S2SV_blank>of<S2SV_blank>%u<S2SV_blank>Hz" , sampleRate ) ; } else if ( ! strncmp ( dff_chunk_header . ckID , "CHNL" , 4 ) && dff_chunk_header . ckDataSize >= 2 ) { memcpy ( & numChannels , cptr , sizeof ( numChannels ) ) ; WavpackBigEndianToNative ( & numChannels , "S" ) ; cptr += sizeof ( numChannels ) ; chansSpecified = ( int ) ( dff_chunk_header . ckDataSize - sizeof ( numChannels ) ) / 4 ; while ( chansSpecified -- ) { if ( ! strncmp ( cptr , "SLFT" , 4 ) || ! strncmp ( cptr , "MLFT" , 4 ) ) chanMask |= 0x1 ; else if ( ! strncmp ( cptr , "SRGT" , 4 ) || ! strncmp ( cptr , "MRGT" , 4 ) ) chanMask |= 0x2 ; else if ( ! strncmp ( cptr , "LS<S2SV_blank><S2SV_blank>" , 4 ) ) chanMask |= 0x10 ; else if ( ! strncmp ( cptr , "RS<S2SV_blank><S2SV_blank>" , 4 ) ) chanMask |= 0x20 ; else if ( ! strncmp ( cptr , "C<S2SV_blank><S2SV_blank><S2SV_blank>" , 4 ) ) chanMask |= 0x4 ; else if ( ! strncmp ( cptr , "LFE<S2SV_blank>" , 4 ) ) chanMask |= 0x8 ; else if ( debug_logging_mode ) error_line ( "undefined<S2SV_blank>channel<S2SV_blank>ID<S2SV_blank>%c%c%c%c" , cptr [ 0 ] , cptr [ 1 ] , cptr [ 2 ] , cptr [ 3 ] ) ; cptr += 4 ; } if ( debug_logging_mode ) error_line ( "%d<S2SV_blank>channels,<S2SV_blank>mask<S2SV_blank>=<S2SV_blank>0x%08x" , numChannels , chanMask ) ; } else if ( ! strncmp ( dff_chunk_header . ckID , "CMPR" , 4 ) && dff_chunk_header . ckDataSize >= 4 ) { if ( strncmp ( cptr , "DSD<S2SV_blank>" , 4 ) ) { error_line ( "DSDIFF<S2SV_blank>files<S2SV_blank>must<S2SV_blank>be<S2SV_blank>uncompressed,<S2SV_blank>not<S2SV_blank>\\"%c%c%c%c\\"!" , cptr [ 0 ] , cptr [ 1 ] , cptr [ 2 ] , cptr [ 3 ] ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } cptr += dff_chunk_header . ckDataSize ; } else { if ( debug_logging_mode ) error_line ( "got<S2SV_blank>PROP/SND<S2SV_blank>chunk<S2SV_blank>type<S2SV_blank>\\"%c%c%c%c\\"<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes" , dff_chunk_header . ckID [ 0 ] , dff_chunk_header . ckID [ 1 ] , dff_chunk_header . ckID [ 2 ] , dff_chunk_header . ckID [ 3 ] , dff_chunk_header . ckDataSize ) ; cptr += dff_chunk_header . ckDataSize ; } } else { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!" , infilename ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } } if ( chanMask && ( config -> channel_mask || ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) ) { error_line ( "this<S2SV_blank>DSDIFF<S2SV_blank>file<S2SV_blank>already<S2SV_blank>has<S2SV_blank>channel<S2SV_blank>order<S2SV_blank>information!" ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } else if ( chanMask ) config -> channel_mask = chanMask ; config -> bits_per_sample = 8 ; config -> bytes_per_sample = 1 ; config -> num_channels = numChannels ; config -> sample_rate = sampleRate / 8 ; config -> qmode |= QMODE_DSD_MSB_FIRST ; } else if ( debug_logging_mode ) error_line ( "got<S2SV_blank>unknown<S2SV_blank>PROP<S2SV_blank>chunk<S2SV_blank>type<S2SV_blank>\\"%c%c%c%c\\"<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes" , prop_chunk [ 0 ] , prop_chunk [ 1 ] , prop_chunk [ 2 ] , prop_chunk [ 3 ] , dff_chunk_header . ckDataSize ) ; free ( prop_chunk ) ; } else if ( ! strncmp ( dff_chunk_header . ckID , "DSD<S2SV_blank>" , 4 ) ) { total_samples = dff_chunk_header . ckDataSize / config -> num_channels ; break ; } else { int bytes_to_copy = ( int ) ( ( ( dff_chunk_header . ckDataSize ) + 1 ) & ~ ( int64_t ) 1 ) ; <S2SV_StartBug> char * buff = malloc ( bytes_to_copy ) ; <S2SV_EndBug> if ( debug_logging_mode ) error_line ( "extra<S2SV_blank>unknown<S2SV_blank>chunk<S2SV_blank>\\"%c%c%c%c\\"<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes" , dff_chunk_header . ckID [ 0 ] , dff_chunk_header . ckID [ 1 ] , dff_chunk_header . ckID [ 2 ] , dff_chunk_header . ckID [ 3 ] , dff_chunk_header . ckDataSize ) ; if ( ! DoReadFile ( infile , buff , bytes_to_copy , & bcount ) || bcount != bytes_to_copy || ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , buff , bytes_to_copy ) ) ) { error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; free ( buff ) ; return WAVPACK_SOFT_ERROR ; } free ( buff ) ; } } if ( debug_logging_mode ) error_line ( "setting<S2SV_blank>configuration<S2SV_blank>with<S2SV_blank>%lld<S2SV_blank>samples" , total_samples ) ; if ( ! WavpackSetConfiguration64 ( wpc , config , total_samples , NULL ) ) { error_line ( "%s:<S2SV_blank>%s" , infilename , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } return WAVPACK_NO_ERROR ; }
CWE-787 int ParseRiffHeaderConfig ( FILE * infile , char * infilename , char * fourcc , WavpackContext * wpc , WavpackConfig * config ) { int is_rf64 = ! strncmp ( fourcc , "RF64" , 4 ) , got_ds64 = 0 ; int64_t total_samples = 0 , infilesize ; RiffChunkHeader riff_chunk_header ; ChunkHeader chunk_header ; WaveHeader WaveHeader ; DS64Chunk ds64_chunk ; uint32_t bcount ; CLEAR ( WaveHeader ) ; CLEAR ( ds64_chunk ) ; infilesize = DoGetFileSize ( infile ) ; if ( ! is_rf64 && infilesize >= 4294967296LL && ! ( config -> qmode & QMODE_IGNORE_LENGTH ) ) { error_line ( "can\'t<S2SV_blank>handle<S2SV_blank>.WAV<S2SV_blank>files<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>4<S2SV_blank>GB<S2SV_blank>(non-standard)!" ) ; return WAVPACK_SOFT_ERROR ; } memcpy ( & riff_chunk_header , fourcc , 4 ) ; if ( ( ! DoReadFile ( infile , ( ( char * ) & riff_chunk_header ) + 4 , sizeof ( RiffChunkHeader ) - 4 , & bcount ) || bcount != sizeof ( RiffChunkHeader ) - 4 || strncmp ( riff_chunk_header . formType , "WAVE" , 4 ) ) ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & riff_chunk_header , sizeof ( RiffChunkHeader ) ) ) { error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } while ( 1 ) { if ( ! DoReadFile ( infile , & chunk_header , sizeof ( ChunkHeader ) , & bcount ) || bcount != sizeof ( ChunkHeader ) ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & chunk_header , sizeof ( ChunkHeader ) ) ) { error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackLittleEndianToNative ( & chunk_header , ChunkHeaderFormat ) ; if ( ! strncmp ( chunk_header . ckID , "ds64" , 4 ) ) { if ( chunk_header . ckSize < sizeof ( DS64Chunk ) || ! DoReadFile ( infile , & ds64_chunk , sizeof ( DS64Chunk ) , & bcount ) || bcount != sizeof ( DS64Chunk ) ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & ds64_chunk , sizeof ( DS64Chunk ) ) ) { error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } got_ds64 = 1 ; WavpackLittleEndianToNative ( & ds64_chunk , DS64ChunkFormat ) ; if ( debug_logging_mode ) error_line ( "DS64:<S2SV_blank>riffSize<S2SV_blank>=<S2SV_blank>%lld,<S2SV_blank>dataSize<S2SV_blank>=<S2SV_blank>%lld,<S2SV_blank>sampleCount<S2SV_blank>=<S2SV_blank>%lld,<S2SV_blank>table_length<S2SV_blank>=<S2SV_blank>%d" , ( long long ) ds64_chunk . riffSize64 , ( long long ) ds64_chunk . dataSize64 , ( long long ) ds64_chunk . sampleCount64 , ds64_chunk . tableLength ) ; if ( ds64_chunk . tableLength * sizeof ( CS64Chunk ) != chunk_header . ckSize - sizeof ( DS64Chunk ) ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } while ( ds64_chunk . tableLength -- ) { CS64Chunk cs64_chunk ; if ( ! DoReadFile ( infile , & cs64_chunk , sizeof ( CS64Chunk ) , & bcount ) || bcount != sizeof ( CS64Chunk ) || ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & cs64_chunk , sizeof ( CS64Chunk ) ) ) ) { error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } } } else if ( ! strncmp ( chunk_header . ckID , "fmt<S2SV_blank>" , 4 ) ) { int supported = TRUE , format ; if ( chunk_header . ckSize < 16 || chunk_header . ckSize > sizeof ( WaveHeader ) || ! DoReadFile ( infile , & WaveHeader , chunk_header . ckSize , & bcount ) || bcount != chunk_header . ckSize ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & WaveHeader , chunk_header . ckSize ) ) { error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackLittleEndianToNative ( & WaveHeader , WaveHeaderFormat ) ; if ( debug_logging_mode ) { error_line ( "format<S2SV_blank>tag<S2SV_blank>size<S2SV_blank>=<S2SV_blank>%d" , chunk_header . ckSize ) ; error_line ( "FormatTag<S2SV_blank>=<S2SV_blank>%x,<S2SV_blank>NumChannels<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>BitsPerSample<S2SV_blank>=<S2SV_blank>%d" , WaveHeader . FormatTag , WaveHeader . NumChannels , WaveHeader . BitsPerSample ) ; error_line ( "BlockAlign<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>SampleRate<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>BytesPerSecond<S2SV_blank>=<S2SV_blank>%d" , WaveHeader . BlockAlign , WaveHeader . SampleRate , WaveHeader . BytesPerSecond ) ; if ( chunk_header . ckSize > 16 ) error_line ( "cbSize<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>ValidBitsPerSample<S2SV_blank>=<S2SV_blank>%d" , WaveHeader . cbSize , WaveHeader . ValidBitsPerSample ) ; if ( chunk_header . ckSize > 20 ) error_line ( "ChannelMask<S2SV_blank>=<S2SV_blank>%x,<S2SV_blank>SubFormat<S2SV_blank>=<S2SV_blank>%d" , WaveHeader . ChannelMask , WaveHeader . SubFormat ) ; } if ( chunk_header . ckSize > 16 && WaveHeader . cbSize == 2 ) config -> qmode |= QMODE_ADOBE_MODE ; format = ( WaveHeader . FormatTag == 0xfffe && chunk_header . ckSize == 40 ) ? WaveHeader . SubFormat : WaveHeader . FormatTag ; config -> bits_per_sample = ( chunk_header . ckSize == 40 && WaveHeader . ValidBitsPerSample ) ? WaveHeader . ValidBitsPerSample : WaveHeader . BitsPerSample ; if ( format != 1 && format != 3 ) supported = FALSE ; if ( format == 3 && config -> bits_per_sample != 32 ) supported = FALSE ; if ( ! WaveHeader . NumChannels || WaveHeader . NumChannels > 256 || WaveHeader . BlockAlign / WaveHeader . NumChannels < ( config -> bits_per_sample + 7 ) / 8 || WaveHeader . BlockAlign / WaveHeader . NumChannels > 4 || WaveHeader . BlockAlign % WaveHeader . NumChannels ) supported = FALSE ; if ( config -> bits_per_sample < 1 || config -> bits_per_sample > 32 ) supported = FALSE ; if ( ! supported ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>an<S2SV_blank>unsupported<S2SV_blank>.WAV<S2SV_blank>format!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( chunk_header . ckSize < 40 ) { if ( ! config -> channel_mask && ! ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) { if ( WaveHeader . NumChannels <= 2 ) config -> channel_mask = 0x5 - WaveHeader . NumChannels ; else if ( WaveHeader . NumChannels <= 18 ) config -> channel_mask = ( 1 << WaveHeader . NumChannels ) - 1 ; else config -> channel_mask = 0x3ffff ; } } else if ( WaveHeader . ChannelMask && ( config -> channel_mask || ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) ) { error_line ( "this<S2SV_blank>WAV<S2SV_blank>file<S2SV_blank>already<S2SV_blank>has<S2SV_blank>channel<S2SV_blank>order<S2SV_blank>information!" ) ; return WAVPACK_SOFT_ERROR ; } else if ( WaveHeader . ChannelMask ) config -> channel_mask = WaveHeader . ChannelMask ; if ( format == 3 ) config -> float_norm_exp = 127 ; else if ( ( config -> qmode & QMODE_ADOBE_MODE ) && WaveHeader . BlockAlign / WaveHeader . NumChannels == 4 ) { if ( WaveHeader . BitsPerSample == 24 ) config -> float_norm_exp = 127 + 23 ; else if ( WaveHeader . BitsPerSample == 32 ) config -> float_norm_exp = 127 + 15 ; } if ( debug_logging_mode ) { if ( config -> float_norm_exp == 127 ) error_line ( "data<S2SV_blank>format:<S2SV_blank>normalized<S2SV_blank>32-bit<S2SV_blank>floating<S2SV_blank>point" ) ; else if ( config -> float_norm_exp ) error_line ( "data<S2SV_blank>format:<S2SV_blank>32-bit<S2SV_blank>floating<S2SV_blank>point<S2SV_blank>(Audition<S2SV_blank>%d:%d<S2SV_blank>float<S2SV_blank>type<S2SV_blank>1)" , config -> float_norm_exp - 126 , 150 - config -> float_norm_exp ) ; else error_line ( "data<S2SV_blank>format:<S2SV_blank>%d-bit<S2SV_blank>integers<S2SV_blank>stored<S2SV_blank>in<S2SV_blank>%d<S2SV_blank>byte(s)" , config -> bits_per_sample , WaveHeader . BlockAlign / WaveHeader . NumChannels ) ; } } else if ( ! strncmp ( chunk_header . ckID , "data" , 4 ) ) { int64_t data_chunk_size = ( got_ds64 && chunk_header . ckSize == ( uint32_t ) - 1 ) ? ds64_chunk . dataSize64 : chunk_header . ckSize ; if ( ! WaveHeader . NumChannels || ( is_rf64 && ! got_ds64 ) ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( infilesize && ! ( config -> qmode & QMODE_IGNORE_LENGTH ) && infilesize - data_chunk_size > 16777216 ) { error_line ( "this<S2SV_blank>.WAV<S2SV_blank>file<S2SV_blank>has<S2SV_blank>over<S2SV_blank>16<S2SV_blank>MB<S2SV_blank>of<S2SV_blank>extra<S2SV_blank>RIFF<S2SV_blank>data,<S2SV_blank>probably<S2SV_blank>is<S2SV_blank>corrupt!" ) ; return WAVPACK_SOFT_ERROR ; } if ( config -> qmode & QMODE_IGNORE_LENGTH ) { if ( infilesize && DoGetFilePosition ( infile ) != - 1 ) total_samples = ( infilesize - DoGetFilePosition ( infile ) ) / WaveHeader . BlockAlign ; else total_samples = - 1 ; } else { total_samples = data_chunk_size / WaveHeader . BlockAlign ; if ( got_ds64 && total_samples != ds64_chunk . sampleCount64 ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( ! total_samples ) { error_line ( "this<S2SV_blank>.WAV<S2SV_blank>file<S2SV_blank>has<S2SV_blank>no<S2SV_blank>audio<S2SV_blank>samples,<S2SV_blank>probably<S2SV_blank>is<S2SV_blank>corrupt!" ) ; return WAVPACK_SOFT_ERROR ; } if ( total_samples > MAX_WAVPACK_SAMPLES ) { error_line ( "%s<S2SV_blank>has<S2SV_blank>too<S2SV_blank>many<S2SV_blank>samples<S2SV_blank>for<S2SV_blank>WavPack!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } } config -> bytes_per_sample = WaveHeader . BlockAlign / WaveHeader . NumChannels ; config -> num_channels = WaveHeader . NumChannels ; config -> sample_rate = WaveHeader . SampleRate ; break ; } else { int bytes_to_copy = ( chunk_header . ckSize + 1 ) & ~ 1L ; <S2SV_StartBug> char * buff = malloc ( bytes_to_copy ) ; <S2SV_EndBug> if ( debug_logging_mode ) error_line ( "extra<S2SV_blank>unknown<S2SV_blank>chunk<S2SV_blank>\\"%c%c%c%c\\"<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes" , chunk_header . ckID [ 0 ] , chunk_header . ckID [ 1 ] , chunk_header . ckID [ 2 ] , chunk_header . ckID [ 3 ] , chunk_header . ckSize ) ; if ( ! DoReadFile ( infile , buff , bytes_to_copy , & bcount ) || bcount != bytes_to_copy || ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , buff , bytes_to_copy ) ) ) { error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; free ( buff ) ; return WAVPACK_SOFT_ERROR ; } free ( buff ) ; } } if ( ! WavpackSetConfiguration64 ( wpc , config , total_samples , NULL ) ) { error_line ( "%s:<S2SV_blank>%s" , infilename , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } return WAVPACK_NO_ERROR ; }
CWE-787 int ParseWave64HeaderConfig ( FILE * infile , char * infilename , char * fourcc , WavpackContext * wpc , WavpackConfig * config ) { int64_t total_samples = 0 , infilesize ; Wave64ChunkHeader chunk_header ; Wave64FileHeader filehdr ; WaveHeader WaveHeader ; uint32_t bcount ; infilesize = DoGetFileSize ( infile ) ; memcpy ( & filehdr , fourcc , 4 ) ; if ( ! DoReadFile ( infile , ( ( char * ) & filehdr ) + 4 , sizeof ( Wave64FileHeader ) - 4 , & bcount ) || bcount != sizeof ( Wave64FileHeader ) - 4 || memcmp ( filehdr . ckID , riff_guid , sizeof ( riff_guid ) ) || memcmp ( filehdr . formType , wave_guid , sizeof ( wave_guid ) ) ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & filehdr , sizeof ( filehdr ) ) ) { error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } # if 1 WavpackLittleEndianToNative ( & filehdr , Wave64ChunkHeaderFormat ) ; if ( infilesize && ! ( config -> qmode & QMODE_IGNORE_LENGTH ) && filehdr . ckSize && filehdr . ckSize + 1 && filehdr . ckSize != infilesize ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } # endif while ( 1 ) { if ( ! DoReadFile ( infile , & chunk_header , sizeof ( Wave64ChunkHeader ) , & bcount ) || bcount != sizeof ( Wave64ChunkHeader ) ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & chunk_header , sizeof ( Wave64ChunkHeader ) ) ) { error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackLittleEndianToNative ( & chunk_header , Wave64ChunkHeaderFormat ) ; chunk_header . ckSize -= sizeof ( chunk_header ) ; if ( ! memcmp ( chunk_header . ckID , fmt_guid , sizeof ( fmt_guid ) ) ) { int supported = TRUE , format ; chunk_header . ckSize = ( chunk_header . ckSize + 7 ) & ~ 7L ; if ( chunk_header . ckSize < 16 || chunk_header . ckSize > sizeof ( WaveHeader ) || ! DoReadFile ( infile , & WaveHeader , ( uint32_t ) chunk_header . ckSize , & bcount ) || bcount != chunk_header . ckSize ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & WaveHeader , ( uint32_t ) chunk_header . ckSize ) ) { error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackLittleEndianToNative ( & WaveHeader , WaveHeaderFormat ) ; if ( debug_logging_mode ) { error_line ( "format<S2SV_blank>tag<S2SV_blank>size<S2SV_blank>=<S2SV_blank>%d" , chunk_header . ckSize ) ; error_line ( "FormatTag<S2SV_blank>=<S2SV_blank>%x,<S2SV_blank>NumChannels<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>BitsPerSample<S2SV_blank>=<S2SV_blank>%d" , WaveHeader . FormatTag , WaveHeader . NumChannels , WaveHeader . BitsPerSample ) ; error_line ( "BlockAlign<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>SampleRate<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>BytesPerSecond<S2SV_blank>=<S2SV_blank>%d" , WaveHeader . BlockAlign , WaveHeader . SampleRate , WaveHeader . BytesPerSecond ) ; if ( chunk_header . ckSize > 16 ) error_line ( "cbSize<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>ValidBitsPerSample<S2SV_blank>=<S2SV_blank>%d" , WaveHeader . cbSize , WaveHeader . ValidBitsPerSample ) ; if ( chunk_header . ckSize > 20 ) error_line ( "ChannelMask<S2SV_blank>=<S2SV_blank>%x,<S2SV_blank>SubFormat<S2SV_blank>=<S2SV_blank>%d" , WaveHeader . ChannelMask , WaveHeader . SubFormat ) ; } if ( chunk_header . ckSize > 16 && WaveHeader . cbSize == 2 ) config -> qmode |= QMODE_ADOBE_MODE ; format = ( WaveHeader . FormatTag == 0xfffe && chunk_header . ckSize == 40 ) ? WaveHeader . SubFormat : WaveHeader . FormatTag ; config -> bits_per_sample = ( chunk_header . ckSize == 40 && WaveHeader . ValidBitsPerSample ) ? WaveHeader . ValidBitsPerSample : WaveHeader . BitsPerSample ; if ( format != 1 && format != 3 ) supported = FALSE ; if ( format == 3 && config -> bits_per_sample != 32 ) supported = FALSE ; if ( ! WaveHeader . NumChannels || WaveHeader . NumChannels > 256 || WaveHeader . BlockAlign / WaveHeader . NumChannels < ( config -> bits_per_sample + 7 ) / 8 || WaveHeader . BlockAlign / WaveHeader . NumChannels > 4 || WaveHeader . BlockAlign % WaveHeader . NumChannels ) supported = FALSE ; if ( config -> bits_per_sample < 1 || config -> bits_per_sample > 32 ) supported = FALSE ; if ( ! supported ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>an<S2SV_blank>unsupported<S2SV_blank>.W64<S2SV_blank>format!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( chunk_header . ckSize < 40 ) { if ( ! config -> channel_mask && ! ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) { if ( WaveHeader . NumChannels <= 2 ) config -> channel_mask = 0x5 - WaveHeader . NumChannels ; else if ( WaveHeader . NumChannels <= 18 ) config -> channel_mask = ( 1 << WaveHeader . NumChannels ) - 1 ; else config -> channel_mask = 0x3ffff ; } } else if ( WaveHeader . ChannelMask && ( config -> channel_mask || ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) ) { error_line ( "this<S2SV_blank>W64<S2SV_blank>file<S2SV_blank>already<S2SV_blank>has<S2SV_blank>channel<S2SV_blank>order<S2SV_blank>information!" ) ; return WAVPACK_SOFT_ERROR ; } else if ( WaveHeader . ChannelMask ) config -> channel_mask = WaveHeader . ChannelMask ; if ( format == 3 ) config -> float_norm_exp = 127 ; else if ( ( config -> qmode & QMODE_ADOBE_MODE ) && WaveHeader . BlockAlign / WaveHeader . NumChannels == 4 ) { if ( WaveHeader . BitsPerSample == 24 ) config -> float_norm_exp = 127 + 23 ; else if ( WaveHeader . BitsPerSample == 32 ) config -> float_norm_exp = 127 + 15 ; } if ( debug_logging_mode ) { if ( config -> float_norm_exp == 127 ) error_line ( "data<S2SV_blank>format:<S2SV_blank>normalized<S2SV_blank>32-bit<S2SV_blank>floating<S2SV_blank>point" ) ; else error_line ( "data<S2SV_blank>format:<S2SV_blank>%d-bit<S2SV_blank>integers<S2SV_blank>stored<S2SV_blank>in<S2SV_blank>%d<S2SV_blank>byte(s)" , config -> bits_per_sample , WaveHeader . BlockAlign / WaveHeader . NumChannels ) ; } } else if ( ! memcmp ( chunk_header . ckID , data_guid , sizeof ( data_guid ) ) ) { if ( ! WaveHeader . NumChannels ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( ( config -> qmode & QMODE_IGNORE_LENGTH ) || chunk_header . ckSize <= 0 ) { config -> qmode |= QMODE_IGNORE_LENGTH ; if ( infilesize && DoGetFilePosition ( infile ) != - 1 ) total_samples = ( infilesize - DoGetFilePosition ( infile ) ) / WaveHeader . BlockAlign ; else total_samples = - 1 ; } else { if ( infilesize && infilesize - chunk_header . ckSize > 16777216 ) { error_line ( "this<S2SV_blank>.W64<S2SV_blank>file<S2SV_blank>has<S2SV_blank>over<S2SV_blank>16<S2SV_blank>MB<S2SV_blank>of<S2SV_blank>extra<S2SV_blank>RIFF<S2SV_blank>data,<S2SV_blank>probably<S2SV_blank>is<S2SV_blank>corrupt!" ) ; return WAVPACK_SOFT_ERROR ; } total_samples = chunk_header . ckSize / WaveHeader . BlockAlign ; if ( ! total_samples ) { error_line ( "this<S2SV_blank>.W64<S2SV_blank>file<S2SV_blank>has<S2SV_blank>no<S2SV_blank>audio<S2SV_blank>samples,<S2SV_blank>probably<S2SV_blank>is<S2SV_blank>corrupt!" ) ; return WAVPACK_SOFT_ERROR ; } if ( total_samples > MAX_WAVPACK_SAMPLES ) { error_line ( "%s<S2SV_blank>has<S2SV_blank>too<S2SV_blank>many<S2SV_blank>samples<S2SV_blank>for<S2SV_blank>WavPack!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } } config -> bytes_per_sample = WaveHeader . BlockAlign / WaveHeader . NumChannels ; config -> num_channels = WaveHeader . NumChannels ; config -> sample_rate = WaveHeader . SampleRate ; break ; } else { int bytes_to_copy = ( chunk_header . ckSize + 7 ) & ~ 7L ; <S2SV_StartBug> char * buff = malloc ( bytes_to_copy ) ; <S2SV_EndBug> if ( debug_logging_mode ) error_line ( "extra<S2SV_blank>unknown<S2SV_blank>chunk<S2SV_blank>\\"%c%c%c%c\\"<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes" , chunk_header . ckID [ 0 ] , chunk_header . ckID [ 1 ] , chunk_header . ckID [ 2 ] , chunk_header . ckID [ 3 ] , chunk_header . ckSize ) ; if ( ! DoReadFile ( infile , buff , bytes_to_copy , & bcount ) || bcount != bytes_to_copy || ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , buff , bytes_to_copy ) ) ) { error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; free ( buff ) ; return WAVPACK_SOFT_ERROR ; } free ( buff ) ; } } if ( ! WavpackSetConfiguration64 ( wpc , config , total_samples , NULL ) ) { error_line ( "%s:<S2SV_blank>%s" , infilename , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } return WAVPACK_NO_ERROR ; }
CWE-125 int ParseCaffHeaderConfig ( FILE * infile , char * infilename , char * fourcc , WavpackContext * wpc , WavpackConfig * config ) { uint32_t chan_chunk = 0 , channel_layout = 0 , bcount ; unsigned char * channel_identities = NULL ; unsigned char * channel_reorder = NULL ; int64_t total_samples = 0 , infilesize ; CAFFileHeader caf_file_header ; CAFChunkHeader caf_chunk_header ; CAFAudioFormat caf_audio_format ; int i ; infilesize = DoGetFileSize ( infile ) ; memcpy ( & caf_file_header , fourcc , 4 ) ; if ( ( ! DoReadFile ( infile , ( ( char * ) & caf_file_header ) + 4 , sizeof ( CAFFileHeader ) - 4 , & bcount ) || bcount != sizeof ( CAFFileHeader ) - 4 ) ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.CAF<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & caf_file_header , sizeof ( CAFFileHeader ) ) ) { error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackBigEndianToNative ( & caf_file_header , CAFFileHeaderFormat ) ; if ( caf_file_header . mFileVersion != 1 ) { error_line ( "%s:<S2SV_blank>can\'t<S2SV_blank>handle<S2SV_blank>version<S2SV_blank>%d<S2SV_blank>.CAF<S2SV_blank>files!" , infilename , caf_file_header . mFileVersion ) ; return WAVPACK_SOFT_ERROR ; } while ( 1 ) { if ( ! DoReadFile ( infile , & caf_chunk_header , sizeof ( CAFChunkHeader ) , & bcount ) || bcount != sizeof ( CAFChunkHeader ) ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.CAF<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & caf_chunk_header , sizeof ( CAFChunkHeader ) ) ) { error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackBigEndianToNative ( & caf_chunk_header , CAFChunkHeaderFormat ) ; if ( ! strncmp ( caf_chunk_header . mChunkType , "desc" , 4 ) ) { int supported = TRUE ; if ( caf_chunk_header . mChunkSize != sizeof ( CAFAudioFormat ) || ! DoReadFile ( infile , & caf_audio_format , ( uint32_t ) caf_chunk_header . mChunkSize , & bcount ) || bcount != caf_chunk_header . mChunkSize ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.CAF<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & caf_audio_format , ( uint32_t ) caf_chunk_header . mChunkSize ) ) { error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackBigEndianToNative ( & caf_audio_format , CAFAudioFormatFormat ) ; if ( debug_logging_mode ) { char formatstr [ 5 ] ; memcpy ( formatstr , caf_audio_format . mFormatID , 4 ) ; formatstr [ 4 ] = 0 ; error_line ( "format<S2SV_blank>=<S2SV_blank>%s,<S2SV_blank>flags<S2SV_blank>=<S2SV_blank>%x,<S2SV_blank>sampling<S2SV_blank>rate<S2SV_blank>=<S2SV_blank>%g" , formatstr , caf_audio_format . mFormatFlags , caf_audio_format . mSampleRate ) ; error_line ( "packet<S2SV_blank>=<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>and<S2SV_blank>%d<S2SV_blank>frames" , caf_audio_format . mBytesPerPacket , caf_audio_format . mFramesPerPacket ) ; error_line ( "channels<S2SV_blank>per<S2SV_blank>frame<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>bits<S2SV_blank>per<S2SV_blank>channel<S2SV_blank>=<S2SV_blank>%d" , caf_audio_format . mChannelsPerFrame , caf_audio_format . mBitsPerChannel ) ; } if ( strncmp ( caf_audio_format . mFormatID , "lpcm" , 4 ) || ( caf_audio_format . mFormatFlags & ~ 3 ) ) supported = FALSE ; else if ( caf_audio_format . mSampleRate < 1.0 || caf_audio_format . mSampleRate > 16777215.0 || caf_audio_format . mSampleRate != floor ( caf_audio_format . mSampleRate ) ) supported = FALSE ; else if ( ! caf_audio_format . mChannelsPerFrame || caf_audio_format . mChannelsPerFrame > 256 ) supported = FALSE ; else if ( caf_audio_format . mBitsPerChannel < 1 || caf_audio_format . mBitsPerChannel > 32 || ( ( caf_audio_format . mFormatFlags & CAF_FORMAT_FLOAT ) && caf_audio_format . mBitsPerChannel != 32 ) ) supported = FALSE ; else if ( caf_audio_format . mFramesPerPacket != 1 || caf_audio_format . mBytesPerPacket / caf_audio_format . mChannelsPerFrame < ( caf_audio_format . mBitsPerChannel + 7 ) / 8 || caf_audio_format . mBytesPerPacket / caf_audio_format . mChannelsPerFrame > 4 || caf_audio_format . mBytesPerPacket % caf_audio_format . mChannelsPerFrame ) supported = FALSE ; if ( ! supported ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>an<S2SV_blank>unsupported<S2SV_blank>.CAF<S2SV_blank>format!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } config -> bytes_per_sample = caf_audio_format . mBytesPerPacket / caf_audio_format . mChannelsPerFrame ; config -> float_norm_exp = ( caf_audio_format . mFormatFlags & CAF_FORMAT_FLOAT ) ? 127 : 0 ; config -> bits_per_sample = caf_audio_format . mBitsPerChannel ; config -> num_channels = caf_audio_format . mChannelsPerFrame ; config -> sample_rate = ( int ) caf_audio_format . mSampleRate ; if ( ! ( caf_audio_format . mFormatFlags & CAF_FORMAT_LITTLE_ENDIAN ) && config -> bytes_per_sample > 1 ) config -> qmode |= QMODE_BIG_ENDIAN ; if ( config -> bytes_per_sample == 1 ) config -> qmode |= QMODE_SIGNED_BYTES ; if ( debug_logging_mode ) { if ( config -> float_norm_exp == 127 ) error_line ( "data<S2SV_blank>format:<S2SV_blank>32-bit<S2SV_blank>%s-endian<S2SV_blank>floating<S2SV_blank>point" , ( config -> qmode & QMODE_BIG_ENDIAN ) ? "big" : "little" ) ; else error_line ( "data<S2SV_blank>format:<S2SV_blank>%d-bit<S2SV_blank>%s-endian<S2SV_blank>integers<S2SV_blank>stored<S2SV_blank>in<S2SV_blank>%d<S2SV_blank>byte(s)" , config -> bits_per_sample , ( config -> qmode & QMODE_BIG_ENDIAN ) ? "big" : "little" , config -> bytes_per_sample ) ; } } else if ( ! strncmp ( caf_chunk_header . mChunkType , "chan" , 4 ) ) { <S2SV_StartBug> CAFChannelLayout * caf_channel_layout = malloc ( ( size_t ) caf_chunk_header . mChunkSize ) ; <S2SV_EndBug> if ( caf_chunk_header . mChunkSize < sizeof ( CAFChannelLayout ) || <S2SV_StartBug> ! DoReadFile ( infile , caf_channel_layout , ( uint32_t ) caf_chunk_header . mChunkSize , & bcount ) || <S2SV_EndBug> bcount != caf_chunk_header . mChunkSize ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.CAF<S2SV_blank>file!" , infilename ) ; free ( caf_channel_layout ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , caf_channel_layout , ( uint32_t ) caf_chunk_header . mChunkSize ) ) { error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; free ( caf_channel_layout ) ; return WAVPACK_SOFT_ERROR ; } WavpackBigEndianToNative ( caf_channel_layout , CAFChannelLayoutFormat ) ; chan_chunk = 1 ; if ( config -> channel_mask || ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) { error_line ( "this<S2SV_blank>CAF<S2SV_blank>file<S2SV_blank>already<S2SV_blank>has<S2SV_blank>channel<S2SV_blank>order<S2SV_blank>information!" ) ; free ( caf_channel_layout ) ; return WAVPACK_SOFT_ERROR ; } switch ( caf_channel_layout -> mChannelLayoutTag ) { case kCAFChannelLayoutTag_UseChannelDescriptions : { CAFChannelDescription * descriptions = ( CAFChannelDescription * ) ( caf_channel_layout + 1 ) ; int num_descriptions = caf_channel_layout -> mNumberChannelDescriptions ; int label , cindex = 0 , idents = 0 ; if ( caf_chunk_header . mChunkSize != sizeof ( CAFChannelLayout ) + sizeof ( CAFChannelDescription ) * num_descriptions || num_descriptions != config -> num_channels ) { error_line ( "channel<S2SV_blank>descriptions<S2SV_blank>in<S2SV_blank>\'chan\'<S2SV_blank>chunk<S2SV_blank>are<S2SV_blank>the<S2SV_blank>wrong<S2SV_blank>size!" ) ; free ( caf_channel_layout ) ; return WAVPACK_SOFT_ERROR ; } if ( num_descriptions >= 256 ) { error_line ( "%d<S2SV_blank>channel<S2SV_blank>descriptions<S2SV_blank>is<S2SV_blank>more<S2SV_blank>than<S2SV_blank>we<S2SV_blank>can<S2SV_blank>handle...ignoring!" ) ; break ; } channel_reorder = malloc ( num_descriptions ) ; memset ( channel_reorder , - 1 , num_descriptions ) ; channel_identities = malloc ( num_descriptions + 1 ) ; for ( i = 0 ; i < num_descriptions ; ++ i ) { WavpackBigEndianToNative ( descriptions + i , CAFChannelDescriptionFormat ) ; if ( debug_logging_mode ) error_line ( "chan<S2SV_blank>%d<S2SV_blank>--><S2SV_blank>%d" , i + 1 , descriptions [ i ] . mChannelLabel ) ; } for ( label = 1 ; label <= 18 ; ++ label ) for ( i = 0 ; i < num_descriptions ; ++ i ) if ( descriptions [ i ] . mChannelLabel == label ) { config -> channel_mask |= 1 << ( label - 1 ) ; channel_reorder [ i ] = cindex ++ ; break ; } for ( i = 0 ; i < num_descriptions ; ++ i ) if ( channel_reorder [ i ] == ( unsigned char ) - 1 ) { uint32_t clabel = descriptions [ i ] . mChannelLabel ; if ( clabel == 0 || clabel == 0xffffffff || clabel == 100 ) channel_identities [ idents ++ ] = 0xff ; else if ( ( clabel >= 33 && clabel <= 44 ) || ( clabel >= 200 && clabel <= 207 ) || ( clabel >= 301 && clabel <= 305 ) ) channel_identities [ idents ++ ] = clabel >= 301 ? clabel - 80 : clabel ; else { error_line ( "warning:<S2SV_blank>unknown<S2SV_blank>channel<S2SV_blank>descriptions<S2SV_blank>label:<S2SV_blank>%d" , clabel ) ; channel_identities [ idents ++ ] = 0xff ; } channel_reorder [ i ] = cindex ++ ; } for ( i = 0 ; i < num_descriptions ; ++ i ) if ( channel_reorder [ i ] != i ) break ; if ( i == num_descriptions ) { free ( channel_reorder ) ; channel_reorder = NULL ; } else { config -> qmode |= QMODE_REORDERED_CHANS ; channel_layout = num_descriptions ; } if ( ! idents ) { free ( channel_identities ) ; channel_identities = NULL ; } else channel_identities [ idents ] = 0 ; if ( debug_logging_mode ) { error_line ( "layout_tag<S2SV_blank>=<S2SV_blank>0x%08x,<S2SV_blank>so<S2SV_blank>generated<S2SV_blank>bitmap<S2SV_blank>of<S2SV_blank>0x%08x<S2SV_blank>from<S2SV_blank>%d<S2SV_blank>descriptions,<S2SV_blank>%d<S2SV_blank>non-MS" , caf_channel_layout -> mChannelLayoutTag , config -> channel_mask , caf_channel_layout -> mNumberChannelDescriptions , idents ) ; if ( channel_reorder && num_descriptions <= 8 ) { char reorder_string [ ] = "12345678" ; for ( i = 0 ; i < num_descriptions ; ++ i ) reorder_string [ i ] = channel_reorder [ i ] + '1' ; reorder_string [ i ] = 0 ; error_line ( "reordering<S2SV_blank>string<S2SV_blank>=<S2SV_blank>\\"%s\\"\\n" , reorder_string ) ; } } } break ; case kCAFChannelLayoutTag_UseChannelBitmap : config -> channel_mask = caf_channel_layout -> mChannelBitmap ; if ( debug_logging_mode ) error_line ( "layout_tag<S2SV_blank>=<S2SV_blank>0x%08x,<S2SV_blank>so<S2SV_blank>using<S2SV_blank>supplied<S2SV_blank>bitmap<S2SV_blank>of<S2SV_blank>0x%08x" , caf_channel_layout -> mChannelLayoutTag , caf_channel_layout -> mChannelBitmap ) ; break ; default : for ( i = 0 ; i < NUM_LAYOUTS ; ++ i ) if ( caf_channel_layout -> mChannelLayoutTag == layouts [ i ] . mChannelLayoutTag ) { config -> channel_mask = layouts [ i ] . mChannelBitmap ; channel_layout = layouts [ i ] . mChannelLayoutTag ; if ( layouts [ i ] . mChannelReorder ) { channel_reorder = ( unsigned char * ) strdup ( layouts [ i ] . mChannelReorder ) ; config -> qmode |= QMODE_REORDERED_CHANS ; } if ( layouts [ i ] . mChannelIdentities ) channel_identities = ( unsigned char * ) strdup ( layouts [ i ] . mChannelIdentities ) ; if ( debug_logging_mode ) error_line ( "layout_tag<S2SV_blank>0x%08x<S2SV_blank>found<S2SV_blank>in<S2SV_blank>table,<S2SV_blank>bitmap<S2SV_blank>=<S2SV_blank>0x%08x,<S2SV_blank>reorder<S2SV_blank>=<S2SV_blank>%s,<S2SV_blank>identities<S2SV_blank>=<S2SV_blank>%s" , channel_layout , config -> channel_mask , channel_reorder ? "yes" : "no" , channel_identities ? "yes" : "no" ) ; break ; } if ( i == NUM_LAYOUTS && debug_logging_mode ) error_line ( "layout_tag<S2SV_blank>0x%08x<S2SV_blank>not<S2SV_blank>found<S2SV_blank>in<S2SV_blank>table...all<S2SV_blank>channels<S2SV_blank>unassigned" , caf_channel_layout -> mChannelLayoutTag ) ; break ; } free ( caf_channel_layout ) ; } else if ( ! strncmp ( caf_chunk_header . mChunkType , "data" , 4 ) ) { uint32_t mEditCount ; if ( ! DoReadFile ( infile , & mEditCount , sizeof ( mEditCount ) , & bcount ) || bcount != sizeof ( mEditCount ) ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.CAF<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & mEditCount , sizeof ( mEditCount ) ) ) { error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } if ( ( config -> qmode & QMODE_IGNORE_LENGTH ) || caf_chunk_header . mChunkSize == - 1 ) { config -> qmode |= QMODE_IGNORE_LENGTH ; if ( infilesize && DoGetFilePosition ( infile ) != - 1 ) total_samples = ( infilesize - DoGetFilePosition ( infile ) ) / caf_audio_format . mBytesPerPacket ; else total_samples = - 1 ; } else { if ( infilesize && infilesize - caf_chunk_header . mChunkSize > 16777216 ) { error_line ( ".CAF<S2SV_blank>file<S2SV_blank>%s<S2SV_blank>has<S2SV_blank>over<S2SV_blank>16<S2SV_blank>MB<S2SV_blank>of<S2SV_blank>extra<S2SV_blank>CAFF<S2SV_blank>data,<S2SV_blank>probably<S2SV_blank>is<S2SV_blank>corrupt!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( ( caf_chunk_header . mChunkSize - 4 ) % caf_audio_format . mBytesPerPacket ) { error_line ( ".CAF<S2SV_blank>file<S2SV_blank>%s<S2SV_blank>has<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>data<S2SV_blank>chunk<S2SV_blank>size,<S2SV_blank>probably<S2SV_blank>is<S2SV_blank>corrupt!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } total_samples = ( caf_chunk_header . mChunkSize - 4 ) / caf_audio_format . mBytesPerPacket ; if ( ! total_samples ) { error_line ( "this<S2SV_blank>.CAF<S2SV_blank>file<S2SV_blank>has<S2SV_blank>no<S2SV_blank>audio<S2SV_blank>samples,<S2SV_blank>probably<S2SV_blank>is<S2SV_blank>corrupt!" ) ; return WAVPACK_SOFT_ERROR ; } if ( total_samples > MAX_WAVPACK_SAMPLES ) { error_line ( "%s<S2SV_blank>has<S2SV_blank>too<S2SV_blank>many<S2SV_blank>samples<S2SV_blank>for<S2SV_blank>WavPack!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } } break ; } else { <S2SV_StartBug> int bytes_to_copy = ( uint32_t ) caf_chunk_header . mChunkSize ; <S2SV_EndBug> <S2SV_StartBug> char * buff = malloc ( bytes_to_copy ) ; <S2SV_EndBug> if ( debug_logging_mode ) error_line ( "extra<S2SV_blank>unknown<S2SV_blank>chunk<S2SV_blank>\\"%c%c%c%c\\"<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes" , caf_chunk_header . mChunkType [ 0 ] , caf_chunk_header . mChunkType [ 1 ] , caf_chunk_header . mChunkType [ 2 ] , caf_chunk_header . mChunkType [ 3 ] , caf_chunk_header . mChunkSize ) ; if ( ! DoReadFile ( infile , buff , bytes_to_copy , & bcount ) || bcount != bytes_to_copy || ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , buff , bytes_to_copy ) ) ) { error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; free ( buff ) ; return WAVPACK_SOFT_ERROR ; } free ( buff ) ; } } if ( ! chan_chunk && ! config -> channel_mask && config -> num_channels <= 2 && ! ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) config -> channel_mask = 0x5 - config -> num_channels ; if ( ! WavpackSetConfiguration64 ( wpc , config , total_samples , channel_identities ) ) { error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } if ( channel_identities ) free ( channel_identities ) ; if ( channel_layout || channel_reorder ) { if ( ! WavpackSetChannelLayout ( wpc , channel_layout , channel_reorder ) ) { error_line ( "problem<S2SV_blank>with<S2SV_blank>setting<S2SV_blank>channel<S2SV_blank>layout<S2SV_blank>(should<S2SV_blank>not<S2SV_blank>happen)" ) ; return WAVPACK_SOFT_ERROR ; } if ( channel_reorder ) free ( channel_reorder ) ; } return WAVPACK_NO_ERROR ; }
CWE-125 int WavpackVerifySingleBlock ( unsigned char * buffer , int verify_checksum ) { WavpackHeader * wphdr = ( WavpackHeader * ) buffer ; uint32_t checksum_passed = 0 , bcount , meta_bc ; unsigned char * dp , meta_id , c1 , c2 ; if ( strncmp ( wphdr -> ckID , "wvpk" , 4 ) || wphdr -> ckSize + 8 < sizeof ( WavpackHeader ) ) return FALSE ; bcount = wphdr -> ckSize - sizeof ( WavpackHeader ) + 8 ; dp = ( unsigned char * ) ( wphdr + 1 ) ; while ( bcount >= 2 ) { meta_id = * dp ++ ; c1 = * dp ++ ; meta_bc = c1 << 1 ; bcount -= 2 ; if ( meta_id & ID_LARGE ) { if ( bcount < 2 ) return FALSE ; c1 = * dp ++ ; c2 = * dp ++ ; meta_bc += ( ( uint32_t ) c1 << 9 ) + ( ( uint32_t ) c2 << 17 ) ; bcount -= 2 ; } if ( bcount < meta_bc ) return FALSE ; if ( verify_checksum && ( meta_id & ID_UNIQUE ) == ID_BLOCK_CHECKSUM ) { # ifdef BITSTREAM_SHORTS uint16_t * csptr = ( uint16_t * ) buffer ; # else unsigned char * csptr = buffer ; # endif int wcount = ( int ) ( dp - 2 - buffer ) >> 1 ; uint32_t csum = ( uint32_t ) - 1 ; if ( ( meta_id & ID_ODD_SIZE ) || meta_bc < 2 || meta_bc > 4 ) return FALSE ; # ifdef BITSTREAM_SHORTS while ( wcount -- ) csum = ( csum * 3 ) + * csptr ++ ; # else WavpackNativeToLittleEndian ( ( WavpackHeader * ) buffer , WavpackHeaderFormat ) ; while ( wcount -- ) { csum = ( csum * 3 ) + csptr [ 0 ] + ( csptr [ 1 ] << 8 ) ; csptr += 2 ; } WavpackLittleEndianToNative ( ( WavpackHeader * ) buffer , WavpackHeaderFormat ) ; # endif if ( meta_bc == 4 ) { <S2SV_StartBug> if ( * dp ++ != ( csum & 0xff ) || * dp ++ != ( ( csum >> 8 ) & 0xff ) || * dp ++ != ( ( csum >> 16 ) & 0xff ) || * dp ++ != ( ( csum >> 24 ) & 0xff ) ) <S2SV_EndBug> return FALSE ; } else { csum ^= csum >> 16 ; <S2SV_StartBug> if ( * dp ++ != ( csum & 0xff ) || * dp ++ != ( ( csum >> 8 ) & 0xff ) ) <S2SV_EndBug> return FALSE ; } checksum_passed ++ ; } bcount -= meta_bc ; dp += meta_bc ; } return ( bcount == 0 ) && ( ! verify_checksum || ! ( wphdr -> flags & HAS_CHECKSUM ) || checksum_passed ) ; }
CWE-824 int ParseDsdiffHeaderConfig ( FILE * infile , char * infilename , char * fourcc , WavpackContext * wpc , WavpackConfig * config ) { int64_t infilesize , total_samples ; DFFFileHeader dff_file_header ; DFFChunkHeader dff_chunk_header ; uint32_t bcount ; infilesize = DoGetFileSize ( infile ) ; memcpy ( & dff_file_header , fourcc , 4 ) ; if ( ( ! DoReadFile ( infile , ( ( char * ) & dff_file_header ) + 4 , sizeof ( DFFFileHeader ) - 4 , & bcount ) || bcount != sizeof ( DFFFileHeader ) - 4 ) || strncmp ( dff_file_header . formType , "DSD<S2SV_blank>" , 4 ) ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & dff_file_header , sizeof ( DFFFileHeader ) ) ) { error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } # if 1 WavpackBigEndianToNative ( & dff_file_header , DFFFileHeaderFormat ) ; if ( infilesize && ! ( config -> qmode & QMODE_IGNORE_LENGTH ) && dff_file_header . ckDataSize && dff_file_header . ckDataSize + 1 && dff_file_header . ckDataSize + 12 != infilesize ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file<S2SV_blank>(by<S2SV_blank>total<S2SV_blank>size)!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( debug_logging_mode ) error_line ( "file<S2SV_blank>header<S2SV_blank>indicated<S2SV_blank>length<S2SV_blank>=<S2SV_blank>%lld" , dff_file_header . ckDataSize ) ; # endif while ( 1 ) { if ( ! DoReadFile ( infile , & dff_chunk_header , sizeof ( DFFChunkHeader ) , & bcount ) || bcount != sizeof ( DFFChunkHeader ) ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & dff_chunk_header , sizeof ( DFFChunkHeader ) ) ) { error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackBigEndianToNative ( & dff_chunk_header , DFFChunkHeaderFormat ) ; if ( debug_logging_mode ) error_line ( "chunk<S2SV_blank>header<S2SV_blank>indicated<S2SV_blank>length<S2SV_blank>=<S2SV_blank>%lld" , dff_chunk_header . ckDataSize ) ; if ( ! strncmp ( dff_chunk_header . ckID , "FVER" , 4 ) ) { uint32_t version ; if ( dff_chunk_header . ckDataSize != sizeof ( version ) || ! DoReadFile ( infile , & version , sizeof ( version ) , & bcount ) || bcount != sizeof ( version ) ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & version , sizeof ( version ) ) ) { error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackBigEndianToNative ( & version , "L" ) ; if ( debug_logging_mode ) error_line ( "dsdiff<S2SV_blank>file<S2SV_blank>version<S2SV_blank>=<S2SV_blank>0x%08x" , version ) ; } else if ( ! strncmp ( dff_chunk_header . ckID , "PROP" , 4 ) ) { char * prop_chunk ; if ( dff_chunk_header . ckDataSize < 4 || dff_chunk_header . ckDataSize > 1024 ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( debug_logging_mode ) error_line ( "got<S2SV_blank>PROP<S2SV_blank>chunk<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>total" , ( int ) dff_chunk_header . ckDataSize ) ; prop_chunk = malloc ( ( size_t ) dff_chunk_header . ckDataSize ) ; if ( ! DoReadFile ( infile , prop_chunk , ( uint32_t ) dff_chunk_header . ckDataSize , & bcount ) || bcount != dff_chunk_header . ckDataSize ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!" , infilename ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , prop_chunk , ( uint32_t ) dff_chunk_header . ckDataSize ) ) { error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } if ( ! strncmp ( prop_chunk , "SND<S2SV_blank>" , 4 ) ) { char * cptr = prop_chunk + 4 , * eptr = prop_chunk + dff_chunk_header . ckDataSize ; uint16_t numChannels = 0 , chansSpecified , chanMask = 0 ; <S2SV_StartBug> uint32_t sampleRate ; <S2SV_EndBug> while ( eptr - cptr >= sizeof ( dff_chunk_header ) ) { memcpy ( & dff_chunk_header , cptr , sizeof ( dff_chunk_header ) ) ; cptr += sizeof ( dff_chunk_header ) ; WavpackBigEndianToNative ( & dff_chunk_header , DFFChunkHeaderFormat ) ; if ( dff_chunk_header . ckDataSize > 0 && dff_chunk_header . ckDataSize <= eptr - cptr ) { if ( ! strncmp ( dff_chunk_header . ckID , "FS<S2SV_blank><S2SV_blank>" , 4 ) && dff_chunk_header . ckDataSize == 4 ) { memcpy ( & sampleRate , cptr , sizeof ( sampleRate ) ) ; WavpackBigEndianToNative ( & sampleRate , "L" ) ; cptr += dff_chunk_header . ckDataSize ; if ( debug_logging_mode ) error_line ( "got<S2SV_blank>sample<S2SV_blank>rate<S2SV_blank>of<S2SV_blank>%u<S2SV_blank>Hz" , sampleRate ) ; } else if ( ! strncmp ( dff_chunk_header . ckID , "CHNL" , 4 ) && dff_chunk_header . ckDataSize >= 2 ) { memcpy ( & numChannels , cptr , sizeof ( numChannels ) ) ; WavpackBigEndianToNative ( & numChannels , "S" ) ; cptr += sizeof ( numChannels ) ; chansSpecified = ( int ) ( dff_chunk_header . ckDataSize - sizeof ( numChannels ) ) / 4 ; if ( numChannels < chansSpecified || numChannels < 1 || numChannels > 256 ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!" , infilename ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } while ( chansSpecified -- ) { if ( ! strncmp ( cptr , "SLFT" , 4 ) || ! strncmp ( cptr , "MLFT" , 4 ) ) chanMask |= 0x1 ; else if ( ! strncmp ( cptr , "SRGT" , 4 ) || ! strncmp ( cptr , "MRGT" , 4 ) ) chanMask |= 0x2 ; else if ( ! strncmp ( cptr , "LS<S2SV_blank><S2SV_blank>" , 4 ) ) chanMask |= 0x10 ; else if ( ! strncmp ( cptr , "RS<S2SV_blank><S2SV_blank>" , 4 ) ) chanMask |= 0x20 ; else if ( ! strncmp ( cptr , "C<S2SV_blank><S2SV_blank><S2SV_blank>" , 4 ) ) chanMask |= 0x4 ; else if ( ! strncmp ( cptr , "LFE<S2SV_blank>" , 4 ) ) chanMask |= 0x8 ; else if ( debug_logging_mode ) error_line ( "undefined<S2SV_blank>channel<S2SV_blank>ID<S2SV_blank>%c%c%c%c" , cptr [ 0 ] , cptr [ 1 ] , cptr [ 2 ] , cptr [ 3 ] ) ; cptr += 4 ; } if ( debug_logging_mode ) error_line ( "%d<S2SV_blank>channels,<S2SV_blank>mask<S2SV_blank>=<S2SV_blank>0x%08x" , numChannels , chanMask ) ; } else if ( ! strncmp ( dff_chunk_header . ckID , "CMPR" , 4 ) && dff_chunk_header . ckDataSize >= 4 ) { if ( strncmp ( cptr , "DSD<S2SV_blank>" , 4 ) ) { error_line ( "DSDIFF<S2SV_blank>files<S2SV_blank>must<S2SV_blank>be<S2SV_blank>uncompressed,<S2SV_blank>not<S2SV_blank>\\"%c%c%c%c\\"!" , cptr [ 0 ] , cptr [ 1 ] , cptr [ 2 ] , cptr [ 3 ] ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } cptr += dff_chunk_header . ckDataSize ; } else { if ( debug_logging_mode ) error_line ( "got<S2SV_blank>PROP/SND<S2SV_blank>chunk<S2SV_blank>type<S2SV_blank>\\"%c%c%c%c\\"<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes" , dff_chunk_header . ckID [ 0 ] , dff_chunk_header . ckID [ 1 ] , dff_chunk_header . ckID [ 2 ] , dff_chunk_header . ckID [ 3 ] , dff_chunk_header . ckDataSize ) ; cptr += dff_chunk_header . ckDataSize ; } } else { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!" , infilename ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } } if ( chanMask && ( config -> channel_mask || ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) ) { error_line ( "this<S2SV_blank>DSDIFF<S2SV_blank>file<S2SV_blank>already<S2SV_blank>has<S2SV_blank>channel<S2SV_blank>order<S2SV_blank>information!" ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } else if ( chanMask ) config -> channel_mask = chanMask ; config -> bits_per_sample = 8 ; config -> bytes_per_sample = 1 ; config -> num_channels = numChannels ; config -> sample_rate = sampleRate / 8 ; config -> qmode |= QMODE_DSD_MSB_FIRST ; } else if ( debug_logging_mode ) error_line ( "got<S2SV_blank>unknown<S2SV_blank>PROP<S2SV_blank>chunk<S2SV_blank>type<S2SV_blank>\\"%c%c%c%c\\"<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes" , prop_chunk [ 0 ] , prop_chunk [ 1 ] , prop_chunk [ 2 ] , prop_chunk [ 3 ] , dff_chunk_header . ckDataSize ) ; free ( prop_chunk ) ; } else if ( ! strncmp ( dff_chunk_header . ckID , "DSD<S2SV_blank>" , 4 ) ) { <S2SV_StartBug> if ( ! config -> num_channels ) { <S2SV_EndBug> error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } total_samples = dff_chunk_header . ckDataSize / config -> num_channels ; break ; } else { int bytes_to_copy = ( int ) ( ( ( dff_chunk_header . ckDataSize ) + 1 ) & ~ ( int64_t ) 1 ) ; char * buff ; if ( bytes_to_copy < 0 || bytes_to_copy > 4194304 ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } buff = malloc ( bytes_to_copy ) ; if ( debug_logging_mode ) error_line ( "extra<S2SV_blank>unknown<S2SV_blank>chunk<S2SV_blank>\\"%c%c%c%c\\"<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes" , dff_chunk_header . ckID [ 0 ] , dff_chunk_header . ckID [ 1 ] , dff_chunk_header . ckID [ 2 ] , dff_chunk_header . ckID [ 3 ] , dff_chunk_header . ckDataSize ) ; if ( ! DoReadFile ( infile , buff , bytes_to_copy , & bcount ) || bcount != bytes_to_copy || ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , buff , bytes_to_copy ) ) ) { error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; free ( buff ) ; return WAVPACK_SOFT_ERROR ; } free ( buff ) ; } } if ( debug_logging_mode ) error_line ( "setting<S2SV_blank>configuration<S2SV_blank>with<S2SV_blank>%lld<S2SV_blank>samples" , total_samples ) ; if ( ! WavpackSetConfiguration64 ( wpc , config , total_samples , NULL ) ) { error_line ( "%s:<S2SV_blank>%s" , infilename , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } return WAVPACK_NO_ERROR ; }
CWE-119 int ParseRiffHeaderConfig ( FILE * infile , char * infilename , char * fourcc , WavpackContext * wpc , WavpackConfig * config ) { int is_rf64 = ! strncmp ( fourcc , "RF64" , 4 ) , got_ds64 = 0 ; int64_t total_samples = 0 , infilesize ; RiffChunkHeader riff_chunk_header ; ChunkHeader chunk_header ; WaveHeader WaveHeader ; DS64Chunk ds64_chunk ; uint32_t bcount ; CLEAR ( WaveHeader ) ; CLEAR ( ds64_chunk ) ; infilesize = DoGetFileSize ( infile ) ; if ( ! is_rf64 && infilesize >= 4294967296LL && ! ( config -> qmode & QMODE_IGNORE_LENGTH ) ) { error_line ( "can\'t<S2SV_blank>handle<S2SV_blank>.WAV<S2SV_blank>files<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>4<S2SV_blank>GB<S2SV_blank>(non-standard)!" ) ; return WAVPACK_SOFT_ERROR ; } memcpy ( & riff_chunk_header , fourcc , 4 ) ; if ( ( ! DoReadFile ( infile , ( ( char * ) & riff_chunk_header ) + 4 , sizeof ( RiffChunkHeader ) - 4 , & bcount ) || bcount != sizeof ( RiffChunkHeader ) - 4 || strncmp ( riff_chunk_header . formType , "WAVE" , 4 ) ) ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & riff_chunk_header , sizeof ( RiffChunkHeader ) ) ) { error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } while ( 1 ) { if ( ! DoReadFile ( infile , & chunk_header , sizeof ( ChunkHeader ) , & bcount ) || bcount != sizeof ( ChunkHeader ) ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & chunk_header , sizeof ( ChunkHeader ) ) ) { error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackLittleEndianToNative ( & chunk_header , ChunkHeaderFormat ) ; if ( ! strncmp ( chunk_header . ckID , "ds64" , 4 ) ) { if ( chunk_header . ckSize < sizeof ( DS64Chunk ) || <S2SV_StartBug> ! DoReadFile ( infile , & ds64_chunk , chunk_header . ckSize , & bcount ) || <S2SV_EndBug> <S2SV_StartBug> bcount != chunk_header . ckSize ) { <S2SV_EndBug> error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && <S2SV_StartBug> ! WavpackAddWrapper ( wpc , & ds64_chunk , chunk_header . ckSize ) ) { <S2SV_EndBug> error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } got_ds64 = 1 ; WavpackLittleEndianToNative ( & ds64_chunk , DS64ChunkFormat ) ; if ( debug_logging_mode ) error_line ( "DS64:<S2SV_blank>riffSize<S2SV_blank>=<S2SV_blank>%lld,<S2SV_blank>dataSize<S2SV_blank>=<S2SV_blank>%lld,<S2SV_blank>sampleCount<S2SV_blank>=<S2SV_blank>%lld,<S2SV_blank>table_length<S2SV_blank>=<S2SV_blank>%d" , ( long long ) ds64_chunk . riffSize64 , ( long long ) ds64_chunk . dataSize64 , ( long long ) ds64_chunk . sampleCount64 , ds64_chunk . tableLength ) ; if ( ds64_chunk . tableLength * sizeof ( CS64Chunk ) != chunk_header . ckSize - sizeof ( DS64Chunk ) ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } while ( ds64_chunk . tableLength -- ) { CS64Chunk cs64_chunk ; if ( ! DoReadFile ( infile , & cs64_chunk , sizeof ( CS64Chunk ) , & bcount ) || bcount != sizeof ( CS64Chunk ) || ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & cs64_chunk , sizeof ( CS64Chunk ) ) ) ) { error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } } } else if ( ! strncmp ( chunk_header . ckID , "fmt<S2SV_blank>" , 4 ) ) { int supported = TRUE , format ; if ( chunk_header . ckSize < 16 || chunk_header . ckSize > sizeof ( WaveHeader ) || ! DoReadFile ( infile , & WaveHeader , chunk_header . ckSize , & bcount ) || bcount != chunk_header . ckSize ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & WaveHeader , chunk_header . ckSize ) ) { error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackLittleEndianToNative ( & WaveHeader , WaveHeaderFormat ) ; if ( debug_logging_mode ) { error_line ( "format<S2SV_blank>tag<S2SV_blank>size<S2SV_blank>=<S2SV_blank>%d" , chunk_header . ckSize ) ; error_line ( "FormatTag<S2SV_blank>=<S2SV_blank>%x,<S2SV_blank>NumChannels<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>BitsPerSample<S2SV_blank>=<S2SV_blank>%d" , WaveHeader . FormatTag , WaveHeader . NumChannels , WaveHeader . BitsPerSample ) ; error_line ( "BlockAlign<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>SampleRate<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>BytesPerSecond<S2SV_blank>=<S2SV_blank>%d" , WaveHeader . BlockAlign , WaveHeader . SampleRate , WaveHeader . BytesPerSecond ) ; if ( chunk_header . ckSize > 16 ) error_line ( "cbSize<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>ValidBitsPerSample<S2SV_blank>=<S2SV_blank>%d" , WaveHeader . cbSize , WaveHeader . ValidBitsPerSample ) ; if ( chunk_header . ckSize > 20 ) error_line ( "ChannelMask<S2SV_blank>=<S2SV_blank>%x,<S2SV_blank>SubFormat<S2SV_blank>=<S2SV_blank>%d" , WaveHeader . ChannelMask , WaveHeader . SubFormat ) ; } if ( chunk_header . ckSize > 16 && WaveHeader . cbSize == 2 ) config -> qmode |= QMODE_ADOBE_MODE ; format = ( WaveHeader . FormatTag == 0xfffe && chunk_header . ckSize == 40 ) ? WaveHeader . SubFormat : WaveHeader . FormatTag ; config -> bits_per_sample = ( chunk_header . ckSize == 40 && WaveHeader . ValidBitsPerSample ) ? WaveHeader . ValidBitsPerSample : WaveHeader . BitsPerSample ; if ( format != 1 && format != 3 ) supported = FALSE ; if ( format == 3 && config -> bits_per_sample != 32 ) supported = FALSE ; if ( ! WaveHeader . NumChannels || WaveHeader . NumChannels > 256 || WaveHeader . BlockAlign / WaveHeader . NumChannels < ( config -> bits_per_sample + 7 ) / 8 || WaveHeader . BlockAlign / WaveHeader . NumChannels > 4 || WaveHeader . BlockAlign % WaveHeader . NumChannels ) supported = FALSE ; if ( config -> bits_per_sample < 1 || config -> bits_per_sample > 32 ) supported = FALSE ; if ( ! supported ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>an<S2SV_blank>unsupported<S2SV_blank>.WAV<S2SV_blank>format!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( chunk_header . ckSize < 40 ) { if ( ! config -> channel_mask && ! ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) { if ( WaveHeader . NumChannels <= 2 ) config -> channel_mask = 0x5 - WaveHeader . NumChannels ; else if ( WaveHeader . NumChannels <= 18 ) config -> channel_mask = ( 1 << WaveHeader . NumChannels ) - 1 ; else config -> channel_mask = 0x3ffff ; } } else if ( WaveHeader . ChannelMask && ( config -> channel_mask || ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) ) { error_line ( "this<S2SV_blank>WAV<S2SV_blank>file<S2SV_blank>already<S2SV_blank>has<S2SV_blank>channel<S2SV_blank>order<S2SV_blank>information!" ) ; return WAVPACK_SOFT_ERROR ; } else if ( WaveHeader . ChannelMask ) config -> channel_mask = WaveHeader . ChannelMask ; if ( format == 3 ) config -> float_norm_exp = 127 ; else if ( ( config -> qmode & QMODE_ADOBE_MODE ) && WaveHeader . BlockAlign / WaveHeader . NumChannels == 4 ) { if ( WaveHeader . BitsPerSample == 24 ) config -> float_norm_exp = 127 + 23 ; else if ( WaveHeader . BitsPerSample == 32 ) config -> float_norm_exp = 127 + 15 ; } if ( debug_logging_mode ) { if ( config -> float_norm_exp == 127 ) error_line ( "data<S2SV_blank>format:<S2SV_blank>normalized<S2SV_blank>32-bit<S2SV_blank>floating<S2SV_blank>point" ) ; else if ( config -> float_norm_exp ) error_line ( "data<S2SV_blank>format:<S2SV_blank>32-bit<S2SV_blank>floating<S2SV_blank>point<S2SV_blank>(Audition<S2SV_blank>%d:%d<S2SV_blank>float<S2SV_blank>type<S2SV_blank>1)" , config -> float_norm_exp - 126 , 150 - config -> float_norm_exp ) ; else error_line ( "data<S2SV_blank>format:<S2SV_blank>%d-bit<S2SV_blank>integers<S2SV_blank>stored<S2SV_blank>in<S2SV_blank>%d<S2SV_blank>byte(s)" , config -> bits_per_sample , WaveHeader . BlockAlign / WaveHeader . NumChannels ) ; } } else if ( ! strncmp ( chunk_header . ckID , "data" , 4 ) ) { int64_t data_chunk_size = ( got_ds64 && chunk_header . ckSize == ( uint32_t ) - 1 ) ? ds64_chunk . dataSize64 : chunk_header . ckSize ; if ( ! WaveHeader . NumChannels || ( is_rf64 && ! got_ds64 ) ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( infilesize && ! ( config -> qmode & QMODE_IGNORE_LENGTH ) && infilesize - data_chunk_size > 16777216 ) { error_line ( "this<S2SV_blank>.WAV<S2SV_blank>file<S2SV_blank>has<S2SV_blank>over<S2SV_blank>16<S2SV_blank>MB<S2SV_blank>of<S2SV_blank>extra<S2SV_blank>RIFF<S2SV_blank>data,<S2SV_blank>probably<S2SV_blank>is<S2SV_blank>corrupt!" ) ; return WAVPACK_SOFT_ERROR ; } if ( config -> qmode & QMODE_IGNORE_LENGTH ) { if ( infilesize && DoGetFilePosition ( infile ) != - 1 ) total_samples = ( infilesize - DoGetFilePosition ( infile ) ) / WaveHeader . BlockAlign ; else total_samples = - 1 ; } else { total_samples = data_chunk_size / WaveHeader . BlockAlign ; if ( got_ds64 && total_samples != ds64_chunk . sampleCount64 ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( ! total_samples ) { error_line ( "this<S2SV_blank>.WAV<S2SV_blank>file<S2SV_blank>has<S2SV_blank>no<S2SV_blank>audio<S2SV_blank>samples,<S2SV_blank>probably<S2SV_blank>is<S2SV_blank>corrupt!" ) ; return WAVPACK_SOFT_ERROR ; } if ( total_samples > MAX_WAVPACK_SAMPLES ) { error_line ( "%s<S2SV_blank>has<S2SV_blank>too<S2SV_blank>many<S2SV_blank>samples<S2SV_blank>for<S2SV_blank>WavPack!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } } config -> bytes_per_sample = WaveHeader . BlockAlign / WaveHeader . NumChannels ; config -> num_channels = WaveHeader . NumChannels ; config -> sample_rate = WaveHeader . SampleRate ; break ; } else { int bytes_to_copy = ( chunk_header . ckSize + 1 ) & ~ 1L ; char * buff = malloc ( bytes_to_copy ) ; if ( debug_logging_mode ) error_line ( "extra<S2SV_blank>unknown<S2SV_blank>chunk<S2SV_blank>\\"%c%c%c%c\\"<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes" , chunk_header . ckID [ 0 ] , chunk_header . ckID [ 1 ] , chunk_header . ckID [ 2 ] , chunk_header . ckID [ 3 ] , chunk_header . ckSize ) ; if ( ! DoReadFile ( infile , buff , bytes_to_copy , & bcount ) || bcount != bytes_to_copy || ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , buff , bytes_to_copy ) ) ) { error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; free ( buff ) ; return WAVPACK_SOFT_ERROR ; } free ( buff ) ; } } if ( ! WavpackSetConfiguration64 ( wpc , config , total_samples , NULL ) ) { error_line ( "%s:<S2SV_blank>%s" , infilename , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } return WAVPACK_NO_ERROR ; }
CWE-119 int WriteRiffHeader ( FILE * outfile , WavpackContext * wpc , int64_t total_samples , int qmode ) { <S2SV_StartBug> int do_rf64 = 0 , write_junk = 1 ; <S2SV_EndBug> ChunkHeader ds64hdr , datahdr , fmthdr ; RiffChunkHeader riffhdr ; <S2SV_StartBug> DS64Chunk ds64_chunk ; <S2SV_EndBug> JunkChunk junkchunk ; WaveHeader wavhdr ; uint32_t bcount ; int64_t total_data_bytes , total_riff_bytes ; int num_channels = WavpackGetNumChannels ( wpc ) ; int32_t channel_mask = WavpackGetChannelMask ( wpc ) ; int32_t sample_rate = WavpackGetSampleRate ( wpc ) ; int bytes_per_sample = WavpackGetBytesPerSample ( wpc ) ; int bits_per_sample = WavpackGetBitsPerSample ( wpc ) ; int format = WavpackGetFloatNormExp ( wpc ) ? 3 : 1 ; int wavhdrsize = 16 ; if ( format == 3 && WavpackGetFloatNormExp ( wpc ) != 127 ) { error_line ( "can\'t<S2SV_blank>create<S2SV_blank>valid<S2SV_blank>RIFF<S2SV_blank>wav<S2SV_blank>header<S2SV_blank>for<S2SV_blank>non-normalized<S2SV_blank>floating<S2SV_blank>data!" ) ; return FALSE ; } if ( total_samples == - 1 ) total_samples = 0x7ffff000 / ( bytes_per_sample * num_channels ) ; total_data_bytes = total_samples * bytes_per_sample * num_channels ; if ( total_data_bytes > 0xff000000 ) { if ( debug_logging_mode ) error_line ( "total_data_bytes<S2SV_blank>=<S2SV_blank>%lld,<S2SV_blank>so<S2SV_blank>rf64" , total_data_bytes ) ; write_junk = 0 ; do_rf64 = 1 ; } else if ( debug_logging_mode ) error_line ( "total_data_bytes<S2SV_blank>=<S2SV_blank>%lld,<S2SV_blank>so<S2SV_blank>riff" , total_data_bytes ) ; CLEAR ( wavhdr ) ; wavhdr . FormatTag = format ; wavhdr . NumChannels = num_channels ; wavhdr . SampleRate = sample_rate ; wavhdr . BytesPerSecond = sample_rate * num_channels * bytes_per_sample ; wavhdr . BlockAlign = bytes_per_sample * num_channels ; wavhdr . BitsPerSample = bits_per_sample ; if ( num_channels > 2 || channel_mask != 0x5 - num_channels ) { wavhdrsize = sizeof ( wavhdr ) ; wavhdr . cbSize = 22 ; wavhdr . ValidBitsPerSample = bits_per_sample ; wavhdr . SubFormat = format ; wavhdr . ChannelMask = channel_mask ; wavhdr . FormatTag = 0xfffe ; wavhdr . BitsPerSample = bytes_per_sample * 8 ; wavhdr . GUID [ 4 ] = 0x10 ; wavhdr . GUID [ 6 ] = 0x80 ; wavhdr . GUID [ 9 ] = 0xaa ; wavhdr . GUID [ 11 ] = 0x38 ; wavhdr . GUID [ 12 ] = 0x9b ; wavhdr . GUID [ 13 ] = 0x71 ; } strncpy ( riffhdr . ckID , do_rf64 ? "RF64" : "RIFF" , sizeof ( riffhdr . ckID ) ) ; strncpy ( riffhdr . formType , "WAVE" , sizeof ( riffhdr . formType ) ) ; total_riff_bytes = sizeof ( riffhdr ) + wavhdrsize + sizeof ( datahdr ) + ( ( total_data_bytes + 1 ) & ~ ( int64_t ) 1 ) ; if ( do_rf64 ) total_riff_bytes += sizeof ( ds64hdr ) + sizeof ( ds64_chunk ) ; <S2SV_StartBug> if ( write_junk ) total_riff_bytes += sizeof ( junkchunk ) ; <S2SV_EndBug> strncpy ( fmthdr . ckID , "fmt<S2SV_blank>" , sizeof ( fmthdr . ckID ) ) ; strncpy ( datahdr . ckID , "data" , sizeof ( datahdr . ckID ) ) ; fmthdr . ckSize = wavhdrsize ; if ( write_junk ) { CLEAR ( junkchunk ) ; strncpy ( junkchunk . ckID , "junk" , sizeof ( junkchunk . ckID ) ) ; junkchunk . ckSize = sizeof ( junkchunk ) - 8 ; WavpackNativeToLittleEndian ( & junkchunk , ChunkHeaderFormat ) ; } if ( do_rf64 ) { strncpy ( ds64hdr . ckID , "ds64" , sizeof ( ds64hdr . ckID ) ) ; <S2SV_StartBug> ds64hdr . ckSize = sizeof ( ds64_chunk ) ; <S2SV_EndBug> CLEAR ( ds64_chunk ) ; ds64_chunk . riffSize64 = total_riff_bytes ; ds64_chunk . dataSize64 = total_data_bytes ; <S2SV_StartBug> ds64_chunk . sampleCount64 = total_samples ; <S2SV_EndBug> riffhdr . ckSize = ( uint32_t ) - 1 ; datahdr . ckSize = ( uint32_t ) - 1 ; WavpackNativeToLittleEndian ( & ds64hdr , ChunkHeaderFormat ) ; WavpackNativeToLittleEndian ( & ds64_chunk , DS64ChunkFormat ) ; } else { riffhdr . ckSize = ( uint32_t ) total_riff_bytes ; datahdr . ckSize = ( uint32_t ) total_data_bytes ; } <S2SV_StartBug> WavpackNativeToLittleEndian ( & riffhdr , ChunkHeaderFormat ) ; <S2SV_EndBug> WavpackNativeToLittleEndian ( & fmthdr , ChunkHeaderFormat ) ; WavpackNativeToLittleEndian ( & wavhdr , WaveHeaderFormat ) ; WavpackNativeToLittleEndian ( & datahdr , ChunkHeaderFormat ) ; if ( ! DoWriteFile ( outfile , & riffhdr , sizeof ( riffhdr ) , & bcount ) || bcount != sizeof ( riffhdr ) || ( do_rf64 && ( ! DoWriteFile ( outfile , & ds64hdr , sizeof ( ds64hdr ) , & bcount ) || bcount != sizeof ( ds64hdr ) ) ) || <S2SV_StartBug> ( do_rf64 && ( ! DoWriteFile ( outfile , & ds64_chunk , sizeof ( ds64_chunk ) , & bcount ) || bcount != sizeof ( ds64_chunk ) ) ) || <S2SV_EndBug> ( write_junk && ( ! DoWriteFile ( outfile , & junkchunk , sizeof ( junkchunk ) , & bcount ) || bcount != sizeof ( junkchunk ) ) ) || ! DoWriteFile ( outfile , & fmthdr , sizeof ( fmthdr ) , & bcount ) || bcount != sizeof ( fmthdr ) || ! DoWriteFile ( outfile , & wavhdr , wavhdrsize , & bcount ) || bcount != wavhdrsize || ! DoWriteFile ( outfile , & datahdr , sizeof ( datahdr ) , & bcount ) || bcount != sizeof ( datahdr ) ) { error_line ( "can\'t<S2SV_blank>write<S2SV_blank>.WAV<S2SV_blank>data,<S2SV_blank>disk<S2SV_blank>probably<S2SV_blank>full!" ) ; return FALSE ; } return TRUE ; }
CWE-665 int ParseCaffHeaderConfig ( FILE * infile , char * infilename , char * fourcc , WavpackContext * wpc , WavpackConfig * config ) { <S2SV_StartBug> uint32_t chan_chunk = 0 , channel_layout = 0 , bcount ; <S2SV_EndBug> unsigned char * channel_identities = NULL ; unsigned char * channel_reorder = NULL ; int64_t total_samples = 0 , infilesize ; CAFFileHeader caf_file_header ; CAFChunkHeader caf_chunk_header ; CAFAudioFormat caf_audio_format ; int i ; infilesize = DoGetFileSize ( infile ) ; memcpy ( & caf_file_header , fourcc , 4 ) ; if ( ( ! DoReadFile ( infile , ( ( char * ) & caf_file_header ) + 4 , sizeof ( CAFFileHeader ) - 4 , & bcount ) || bcount != sizeof ( CAFFileHeader ) - 4 ) ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.CAF<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & caf_file_header , sizeof ( CAFFileHeader ) ) ) { error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackBigEndianToNative ( & caf_file_header , CAFFileHeaderFormat ) ; if ( caf_file_header . mFileVersion != 1 ) { error_line ( "%s:<S2SV_blank>can\'t<S2SV_blank>handle<S2SV_blank>version<S2SV_blank>%d<S2SV_blank>.CAF<S2SV_blank>files!" , infilename , caf_file_header . mFileVersion ) ; return WAVPACK_SOFT_ERROR ; } while ( 1 ) { if ( ! DoReadFile ( infile , & caf_chunk_header , sizeof ( CAFChunkHeader ) , & bcount ) || bcount != sizeof ( CAFChunkHeader ) ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.CAF<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & caf_chunk_header , sizeof ( CAFChunkHeader ) ) ) { error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackBigEndianToNative ( & caf_chunk_header , CAFChunkHeaderFormat ) ; if ( ! strncmp ( caf_chunk_header . mChunkType , "desc" , 4 ) ) { int supported = TRUE ; if ( caf_chunk_header . mChunkSize != sizeof ( CAFAudioFormat ) || ! DoReadFile ( infile , & caf_audio_format , ( uint32_t ) caf_chunk_header . mChunkSize , & bcount ) || bcount != caf_chunk_header . mChunkSize ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.CAF<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & caf_audio_format , ( uint32_t ) caf_chunk_header . mChunkSize ) ) { error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } <S2SV_StartBug> WavpackBigEndianToNative ( & caf_audio_format , CAFAudioFormatFormat ) ; <S2SV_EndBug> if ( debug_logging_mode ) { char formatstr [ 5 ] ; memcpy ( formatstr , caf_audio_format . mFormatID , 4 ) ; formatstr [ 4 ] = 0 ; error_line ( "format<S2SV_blank>=<S2SV_blank>%s,<S2SV_blank>flags<S2SV_blank>=<S2SV_blank>%x,<S2SV_blank>sampling<S2SV_blank>rate<S2SV_blank>=<S2SV_blank>%g" , formatstr , caf_audio_format . mFormatFlags , caf_audio_format . mSampleRate ) ; error_line ( "packet<S2SV_blank>=<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>and<S2SV_blank>%d<S2SV_blank>frames" , caf_audio_format . mBytesPerPacket , caf_audio_format . mFramesPerPacket ) ; error_line ( "channels<S2SV_blank>per<S2SV_blank>frame<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>bits<S2SV_blank>per<S2SV_blank>channel<S2SV_blank>=<S2SV_blank>%d" , caf_audio_format . mChannelsPerFrame , caf_audio_format . mBitsPerChannel ) ; } if ( strncmp ( caf_audio_format . mFormatID , "lpcm" , 4 ) || ( caf_audio_format . mFormatFlags & ~ 3 ) ) supported = FALSE ; else if ( caf_audio_format . mSampleRate < 1.0 || caf_audio_format . mSampleRate > 16777215.0 || caf_audio_format . mSampleRate != floor ( caf_audio_format . mSampleRate ) ) supported = FALSE ; else if ( ! caf_audio_format . mChannelsPerFrame || caf_audio_format . mChannelsPerFrame > 256 ) supported = FALSE ; else if ( caf_audio_format . mBitsPerChannel < 1 || caf_audio_format . mBitsPerChannel > 32 || ( ( caf_audio_format . mFormatFlags & CAF_FORMAT_FLOAT ) && caf_audio_format . mBitsPerChannel != 32 ) ) supported = FALSE ; else if ( caf_audio_format . mFramesPerPacket != 1 || caf_audio_format . mBytesPerPacket / caf_audio_format . mChannelsPerFrame < ( caf_audio_format . mBitsPerChannel + 7 ) / 8 || caf_audio_format . mBytesPerPacket / caf_audio_format . mChannelsPerFrame > 4 || caf_audio_format . mBytesPerPacket % caf_audio_format . mChannelsPerFrame ) supported = FALSE ; if ( ! supported ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>an<S2SV_blank>unsupported<S2SV_blank>.CAF<S2SV_blank>format!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } config -> bytes_per_sample = caf_audio_format . mBytesPerPacket / caf_audio_format . mChannelsPerFrame ; config -> float_norm_exp = ( caf_audio_format . mFormatFlags & CAF_FORMAT_FLOAT ) ? 127 : 0 ; config -> bits_per_sample = caf_audio_format . mBitsPerChannel ; config -> num_channels = caf_audio_format . mChannelsPerFrame ; config -> sample_rate = ( int ) caf_audio_format . mSampleRate ; if ( ! ( caf_audio_format . mFormatFlags & CAF_FORMAT_LITTLE_ENDIAN ) && config -> bytes_per_sample > 1 ) config -> qmode |= QMODE_BIG_ENDIAN ; if ( config -> bytes_per_sample == 1 ) config -> qmode |= QMODE_SIGNED_BYTES ; if ( debug_logging_mode ) { if ( config -> float_norm_exp == 127 ) error_line ( "data<S2SV_blank>format:<S2SV_blank>32-bit<S2SV_blank>%s-endian<S2SV_blank>floating<S2SV_blank>point" , ( config -> qmode & QMODE_BIG_ENDIAN ) ? "big" : "little" ) ; else error_line ( "data<S2SV_blank>format:<S2SV_blank>%d-bit<S2SV_blank>%s-endian<S2SV_blank>integers<S2SV_blank>stored<S2SV_blank>in<S2SV_blank>%d<S2SV_blank>byte(s)" , config -> bits_per_sample , ( config -> qmode & QMODE_BIG_ENDIAN ) ? "big" : "little" , config -> bytes_per_sample ) ; } } else if ( ! strncmp ( caf_chunk_header . mChunkType , "chan" , 4 ) ) { CAFChannelLayout * caf_channel_layout ; if ( caf_chunk_header . mChunkSize < 0 || caf_chunk_header . mChunkSize > 1024 || caf_chunk_header . mChunkSize < sizeof ( CAFChannelLayout ) ) { error_line ( "this<S2SV_blank>.CAF<S2SV_blank>file<S2SV_blank>has<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>\'chan\'<S2SV_blank>chunk!" ) ; return WAVPACK_SOFT_ERROR ; } if ( debug_logging_mode ) error_line ( "\'chan\'<S2SV_blank>chunk<S2SV_blank>is<S2SV_blank>%d<S2SV_blank>bytes" , ( int ) caf_chunk_header . mChunkSize ) ; caf_channel_layout = malloc ( ( size_t ) caf_chunk_header . mChunkSize ) ; if ( ! DoReadFile ( infile , caf_channel_layout , ( uint32_t ) caf_chunk_header . mChunkSize , & bcount ) || bcount != caf_chunk_header . mChunkSize ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.CAF<S2SV_blank>file!" , infilename ) ; free ( caf_channel_layout ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , caf_channel_layout , ( uint32_t ) caf_chunk_header . mChunkSize ) ) { error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; free ( caf_channel_layout ) ; return WAVPACK_SOFT_ERROR ; } WavpackBigEndianToNative ( caf_channel_layout , CAFChannelLayoutFormat ) ; chan_chunk = 1 ; if ( config -> channel_mask || ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) { error_line ( "this<S2SV_blank>CAF<S2SV_blank>file<S2SV_blank>already<S2SV_blank>has<S2SV_blank>channel<S2SV_blank>order<S2SV_blank>information!" ) ; free ( caf_channel_layout ) ; return WAVPACK_SOFT_ERROR ; } switch ( caf_channel_layout -> mChannelLayoutTag ) { case kCAFChannelLayoutTag_UseChannelDescriptions : { CAFChannelDescription * descriptions = ( CAFChannelDescription * ) ( caf_channel_layout + 1 ) ; int num_descriptions = caf_channel_layout -> mNumberChannelDescriptions ; int label , cindex = 0 , idents = 0 ; if ( caf_chunk_header . mChunkSize != sizeof ( CAFChannelLayout ) + sizeof ( CAFChannelDescription ) * num_descriptions || num_descriptions != config -> num_channels ) { error_line ( "channel<S2SV_blank>descriptions<S2SV_blank>in<S2SV_blank>\'chan\'<S2SV_blank>chunk<S2SV_blank>are<S2SV_blank>the<S2SV_blank>wrong<S2SV_blank>size!" ) ; free ( caf_channel_layout ) ; return WAVPACK_SOFT_ERROR ; } if ( num_descriptions >= 256 ) { error_line ( "%d<S2SV_blank>channel<S2SV_blank>descriptions<S2SV_blank>is<S2SV_blank>more<S2SV_blank>than<S2SV_blank>we<S2SV_blank>can<S2SV_blank>handle...ignoring!" ) ; break ; } channel_reorder = malloc ( num_descriptions ) ; memset ( channel_reorder , - 1 , num_descriptions ) ; channel_identities = malloc ( num_descriptions + 1 ) ; for ( i = 0 ; i < num_descriptions ; ++ i ) { WavpackBigEndianToNative ( descriptions + i , CAFChannelDescriptionFormat ) ; if ( debug_logging_mode ) error_line ( "chan<S2SV_blank>%d<S2SV_blank>--><S2SV_blank>%d" , i + 1 , descriptions [ i ] . mChannelLabel ) ; } for ( label = 1 ; label <= 18 ; ++ label ) for ( i = 0 ; i < num_descriptions ; ++ i ) if ( descriptions [ i ] . mChannelLabel == label ) { config -> channel_mask |= 1 << ( label - 1 ) ; channel_reorder [ i ] = cindex ++ ; break ; } for ( i = 0 ; i < num_descriptions ; ++ i ) if ( channel_reorder [ i ] == ( unsigned char ) - 1 ) { uint32_t clabel = descriptions [ i ] . mChannelLabel ; if ( clabel == 0 || clabel == 0xffffffff || clabel == 100 ) channel_identities [ idents ++ ] = 0xff ; else if ( ( clabel >= 33 && clabel <= 44 ) || ( clabel >= 200 && clabel <= 207 ) || ( clabel >= 301 && clabel <= 305 ) ) channel_identities [ idents ++ ] = clabel >= 301 ? clabel - 80 : clabel ; else { error_line ( "warning:<S2SV_blank>unknown<S2SV_blank>channel<S2SV_blank>descriptions<S2SV_blank>label:<S2SV_blank>%d" , clabel ) ; channel_identities [ idents ++ ] = 0xff ; } channel_reorder [ i ] = cindex ++ ; } for ( i = 0 ; i < num_descriptions ; ++ i ) if ( channel_reorder [ i ] != i ) break ; if ( i == num_descriptions ) { free ( channel_reorder ) ; channel_reorder = NULL ; } else { config -> qmode |= QMODE_REORDERED_CHANS ; channel_layout = num_descriptions ; } if ( ! idents ) { free ( channel_identities ) ; channel_identities = NULL ; } else channel_identities [ idents ] = 0 ; if ( debug_logging_mode ) { error_line ( "layout_tag<S2SV_blank>=<S2SV_blank>0x%08x,<S2SV_blank>so<S2SV_blank>generated<S2SV_blank>bitmap<S2SV_blank>of<S2SV_blank>0x%08x<S2SV_blank>from<S2SV_blank>%d<S2SV_blank>descriptions,<S2SV_blank>%d<S2SV_blank>non-MS" , caf_channel_layout -> mChannelLayoutTag , config -> channel_mask , caf_channel_layout -> mNumberChannelDescriptions , idents ) ; if ( channel_reorder && num_descriptions <= 8 ) { char reorder_string [ ] = "12345678" ; for ( i = 0 ; i < num_descriptions ; ++ i ) reorder_string [ i ] = channel_reorder [ i ] + '1' ; reorder_string [ i ] = 0 ; error_line ( "reordering<S2SV_blank>string<S2SV_blank>=<S2SV_blank>\\"%s\\"\\n" , reorder_string ) ; } } } break ; case kCAFChannelLayoutTag_UseChannelBitmap : config -> channel_mask = caf_channel_layout -> mChannelBitmap ; if ( debug_logging_mode ) error_line ( "layout_tag<S2SV_blank>=<S2SV_blank>0x%08x,<S2SV_blank>so<S2SV_blank>using<S2SV_blank>supplied<S2SV_blank>bitmap<S2SV_blank>of<S2SV_blank>0x%08x" , caf_channel_layout -> mChannelLayoutTag , caf_channel_layout -> mChannelBitmap ) ; break ; default : for ( i = 0 ; i < NUM_LAYOUTS ; ++ i ) if ( caf_channel_layout -> mChannelLayoutTag == layouts [ i ] . mChannelLayoutTag ) { config -> channel_mask = layouts [ i ] . mChannelBitmap ; channel_layout = layouts [ i ] . mChannelLayoutTag ; if ( layouts [ i ] . mChannelReorder ) { channel_reorder = ( unsigned char * ) strdup ( layouts [ i ] . mChannelReorder ) ; config -> qmode |= QMODE_REORDERED_CHANS ; } if ( layouts [ i ] . mChannelIdentities ) channel_identities = ( unsigned char * ) strdup ( layouts [ i ] . mChannelIdentities ) ; if ( debug_logging_mode ) error_line ( "layout_tag<S2SV_blank>0x%08x<S2SV_blank>found<S2SV_blank>in<S2SV_blank>table,<S2SV_blank>bitmap<S2SV_blank>=<S2SV_blank>0x%08x,<S2SV_blank>reorder<S2SV_blank>=<S2SV_blank>%s,<S2SV_blank>identities<S2SV_blank>=<S2SV_blank>%s" , channel_layout , config -> channel_mask , channel_reorder ? "yes" : "no" , channel_identities ? "yes" : "no" ) ; break ; } if ( i == NUM_LAYOUTS && debug_logging_mode ) error_line ( "layout_tag<S2SV_blank>0x%08x<S2SV_blank>not<S2SV_blank>found<S2SV_blank>in<S2SV_blank>table...all<S2SV_blank>channels<S2SV_blank>unassigned" , caf_channel_layout -> mChannelLayoutTag ) ; break ; } free ( caf_channel_layout ) ; } else if ( ! strncmp ( caf_chunk_header . mChunkType , "data" , 4 ) ) { uint32_t mEditCount ; <S2SV_StartBug> if ( ! DoReadFile ( infile , & mEditCount , sizeof ( mEditCount ) , & bcount ) || <S2SV_EndBug> bcount != sizeof ( mEditCount ) ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.CAF<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & mEditCount , sizeof ( mEditCount ) ) ) { error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } if ( ( config -> qmode & QMODE_IGNORE_LENGTH ) || caf_chunk_header . mChunkSize == - 1 ) { config -> qmode |= QMODE_IGNORE_LENGTH ; if ( infilesize && DoGetFilePosition ( infile ) != - 1 ) total_samples = ( infilesize - DoGetFilePosition ( infile ) ) / caf_audio_format . mBytesPerPacket ; else total_samples = - 1 ; } else { if ( infilesize && infilesize - caf_chunk_header . mChunkSize > 16777216 ) { error_line ( ".CAF<S2SV_blank>file<S2SV_blank>%s<S2SV_blank>has<S2SV_blank>over<S2SV_blank>16<S2SV_blank>MB<S2SV_blank>of<S2SV_blank>extra<S2SV_blank>CAFF<S2SV_blank>data,<S2SV_blank>probably<S2SV_blank>is<S2SV_blank>corrupt!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( ( caf_chunk_header . mChunkSize - 4 ) % caf_audio_format . mBytesPerPacket ) { error_line ( ".CAF<S2SV_blank>file<S2SV_blank>%s<S2SV_blank>has<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>data<S2SV_blank>chunk<S2SV_blank>size,<S2SV_blank>probably<S2SV_blank>is<S2SV_blank>corrupt!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } total_samples = ( caf_chunk_header . mChunkSize - 4 ) / caf_audio_format . mBytesPerPacket ; if ( ! total_samples ) { error_line ( "this<S2SV_blank>.CAF<S2SV_blank>file<S2SV_blank>has<S2SV_blank>no<S2SV_blank>audio<S2SV_blank>samples,<S2SV_blank>probably<S2SV_blank>is<S2SV_blank>corrupt!" ) ; return WAVPACK_SOFT_ERROR ; } if ( total_samples > MAX_WAVPACK_SAMPLES ) { error_line ( "%s<S2SV_blank>has<S2SV_blank>too<S2SV_blank>many<S2SV_blank>samples<S2SV_blank>for<S2SV_blank>WavPack!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } } break ; } else { uint32_t bytes_to_copy = ( uint32_t ) caf_chunk_header . mChunkSize ; char * buff ; if ( caf_chunk_header . mChunkSize < 0 || caf_chunk_header . mChunkSize > 1048576 ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.CAF<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } buff = malloc ( bytes_to_copy ) ; if ( debug_logging_mode ) error_line ( "extra<S2SV_blank>unknown<S2SV_blank>chunk<S2SV_blank>\\"%c%c%c%c\\"<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes" , caf_chunk_header . mChunkType [ 0 ] , caf_chunk_header . mChunkType [ 1 ] , caf_chunk_header . mChunkType [ 2 ] , caf_chunk_header . mChunkType [ 3 ] , caf_chunk_header . mChunkSize ) ; if ( ! DoReadFile ( infile , buff , bytes_to_copy , & bcount ) || bcount != bytes_to_copy || ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , buff , bytes_to_copy ) ) ) { error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; free ( buff ) ; return WAVPACK_SOFT_ERROR ; } free ( buff ) ; } } if ( ! chan_chunk && ! config -> channel_mask && config -> num_channels <= 2 && ! ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) config -> channel_mask = 0x5 - config -> num_channels ; if ( ! WavpackSetConfiguration64 ( wpc , config , total_samples , channel_identities ) ) { error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } if ( channel_identities ) free ( channel_identities ) ; if ( channel_layout || channel_reorder ) { if ( ! WavpackSetChannelLayout ( wpc , channel_layout , channel_reorder ) ) { error_line ( "problem<S2SV_blank>with<S2SV_blank>setting<S2SV_blank>channel<S2SV_blank>layout<S2SV_blank>(should<S2SV_blank>not<S2SV_blank>happen)" ) ; return WAVPACK_SOFT_ERROR ; } if ( channel_reorder ) free ( channel_reorder ) ; } return WAVPACK_NO_ERROR ; }
CWE-125 ut32 armass_assemble ( const char * str , ut64 off , int thumb ) { int i , j ; char buf [ 128 ] ; ArmOpcode aop = { . off = off } ; <S2SV_StartBug> for ( i = j = 0 ; i < sizeof ( buf ) - 1 && str [ i ] ; i ++ , j ++ ) { <S2SV_EndBug> if ( str [ j ] == '#' ) { i -- ; continue ; } buf [ i ] = tolower ( ( const ut8 ) str [ j ] ) ; } buf [ i ] = 0 ; arm_opcode_parse ( & aop , buf ) ; aop . off = off ; if ( thumb < 0 || thumb > 1 ) { return - 1 ; } if ( ! assemble [ thumb ] ( & aop , off , buf ) ) { return - 1 ; } return aop . o ; }
CWE-125 static bool parseOperands ( char * str , ArmOp * op ) { char * t = strdup ( str ) ; int operand = 0 ; char * token = t ; char * x ; int imm_count = 0 ; int mem_opt = 0 ; if ( ! token ) { return false ; } while ( token ) { char * next = strchr ( token , ',' ) ; if ( next ) { * next ++ = 0 ; } while ( token [ 0 ] == '<S2SV_blank>' ) { token ++ ; } if ( operand >= MAX_OPERANDS ) { eprintf ( "Too<S2SV_blank>many<S2SV_blank>operands\\n" ) ; return false ; } op -> operands [ operand ] . type = ARM_NOTYPE ; op -> operands [ operand ] . reg_type = ARM_UNDEFINED ; op -> operands [ operand ] . shift = ARM_NO_SHIFT ; while ( token [ 0 ] == '<S2SV_blank>' || token [ 0 ] == '[' || token [ 0 ] == ']' ) { token ++ ; } if ( ! strncmp ( token , "lsl" , 3 ) ) { op -> operands [ operand ] . shift = ARM_LSL ; } else if ( ! strncmp ( token , "lsr" , 3 ) ) { op -> operands [ operand ] . shift = ARM_LSR ; } else if ( ! strncmp ( token , "asr" , 3 ) ) { op -> operands [ operand ] . shift = ARM_ASR ; } <S2SV_StartBug> if ( op -> operands [ operand ] . shift != ARM_NO_SHIFT ) { <S2SV_EndBug> op -> operands_count ++ ; op -> operands [ operand ] . shift_amount = r_num_math ( NULL , token + 4 ) ; if ( op -> operands [ operand ] . shift_amount > 63 ) { return false ; } operand ++ ; token = next ; continue ; } switch ( token [ 0 ] ) { case 'x' : x = strchr ( token , ',' ) ; if ( x ) { x [ 0 ] = '\\0' ; } op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_GPR ; op -> operands [ operand ] . reg_type = ARM_REG64 ; op -> operands [ operand ] . reg = r_num_math ( NULL , token + 1 ) ; if ( op -> operands [ operand ] . reg > 31 ) { return false ; } break ; case 'w' : op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_GPR ; op -> operands [ operand ] . reg_type = ARM_REG32 ; op -> operands [ operand ] . reg = r_num_math ( NULL , token + 1 ) ; if ( op -> operands [ operand ] . reg > 31 ) { return false ; } break ; case 'v' : op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_FP ; op -> operands [ operand ] . reg = r_num_math ( NULL , token + 1 ) ; break ; case 's' : case 'S' : if ( token [ 1 ] == 'P' || token [ 1 ] == 'p' ) { int i ; for ( i = 0 ; msr_const [ i ] . name ; i ++ ) { if ( ! r_str_ncasecmp ( token , msr_const [ i ] . name , strlen ( msr_const [ i ] . name ) ) ) { op -> operands [ operand ] . sp_val = msr_const [ i ] . val ; break ; } } op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_GPR ; op -> operands [ operand ] . reg_type = ARM_SP | ARM_REG64 ; op -> operands [ operand ] . reg = 31 ; break ; } mem_opt = get_mem_option ( token ) ; if ( mem_opt != - 1 ) { op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_MEM_OPT ; op -> operands [ operand ] . mem_option = mem_opt ; } break ; case 'L' : case 'l' : case 'I' : case 'i' : case 'N' : case 'n' : case 'O' : case 'o' : case 'p' : case 'P' : mem_opt = get_mem_option ( token ) ; if ( mem_opt != - 1 ) { op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_MEM_OPT ; op -> operands [ operand ] . mem_option = mem_opt ; } break ; case '-' : op -> operands [ operand ] . sign = - 1 ; default : op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_CONSTANT ; op -> operands [ operand ] . immediate = r_num_math ( NULL , token ) ; imm_count ++ ; break ; } token = next ; operand ++ ; if ( operand > MAX_OPERANDS ) { free ( t ) ; return false ; } } free ( t ) ; return true ; }
CWE-400 void * gstd_accept ( int fd , char * * display_creds , char * * export_name , char * * mech ) { gss_name_t client ; gss_OID mech_oid ; struct gstd_tok * tok ; gss_ctx_id_t ctx = GSS_C_NO_CONTEXT ; gss_buffer_desc in , out ; OM_uint32 maj , min ; int ret ; * display_creds = NULL ; * export_name = NULL ; out . length = 0 ; in . length = 0 ; read_packet ( fd , & in , 60000 , 1 ) ; again : while ( ( ret = read_packet ( fd , & in , 60000 , 0 ) ) == - 2 ) ; if ( ret < 1 ) return NULL ; maj = gss_accept_sec_context ( & min , & ctx , GSS_C_NO_CREDENTIAL , & in , GSS_C_NO_CHANNEL_BINDINGS , & client , & mech_oid , & out , NULL , <S2SV_StartBug> NULL , NULL ) ; <S2SV_EndBug> if ( out . length && write_packet ( fd , & out ) ) { gss_release_buffer ( & min , & out ) ; return NULL ; } <S2SV_StartBug> GSTD_GSS_ERROR ( maj , min , NULL , "gss_accept_sec_context" ) ; <S2SV_EndBug> if ( maj & GSS_S_CONTINUE_NEEDED ) goto again ; * display_creds = gstd_get_display_name ( client ) ; * export_name = gstd_get_export_name ( client ) ; * mech = gstd_get_mech ( mech_oid ) ; gss_release_name ( & min , & client ) ; SETUP_GSTD_TOK ( tok , ctx , fd , "gstd_accept" ) ; return tok ; }
CWE-400 static int read_packet ( int fd , gss_buffer_t buf , int timeout , int first ) { int ret ; static uint32_t len = 0 ; static char len_buf [ 4 ] ; static int len_buf_pos = 0 ; static char * tmpbuf = 0 ; static int tmpbuf_pos = 0 ; if ( first ) { len_buf_pos = 0 ; return - 2 ; } if ( len_buf_pos < 4 ) { ret = timed_read ( fd , & len_buf [ len_buf_pos ] , 4 - len_buf_pos , timeout ) ; if ( ret == - 1 ) { if ( errno == EINTR || errno == EAGAIN ) return - 2 ; LOG ( LOG_ERR , ( "%s" , strerror ( errno ) ) ) ; <S2SV_StartBug> return - 1 ; <S2SV_EndBug> } if ( ret == 0 ) { if ( len_buf_pos == 0 ) return 0 ; LOG ( LOG_INFO , ( "EOF<S2SV_blank>reading<S2SV_blank>packet<S2SV_blank>len" ) ) ; <S2SV_StartBug> return - 1 ; <S2SV_EndBug> } len_buf_pos += ret ; } if ( len_buf_pos != 4 ) return - 2 ; len = ntohl ( * ( uint32_t * ) len_buf ) ; if ( len > GSTD_MAXPACKETCONTENTS + 512 ) { LOG ( LOG_ERR , ( "ridiculous<S2SV_blank>length,<S2SV_blank>%ld" , len ) ) ; <S2SV_StartBug> return - 1 ; <S2SV_EndBug> } if ( ! tmpbuf ) { if ( ( tmpbuf = malloc ( len ) ) == NULL ) { LOG ( LOG_CRIT , ( "malloc<S2SV_blank>failure,<S2SV_blank>%ld<S2SV_blank>bytes" , len ) ) ; <S2SV_StartBug> return - 1 ; <S2SV_EndBug> } } ret = timed_read ( fd , tmpbuf + tmpbuf_pos , len - tmpbuf_pos , timeout ) ; if ( ret == - 1 ) { if ( errno == EINTR || errno == EAGAIN ) return - 2 ; LOG ( LOG_ERR , ( "%s" , strerror ( errno ) ) ) ; <S2SV_StartBug> return - 1 ; <S2SV_EndBug> } if ( ret == 0 ) { LOG ( LOG_ERR , ( "EOF<S2SV_blank>while<S2SV_blank>reading<S2SV_blank>packet<S2SV_blank>(len=%d)" , len ) ) ; <S2SV_StartBug> return - 1 ; <S2SV_EndBug> } tmpbuf_pos += ret ; if ( tmpbuf_pos == len ) { buf -> length = len ; buf -> value = tmpbuf ; len = len_buf_pos = tmpbuf_pos = 0 ; tmpbuf = NULL ; LOG ( LOG_DEBUG , ( "read<S2SV_blank>packet<S2SV_blank>of<S2SV_blank>length<S2SV_blank>%d" , buf -> length ) ) ; return 1 ; } return - 2 ; <S2SV_StartBug> } <S2SV_EndBug>
CWE-787 int main ( int argc , char * * argv ) { int i , n_valid , do_write , do_scrub ; char * c , * dname , * name ; DIR * dir ; FILE * fp ; pdf_t * pdf ; pdf_flag_t flags ; if ( argc < 2 ) usage ( ) ; do_write = do_scrub = flags = 0 ; name = NULL ; for ( i = 1 ; i < argc ; i ++ ) { if ( strncmp ( argv [ i ] , "-w" , 2 ) == 0 ) do_write = 1 ; else if ( strncmp ( argv [ i ] , "-i" , 2 ) == 0 ) flags |= PDF_FLAG_DISP_CREATOR ; else if ( strncmp ( argv [ i ] , "-q" , 2 ) == 0 ) flags |= PDF_FLAG_QUIET ; else if ( strncmp ( argv [ i ] , "-s" , 2 ) == 0 ) do_scrub = 1 ; else if ( argv [ i ] [ 0 ] != '-' ) name = argv [ i ] ; else if ( argv [ i ] [ 0 ] == '-' ) usage ( ) ; } if ( ! name ) usage ( ) ; if ( ! ( fp = fopen ( name , "r" ) ) ) { ERR ( "Could<S2SV_blank>not<S2SV_blank>open<S2SV_blank>file<S2SV_blank>\'%s\'\\n" , argv [ 1 ] ) ; return - 1 ; } else if ( ! pdf_is_pdf ( fp ) ) { ERR ( "\'%s\'<S2SV_blank>specified<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>PDF\\n" , name ) ; fclose ( fp ) ; return - 1 ; } if ( ! ( pdf = init_pdf ( fp , name ) ) ) { fclose ( fp ) ; return - 1 ; } for ( i = 0 , n_valid = 0 ; i < pdf -> n_xrefs ; i ++ ) if ( pdf -> xrefs [ i ] . version ) ++ n_valid ; if ( n_valid < 2 ) { if ( ! ( flags & ( PDF_FLAG_QUIET | PDF_FLAG_DISP_CREATOR ) ) ) printf ( "%s:<S2SV_blank>There<S2SV_blank>is<S2SV_blank>only<S2SV_blank>one<S2SV_blank>version<S2SV_blank>of<S2SV_blank>this<S2SV_blank>PDF\\n" , pdf -> name ) ; if ( do_write ) { fclose ( fp ) ; pdf_delete ( pdf ) ; return 0 ; } } dname = NULL ; if ( do_write ) { if ( ( c = strrchr ( name , '/' ) ) ) name = c + 1 ; if ( ( c = strrchr ( name , '.' ) ) ) * c = '\\0' ; <S2SV_StartBug> dname = malloc ( strlen ( name ) + 16 ) ; <S2SV_EndBug> sprintf ( dname , "%s-versions" , name ) ; if ( ! ( dir = opendir ( dname ) ) ) mkdir ( dname , S_IRWXU ) ; else { ERR ( "This<S2SV_blank>directory<S2SV_blank>already<S2SV_blank>exists,<S2SV_blank>PDF<S2SV_blank>version<S2SV_blank>extraction<S2SV_blank>will<S2SV_blank>" "not<S2SV_blank>occur.\\n" ) ; fclose ( fp ) ; closedir ( dir ) ; free ( dname ) ; pdf_delete ( pdf ) ; return - 1 ; } for ( i = 0 ; i < pdf -> n_xrefs ; i ++ ) if ( pdf -> xrefs [ i ] . version ) write_version ( fp , name , dname , & pdf -> xrefs [ i ] ) ; } pdf_summarize ( fp , pdf , dname , flags ) ; if ( do_scrub ) scrub_document ( fp , pdf ) ; if ( flags & PDF_FLAG_DISP_CREATOR ) display_creator ( fp , pdf ) ; fclose ( fp ) ; free ( dname ) ; pdf_delete ( pdf ) ; return 0 ; }
CWE-787 static void write_version ( FILE * fp , const char * fname , const char * dirname , xref_t * xref ) { long start ; char * c , * new_fname , data ; FILE * new_fp ; start = ftell ( fp ) ; if ( ( c = strstr ( fname , ".pdf" ) ) ) * c = '\\0' ; <S2SV_StartBug> new_fname = malloc ( strlen ( fname ) + strlen ( dirname ) + 16 ) ; <S2SV_EndBug> snprintf ( new_fname , strlen ( fname ) + strlen ( dirname ) + 16 , "%s/%s-version-%d.pdf" , dirname , fname , xref -> version ) ; if ( ! ( new_fp = fopen ( new_fname , "w" ) ) ) { ERR ( "Could<S2SV_blank>not<S2SV_blank>create<S2SV_blank>file<S2SV_blank>\'%s\'\\n" , new_fname ) ; fseek ( fp , start , SEEK_SET ) ; free ( new_fname ) ; return ; } fseek ( fp , 0 , SEEK_SET ) ; while ( fread ( & data , 1 , 1 , fp ) ) fwrite ( & data , 1 , 1 , new_fp ) ; fprintf ( new_fp , "\\r\\nstartxref\\r\\n%ld\\r\\n%%%%EOF" , xref -> start ) ; fclose ( new_fp ) ; free ( new_fname ) ; fseek ( fp , start , SEEK_SET ) ; }
CWE-787 static char * decode_text_string ( const char * str , size_t str_len ) { int idx , is_hex , is_utf16be , ascii_idx ; char * ascii , hex_buf [ 5 ] = { 0 } ; is_hex = is_utf16be = idx = ascii_idx = 0 ; if ( str [ 0 ] == '(' ) { <S2SV_StartBug> ascii = malloc ( strlen ( str ) + 1 ) ; <S2SV_EndBug> strncpy ( ascii , str , strlen ( str ) + 1 ) ; return ascii ; } else if ( str [ 0 ] == '<' ) { is_hex = 1 ; ++ idx ; } if ( is_hex && ( str_len > 5 ) && ( str [ idx ] == 'F' ) && ( str [ idx + 1 ] == 'E' ) && ( str [ idx + 2 ] == 'F' ) && ( str [ idx + 3 ] == 'F' ) ) { is_utf16be = 1 ; idx += 4 ; } else return NULL ; <S2SV_StartBug> ascii = malloc ( str_len ) ; <S2SV_EndBug> for ( ; idx < str_len ; ++ idx ) { hex_buf [ 0 ] = str [ idx ++ ] ; hex_buf [ 1 ] = str [ idx ++ ] ; hex_buf [ 2 ] = str [ idx ++ ] ; hex_buf [ 3 ] = str [ idx ] ; ascii [ ascii_idx ++ ] = strtol ( hex_buf , NULL , 16 ) ; } return ascii ; }
CWE-787 static char * get_header ( FILE * fp ) { <S2SV_StartBug> long start ; <S2SV_EndBug> <S2SV_StartBug> char * header ; <S2SV_EndBug> header = calloc ( 1 , 1024 ) ; <S2SV_StartBug> start = ftell ( fp ) ; <S2SV_EndBug> fseek ( fp , 0 , SEEK_SET ) ; SAFE_E ( fread ( header , 1 , 1023 , fp ) , 1023 , "Failed<S2SV_blank>to<S2SV_blank>load<S2SV_blank>PDF<S2SV_blank>header.\\n" ) ; fseek ( fp , start , SEEK_SET ) ; return header ; }
CWE-787 static char * get_object ( FILE * fp , int obj_id , const xref_t * xref , size_t * size , int * is_stream ) { static const int blk_sz = 256 ; int i , total_sz , read_sz , n_blks , search , stream ; size_t obj_sz ; char * c , * data ; long start ; const xref_entry_t * entry ; if ( size ) * size = 0 ; if ( is_stream ) * is_stream = 0 ; start = ftell ( fp ) ; entry = NULL ; for ( i = 0 ; i < xref -> n_entries ; i ++ ) if ( xref -> entries [ i ] . obj_id == obj_id ) { entry = & xref -> entries [ i ] ; break ; } if ( ! entry ) return NULL ; fseek ( fp , entry -> offset , SEEK_SET ) ; obj_sz = 0 ; total_sz = 0 ; n_blks = 1 ; <S2SV_StartBug> data = malloc ( blk_sz * n_blks ) ; <S2SV_EndBug> memset ( data , 0 , blk_sz * n_blks ) ; stream = 0 ; while ( ( read_sz = fread ( data + total_sz , 1 , blk_sz - 1 , fp ) ) && ! ferror ( fp ) ) { total_sz += read_sz ; * ( data + total_sz ) = '\\0' ; if ( total_sz + blk_sz >= ( blk_sz * n_blks ) ) data = realloc ( data , blk_sz * ( ++ n_blks ) ) ; search = total_sz - read_sz ; if ( search < 0 ) search = 0 ; if ( ( c = strstr ( data + search , "endobj" ) ) ) { * ( c + strlen ( "endobj" ) + 1 ) = '\\0' ; obj_sz = ( void * ) strstr ( data + search , "endobj" ) - ( void * ) data ; obj_sz += strlen ( "endobj" ) + 1 ; break ; } else if ( strstr ( data , "stream" ) ) stream = 1 ; } clearerr ( fp ) ; fseek ( fp , start , SEEK_SET ) ; if ( size ) * size = obj_sz ; if ( is_stream ) * is_stream = stream ; return data ; }
CWE-787 static void load_xref_from_plaintext ( FILE * fp , xref_t * xref ) { int i , buf_idx , obj_id , added_entries ; char c , buf [ 32 ] = { 0 } ; long start , pos ; start = ftell ( fp ) ; pos = xref -> end ; fseek ( fp , pos , SEEK_SET ) ; while ( ftell ( fp ) != 0 ) if ( SAFE_F ( fp , ( fgetc ( fp ) == '/' && fgetc ( fp ) == 'S' ) ) ) break ; else SAFE_E ( fseek ( fp , -- pos , SEEK_SET ) , 0 , "Failed<S2SV_blank>seek<S2SV_blank>to<S2SV_blank>xref<S2SV_blank>/Size.\\n" ) ; SAFE_E ( fread ( buf , 1 , 21 , fp ) , 21 , "Failed<S2SV_blank>to<S2SV_blank>load<S2SV_blank>entry<S2SV_blank>Size<S2SV_blank>string.\\n" ) ; xref -> n_entries = atoi ( buf + strlen ( "ize<S2SV_blank>" ) ) ; <S2SV_StartBug> xref -> entries = calloc ( 1 , xref -> n_entries * sizeof ( struct _xref_entry ) ) ; <S2SV_EndBug> obj_id = 0 ; fseek ( fp , xref -> start + strlen ( "xref" ) , SEEK_SET ) ; added_entries = 0 ; for ( i = 0 ; i < xref -> n_entries ; i ++ ) { c = fgetc ( fp ) ; while ( c == '\\n' || c == '\\r' ) c = fgetc ( fp ) ; buf_idx = 0 ; while ( c != '\\n' && c != '\\r' && ! feof ( fp ) && ! ferror ( fp ) && buf_idx < sizeof ( buf ) ) { buf [ buf_idx ++ ] = c ; c = fgetc ( fp ) ; } if ( buf_idx >= sizeof ( buf ) ) { ERR ( "Failed<S2SV_blank>to<S2SV_blank>locate<S2SV_blank>newline<S2SV_blank>character.<S2SV_blank>" "This<S2SV_blank>might<S2SV_blank>be<S2SV_blank>a<S2SV_blank>corrupt<S2SV_blank>PDF.\\n" ) ; exit ( EXIT_FAILURE ) ; } buf [ buf_idx ] = '\\0' ; if ( strchr ( buf , 't' ) ) break ; if ( strlen ( buf ) > 17 ) { xref -> entries [ i ] . obj_id = obj_id ++ ; xref -> entries [ i ] . offset = atol ( strtok ( buf , "<S2SV_blank>" ) ) ; xref -> entries [ i ] . gen_num = atoi ( strtok ( NULL , "<S2SV_blank>" ) ) ; xref -> entries [ i ] . f_or_n = buf [ 17 ] ; ++ added_entries ; } else { obj_id = atoi ( buf ) ; -- i ; } } xref -> n_entries = added_entries ; fseek ( fp , start , SEEK_SET ) ; }
CWE-787 static pdf_creator_t * new_creator ( int * n_elements ) { pdf_creator_t * daddy ; static const pdf_creator_t creator_template [ ] = { { "Title" , "" } , { "Author" , "" } , { "Subject" , "" } , { "Keywords" , "" } , { "Creator" , "" } , { "Producer" , "" } , { "CreationDate" , "" } , { "ModDate" , "" } , { "Trapped" , "" } , } ; <S2SV_StartBug> daddy = malloc ( sizeof ( creator_template ) ) ; <S2SV_EndBug> memcpy ( daddy , creator_template , sizeof ( creator_template ) ) ; if ( n_elements ) * n_elements = sizeof ( creator_template ) / sizeof ( creator_template [ 0 ] ) ; return daddy ; }
CWE-787 void pdf_load_pages_kids ( FILE * fp , pdf_t * pdf ) { int i , id , dummy ; char * buf , * c ; long start , sz ; start = ftell ( fp ) ; for ( i = 0 ; i < pdf -> n_xrefs ; i ++ ) { if ( pdf -> xrefs [ i ] . version && ( pdf -> xrefs [ i ] . end != 0 ) ) { fseek ( fp , pdf -> xrefs [ i ] . start , SEEK_SET ) ; while ( SAFE_F ( fp , ( fgetc ( fp ) != 't' ) ) ) ; sz = pdf -> xrefs [ i ] . end - ftell ( fp ) ; <S2SV_StartBug> buf = malloc ( sz + 1 ) ; <S2SV_EndBug> SAFE_E ( fread ( buf , 1 , sz , fp ) , sz , "Failed<S2SV_blank>to<S2SV_blank>load<S2SV_blank>/Root.\\n" ) ; buf [ sz ] = '\\0' ; if ( ! ( c = strstr ( buf , "/Root" ) ) ) { free ( buf ) ; continue ; } id = atoi ( c + strlen ( "/Root" ) + 1 ) ; free ( buf ) ; buf = get_object ( fp , id , & pdf -> xrefs [ i ] , NULL , & dummy ) ; if ( ! buf || ! ( c = strstr ( buf , "/Pages" ) ) ) { free ( buf ) ; continue ; } id = atoi ( c + strlen ( "/Pages" ) + 1 ) ; load_kids ( fp , id , & pdf -> xrefs [ i ] ) ; free ( buf ) ; } } fseek ( fp , start , SEEK_SET ) ; }
CWE-787 int pdf_load_xrefs ( FILE * fp , pdf_t * pdf ) { int i , ver , is_linear ; long pos , pos_count ; char x , * c , buf [ 256 ] ; c = NULL ; pdf -> n_xrefs = 0 ; fseek ( fp , 0 , SEEK_SET ) ; while ( get_next_eof ( fp ) >= 0 ) ++ pdf -> n_xrefs ; if ( ! pdf -> n_xrefs ) return 0 ; fseek ( fp , 0 , SEEK_SET ) ; <S2SV_StartBug> pdf -> xrefs = calloc ( 1 , sizeof ( xref_t ) * pdf -> n_xrefs ) ; <S2SV_EndBug> ver = 1 ; for ( i = 0 ; i < pdf -> n_xrefs ; i ++ ) { if ( ( pos = get_next_eof ( fp ) ) < 0 ) break ; pdf -> xrefs [ i ] . version = ver ++ ; pos_count = 0 ; while ( SAFE_F ( fp , ( ( x = fgetc ( fp ) ) != 'f' ) ) ) fseek ( fp , pos - ( ++ pos_count ) , SEEK_SET ) ; if ( pos_count >= sizeof ( buf ) ) { ERR ( "Failed<S2SV_blank>to<S2SV_blank>locate<S2SV_blank>the<S2SV_blank>startxref<S2SV_blank>token.<S2SV_blank>" "This<S2SV_blank>might<S2SV_blank>be<S2SV_blank>a<S2SV_blank>corrupt<S2SV_blank>PDF.\\n" ) ; return - 1 ; } memset ( buf , 0 , sizeof ( buf ) ) ; SAFE_E ( fread ( buf , 1 , pos_count , fp ) , pos_count , "Failed<S2SV_blank>to<S2SV_blank>read<S2SV_blank>startxref.\\n" ) ; c = buf ; while ( * c == '<S2SV_blank>' || * c == '\\n' || * c == '\\r' ) ++ c ; pdf -> xrefs [ i ] . start = atol ( c ) ; if ( pdf -> xrefs [ i ] . start == 0 ) get_xref_linear_skipped ( fp , & pdf -> xrefs [ i ] ) ; else { pos = ftell ( fp ) ; fseek ( fp , pdf -> xrefs [ i ] . start , SEEK_SET ) ; pdf -> xrefs [ i ] . end = get_next_eof ( fp ) ; fseek ( fp , pos , SEEK_SET ) ; } if ( ! is_valid_xref ( fp , pdf , & pdf -> xrefs [ i ] ) ) { is_linear = pdf -> xrefs [ i ] . is_linear ; memset ( & pdf -> xrefs [ i ] , 0 , sizeof ( xref_t ) ) ; pdf -> xrefs [ i ] . is_linear = is_linear ; rewind ( fp ) ; get_next_eof ( fp ) ; continue ; } load_xref_entries ( fp , & pdf -> xrefs [ i ] ) ; } if ( pdf -> xrefs [ 0 ] . is_linear ) resolve_linearized_pdf ( pdf ) ; load_creator ( fp , pdf ) ; return pdf -> n_xrefs ; }
CWE-787 pdf_t * pdf_new ( const char * name ) { const char * n ; pdf_t * pdf ; <S2SV_StartBug> pdf = calloc ( 1 , sizeof ( pdf_t ) ) ; <S2SV_EndBug> if ( name ) { if ( ( n = strrchr ( name , '/' ) ) ) ++ n ; else n = name ; <S2SV_StartBug> pdf -> name = malloc ( strlen ( n ) + 1 ) ; <S2SV_EndBug> strcpy ( pdf -> name , n ) ; } else { <S2SV_StartBug> pdf -> name = malloc ( strlen ( "Unknown" ) + 1 ) ; <S2SV_EndBug> strcpy ( pdf -> name , "Unknown" ) ; } return pdf ; }
CWE-787 void pdf_summarize ( FILE * fp , const pdf_t * pdf , const char * name , pdf_flag_t flags ) { int i , j , page , n_versions , n_entries ; FILE * dst , * out ; char * dst_name , * c ; dst = NULL ; dst_name = NULL ; if ( name ) { <S2SV_StartBug> dst_name = malloc ( strlen ( name ) * 2 + 16 ) ; <S2SV_EndBug> sprintf ( dst_name , "%s/%s" , name , name ) ; if ( ( c = strrchr ( dst_name , '.' ) ) && ( strncmp ( c , ".pdf" , 4 ) == 0 ) ) * c = '\\0' ; strcat ( dst_name , ".summary" ) ; if ( ! ( dst = fopen ( dst_name , "w" ) ) ) { ERR ( "Could<S2SV_blank>not<S2SV_blank>open<S2SV_blank>file<S2SV_blank>\'%s\'<S2SV_blank>for<S2SV_blank>writing\\n" , dst_name ) ; return ; } } out = ( dst ) ? dst : stdout ; n_versions = pdf -> n_xrefs ; if ( n_versions && pdf -> xrefs [ 0 ] . is_linear ) -- n_versions ; for ( i = 1 ; i < pdf -> n_xrefs ; ++ i ) if ( pdf -> xrefs [ i ] . end == 0 ) -- n_versions ; if ( ! pdf -> n_xrefs || ( ! n_versions && pdf -> xrefs [ 0 ] . is_linear ) ) n_versions = 1 ; n_entries = 0 ; for ( i = 0 ; ! ( const int ) pdf -> has_xref_streams && i < pdf -> n_xrefs ; i ++ ) { if ( flags & PDF_FLAG_QUIET ) continue ; for ( j = 0 ; j < pdf -> xrefs [ i ] . n_entries ; j ++ ) { ++ n_entries ; fprintf ( out , "%s:<S2SV_blank>--%c--<S2SV_blank>Version<S2SV_blank>%d<S2SV_blank>--<S2SV_blank>Object<S2SV_blank>%d<S2SV_blank>(%s)" , pdf -> name , pdf_get_object_status ( pdf , i , j ) , pdf -> xrefs [ i ] . version , pdf -> xrefs [ i ] . entries [ j ] . obj_id , get_type ( fp , pdf -> xrefs [ i ] . entries [ j ] . obj_id , & pdf -> xrefs [ i ] ) ) ; if ( 0 ) fprintf ( out , "<S2SV_blank>Page(%d)\\n" , page ) ; else fprintf ( out , "\\n" ) ; } } if ( ! ( flags & PDF_FLAG_QUIET ) ) { if ( pdf -> has_xref_streams || ! n_entries ) fprintf ( out , "%s:<S2SV_blank>This<S2SV_blank>PDF<S2SV_blank>contains<S2SV_blank>potential<S2SV_blank>cross<S2SV_blank>reference<S2SV_blank>streams.\\n" "%s:<S2SV_blank>An<S2SV_blank>object<S2SV_blank>summary<S2SV_blank>is<S2SV_blank>not<S2SV_blank>available.\\n" , pdf -> name , pdf -> name ) ; fprintf ( out , "----------<S2SV_blank>%s<S2SV_blank>----------\\n" "Versions:<S2SV_blank>%d\\n" , pdf -> name , n_versions ) ; if ( ! pdf -> has_xref_streams ) for ( i = 0 ; i < pdf -> n_xrefs ; i ++ ) { if ( pdf -> xrefs [ i ] . is_linear ) continue ; n_entries = pdf -> xrefs [ i ] . n_entries ; if ( pdf -> xrefs [ 0 ] . is_linear ) n_entries += pdf -> xrefs [ 0 ] . n_entries ; if ( pdf -> xrefs [ i ] . version && n_entries ) fprintf ( out , "Version<S2SV_blank>%d<S2SV_blank>--<S2SV_blank>%d<S2SV_blank>objects\\n" , pdf -> xrefs [ i ] . version , n_entries ) ; } } else fprintf ( out , "%s:<S2SV_blank>%d\\n" , pdf -> name , n_versions ) ; if ( dst ) { fclose ( dst ) ; free ( dst_name ) ; } }
CWE-119 void jslGetTokenString ( char * str , size_t len ) { if ( lex -> tk == LEX_ID ) { <S2SV_StartBug> strncpy ( str , "ID:" , len ) ; <S2SV_EndBug> <S2SV_StartBug> strncat ( str , jslGetTokenValueAsString ( ) , len ) ; <S2SV_EndBug> } else if ( lex -> tk == LEX_STR ) { <S2SV_StartBug> strncpy ( str , "String:\'" , len ) ; <S2SV_EndBug> <S2SV_StartBug> strncat ( str , jslGetTokenValueAsString ( ) , len ) ; <S2SV_EndBug> strncat ( str , "\'" , len ) ; } else jslTokenAsString ( lex -> tk , str , len ) ; }
CWE-119 void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { case LEX_EOF : strncpy ( str , "EOF" , len ) ; return ; case LEX_ID : strncpy ( str , "ID" , len ) ; return ; case LEX_INT : strncpy ( str , "INT" , len ) ; return ; case LEX_FLOAT : strncpy ( str , "FLOAT" , len ) ; return ; case LEX_STR : strncpy ( str , "STRING" , len ) ; return ; case LEX_UNFINISHED_STR : strncpy ( str , "UNFINISHED<S2SV_blank>STRING" , len ) ; return ; case LEX_TEMPLATE_LITERAL : strncpy ( str , "TEMPLATE<S2SV_blank>LITERAL" , len ) ; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , "UNFINISHED<S2SV_blank>TEMPLATE<S2SV_blank>LITERAL" , len ) ; return ; case LEX_REGEX : strncpy ( str , "REGEX" , len ) ; return ; case LEX_UNFINISHED_REGEX : strncpy ( str , "UNFINISHED<S2SV_blank>REGEX" , len ) ; return ; case LEX_UNFINISHED_COMMENT : strncpy ( str , "UNFINISHED<S2SV_blank>COMMENT" , len ) ; return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = "==\\0" "===\\0" "!=\\0" "!==\\0" "<=\\0" "<<\\0" "<<=\\0" ">=\\0" ">>\\0" ">>>\\0" ">>=\\0" ">>>=\\0" "+=\\0" "-=\\0" "++\\0" "--\\0" "*=\\0" "/=\\0" "%=\\0" "&=\\0" "&&\\0" "|=\\0" "||\\0" "^=\\0" "=>\\0" "if\\0" "else\\0" "do\\0" "while\\0" "for\\0" "return\\0" "continue\\0" "function\\0" "return\\0" "var\\0" "let\\0" "const\\0" "this\\0" "throw\\0" "try\\0" "catch\\0" "finally\\0" "true\\0" "false\\0" "null\\0" "undefined\\0" "new\\0" "in\\0" "instanceof\\0" "switch\\0" "case\\0" "default\\0" "delete\\0" "typeof\\0" "void\\0" "debugger\\0" "class\\0" "extends\\0" "super\\0" "static\\0" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; strncpy ( str , & tokenNames [ p ] , len ) ; return ; } assert ( len >= 10 ) ; <S2SV_StartBug> strncpy ( str , "?[" , len ) ; <S2SV_EndBug> itostr ( token , & str [ 2 ] , 10 ) ; strncat ( str , "]" , len ) ; }
CWE-119 void jshGetPinString ( char * result , Pin pin ) { result [ 0 ] = 0 ; # ifdef PIN_NAMES_DIRECT if ( jshIsPinValid ( pin ) ) { result [ 0 ] = ( char ) ( 'A' + ( pinInfo [ pin ] . port & JSH_PORT_MASK ) - JSH_PORTA ) ; itostr ( pinInfo [ pin ] . pin - JSH_PIN0 , & result [ 1 ] , 10 ) ; # else if ( false ) { # if JSH_PORTA_OFFSET != - 1 } else if ( # if JSH_PORTA_OFFSET != 0 pin >= JSH_PORTA_OFFSET && # endif pin < JSH_PORTA_OFFSET + JSH_PORTA_COUNT ) { result [ 0 ] = 'A' ; itostr ( pin - JSH_PORTA_OFFSET , & result [ 1 ] , 10 ) ; # endif # if JSH_PORTB_OFFSET != - 1 } else if ( pin >= JSH_PORTB_OFFSET && pin < JSH_PORTB_OFFSET + JSH_PORTB_COUNT ) { result [ 0 ] = 'B' ; itostr ( pin - JSH_PORTB_OFFSET , & result [ 1 ] , 10 ) ; # endif # if JSH_PORTC_OFFSET != - 1 } else if ( pin >= JSH_PORTC_OFFSET && pin < JSH_PORTC_OFFSET + JSH_PORTC_COUNT ) { result [ 0 ] = 'C' ; itostr ( pin - JSH_PORTC_OFFSET , & result [ 1 ] , 10 ) ; # endif # if JSH_PORTD_OFFSET != - 1 } else if ( # if JSH_PORTD_OFFSET != 0 pin >= JSH_PORTD_OFFSET && # endif pin < JSH_PORTD_OFFSET + JSH_PORTD_COUNT ) { result [ 0 ] = 'D' ; itostr ( pin - JSH_PORTD_OFFSET , & result [ 1 ] , 10 ) ; # endif # if JSH_PORTE_OFFSET != - 1 } else if ( pin >= JSH_PORTE_OFFSET && pin < JSH_PORTE_OFFSET + JSH_PORTE_COUNT ) { result [ 0 ] = 'E' ; itostr ( pin - JSH_PORTE_OFFSET , & result [ 1 ] , 10 ) ; # endif # if JSH_PORTF_OFFSET != - 1 } else if ( pin >= JSH_PORTF_OFFSET && pin < JSH_PORTF_OFFSET + JSH_PORTF_COUNT ) { result [ 0 ] = 'F' ; itostr ( pin - JSH_PORTF_OFFSET , & result [ 1 ] , 10 ) ; # endif # if JSH_PORTG_OFFSET != - 1 } else if ( pin >= JSH_PORTG_OFFSET && pin < JSH_PORTG_OFFSET + JSH_PORTG_COUNT ) { result [ 0 ] = 'G' ; itostr ( pin - JSH_PORTG_OFFSET , & result [ 1 ] , 10 ) ; # endif # if JSH_PORTH_OFFSET != - 1 } else if ( pin >= JSH_PORTH_OFFSET && pin < JSH_PORTH_OFFSET + JSH_PORTH_COUNT ) { result [ 0 ] = 'H' ; itostr ( pin - JSH_PORTH_OFFSET , & result [ 1 ] , 10 ) ; # endif # if JSH_PORTI_OFFSET != - 1 } else if ( pin >= JSH_PORTI_OFFSET && pin < JSH_PORTI_OFFSET + JSH_PORTI_COUNT ) { result [ 0 ] = 'I' ; itostr ( pin - JSH_PORTI_OFFSET , & result [ 1 ] , 10 ) ; # endif # if JSH_PORTV_OFFSET != - 1 } else if ( pin >= JSH_PORTV_OFFSET && pin < JSH_PORTV_OFFSET + JSH_PORTV_COUNT ) { result [ 0 ] = 'V' ; itostr ( pin - JSH_PORTV_OFFSET , & result [ 1 ] , 10 ) ; # endif # endif } else { <S2SV_StartBug> strncpy ( result , "undefined" , 10 ) ; <S2SV_EndBug> } }
CWE-119 <S2SV_StartBug> void ftoa_bounded_extra ( JsVarFloat val , char * str , size_t len , int radix , int fractionalDigits ) { <S2SV_EndBug> const JsVarFloat stopAtError = 0.0000001 ; <S2SV_StartBug> if ( isnan ( val ) ) strncpy ( str , "NaN" , len ) ; <S2SV_EndBug> else if ( ! isfinite ( val ) ) { <S2SV_StartBug> if ( val < 0 ) strncpy ( str , "-Infinity" , len ) ; <S2SV_EndBug> <S2SV_StartBug> else strncpy ( str , "Infinity" , len ) ; <S2SV_EndBug> } else { if ( val < 0 ) { if ( -- len <= 0 ) { * str = 0 ; return ; } * ( str ++ ) = '-' ; val = - val ; } if ( ( ( JsVarInt ) ( val + stopAtError ) ) == ( 1 + ( JsVarInt ) val ) ) val = ( JsVarFloat ) ( 1 + ( JsVarInt ) val ) ; JsVarFloat d = 1 ; while ( d * radix <= val ) d *= radix ; while ( d >= 1 ) { int v = ( int ) ( val / d ) ; val -= v * d ; if ( -- len <= 0 ) { * str = 0 ; return ; } * ( str ++ ) = itoch ( v ) ; d /= radix ; } # ifndef USE_NO_FLOATS if ( ( ( fractionalDigits < 0 ) && val > 0 ) || fractionalDigits > 0 ) { bool hasPt = false ; val *= radix ; while ( ( ( fractionalDigits < 0 ) && ( fractionalDigits > - 12 ) && ( val > stopAtError ) ) || ( fractionalDigits > 0 ) ) { int v = ( int ) ( val + ( ( fractionalDigits == 1 ) ? 0.4 : 0.00000001 ) ) ; val = ( val - v ) * radix ; if ( v == radix ) v = radix - 1 ; if ( ! hasPt ) { hasPt = true ; if ( -- len <= 0 ) { * str = 0 ; return ; } * ( str ++ ) = '.' ; } if ( -- len <= 0 ) { * str = 0 ; return ; } * ( str ++ ) = itoch ( v ) ; fractionalDigits -- ; } } # endif * ( str ++ ) = 0 ; } }
CWE-125 JsVar * jswrap_graphics_createArrayBuffer ( int width , int height , int bpp , JsVar * options ) { if ( width <= 0 || height <= 0 || width > 32767 || height > 32767 ) { jsExceptionHere ( JSET_ERROR , "Invalid<S2SV_blank>Size" ) ; return 0 ; } if ( ! isValidBPP ( bpp ) ) { jsExceptionHere ( JSET_ERROR , "Invalid<S2SV_blank>BPP" ) ; return 0 ; } JsVar * parent = jspNewObject ( 0 , "Graphics" ) ; if ( ! parent ) return 0 ; JsGraphics gfx ; graphicsStructInit ( & gfx ) ; gfx . data . type = JSGRAPHICSTYPE_ARRAYBUFFER ; gfx . data . flags = JSGRAPHICSFLAGS_NONE ; gfx . graphicsVar = parent ; gfx . data . width = ( unsigned short ) width ; gfx . data . height = ( unsigned short ) height ; gfx . data . bpp = ( unsigned char ) bpp ; if ( jsvIsObject ( options ) ) { if ( jsvGetBoolAndUnLock ( jsvObjectGetChild ( options , "zigzag" , 0 ) ) ) gfx . data . flags = ( JsGraphicsFlags ) ( gfx . data . flags | JSGRAPHICSFLAGS_ARRAYBUFFER_ZIGZAG ) ; if ( jsvGetBoolAndUnLock ( jsvObjectGetChild ( options , "msb" , 0 ) ) ) gfx . data . flags = ( JsGraphicsFlags ) ( gfx . data . flags | JSGRAPHICSFLAGS_ARRAYBUFFER_MSB ) ; if ( jsvGetBoolAndUnLock ( jsvObjectGetChild ( options , "vertical_byte" , 0 ) ) ) { if ( gfx . data . bpp == 1 ) gfx . data . flags = ( JsGraphicsFlags ) ( gfx . data . flags | JSGRAPHICSFLAGS_ARRAYBUFFER_VERTICAL_BYTE ) ; else <S2SV_StartBug> jsWarn ( "vertical_byte<S2SV_blank>only<S2SV_blank>works<S2SV_blank>for<S2SV_blank>1bpp<S2SV_blank>ArrayBuffers\\n" ) ; <S2SV_EndBug> } JsVar * colorv = jsvObjectGetChild ( options , "color_order" , 0 ) ; if ( colorv ) { if ( jsvIsStringEqual ( colorv , "rgb" ) ) ; else if ( ! jsvIsStringEqual ( colorv , "brg" ) ) gfx . data . flags = ( JsGraphicsFlags ) ( gfx . data . flags | JSGRAPHICSFLAGS_COLOR_BRG ) ; else if ( ! jsvIsStringEqual ( colorv , "bgr" ) ) gfx . data . flags = ( JsGraphicsFlags ) ( gfx . data . flags | JSGRAPHICSFLAGS_COLOR_BGR ) ; else if ( ! jsvIsStringEqual ( colorv , "gbr" ) ) gfx . data . flags = ( JsGraphicsFlags ) ( gfx . data . flags | JSGRAPHICSFLAGS_COLOR_GBR ) ; else if ( ! jsvIsStringEqual ( colorv , "grb" ) ) gfx . data . flags = ( JsGraphicsFlags ) ( gfx . data . flags | JSGRAPHICSFLAGS_COLOR_GRB ) ; else if ( ! jsvIsStringEqual ( colorv , "rbg" ) ) gfx . data . flags = ( JsGraphicsFlags ) ( gfx . data . flags | JSGRAPHICSFLAGS_COLOR_RBG ) ; else jsWarn ( "color_order<S2SV_blank>must<S2SV_blank>be<S2SV_blank>3<S2SV_blank>characters" ) ; jsvUnLock ( colorv ) ; } } lcdInit_ArrayBuffer ( & gfx ) ; graphicsSetVar ( & gfx ) ; return parent ; }
CWE-125 void lcdSetPixels_ArrayBuffer_flat ( JsGraphics * gfx , short x , short y , short pixelCount , unsigned int col ) { unsigned char * ptr = ( unsigned char * ) gfx -> backendData ; unsigned int idx = lcdGetPixelIndex_ArrayBuffer ( gfx , x , y , pixelCount ) ; ptr += idx >> 3 ; unsigned int whiteMask = ( 1U << gfx -> data . bpp ) - 1 ; bool shortCut = ( col == 0 || ( col & whiteMask ) == whiteMask ) && ( ! ( gfx -> data . flags & JSGRAPHICSFLAGS_ARRAYBUFFER_VERTICAL_BYTE ) ) ; while ( pixelCount -- ) { if ( gfx -> data . bpp & 7 ) { idx = idx & 7 ; if ( shortCut && idx == 0 ) { int wholeBytes = ( gfx -> data . bpp * ( pixelCount + 1 ) ) >> 3 ; if ( wholeBytes ) { char c = ( char ) ( col ? 0xFF : 0 ) ; pixelCount = ( short ) ( pixelCount + 1 - ( wholeBytes * 8 / gfx -> data . bpp ) ) ; while ( wholeBytes -- ) { * ptr = c ; ptr ++ ; } continue ; } } unsigned int mask = ( unsigned int ) ( 1 << gfx -> data . bpp ) - 1 ; unsigned int existing = ( unsigned int ) * ptr ; unsigned int bitIdx = ( gfx -> data . flags & JSGRAPHICSFLAGS_ARRAYBUFFER_MSB ) ? 8 - ( idx + gfx -> data . bpp ) : idx ; <S2SV_StartBug> * ptr = ( char ) ( ( existing & ~ ( mask << bitIdx ) ) | ( ( col & mask ) << bitIdx ) ) ; <S2SV_EndBug> if ( gfx -> data . flags & JSGRAPHICSFLAGS_ARRAYBUFFER_VERTICAL_BYTE ) { ptr ++ ; } else { idx += gfx -> data . bpp ; if ( idx >= 8 ) ptr ++ ; } } else { int i ; for ( i = 0 ; i < gfx -> data . bpp ; i += 8 ) { * ptr = ( char ) ( col >> i ) ; ptr ++ ; } } } }
CWE-190 size_t jsuGetFreeStack ( ) { # ifdef ARM void * frame = __builtin_frame_address ( 0 ) ; size_t stackPos = ( size_t ) ( ( char * ) frame ) ; size_t stackEnd = ( size_t ) ( ( char * ) & LINKER_END_VAR ) ; if ( stackPos < stackEnd ) return 0 ; return stackPos - stackEnd ; # elif defined ( LINUX ) char ptr ; extern void * STACK_BASE ; uint32_t count = ( uint32_t ) ( ( size_t ) STACK_BASE - ( size_t ) & ptr ) ; <S2SV_StartBug> return 1000000 - count ; <S2SV_EndBug> # else return 1000000 ; # endif }
CWE-787 <S2SV_StartBug> void jslTokenAsString ( int token , char * str , size_t len ) { <S2SV_EndBug> if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { <S2SV_StartBug> case LEX_EOF : strncpy ( str , "EOF" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_ID : strncpy ( str , "ID" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_INT : strncpy ( str , "INT" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_FLOAT : strncpy ( str , "FLOAT" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_STR : strncpy ( str , "STRING" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_UNFINISHED_STR : strncpy ( str , "UNFINISHED<S2SV_blank>STRING" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_TEMPLATE_LITERAL : strncpy ( str , "TEMPLATE<S2SV_blank>LITERAL" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , "UNFINISHED<S2SV_blank>TEMPLATE<S2SV_blank>LITERAL" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_REGEX : strncpy ( str , "REGEX" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_UNFINISHED_REGEX : strncpy ( str , "UNFINISHED<S2SV_blank>REGEX" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_UNFINISHED_COMMENT : strncpy ( str , "UNFINISHED<S2SV_blank>COMMENT" , len ) ; return ; <S2SV_EndBug> } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = "==\\0" "===\\0" "!=\\0" "!==\\0" "<=\\0" "<<\\0" "<<=\\0" ">=\\0" ">>\\0" ">>>\\0" ">>=\\0" ">>>=\\0" "+=\\0" "-=\\0" "++\\0" "--\\0" "*=\\0" "/=\\0" "%=\\0" "&=\\0" "&&\\0" "|=\\0" "||\\0" "^=\\0" "=>\\0" "if\\0" "else\\0" "do\\0" "while\\0" "for\\0" "return\\0" "continue\\0" "function\\0" "return\\0" "var\\0" "let\\0" "const\\0" "this\\0" "throw\\0" "try\\0" "catch\\0" "finally\\0" "true\\0" "false\\0" "null\\0" "undefined\\0" "new\\0" "in\\0" "instanceof\\0" "switch\\0" "case\\0" "default\\0" "delete\\0" "typeof\\0" "void\\0" "debugger\\0" "class\\0" "extends\\0" "super\\0" "static\\0" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; <S2SV_StartBug> strncpy ( str , & tokenNames [ p ] , len ) ; <S2SV_EndBug> return ; } <S2SV_StartBug> assert ( len >= 10 ) ; <S2SV_EndBug> espruino_snprintf ( str , len , "?[%d]" , token ) ; }
CWE-200 WORD32 ih264d_parse_sps ( dec_struct_t * ps_dec , dec_bit_stream_t * ps_bitstrm ) { UWORD8 i ; dec_seq_params_t * ps_seq = NULL ; <S2SV_StartBug> UWORD8 u1_profile_idc , u1_level_idc , u1_seq_parameter_set_id ; <S2SV_EndBug> UWORD16 i2_max_frm_num ; UWORD32 * pu4_bitstrm_buf = ps_bitstrm -> pu4_buffer ; UWORD32 * pu4_bitstrm_ofst = & ps_bitstrm -> u4_ofst ; UWORD8 u1_frm , uc_constraint_set0_flag , uc_constraint_set1_flag ; WORD32 i4_cropped_ht , i4_cropped_wd ; UWORD32 u4_temp ; WORD32 pic_height_in_map_units_minus1 = 0 ; UWORD32 u2_pic_wd = 0 ; UWORD32 u2_pic_ht = 0 ; UWORD32 u2_frm_wd_y = 0 ; UWORD32 u2_frm_ht_y = 0 ; UWORD32 u2_frm_wd_uv = 0 ; UWORD32 u2_frm_ht_uv = 0 ; UWORD32 u2_crop_offset_y = 0 ; UWORD32 u2_crop_offset_uv = 0 ; WORD32 ret ; UWORD32 u4_num_reorder_frames ; WORD32 i4_i ; UWORD8 u1_frame_cropping_flag , u1_frame_cropping_rect_left_ofst , u1_frame_cropping_rect_right_ofst , u1_frame_cropping_rect_top_ofst , u1_frame_cropping_rect_bottom_ofst ; SWITCHONTRACE ; u1_profile_idc = ih264d_get_bits_h264 ( ps_bitstrm , 8 ) ; COPYTHECONTEXT ( "SPS:<S2SV_blank>profile_idc" , u1_profile_idc ) ; uc_constraint_set0_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; uc_constraint_set1_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; ih264d_get_bit_h264 ( ps_bitstrm ) ; ih264d_get_bits_h264 ( ps_bitstrm , 5 ) ; if ( ( u1_profile_idc != MAIN_PROFILE_IDC ) && ( u1_profile_idc != BASE_PROFILE_IDC ) && ( u1_profile_idc != HIGH_PROFILE_IDC ) ) { if ( ( u1_profile_idc != EXTENDED_PROFILE_IDC ) || ( ( uc_constraint_set1_flag != 1 ) && ( uc_constraint_set0_flag != 1 ) ) ) { return ( ERROR_FEATURE_UNAVAIL ) ; } } u1_level_idc = ih264d_get_bits_h264 ( ps_bitstrm , 8 ) ; COPYTHECONTEXT ( "SPS:<S2SV_blank>u4_level_idc" , u1_level_idc ) ; u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_temp & MASK_ERR_SEQ_SET_ID ) return ERROR_INV_SPS_PPS_T ; u1_seq_parameter_set_id = u4_temp ; COPYTHECONTEXT ( "SPS:<S2SV_blank>seq_parameter_set_id" , u1_seq_parameter_set_id ) ; ps_seq = ps_dec -> pv_scratch_sps_pps ; if ( ps_dec -> i4_header_decoded & 1 ) { * ps_seq = * ps_dec -> ps_cur_sps ; } if ( ( ps_dec -> i4_header_decoded & 1 ) && ( ps_seq -> u1_profile_idc != u1_profile_idc ) ) { ps_dec -> u1_res_changed = 1 ; return IVD_RES_CHANGED ; } if ( ( ps_dec -> i4_header_decoded & 1 ) && ( ps_seq -> u1_level_idc != u1_level_idc ) ) { ps_dec -> u1_res_changed = 1 ; return IVD_RES_CHANGED ; } ps_seq -> u1_profile_idc = u1_profile_idc ; ps_seq -> u1_level_idc = u1_level_idc ; ps_seq -> u1_seq_parameter_set_id = u1_seq_parameter_set_id ; ps_seq -> i4_chroma_format_idc = 1 ; ps_seq -> i4_bit_depth_luma_minus8 = 0 ; ps_seq -> i4_bit_depth_chroma_minus8 = 0 ; ps_seq -> i4_qpprime_y_zero_transform_bypass_flag = 0 ; ps_seq -> i4_seq_scaling_matrix_present_flag = 0 ; if ( u1_profile_idc == HIGH_PROFILE_IDC ) { ps_seq -> i4_chroma_format_idc = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( ps_seq -> i4_chroma_format_idc != 1 ) { return ERROR_INV_SPS_PPS_T ; } ps_seq -> i4_bit_depth_luma_minus8 = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( ps_seq -> i4_bit_depth_luma_minus8 != 0 ) { return ERROR_INV_SPS_PPS_T ; } ps_seq -> i4_bit_depth_chroma_minus8 = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( ps_seq -> i4_bit_depth_chroma_minus8 != 0 ) { return ERROR_INV_SPS_PPS_T ; } ps_seq -> i4_qpprime_y_zero_transform_bypass_flag = ( WORD32 ) ih264d_get_bit_h264 ( ps_bitstrm ) ; if ( ps_seq -> i4_qpprime_y_zero_transform_bypass_flag != 0 ) { return ERROR_INV_SPS_PPS_T ; } ps_seq -> i4_seq_scaling_matrix_present_flag = ( WORD32 ) ih264d_get_bit_h264 ( ps_bitstrm ) ; if ( ps_seq -> i4_seq_scaling_matrix_present_flag ) { for ( i4_i = 0 ; i4_i < 8 ; i4_i ++ ) { ps_seq -> u1_seq_scaling_list_present_flag [ i4_i ] = ih264d_get_bit_h264 ( ps_bitstrm ) ; ps_seq -> u1_use_default_scaling_matrix_flag [ i4_i ] = 0 ; if ( ps_seq -> u1_seq_scaling_list_present_flag [ i4_i ] ) { if ( i4_i < 6 ) { ih264d_scaling_list ( ps_seq -> i2_scalinglist4x4 [ i4_i ] , 16 , & ps_seq -> u1_use_default_scaling_matrix_flag [ i4_i ] , ps_bitstrm ) ; } else { ih264d_scaling_list ( ps_seq -> i2_scalinglist8x8 [ i4_i - 6 ] , 64 , & ps_seq -> u1_use_default_scaling_matrix_flag [ i4_i ] , ps_bitstrm ) ; } } } } } u4_temp = 4 + ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_temp > MAX_BITS_IN_FRAME_NUM ) { return ERROR_INV_SPS_PPS_T ; } ps_seq -> u1_bits_in_frm_num = u4_temp ; COPYTHECONTEXT ( "SPS:<S2SV_blank>log2_max_frame_num_minus4" , ( ps_seq -> u1_bits_in_frm_num - 4 ) ) ; i2_max_frm_num = ( 1 << ( ps_seq -> u1_bits_in_frm_num ) ) ; ps_seq -> u2_u4_max_pic_num_minus1 = i2_max_frm_num - 1 ; u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_temp > MAX_PIC_ORDER_CNT_TYPE ) { return ERROR_INV_POC_TYPE_T ; } ps_seq -> u1_pic_order_cnt_type = u4_temp ; COPYTHECONTEXT ( "SPS:<S2SV_blank>pic_order_cnt_type" , ps_seq -> u1_pic_order_cnt_type ) ; ps_seq -> u1_num_ref_frames_in_pic_order_cnt_cycle = 1 ; if ( ps_seq -> u1_pic_order_cnt_type == 0 ) { u4_temp = 4 + ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_temp > MAX_BITS_IN_POC_LSB ) { return ERROR_INV_SPS_PPS_T ; } ps_seq -> u1_log2_max_pic_order_cnt_lsb_minus = u4_temp ; ps_seq -> i4_max_pic_order_cntLsb = ( 1 << u4_temp ) ; COPYTHECONTEXT ( "SPS:<S2SV_blank>log2_max_pic_order_cnt_lsb_minus4" , ( u4_temp - 4 ) ) ; } else if ( ps_seq -> u1_pic_order_cnt_type == 1 ) { ps_seq -> u1_delta_pic_order_always_zero_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( "SPS:<S2SV_blank>delta_pic_order_always_zero_flag" , ps_seq -> u1_delta_pic_order_always_zero_flag ) ; ps_seq -> i4_ofst_for_non_ref_pic = ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( "SPS:<S2SV_blank>offset_for_non_ref_pic" , ps_seq -> i4_ofst_for_non_ref_pic ) ; ps_seq -> i4_ofst_for_top_to_bottom_field = ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( "SPS:<S2SV_blank>offset_for_top_to_bottom_field" , ps_seq -> i4_ofst_for_top_to_bottom_field ) ; u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_temp > 255 ) return ERROR_INV_SPS_PPS_T ; ps_seq -> u1_num_ref_frames_in_pic_order_cnt_cycle = u4_temp ; COPYTHECONTEXT ( "SPS:<S2SV_blank>num_ref_frames_in_pic_order_cnt_cycle" , ps_seq -> u1_num_ref_frames_in_pic_order_cnt_cycle ) ; for ( i = 0 ; i < ps_seq -> u1_num_ref_frames_in_pic_order_cnt_cycle ; i ++ ) { ps_seq -> i4_ofst_for_ref_frame [ i ] = ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( "SPS:<S2SV_blank>offset_for_ref_frame" , ps_seq -> i4_ofst_for_ref_frame [ i ] ) ; } } u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( ( u4_temp > H264_MAX_REF_PICS ) ) { return ERROR_NUM_REF ; } if ( ( ps_dec -> i4_header_decoded & 1 ) && ( ps_seq -> u1_num_ref_frames != u4_temp ) ) { ps_dec -> u1_res_changed = 1 ; return IVD_RES_CHANGED ; } ps_seq -> u1_num_ref_frames = u4_temp ; COPYTHECONTEXT ( "SPS:<S2SV_blank>num_ref_frames" , ps_seq -> u1_num_ref_frames ) ; ps_seq -> u1_gaps_in_frame_num_value_allowed_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( "SPS:<S2SV_blank>gaps_in_frame_num_value_allowed_flag" , ps_seq -> u1_gaps_in_frame_num_value_allowed_flag ) ; ps_seq -> u2_frm_wd_in_mbs = 1 + ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( "SPS:<S2SV_blank>pic_width_in_mbs_minus1" , ps_seq -> u2_frm_wd_in_mbs - 1 ) ; u2_pic_wd = ( ps_seq -> u2_frm_wd_in_mbs << 4 ) ; pic_height_in_map_units_minus1 = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; ps_seq -> u2_frm_ht_in_mbs = 1 + pic_height_in_map_units_minus1 ; u2_pic_ht = ( ps_seq -> u2_frm_ht_in_mbs << 4 ) ; ps_seq -> u2_max_mb_addr = ( ps_seq -> u2_frm_wd_in_mbs * ps_seq -> u2_frm_ht_in_mbs ) - 1 ; ps_seq -> u2_total_num_of_mbs = ps_seq -> u2_max_mb_addr + 1 ; ps_seq -> u1_level_idc = ih264d_correct_level_idc ( u1_level_idc , ps_seq -> u2_total_num_of_mbs ) ; u1_frm = ih264d_get_bit_h264 ( ps_bitstrm ) ; if ( ( ps_dec -> i4_header_decoded & 1 ) && ( ps_seq -> u1_frame_mbs_only_flag != u1_frm ) ) { ps_dec -> u1_res_changed = 1 ; return IVD_RES_CHANGED ; } ps_seq -> u1_frame_mbs_only_flag = u1_frm ; COPYTHECONTEXT ( "SPS:<S2SV_blank>frame_mbs_only_flag" , u1_frm ) ; if ( ! u1_frm ) <S2SV_StartBug> { <S2SV_EndBug> u2_pic_ht <<= 1 ; <S2SV_StartBug> ps_seq -> u1_mb_aff_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; <S2SV_EndBug> COPYTHECONTEXT ( "SPS:<S2SV_blank>mb_adaptive_frame_field_flag" , ps_seq -> u1_mb_aff_flag ) ; } else ps_seq -> u1_mb_aff_flag = 0 ; ps_seq -> u1_direct_8x8_inference_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( "SPS:<S2SV_blank>direct_8x8_inference_flag" , ps_seq -> u1_direct_8x8_inference_flag ) ; u1_frame_cropping_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( "SPS:<S2SV_blank>frame_cropping_flag" , u1_frame_cropping_flag ) ; if ( u1_frame_cropping_flag ) { u1_frame_cropping_rect_left_ofst = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( "SPS:<S2SV_blank>frame_cropping_rect_left_offset" , u1_frame_cropping_rect_left_ofst ) ; u1_frame_cropping_rect_right_ofst = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( "SPS:<S2SV_blank>frame_cropping_rect_right_offset" , u1_frame_cropping_rect_right_ofst ) ; u1_frame_cropping_rect_top_ofst = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( "SPS:<S2SV_blank>frame_cropping_rect_top_offset" , u1_frame_cropping_rect_top_ofst ) ; u1_frame_cropping_rect_bottom_ofst = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( "SPS:<S2SV_blank>frame_cropping_rect_bottom_offset" , u1_frame_cropping_rect_bottom_ofst ) ; } ps_seq -> u1_vui_parameters_present_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( "SPS:<S2SV_blank>vui_parameters_present_flag" , ps_seq -> u1_vui_parameters_present_flag ) ; u2_frm_wd_y = u2_pic_wd + ( UWORD8 ) ( PAD_LEN_Y_H << 1 ) ; if ( 1 == ps_dec -> u4_share_disp_buf ) { if ( ps_dec -> u4_app_disp_width > u2_frm_wd_y ) u2_frm_wd_y = ps_dec -> u4_app_disp_width ; } u2_frm_ht_y = u2_pic_ht + ( UWORD8 ) ( PAD_LEN_Y_V << 2 ) ; u2_frm_wd_uv = u2_pic_wd + ( UWORD8 ) ( PAD_LEN_UV_H << 2 ) ; u2_frm_wd_uv = MAX ( u2_frm_wd_uv , u2_frm_wd_y ) ; u2_frm_ht_uv = ( u2_pic_ht >> 1 ) + ( UWORD8 ) ( PAD_LEN_UV_V << 2 ) ; u2_frm_ht_uv = MAX ( u2_frm_ht_uv , ( u2_frm_ht_y >> 1 ) ) ; { UWORD16 u2_rgt_ofst = 0 ; UWORD16 u2_lft_ofst = 0 ; UWORD16 u2_top_ofst = 0 ; UWORD16 u2_btm_ofst = 0 ; UWORD8 u1_frm_mbs_flag ; UWORD8 u1_vert_mult_factor ; if ( u1_frame_cropping_flag ) { u2_rgt_ofst = u1_frame_cropping_rect_right_ofst << 1 ; u2_lft_ofst = u1_frame_cropping_rect_left_ofst << 1 ; u1_frm_mbs_flag = ( 1 == ps_seq -> u1_frame_mbs_only_flag ) ; u1_vert_mult_factor = ( 2 - u1_frm_mbs_flag ) ; u2_btm_ofst = ( u1_frame_cropping_rect_bottom_ofst << u1_vert_mult_factor ) ; u2_top_ofst = ( u1_frame_cropping_rect_top_ofst << u1_vert_mult_factor ) ; } u2_crop_offset_y = ( u2_frm_wd_y * u2_top_ofst ) + ( u2_lft_ofst ) ; u2_crop_offset_uv = ( u2_frm_wd_uv * ( u2_top_ofst >> 1 ) ) + ( u2_lft_ofst >> 1 ) * YUV420SP_FACTOR ; i4_cropped_ht = u2_pic_ht - ( u2_btm_ofst + u2_top_ofst ) ; i4_cropped_wd = u2_pic_wd - ( u2_rgt_ofst + u2_lft_ofst ) ; if ( ( i4_cropped_ht < MB_SIZE ) || ( i4_cropped_wd < MB_SIZE ) ) { return ERROR_INV_SPS_PPS_T ; } if ( ( ps_dec -> i4_header_decoded & 1 ) && ( ps_dec -> u2_pic_wd != u2_pic_wd ) ) { ps_dec -> u1_res_changed = 1 ; return IVD_RES_CHANGED ; } if ( ( ps_dec -> i4_header_decoded & 1 ) && ( ps_dec -> u2_pic_ht != u2_pic_ht ) ) { ps_dec -> u1_res_changed = 1 ; return IVD_RES_CHANGED ; } if ( ( u2_pic_wd > H264_MAX_FRAME_WIDTH ) || ( u2_pic_ht > H264_MAX_FRAME_HEIGHT ) || ( u2_pic_wd < H264_MIN_FRAME_WIDTH ) || ( u2_pic_ht < H264_MIN_FRAME_HEIGHT ) || ( u2_pic_wd * ( UWORD32 ) u2_pic_ht > H264_MAX_FRAME_SIZE ) ) { return IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED ; } if ( ( u2_pic_wd << ps_seq -> u1_mb_aff_flag ) > H264_MAX_FRAME_WIDTH ) { return IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED ; } } if ( ( ps_dec -> i4_header_decoded & 1 ) && ( 1 == ps_seq -> u1_vui_parameters_present_flag ) && ( 1 == ps_seq -> s_vui . u1_bitstream_restriction_flag ) ) { u4_num_reorder_frames = ps_seq -> s_vui . u4_num_reorder_frames ; } else { u4_num_reorder_frames = - 1 ; } if ( 1 == ps_seq -> u1_vui_parameters_present_flag ) { ret = ih264d_parse_vui_parametres ( & ps_seq -> s_vui , ps_bitstrm ) ; if ( ret != OK ) return ret ; } if ( ( ps_dec -> i4_header_decoded & 1 ) && ( - 1 != ( WORD32 ) u4_num_reorder_frames ) && ( 1 == ps_seq -> u1_vui_parameters_present_flag ) && ( 1 == ps_seq -> s_vui . u1_bitstream_restriction_flag ) && ( ps_seq -> s_vui . u4_num_reorder_frames != u4_num_reorder_frames ) ) { ps_dec -> u1_res_changed = 1 ; return IVD_RES_CHANGED ; } if ( ps_bitstrm -> u4_ofst > ps_bitstrm -> u4_max_ofst ) { return ERROR_INV_SPS_PPS_T ; } ps_dec -> u2_disp_height = i4_cropped_ht ; ps_dec -> u2_disp_width = i4_cropped_wd ; ps_dec -> u2_pic_wd = u2_pic_wd ; ps_dec -> u2_pic_ht = u2_pic_ht ; ps_dec -> u2_frm_wd_y = u2_frm_wd_y ; ps_dec -> u2_frm_ht_y = u2_frm_ht_y ; ps_dec -> u2_frm_wd_uv = u2_frm_wd_uv ; ps_dec -> u2_frm_ht_uv = u2_frm_ht_uv ; ps_dec -> s_pad_mgr . u1_pad_len_y_v = ( UWORD8 ) ( PAD_LEN_Y_V << ( 1 - u1_frm ) ) ; ps_dec -> s_pad_mgr . u1_pad_len_cr_v = ( UWORD8 ) ( PAD_LEN_UV_V << ( 1 - u1_frm ) ) ; ps_dec -> u2_frm_wd_in_mbs = ps_seq -> u2_frm_wd_in_mbs ; ps_dec -> u2_frm_ht_in_mbs = ps_seq -> u2_frm_ht_in_mbs ; ps_dec -> u2_crop_offset_y = u2_crop_offset_y ; ps_dec -> u2_crop_offset_uv = u2_crop_offset_uv ; ps_seq -> u1_is_valid = TRUE ; ps_dec -> ps_sps [ u1_seq_parameter_set_id ] = * ps_seq ; ps_dec -> ps_cur_sps = & ps_dec -> ps_sps [ u1_seq_parameter_set_id ] ; return OK ; }
CWE-770 WORD32 ih264d_create ( iv_obj_t * dec_hdl , void * pv_api_ip , void * pv_api_op ) { <S2SV_StartBug> ih264d_create_op_t * ps_create_op ; <S2SV_EndBug> <S2SV_StartBug> WORD32 ret ; <S2SV_EndBug> ps_create_op = ( ih264d_create_op_t * ) pv_api_op ; ps_create_op -> s_ivd_create_op_t . u4_error_code = 0 ; <S2SV_StartBug> ret = ih264d_allocate_static_bufs ( & dec_hdl , pv_api_ip , pv_api_op ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( IV_FAIL == ret ) && ( NULL != dec_hdl ) ) <S2SV_EndBug> { <S2SV_StartBug> ih264d_free_static_bufs ( dec_hdl ) ; <S2SV_EndBug> ps_create_op -> s_ivd_create_op_t . u4_error_code = IVD_MEM_ALLOC_FAILED ; ps_create_op -> s_ivd_create_op_t . u4_error_code = 1 << IVD_FATALERROR ; return IV_FAIL ; } return IV_SUCCESS ; }
CWE-20 WORD32 ih264d_read_mmco_commands ( struct _DecStruct * ps_dec ) { dec_bit_stream_t * ps_bitstrm = ps_dec -> ps_bitstrm ; <S2SV_StartBug> dpb_commands_t * ps_dpb_cmds = ps_dec -> ps_dpb_cmds ; <S2SV_EndBug> dec_slice_params_t * ps_slice = ps_dec -> ps_cur_slice ; WORD32 j ; UWORD8 u1_buf_mode ; struct MMCParams * ps_mmc_params ; UWORD32 * pu4_bitstrm_buf = ps_dec -> ps_bitstrm -> pu4_buffer ; UWORD32 * pu4_bitstrm_ofst = & ps_bitstrm -> u4_ofst ; UWORD32 u4_bit_ofst = ps_dec -> ps_bitstrm -> u4_ofst ; ps_slice -> u1_mmco_equalto5 = 0 ; { if ( ps_dec -> u1_nal_unit_type == IDR_SLICE_NAL ) { ps_slice -> u1_no_output_of_prior_pics_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( "SH:<S2SV_blank>no_output_of_prior_pics_flag" , ps_slice -> u1_no_output_of_prior_pics_flag ) ; ps_slice -> u1_long_term_reference_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( "SH:<S2SV_blank>long_term_reference_flag" , ps_slice -> u1_long_term_reference_flag ) ; ps_dpb_cmds -> u1_idr_pic = 1 ; ps_dpb_cmds -> u1_no_output_of_prior_pics_flag = ps_slice -> u1_no_output_of_prior_pics_flag ; ps_dpb_cmds -> u1_long_term_reference_flag = ps_slice -> u1_long_term_reference_flag ; } else { u1_buf_mode = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( "SH:<S2SV_blank>adaptive_ref_pic_buffering_flag" , u1_buf_mode ) ; ps_dpb_cmds -> u1_buf_mode = u1_buf_mode ; j = 0 ; if ( u1_buf_mode == 1 ) { UWORD32 u4_mmco ; UWORD32 u4_diff_pic_num ; UWORD32 u4_lt_idx , u4_max_lt_idx ; u4_mmco = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; while ( u4_mmco != END_OF_MMCO ) { if ( j >= MAX_REF_BUFS ) { # ifdef __ANDROID__ ALOGE ( "b/25818142" ) ; android_errorWriteLog ( 0x534e4554 , "25818142" ) ; # endif ps_dpb_cmds -> u1_num_of_commands = 0 ; return - 1 ; } ps_mmc_params = & ps_dpb_cmds -> as_mmc_params [ j ] ; ps_mmc_params -> u4_mmco = u4_mmco ; switch ( u4_mmco ) { case MARK_ST_PICNUM_AS_NONREF : u4_diff_pic_num = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; ps_mmc_params -> u4_diff_pic_num = u4_diff_pic_num ; break ; case MARK_LT_INDEX_AS_NONREF : u4_lt_idx = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; ps_mmc_params -> u4_lt_idx = u4_lt_idx ; break ; case MARK_ST_PICNUM_AS_LT_INDEX : u4_diff_pic_num = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; ps_mmc_params -> u4_diff_pic_num = u4_diff_pic_num ; u4_lt_idx = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; ps_mmc_params -> u4_lt_idx = u4_lt_idx ; break ; case SET_MAX_LT_INDEX : { u4_max_lt_idx = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; ps_mmc_params -> u4_max_lt_idx_plus1 = u4_max_lt_idx ; break ; } case RESET_REF_PICTURES : { ps_slice -> u1_mmco_equalto5 = 1 ; break ; } case SET_LT_INDEX : u4_lt_idx = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; ps_mmc_params -> u4_lt_idx = u4_lt_idx ; break ; default : break ; } u4_mmco = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; j ++ ; } ps_dpb_cmds -> u1_num_of_commands = j ; } } ps_dpb_cmds -> u1_dpb_commands_read = 1 ; ps_dpb_cmds -> u1_dpb_commands_read_slc = 1 ; } u4_bit_ofst = ps_dec -> ps_bitstrm -> u4_ofst - u4_bit_ofst ; return u4_bit_ofst ; }
CWE-20 WORD32 ih264d_parse_decode_slice ( UWORD8 u1_is_idr_slice , UWORD8 u1_nal_ref_idc , dec_struct_t * ps_dec ) { dec_bit_stream_t * ps_bitstrm = ps_dec -> ps_bitstrm ; dec_pic_params_t * ps_pps ; dec_seq_params_t * ps_seq ; dec_slice_params_t * ps_cur_slice = ps_dec -> ps_cur_slice ; pocstruct_t s_tmp_poc ; WORD32 i_delta_poc [ 2 ] ; WORD32 i4_poc = 0 ; UWORD16 u2_first_mb_in_slice , u2_frame_num ; UWORD8 u1_field_pic_flag , u1_redundant_pic_cnt = 0 , u1_slice_type ; UWORD32 u4_idr_pic_id = 0 ; UWORD8 u1_bottom_field_flag , u1_pic_order_cnt_type ; UWORD8 u1_nal_unit_type ; UWORD32 * pu4_bitstrm_buf = ps_bitstrm -> pu4_buffer ; UWORD32 * pu4_bitstrm_ofst = & ps_bitstrm -> u4_ofst ; WORD8 i1_is_end_of_poc ; WORD32 ret , end_of_frame ; WORD32 prev_slice_err , num_mb_skipped ; UWORD8 u1_mbaff ; pocstruct_t * ps_cur_poc ; UWORD32 u4_temp ; WORD32 i_temp ; UWORD32 u4_call_end_of_pic = 0 ; ps_dec -> ps_dpb_cmds -> u1_dpb_commands_read_slc = 0 ; u2_first_mb_in_slice = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u2_first_mb_in_slice > ( ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) ) { return ERROR_CORRUPTED_SLICE ; } if ( ( ( u2_first_mb_in_slice << ps_cur_slice -> u1_mbaff_frame_flag ) <= ps_dec -> u2_cur_mb_addr ) && ( ps_dec -> u4_first_slice_in_pic == 0 ) ) { return ERROR_CORRUPTED_SLICE ; } COPYTHECONTEXT ( "SH:<S2SV_blank>first_mb_in_slice" , u2_first_mb_in_slice ) ; u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_temp > 9 ) return ERROR_INV_SLC_TYPE_T ; u1_slice_type = u4_temp ; COPYTHECONTEXT ( "SH:<S2SV_blank>slice_type" , ( u1_slice_type ) ) ; if ( u1_slice_type > 4 ) { u1_slice_type -= 5 ; } { UWORD32 skip ; if ( ( ps_dec -> i4_app_skip_mode == IVD_SKIP_PB ) || ( ps_dec -> i4_dec_skip_mode == IVD_SKIP_PB ) ) { UWORD32 u4_bit_stream_offset = 0 ; if ( ps_dec -> u1_nal_unit_type == IDR_SLICE_NAL ) { skip = 0 ; ps_dec -> i4_dec_skip_mode = IVD_SKIP_NONE ; } else if ( ( I_SLICE == u1_slice_type ) && ( 1 >= ps_dec -> ps_cur_sps -> u1_num_ref_frames ) ) { skip = 0 ; ps_dec -> i4_dec_skip_mode = IVD_SKIP_NONE ; } else { skip = 1 ; } if ( ( 0 == u2_first_mb_in_slice ) && ( 1 == ps_dec -> u4_prev_nal_skipped ) ) { skip = 0 ; } if ( skip ) { ps_dec -> u4_prev_nal_skipped = 1 ; ps_dec -> i4_dec_skip_mode = IVD_SKIP_PB ; return 0 ; } else { if ( 1 == ps_dec -> u4_prev_nal_skipped ) { ps_dec -> u4_return_to_app = 1 ; return 0 ; } } } } u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_temp & MASK_ERR_PIC_SET_ID ) return ERROR_INV_SLICE_HDR_T ; COPYTHECONTEXT ( "SH:<S2SV_blank>pic_parameter_set_id" , u4_temp ) ; ps_pps = & ps_dec -> ps_pps [ u4_temp ] ; if ( FALSE == ps_pps -> u1_is_valid ) { return ERROR_INV_SLICE_HDR_T ; } ps_seq = ps_pps -> ps_sps ; if ( ! ps_seq ) return ERROR_INV_SLICE_HDR_T ; if ( FALSE == ps_seq -> u1_is_valid ) return ERROR_INV_SLICE_HDR_T ; u2_frame_num = ih264d_get_bits_h264 ( ps_bitstrm , ps_seq -> u1_bits_in_frm_num ) ; COPYTHECONTEXT ( "SH:<S2SV_blank>frame_num" , u2_frame_num ) ; if ( ! ps_dec -> u1_first_slice_in_stream && ps_dec -> u4_first_slice_in_pic ) { pocstruct_t * ps_prev_poc = & ps_dec -> s_prev_pic_poc ; pocstruct_t * ps_cur_poc = & ps_dec -> s_cur_pic_poc ; ps_dec -> u2_mbx = 0xffff ; ps_dec -> u2_mby = 0 ; if ( ( 0 == u1_is_idr_slice ) && ps_cur_slice -> u1_nal_ref_idc ) ps_dec -> u2_prev_ref_frame_num = ps_cur_slice -> u2_frame_num ; if ( u1_is_idr_slice || ps_cur_slice -> u1_mmco_equalto5 ) ps_dec -> u2_prev_ref_frame_num = 0 ; if ( ps_dec -> ps_cur_sps -> u1_gaps_in_frame_num_value_allowed_flag ) { ih264d_decode_gaps_in_frame_num ( ps_dec , u2_frame_num ) ; } ps_prev_poc -> i4_prev_frame_num_ofst = ps_cur_poc -> i4_prev_frame_num_ofst ; ps_prev_poc -> u2_frame_num = ps_cur_poc -> u2_frame_num ; ps_prev_poc -> u1_mmco_equalto5 = ps_cur_slice -> u1_mmco_equalto5 ; if ( ps_cur_slice -> u1_nal_ref_idc ) { ps_prev_poc -> i4_pic_order_cnt_lsb = ps_cur_poc -> i4_pic_order_cnt_lsb ; ps_prev_poc -> i4_pic_order_cnt_msb = ps_cur_poc -> i4_pic_order_cnt_msb ; ps_prev_poc -> i4_delta_pic_order_cnt_bottom = ps_cur_poc -> i4_delta_pic_order_cnt_bottom ; ps_prev_poc -> i4_delta_pic_order_cnt [ 0 ] = ps_cur_poc -> i4_delta_pic_order_cnt [ 0 ] ; ps_prev_poc -> i4_delta_pic_order_cnt [ 1 ] = ps_cur_poc -> i4_delta_pic_order_cnt [ 1 ] ; ps_prev_poc -> u1_bot_field = ps_cur_poc -> u1_bot_field ; } ps_dec -> u2_total_mbs_coded = 0 ; } if ( ! ps_seq -> u1_frame_mbs_only_flag ) { u1_field_pic_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( "SH:<S2SV_blank>field_pic_flag" , u1_field_pic_flag ) ; u1_bottom_field_flag = 0 ; if ( u1_field_pic_flag ) { ps_dec -> pu1_inv_scan = ( UWORD8 * ) gau1_ih264d_inv_scan_fld ; u1_bottom_field_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( "SH:<S2SV_blank>bottom_field_flag" , u1_bottom_field_flag ) ; } else { ps_dec -> pu1_inv_scan = ( UWORD8 * ) gau1_ih264d_inv_scan ; } } else { u1_field_pic_flag = 0 ; u1_bottom_field_flag = 0 ; ps_dec -> pu1_inv_scan = ( UWORD8 * ) gau1_ih264d_inv_scan ; } u1_nal_unit_type = SLICE_NAL ; if ( u1_is_idr_slice ) { u1_nal_unit_type = IDR_SLICE_NAL ; u4_idr_pic_id = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_idr_pic_id > 65535 ) return ERROR_INV_SLICE_HDR_T ; COPYTHECONTEXT ( "SH:<S2SV_blank><S2SV_blank>" , u4_idr_pic_id ) ; } i_delta_poc [ 0 ] = i_delta_poc [ 1 ] = 0 ; s_tmp_poc . i4_pic_order_cnt_lsb = 0 ; s_tmp_poc . i4_delta_pic_order_cnt_bottom = 0 ; u1_pic_order_cnt_type = ps_seq -> u1_pic_order_cnt_type ; if ( u1_pic_order_cnt_type == 0 ) { i_temp = ih264d_get_bits_h264 ( ps_bitstrm , ps_seq -> u1_log2_max_pic_order_cnt_lsb_minus ) ; if ( i_temp < 0 || i_temp >= ps_seq -> i4_max_pic_order_cntLsb ) return ERROR_INV_SLICE_HDR_T ; s_tmp_poc . i4_pic_order_cnt_lsb = i_temp ; COPYTHECONTEXT ( "SH:<S2SV_blank>pic_order_cnt_lsb" , s_tmp_poc . i4_pic_order_cnt_lsb ) ; if ( ( ps_pps -> u1_pic_order_present_flag == 1 ) && ( ! u1_field_pic_flag ) ) { s_tmp_poc . i4_delta_pic_order_cnt_bottom = ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( "SH:<S2SV_blank>delta_pic_order_cnt_bottom" , s_tmp_poc . i4_delta_pic_order_cnt_bottom ) ; } } s_tmp_poc . i4_delta_pic_order_cnt [ 0 ] = 0 ; s_tmp_poc . i4_delta_pic_order_cnt [ 1 ] = 0 ; if ( u1_pic_order_cnt_type == 1 && ( ! ps_seq -> u1_delta_pic_order_always_zero_flag ) ) { s_tmp_poc . i4_delta_pic_order_cnt [ 0 ] = ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( "SH:<S2SV_blank>delta_pic_order_cnt[0]" , s_tmp_poc . i4_delta_pic_order_cnt [ 0 ] ) ; if ( ps_pps -> u1_pic_order_present_flag && ! u1_field_pic_flag ) { s_tmp_poc . i4_delta_pic_order_cnt [ 1 ] = ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( "SH:<S2SV_blank>delta_pic_order_cnt[1]" , s_tmp_poc . i4_delta_pic_order_cnt [ 1 ] ) ; } } if ( ps_pps -> u1_redundant_pic_cnt_present_flag ) { u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_temp > MAX_REDUNDANT_PIC_CNT ) return ERROR_INV_SLICE_HDR_T ; u1_redundant_pic_cnt = u4_temp ; COPYTHECONTEXT ( "SH:<S2SV_blank>redundant_pic_cnt" , u1_redundant_pic_cnt ) ; } i1_is_end_of_poc = 1 ; ps_dec -> ps_dec_err_status -> u1_err_flag &= MASK_REJECT_CUR_PIC ; if ( ps_dec -> u4_first_slice_in_pic == 0 ) { i1_is_end_of_poc = ih264d_is_end_of_pic ( u2_frame_num , u1_nal_ref_idc , & s_tmp_poc , & ps_dec -> s_cur_pic_poc , ps_cur_slice , u1_pic_order_cnt_type , u1_nal_unit_type , u4_idr_pic_id , u1_field_pic_flag , u1_bottom_field_flag ) ; if ( i1_is_end_of_poc ) { ps_dec -> u1_first_slice_in_stream = 0 ; return ERROR_INCOMPLETE_FRAME ; } } u1_mbaff = ps_seq -> u1_mb_aff_flag && ( ! u1_field_pic_flag ) ; prev_slice_err = 0 ; if ( i1_is_end_of_poc || ps_dec -> u1_first_slice_in_stream ) { if ( u2_frame_num != ps_dec -> u2_prv_frame_num && ps_dec -> u1_top_bottom_decoded != 0 && ps_dec -> u1_top_bottom_decoded != ( TOP_FIELD_ONLY | BOT_FIELD_ONLY ) ) { ps_dec -> u1_dangling_field = 1 ; if ( ps_dec -> u4_first_slice_in_pic ) { prev_slice_err = 1 ; } else { prev_slice_err = 2 ; } if ( ps_dec -> u1_top_bottom_decoded == TOP_FIELD_ONLY ) ps_cur_slice -> u1_bottom_field_flag = 1 ; else ps_cur_slice -> u1_bottom_field_flag = 0 ; num_mb_skipped = ( ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) - ps_dec -> u2_total_mbs_coded ; ps_cur_poc = & ps_dec -> s_cur_pic_poc ; u1_is_idr_slice = ps_cur_slice -> u1_nal_unit_type == IDR_SLICE_NAL ; } else if ( ps_dec -> u4_first_slice_in_pic ) { if ( u2_first_mb_in_slice > 0 ) { prev_slice_err = 1 ; num_mb_skipped = u2_first_mb_in_slice << u1_mbaff ; ps_cur_poc = & s_tmp_poc ; ps_cur_slice -> u4_idr_pic_id = u4_idr_pic_id ; ps_cur_slice -> u1_field_pic_flag = u1_field_pic_flag ; ps_cur_slice -> u1_bottom_field_flag = u1_bottom_field_flag ; ps_cur_slice -> i4_pic_order_cnt_lsb = s_tmp_poc . i4_pic_order_cnt_lsb ; ps_cur_slice -> u1_nal_unit_type = u1_nal_unit_type ; ps_cur_slice -> u1_redundant_pic_cnt = u1_redundant_pic_cnt ; ps_cur_slice -> u1_nal_ref_idc = u1_nal_ref_idc ; ps_cur_slice -> u1_pic_order_cnt_type = u1_pic_order_cnt_type ; ps_cur_slice -> u1_mbaff_frame_flag = ps_seq -> u1_mb_aff_flag && ( ! u1_field_pic_flag ) ; } } else { prev_slice_err = 2 ; num_mb_skipped = ( ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) - ps_dec -> u2_total_mbs_coded ; ps_cur_poc = & s_tmp_poc ; } } else { if ( ( u2_first_mb_in_slice << u1_mbaff ) > ps_dec -> u2_total_mbs_coded ) { prev_slice_err = 2 ; num_mb_skipped = ( u2_first_mb_in_slice << u1_mbaff ) - ps_dec -> u2_total_mbs_coded ; ps_cur_poc = & s_tmp_poc ; } else if ( ( u2_first_mb_in_slice << u1_mbaff ) < ps_dec -> u2_total_mbs_coded ) { return ERROR_CORRUPTED_SLICE ; } } if ( prev_slice_err ) { ret = ih264d_mark_err_slice_skip ( ps_dec , num_mb_skipped , u1_is_idr_slice , u2_frame_num , ps_cur_poc , prev_slice_err ) ; if ( ps_dec -> u1_dangling_field == 1 ) { ps_dec -> u1_second_field = 1 - ps_dec -> u1_second_field ; ps_dec -> u1_first_slice_in_stream = 0 ; ps_dec -> u1_top_bottom_decoded = TOP_FIELD_ONLY | BOT_FIELD_ONLY ; return ERROR_DANGLING_FIELD_IN_PIC ; } if ( prev_slice_err == 2 ) { ps_dec -> u1_first_slice_in_stream = 0 ; return ERROR_INCOMPLETE_FRAME ; } if ( ps_dec -> u2_total_mbs_coded >= ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) { ps_dec -> u1_first_slice_in_stream = 0 ; return ERROR_IN_LAST_SLICE_OF_PIC ; } if ( ps_dec -> ps_dec_err_status -> u1_err_flag & REJECT_CUR_PIC ) { ih264d_err_pic_dispbuf_mgr ( ps_dec ) ; return ERROR_NEW_FRAME_EXPECTED ; } if ( ret != OK ) return ret ; i1_is_end_of_poc = 0 ; } if ( ps_dec -> u4_first_slice_in_pic == 0 ) { ps_dec -> ps_parse_cur_slice ++ ; ps_dec -> u2_cur_slice_num ++ ; } if ( ( ps_dec -> u1_separate_parse == 0 ) && ( ps_dec -> u4_first_slice_in_pic == 0 ) ) { ps_dec -> ps_decode_cur_slice ++ ; } ps_dec -> u1_slice_header_done = 0 ; if ( u1_field_pic_flag ) { ps_dec -> u2_prv_frame_num = u2_frame_num ; } if ( ps_cur_slice -> u1_mmco_equalto5 ) { WORD32 i4_temp_poc ; WORD32 i4_top_field_order_poc , i4_bot_field_order_poc ; if ( ! ps_cur_slice -> u1_field_pic_flag ) { i4_top_field_order_poc = ps_dec -> ps_cur_pic -> i4_top_field_order_cnt ; i4_bot_field_order_poc = ps_dec -> ps_cur_pic -> i4_bottom_field_order_cnt ; i4_temp_poc = MIN ( i4_top_field_order_poc , i4_bot_field_order_poc ) ; } else if ( ! ps_cur_slice -> u1_bottom_field_flag ) i4_temp_poc = ps_dec -> ps_cur_pic -> i4_top_field_order_cnt ; else i4_temp_poc = ps_dec -> ps_cur_pic -> i4_bottom_field_order_cnt ; ps_dec -> ps_cur_pic -> i4_top_field_order_cnt = i4_temp_poc - ps_dec -> ps_cur_pic -> i4_top_field_order_cnt ; ps_dec -> ps_cur_pic -> i4_bottom_field_order_cnt = i4_temp_poc - ps_dec -> ps_cur_pic -> i4_bottom_field_order_cnt ; ps_dec -> ps_cur_pic -> i4_poc = i4_temp_poc ; ps_dec -> ps_cur_pic -> i4_avg_poc = i4_temp_poc ; } if ( ps_dec -> u4_first_slice_in_pic ) { ret = ih264d_decode_pic_order_cnt ( u1_is_idr_slice , u2_frame_num , & ps_dec -> s_prev_pic_poc , & s_tmp_poc , ps_cur_slice , ps_pps , u1_nal_ref_idc , u1_bottom_field_flag , u1_field_pic_flag , & i4_poc ) ; if ( ret != OK ) return ret ; if ( i4_poc >= ps_dec -> i4_max_poc ) ps_dec -> i4_max_poc = i4_poc ; if ( i4_poc == 0 ) { ps_dec -> i4_prev_max_display_seq = ps_dec -> i4_prev_max_display_seq + ps_dec -> i4_max_poc + ps_dec -> u1_max_dec_frame_buffering + 1 ; ps_dec -> i4_max_poc = 0 ; } } ps_cur_slice -> i4_delta_pic_order_cnt [ 0 ] = i_delta_poc [ 0 ] ; ps_cur_slice -> i4_delta_pic_order_cnt [ 1 ] = i_delta_poc [ 1 ] ; ps_cur_slice -> u4_idr_pic_id = u4_idr_pic_id ; ps_cur_slice -> u2_first_mb_in_slice = u2_first_mb_in_slice ; ps_cur_slice -> u1_field_pic_flag = u1_field_pic_flag ; ps_cur_slice -> u1_bottom_field_flag = u1_bottom_field_flag ; ps_cur_slice -> u1_slice_type = u1_slice_type ; ps_cur_slice -> i4_pic_order_cnt_lsb = s_tmp_poc . i4_pic_order_cnt_lsb ; ps_cur_slice -> u1_nal_unit_type = u1_nal_unit_type ; ps_cur_slice -> u1_redundant_pic_cnt = u1_redundant_pic_cnt ; ps_cur_slice -> u1_nal_ref_idc = u1_nal_ref_idc ; ps_cur_slice -> u1_pic_order_cnt_type = u1_pic_order_cnt_type ; if ( ps_seq -> u1_frame_mbs_only_flag ) ps_cur_slice -> u1_direct_8x8_inference_flag = ps_seq -> u1_direct_8x8_inference_flag ; else ps_cur_slice -> u1_direct_8x8_inference_flag = 1 ; if ( u1_slice_type == B_SLICE ) { ps_cur_slice -> u1_direct_spatial_mv_pred_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( "SH:<S2SV_blank>direct_spatial_mv_pred_flag" , ps_cur_slice -> u1_direct_spatial_mv_pred_flag ) ; if ( ps_cur_slice -> u1_direct_spatial_mv_pred_flag ) ps_cur_slice -> pf_decodeDirect = ih264d_decode_spatial_direct ; else ps_cur_slice -> pf_decodeDirect = ih264d_decode_temporal_direct ; if ( ! ( ( ps_pps -> ps_sps -> u1_mb_aff_flag ) && ( ! u1_field_pic_flag ) ) ) ps_dec -> pf_mvpred = ih264d_mvpred_nonmbaffB ; } else { if ( ! ( ( ps_pps -> ps_sps -> u1_mb_aff_flag ) && ( ! u1_field_pic_flag ) ) ) ps_dec -> pf_mvpred = ih264d_mvpred_nonmbaff ; } if ( ps_dec -> u4_first_slice_in_pic ) { if ( u2_first_mb_in_slice == 0 ) { ret = ih264d_start_of_pic ( ps_dec , i4_poc , & s_tmp_poc , u2_frame_num , ps_pps ) ; if ( ret != OK ) return ret ; } ps_dec -> u4_output_present = 0 ; { ih264d_get_next_display_field ( ps_dec , ps_dec -> ps_out_buffer , & ( ps_dec -> s_disp_op ) ) ; if ( 0 != ps_dec -> s_disp_op . u4_error_code ) { ps_dec -> u4_fmt_conv_cur_row = ps_dec -> s_disp_frame_info . u4_y_ht ; } else ps_dec -> u4_output_present = 1 ; } if ( ps_dec -> u1_separate_parse == 1 ) { if ( ps_dec -> u4_dec_thread_created == 0 ) { ithread_create ( ps_dec -> pv_dec_thread_handle , NULL , ( void * ) ih264d_decode_picture_thread , ( void * ) ps_dec ) ; ps_dec -> u4_dec_thread_created = 1 ; } if ( ( ps_dec -> u4_num_cores == 3 ) && ( ( ps_dec -> u4_app_disable_deblk_frm == 0 ) || ps_dec -> i1_recon_in_thread3_flag ) && ( ps_dec -> u4_bs_deblk_thread_created == 0 ) ) { ps_dec -> u4_start_recon_deblk = 0 ; ithread_create ( ps_dec -> pv_bs_deblk_thread_handle , NULL , ( void * ) ih264d_recon_deblk_thread , ( void * ) ps_dec ) ; ps_dec -> u4_bs_deblk_thread_created = 1 ; } } } { UWORD8 uc_nofield_nombaff ; uc_nofield_nombaff = ( ( ps_dec -> ps_cur_slice -> u1_field_pic_flag == 0 ) && ( ps_dec -> ps_cur_slice -> u1_mbaff_frame_flag == 0 ) && ( u1_slice_type != B_SLICE ) && ( ps_dec -> ps_cur_pps -> u1_wted_pred_flag == 0 ) ) ; if ( uc_nofield_nombaff ) { ps_dec -> p_form_mb_part_info = ih264d_form_mb_part_info_bp ; ps_dec -> p_motion_compensate = ih264d_motion_compensate_bp ; } else { ps_dec -> p_form_mb_part_info = ih264d_form_mb_part_info_mp ; ps_dec -> p_motion_compensate = ih264d_motion_compensate_mp ; } } { dec_err_status_t * ps_err = ps_dec -> ps_dec_err_status ; if ( ps_err -> u4_frm_sei_sync == u2_frame_num ) { ps_err -> u1_err_flag = ACCEPT_ALL_PICS ; ps_err -> u4_frm_sei_sync = SYNC_FRM_DEFAULT ; } ps_err -> u4_cur_frm = u2_frame_num ; } { WORD32 i4_skip_b_pic , i4_skip_p_pic ; i4_skip_b_pic = ( ps_dec -> u4_skip_frm_mask & B_SLC_BIT ) && ( B_SLICE == u1_slice_type ) && ( 0 == u1_nal_ref_idc ) ; i4_skip_p_pic = ( ps_dec -> u4_skip_frm_mask & P_SLC_BIT ) && ( P_SLICE == u1_slice_type ) && ( 0 == u1_nal_ref_idc ) ; if ( i4_skip_b_pic ) { ps_dec -> ps_cur_pic -> u4_pack_slc_typ |= B_SLC_BIT ; ps_dec -> u1_last_pic_not_decoded = 1 ; return OK ; } if ( i4_skip_p_pic ) { ps_dec -> ps_cur_pic -> u4_pack_slc_typ |= P_SLC_BIT ; ps_dec -> u1_last_pic_not_decoded = 1 ; return OK ; } } { UWORD16 u2_mb_x , u2_mb_y ; ps_dec -> i4_submb_ofst = ( ( u2_first_mb_in_slice << ps_cur_slice -> u1_mbaff_frame_flag ) * SUB_BLK_SIZE ) - SUB_BLK_SIZE ; if ( u2_first_mb_in_slice ) { UWORD8 u1_mb_aff ; UWORD8 u1_field_pic ; UWORD16 u2_frm_wd_in_mbs ; u2_frm_wd_in_mbs = ps_seq -> u2_frm_wd_in_mbs ; u1_mb_aff = ps_cur_slice -> u1_mbaff_frame_flag ; u1_field_pic = ps_cur_slice -> u1_field_pic_flag ; { UWORD32 x_offset ; UWORD32 y_offset ; UWORD32 u4_frame_stride ; tfr_ctxt_t * ps_trns_addr ; if ( ps_dec -> u1_separate_parse ) { ps_trns_addr = & ps_dec -> s_tran_addrecon_parse ; } else { ps_trns_addr = & ps_dec -> s_tran_addrecon ; } u2_mb_x = MOD ( u2_first_mb_in_slice , u2_frm_wd_in_mbs ) ; u2_mb_y = DIV ( u2_first_mb_in_slice , u2_frm_wd_in_mbs ) ; u2_mb_y <<= u1_mb_aff ; if ( ( u2_mb_x > u2_frm_wd_in_mbs - 1 ) || ( u2_mb_y > ps_dec -> u2_frm_ht_in_mbs - 1 ) ) { return ERROR_CORRUPTED_SLICE ; } u4_frame_stride = ps_dec -> u2_frm_wd_y << u1_field_pic ; x_offset = u2_mb_x << 4 ; y_offset = ( u2_mb_y * u4_frame_stride ) << 4 ; ps_trns_addr -> pu1_dest_y = ps_dec -> s_cur_pic . pu1_buf1 + x_offset + y_offset ; u4_frame_stride = ps_dec -> u2_frm_wd_uv << u1_field_pic ; x_offset >>= 1 ; y_offset = ( u2_mb_y * u4_frame_stride ) << 3 ; x_offset *= YUV420SP_FACTOR ; ps_trns_addr -> pu1_dest_u = ps_dec -> s_cur_pic . pu1_buf2 + x_offset + y_offset ; ps_trns_addr -> pu1_dest_v = ps_dec -> s_cur_pic . pu1_buf3 + x_offset + y_offset ; ps_trns_addr -> pu1_mb_y = ps_trns_addr -> pu1_dest_y ; ps_trns_addr -> pu1_mb_u = ps_trns_addr -> pu1_dest_u ; ps_trns_addr -> pu1_mb_v = ps_trns_addr -> pu1_dest_v ; if ( ps_dec -> u1_separate_parse == 1 ) { ps_dec -> ps_deblk_mbn = ps_dec -> ps_deblk_pic + ( u2_first_mb_in_slice << u1_mb_aff ) ; } else { ps_dec -> ps_deblk_mbn = ps_dec -> ps_deblk_pic + ( u2_first_mb_in_slice << u1_mb_aff ) ; } ps_dec -> u2_cur_mb_addr = ( u2_first_mb_in_slice << u1_mb_aff ) ; ps_dec -> ps_mv_cur = ps_dec -> s_cur_pic . ps_mv + ( ( u2_first_mb_in_slice << u1_mb_aff ) << 4 ) ; } } else { tfr_ctxt_t * ps_trns_addr ; if ( ps_dec -> u1_separate_parse ) { ps_trns_addr = & ps_dec -> s_tran_addrecon_parse ; } else { ps_trns_addr = & ps_dec -> s_tran_addrecon ; } u2_mb_x = 0xffff ; u2_mb_y = 0 ; ps_dec -> u2_cur_mb_addr = 0 ; ps_dec -> ps_deblk_mbn = ps_dec -> ps_deblk_pic ; ps_dec -> ps_mv_cur = ps_dec -> s_cur_pic . ps_mv ; ps_trns_addr -> pu1_dest_y = ps_dec -> s_cur_pic . pu1_buf1 ; ps_trns_addr -> pu1_dest_u = ps_dec -> s_cur_pic . pu1_buf2 ; ps_trns_addr -> pu1_dest_v = ps_dec -> s_cur_pic . pu1_buf3 ; ps_trns_addr -> pu1_mb_y = ps_trns_addr -> pu1_dest_y ; ps_trns_addr -> pu1_mb_u = ps_trns_addr -> pu1_dest_u ; ps_trns_addr -> pu1_mb_v = ps_trns_addr -> pu1_dest_v ; } ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; ps_dec -> u2_mbx = ( MOD ( u2_first_mb_in_slice - 1 , ps_seq -> u2_frm_wd_in_mbs ) ) ; ps_dec -> u2_mby = ( DIV ( u2_first_mb_in_slice - 1 , ps_seq -> u2_frm_wd_in_mbs ) ) ; ps_dec -> u2_mby <<= ps_cur_slice -> u1_mbaff_frame_flag ; ps_dec -> i2_prev_slice_mbx = ps_dec -> u2_mbx ; ps_dec -> i2_prev_slice_mby = ps_dec -> u2_mby ; } ps_bitstrm -> u4_max_ofst += ps_dec -> ps_cur_pps -> u1_entropy_coding_mode ; ps_dec -> u1_B = ( u1_slice_type == B_SLICE ) ; ps_dec -> u4_next_mb_skip = 0 ; ps_dec -> ps_parse_cur_slice -> u4_first_mb_in_slice = ps_dec -> ps_cur_slice -> u2_first_mb_in_slice ; ps_dec -> ps_parse_cur_slice -> slice_type = ps_dec -> ps_cur_slice -> u1_slice_type ; ps_dec -> u4_start_recon_deblk = 1 ; { WORD32 num_entries ; WORD32 size ; UWORD8 * pu1_buf ; num_entries = MAX_FRAMES ; if ( ( 1 >= ps_dec -> ps_cur_sps -> u1_num_ref_frames ) && ( 0 == ps_dec -> i4_display_delay ) ) { num_entries = 1 ; } num_entries = ( ( 2 * num_entries ) + 1 ) ; num_entries *= 2 ; size = num_entries * sizeof ( void * ) ; size += PAD_MAP_IDX_POC * sizeof ( void * ) ; pu1_buf = ( UWORD8 * ) ps_dec -> pv_map_ref_idx_to_poc_buf ; pu1_buf += size * ps_dec -> u2_cur_slice_num ; ps_dec -> ps_parse_cur_slice -> ppv_map_ref_idx_to_poc = ( void * ) pu1_buf ; } if ( ps_dec -> u1_separate_parse ) { ps_dec -> ps_parse_cur_slice -> pv_tu_coeff_data_start = ps_dec -> pv_parse_tu_coeff_data ; } else { ps_dec -> pv_proc_tu_coeff_data = ps_dec -> pv_parse_tu_coeff_data ; } if ( u1_slice_type == I_SLICE ) { ps_dec -> ps_cur_pic -> u4_pack_slc_typ |= I_SLC_BIT ; ret = ih264d_parse_islice ( ps_dec , u2_first_mb_in_slice ) ; if ( ps_dec -> i4_pic_type != B_SLICE && ps_dec -> i4_pic_type != P_SLICE ) ps_dec -> i4_pic_type = I_SLICE ; } else if ( u1_slice_type == P_SLICE ) { ps_dec -> ps_cur_pic -> u4_pack_slc_typ |= P_SLC_BIT ; ret = ih264d_parse_pslice ( ps_dec , u2_first_mb_in_slice ) ; ps_dec -> u1_pr_sl_type = u1_slice_type ; if ( ps_dec -> i4_pic_type != B_SLICE ) ps_dec -> i4_pic_type = P_SLICE ; } else if ( u1_slice_type == B_SLICE ) { ps_dec -> ps_cur_pic -> u4_pack_slc_typ |= B_SLC_BIT ; ret = ih264d_parse_bslice ( ps_dec , u2_first_mb_in_slice ) ; ps_dec -> u1_pr_sl_type = u1_slice_type ; ps_dec -> i4_pic_type = B_SLICE ; } else return ERROR_INV_SLC_TYPE_T ; if ( ps_dec -> u1_slice_header_done ) { ps_dec -> u1_first_slice_in_stream = 0 ; } if ( ret != OK ) return ret ; <S2SV_StartBug> ps_dec -> i2_prev_slice_mbx = ps_dec -> u2_mbx ; <S2SV_EndBug> ps_dec -> i2_prev_slice_mby = ps_dec -> u2_mby ; if ( ps_dec -> u2_total_mbs_coded >= ( ps_seq -> u2_max_mb_addr + 1 ) ) { ps_dec -> u1_pic_decode_done = 1 ; } { dec_err_status_t * ps_err = ps_dec -> ps_dec_err_status ; if ( ( ps_err -> u1_err_flag & REJECT_PB_PICS ) && ( ps_err -> u1_cur_pic_type == PIC_TYPE_I ) ) { ps_err -> u1_err_flag = ACCEPT_ALL_PICS ; } } PRINT_BIN_BIT_RATIO ( ps_dec ) return ret ; }
CWE-200 WORD32 ih264d_video_decode ( iv_obj_t * dec_hdl , void * pv_api_ip , void * pv_api_op ) { dec_struct_t * ps_dec = ( dec_struct_t * ) ( dec_hdl -> pv_codec_handle ) ; WORD32 i4_err_status = 0 ; UWORD8 * pu1_buf = NULL ; WORD32 buflen ; UWORD32 u4_max_ofst , u4_length_of_start_code = 0 ; UWORD32 bytes_consumed = 0 ; UWORD32 cur_slice_is_nonref = 0 ; UWORD32 u4_next_is_aud ; UWORD32 u4_first_start_code_found = 0 ; WORD32 ret = 0 , api_ret_value = IV_SUCCESS ; WORD32 header_data_left = 0 , frame_data_left = 0 ; UWORD8 * pu1_bitstrm_buf ; ivd_video_decode_ip_t * ps_dec_ip ; ivd_video_decode_op_t * ps_dec_op ; ithread_set_name ( ( void * ) "Parse_thread" ) ; ps_dec_ip = ( ivd_video_decode_ip_t * ) pv_api_ip ; ps_dec_op = ( ivd_video_decode_op_t * ) pv_api_op ; { UWORD32 u4_size ; u4_size = ps_dec_op -> u4_size ; memset ( ps_dec_op , 0 , sizeof ( ivd_video_decode_op_t ) ) ; ps_dec_op -> u4_size = u4_size ; } ps_dec -> pv_dec_out = ps_dec_op ; if ( ps_dec -> init_done != 1 ) { return IV_FAIL ; } DATA_SYNC ( ) ; if ( 0 == ps_dec -> u1_flushfrm ) { if ( ps_dec_ip -> pv_stream_buffer == NULL ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DEC_FRM_BS_BUF_NULL ; return IV_FAIL ; } if ( ps_dec_ip -> u4_num_Bytes <= 0 ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DEC_NUMBYTES_INV ; return IV_FAIL ; } } ps_dec -> u1_pic_decode_done = 0 ; ps_dec_op -> u4_num_bytes_consumed = 0 ; ps_dec -> ps_out_buffer = NULL ; if ( ps_dec_ip -> u4_size >= offsetof ( ivd_video_decode_ip_t , s_out_buffer ) ) ps_dec -> ps_out_buffer = & ps_dec_ip -> s_out_buffer ; ps_dec -> u4_fmt_conv_cur_row = 0 ; ps_dec -> u4_output_present = 0 ; ps_dec -> s_disp_op . u4_error_code = 1 ; ps_dec -> u4_fmt_conv_num_rows = FMT_CONV_NUM_ROWS ; if ( 0 == ps_dec -> u4_share_disp_buf && ps_dec -> i4_decode_header == 0 ) { UWORD32 i ; if ( ( ps_dec -> ps_out_buffer -> u4_num_bufs == 0 ) || ( ps_dec -> ps_out_buffer -> u4_num_bufs > IVD_VIDDEC_MAX_IO_BUFFERS ) ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DISP_FRM_ZERO_OP_BUFS ; return IV_FAIL ; } for ( i = 0 ; i < ps_dec -> ps_out_buffer -> u4_num_bufs ; i ++ ) { if ( ps_dec -> ps_out_buffer -> pu1_bufs [ i ] == NULL ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DISP_FRM_OP_BUF_NULL ; return IV_FAIL ; } if ( ps_dec -> ps_out_buffer -> u4_min_out_buf_size [ i ] == 0 ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DISP_FRM_ZERO_OP_BUF_SIZE ; return IV_FAIL ; } } } if ( ps_dec -> u4_total_frames_decoded >= NUM_FRAMES_LIMIT ) { ps_dec_op -> u4_error_code = ERROR_FRAME_LIMIT_OVER ; return IV_FAIL ; } ps_dec -> u4_ts = ps_dec_ip -> u4_ts ; ps_dec_op -> u4_error_code = 0 ; ps_dec_op -> e_pic_type = - 1 ; ps_dec_op -> u4_output_present = 0 ; ps_dec_op -> u4_frame_decoded_flag = 0 ; ps_dec -> i4_frametype = - 1 ; ps_dec -> i4_content_type = - 1 ; ps_dec -> u4_slice_start_code_found = 0 ; if ( ps_dec -> u1_init_dec_flag == 1 && ps_dec -> u4_share_disp_buf == 1 && ps_dec -> u1_flushfrm == 0 ) { UWORD32 i ; WORD32 disp_avail = 0 , free_id ; for ( i = 0 ; i < ps_dec -> u1_pic_bufs ; i ++ ) { if ( 0 == ps_dec -> u4_disp_buf_mapping [ i ] || 1 == ps_dec -> u4_disp_buf_to_be_freed [ i ] ) { disp_avail = 1 ; break ; } } if ( 0 == disp_avail ) { ps_dec_op -> u4_error_code = IVD_DEC_REF_BUF_NULL ; ps_dec_op -> u4_error_code |= ( 1 << IVD_UNSUPPORTEDPARAM ) ; return ( IV_FAIL ) ; } while ( 1 ) { pic_buffer_t * ps_pic_buf ; ps_pic_buf = ( pic_buffer_t * ) ih264_buf_mgr_get_next_free ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , & free_id ) ; if ( ps_pic_buf == NULL ) { UWORD32 i , display_queued = 0 ; for ( i = 0 ; i < ( MAX_DISP_BUFS_NEW ) ; i ++ ) { if ( 0 != ps_dec -> u4_disp_buf_mapping [ i ] ) { display_queued = 1 ; break ; } } if ( 1 == display_queued ) { ps_dec_op -> u4_error_code = IVD_DEC_REF_BUF_NULL ; ps_dec_op -> u4_error_code |= ( 1 << IVD_UNSUPPORTEDPARAM ) ; return ( IV_FAIL ) ; } } else { if ( 1 == ps_dec -> u4_disp_buf_mapping [ free_id ] ) { ih264_buf_mgr_set_status ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , free_id , BUF_MGR_IO ) ; } else { ih264_buf_mgr_release ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , free_id , BUF_MGR_IO ) ; break ; } } } } if ( ps_dec -> u1_flushfrm ) { if ( ps_dec -> u1_init_dec_flag == 0 ) { ps_dec -> u1_flushfrm = 0 ; return ( IV_FAIL ) ; } ih264d_get_next_display_field ( ps_dec , ps_dec -> ps_out_buffer , & ( ps_dec -> s_disp_op ) ) ; if ( 0 == ps_dec -> s_disp_op . u4_error_code ) { if ( check_app_out_buf_size ( ps_dec ) != IV_SUCCESS ) { ps_dec_op -> u4_error_code = IVD_DISP_FRM_ZERO_OP_BUF_SIZE ; return ( IV_FAIL ) ; } ps_dec -> u4_fmt_conv_cur_row = 0 ; ps_dec -> u4_fmt_conv_num_rows = ps_dec -> s_disp_frame_info . u4_y_ht ; ih264d_format_convert ( ps_dec , & ( ps_dec -> s_disp_op ) , ps_dec -> u4_fmt_conv_cur_row , ps_dec -> u4_fmt_conv_num_rows ) ; ps_dec -> u4_fmt_conv_cur_row += ps_dec -> u4_fmt_conv_num_rows ; ps_dec -> u4_output_present = 1 ; } ih264d_release_display_field ( ps_dec , & ( ps_dec -> s_disp_op ) ) ; ps_dec_op -> u4_pic_wd = ( UWORD32 ) ps_dec -> u2_disp_width ; ps_dec_op -> u4_pic_ht = ( UWORD32 ) ps_dec -> u2_disp_height ; ps_dec_op -> u4_new_seq = 0 ; ps_dec_op -> u4_output_present = ps_dec -> u4_output_present ; ps_dec_op -> u4_progressive_frame_flag = ps_dec -> s_disp_op . u4_progressive_frame_flag ; ps_dec_op -> e_output_format = ps_dec -> s_disp_op . e_output_format ; ps_dec_op -> s_disp_frm_buf = ps_dec -> s_disp_op . s_disp_frm_buf ; ps_dec_op -> e4_fld_type = ps_dec -> s_disp_op . e4_fld_type ; ps_dec_op -> u4_ts = ps_dec -> s_disp_op . u4_ts ; ps_dec_op -> u4_disp_buf_id = ps_dec -> s_disp_op . u4_disp_buf_id ; ps_dec_op -> u4_is_ref_flag = - 1 ; ps_dec_op -> e_pic_type = IV_NA_FRAME ; ps_dec_op -> u4_frame_decoded_flag = 0 ; if ( 0 == ps_dec -> s_disp_op . u4_error_code ) { return ( IV_SUCCESS ) ; } else return ( IV_FAIL ) ; } if ( ps_dec -> u1_res_changed == 1 ) { ih264d_init_decoder ( ps_dec ) ; } ps_dec -> u4_prev_nal_skipped = 0 ; ps_dec -> u2_cur_mb_addr = 0 ; ps_dec -> u2_total_mbs_coded = 0 ; ps_dec -> u2_cur_slice_num = 0 ; ps_dec -> cur_dec_mb_num = 0 ; ps_dec -> cur_recon_mb_num = 0 ; ps_dec -> u4_first_slice_in_pic = 1 ; ps_dec -> u1_slice_header_done = 0 ; ps_dec -> u1_dangling_field = 0 ; ps_dec -> u4_dec_thread_created = 0 ; ps_dec -> u4_bs_deblk_thread_created = 0 ; ps_dec -> u4_cur_bs_mb_num = 0 ; ps_dec -> u4_start_recon_deblk = 0 ; ps_dec -> u4_sps_cnt_in_process = 0 ; DEBUG_THREADS_PRINTF ( "<S2SV_blank>Starting<S2SV_blank>process<S2SV_blank>call\\n" ) ; ps_dec -> u4_pic_buf_got = 0 ; do { WORD32 buf_size ; pu1_buf = ( UWORD8 * ) ps_dec_ip -> pv_stream_buffer + ps_dec_op -> u4_num_bytes_consumed ; u4_max_ofst = ps_dec_ip -> u4_num_Bytes - ps_dec_op -> u4_num_bytes_consumed ; if ( ( NULL == ps_dec -> pu1_bits_buf_dynamic ) && ( ps_dec -> i4_header_decoded & 1 ) ) { WORD32 size ; void * pv_buf ; void * pv_mem_ctxt = ps_dec -> pv_mem_ctxt ; size = MAX ( 256000 , ps_dec -> u2_pic_wd * ps_dec -> u2_pic_ht * 3 / 2 ) ; <S2SV_StartBug> pv_buf = ps_dec -> pf_aligned_alloc ( pv_mem_ctxt , 128 , size ) ; <S2SV_EndBug> RETURN_IF ( ( NULL == pv_buf ) , IV_FAIL ) ; ps_dec -> pu1_bits_buf_dynamic = pv_buf ; ps_dec -> u4_dynamic_bits_buf_size = size ; } if ( ps_dec -> pu1_bits_buf_dynamic ) { pu1_bitstrm_buf = ps_dec -> pu1_bits_buf_dynamic ; buf_size = ps_dec -> u4_dynamic_bits_buf_size ; } else { pu1_bitstrm_buf = ps_dec -> pu1_bits_buf_static ; buf_size = ps_dec -> u4_static_bits_buf_size ; } u4_next_is_aud = 0 ; buflen = ih264d_find_start_code ( pu1_buf , 0 , u4_max_ofst , & u4_length_of_start_code , & u4_next_is_aud ) ; if ( buflen == - 1 ) buflen = 0 ; buflen = MIN ( buflen , buf_size - 8 ) ; bytes_consumed = buflen + u4_length_of_start_code ; ps_dec_op -> u4_num_bytes_consumed += bytes_consumed ; { UWORD8 u1_firstbyte , u1_nal_ref_idc ; if ( ps_dec -> i4_app_skip_mode == IVD_SKIP_B ) { u1_firstbyte = * ( pu1_buf + u4_length_of_start_code ) ; u1_nal_ref_idc = ( UWORD8 ) ( NAL_REF_IDC ( u1_firstbyte ) ) ; if ( u1_nal_ref_idc == 0 ) { cur_slice_is_nonref = 1 ; continue ; } else { if ( 1 == cur_slice_is_nonref ) { ps_dec_op -> u4_num_bytes_consumed -= bytes_consumed ; ps_dec_op -> e_pic_type = IV_B_FRAME ; ps_dec_op -> u4_error_code = IVD_DEC_FRM_SKIPPED ; ps_dec_op -> u4_error_code |= ( 1 << IVD_UNSUPPORTEDPARAM ) ; ps_dec_op -> u4_frame_decoded_flag = 0 ; ps_dec_op -> u4_size = sizeof ( ivd_video_decode_op_t ) ; ih264d_signal_decode_thread ( ps_dec ) ; if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } return ( IV_FAIL ) ; } } } } if ( buflen ) { memcpy ( pu1_bitstrm_buf , pu1_buf + u4_length_of_start_code , buflen ) ; if ( ( buflen + 8 ) < buf_size ) { memset ( pu1_bitstrm_buf + buflen , 0 , 8 ) ; } u4_first_start_code_found = 1 ; } else { if ( u4_first_start_code_found == 0 ) { ps_dec -> i4_error_code = ERROR_START_CODE_NOT_FOUND ; ps_dec_op -> u4_error_code |= 1 << IVD_INSUFFICIENTDATA ; if ( ps_dec -> u4_pic_buf_got == 0 ) { ih264d_fill_output_struct_from_context ( ps_dec , ps_dec_op ) ; ps_dec_op -> u4_error_code = ps_dec -> i4_error_code ; ps_dec_op -> u4_frame_decoded_flag = 0 ; return ( IV_FAIL ) ; } else { ps_dec -> u1_pic_decode_done = 1 ; continue ; } } else { frame_data_left = 0 ; header_data_left = 0 ; continue ; } } ps_dec -> u4_return_to_app = 0 ; ret = ih264d_parse_nal_unit ( dec_hdl , ps_dec_op , pu1_bitstrm_buf , buflen ) ; if ( ret != OK ) { UWORD32 error = ih264d_map_error ( ret ) ; ps_dec_op -> u4_error_code = error | ret ; api_ret_value = IV_FAIL ; if ( ( ret == IVD_RES_CHANGED ) || ( ret == IVD_MEM_ALLOC_FAILED ) || ( ret == ERROR_UNAVAIL_PICBUF_T ) || ( ret == ERROR_UNAVAIL_MVBUF_T ) || ( ret == ERROR_INV_SPS_PPS_T ) || ( ret == IVD_DISP_FRM_ZERO_OP_BUF_SIZE ) ) { ps_dec -> u4_slice_start_code_found = 0 ; break ; } if ( ( ret == ERROR_INCOMPLETE_FRAME ) || ( ret == ERROR_DANGLING_FIELD_IN_PIC ) ) { ps_dec_op -> u4_num_bytes_consumed -= bytes_consumed ; api_ret_value = IV_FAIL ; break ; } if ( ret == ERROR_IN_LAST_SLICE_OF_PIC ) { api_ret_value = IV_FAIL ; break ; } } if ( ps_dec -> u4_return_to_app ) { ps_dec_op -> u4_num_bytes_consumed -= bytes_consumed ; ps_dec_op -> u4_error_code = IVD_DEC_FRM_SKIPPED ; ps_dec_op -> u4_error_code |= ( 1 << IVD_UNSUPPORTEDPARAM ) ; ps_dec_op -> u4_frame_decoded_flag = 0 ; ps_dec_op -> u4_size = sizeof ( ivd_video_decode_op_t ) ; ih264d_signal_decode_thread ( ps_dec ) ; if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } return ( IV_FAIL ) ; } header_data_left = ( ( ps_dec -> i4_decode_header == 1 ) && ( ps_dec -> i4_header_decoded != 3 ) && ( ps_dec_op -> u4_num_bytes_consumed < ps_dec_ip -> u4_num_Bytes ) ) ; frame_data_left = ( ( ( ps_dec -> i4_decode_header == 0 ) && ( ( ps_dec -> u1_pic_decode_done == 0 ) || ( u4_next_is_aud == 1 ) ) ) && ( ps_dec_op -> u4_num_bytes_consumed < ps_dec_ip -> u4_num_Bytes ) ) ; } while ( ( header_data_left == 1 ) || ( frame_data_left == 1 ) ) ; if ( ( ps_dec -> u4_pic_buf_got == 1 ) && ( ret != IVD_MEM_ALLOC_FAILED ) && ps_dec -> u2_total_mbs_coded < ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) { WORD32 num_mb_skipped ; WORD32 prev_slice_err ; pocstruct_t temp_poc ; WORD32 ret1 ; WORD32 ht_in_mbs ; ht_in_mbs = ps_dec -> u2_pic_ht >> ( 4 + ps_dec -> ps_cur_slice -> u1_field_pic_flag ) ; num_mb_skipped = ( ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) - ps_dec -> u2_total_mbs_coded ; if ( ps_dec -> u4_first_slice_in_pic && ( ps_dec -> u4_pic_buf_got == 0 ) ) prev_slice_err = 1 ; else prev_slice_err = 2 ; if ( ps_dec -> u4_first_slice_in_pic && ( ps_dec -> u2_total_mbs_coded == 0 ) ) prev_slice_err = 1 ; ret1 = ih264d_mark_err_slice_skip ( ps_dec , num_mb_skipped , ps_dec -> u1_nal_unit_type == IDR_SLICE_NAL , ps_dec -> ps_cur_slice -> u2_frame_num , & temp_poc , prev_slice_err ) ; if ( ( ret1 == ERROR_UNAVAIL_PICBUF_T ) || ( ret1 == ERROR_UNAVAIL_MVBUF_T ) || ( ret1 == ERROR_INV_SPS_PPS_T ) ) { ret = ret1 ; } } if ( ( ret == IVD_RES_CHANGED ) || ( ret == IVD_MEM_ALLOC_FAILED ) || ( ret == ERROR_UNAVAIL_PICBUF_T ) || ( ret == ERROR_UNAVAIL_MVBUF_T ) || ( ret == ERROR_INV_SPS_PPS_T ) ) { ih264d_signal_decode_thread ( ps_dec ) ; if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } if ( ret == IVD_RES_CHANGED ) { ps_dec_op -> u4_num_bytes_consumed -= bytes_consumed ; } return IV_FAIL ; } if ( ps_dec -> u1_separate_parse ) { if ( ps_dec -> u4_num_cores == 2 ) { if ( ( ps_dec -> u4_nmb_deblk == 0 ) && ( ps_dec -> u4_start_recon_deblk == 1 ) && ( ps_dec -> ps_cur_sps -> u1_mb_aff_flag == 0 ) ) { UWORD32 u4_num_mbs , u4_max_addr ; tfr_ctxt_t s_tfr_ctxt ; tfr_ctxt_t * ps_tfr_cxt = & s_tfr_ctxt ; pad_mgr_t * ps_pad_mgr = & ps_dec -> s_pad_mgr ; u4_max_addr = ( ps_dec -> u2_frm_wd_in_mbs * ps_dec -> u2_frm_ht_in_mbs ) - 1 ; ps_dec -> u4_cur_bs_mb_num = u4_max_addr + 1 ; ih264d_init_deblk_tfr_ctxt ( ps_dec , ps_pad_mgr , ps_tfr_cxt , ps_dec -> u2_frm_wd_in_mbs , 0 ) ; u4_num_mbs = u4_max_addr - ps_dec -> u4_cur_deblk_mb_num + 1 ; DEBUG_PERF_PRINTF ( "mbs<S2SV_blank>left<S2SV_blank>for<S2SV_blank>deblocking=<S2SV_blank>%d<S2SV_blank>\\n" , u4_num_mbs ) ; if ( u4_num_mbs != 0 ) ih264d_check_mb_map_deblk ( ps_dec , u4_num_mbs , ps_tfr_cxt , 1 ) ; ps_dec -> u4_start_recon_deblk = 0 ; } } ih264d_signal_decode_thread ( ps_dec ) ; if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } } DATA_SYNC ( ) ; if ( ( ps_dec_op -> u4_error_code & 0xff ) != ERROR_DYNAMIC_RESOLUTION_NOT_SUPPORTED ) { ps_dec_op -> u4_pic_wd = ( UWORD32 ) ps_dec -> u2_disp_width ; ps_dec_op -> u4_pic_ht = ( UWORD32 ) ps_dec -> u2_disp_height ; } if ( ps_dec -> i4_header_decoded != 3 ) { ps_dec_op -> u4_error_code |= ( 1 << IVD_INSUFFICIENTDATA ) ; } if ( ps_dec -> i4_decode_header == 1 && ps_dec -> i4_header_decoded != 3 ) { ps_dec_op -> u4_error_code |= ( 1 << IVD_INSUFFICIENTDATA ) ; } if ( ps_dec -> u4_prev_nal_skipped ) { ps_dec_op -> u4_error_code = IVD_DEC_FRM_SKIPPED ; ps_dec_op -> u4_error_code |= ( 1 << IVD_UNSUPPORTEDPARAM ) ; ps_dec_op -> u4_frame_decoded_flag = 0 ; ps_dec_op -> u4_size = sizeof ( ivd_video_decode_op_t ) ; if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } return ( IV_FAIL ) ; } if ( ( ps_dec -> u4_pic_buf_got == 1 ) && ( ERROR_DANGLING_FIELD_IN_PIC != i4_err_status ) ) { if ( ps_dec -> ps_cur_slice -> u1_field_pic_flag ) { if ( 1 == ps_dec -> ps_cur_slice -> u1_bottom_field_flag ) { ps_dec -> u1_top_bottom_decoded |= BOT_FIELD_ONLY ; } else { ps_dec -> u1_top_bottom_decoded |= TOP_FIELD_ONLY ; } } else { ps_dec -> u1_top_bottom_decoded = TOP_FIELD_ONLY | BOT_FIELD_ONLY ; } if ( ( ps_dec -> ps_dec_err_status -> u1_err_flag & REJECT_CUR_PIC ) == 0 ) { ret = ih264d_deblock_display ( ps_dec ) ; } if ( ps_dec -> i4_header_decoded == 3 ) { ps_dec -> u2_total_mbs_coded = ps_dec -> ps_cur_sps -> u2_max_mb_addr + 1 ; } if ( ps_dec -> ps_cur_slice -> u1_nal_unit_type == IDR_SLICE_NAL ) { ps_dec -> i4_frametype = IV_IDR_FRAME ; } else if ( ps_dec -> i4_pic_type == B_SLICE ) { ps_dec -> i4_frametype = IV_B_FRAME ; } else if ( ps_dec -> i4_pic_type == P_SLICE ) { ps_dec -> i4_frametype = IV_P_FRAME ; } else if ( ps_dec -> i4_pic_type == I_SLICE ) { ps_dec -> i4_frametype = IV_I_FRAME ; } else { H264_DEC_DEBUG_PRINT ( "Shouldn\'t<S2SV_blank>come<S2SV_blank>here\\n" ) ; } ps_dec -> i4_content_type = ps_dec -> ps_cur_slice -> u1_field_pic_flag ; ps_dec -> u4_total_frames_decoded = ps_dec -> u4_total_frames_decoded + 2 ; ps_dec -> u4_total_frames_decoded = ps_dec -> u4_total_frames_decoded - ps_dec -> ps_cur_slice -> u1_field_pic_flag ; } if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } { if ( ( IVD_DECODE_FRAME_OUT == ps_dec -> e_frm_out_mode ) && ps_dec -> u1_init_dec_flag ) { ih264d_get_next_display_field ( ps_dec , ps_dec -> ps_out_buffer , & ( ps_dec -> s_disp_op ) ) ; if ( 0 == ps_dec -> s_disp_op . u4_error_code ) { ps_dec -> u4_fmt_conv_cur_row = 0 ; ps_dec -> u4_output_present = 1 ; } } ih264d_fill_output_struct_from_context ( ps_dec , ps_dec_op ) ; if ( ps_dec -> u4_output_present && ( ps_dec -> u4_fmt_conv_cur_row < ps_dec -> s_disp_frame_info . u4_y_ht ) ) { ps_dec -> u4_fmt_conv_num_rows = ps_dec -> s_disp_frame_info . u4_y_ht - ps_dec -> u4_fmt_conv_cur_row ; ih264d_format_convert ( ps_dec , & ( ps_dec -> s_disp_op ) , ps_dec -> u4_fmt_conv_cur_row , ps_dec -> u4_fmt_conv_num_rows ) ; ps_dec -> u4_fmt_conv_cur_row += ps_dec -> u4_fmt_conv_num_rows ; } ih264d_release_display_field ( ps_dec , & ( ps_dec -> s_disp_op ) ) ; } if ( ps_dec -> i4_decode_header == 1 && ( ps_dec -> i4_header_decoded & 1 ) == 1 ) { ps_dec_op -> u4_progressive_frame_flag = 1 ; if ( ( NULL != ps_dec -> ps_cur_sps ) && ( 1 == ( ps_dec -> ps_cur_sps -> u1_is_valid ) ) ) { if ( ( 0 == ps_dec -> ps_sps -> u1_frame_mbs_only_flag ) && ( 0 == ps_dec -> ps_sps -> u1_mb_aff_flag ) ) ps_dec_op -> u4_progressive_frame_flag = 0 ; } } if ( ( TOP_FIELD_ONLY | BOT_FIELD_ONLY ) == ps_dec -> u1_top_bottom_decoded ) { ps_dec -> u1_top_bottom_decoded = 0 ; } if ( ps_dec -> u4_pic_buf_got == 1 ) { if ( 1 == ps_dec -> u1_last_pic_not_decoded ) { ret = ih264d_end_of_pic_dispbuf_mgr ( ps_dec ) ; if ( ret != OK ) return ret ; ret = ih264d_end_of_pic ( ps_dec ) ; if ( ret != OK ) return ret ; } else { ret = ih264d_end_of_pic ( ps_dec ) ; if ( ret != OK ) return ret ; } } DATA_SYNC ( ) ; H264_DEC_DEBUG_PRINT ( "The<S2SV_blank>num<S2SV_blank>bytes<S2SV_blank>consumed:<S2SV_blank>%d\\n" , ps_dec_op -> u4_num_bytes_consumed ) ; return api_ret_value ; }
CWE-200 WORD32 ih264d_parse_sei_message ( dec_struct_t * ps_dec , dec_bit_stream_t * ps_bitstrm ) { UWORD32 ui4_payload_type , ui4_payload_size ; UWORD32 u4_bits ; WORD32 i4_status = 0 ; do { ui4_payload_type = 0 ; u4_bits = ih264d_get_bits_h264 ( ps_bitstrm , 8 ) ; <S2SV_StartBug> while ( 0xff == u4_bits ) <S2SV_EndBug> { u4_bits = ih264d_get_bits_h264 ( ps_bitstrm , 8 ) ; ui4_payload_type += 255 ; } ui4_payload_type += u4_bits ; ui4_payload_size = 0 ; u4_bits = ih264d_get_bits_h264 ( ps_bitstrm , 8 ) ; <S2SV_StartBug> while ( 0xff == u4_bits ) <S2SV_EndBug> { u4_bits = ih264d_get_bits_h264 ( ps_bitstrm , 8 ) ; ui4_payload_size += 255 ; } ui4_payload_size += u4_bits ; i4_status = ih264d_parse_sei_payload ( ps_bitstrm , ui4_payload_type , ui4_payload_size , ps_dec ) ; if ( i4_status == - 1 ) { i4_status = 0 ; break ; } if ( i4_status != OK ) return i4_status ; if ( ih264d_check_byte_aligned ( ps_bitstrm ) == 0 ) { u4_bits = ih264d_get_bit_h264 ( ps_bitstrm ) ; if ( 0 == u4_bits ) { H264_DEC_DEBUG_PRINT ( "\\nError<S2SV_blank>in<S2SV_blank>parsing<S2SV_blank>SEI<S2SV_blank>message" ) ; } <S2SV_StartBug> while ( 0 == ih264d_check_byte_aligned ( ps_bitstrm ) ) <S2SV_EndBug> { u4_bits = ih264d_get_bit_h264 ( ps_bitstrm ) ; if ( u4_bits ) { H264_DEC_DEBUG_PRINT ( "\\nError<S2SV_blank>in<S2SV_blank>parsing<S2SV_blank>SEI<S2SV_blank>message" ) ; } } } } while ( ps_bitstrm -> u4_ofst < ps_bitstrm -> u4_max_ofst ) ; return ( i4_status ) ; }
CWE-200 IHEVCD_ERROR_T ihevcd_parse_slice_data ( codec_t * ps_codec ) { IHEVCD_ERROR_T ret = ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ; WORD32 end_of_slice_flag = 0 ; sps_t * ps_sps ; pps_t * ps_pps ; slice_header_t * ps_slice_hdr ; WORD32 end_of_pic ; tile_t * ps_tile , * ps_tile_prev ; WORD32 i ; WORD32 ctb_addr ; WORD32 tile_idx ; WORD32 cabac_init_idc ; WORD32 ctb_size ; WORD32 num_ctb_in_row ; WORD32 num_min4x4_in_ctb ; WORD32 slice_qp ; WORD32 slice_start_ctb_idx ; WORD32 tile_start_ctb_idx ; ps_slice_hdr = ps_codec -> s_parse . ps_slice_hdr_base ; ps_pps = ps_codec -> s_parse . ps_pps_base ; ps_sps = ps_codec -> s_parse . ps_sps_base ; ps_slice_hdr += ( ps_codec -> s_parse . i4_cur_slice_idx & ( MAX_SLICE_HDR_CNT - 1 ) ) ; ps_pps += ps_slice_hdr -> i1_pps_id ; ps_sps += ps_pps -> i1_sps_id ; if ( 0 != ps_codec -> s_parse . i4_cur_slice_idx ) { if ( ! ps_slice_hdr -> i1_dependent_slice_flag ) { ps_codec -> s_parse . i4_cur_independent_slice_idx ++ ; if ( MAX_SLICE_HDR_CNT == ps_codec -> s_parse . i4_cur_independent_slice_idx ) ps_codec -> s_parse . i4_cur_independent_slice_idx = 0 ; } } ctb_size = 1 << ps_sps -> i1_log2_ctb_size ; num_min4x4_in_ctb = ( ctb_size / 4 ) * ( ctb_size / 4 ) ; num_ctb_in_row = ps_sps -> i2_pic_wd_in_ctb ; if ( 0 == ps_codec -> i4_slice_error ) { ps_codec -> s_parse . i4_ctb_x = ps_slice_hdr -> i2_ctb_x ; ps_codec -> s_parse . i4_ctb_y = ps_slice_hdr -> i2_ctb_y ; } ps_codec -> s_parse . ps_pps = ps_pps ; ps_codec -> s_parse . ps_sps = ps_sps ; ps_codec -> s_parse . ps_slice_hdr = ps_slice_hdr ; ihevcd_get_tile_pos ( ps_pps , ps_sps , ps_codec -> s_parse . i4_ctb_x , ps_codec -> s_parse . i4_ctb_y , & ps_codec -> s_parse . i4_ctb_tile_x , & ps_codec -> s_parse . i4_ctb_tile_y , & tile_idx ) ; ps_codec -> s_parse . ps_tile = ps_pps -> ps_tile + tile_idx ; ps_codec -> s_parse . i4_cur_tile_idx = tile_idx ; ps_tile = ps_codec -> s_parse . ps_tile ; if ( tile_idx ) ps_tile_prev = ps_tile - 1 ; else ps_tile_prev = ps_tile ; if ( 0 == ps_codec -> i4_slice_error ) { if ( 1 == ps_slice_hdr -> i1_dependent_slice_flag ) { if ( ( 0 == ps_codec -> s_parse . i4_ctb_tile_x ) && ( 0 == ps_codec -> s_parse . i4_ctb_tile_y ) ) { ps_codec -> s_parse . i4_ctb_slice_x = 0 ; ps_codec -> s_parse . i4_ctb_slice_y = 0 ; } } if ( ! ps_slice_hdr -> i1_dependent_slice_flag ) { ps_codec -> s_parse . i4_ctb_slice_x = 0 ; ps_codec -> s_parse . i4_ctb_slice_y = 0 ; } } if ( ( 0 == ps_codec -> s_parse . i4_ctb_y ) && ( 0 == ps_codec -> s_parse . i4_ctb_x ) ) { ret = ihevcd_parse_pic_init ( ps_codec ) ; RETURN_IF ( ( ret != ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ) , ret ) ; ps_codec -> s_parse . pu4_pic_tu_idx [ 0 ] = 0 ; ps_codec -> s_parse . pu4_pic_pu_idx [ 0 ] = 0 ; ps_codec -> s_parse . i4_cur_independent_slice_idx = 0 ; ps_codec -> s_parse . i4_ctb_tile_x = 0 ; ps_codec -> s_parse . i4_ctb_tile_y = 0 ; } { mv_buf_t * ps_mv_buf = ps_codec -> s_parse . ps_cur_mv_buf ; if ( ps_slice_hdr -> i1_num_ref_idx_l1_active != 0 ) { for ( i = 0 ; i < ps_slice_hdr -> i1_num_ref_idx_l1_active ; i ++ ) { ps_mv_buf -> l1_collocated_poc [ ( ps_codec -> s_parse . i4_cur_slice_idx & ( MAX_SLICE_HDR_CNT - 1 ) ) ] [ i ] = ( ( pic_buf_t * ) ps_slice_hdr -> as_ref_pic_list1 [ i ] . pv_pic_buf ) -> i4_abs_poc ; ps_mv_buf -> u1_l1_collocated_poc_lt [ ( ps_codec -> s_parse . i4_cur_slice_idx & ( MAX_SLICE_HDR_CNT - 1 ) ) ] [ i ] = ( ( pic_buf_t * ) ps_slice_hdr -> as_ref_pic_list1 [ i ] . pv_pic_buf ) -> u1_used_as_ref ; } } if ( ps_slice_hdr -> i1_num_ref_idx_l0_active != 0 ) { for ( i = 0 ; i < ps_slice_hdr -> i1_num_ref_idx_l0_active ; i ++ ) { ps_mv_buf -> l0_collocated_poc [ ( ps_codec -> s_parse . i4_cur_slice_idx & ( MAX_SLICE_HDR_CNT - 1 ) ) ] [ i ] = ( ( pic_buf_t * ) ps_slice_hdr -> as_ref_pic_list0 [ i ] . pv_pic_buf ) -> i4_abs_poc ; ps_mv_buf -> u1_l0_collocated_poc_lt [ ( ps_codec -> s_parse . i4_cur_slice_idx & ( MAX_SLICE_HDR_CNT - 1 ) ) ] [ i ] = ( ( pic_buf_t * ) ps_slice_hdr -> as_ref_pic_list0 [ i ] . pv_pic_buf ) -> u1_used_as_ref ; } } } if ( ( 0 == ps_codec -> s_parse . i4_ctb_slice_x ) || ( 0 == ps_codec -> s_parse . i4_ctb_slice_y ) ) { WORD32 cur_poc , ref_list_poc , flag = 1 ; cur_poc = ps_slice_hdr -> i4_abs_pic_order_cnt ; for ( i = 0 ; i < ps_slice_hdr -> i1_num_ref_idx_l0_active ; i ++ ) { ref_list_poc = ( ( mv_buf_t * ) ps_slice_hdr -> as_ref_pic_list0 [ i ] . pv_mv_buf ) -> i4_abs_poc ; if ( ref_list_poc > cur_poc ) { flag = 0 ; break ; } } if ( flag && ( ps_slice_hdr -> i1_slice_type == BSLICE ) ) { for ( i = 0 ; i < ps_slice_hdr -> i1_num_ref_idx_l1_active ; i ++ ) { ref_list_poc = ( ( mv_buf_t * ) ps_slice_hdr -> as_ref_pic_list1 [ i ] . pv_mv_buf ) -> i4_abs_poc ; if ( ref_list_poc > cur_poc ) { flag = 0 ; break ; } } } ps_slice_hdr -> i1_low_delay_flag = flag ; } if ( ps_slice_hdr -> i1_slice_type == ISLICE ) { cabac_init_idc = 0 ; } else if ( ps_slice_hdr -> i1_slice_type == PSLICE ) { cabac_init_idc = ps_slice_hdr -> i1_cabac_init_flag ? 2 : 1 ; } else { cabac_init_idc = ps_slice_hdr -> i1_cabac_init_flag ? 1 : 2 ; } slice_qp = ps_slice_hdr -> i1_slice_qp_delta + ps_pps -> i1_pic_init_qp ; slice_qp = CLIP3 ( slice_qp , 0 , 51 ) ; if ( ( 0 == ps_slice_hdr -> i1_dependent_slice_flag ) || ( ( 1 == ps_slice_hdr -> i1_dependent_slice_flag ) && ( ( 0 == ps_codec -> s_parse . i4_ctb_tile_x ) && ( 0 == ps_codec -> s_parse . i4_ctb_tile_y ) ) ) ) { ps_codec -> s_parse . u4_qp = slice_qp ; } if ( ( 1 == ps_slice_hdr -> i1_dependent_slice_flag ) && ( ! ( ( ps_codec -> s_parse . i4_ctb_tile_x == 0 ) && ( ps_codec -> s_parse . i4_ctb_tile_y == 0 ) ) ) ) { if ( ( 0 == ps_pps -> i1_entropy_coding_sync_enabled_flag ) || ( ps_pps -> i1_entropy_coding_sync_enabled_flag && ( 0 != ps_codec -> s_parse . i4_ctb_x ) ) ) { ihevcd_cabac_reset ( & ps_codec -> s_parse . s_cabac , & ps_codec -> s_parse . s_bitstrm ) ; } } else if ( ( 0 == ps_pps -> i1_entropy_coding_sync_enabled_flag ) || ( ps_pps -> i1_entropy_coding_sync_enabled_flag && ( 0 != ps_codec -> s_parse . i4_ctb_x ) ) ) { ret = ihevcd_cabac_init ( & ps_codec -> s_parse . s_cabac , & ps_codec -> s_parse . s_bitstrm , slice_qp , cabac_init_idc , & gau1_ihevc_cab_ctxts [ cabac_init_idc ] [ slice_qp ] [ 0 ] ) ; if ( ret != ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ) { ps_codec -> i4_slice_error = 1 ; end_of_slice_flag = 1 ; ret = ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ; } } do { { WORD32 cur_ctb_idx = ps_codec -> s_parse . i4_ctb_x + ps_codec -> s_parse . i4_ctb_y * ( ps_sps -> i2_pic_wd_in_ctb ) ; if ( 1 == ps_codec -> i4_num_cores && 0 == cur_ctb_idx % RESET_TU_BUF_NCTB ) { ps_codec -> s_parse . ps_tu = ps_codec -> s_parse . ps_pic_tu ; ps_codec -> s_parse . i4_pic_tu_idx = 0 ; } } end_of_pic = 0 ; ps_codec -> s_parse . i4_ctb_num_pcm_blks = 0 ; if ( ( ( 0 == ps_codec -> s_parse . i4_ctb_tile_x ) && ( 0 == ps_codec -> s_parse . i4_ctb_tile_y ) ) && ( ! ( ( ps_tile -> u1_pos_x == 0 ) && ( ps_tile -> u1_pos_y == 0 ) ) ) && ( ! ( ( 0 == ps_codec -> s_parse . i4_ctb_slice_x ) && ( 0 == ps_codec -> s_parse . i4_ctb_slice_y ) ) ) ) { slice_qp = ps_slice_hdr -> i1_slice_qp_delta + ps_pps -> i1_pic_init_qp ; slice_qp = CLIP3 ( slice_qp , 0 , 51 ) ; ps_codec -> s_parse . u4_qp = slice_qp ; ihevcd_get_tile_pos ( ps_pps , ps_sps , ps_codec -> s_parse . i4_ctb_x , ps_codec -> s_parse . i4_ctb_y , & ps_codec -> s_parse . i4_ctb_tile_x , & ps_codec -> s_parse . i4_ctb_tile_y , & tile_idx ) ; ps_codec -> s_parse . ps_tile = ps_pps -> ps_tile + tile_idx ; ps_codec -> s_parse . i4_cur_tile_idx = tile_idx ; ps_tile_prev = ps_tile - 1 ; tile_start_ctb_idx = ps_tile -> u1_pos_x + ps_tile -> u1_pos_y * ( ps_sps -> i2_pic_wd_in_ctb ) ; slice_start_ctb_idx = ps_slice_hdr -> i2_ctb_x + ps_slice_hdr -> i2_ctb_y * ( ps_sps -> i2_pic_wd_in_ctb ) ; if ( slice_start_ctb_idx < tile_start_ctb_idx ) { ps_codec -> s_parse . i4_ctb_slice_y = ps_tile -> u1_pos_y - ps_slice_hdr -> i2_ctb_y ; if ( ! ( ( ( ps_slice_hdr -> i2_ctb_x + ps_tile_prev -> u2_wd ) % ps_sps -> i2_pic_wd_in_ctb ) == ps_tile -> u1_pos_x ) ) { if ( ps_slice_hdr -> i2_ctb_y <= ps_tile -> u1_pos_y ) { if ( ps_slice_hdr -> i2_ctb_x > ps_tile -> u1_pos_x ) { ps_codec -> s_parse . i4_ctb_slice_y -= 1 ; } } } } if ( ! ps_slice_hdr -> i1_dependent_slice_flag ) { ret = ihevcd_cabac_init ( & ps_codec -> s_parse . s_cabac , & ps_codec -> s_parse . s_bitstrm , slice_qp , cabac_init_idc , & gau1_ihevc_cab_ctxts [ cabac_init_idc ] [ slice_qp ] [ 0 ] ) ; if ( ret != ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ) { ps_codec -> i4_slice_error = 1 ; end_of_slice_flag = 1 ; ret = ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ; } } } if ( 0 == ps_codec -> s_parse . i4_ctb_tile_x ) { if ( 1 < ps_codec -> i4_num_cores ) { proc_job_t s_job ; IHEVCD_ERROR_T ret ; s_job . i4_cmd = CMD_PROCESS ; s_job . i2_ctb_cnt = ( WORD16 ) ps_tile -> u2_wd ; s_job . i2_ctb_x = ( WORD16 ) ps_codec -> s_parse . i4_ctb_x ; s_job . i2_ctb_y = ( WORD16 ) ps_codec -> s_parse . i4_ctb_y ; s_job . i2_slice_idx = ( WORD16 ) ps_codec -> s_parse . i4_cur_slice_idx ; s_job . i4_tu_coeff_data_ofst = ( UWORD8 * ) ps_codec -> s_parse . pv_tu_coeff_data - ( UWORD8 * ) ps_codec -> s_parse . pv_pic_tu_coeff_data ; ret = ihevcd_jobq_queue ( ( jobq_t * ) ps_codec -> s_parse . pv_proc_jobq , & s_job , sizeof ( proc_job_t ) , 1 ) ; if ( ret != ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ) return ret ; } else { process_ctxt_t * ps_proc = & ps_codec -> as_process [ 0 ] ; WORD32 tu_coeff_data_ofst = ( UWORD8 * ) ps_codec -> s_parse . pv_tu_coeff_data - ( UWORD8 * ) ps_codec -> s_parse . pv_pic_tu_coeff_data ; ps_proc -> i4_ctb_cnt = ps_tile -> u2_wd ; ps_proc -> i4_ctb_x = ps_codec -> s_parse . i4_ctb_x ; ps_proc -> i4_ctb_y = ps_codec -> s_parse . i4_ctb_y ; ps_proc -> i4_cur_slice_idx = ps_codec -> s_parse . i4_cur_slice_idx ; ihevcd_init_proc_ctxt ( ps_proc , tu_coeff_data_ofst ) ; } } if ( ps_pps -> i1_entropy_coding_sync_enabled_flag ) { if ( 0 == ps_codec -> s_parse . i4_ctb_x ) { WORD32 default_ctxt = 0 ; if ( ( 0 == ps_codec -> s_parse . i4_ctb_slice_y ) && ( ! ps_slice_hdr -> i1_dependent_slice_flag ) ) default_ctxt = 1 ; if ( 1 == ps_sps -> i2_pic_wd_in_ctb ) default_ctxt = 1 ; ps_codec -> s_parse . u4_qp = slice_qp ; if ( default_ctxt ) { ret = ihevcd_cabac_init ( & ps_codec -> s_parse . s_cabac , & ps_codec -> s_parse . s_bitstrm , slice_qp , cabac_init_idc , & gau1_ihevc_cab_ctxts [ cabac_init_idc ] [ slice_qp ] [ 0 ] ) ; if ( ret != ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ) { ps_codec -> i4_slice_error = 1 ; end_of_slice_flag = 1 ; ret = ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ; } } else { ret = ihevcd_cabac_init ( & ps_codec -> s_parse . s_cabac , & ps_codec -> s_parse . s_bitstrm , slice_qp , cabac_init_idc , ( const UWORD8 * ) & ps_codec -> s_parse . s_cabac . au1_ctxt_models_sync ) ; if ( ret != ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ) { ps_codec -> i4_slice_error = 1 ; end_of_slice_flag = 1 ; ret = ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ; } } } } if ( 0 == ps_codec -> i4_slice_error ) { if ( ps_slice_hdr -> i1_slice_sao_luma_flag || ps_slice_hdr -> i1_slice_sao_chroma_flag ) ihevcd_parse_sao ( ps_codec ) ; } else { sao_t * ps_sao = ps_codec -> s_parse . ps_pic_sao + ps_codec -> s_parse . i4_ctb_x + ps_codec -> s_parse . i4_ctb_y * ps_sps -> i2_pic_wd_in_ctb ; ps_sao -> b3_y_type_idx = 0 ; ps_sao -> b3_cb_type_idx = 0 ; ps_sao -> b3_cr_type_idx = 0 ; } { WORD32 ctb_indx ; ctb_indx = ps_codec -> s_parse . i4_ctb_x + ps_sps -> i2_pic_wd_in_ctb * ps_codec -> s_parse . i4_ctb_y ; ps_codec -> s_parse . s_bs_ctxt . pu1_pic_qp_const_in_ctb [ ctb_indx >> 3 ] |= ( 1 << ( ctb_indx & 7 ) ) ; { UWORD16 * pu1_slice_idx = ps_codec -> s_parse . pu1_slice_idx ; pu1_slice_idx [ ctb_indx ] = ps_codec -> s_parse . i4_cur_independent_slice_idx ; } } if ( 0 == ps_codec -> i4_slice_error ) { tu_t * ps_tu = ps_codec -> s_parse . ps_tu ; WORD32 i4_tu_cnt = ps_codec -> s_parse . s_cu . i4_tu_cnt ; WORD32 i4_pic_tu_idx = ps_codec -> s_parse . i4_pic_tu_idx ; pu_t * ps_pu = ps_codec -> s_parse . ps_pu ; WORD32 i4_pic_pu_idx = ps_codec -> s_parse . i4_pic_pu_idx ; UWORD8 * pu1_tu_coeff_data = ( UWORD8 * ) ps_codec -> s_parse . pv_tu_coeff_data ; ret = ihevcd_parse_coding_quadtree ( ps_codec , ( ps_codec -> s_parse . i4_ctb_x << ps_sps -> i1_log2_ctb_size ) , ( ps_codec -> s_parse . i4_ctb_y << ps_sps -> i1_log2_ctb_size ) , ps_sps -> i1_log2_ctb_size , 0 ) ; if ( ret != ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ) { <S2SV_StartBug> WORD32 pu_skip_wd , pu_skip_ht ; <S2SV_EndBug> WORD32 rows_remaining , cols_remaining ; WORD32 tu_coeff_data_reset_size ; rows_remaining = ps_sps -> i2_pic_height_in_luma_samples - ( ps_codec -> s_parse . i4_ctb_y << ps_sps -> i1_log2_ctb_size ) ; pu_skip_ht = MIN ( ctb_size , rows_remaining ) ; cols_remaining = ps_sps -> i2_pic_width_in_luma_samples - ( ps_codec -> s_parse . i4_ctb_x << ps_sps -> i1_log2_ctb_size ) ; pu_skip_wd = MIN ( ctb_size , cols_remaining ) ; ps_codec -> s_parse . ps_tu = ps_tu ; ps_codec -> s_parse . s_cu . i4_tu_cnt = i4_tu_cnt ; ps_codec -> s_parse . i4_pic_tu_idx = i4_pic_tu_idx ; ps_codec -> s_parse . ps_pu = ps_pu ; <S2SV_StartBug> ps_codec -> s_parse . i4_pic_pu_idx = i4_pic_pu_idx ; <S2SV_EndBug> ps_tu -> b1_cb_cbf = 0 ; ps_tu -> b1_cr_cbf = 0 ; ps_tu -> b1_y_cbf = 0 ; ps_tu -> b4_pos_x = 0 ; ps_tu -> b4_pos_y = 0 ; ps_tu -> b1_transquant_bypass = 0 ; ps_tu -> b3_size = ( ps_sps -> i1_log2_ctb_size - 2 ) ; ps_tu -> b7_qp = ps_codec -> s_parse . u4_qp ; ps_tu -> b3_chroma_intra_mode_idx = INTRA_PRED_CHROMA_IDX_NONE ; ps_tu -> b6_luma_intra_mode = INTRA_PRED_NONE ; ps_tu -> b1_first_tu_in_cu = 1 ; tu_coeff_data_reset_size = ( UWORD8 * ) ps_codec -> s_parse . pv_tu_coeff_data - pu1_tu_coeff_data ; memset ( pu1_tu_coeff_data , 0 , tu_coeff_data_reset_size ) ; ps_codec -> s_parse . pv_tu_coeff_data = ( void * ) pu1_tu_coeff_data ; <S2SV_StartBug> ps_codec -> s_parse . ps_tu ++ ; <S2SV_EndBug> ps_codec -> s_parse . s_cu . i4_tu_cnt ++ ; ps_codec -> s_parse . i4_pic_tu_idx ++ ; ps_codec -> s_parse . s_cu . i4_pred_mode = PRED_MODE_SKIP ; ps_codec -> s_parse . s_cu . i4_part_mode = PART_2Nx2N ; ps_pu -> b2_part_idx = 0 ; ps_pu -> b4_pos_x = 0 ; ps_pu -> b4_pos_y = 0 ; ps_pu -> b4_wd = ( pu_skip_wd >> 2 ) - 1 ; ps_pu -> b4_ht = ( pu_skip_ht >> 2 ) - 1 ; ps_pu -> b1_intra_flag = 0 ; ps_pu -> b3_part_mode = ps_codec -> s_parse . s_cu . i4_part_mode ; ps_pu -> b1_merge_flag = 1 ; ps_pu -> b3_merge_idx = 0 ; ps_codec -> s_parse . ps_pu ++ ; ps_codec -> s_parse . i4_pic_pu_idx ++ ; ps_codec -> i4_slice_error = 1 ; end_of_slice_flag = 1 ; ret = ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ; } } else { <S2SV_StartBug> tu_t * ps_tu = ps_codec -> s_parse . ps_tu ; <S2SV_EndBug> pu_t * ps_pu = ps_codec -> s_parse . ps_pu ; WORD32 pu_skip_wd , pu_skip_ht ; WORD32 rows_remaining , cols_remaining ; rows_remaining = ps_sps -> i2_pic_height_in_luma_samples - ( ps_codec -> s_parse . i4_ctb_y << ps_sps -> i1_log2_ctb_size ) ; pu_skip_ht = MIN ( ctb_size , rows_remaining ) ; cols_remaining = ps_sps -> i2_pic_width_in_luma_samples - ( ps_codec -> s_parse . i4_ctb_x << ps_sps -> i1_log2_ctb_size ) ; pu_skip_wd = MIN ( ctb_size , cols_remaining ) ; ps_tu -> b1_cb_cbf = 0 ; ps_tu -> b1_cr_cbf = 0 ; ps_tu -> b1_y_cbf = 0 ; ps_tu -> b4_pos_x = 0 ; ps_tu -> b4_pos_y = 0 ; ps_tu -> b1_transquant_bypass = 0 ; ps_tu -> b3_size = ( ps_sps -> i1_log2_ctb_size - 2 ) ; ps_tu -> b7_qp = ps_codec -> s_parse . u4_qp ; ps_tu -> b3_chroma_intra_mode_idx = INTRA_PRED_CHROMA_IDX_NONE ; ps_tu -> b6_luma_intra_mode = INTRA_PRED_NONE ; ps_tu -> b1_first_tu_in_cu = 1 ; ps_codec -> s_parse . ps_tu ++ ; ps_codec -> s_parse . s_cu . i4_tu_cnt ++ ; ps_codec -> s_parse . i4_pic_tu_idx ++ ; ps_codec -> s_parse . s_cu . i4_pred_mode = PRED_MODE_SKIP ; ps_codec -> s_parse . s_cu . i4_part_mode = PART_2Nx2N ; ps_pu -> b2_part_idx = 0 ; ps_pu -> b4_pos_x = 0 ; ps_pu -> b4_pos_y = 0 ; ps_pu -> b4_wd = ( pu_skip_wd >> 2 ) - 1 ; ps_pu -> b4_ht = ( pu_skip_ht >> 2 ) - 1 ; ps_pu -> b1_intra_flag = 0 ; ps_pu -> b3_part_mode = ps_codec -> s_parse . s_cu . i4_part_mode ; ps_pu -> b1_merge_flag = 1 ; ps_pu -> b3_merge_idx = 0 ; ps_codec -> s_parse . ps_pu ++ ; ps_codec -> s_parse . i4_pic_pu_idx ++ ; } if ( 0 == ps_codec -> i4_slice_error ) end_of_slice_flag = ihevcd_cabac_decode_terminate ( & ps_codec -> s_parse . s_cabac , & ps_codec -> s_parse . s_bitstrm ) ; AEV_TRACE ( "end_of_slice_flag" , end_of_slice_flag , ps_codec -> s_parse . s_cabac . u4_range ) ; if ( ps_pps -> i1_tiles_enabled_flag || ps_pps -> i1_entropy_coding_sync_enabled_flag ) { WORD32 end_of_tile = 0 ; WORD32 end_of_tile_row = 0 ; if ( ps_pps -> i1_entropy_coding_sync_enabled_flag || ps_pps -> i1_tiles_enabled_flag ) { if ( 1 == ps_codec -> s_parse . i4_ctb_x ) { WORD32 size = sizeof ( ps_codec -> s_parse . s_cabac . au1_ctxt_models ) ; memcpy ( & ps_codec -> s_parse . s_cabac . au1_ctxt_models_sync , & ps_codec -> s_parse . s_cabac . au1_ctxt_models , size ) ; } } if ( ( ps_codec -> s_parse . i4_ctb_tile_x + 1 ) == ( ps_tile -> u2_wd ) ) { end_of_tile_row = 1 ; if ( ( ps_codec -> s_parse . i4_ctb_tile_y + 1 ) == ps_tile -> u2_ht ) end_of_tile = 1 ; } if ( ( 0 == end_of_slice_flag ) && ( ( ps_pps -> i1_tiles_enabled_flag && end_of_tile ) || ( ps_pps -> i1_entropy_coding_sync_enabled_flag && end_of_tile_row ) ) ) { WORD32 end_of_sub_stream_one_bit ; end_of_sub_stream_one_bit = ihevcd_cabac_decode_terminate ( & ps_codec -> s_parse . s_cabac , & ps_codec -> s_parse . s_bitstrm ) ; AEV_TRACE ( "end_of_sub_stream_one_bit" , end_of_sub_stream_one_bit , ps_codec -> s_parse . s_cabac . u4_range ) ; if ( ps_codec -> s_parse . s_bitstrm . u4_bit_ofst % 8 ) ihevcd_bits_flush_to_byte_boundary ( & ps_codec -> s_parse . s_bitstrm ) ; UNUSED ( end_of_sub_stream_one_bit ) ; } } { WORD32 ctb_indx ; ctb_addr = ps_codec -> s_parse . i4_ctb_y * num_ctb_in_row + ps_codec -> s_parse . i4_ctb_x ; ctb_indx = ++ ctb_addr ; if ( ( ps_tile -> u2_wd == ( ps_codec -> s_parse . i4_ctb_tile_x + 1 ) ) && ( ps_tile -> u2_wd != ps_sps -> i2_pic_wd_in_ctb ) ) { ctb_indx = ( ps_sps -> i2_pic_wd_in_ctb * ( ps_codec -> s_parse . i4_ctb_tile_y + 1 + ps_tile -> u1_pos_y ) ) + ps_tile -> u1_pos_x ; if ( ps_tile -> u2_ht == ( ps_codec -> s_parse . i4_ctb_tile_y + 1 ) ) { if ( ( ps_tile -> u2_wd + ps_tile -> u1_pos_x == ps_sps -> i2_pic_wd_in_ctb ) && ( ( ps_tile -> u2_ht + ps_tile -> u1_pos_y == ps_sps -> i2_pic_ht_in_ctb ) ) ) { ctb_indx = ctb_addr ; } else { tile_t * ps_next_tile = ps_codec -> s_parse . ps_tile + 1 ; ctb_indx = ps_next_tile -> u1_pos_x + ( ps_next_tile -> u1_pos_y * ps_sps -> i2_pic_wd_in_ctb ) ; } } } ps_codec -> s_parse . pu4_pic_pu_idx [ ctb_indx ] = ps_codec -> s_parse . i4_pic_pu_idx ; ps_codec -> s_parse . i4_next_pu_ctb_cnt = ctb_indx ; ps_codec -> s_parse . pu1_pu_map += num_min4x4_in_ctb ; if ( 1 == ps_codec -> i4_num_cores ) { ctb_indx = ( 0 == ctb_addr % RESET_TU_BUF_NCTB ) ? RESET_TU_BUF_NCTB : ctb_addr % RESET_TU_BUF_NCTB ; if ( ( ps_tile -> u2_wd == ( ps_codec -> s_parse . i4_ctb_tile_x + 1 ) ) && ( ps_tile -> u2_wd != ps_sps -> i2_pic_wd_in_ctb ) ) { ctb_indx = ( ps_sps -> i2_pic_wd_in_ctb * ( ps_codec -> s_parse . i4_ctb_tile_y + 1 + ps_tile -> u1_pos_y ) ) + ps_tile -> u1_pos_x ; if ( ps_tile -> u2_ht == ( ps_codec -> s_parse . i4_ctb_tile_y + 1 ) ) { if ( ( ps_tile -> u2_wd + ps_tile -> u1_pos_x == ps_sps -> i2_pic_wd_in_ctb ) && ( ( ps_tile -> u2_ht + ps_tile -> u1_pos_y == ps_sps -> i2_pic_ht_in_ctb ) ) ) { ctb_indx = ( 0 == ctb_addr % RESET_TU_BUF_NCTB ) ? RESET_TU_BUF_NCTB : ctb_addr % RESET_TU_BUF_NCTB ; } else { tile_t * ps_next_tile = ps_codec -> s_parse . ps_tile + 1 ; ctb_indx = ps_next_tile -> u1_pos_x + ( ps_next_tile -> u1_pos_y * ps_sps -> i2_pic_wd_in_ctb ) ; } } } ps_codec -> s_parse . i4_next_tu_ctb_cnt = ctb_indx ; ps_codec -> s_parse . pu4_pic_tu_idx [ ctb_indx ] = ps_codec -> s_parse . i4_pic_tu_idx ; } else { ctb_indx = ctb_addr ; if ( ( ps_tile -> u2_wd == ( ps_codec -> s_parse . i4_ctb_tile_x + 1 ) ) && ( ps_tile -> u2_wd != ps_sps -> i2_pic_wd_in_ctb ) ) { ctb_indx = ( ps_sps -> i2_pic_wd_in_ctb * ( ps_codec -> s_parse . i4_ctb_tile_y + 1 + ps_tile -> u1_pos_y ) ) + ps_tile -> u1_pos_x ; if ( ps_tile -> u2_ht == ( ps_codec -> s_parse . i4_ctb_tile_y + 1 ) ) { if ( ( ps_tile -> u2_wd + ps_tile -> u1_pos_x == ps_sps -> i2_pic_wd_in_ctb ) && ( ( ps_tile -> u2_ht + ps_tile -> u1_pos_y == ps_sps -> i2_pic_ht_in_ctb ) ) ) { ctb_indx = ctb_addr ; } else { tile_t * ps_next_tile = ps_codec -> s_parse . ps_tile + 1 ; ctb_indx = ps_next_tile -> u1_pos_x + ( ps_next_tile -> u1_pos_y * ps_sps -> i2_pic_wd_in_ctb ) ; } } } ps_codec -> s_parse . i4_next_tu_ctb_cnt = ctb_indx ; ps_codec -> s_parse . pu4_pic_tu_idx [ ctb_indx ] = ps_codec -> s_parse . i4_pic_tu_idx ; } ps_codec -> s_parse . pu1_tu_map += num_min4x4_in_ctb ; } if ( ps_codec -> i4_num_cores <= MV_PRED_NUM_CORES_THRESHOLD ) { WORD8 u1_top_ctb_avail = 1 ; WORD8 u1_left_ctb_avail = 1 ; WORD8 u1_top_lt_ctb_avail = 1 ; WORD8 u1_top_rt_ctb_avail = 1 ; WORD16 i2_wd_in_ctb ; tile_start_ctb_idx = ps_tile -> u1_pos_x + ps_tile -> u1_pos_y * ( ps_sps -> i2_pic_wd_in_ctb ) ; slice_start_ctb_idx = ps_slice_hdr -> i2_ctb_x + ps_slice_hdr -> i2_ctb_y * ( ps_sps -> i2_pic_wd_in_ctb ) ; if ( ( slice_start_ctb_idx < tile_start_ctb_idx ) ) { i2_wd_in_ctb = ps_sps -> i2_pic_wd_in_ctb ; } else { i2_wd_in_ctb = ps_tile -> u2_wd ; } if ( ( 0 == ps_codec -> s_parse . i4_ctb_y ) || ( 0 == ps_codec -> s_parse . i4_ctb_tile_y ) ) { u1_top_ctb_avail = 0 ; u1_top_lt_ctb_avail = 0 ; u1_top_rt_ctb_avail = 0 ; } if ( ( 0 == ps_codec -> s_parse . i4_ctb_x ) || ( 0 == ps_codec -> s_parse . i4_ctb_tile_x ) ) { u1_left_ctb_avail = 0 ; u1_top_lt_ctb_avail = 0 ; if ( ( 0 == ps_codec -> s_parse . i4_ctb_slice_y ) || ( 0 == ps_codec -> s_parse . i4_ctb_tile_y ) ) { u1_top_ctb_avail = 0 ; if ( ( i2_wd_in_ctb - 1 ) != ps_codec -> s_parse . i4_ctb_slice_x ) { u1_top_rt_ctb_avail = 0 ; } } } else if ( ps_codec -> s_parse . i4_ctb_x > 0 ) { if ( ( 0 == ps_codec -> s_parse . i4_ctb_slice_y ) || ( 0 == ps_codec -> s_parse . i4_ctb_tile_y ) ) { u1_top_ctb_avail = 0 ; u1_top_lt_ctb_avail = 0 ; if ( 0 == ps_codec -> s_parse . i4_ctb_slice_x ) { u1_left_ctb_avail = 0 ; } if ( ( i2_wd_in_ctb - 1 ) != ps_codec -> s_parse . i4_ctb_slice_x ) { u1_top_rt_ctb_avail = 0 ; } } else if ( ( 1 == ps_codec -> s_parse . i4_ctb_slice_y ) && ( 0 == ps_codec -> s_parse . i4_ctb_slice_x ) ) { u1_top_lt_ctb_avail = 0 ; } } if ( ( ( ps_sps -> i2_pic_wd_in_ctb - 1 ) == ps_codec -> s_parse . i4_ctb_x ) || ( ( ps_tile -> u2_wd - 1 ) == ps_codec -> s_parse . i4_ctb_tile_x ) ) { u1_top_rt_ctb_avail = 0 ; } if ( PSLICE == ps_slice_hdr -> i1_slice_type || BSLICE == ps_slice_hdr -> i1_slice_type ) { mv_ctxt_t s_mv_ctxt ; process_ctxt_t * ps_proc ; UWORD32 * pu4_ctb_top_pu_idx ; UWORD32 * pu4_ctb_left_pu_idx ; UWORD32 * pu4_ctb_top_left_pu_idx ; WORD32 i4_ctb_pu_cnt ; WORD32 cur_ctb_idx ; WORD32 next_ctb_idx ; WORD32 cur_pu_idx ; ps_proc = & ps_codec -> as_process [ ( ps_codec -> i4_num_cores == 1 ) ? 1 : ( ps_codec -> i4_num_cores - 1 ) ] ; cur_ctb_idx = ps_codec -> s_parse . i4_ctb_x + ps_codec -> s_parse . i4_ctb_y * ( ps_sps -> i2_pic_wd_in_ctb ) ; next_ctb_idx = ps_codec -> s_parse . i4_next_pu_ctb_cnt ; i4_ctb_pu_cnt = ps_codec -> s_parse . pu4_pic_pu_idx [ next_ctb_idx ] - ps_codec -> s_parse . pu4_pic_pu_idx [ cur_ctb_idx ] ; cur_pu_idx = ps_codec -> s_parse . pu4_pic_pu_idx [ cur_ctb_idx ] ; pu4_ctb_top_pu_idx = ps_proc -> pu4_pic_pu_idx_top + ( ps_codec -> s_parse . i4_ctb_x * ctb_size / MIN_PU_SIZE ) ; pu4_ctb_left_pu_idx = ps_proc -> pu4_pic_pu_idx_left ; pu4_ctb_top_left_pu_idx = & ps_proc -> u4_ctb_top_left_pu_idx ; { s_mv_ctxt . ps_pps = ps_pps ; s_mv_ctxt . ps_sps = ps_sps ; s_mv_ctxt . ps_slice_hdr = ps_slice_hdr ; s_mv_ctxt . i4_ctb_x = ps_codec -> s_parse . i4_ctb_x ; s_mv_ctxt . i4_ctb_y = ps_codec -> s_parse . i4_ctb_y ; s_mv_ctxt . ps_pu = & ps_codec -> s_parse . ps_pic_pu [ cur_pu_idx ] ; s_mv_ctxt . ps_pic_pu = ps_codec -> s_parse . ps_pic_pu ; s_mv_ctxt . ps_tile = ps_tile ; s_mv_ctxt . pu4_pic_pu_idx_map = ps_proc -> pu4_pic_pu_idx_map ; s_mv_ctxt . pu4_pic_pu_idx = ps_codec -> s_parse . pu4_pic_pu_idx ; s_mv_ctxt . pu1_pic_pu_map = ps_codec -> s_parse . pu1_pic_pu_map ; s_mv_ctxt . i4_ctb_pu_cnt = i4_ctb_pu_cnt ; s_mv_ctxt . i4_ctb_start_pu_idx = cur_pu_idx ; s_mv_ctxt . u1_top_ctb_avail = u1_top_ctb_avail ; s_mv_ctxt . u1_top_rt_ctb_avail = u1_top_rt_ctb_avail ; s_mv_ctxt . u1_top_lt_ctb_avail = u1_top_lt_ctb_avail ; s_mv_ctxt . u1_left_ctb_avail = u1_left_ctb_avail ; } ihevcd_get_mv_ctb ( & s_mv_ctxt , pu4_ctb_top_pu_idx , pu4_ctb_left_pu_idx , pu4_ctb_top_left_pu_idx ) ; } else { WORD32 num_minpu_in_ctb = ( ctb_size / MIN_PU_SIZE ) * ( ctb_size / MIN_PU_SIZE ) ; UWORD8 * pu1_pic_pu_map_ctb = ps_codec -> s_parse . pu1_pic_pu_map + ( ps_codec -> s_parse . i4_ctb_x + ps_codec -> s_parse . i4_ctb_y * ps_sps -> i2_pic_wd_in_ctb ) * num_minpu_in_ctb ; process_ctxt_t * ps_proc = & ps_codec -> as_process [ ( ps_codec -> i4_num_cores == 1 ) ? 1 : ( ps_codec -> i4_num_cores - 1 ) ] ; WORD32 row , col ; WORD32 pu_cnt ; WORD32 num_pu_per_ctb ; WORD32 cur_ctb_idx ; WORD32 next_ctb_idx ; WORD32 ctb_start_pu_idx ; UWORD32 * pu4_nbr_pu_idx = ps_proc -> pu4_pic_pu_idx_map ; WORD32 nbr_pu_idx_strd = MAX_CTB_SIZE / MIN_PU_SIZE + 2 ; pu_t * ps_pu ; for ( row = 0 ; row < ctb_size / MIN_PU_SIZE ; row ++ ) { for ( col = 0 ; col < ctb_size / MIN_PU_SIZE ; col ++ ) { pu1_pic_pu_map_ctb [ row * ctb_size / MIN_PU_SIZE + col ] = 0 ; } } cur_ctb_idx = ps_codec -> s_parse . i4_ctb_x + ps_codec -> s_parse . i4_ctb_y * ( ps_sps -> i2_pic_wd_in_ctb ) ; next_ctb_idx = ps_codec -> s_parse . i4_next_pu_ctb_cnt ; num_pu_per_ctb = ps_codec -> s_parse . pu4_pic_pu_idx [ next_ctb_idx ] - ps_codec -> s_parse . pu4_pic_pu_idx [ cur_ctb_idx ] ; ctb_start_pu_idx = ps_codec -> s_parse . pu4_pic_pu_idx [ cur_ctb_idx ] ; ps_pu = & ps_codec -> s_parse . ps_pic_pu [ ctb_start_pu_idx ] ; for ( pu_cnt = 0 ; pu_cnt < num_pu_per_ctb ; pu_cnt ++ , ps_pu ++ ) { UWORD32 cur_pu_idx ; WORD32 pu_ht = ( ps_pu -> b4_ht + 1 ) << 2 ; WORD32 pu_wd = ( ps_pu -> b4_wd + 1 ) << 2 ; cur_pu_idx = ctb_start_pu_idx + pu_cnt ; for ( row = 0 ; row < pu_ht / MIN_PU_SIZE ; row ++ ) for ( col = 0 ; col < pu_wd / MIN_PU_SIZE ; col ++ ) pu4_nbr_pu_idx [ ( 1 + ps_pu -> b4_pos_x + col ) + ( 1 + ps_pu -> b4_pos_y + row ) * nbr_pu_idx_strd ] = cur_pu_idx ; } { WORD32 rows_remaining = ps_sps -> i2_pic_height_in_luma_samples - ( ps_codec -> s_parse . i4_ctb_y << ps_sps -> i1_log2_ctb_size ) ; WORD32 ctb_size_left = MIN ( ctb_size , rows_remaining ) ; ps_proc -> u4_ctb_top_left_pu_idx = ps_proc -> pu4_pic_pu_idx_top [ ( ps_codec -> s_parse . i4_ctb_x * ctb_size / MIN_PU_SIZE ) + ctb_size / MIN_PU_SIZE - 1 ] ; for ( i = 0 ; i < ctb_size / MIN_PU_SIZE ; i ++ ) { ps_proc -> pu4_pic_pu_idx_left [ i ] = pu4_nbr_pu_idx [ ( ctb_size / MIN_PU_SIZE ) + ( i + 1 ) * nbr_pu_idx_strd ] ; ps_proc -> pu4_pic_pu_idx_top [ ( ps_codec -> s_parse . i4_ctb_x * ctb_size / MIN_PU_SIZE ) + i ] = pu4_nbr_pu_idx [ ( ctb_size_left / MIN_PU_SIZE ) * nbr_pu_idx_strd + i + 1 ] ; } } } if ( 0 == ps_codec -> i4_disable_deblk_pic ) { if ( ( 0 == ps_slice_hdr -> i1_slice_disable_deblocking_filter_flag ) && ( 0 == ps_codec -> i4_slice_error ) ) { WORD32 i4_ctb_tu_cnt ; WORD32 cur_ctb_idx , next_ctb_idx ; WORD32 cur_pu_idx ; WORD32 cur_tu_idx ; process_ctxt_t * ps_proc ; ps_proc = & ps_codec -> as_process [ ( ps_codec -> i4_num_cores == 1 ) ? 1 : ( ps_codec -> i4_num_cores - 1 ) ] ; cur_ctb_idx = ps_codec -> s_parse . i4_ctb_x + ps_codec -> s_parse . i4_ctb_y * ( ps_sps -> i2_pic_wd_in_ctb ) ; cur_pu_idx = ps_codec -> s_parse . pu4_pic_pu_idx [ cur_ctb_idx ] ; next_ctb_idx = ps_codec -> s_parse . i4_next_tu_ctb_cnt ; if ( 1 == ps_codec -> i4_num_cores ) { i4_ctb_tu_cnt = ps_codec -> s_parse . pu4_pic_tu_idx [ next_ctb_idx ] - ps_codec -> s_parse . pu4_pic_tu_idx [ cur_ctb_idx % RESET_TU_BUF_NCTB ] ; cur_tu_idx = ps_codec -> s_parse . pu4_pic_tu_idx [ cur_ctb_idx % RESET_TU_BUF_NCTB ] ; } else { i4_ctb_tu_cnt = ps_codec -> s_parse . pu4_pic_tu_idx [ next_ctb_idx ] - ps_codec -> s_parse . pu4_pic_tu_idx [ cur_ctb_idx ] ; cur_tu_idx = ps_codec -> s_parse . pu4_pic_tu_idx [ cur_ctb_idx ] ; } ps_codec -> s_parse . s_bs_ctxt . ps_pps = ps_codec -> s_parse . ps_pps ; ps_codec -> s_parse . s_bs_ctxt . ps_sps = ps_codec -> s_parse . ps_sps ; ps_codec -> s_parse . s_bs_ctxt . ps_codec = ps_codec ; ps_codec -> s_parse . s_bs_ctxt . i4_ctb_tu_cnt = i4_ctb_tu_cnt ; ps_codec -> s_parse . s_bs_ctxt . i4_ctb_x = ps_codec -> s_parse . i4_ctb_x ; ps_codec -> s_parse . s_bs_ctxt . i4_ctb_y = ps_codec -> s_parse . i4_ctb_y ; ps_codec -> s_parse . s_bs_ctxt . i4_ctb_tile_x = ps_codec -> s_parse . i4_ctb_tile_x ; ps_codec -> s_parse . s_bs_ctxt . i4_ctb_tile_y = ps_codec -> s_parse . i4_ctb_tile_y ; ps_codec -> s_parse . s_bs_ctxt . i4_ctb_slice_x = ps_codec -> s_parse . i4_ctb_slice_x ; ps_codec -> s_parse . s_bs_ctxt . i4_ctb_slice_y = ps_codec -> s_parse . i4_ctb_slice_y ; ps_codec -> s_parse . s_bs_ctxt . ps_tu = & ps_codec -> s_parse . ps_pic_tu [ cur_tu_idx ] ; ps_codec -> s_parse . s_bs_ctxt . ps_pu = & ps_codec -> s_parse . ps_pic_pu [ cur_pu_idx ] ; ps_codec -> s_parse . s_bs_ctxt . pu4_pic_pu_idx_map = ps_proc -> pu4_pic_pu_idx_map ; ps_codec -> s_parse . s_bs_ctxt . i4_next_pu_ctb_cnt = ps_codec -> s_parse . i4_next_pu_ctb_cnt ; ps_codec -> s_parse . s_bs_ctxt . i4_next_tu_ctb_cnt = ps_codec -> s_parse . i4_next_tu_ctb_cnt ; ps_codec -> s_parse . s_bs_ctxt . pu1_slice_idx = ps_codec -> s_parse . pu1_slice_idx ; ps_codec -> s_parse . s_bs_ctxt . ps_slice_hdr = ps_codec -> s_parse . ps_slice_hdr ; ps_codec -> s_parse . s_bs_ctxt . ps_tile = ps_codec -> s_parse . ps_tile ; if ( ISLICE == ps_slice_hdr -> i1_slice_type ) { ihevcd_ctb_boundary_strength_islice ( & ps_codec -> s_parse . s_bs_ctxt ) ; } else { ihevcd_ctb_boundary_strength_pbslice ( & ps_codec -> s_parse . s_bs_ctxt ) ; } } else { WORD32 bs_strd = ( ps_sps -> i2_pic_wd_in_ctb + 1 ) * ( ctb_size * ctb_size / 8 / 16 ) ; UWORD32 * pu4_vert_bs = ( UWORD32 * ) ( ( UWORD8 * ) ps_codec -> s_parse . s_bs_ctxt . pu4_pic_vert_bs + ps_codec -> s_parse . i4_ctb_x * ( ctb_size * ctb_size / 8 / 16 ) + ps_codec -> s_parse . i4_ctb_y * bs_strd ) ; UWORD32 * pu4_horz_bs = ( UWORD32 * ) ( ( UWORD8 * ) ps_codec -> s_parse . s_bs_ctxt . pu4_pic_horz_bs + ps_codec -> s_parse . i4_ctb_x * ( ctb_size * ctb_size / 8 / 16 ) + ps_codec -> s_parse . i4_ctb_y * bs_strd ) ; memset ( pu4_vert_bs , 0 , ( ctb_size / 8 + 1 ) * ( ctb_size / 4 ) / 8 * 2 ) ; memset ( pu4_horz_bs , 0 , ( ctb_size / 8 ) * ( ctb_size / 4 ) / 8 * 2 ) ; } } } { sps_t * ps_sps = ps_codec -> s_parse . ps_sps ; UWORD8 * pu1_buf ; WORD32 idx ; idx = ( ps_codec -> s_parse . i4_ctb_x ) ; idx += ( ( ps_codec -> s_parse . i4_ctb_y ) * ps_sps -> i2_pic_wd_in_ctb ) ; pu1_buf = ( ps_codec -> pu1_parse_map + idx ) ; * pu1_buf = 1 ; } ps_codec -> s_parse . i4_ctb_tile_x ++ ; ps_codec -> s_parse . i4_ctb_x ++ ; ps_codec -> s_parse . i4_ctb_slice_x ++ ; if ( ps_pps -> i1_tiles_enabled_flag ) { tile_start_ctb_idx = ps_tile -> u1_pos_x + ps_tile -> u1_pos_y * ( ps_sps -> i2_pic_wd_in_ctb ) ; slice_start_ctb_idx = ps_slice_hdr -> i2_ctb_x + ps_slice_hdr -> i2_ctb_y * ( ps_sps -> i2_pic_wd_in_ctb ) ; if ( ( slice_start_ctb_idx < tile_start_ctb_idx ) ) { if ( ps_codec -> s_parse . i4_ctb_slice_x == ( ps_tile -> u1_pos_x + ps_tile -> u2_wd ) ) { ps_codec -> s_parse . i4_ctb_slice_y ++ ; ps_codec -> s_parse . i4_ctb_slice_x = ps_tile -> u1_pos_x ; } } else if ( ps_codec -> s_parse . i4_ctb_slice_x == ( ps_tile -> u2_wd ) ) { ps_codec -> s_parse . i4_ctb_slice_y ++ ; ps_codec -> s_parse . i4_ctb_slice_x = 0 ; } } else { if ( ps_codec -> s_parse . i4_ctb_slice_x == ps_tile -> u2_wd ) { ps_codec -> s_parse . i4_ctb_slice_y ++ ; ps_codec -> s_parse . i4_ctb_slice_x = 0 ; } } if ( ps_codec -> s_parse . i4_ctb_tile_x == ( ps_tile -> u2_wd ) ) { ps_codec -> s_parse . i4_ctb_tile_x = 0 ; ps_codec -> s_parse . i4_ctb_x = ps_tile -> u1_pos_x ; ps_codec -> s_parse . i4_ctb_tile_y ++ ; ps_codec -> s_parse . i4_ctb_y ++ ; if ( ps_codec -> s_parse . i4_ctb_tile_y == ( ps_tile -> u2_ht ) ) { ps_codec -> s_parse . i4_ctb_tile_y = 0 ; ps_codec -> s_parse . i4_ctb_tile_x = 0 ; ps_codec -> s_parse . ps_tile ++ ; if ( ( ps_tile -> u2_ht + ps_tile -> u1_pos_y == ps_sps -> i2_pic_ht_in_ctb ) && ( ps_tile -> u2_wd + ps_tile -> u1_pos_x == ps_sps -> i2_pic_wd_in_ctb ) ) { end_of_pic = 1 ; ps_codec -> s_parse . i4_ctb_x = 0 ; ps_codec -> s_parse . i4_ctb_y = ps_sps -> i2_pic_ht_in_ctb ; } else { ps_tile = ps_codec -> s_parse . ps_tile ; ps_codec -> s_parse . i4_ctb_x = ps_tile -> u1_pos_x ; ps_codec -> s_parse . i4_ctb_y = ps_tile -> u1_pos_y ; ps_codec -> s_parse . i4_ctb_tile_y = 0 ; ps_codec -> s_parse . i4_ctb_tile_x = 0 ; ps_codec -> s_parse . i4_ctb_slice_x = ps_tile -> u1_pos_x ; ps_codec -> s_parse . i4_ctb_slice_y = ps_tile -> u1_pos_y ; } } } ps_codec -> s_parse . i4_next_ctb_indx = ps_codec -> s_parse . i4_ctb_x + ps_codec -> s_parse . i4_ctb_y * ps_sps -> i2_pic_wd_in_ctb ; if ( ps_codec -> i4_slice_error ) { slice_header_t * ps_slice_hdr_next = ps_slice_hdr + 1 ; WORD32 next_slice_addr = ps_slice_hdr_next -> i2_ctb_x + ps_slice_hdr_next -> i2_ctb_y * ps_sps -> i2_pic_wd_in_ctb ; if ( ps_codec -> s_parse . i4_next_ctb_indx == next_slice_addr ) end_of_slice_flag = 1 ; } if ( ( 1 == ps_codec -> i4_num_cores ) && ( ps_codec -> s_parse . i4_ctb_tile_x == 0 ) ) { process_ctxt_t * ps_proc = & ps_codec -> as_process [ 0 ] ; ps_proc -> i4_ctb_cnt = ps_proc -> ps_tile -> u2_wd ; ihevcd_process ( ps_proc ) ; } if ( ( UWORD8 * ) ps_codec -> s_parse . s_bitstrm . pu1_buf_max + BITSTRM_OFF_THRS < ( ( UWORD8 * ) ps_codec -> s_parse . s_bitstrm . pu4_buf + ( ps_codec -> s_parse . s_bitstrm . u4_bit_ofst / 8 ) ) ) { if ( 0 == ps_codec -> i4_slice_error ) end_of_slice_flag = 1 ; } if ( end_of_pic ) break ; } while ( ! end_of_slice_flag ) ; ps_codec -> i4_slice_error = 0 ; if ( 0 == end_of_pic ) { while ( 1 ) { WORD32 parse_slice_idx ; parse_slice_idx = ps_codec -> s_parse . i4_cur_slice_idx ; parse_slice_idx ++ ; { if ( ( 1 == ps_codec -> i4_num_cores ) || ( 0 != ( parse_slice_idx & ( MAX_SLICE_HDR_CNT - 1 ) ) ) ) { ps_codec -> s_parse . i4_cur_slice_idx = parse_slice_idx ; break ; } else { WORD32 ctb_indx = 0 ; while ( ctb_indx != ps_sps -> i4_pic_size_in_ctb ) { WORD32 parse_status = * ( ps_codec -> pu1_parse_map + ctb_indx ) ; volatile WORD32 proc_status = * ( ps_codec -> pu1_proc_map + ctb_indx ) & 1 ; if ( parse_status == proc_status ) ctb_indx ++ ; } ps_codec -> s_parse . i4_cur_slice_idx = parse_slice_idx ; break ; } } } } else { # if FRAME_ILF_PAD if ( FRAME_ILF_PAD && 1 == ps_codec -> i4_num_cores ) { if ( ps_slice_hdr -> i4_abs_pic_order_cnt == 0 ) { DUMP_PRE_ILF ( ps_codec -> as_process [ 0 ] . pu1_cur_pic_luma , ps_codec -> as_process [ 0 ] . pu1_cur_pic_chroma , ps_sps -> i2_pic_width_in_luma_samples , ps_sps -> i2_pic_height_in_luma_samples , ps_codec -> i4_strd ) ; DUMP_BS ( ps_codec -> as_process [ 0 ] . s_bs_ctxt . pu4_pic_vert_bs , ps_codec -> as_process [ 0 ] . s_bs_ctxt . pu4_pic_horz_bs , ps_sps -> i2_pic_wd_in_ctb * ( ctb_size * ctb_size / 8 / 16 ) * ps_sps -> i2_pic_ht_in_ctb , ( ps_sps -> i2_pic_wd_in_ctb + 1 ) * ( ctb_size * ctb_size / 8 / 16 ) * ps_sps -> i2_pic_ht_in_ctb ) ; DUMP_QP ( ps_codec -> as_process [ 0 ] . s_bs_ctxt . pu1_pic_qp , ( ps_sps -> i2_pic_height_in_luma_samples * ps_sps -> i2_pic_width_in_luma_samples ) / ( MIN_CU_SIZE * MIN_CU_SIZE ) ) ; DUMP_QP_CONST_IN_CTB ( ps_codec -> as_process [ 0 ] . s_bs_ctxt . pu1_pic_qp_const_in_ctb , ( ps_sps -> i2_pic_height_in_luma_samples * ps_sps -> i2_pic_width_in_luma_samples ) / ( MIN_CTB_SIZE * MIN_CTB_SIZE ) / 8 ) ; DUMP_NO_LOOP_FILTER ( ps_codec -> as_process [ 0 ] . pu1_pic_no_loop_filter_flag , ( ps_sps -> i2_pic_width_in_luma_samples / MIN_CU_SIZE ) * ( ps_sps -> i2_pic_height_in_luma_samples / MIN_CU_SIZE ) / 8 ) ; DUMP_OFFSETS ( ps_slice_hdr -> i1_beta_offset_div2 , ps_slice_hdr -> i1_tc_offset_div2 , ps_pps -> i1_pic_cb_qp_offset , ps_pps -> i1_pic_cr_qp_offset ) ; } ps_codec -> s_parse . s_deblk_ctxt . ps_pps = ps_codec -> s_parse . ps_pps ; ps_codec -> s_parse . s_deblk_ctxt . ps_sps = ps_codec -> s_parse . ps_sps ; ps_codec -> s_parse . s_deblk_ctxt . ps_codec = ps_codec ; ps_codec -> s_parse . s_deblk_ctxt . ps_slice_hdr = ps_codec -> s_parse . ps_slice_hdr ; ps_codec -> s_parse . s_deblk_ctxt . is_chroma_yuv420sp_vu = ( ps_codec -> e_ref_chroma_fmt == IV_YUV_420SP_VU ) ; ps_codec -> s_parse . s_sao_ctxt . ps_pps = ps_codec -> s_parse . ps_pps ; ps_codec -> s_parse . s_sao_ctxt . ps_sps = ps_codec -> s_parse . ps_sps ; ps_codec -> s_parse . s_sao_ctxt . ps_codec = ps_codec ; ps_codec -> s_parse . s_sao_ctxt . ps_slice_hdr = ps_codec -> s_parse . ps_slice_hdr ; ihevcd_ilf_pad_frame ( & ps_codec -> s_parse . s_deblk_ctxt , & ps_codec -> s_parse . s_sao_ctxt ) ; } # endif ps_codec -> s_parse . i4_end_of_frame = 1 ; } return ret ; }
CWE-770 WORD32 ihevcd_create ( iv_obj_t * ps_codec_obj , void * pv_api_ip , void * pv_api_op ) { <S2SV_StartBug> ihevcd_cxa_create_op_t * ps_create_op ; <S2SV_EndBug> WORD32 ret ; codec_t * ps_codec ; <S2SV_StartBug> ps_create_op = ( ihevcd_cxa_create_op_t * ) pv_api_op ; <S2SV_EndBug> ps_create_op -> s_ivd_create_op_t . u4_error_code = 0 ; <S2SV_StartBug> ret = ihevcd_allocate_static_bufs ( & ps_codec_obj , pv_api_ip , pv_api_op ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( IV_FAIL == ret ) && ( NULL != ps_codec_obj ) ) <S2SV_EndBug> { <S2SV_StartBug> ihevcd_free_static_bufs ( ps_codec_obj ) ; <S2SV_EndBug> ps_create_op -> s_ivd_create_op_t . u4_error_code = IVD_MEM_ALLOC_FAILED ; ps_create_op -> s_ivd_create_op_t . u4_error_code = 1 << IVD_FATALERROR ; return IV_FAIL ; } ps_codec = ( codec_t * ) ps_codec_obj -> pv_codec_handle ; ret = ihevcd_init ( ps_codec ) ; TRACE_INIT ( NULL ) ; STATS_INIT ( ) ; return ret ; }
CWE-200 IHEVCD_ERROR_T ihevcd_parse_slice_header ( codec_t * ps_codec , nal_header_t * ps_nal ) { IHEVCD_ERROR_T ret = ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ; WORD32 value ; WORD32 i , j ; WORD32 sps_id ; pps_t * ps_pps ; sps_t * ps_sps ; slice_header_t * ps_slice_hdr ; WORD32 disable_deblocking_filter_flag ; bitstrm_t * ps_bitstrm = & ps_codec -> s_parse . s_bitstrm ; WORD32 idr_pic_flag ; WORD32 pps_id ; WORD32 first_slice_in_pic_flag ; WORD32 no_output_of_prior_pics_flag = 0 ; WORD8 i1_nal_unit_type = ps_nal -> i1_nal_unit_type ; WORD32 num_poc_total_curr = 0 ; <S2SV_StartBug> WORD32 slice_address ; <S2SV_EndBug> if ( ps_codec -> i4_slice_error == 1 ) return ret ; idr_pic_flag = ( NAL_IDR_W_LP == i1_nal_unit_type ) || ( NAL_IDR_N_LP == i1_nal_unit_type ) ; BITS_PARSE ( "first_slice_in_pic_flag" , first_slice_in_pic_flag , ps_bitstrm , 1 ) ; if ( ( NAL_BLA_W_LP <= i1_nal_unit_type ) && ( NAL_RSV_RAP_VCL23 >= i1_nal_unit_type ) ) { BITS_PARSE ( "no_output_of_prior_pics_flag" , no_output_of_prior_pics_flag , ps_bitstrm , 1 ) ; } UEV_PARSE ( "pic_parameter_set_id" , pps_id , ps_bitstrm ) ; pps_id = CLIP3 ( pps_id , 0 , MAX_PPS_CNT - 2 ) ; ps_pps = ps_codec -> s_parse . ps_pps_base + pps_id ; if ( 0 == ps_pps -> i1_pps_valid ) { pps_t * ps_pps_ref = ps_codec -> ps_pps_base ; while ( 0 == ps_pps_ref -> i1_pps_valid ) { ps_pps_ref ++ ; if ( ( ps_pps_ref - ps_codec -> ps_pps_base >= MAX_PPS_CNT - 1 ) ) return IHEVCD_INVALID_HEADER ; } ihevcd_copy_pps ( ps_codec , pps_id , ps_pps_ref -> i1_pps_id ) ; } sps_id = ps_pps -> i1_sps_id ; ps_sps = ps_codec -> s_parse . ps_sps_base + sps_id ; if ( ( 0 != ps_codec -> u4_pic_cnt || ps_codec -> i4_pic_present ) && first_slice_in_pic_flag ) { if ( ps_codec -> i4_pic_present ) { slice_header_t * ps_slice_hdr_next ; ps_codec -> i4_slice_error = 1 ; ps_codec -> s_parse . i4_cur_slice_idx -- ; if ( ps_codec -> s_parse . i4_cur_slice_idx < 0 ) ps_codec -> s_parse . i4_cur_slice_idx = 0 ; ps_slice_hdr_next = ps_codec -> s_parse . ps_slice_hdr_base + ( ( ps_codec -> s_parse . i4_cur_slice_idx + 1 ) & ( MAX_SLICE_HDR_CNT - 1 ) ) ; ps_slice_hdr_next -> i2_ctb_x = 0 ; ps_slice_hdr_next -> i2_ctb_y = ps_codec -> s_parse . ps_sps -> i2_pic_ht_in_ctb ; return ret ; } else { ps_codec -> i4_slice_error = 0 ; } } if ( first_slice_in_pic_flag ) { ps_codec -> s_parse . i4_cur_slice_idx = 0 ; } else { if ( 0 == ps_codec -> i4_pic_present ) ps_codec -> s_parse . i4_cur_slice_idx = 1 ; } ps_slice_hdr = ps_codec -> s_parse . ps_slice_hdr_base + ( ps_codec -> s_parse . i4_cur_slice_idx & ( MAX_SLICE_HDR_CNT - 1 ) ) ; if ( ( ps_pps -> i1_dependent_slice_enabled_flag ) && ( ! first_slice_in_pic_flag ) ) { BITS_PARSE ( "dependent_slice_flag" , value , ps_bitstrm , 1 ) ; if ( value && ( ps_codec -> s_parse . i4_cur_slice_idx > 0 ) ) { ihevcd_copy_slice_hdr ( ps_codec , ( ps_codec -> s_parse . i4_cur_slice_idx & ( MAX_SLICE_HDR_CNT - 1 ) ) , ( ( ps_codec -> s_parse . i4_cur_slice_idx - 1 ) & ( MAX_SLICE_HDR_CNT - 1 ) ) ) ; } ps_slice_hdr -> i1_dependent_slice_flag = value ; } else { ps_slice_hdr -> i1_dependent_slice_flag = 0 ; } ps_slice_hdr -> i1_nal_unit_type = i1_nal_unit_type ; ps_slice_hdr -> i1_pps_id = pps_id ; ps_slice_hdr -> i1_first_slice_in_pic_flag = first_slice_in_pic_flag ; ps_slice_hdr -> i1_no_output_of_prior_pics_flag = 1 ; if ( ( NAL_BLA_W_LP <= i1_nal_unit_type ) && ( NAL_RSV_RAP_VCL23 >= i1_nal_unit_type ) ) { ps_slice_hdr -> i1_no_output_of_prior_pics_flag = no_output_of_prior_pics_flag ; } ps_slice_hdr -> i1_pps_id = pps_id ; if ( ! ps_slice_hdr -> i1_first_slice_in_pic_flag ) { WORD32 num_bits ; num_bits = 32 - CLZ ( ps_sps -> i4_pic_size_in_ctb - 1 ) ; BITS_PARSE ( "slice_address" , value , ps_bitstrm , num_bits ) ; slice_address = value ; if ( value >= ps_sps -> i4_pic_size_in_ctb ) return IHEVCD_IGNORE_SLICE ; } else { slice_address = 0 ; } if ( ! ps_slice_hdr -> i1_dependent_slice_flag ) { ps_slice_hdr -> i1_pic_output_flag = 1 ; ps_slice_hdr -> i4_pic_order_cnt_lsb = 0 ; ps_slice_hdr -> i1_num_long_term_sps = 0 ; ps_slice_hdr -> i1_num_long_term_pics = 0 ; for ( i = 0 ; i < ps_pps -> i1_num_extra_slice_header_bits ; i ++ ) { BITS_PARSE ( "slice_reserved_undetermined_flag[<S2SV_blank>i<S2SV_blank>]" , value , ps_bitstrm , 1 ) ; } UEV_PARSE ( "slice_type" , value , ps_bitstrm ) ; ps_slice_hdr -> i1_slice_type = value ; if ( ( ps_slice_hdr -> i1_nal_unit_type >= NAL_BLA_W_LP ) && ( ps_slice_hdr -> i1_nal_unit_type <= NAL_RSV_RAP_VCL23 ) ) ps_slice_hdr -> i1_slice_type = ISLICE ; if ( ( ps_slice_hdr -> i1_slice_type < 0 ) || ( ps_slice_hdr -> i1_slice_type > 2 ) ) return IHEVCD_IGNORE_SLICE ; if ( ps_pps -> i1_output_flag_present_flag ) { BITS_PARSE ( "pic_output_flag" , value , ps_bitstrm , 1 ) ; ps_slice_hdr -> i1_pic_output_flag = value ; } ps_slice_hdr -> i1_colour_plane_id = 0 ; if ( 1 == ps_sps -> i1_separate_colour_plane_flag ) { BITS_PARSE ( "colour_plane_id" , value , ps_bitstrm , 2 ) ; ps_slice_hdr -> i1_colour_plane_id = value ; } ps_slice_hdr -> i1_slice_temporal_mvp_enable_flag = 0 ; if ( ! idr_pic_flag ) { WORD32 st_rps_idx ; WORD32 num_neg_pics ; WORD32 num_pos_pics ; WORD8 * pi1_used ; BITS_PARSE ( "pic_order_cnt_lsb" , value , ps_bitstrm , ps_sps -> i1_log2_max_pic_order_cnt_lsb ) ; ps_slice_hdr -> i4_pic_order_cnt_lsb = value ; BITS_PARSE ( "short_term_ref_pic_set_sps_flag" , value , ps_bitstrm , 1 ) ; ps_slice_hdr -> i1_short_term_ref_pic_set_sps_flag = value ; if ( 1 == ps_slice_hdr -> i1_short_term_ref_pic_set_sps_flag ) { WORD32 numbits ; ps_slice_hdr -> i1_short_term_ref_pic_set_idx = 0 ; if ( ps_sps -> i1_num_short_term_ref_pic_sets > 1 ) { numbits = 32 - CLZ ( ps_sps -> i1_num_short_term_ref_pic_sets - 1 ) ; BITS_PARSE ( "short_term_ref_pic_set_idx" , value , ps_bitstrm , numbits ) ; ps_slice_hdr -> i1_short_term_ref_pic_set_idx = value ; } st_rps_idx = ps_slice_hdr -> i1_short_term_ref_pic_set_idx ; num_neg_pics = ps_sps -> as_stref_picset [ st_rps_idx ] . i1_num_neg_pics ; num_pos_pics = ps_sps -> as_stref_picset [ st_rps_idx ] . i1_num_pos_pics ; pi1_used = ps_sps -> as_stref_picset [ st_rps_idx ] . ai1_used ; } else { ihevcd_short_term_ref_pic_set ( ps_bitstrm , & ps_sps -> as_stref_picset [ 0 ] , ps_sps -> i1_num_short_term_ref_pic_sets , ps_sps -> i1_num_short_term_ref_pic_sets , & ps_slice_hdr -> s_stref_picset ) ; st_rps_idx = ps_sps -> i1_num_short_term_ref_pic_sets ; num_neg_pics = ps_slice_hdr -> s_stref_picset . i1_num_neg_pics ; num_pos_pics = ps_slice_hdr -> s_stref_picset . i1_num_pos_pics ; pi1_used = ps_slice_hdr -> s_stref_picset . ai1_used ; } if ( ps_sps -> i1_long_term_ref_pics_present_flag ) { if ( ps_sps -> i1_num_long_term_ref_pics_sps > 0 ) { UEV_PARSE ( "num_long_term_sps" , value , ps_bitstrm ) ; ps_slice_hdr -> i1_num_long_term_sps = value ; ps_slice_hdr -> i1_num_long_term_sps = CLIP3 ( ps_slice_hdr -> i1_num_long_term_sps , 0 , MAX_DPB_SIZE - num_neg_pics - num_pos_pics ) ; } UEV_PARSE ( "num_long_term_pics" , value , ps_bitstrm ) ; ps_slice_hdr -> i1_num_long_term_pics = value ; ps_slice_hdr -> i1_num_long_term_pics = CLIP3 ( ps_slice_hdr -> i1_num_long_term_pics , 0 , MAX_DPB_SIZE - num_neg_pics - num_pos_pics - ps_slice_hdr -> i1_num_long_term_sps ) ; for ( i = 0 ; i < ( ps_slice_hdr -> i1_num_long_term_sps + ps_slice_hdr -> i1_num_long_term_pics ) ; i ++ ) { if ( i < ps_slice_hdr -> i1_num_long_term_sps ) { if ( ps_sps -> i1_num_long_term_ref_pics_sps > 1 ) { WORD32 num_bits = 32 - CLZ ( ps_sps -> i1_num_long_term_ref_pics_sps - 1 ) ; BITS_PARSE ( "lt_idx_sps[<S2SV_blank>i<S2SV_blank>]" , value , ps_bitstrm , num_bits ) ; } else { value = 0 ; } ps_slice_hdr -> ai4_poc_lsb_lt [ i ] = ps_sps -> au2_lt_ref_pic_poc_lsb_sps [ value ] ; ps_slice_hdr -> ai1_used_by_curr_pic_lt_flag [ i ] = ps_sps -> ai1_used_by_curr_pic_lt_sps_flag [ value ] ; } else { BITS_PARSE ( "poc_lsb_lt[<S2SV_blank>i<S2SV_blank>]" , value , ps_bitstrm , ps_sps -> i1_log2_max_pic_order_cnt_lsb ) ; ps_slice_hdr -> ai4_poc_lsb_lt [ i ] = value ; BITS_PARSE ( "used_by_curr_pic_lt_flag[<S2SV_blank>i<S2SV_blank>]" , value , ps_bitstrm , 1 ) ; ps_slice_hdr -> ai1_used_by_curr_pic_lt_flag [ i ] = value ; } BITS_PARSE ( "delta_poc_msb_present_flag[<S2SV_blank>i<S2SV_blank>]" , value , ps_bitstrm , 1 ) ; ps_slice_hdr -> ai1_delta_poc_msb_present_flag [ i ] = value ; ps_slice_hdr -> ai1_delta_poc_msb_cycle_lt [ i ] = 0 ; if ( ps_slice_hdr -> ai1_delta_poc_msb_present_flag [ i ] ) { UEV_PARSE ( "delata_poc_msb_cycle_lt[<S2SV_blank>i<S2SV_blank>]" , value , ps_bitstrm ) ; ps_slice_hdr -> ai1_delta_poc_msb_cycle_lt [ i ] = value ; } if ( ( i != 0 ) && ( i != ps_slice_hdr -> i1_num_long_term_sps ) ) { ps_slice_hdr -> ai1_delta_poc_msb_cycle_lt [ i ] += ps_slice_hdr -> ai1_delta_poc_msb_cycle_lt [ i - 1 ] ; } } } for ( i = 0 ; i < num_neg_pics + num_pos_pics ; i ++ ) { if ( pi1_used [ i ] ) { num_poc_total_curr ++ ; } } for ( i = 0 ; i < ps_slice_hdr -> i1_num_long_term_sps + ps_slice_hdr -> i1_num_long_term_pics ; i ++ ) { if ( ps_slice_hdr -> ai1_used_by_curr_pic_lt_flag [ i ] ) { num_poc_total_curr ++ ; } } if ( ps_sps -> i1_sps_temporal_mvp_enable_flag ) { BITS_PARSE ( "enable_temporal_mvp_flag" , value , ps_bitstrm , 1 ) ; ps_slice_hdr -> i1_slice_temporal_mvp_enable_flag = value ; } } ps_slice_hdr -> i1_slice_sao_luma_flag = 0 ; ps_slice_hdr -> i1_slice_sao_chroma_flag = 0 ; if ( ps_sps -> i1_sample_adaptive_offset_enabled_flag ) { BITS_PARSE ( "slice_sao_luma_flag" , value , ps_bitstrm , 1 ) ; ps_slice_hdr -> i1_slice_sao_luma_flag = value ; BITS_PARSE ( "slice_sao_chroma_flag" , value , ps_bitstrm , 1 ) ; ps_slice_hdr -> i1_slice_sao_chroma_flag = value ; } ps_slice_hdr -> i1_max_num_merge_cand = 1 ; ps_slice_hdr -> i1_cabac_init_flag = 0 ; ps_slice_hdr -> i1_num_ref_idx_l0_active = 0 ; ps_slice_hdr -> i1_num_ref_idx_l1_active = 0 ; ps_slice_hdr -> i1_slice_cb_qp_offset = 0 ; ps_slice_hdr -> i1_slice_cr_qp_offset = 0 ; if ( ( PSLICE == ps_slice_hdr -> i1_slice_type ) || ( BSLICE == ps_slice_hdr -> i1_slice_type ) ) { BITS_PARSE ( "num_ref_idx_active_override_flag" , value , ps_bitstrm , 1 ) ; ps_slice_hdr -> i1_num_ref_idx_active_override_flag = value ; if ( ps_slice_hdr -> i1_num_ref_idx_active_override_flag ) { UEV_PARSE ( "num_ref_idx_l0_active_minus1" , value , ps_bitstrm ) ; ps_slice_hdr -> i1_num_ref_idx_l0_active = value + 1 ; if ( BSLICE == ps_slice_hdr -> i1_slice_type ) { UEV_PARSE ( "num_ref_idx_l1_active_minus1" , value , ps_bitstrm ) ; ps_slice_hdr -> i1_num_ref_idx_l1_active = value + 1 ; } } else { ps_slice_hdr -> i1_num_ref_idx_l0_active = ps_pps -> i1_num_ref_idx_l0_default_active ; if ( BSLICE == ps_slice_hdr -> i1_slice_type ) { ps_slice_hdr -> i1_num_ref_idx_l1_active = ps_pps -> i1_num_ref_idx_l1_default_active ; } } ps_slice_hdr -> i1_num_ref_idx_l0_active = CLIP3 ( ps_slice_hdr -> i1_num_ref_idx_l0_active , 0 , MAX_DPB_SIZE - 1 ) ; ps_slice_hdr -> i1_num_ref_idx_l1_active = CLIP3 ( ps_slice_hdr -> i1_num_ref_idx_l1_active , 0 , MAX_DPB_SIZE - 1 ) ; if ( 0 == num_poc_total_curr ) return IHEVCD_IGNORE_SLICE ; if ( ( ps_pps -> i1_lists_modification_present_flag ) && ( num_poc_total_curr > 1 ) ) { ihevcd_ref_pic_list_modification ( ps_bitstrm , ps_slice_hdr , num_poc_total_curr ) ; } else { ps_slice_hdr -> s_rplm . i1_ref_pic_list_modification_flag_l0 = 0 ; ps_slice_hdr -> s_rplm . i1_ref_pic_list_modification_flag_l1 = 0 ; } if ( BSLICE == ps_slice_hdr -> i1_slice_type ) { BITS_PARSE ( "mvd_l1_zero_flag" , value , ps_bitstrm , 1 ) ; ps_slice_hdr -> i1_mvd_l1_zero_flag = value ; } ps_slice_hdr -> i1_cabac_init_flag = 0 ; if ( ps_pps -> i1_cabac_init_present_flag ) { BITS_PARSE ( "cabac_init_flag" , value , ps_bitstrm , 1 ) ; ps_slice_hdr -> i1_cabac_init_flag = value ; } ps_slice_hdr -> i1_collocated_from_l0_flag = 1 ; ps_slice_hdr -> i1_collocated_ref_idx = 0 ; if ( ps_slice_hdr -> i1_slice_temporal_mvp_enable_flag ) { if ( BSLICE == ps_slice_hdr -> i1_slice_type ) { BITS_PARSE ( "collocated_from_l0_flag" , value , ps_bitstrm , 1 ) ; ps_slice_hdr -> i1_collocated_from_l0_flag = value ; } if ( ( ps_slice_hdr -> i1_collocated_from_l0_flag && ( ps_slice_hdr -> i1_num_ref_idx_l0_active > 1 ) ) || ( ! ps_slice_hdr -> i1_collocated_from_l0_flag && ( ps_slice_hdr -> i1_num_ref_idx_l1_active > 1 ) ) ) { UEV_PARSE ( "collocated_ref_idx" , value , ps_bitstrm ) ; ps_slice_hdr -> i1_collocated_ref_idx = value ; } } ps_slice_hdr -> i1_collocated_ref_idx = CLIP3 ( ps_slice_hdr -> i1_collocated_ref_idx , 0 , MAX_DPB_SIZE - 1 ) ; if ( ( ps_pps -> i1_weighted_pred_flag && ( PSLICE == ps_slice_hdr -> i1_slice_type ) ) || ( ps_pps -> i1_weighted_bipred_flag && ( BSLICE == ps_slice_hdr -> i1_slice_type ) ) ) { ihevcd_parse_pred_wt_ofst ( ps_bitstrm , ps_sps , ps_pps , ps_slice_hdr ) ; } UEV_PARSE ( "five_minus_max_num_merge_cand" , value , ps_bitstrm ) ; ps_slice_hdr -> i1_max_num_merge_cand = 5 - value ; } ps_slice_hdr -> i1_max_num_merge_cand = CLIP3 ( ps_slice_hdr -> i1_max_num_merge_cand , 1 , 5 ) ; SEV_PARSE ( "slice_qp_delta" , value , ps_bitstrm ) ; ps_slice_hdr -> i1_slice_qp_delta = value ; if ( ps_pps -> i1_pic_slice_level_chroma_qp_offsets_present_flag ) { SEV_PARSE ( "slice_cb_qp_offset" , value , ps_bitstrm ) ; ps_slice_hdr -> i1_slice_cb_qp_offset = value ; SEV_PARSE ( "slice_cr_qp_offset" , value , ps_bitstrm ) ; ps_slice_hdr -> i1_slice_cr_qp_offset = value ; } ps_slice_hdr -> i1_deblocking_filter_override_flag = 0 ; ps_slice_hdr -> i1_slice_disable_deblocking_filter_flag = ps_pps -> i1_pic_disable_deblocking_filter_flag ; ps_slice_hdr -> i1_beta_offset_div2 = ps_pps -> i1_beta_offset_div2 ; ps_slice_hdr -> i1_tc_offset_div2 = ps_pps -> i1_tc_offset_div2 ; disable_deblocking_filter_flag = ps_pps -> i1_pic_disable_deblocking_filter_flag ; if ( ps_pps -> i1_deblocking_filter_control_present_flag ) { if ( ps_pps -> i1_deblocking_filter_override_enabled_flag ) { BITS_PARSE ( "deblocking_filter_override_flag" , value , ps_bitstrm , 1 ) ; ps_slice_hdr -> i1_deblocking_filter_override_flag = value ; } if ( ps_slice_hdr -> i1_deblocking_filter_override_flag ) { BITS_PARSE ( "slice_disable_deblocking_filter_flag" , value , ps_bitstrm , 1 ) ; ps_slice_hdr -> i1_slice_disable_deblocking_filter_flag = value ; disable_deblocking_filter_flag = ps_slice_hdr -> i1_slice_disable_deblocking_filter_flag ; if ( ! ps_slice_hdr -> i1_slice_disable_deblocking_filter_flag ) { SEV_PARSE ( "beta_offset_div2" , value , ps_bitstrm ) ; ps_slice_hdr -> i1_beta_offset_div2 = value ; SEV_PARSE ( "tc_offset_div2" , value , ps_bitstrm ) ; ps_slice_hdr -> i1_tc_offset_div2 = value ; } } } ps_slice_hdr -> i1_slice_loop_filter_across_slices_enabled_flag = ps_pps -> i1_loop_filter_across_slices_enabled_flag ; if ( ps_pps -> i1_loop_filter_across_slices_enabled_flag && ( ps_slice_hdr -> i1_slice_sao_luma_flag || ps_slice_hdr -> i1_slice_sao_chroma_flag || ! disable_deblocking_filter_flag ) ) { BITS_PARSE ( "slice_loop_filter_across_slices_enabled_flag" , value , ps_bitstrm , 1 ) ; ps_slice_hdr -> i1_slice_loop_filter_across_slices_enabled_flag = value ; } } if ( ( ! first_slice_in_pic_flag ) && ( ps_codec -> i4_pic_present ) ) { slice_header_t * ps_slice_hdr_base = ps_codec -> ps_slice_hdr_base ; if ( ( ps_slice_hdr_base -> i1_pps_id != ps_slice_hdr -> i1_pps_id ) || ( ps_slice_hdr_base -> i4_pic_order_cnt_lsb != ps_slice_hdr -> i4_pic_order_cnt_lsb ) ) { return IHEVCD_IGNORE_SLICE ; } } if ( 0 == ps_codec -> i4_pic_present ) { ps_slice_hdr -> i4_abs_pic_order_cnt = ihevcd_calc_poc ( ps_codec , ps_nal , ps_sps -> i1_log2_max_pic_order_cnt_lsb , ps_slice_hdr -> i4_pic_order_cnt_lsb ) ; } else { ps_slice_hdr -> i4_abs_pic_order_cnt = ps_codec -> s_parse . i4_abs_pic_order_cnt ; } if ( ! first_slice_in_pic_flag ) { if ( ps_codec -> s_parse . i4_abs_pic_order_cnt == ps_slice_hdr -> i4_abs_pic_order_cnt ) { if ( slice_address > ps_codec -> s_parse . i4_next_ctb_indx ) { if ( ps_codec -> i4_pic_present ) { <S2SV_StartBug> slice_header_t * ps_slice_hdr_next ; <S2SV_EndBug> ps_codec -> i4_slice_error = 1 ; ps_codec -> s_parse . i4_cur_slice_idx -- ; if ( ps_codec -> s_parse . i4_cur_slice_idx < 0 ) ps_codec -> s_parse . i4_cur_slice_idx = 0 ; ps_slice_hdr_next = ps_codec -> s_parse . ps_slice_hdr_base + ( ( ps_codec -> s_parse . i4_cur_slice_idx + 1 ) & ( MAX_SLICE_HDR_CNT - 1 ) ) ; ps_slice_hdr_next -> i2_ctb_x = slice_address % ps_sps -> i2_pic_wd_in_ctb ; ps_slice_hdr_next -> i2_ctb_y = slice_address / ps_sps -> i2_pic_wd_in_ctb ; return ret ; } else { return IHEVCD_IGNORE_SLICE ; } } else if ( slice_address < ps_codec -> s_parse . i4_next_ctb_indx ) { return IHEVCD_IGNORE_SLICE ; } else { ps_codec -> i4_slice_error = 0 ; } } else { if ( ps_codec -> i4_pic_present ) { slice_header_t * ps_slice_hdr_next ; ps_codec -> i4_slice_error = 1 ; ps_codec -> s_parse . i4_cur_slice_idx -- ; if ( ps_codec -> s_parse . i4_cur_slice_idx < 0 ) ps_codec -> s_parse . i4_cur_slice_idx = 0 ; ps_slice_hdr_next = ps_codec -> s_parse . ps_slice_hdr_base + ( ( ps_codec -> s_parse . i4_cur_slice_idx + 1 ) & ( MAX_SLICE_HDR_CNT - 1 ) ) ; ps_slice_hdr_next -> i2_ctb_x = 0 ; ps_slice_hdr_next -> i2_ctb_y = ps_codec -> s_parse . ps_sps -> i2_pic_ht_in_ctb ; return ret ; } else { if ( ps_slice_hdr -> i1_dependent_slice_flag ) return IHEVCD_IGNORE_SLICE ; ps_codec -> s_parse . i4_abs_pic_order_cnt = ps_slice_hdr -> i4_abs_pic_order_cnt ; } } } else { if ( ps_codec -> s_parse . i4_abs_pic_order_cnt == ps_slice_hdr -> i4_abs_pic_order_cnt ) return IHEVCD_IGNORE_SLICE ; ps_codec -> s_parse . i4_abs_pic_order_cnt = ps_slice_hdr -> i4_abs_pic_order_cnt ; } ps_slice_hdr -> i4_num_entry_point_offsets = 0 ; if ( ( ps_pps -> i1_tiles_enabled_flag ) || ( ps_pps -> i1_entropy_coding_sync_enabled_flag ) ) { UEV_PARSE ( "num_entry_point_offsets" , value , ps_bitstrm ) ; ps_slice_hdr -> i4_num_entry_point_offsets = value ; { WORD32 max_num_entry_point_offsets ; if ( ( ps_pps -> i1_tiles_enabled_flag ) && ( ps_pps -> i1_entropy_coding_sync_enabled_flag ) ) { max_num_entry_point_offsets = ps_pps -> i1_num_tile_columns * ( ps_sps -> i2_pic_ht_in_ctb - 1 ) ; } else if ( ps_pps -> i1_tiles_enabled_flag ) { max_num_entry_point_offsets = ps_pps -> i1_num_tile_columns * ps_pps -> i1_num_tile_rows ; } else { max_num_entry_point_offsets = ( ps_sps -> i2_pic_ht_in_ctb - 1 ) ; } ps_slice_hdr -> i4_num_entry_point_offsets = CLIP3 ( ps_slice_hdr -> i4_num_entry_point_offsets , 0 , max_num_entry_point_offsets ) ; } if ( ps_slice_hdr -> i4_num_entry_point_offsets > 0 ) { UEV_PARSE ( "offset_len_minus1" , value , ps_bitstrm ) ; ps_slice_hdr -> i1_offset_len = value + 1 ; for ( i = 0 ; i < ps_slice_hdr -> i4_num_entry_point_offsets ; i ++ ) { BITS_PARSE ( "entry_point_offset" , value , ps_bitstrm , ps_slice_hdr -> i1_offset_len ) ; } } } if ( ps_pps -> i1_slice_header_extension_present_flag ) { UEV_PARSE ( "slice_header_extension_length" , value , ps_bitstrm ) ; ps_slice_hdr -> i2_slice_header_extension_length = value ; for ( i = 0 ; i < ps_slice_hdr -> i2_slice_header_extension_length ; i ++ ) { BITS_PARSE ( "slice_header_extension_data_byte" , value , ps_bitstrm , 8 ) ; } } ihevcd_bits_flush_to_byte_boundary ( ps_bitstrm ) ; if ( ( UWORD8 * ) ps_bitstrm -> pu4_buf > ps_bitstrm -> pu1_buf_max ) return IHEVCD_INVALID_PARAMETER ; { dpb_mgr_t * ps_dpb_mgr = ( dpb_mgr_t * ) ps_codec -> pv_dpb_mgr ; WORD32 r_idx ; if ( ( NAL_IDR_W_LP == ps_slice_hdr -> i1_nal_unit_type ) || ( NAL_IDR_N_LP == ps_slice_hdr -> i1_nal_unit_type ) || ( NAL_BLA_N_LP == ps_slice_hdr -> i1_nal_unit_type ) || ( NAL_BLA_W_DLP == ps_slice_hdr -> i1_nal_unit_type ) || ( NAL_BLA_W_LP == ps_slice_hdr -> i1_nal_unit_type ) || ( 0 == ps_codec -> u4_pic_cnt ) ) { for ( i = 0 ; i < MAX_DPB_BUFS ; i ++ ) { if ( ps_dpb_mgr -> as_dpb_info [ i ] . ps_pic_buf ) { pic_buf_t * ps_pic_buf = ps_dpb_mgr -> as_dpb_info [ i ] . ps_pic_buf ; mv_buf_t * ps_mv_buf ; ihevc_dpb_mgr_del_ref ( ( dpb_mgr_t * ) ps_codec -> pv_dpb_mgr , ( buf_mgr_t * ) ps_codec -> pv_pic_buf_mgr , ps_pic_buf -> i4_abs_poc ) ; ps_mv_buf = ( mv_buf_t * ) ps_codec -> ps_mv_buf ; for ( j = 0 ; j < ps_codec -> i4_max_dpb_size ; j ++ ) { if ( ps_mv_buf && ps_mv_buf -> i4_abs_poc == ps_pic_buf -> i4_abs_poc ) { ihevc_buf_mgr_release ( ( buf_mgr_t * ) ps_codec -> pv_mv_buf_mgr , j , BUF_MGR_REF ) ; break ; } ps_mv_buf ++ ; } } } for ( r_idx = 0 ; r_idx < MAX_DPB_SIZE ; r_idx ++ ) { ps_slice_hdr -> as_ref_pic_list0 [ r_idx ] . pv_pic_buf = NULL ; ps_slice_hdr -> as_ref_pic_list0 [ r_idx ] . pv_mv_buf = NULL ; ps_slice_hdr -> as_ref_pic_list1 [ r_idx ] . pv_pic_buf = NULL ; ps_slice_hdr -> as_ref_pic_list1 [ r_idx ] . pv_mv_buf = NULL ; } } else { ret = ihevcd_ref_list ( ps_codec , ps_pps , ps_sps , ps_slice_hdr ) ; if ( ( WORD32 ) IHEVCD_SUCCESS != ret ) { return ret ; } } } if ( ps_codec -> i4_pic_present ) { pic_buf_t * ps_pic_buf_ref ; mv_buf_t * ps_mv_buf_ref ; WORD32 r_idx ; dpb_mgr_t * ps_dpb_mgr = ( dpb_mgr_t * ) ps_codec -> pv_dpb_mgr ; buf_mgr_t * ps_mv_buf_mgr = ( buf_mgr_t * ) ps_codec -> pv_mv_buf_mgr ; ps_pic_buf_ref = ihevc_dpb_mgr_get_ref_by_nearest_poc ( ps_dpb_mgr , ps_slice_hdr -> i4_abs_pic_order_cnt ) ; if ( NULL == ps_pic_buf_ref ) { ps_pic_buf_ref = ps_codec -> as_process [ 0 ] . ps_cur_pic ; ps_mv_buf_ref = ps_codec -> s_parse . ps_cur_mv_buf ; } else { ps_mv_buf_ref = ihevcd_mv_mgr_get_poc ( ps_mv_buf_mgr , ps_pic_buf_ref -> i4_abs_poc ) ; } for ( r_idx = 0 ; r_idx < ps_slice_hdr -> i1_num_ref_idx_l0_active ; r_idx ++ ) { if ( NULL == ps_slice_hdr -> as_ref_pic_list0 [ r_idx ] . pv_pic_buf ) { ps_slice_hdr -> as_ref_pic_list0 [ r_idx ] . pv_pic_buf = ( void * ) ps_pic_buf_ref ; ps_slice_hdr -> as_ref_pic_list0 [ r_idx ] . pv_mv_buf = ( void * ) ps_mv_buf_ref ; } } for ( r_idx = ps_slice_hdr -> i1_num_ref_idx_l0_active ; r_idx < MAX_DPB_SIZE ; r_idx ++ ) { ps_slice_hdr -> as_ref_pic_list0 [ r_idx ] . pv_pic_buf = ( void * ) ps_pic_buf_ref ; ps_slice_hdr -> as_ref_pic_list0 [ r_idx ] . pv_mv_buf = ( void * ) ps_mv_buf_ref ; } for ( r_idx = 0 ; r_idx < ps_slice_hdr -> i1_num_ref_idx_l1_active ; r_idx ++ ) { if ( NULL == ps_slice_hdr -> as_ref_pic_list1 [ r_idx ] . pv_pic_buf ) { ps_slice_hdr -> as_ref_pic_list1 [ r_idx ] . pv_pic_buf = ( void * ) ps_pic_buf_ref ; ps_slice_hdr -> as_ref_pic_list1 [ r_idx ] . pv_mv_buf = ( void * ) ps_mv_buf_ref ; } } for ( r_idx = ps_slice_hdr -> i1_num_ref_idx_l1_active ; r_idx < MAX_DPB_SIZE ; r_idx ++ ) { ps_slice_hdr -> as_ref_pic_list1 [ r_idx ] . pv_pic_buf = ( void * ) ps_pic_buf_ref ; ps_slice_hdr -> as_ref_pic_list1 [ r_idx ] . pv_mv_buf = ( void * ) ps_mv_buf_ref ; } } if ( ! ps_slice_hdr -> i1_first_slice_in_pic_flag ) { ps_slice_hdr -> i2_ctb_x = slice_address % ps_sps -> i2_pic_wd_in_ctb ; ps_slice_hdr -> i2_ctb_y = slice_address / ps_sps -> i2_pic_wd_in_ctb ; if ( ! ps_slice_hdr -> i1_dependent_slice_flag ) { ps_slice_hdr -> i2_independent_ctb_x = ps_slice_hdr -> i2_ctb_x ; ps_slice_hdr -> i2_independent_ctb_y = ps_slice_hdr -> i2_ctb_y ; } } else { ps_slice_hdr -> i2_ctb_x = 0 ; ps_slice_hdr -> i2_ctb_y = 0 ; ps_slice_hdr -> i2_independent_ctb_x = 0 ; ps_slice_hdr -> i2_independent_ctb_y = 0 ; } if ( ( ! first_slice_in_pic_flag ) && ( 0 == ps_codec -> i4_pic_present ) ) { slice_header_t * ps_slice_hdr_prev = ps_codec -> s_parse . ps_slice_hdr_base ; ihevcd_copy_slice_hdr ( ps_codec , 0 , ( ps_codec -> s_parse . i4_cur_slice_idx & ( MAX_SLICE_HDR_CNT - 1 ) ) ) ; <S2SV_StartBug> ps_codec -> i4_slice_error = 1 ; <S2SV_EndBug> ps_slice_hdr_prev -> i2_ctb_x = 0 ; ps_slice_hdr_prev -> i2_ctb_y = 0 ; ps_codec -> s_parse . i4_ctb_x = 0 ; ps_codec -> s_parse . i4_ctb_y = 0 ; ps_codec -> s_parse . i4_cur_slice_idx = 0 ; if ( ( ps_slice_hdr -> i2_ctb_x == 0 ) && ( ps_slice_hdr -> i2_ctb_y == 0 ) ) { ps_slice_hdr -> i2_ctb_x ++ ; } } { if ( ( i1_nal_unit_type < NAL_BLA_W_LP ) && ( i1_nal_unit_type % 2 == 0 ) ) { if ( IVD_SKIP_B == ps_codec -> e_pic_skip_mode ) return IHEVCD_IGNORE_SLICE ; } if ( ( IVD_SKIP_PB == ps_codec -> e_pic_skip_mode ) && ( ISLICE != ps_slice_hdr -> i1_slice_type ) ) { return IHEVCD_IGNORE_SLICE ; } } <S2SV_StartBug> return ret ; <S2SV_EndBug> }
CWE-190 void ihevcd_parse_sei_payload ( codec_t * ps_codec , UWORD32 u4_payload_type , UWORD32 u4_payload_size , WORD8 i1_nal_type ) { parse_ctxt_t * ps_parse = & ps_codec -> s_parse ; bitstrm_t * ps_bitstrm = & ps_parse -> s_bitstrm ; WORD32 payload_bits_remaining = 0 ; sps_t * ps_sps ; UWORD32 i ; for ( i = 0 ; i < MAX_SPS_CNT ; i ++ ) { ps_sps = ps_codec -> ps_sps_base + i ; if ( ps_sps -> i1_sps_valid ) { break ; } } if ( NULL == ps_sps ) { return ; } if ( NAL_PREFIX_SEI == i1_nal_type ) { switch ( u4_payload_type ) { case SEI_BUFFERING_PERIOD : ps_parse -> s_sei_params . i1_sei_parameters_present_flag = 1 ; ihevcd_parse_buffering_period_sei ( ps_codec , ps_sps ) ; break ; case SEI_PICTURE_TIMING : ps_parse -> s_sei_params . i1_sei_parameters_present_flag = 1 ; ihevcd_parse_pic_timing_sei ( ps_codec , ps_sps ) ; break ; case SEI_TIME_CODE : ps_parse -> s_sei_params . i1_sei_parameters_present_flag = 1 ; ihevcd_parse_time_code_sei ( ps_codec ) ; break ; case SEI_MASTERING_DISPLAY_COLOUR_VOLUME : ps_parse -> s_sei_params . i4_sei_mastering_disp_colour_vol_params_present_flags = 1 ; ihevcd_parse_mastering_disp_params_sei ( ps_codec ) ; break ; case SEI_USER_DATA_REGISTERED_ITU_T_T35 : ps_parse -> s_sei_params . i1_sei_parameters_present_flag = 1 ; <S2SV_StartBug> ihevcd_parse_user_data_registered_itu_t_t35 ( ps_codec , <S2SV_EndBug> <S2SV_StartBug> u4_payload_size ) ; <S2SV_EndBug> break ; default : for ( i = 0 ; i < u4_payload_size ; i ++ ) { ihevcd_bits_flush ( ps_bitstrm , 8 ) ; } break ; } } else { switch ( u4_payload_type ) { case SEI_USER_DATA_REGISTERED_ITU_T_T35 : ps_parse -> s_sei_params . i1_sei_parameters_present_flag = 1 ; <S2SV_StartBug> ihevcd_parse_user_data_registered_itu_t_t35 ( ps_codec , <S2SV_EndBug> <S2SV_StartBug> u4_payload_size ) ; <S2SV_EndBug> break ; default : for ( i = 0 ; i < u4_payload_size ; i ++ ) { ihevcd_bits_flush ( ps_bitstrm , 8 ) ; } break ; } } payload_bits_remaining = ihevcd_bits_num_bits_remaining ( ps_bitstrm ) ; if ( payload_bits_remaining ) { WORD32 final_bits ; WORD32 final_payload_bits = 0 ; WORD32 mask = 0xFF ; UWORD32 u4_dummy ; UWORD32 u4_reserved_payload_extension_data ; UNUSED ( u4_dummy ) ; UNUSED ( u4_reserved_payload_extension_data ) ; while ( payload_bits_remaining > 9 ) { BITS_PARSE ( "reserved_payload_extension_data" , u4_reserved_payload_extension_data , ps_bitstrm , 1 ) ; payload_bits_remaining -- ; } final_bits = ihevcd_bits_nxt ( ps_bitstrm , payload_bits_remaining ) ; while ( final_bits & ( mask >> final_payload_bits ) ) { final_payload_bits ++ ; continue ; } while ( payload_bits_remaining > ( 9 - final_payload_bits ) ) { BITS_PARSE ( "reserved_payload_extension_data" , u4_reserved_payload_extension_data , ps_bitstrm , 1 ) ; payload_bits_remaining -- ; } BITS_PARSE ( "payload_bit_equal_to_one" , u4_dummy , ps_bitstrm , 1 ) ; payload_bits_remaining -- ; while ( payload_bits_remaining ) { BITS_PARSE ( "payload_bit_equal_to_zero" , u4_dummy , ps_bitstrm , 1 ) ; payload_bits_remaining -- ; } } return ; }
CWE-200 IMPEG2D_ERROR_CODES_T impeg2d_dec_pic_hdr ( dec_state_t * ps_dec ) { stream_t * ps_stream ; ps_stream = & ps_dec -> s_bit_stream ; impeg2d_bit_stream_flush ( ps_stream , START_CODE_LEN ) ; impeg2d_bit_stream_get ( ps_stream , 10 ) ; ps_dec -> e_pic_type = ( e_pic_type_t ) impeg2d_bit_stream_get ( ps_stream , 3 ) ; if ( ( ps_dec -> e_pic_type < I_PIC ) || ( ps_dec -> e_pic_type > D_PIC ) ) { impeg2d_next_code ( ps_dec , PICTURE_START_CODE ) ; return IMPEG2D_INVALID_PIC_TYPE ; } impeg2d_bit_stream_get ( ps_stream , 16 ) ; if ( ps_dec -> e_pic_type == P_PIC || ps_dec -> e_pic_type == B_PIC ) { ps_dec -> u2_full_pel_forw_vector = impeg2d_bit_stream_get_bit ( ps_stream ) ; ps_dec -> u2_forw_f_code = impeg2d_bit_stream_get ( ps_stream , 3 ) ; } if ( ps_dec -> e_pic_type == B_PIC ) { ps_dec -> u2_full_pel_back_vector = impeg2d_bit_stream_get_bit ( ps_stream ) ; ps_dec -> u2_back_f_code = impeg2d_bit_stream_get ( ps_stream , 3 ) ; } if ( ps_dec -> u2_is_mpeg2 == 0 ) { <S2SV_StartBug> ps_dec -> au2_f_code [ 0 ] [ 0 ] = ps_dec -> au2_f_code [ 0 ] [ 1 ] = ps_dec -> u2_forw_f_code ; <S2SV_EndBug> ps_dec -> au2_f_code [ 1 ] [ 0 ] = ps_dec -> au2_f_code [ 1 ] [ 1 ] = ps_dec -> u2_back_f_code ; } while ( impeg2d_bit_stream_nxt ( ps_stream , 1 ) == 1 && ps_stream -> u4_offset < ps_stream -> u4_max_offset ) { impeg2d_bit_stream_get ( ps_stream , 9 ) ; } impeg2d_bit_stream_get_bit ( ps_stream ) ; impeg2d_next_start_code ( ps_dec ) ; return ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE ; }
CWE-200 IMPEG2D_ERROR_CODES_T impeg2d_init_video_state ( dec_state_t * ps_dec , e_video_type_t e_video_type ) { if ( e_video_type == MPEG_1_VIDEO ) { ps_dec -> u2_is_mpeg2 = 0 ; ps_dec -> u2_progressive_sequence = 1 ; ps_dec -> u2_intra_dc_precision = 0 ; ps_dec -> u2_picture_structure = FRAME_PICTURE ; ps_dec -> u2_frame_pred_frame_dct = 1 ; ps_dec -> u2_concealment_motion_vectors = 0 ; ps_dec -> u2_q_scale_type = 0 ; ps_dec -> u2_intra_vlc_format = 0 ; ps_dec -> u2_alternate_scan = 0 ; ps_dec -> u2_repeat_first_field = 0 ; ps_dec -> u2_progressive_frame = 1 ; ps_dec -> u2_frame_rate_extension_n = 0 ; ps_dec -> u2_frame_rate_extension_d = 0 ; <S2SV_StartBug> ps_dec -> pf_vld_inv_quant = impeg2d_vld_inv_quant_mpeg1 ; <S2SV_EndBug> } else { ps_dec -> u2_is_mpeg2 = 1 ; ps_dec -> u2_full_pel_forw_vector = 0 ; ps_dec -> u2_forw_f_code = 7 ; ps_dec -> u2_full_pel_back_vector = 0 ; ps_dec -> u2_back_f_code = 7 ; ps_dec -> pf_vld_inv_quant = impeg2d_vld_inv_quant_mpeg2 ; } impeg2d_init_function_ptr ( ps_dec ) ; ps_dec -> u2_frame_height = ALIGN16 ( ps_dec -> u2_vertical_size ) ; ps_dec -> u2_frame_width = ALIGN16 ( ps_dec -> u2_horizontal_size ) ; ps_dec -> u2_num_horiz_mb = ( ps_dec -> u2_horizontal_size + 15 ) >> 4 ; if ( ps_dec -> u2_frame_height > ps_dec -> u2_create_max_height || ps_dec -> u2_frame_width > ps_dec -> u2_create_max_width ) { return IMPEG2D_PIC_SIZE_NOT_SUPPORTED ; } ps_dec -> u2_num_flds_decoded = 0 ; { UWORD32 numer ; UWORD32 denom ; numer = ( UWORD32 ) gau2_impeg2_frm_rate_code [ ps_dec -> u2_frame_rate_code ] [ 1 ] * ( UWORD32 ) ( ps_dec -> u2_frame_rate_extension_d + 1 ) ; denom = ( UWORD32 ) gau2_impeg2_frm_rate_code [ ps_dec -> u2_frame_rate_code ] [ 0 ] * ( UWORD32 ) ( ps_dec -> u2_frame_rate_extension_n + 1 ) ; ps_dec -> u2_framePeriod = ( numer * 1000 * 100 ) / denom ; } if ( VERTICAL_SCAN == ps_dec -> u2_alternate_scan ) { ps_dec -> pu1_inv_scan_matrix = ( UWORD8 * ) gau1_impeg2_inv_scan_vertical ; } else { ps_dec -> pu1_inv_scan_matrix = ( UWORD8 * ) gau1_impeg2_inv_scan_zig_zag ; } return ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE ; }
CWE-787 IMPEG2D_ERROR_CODES_T impeg2d_dec_seq_hdr ( dec_state_t * ps_dec ) { stream_t * ps_stream ; ps_stream = & ps_dec -> s_bit_stream ; UWORD16 u2_height ; UWORD16 u2_width ; if ( impeg2d_bit_stream_nxt ( ps_stream , START_CODE_LEN ) != SEQUENCE_HEADER_CODE ) { impeg2d_bit_stream_flush ( ps_stream , START_CODE_LEN ) ; return IMPEG2D_FRM_HDR_START_CODE_NOT_FOUND ; } impeg2d_bit_stream_flush ( ps_stream , START_CODE_LEN ) ; u2_width = impeg2d_bit_stream_get ( ps_stream , 12 ) ; u2_height = impeg2d_bit_stream_get ( ps_stream , 12 ) ; if ( 0 == u2_width || 0 == u2_height ) { IMPEG2D_ERROR_CODES_T e_error = IMPEG2D_FRM_HDR_DECODE_ERR ; return e_error ; } if ( ( u2_width != ps_dec -> u2_horizontal_size ) || ( u2_height != ps_dec -> u2_vertical_size ) ) { if ( 0 == ps_dec -> u2_header_done ) { ps_dec -> u2_horizontal_size = u2_width ; ps_dec -> u2_vertical_size = u2_height ; <S2SV_StartBug> if ( 0 == ps_dec -> u4_frm_buf_stride ) <S2SV_EndBug> { ps_dec -> u4_frm_buf_stride = ( UWORD32 ) ( u2_width ) ; } } else { if ( 0 == ps_dec -> i4_pic_count ) { return ( IMPEG2D_ERROR_CODES_T ) IMPEG2D_FRM_HDR_DECODE_ERR ; } <S2SV_StartBug> else if ( ( u2_width > ps_dec -> u2_create_max_width ) <S2SV_EndBug> <S2SV_StartBug> || ( u2_height > ps_dec -> u2_create_max_height ) ) <S2SV_EndBug> { IMPEG2D_ERROR_CODES_T e_error = IMPEG2D_UNSUPPORTED_DIMENSIONS ; ps_dec -> u2_reinit_max_height = u2_height ; ps_dec -> u2_reinit_max_width = u2_width ; return e_error ; } else { return ( IMPEG2D_ERROR_CODES_T ) IVD_RES_CHANGED ; } } } if ( ( ps_dec -> u2_horizontal_size > ps_dec -> u2_create_max_width ) || ( ps_dec -> u2_vertical_size > ps_dec -> u2_create_max_height ) ) { IMPEG2D_ERROR_CODES_T e_error = IMPEG2D_UNSUPPORTED_DIMENSIONS ; ps_dec -> u2_reinit_max_height = ps_dec -> u2_vertical_size ; ps_dec -> u2_reinit_max_width = ps_dec -> u2_horizontal_size ; <S2SV_StartBug> return e_error ; <S2SV_EndBug> } ps_dec -> u2_aspect_ratio_info = impeg2d_bit_stream_get ( ps_stream , 4 ) ; ps_dec -> u2_frame_rate_code = impeg2d_bit_stream_get ( ps_stream , 4 ) ; if ( ps_dec -> u2_frame_rate_code > MPEG2_MAX_FRAME_RATE_CODE ) { return IMPEG2D_FRM_HDR_DECODE_ERR ; } impeg2d_bit_stream_flush ( ps_stream , 18 ) ; GET_MARKER_BIT ( ps_dec , ps_stream ) ; impeg2d_bit_stream_flush ( ps_stream , 11 ) ; if ( impeg2d_bit_stream_get_bit ( ps_stream ) == 1 ) { UWORD16 i ; for ( i = 0 ; i < NUM_PELS_IN_BLOCK ; i ++ ) { ps_dec -> au1_intra_quant_matrix [ gau1_impeg2_inv_scan_zig_zag [ i ] ] = ( UWORD8 ) impeg2d_bit_stream_get ( ps_stream , 8 ) ; } } else { memcpy ( ps_dec -> au1_intra_quant_matrix , gau1_impeg2_intra_quant_matrix_default , NUM_PELS_IN_BLOCK ) ; } if ( impeg2d_bit_stream_get_bit ( ps_stream ) == 1 ) { UWORD16 i ; for ( i = 0 ; i < NUM_PELS_IN_BLOCK ; i ++ ) { ps_dec -> au1_inter_quant_matrix [ gau1_impeg2_inv_scan_zig_zag [ i ] ] = ( UWORD8 ) impeg2d_bit_stream_get ( ps_stream , 8 ) ; } } else { memcpy ( ps_dec -> au1_inter_quant_matrix , gau1_impeg2_inter_quant_matrix_default , NUM_PELS_IN_BLOCK ) ; } impeg2d_next_start_code ( ps_dec ) ; return ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE ; }
CWE-787 void impeg2d_dec_hdr ( void * pv_dec , impeg2d_video_decode_ip_t * ps_ip , impeg2d_video_decode_op_t * ps_op ) { UWORD32 u4_bits_read ; dec_state_t * ps_dec ; UWORD32 u4_size = ps_ip -> s_ivd_video_decode_ip_t . u4_num_Bytes ; ps_dec = ( dec_state_t * ) pv_dec ; ps_op -> s_ivd_video_decode_op_t . u4_error_code = 0 ; if ( u4_size > MAX_BITSTREAM_BUFFER_SIZE ) { u4_size = MAX_BITSTREAM_BUFFER_SIZE ; } memcpy ( ps_dec -> pu1_input_buffer , ps_ip -> s_ivd_video_decode_ip_t . pv_stream_buffer , u4_size ) ; impeg2d_bit_stream_init ( & ( ps_dec -> s_bit_stream ) , ps_dec -> pu1_input_buffer , u4_size ) ; { { IMPEG2D_ERROR_CODES_T e_error ; e_error = impeg2d_process_video_header ( ps_dec ) ; if ( ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE != e_error ) { ps_op -> s_ivd_video_decode_op_t . u4_error_code = e_error ; u4_bits_read = impeg2d_bit_stream_num_bits_read ( & ps_dec -> s_bit_stream ) ; ps_op -> s_ivd_video_decode_op_t . u4_num_bytes_consumed = u4_bits_read >> 3 ; if ( ps_op -> s_ivd_video_decode_op_t . u4_num_bytes_consumed > ps_ip -> s_ivd_video_decode_ip_t . u4_num_Bytes ) { ps_op -> s_ivd_video_decode_op_t . u4_num_bytes_consumed = ps_ip -> s_ivd_video_decode_ip_t . u4_num_Bytes ; } if ( ps_op -> s_ivd_video_decode_op_t . u4_error_code == 0 ) ps_op -> s_ivd_video_decode_op_t . u4_error_code = e_error ; if ( IMPEG2D_UNSUPPORTED_DIMENSIONS == e_error ) { ps_op -> s_ivd_video_decode_op_t . u4_num_bytes_consumed = 0 ; ps_dec -> u2_header_done = 0 ; ps_op -> s_ivd_video_decode_op_t . u4_pic_ht = ps_dec -> u2_reinit_max_height ; ps_op -> s_ivd_video_decode_op_t . u4_pic_wd = ps_dec -> u2_reinit_max_width ; } impeg2d_next_code ( ps_dec , SEQUENCE_HEADER_CODE ) ; return ; } } ps_op -> s_ivd_video_decode_op_t . u4_pic_ht = ps_dec -> u2_vertical_size ; ps_op -> s_ivd_video_decode_op_t . u4_pic_wd = ps_dec -> u2_horizontal_size ; ps_op -> s_ivd_video_decode_op_t . e_pic_type = IV_NA_FRAME ; ps_op -> s_ivd_video_decode_op_t . u4_error_code = IV_SUCCESS ; u4_bits_read = impeg2d_bit_stream_num_bits_read ( & ps_dec -> s_bit_stream ) ; ps_op -> s_ivd_video_decode_op_t . u4_num_bytes_consumed = u4_bits_read >> 3 ; if ( ps_op -> s_ivd_video_decode_op_t . u4_num_bytes_consumed > ps_ip -> s_ivd_video_decode_ip_t . u4_num_Bytes ) { ps_op -> s_ivd_video_decode_op_t . u4_num_bytes_consumed = ps_ip -> s_ivd_video_decode_ip_t . u4_num_Bytes ; } ps_op -> s_ivd_video_decode_op_t . u4_frame_decoded_flag = 0 ; <S2SV_StartBug> ps_dec -> u2_header_done = 1 ; <S2SV_EndBug> } }
CWE-20 static vpx_image_t * img_alloc_helper ( vpx_image_t * img , vpx_img_fmt_t fmt , unsigned int d_w , unsigned int d_h , unsigned int buf_align , unsigned int stride_align , unsigned char * img_data ) { unsigned int h , w , s , xcs , ycs , bps ; unsigned int stride_in_bytes ; int align ; if ( ! buf_align ) buf_align = 1 ; if ( buf_align & ( buf_align - 1 ) ) goto fail ; if ( ! stride_align ) stride_align = 1 ; if ( stride_align & ( stride_align - 1 ) ) goto fail ; switch ( fmt ) { case VPX_IMG_FMT_RGB32 : case VPX_IMG_FMT_RGB32_LE : case VPX_IMG_FMT_ARGB : case VPX_IMG_FMT_ARGB_LE : bps = 32 ; break ; case VPX_IMG_FMT_RGB24 : case VPX_IMG_FMT_BGR24 : bps = 24 ; break ; case VPX_IMG_FMT_RGB565 : case VPX_IMG_FMT_RGB565_LE : case VPX_IMG_FMT_RGB555 : case VPX_IMG_FMT_RGB555_LE : case VPX_IMG_FMT_UYVY : case VPX_IMG_FMT_YUY2 : case VPX_IMG_FMT_YVYU : bps = 16 ; break ; case VPX_IMG_FMT_I420 : case VPX_IMG_FMT_YV12 : case VPX_IMG_FMT_VPXI420 : case VPX_IMG_FMT_VPXYV12 : bps = 12 ; break ; case VPX_IMG_FMT_I422 : case VPX_IMG_FMT_I440 : bps = 16 ; break ; case VPX_IMG_FMT_I444 : bps = 24 ; break ; case VPX_IMG_FMT_I42016 : bps = 24 ; break ; case VPX_IMG_FMT_I42216 : case VPX_IMG_FMT_I44016 : bps = 32 ; break ; case VPX_IMG_FMT_I44416 : bps = 48 ; break ; default : bps = 16 ; break ; } switch ( fmt ) { case VPX_IMG_FMT_I420 : case VPX_IMG_FMT_YV12 : case VPX_IMG_FMT_VPXI420 : case VPX_IMG_FMT_VPXYV12 : case VPX_IMG_FMT_I422 : case VPX_IMG_FMT_I42016 : case VPX_IMG_FMT_I42216 : xcs = 1 ; break ; default : xcs = 0 ; break ; } switch ( fmt ) { case VPX_IMG_FMT_I420 : case VPX_IMG_FMT_I440 : case VPX_IMG_FMT_YV12 : case VPX_IMG_FMT_VPXI420 : case VPX_IMG_FMT_VPXYV12 : case VPX_IMG_FMT_I42016 : case VPX_IMG_FMT_I44016 : ycs = 1 ; break ; default : ycs = 0 ; break ; } <S2SV_StartBug> align = ( 1 << xcs ) - 1 ; <S2SV_EndBug> w = ( d_w + align ) & ~ align ; align = ( 1 << ycs ) - 1 ; h = ( d_h + align ) & ~ align ; s = ( fmt & VPX_IMG_FMT_PLANAR ) ? w : bps * w / 8 ; s = ( s + stride_align - 1 ) & ~ ( stride_align - 1 ) ; stride_in_bytes = ( fmt & VPX_IMG_FMT_HIGHBITDEPTH ) ? s * 2 : s ; <S2SV_StartBug> if ( ! img ) { <S2SV_EndBug> img = ( vpx_image_t * ) calloc ( 1 , sizeof ( vpx_image_t ) ) ; if ( ! img ) goto fail ; img -> self_allocd = 1 ; } else { memset ( img , 0 , sizeof ( vpx_image_t ) ) ; } img -> img_data = img_data ; if ( ! img_data ) { const uint64_t alloc_size = ( fmt & VPX_IMG_FMT_PLANAR ) ? ( uint64_t ) h * s * bps / 8 : ( uint64_t ) h * s ; if ( alloc_size != ( size_t ) alloc_size ) goto fail ; img -> img_data = ( uint8_t * ) vpx_memalign ( buf_align , ( size_t ) alloc_size ) ; img -> img_data_owner = 1 ; } if ( ! img -> img_data ) goto fail ; img -> fmt = fmt ; img -> bit_depth = ( fmt & VPX_IMG_FMT_HIGHBITDEPTH ) ? 16 : 8 ; img -> w = w ; img -> h = h ; img -> x_chroma_shift = xcs ; img -> y_chroma_shift = ycs ; img -> bps = bps ; img -> stride [ VPX_PLANE_Y ] = img -> stride [ VPX_PLANE_ALPHA ] = stride_in_bytes ; img -> stride [ VPX_PLANE_U ] = img -> stride [ VPX_PLANE_V ] = stride_in_bytes >> xcs ; if ( ! vpx_img_set_rect ( img , 0 , 0 , d_w , d_h ) ) return img ; fail : vpx_img_free ( img ) ; return NULL ; }
CWE-787 VOID ixheaacd_esbr_postradixcompute2 ( WORD32 * ptr_y , WORD32 * ptr_x , const WORD32 * pdig_rev_tbl , WORD32 npoints ) { WORD32 i , k ; WORD32 h2 ; WORD32 x_0 , x_1 , x_2 , x_3 ; WORD32 x_4 , x_5 , x_6 , x_7 ; <S2SV_StartBug> WORD32 x_8 , x_9 , x_a , x_b , x_c , x_d , x_e , x_f ; <S2SV_EndBug> WORD32 n00 , n10 , n20 , n30 , n01 , n11 , n21 , n31 ; WORD32 n02 , n12 , n22 , n32 , n03 , n13 , n23 , n33 ; WORD32 n0 , j0 ; WORD32 * x2 , * x0 ; WORD32 * y0 , * y1 , * y2 , * y3 ; y0 = ptr_y ; y2 = ptr_y + ( WORD32 ) npoints ; x0 = ptr_x ; x2 = ptr_x + ( WORD32 ) ( npoints >> 1 ) ; y1 = y0 + ( WORD32 ) ( npoints >> 2 ) ; y3 = y2 + ( WORD32 ) ( npoints >> 2 ) ; j0 = 8 ; n0 = npoints >> 1 ; for ( k = 0 ; k < 2 ; k ++ ) { for ( i = 0 ; i < npoints >> 1 ; i += 8 ) { h2 = * pdig_rev_tbl ++ >> 2 ; x_0 = * x0 ++ ; x_1 = * x0 ++ ; x_2 = * x0 ++ ; x_3 = * x0 ++ ; x_4 = * x0 ++ ; x_5 = * x0 ++ ; x_6 = * x0 ++ ; x_7 = * x0 ++ ; <S2SV_StartBug> n00 = x_0 + x_2 ; <S2SV_EndBug> n01 = x_1 + x_3 ; n20 = x_0 - x_2 ; n21 = x_1 - x_3 ; n10 = x_4 + x_6 ; n11 = x_5 + x_7 ; n30 = x_4 - x_6 ; n31 = x_5 - x_7 ; y0 [ h2 ] = n00 ; y0 [ h2 + 1 ] = n01 ; <S2SV_StartBug> y1 [ h2 ] = n10 ; <S2SV_EndBug> <S2SV_StartBug> y1 [ h2 + 1 ] = n11 ; <S2SV_EndBug> y2 [ h2 ] = n20 ; y2 [ h2 + 1 ] = n21 ; <S2SV_StartBug> y3 [ h2 ] = n30 ; <S2SV_EndBug> <S2SV_StartBug> y3 [ h2 + 1 ] = n31 ; <S2SV_EndBug> x_8 = * x2 ++ ; x_9 = * x2 ++ ; x_a = * x2 ++ ; x_b = * x2 ++ ; x_c = * x2 ++ ; x_d = * x2 ++ ; x_e = * x2 ++ ; x_f = * x2 ++ ; n02 = x_8 + x_a ; n03 = x_9 + x_b ; n22 = x_8 - x_a ; n23 = x_9 - x_b ; n12 = x_c + x_e ; n13 = x_d + x_f ; n32 = x_c - x_e ; n33 = x_d - x_f ; y0 [ h2 + 2 ] = n02 ; y0 [ h2 + 3 ] = n03 ; y1 [ h2 + 2 ] = n12 ; y1 [ h2 + 3 ] = n13 ; y2 [ h2 + 2 ] = n22 ; y2 [ h2 + 3 ] = n23 ; y3 [ h2 + 2 ] = n32 ; y3 [ h2 + 3 ] = n33 ; } x0 += ( WORD32 ) npoints >> 1 ; x2 += ( WORD32 ) npoints >> 1 ; } }
CWE-787 VOID ixheaacd_esbr_radix4bfly ( const WORD32 * w , WORD32 * x , WORD32 index1 , WORD32 index ) { int i ; WORD32 l1 , l2 , h2 , fft_jmp ; <S2SV_StartBug> WORD32 xt0_0 , yt0_0 , xt1_0 , yt1_0 , xt2_0 , yt2_0 ; <S2SV_EndBug> <S2SV_StartBug> WORD32 xh0_0 , xh1_0 , xh20_0 , xh21_0 , xl0_0 , xl1_0 , xl20_0 , xl21_0 ; <S2SV_EndBug> WORD32 x_0 , x_1 , x_l1_0 , x_l1_1 , x_l2_0 , x_l2_1 ; WORD32 x_h2_0 , x_h2_1 ; WORD32 si10 , si20 , si30 , co10 , co20 , co30 ; WORD64 mul_1 , mul_2 , mul_3 , mul_4 , mul_5 , mul_6 ; WORD64 mul_7 , mul_8 , mul_9 , mul_10 , mul_11 , mul_12 ; WORD32 * x_l1 ; WORD32 * x_l2 ; WORD32 * x_h2 ; const WORD32 * w_ptr = w ; WORD32 i1 ; h2 = index << 1 ; l1 = index << 2 ; l2 = ( index << 2 ) + ( index << 1 ) ; x_l1 = & ( x [ l1 ] ) ; x_l2 = & ( x [ l2 ] ) ; x_h2 = & ( x [ h2 ] ) ; fft_jmp = 6 * ( index ) ; for ( i1 = 0 ; i1 < index1 ; i1 ++ ) { for ( i = 0 ; i < index ; i ++ ) { si10 = ( * w_ptr ++ ) ; co10 = ( * w_ptr ++ ) ; si20 = ( * w_ptr ++ ) ; co20 = ( * w_ptr ++ ) ; si30 = ( * w_ptr ++ ) ; co30 = ( * w_ptr ++ ) ; x_0 = x [ 0 ] ; x_h2_0 = x [ h2 ] ; x_l1_0 = x [ l1 ] ; x_l2_0 = x [ l2 ] ; <S2SV_StartBug> xh0_0 = x_0 + x_l1_0 ; <S2SV_EndBug> <S2SV_StartBug> xl0_0 = x_0 - x_l1_0 ; <S2SV_EndBug> <S2SV_StartBug> xh20_0 = x_h2_0 + x_l2_0 ; <S2SV_EndBug> <S2SV_StartBug> xl20_0 = x_h2_0 - x_l2_0 ; <S2SV_EndBug> <S2SV_StartBug> x [ 0 ] = xh0_0 + xh20_0 ; <S2SV_EndBug> <S2SV_StartBug> xt0_0 = xh0_0 - xh20_0 ; <S2SV_EndBug> x_1 = x [ 1 ] ; x_h2_1 = x [ h2 + 1 ] ; x_l1_1 = x [ l1 + 1 ] ; x_l2_1 = x [ l2 + 1 ] ; <S2SV_StartBug> xh1_0 = x_1 + x_l1_1 ; <S2SV_EndBug> <S2SV_StartBug> xl1_0 = x_1 - x_l1_1 ; <S2SV_EndBug> <S2SV_StartBug> xh21_0 = x_h2_1 + x_l2_1 ; <S2SV_EndBug> <S2SV_StartBug> xl21_0 = x_h2_1 - x_l2_1 ; <S2SV_EndBug> <S2SV_StartBug> x [ 1 ] = xh1_0 + xh21_0 ; <S2SV_EndBug> <S2SV_StartBug> yt0_0 = xh1_0 - xh21_0 ; <S2SV_EndBug> <S2SV_StartBug> xt1_0 = xl0_0 + xl21_0 ; <S2SV_EndBug> <S2SV_StartBug> xt2_0 = xl0_0 - xl21_0 ; <S2SV_EndBug> <S2SV_StartBug> yt2_0 = xl1_0 + xl20_0 ; <S2SV_EndBug> <S2SV_StartBug> yt1_0 = xl1_0 - xl20_0 ; <S2SV_EndBug> mul_11 = ixheaacd_mult64 ( xt2_0 , co30 ) ; mul_3 = ixheaacd_mult64 ( yt2_0 , si30 ) ; x [ l2 ] = ( WORD32 ) ( ( mul_3 + mul_11 ) >> 32 ) << RADIXSHIFT ; mul_5 = ixheaacd_mult64 ( xt2_0 , si30 ) ; mul_9 = ixheaacd_mult64 ( yt2_0 , co30 ) ; x [ l2 + 1 ] = ( WORD32 ) ( ( mul_9 - mul_5 ) >> 32 ) << RADIXSHIFT ; mul_12 = ixheaacd_mult64 ( xt0_0 , co20 ) ; mul_2 = ixheaacd_mult64 ( yt0_0 , si20 ) ; x [ l1 ] = ( WORD32 ) ( ( mul_2 + mul_12 ) >> 32 ) << RADIXSHIFT ; mul_6 = ixheaacd_mult64 ( xt0_0 , si20 ) ; mul_8 = ixheaacd_mult64 ( yt0_0 , co20 ) ; x [ l1 + 1 ] = ( WORD32 ) ( ( mul_8 - mul_6 ) >> 32 ) << RADIXSHIFT ; mul_4 = ixheaacd_mult64 ( xt1_0 , co10 ) ; mul_1 = ixheaacd_mult64 ( yt1_0 , si10 ) ; x [ h2 ] = ( WORD32 ) ( ( mul_1 + mul_4 ) >> 32 ) << RADIXSHIFT ; mul_10 = ixheaacd_mult64 ( xt1_0 , si10 ) ; mul_7 = ixheaacd_mult64 ( yt1_0 , co10 ) ; x [ h2 + 1 ] = ( WORD32 ) ( ( mul_7 - mul_10 ) >> 32 ) << RADIXSHIFT ; x += 2 ; } x += fft_jmp ; w_ptr = w_ptr - fft_jmp ; } }
CWE-787 VOID ixheaacd_shiftrountine_with_rnd_hq ( WORD32 * qmf_real , WORD32 * qmf_imag , WORD32 * filter_states , WORD32 len , WORD32 shift ) { WORD32 * filter_states_rev = filter_states + len ; WORD32 treal , timag ; WORD32 j ; for ( j = ( len - 1 ) ; j >= 0 ; j -= 2 ) { WORD32 r1 , r2 , i1 , i2 ; i2 = qmf_imag [ j ] ; r2 = qmf_real [ j ] ; r1 = * qmf_real ++ ; i1 = * qmf_imag ++ ; <S2SV_StartBug> timag = ixheaacd_add32 ( i1 , r1 ) ; <S2SV_EndBug> timag = ( ixheaacd_shl32_sat ( timag , shift ) ) ; filter_states_rev [ j ] = timag ; <S2SV_StartBug> treal = ixheaacd_sub32 ( i2 , r2 ) ; <S2SV_EndBug> treal = ( ixheaacd_shl32_sat ( treal , shift ) ) ; filter_states [ j ] = treal ; treal = ixheaacd_sub32 ( i1 , r1 ) ; treal = ( ixheaacd_shl32_sat ( treal , shift ) ) ; * filter_states ++ = treal ; timag = ixheaacd_add32 ( i2 , r2 ) ; timag = ( ixheaacd_shl32_sat ( timag , shift ) ) ; * filter_states_rev ++ = timag ; } }
CWE-787 WORD32 ixheaacd_complex_anal_filt ( ia_esbr_hbe_txposer_struct * ptr_hbe_txposer ) { WORD32 idx ; WORD32 anal_size = 2 * ptr_hbe_txposer -> synth_size ; WORD32 N = ( 10 * anal_size ) ; for ( idx = 0 ; idx < ( ptr_hbe_txposer -> no_bins >> 1 ) ; idx ++ ) { WORD32 i , j , k , l ; FLOAT32 window_output [ 640 ] ; FLOAT32 u [ 128 ] , u_in [ 256 ] , u_out [ 256 ] ; FLOAT32 accu_r , accu_i ; const FLOAT32 * inp_signal ; FLOAT32 * anal_buf ; FLOAT32 * analy_cos_sin_tab = ptr_hbe_txposer -> analy_cos_sin_tab ; const FLOAT32 * interp_window_coeff = ptr_hbe_txposer -> analy_wind_coeff ; FLOAT32 * x = ptr_hbe_txposer -> analy_buf ; memset ( ptr_hbe_txposer -> qmf_in_buf [ idx + HBE_OPER_WIN_LEN - 1 ] , 0 , TWICE_QMF_SYNTH_CHANNELS_NUM * sizeof ( FLOAT32 ) ) ; inp_signal = ptr_hbe_txposer -> ptr_input_buf + idx * 2 * ptr_hbe_txposer -> synth_size + 1 ; anal_buf = & ptr_hbe_txposer -> qmf_in_buf [ idx + HBE_OPER_WIN_LEN - 1 ] [ 4 * ptr_hbe_txposer -> k_start ] ; for ( i = N - 1 ; i >= anal_size ; i -- ) { x [ i ] = x [ i - anal_size ] ; } for ( i = anal_size - 1 ; i >= 0 ; i -- ) { x [ i ] = inp_signal [ anal_size - 1 - i ] ; } for ( i = 0 ; i < N ; i ++ ) { window_output [ i ] = x [ i ] * interp_window_coeff [ i ] ; } for ( i = 0 ; i < 2 * anal_size ; i ++ ) { accu_r = 0.0 ; for ( j = 0 ; j < 5 ; j ++ ) { accu_r = accu_r + window_output [ i + j * 2 * anal_size ] ; } u [ i ] = accu_r ; } if ( anal_size == 40 ) { for ( i = 1 ; i < anal_size ; i ++ ) { FLOAT32 temp1 = u [ i ] + u [ 2 * anal_size - i ] ; FLOAT32 temp2 = u [ i ] - u [ 2 * anal_size - i ] ; u [ i ] = temp1 ; u [ 2 * anal_size - i ] = temp2 ; } for ( k = 0 ; k < anal_size ; k ++ ) { accu_r = u [ anal_size ] ; if ( k & 1 ) accu_i = u [ 0 ] ; else accu_i = - u [ 0 ] ; for ( l = 1 ; l < anal_size ; l ++ ) { accu_r = accu_r + u [ 0 + l ] * analy_cos_sin_tab [ 2 * l + 0 ] ; accu_i = accu_i + u [ 2 * anal_size - l ] * analy_cos_sin_tab [ 2 * l + 1 ] ; } analy_cos_sin_tab += ( 2 * anal_size ) ; * anal_buf ++ = ( FLOAT32 ) accu_r ; * anal_buf ++ = ( FLOAT32 ) accu_i ; } } else { FLOAT32 * ptr_u = u_in ; FLOAT32 * ptr_v = u_out ; for ( k = 0 ; k < anal_size * 2 ; k ++ ) { * ptr_u ++ = ( ( * analy_cos_sin_tab ++ ) * u [ k ] ) ; * ptr_u ++ = ( ( * analy_cos_sin_tab ++ ) * u [ k ] ) ; } <S2SV_StartBug> if ( ixheaacd_cmplx_anal_fft != NULL ) <S2SV_EndBug> <S2SV_StartBug> ( * ixheaacd_cmplx_anal_fft ) ( u_in , u_out , anal_size * 2 ) ; <S2SV_EndBug> else return - 1 ; for ( k = 0 ; k < anal_size / 2 ; k ++ ) { * ( anal_buf + 1 ) = - * ptr_v ++ ; * anal_buf = * ptr_v ++ ; anal_buf += 2 ; * ( anal_buf + 1 ) = * ptr_v ++ ; * anal_buf = - * ptr_v ++ ; anal_buf += 2 ; } } } return 0 ; }
CWE-787 WORD32 ixheaacd_real_synth_filt ( ia_esbr_hbe_txposer_struct * ptr_hbe_txposer , WORD32 num_columns , FLOAT32 qmf_buf_real [ ] [ 64 ] , FLOAT32 qmf_buf_imag [ ] [ 64 ] ) { WORD32 i , j , k , l , idx ; FLOAT32 g [ 640 ] ; FLOAT32 w [ 640 ] ; FLOAT32 synth_out [ 128 ] ; FLOAT32 accu_r ; WORD32 synth_size = ptr_hbe_txposer -> synth_size ; FLOAT32 * ptr_cos_tab_trans_qmf = ( FLOAT32 * ) & ixheaacd_cos_table_trans_qmf [ 0 ] [ 0 ] + ptr_hbe_txposer -> k_start * 32 ; FLOAT32 * buffer = ptr_hbe_txposer -> synth_buf ; for ( idx = 0 ; idx < num_columns ; idx ++ ) { FLOAT32 loc_qmf_buf [ 64 ] ; FLOAT32 * synth_buf_r = loc_qmf_buf ; FLOAT32 * out_buf = ptr_hbe_txposer -> ptr_input_buf + ( idx + 1 ) * ptr_hbe_txposer -> synth_size ; FLOAT32 * synth_cos_tab = ptr_hbe_txposer -> synth_cos_tab ; const FLOAT32 * interp_window_coeff = ptr_hbe_txposer -> synth_wind_coeff ; if ( ptr_hbe_txposer -> k_start < 0 ) return - 1 ; for ( k = 0 ; k < synth_size ; k ++ ) { WORD32 ki = ptr_hbe_txposer -> k_start + k ; synth_buf_r [ k ] = ( FLOAT32 ) ( ptr_cos_tab_trans_qmf [ ( k << 1 ) + 0 ] * qmf_buf_real [ idx ] [ ki ] + ptr_cos_tab_trans_qmf [ ( k << 1 ) + 1 ] * qmf_buf_imag [ idx ] [ ki ] ) ; synth_buf_r [ k + ptr_hbe_txposer -> synth_size ] = 0 ; } for ( l = ( 20 * synth_size - 1 ) ; l >= 2 * synth_size ; l -- ) { buffer [ l ] = buffer [ l - 2 * synth_size ] ; } if ( synth_size == 20 ) { FLOAT32 * psynth_cos_tab = synth_cos_tab ; for ( l = 0 ; l < ( synth_size + 1 ) ; l ++ ) { accu_r = 0.0 ; for ( k = 0 ; k < synth_size ; k ++ ) { accu_r += synth_buf_r [ k ] * psynth_cos_tab [ k ] ; } buffer [ 0 + l ] = accu_r ; buffer [ synth_size - l ] = accu_r ; psynth_cos_tab = psynth_cos_tab + synth_size ; } for ( l = ( synth_size + 1 ) ; l < ( 2 * synth_size - synth_size / 2 ) ; l ++ ) { accu_r = 0.0 ; for ( k = 0 ; k < synth_size ; k ++ ) { accu_r += synth_buf_r [ k ] * psynth_cos_tab [ k ] ; } buffer [ 0 + l ] = accu_r ; buffer [ 3 * synth_size - l ] = - accu_r ; psynth_cos_tab = psynth_cos_tab + synth_size ; } accu_r = 0.0 ; for ( k = 0 ; k < synth_size ; k ++ ) { accu_r += synth_buf_r [ k ] * psynth_cos_tab [ k ] ; } buffer [ 3 * synth_size >> 1 ] = accu_r ; } else { FLOAT32 tmp ; FLOAT32 * ptr_u = synth_out ; WORD32 kmax = ( synth_size >> 1 ) ; FLOAT32 * syn_buf = & buffer [ kmax ] ; kmax += synth_size ; <S2SV_StartBug> if ( ixheaacd_real_synth_fft != NULL ) <S2SV_EndBug> <S2SV_StartBug> ( * ixheaacd_real_synth_fft ) ( synth_buf_r , synth_out , synth_size * 2 ) ; <S2SV_EndBug> else return - 1 ; for ( k = 0 ; k < kmax ; k ++ ) { tmp = ( ( * ptr_u ++ ) * ( * synth_cos_tab ++ ) ) ; tmp -= ( ( * ptr_u ++ ) * ( * synth_cos_tab ++ ) ) ; * syn_buf ++ = tmp ; } syn_buf = & buffer [ 0 ] ; kmax -= synth_size ; for ( k = 0 ; k < kmax ; k ++ ) { tmp = ( ( * ptr_u ++ ) * ( * synth_cos_tab ++ ) ) ; tmp -= ( ( * ptr_u ++ ) * ( * synth_cos_tab ++ ) ) ; * syn_buf ++ = tmp ; } } for ( i = 0 ; i < 5 ; i ++ ) { memcpy ( & g [ ( 2 * i + 0 ) * synth_size ] , & buffer [ ( 4 * i + 0 ) * synth_size ] , sizeof ( FLOAT32 ) * synth_size ) ; memcpy ( & g [ ( 2 * i + 1 ) * synth_size ] , & buffer [ ( 4 * i + 3 ) * synth_size ] , sizeof ( FLOAT32 ) * synth_size ) ; } for ( k = 0 ; k < 10 * synth_size ; k ++ ) { w [ k ] = g [ k ] * interp_window_coeff [ k ] ; } for ( i = 0 ; i < synth_size ; i ++ ) { accu_r = 0.0 ; for ( j = 0 ; j < 10 ; j ++ ) { accu_r = accu_r + w [ synth_size * j + i ] ; } out_buf [ i ] = ( FLOAT32 ) accu_r ; } } return 0 ; }
CWE-787 WORD32 ixheaacd_qmf_hbe_data_reinit ( ia_esbr_hbe_txposer_struct * ptr_hbe_txposer , WORD16 * p_freq_band_tab [ 2 ] , WORD16 * p_num_sfb , WORD32 upsamp_4_flag ) { WORD32 synth_size , sfb , patch , stop_patch ; if ( ptr_hbe_txposer != NULL ) { ptr_hbe_txposer -> start_band = p_freq_band_tab [ LOW ] [ 0 ] ; ptr_hbe_txposer -> end_band = p_freq_band_tab [ LOW ] [ p_num_sfb [ LOW ] ] ; ptr_hbe_txposer -> synth_size = 4 * ( ( ptr_hbe_txposer -> start_band + 4 ) / 8 + 1 ) ; ptr_hbe_txposer -> k_start = ixheaacd_start_subband2kL_tbl [ ptr_hbe_txposer -> start_band ] ; ptr_hbe_txposer -> upsamp_4_flag = upsamp_4_flag ; if ( upsamp_4_flag ) { if ( ptr_hbe_txposer -> k_start + ptr_hbe_txposer -> synth_size > 16 ) ptr_hbe_txposer -> k_start = 16 - ptr_hbe_txposer -> synth_size ; } else if ( ptr_hbe_txposer -> core_frame_length == 768 ) { if ( ptr_hbe_txposer -> k_start + ptr_hbe_txposer -> synth_size > 24 ) ptr_hbe_txposer -> k_start = 24 - ptr_hbe_txposer -> synth_size ; } memset ( ptr_hbe_txposer -> synth_buf , 0 , 1280 * sizeof ( FLOAT32 ) ) ; synth_size = ptr_hbe_txposer -> synth_size ; ptr_hbe_txposer -> synth_buf_offset = 18 * synth_size ; switch ( synth_size ) { case 4 : ptr_hbe_txposer -> synth_cos_tab = ( FLOAT32 * ) ixheaacd_synth_cos_table_kl_4 ; ptr_hbe_txposer -> analy_cos_sin_tab = ( FLOAT32 * ) ixheaacd_analy_cos_sin_table_kl_8 ; <S2SV_StartBug> ixheaacd_real_synth_fft = & ixheaacd_real_synth_fft_p2 ; <S2SV_EndBug> <S2SV_StartBug> ixheaacd_cmplx_anal_fft = & ixheaacd_cmplx_anal_fft_p2 ; <S2SV_EndBug> break ; case 8 : ptr_hbe_txposer -> synth_cos_tab = ( FLOAT32 * ) ixheaacd_synth_cos_table_kl_8 ; ptr_hbe_txposer -> analy_cos_sin_tab = ( FLOAT32 * ) ixheaacd_analy_cos_sin_table_kl_16 ; <S2SV_StartBug> ixheaacd_real_synth_fft = & ixheaacd_real_synth_fft_p2 ; <S2SV_EndBug> <S2SV_StartBug> ixheaacd_cmplx_anal_fft = & ixheaacd_cmplx_anal_fft_p2 ; <S2SV_EndBug> break ; case 12 : ptr_hbe_txposer -> synth_cos_tab = ( FLOAT32 * ) ixheaacd_synth_cos_table_kl_12 ; ptr_hbe_txposer -> analy_cos_sin_tab = ( FLOAT32 * ) ixheaacd_analy_cos_sin_table_kl_24 ; <S2SV_StartBug> ixheaacd_real_synth_fft = & ixheaacd_real_synth_fft_p3 ; <S2SV_EndBug> <S2SV_StartBug> ixheaacd_cmplx_anal_fft = & ixheaacd_cmplx_anal_fft_p3 ; <S2SV_EndBug> break ; case 16 : ptr_hbe_txposer -> synth_cos_tab = ( FLOAT32 * ) ixheaacd_synth_cos_table_kl_16 ; ptr_hbe_txposer -> analy_cos_sin_tab = ( FLOAT32 * ) ixheaacd_analy_cos_sin_table_kl_32 ; <S2SV_StartBug> ixheaacd_real_synth_fft = & ixheaacd_real_synth_fft_p2 ; <S2SV_EndBug> <S2SV_StartBug> ixheaacd_cmplx_anal_fft = & ixheaacd_cmplx_anal_fft_p2 ; <S2SV_EndBug> break ; case 20 : ptr_hbe_txposer -> synth_cos_tab = ( FLOAT32 * ) ixheaacd_synth_cos_table_kl_20 ; ptr_hbe_txposer -> analy_cos_sin_tab = ( FLOAT32 * ) ixheaacd_analy_cos_sin_table_kl_40 ; break ; default : ptr_hbe_txposer -> synth_cos_tab = ( FLOAT32 * ) ixheaacd_synth_cos_table_kl_4 ; ptr_hbe_txposer -> analy_cos_sin_tab = ( FLOAT32 * ) ixheaacd_analy_cos_sin_table_kl_8 ; <S2SV_StartBug> ixheaacd_real_synth_fft = & ixheaacd_real_synth_fft_p2 ; <S2SV_EndBug> <S2SV_StartBug> ixheaacd_cmplx_anal_fft = & ixheaacd_cmplx_anal_fft_p2 ; <S2SV_EndBug> } ptr_hbe_txposer -> synth_wind_coeff = ixheaacd_map_prot_filter ( synth_size ) ; memset ( ptr_hbe_txposer -> analy_buf , 0 , 640 * sizeof ( FLOAT32 ) ) ; synth_size = 2 * ptr_hbe_txposer -> synth_size ; ptr_hbe_txposer -> analy_wind_coeff = ixheaacd_map_prot_filter ( synth_size ) ; memset ( ptr_hbe_txposer -> x_over_qmf , 0 , MAX_NUM_PATCHES * sizeof ( WORD32 ) ) ; sfb = 0 ; if ( upsamp_4_flag ) { stop_patch = MAX_NUM_PATCHES ; ptr_hbe_txposer -> max_stretch = MAX_STRETCH ; } else { stop_patch = MAX_STRETCH ; } for ( patch = 1 ; patch <= stop_patch ; patch ++ ) { while ( sfb <= p_num_sfb [ LOW ] && p_freq_band_tab [ LOW ] [ sfb ] <= patch * ptr_hbe_txposer -> start_band ) sfb ++ ; if ( sfb <= p_num_sfb [ LOW ] ) { if ( ( patch * ptr_hbe_txposer -> start_band - p_freq_band_tab [ LOW ] [ sfb - 1 ] ) <= 3 ) { ptr_hbe_txposer -> x_over_qmf [ patch - 1 ] = p_freq_band_tab [ LOW ] [ sfb - 1 ] ; } else { WORD32 sfb = 0 ; while ( sfb <= p_num_sfb [ HIGH ] && p_freq_band_tab [ HIGH ] [ sfb ] <= patch * ptr_hbe_txposer -> start_band ) sfb ++ ; ptr_hbe_txposer -> x_over_qmf [ patch - 1 ] = p_freq_band_tab [ HIGH ] [ sfb - 1 ] ; } } else { ptr_hbe_txposer -> x_over_qmf [ patch - 1 ] = ptr_hbe_txposer -> end_band ; ptr_hbe_txposer -> max_stretch = min ( patch , MAX_STRETCH ) ; break ; <S2SV_StartBug> } <S2SV_EndBug> } } if ( ptr_hbe_txposer -> k_start < 0 ) { return - 1 ; } <S2SV_StartBug> return 0 ; <S2SV_EndBug> }
CWE-611 void xmlParsePEReference ( xmlParserCtxtPtr ctxt ) { const xmlChar * name ; xmlEntityPtr entity = NULL ; xmlParserInputPtr input ; if ( RAW != '%' ) return ; NEXT ; name = xmlParseName ( ctxt ) ; if ( name == NULL ) { xmlFatalErrMsg ( ctxt , XML_ERR_NAME_REQUIRED , "xmlParsePEReference:<S2SV_blank>no<S2SV_blank>name\\n" ) ; return ; } if ( RAW != ';' ) { xmlFatalErr ( ctxt , XML_ERR_ENTITYREF_SEMICOL_MISSING , NULL ) ; return ; } NEXT ; ctxt -> nbentities ++ ; if ( ( ctxt -> sax != NULL ) && ( ctxt -> sax -> getParameterEntity != NULL ) ) entity = ctxt -> sax -> getParameterEntity ( ctxt -> userData , name ) ; if ( ctxt -> instate == XML_PARSER_EOF ) return ; if ( entity == NULL ) { if ( ( ctxt -> standalone == 1 ) || ( ( ctxt -> hasExternalSubset == 0 ) && ( ctxt -> hasPErefs == 0 ) ) ) { xmlFatalErrMsgStr ( ctxt , XML_ERR_UNDECLARED_ENTITY , "PEReference:<S2SV_blank>%%%s;<S2SV_blank>not<S2SV_blank>found\\n" , name ) ; } else { xmlWarningMsg ( ctxt , XML_WAR_UNDECLARED_ENTITY , "PEReference:<S2SV_blank>%%%s;<S2SV_blank>not<S2SV_blank>found\\n" , name , NULL ) ; ctxt -> valid = 0 ; } xmlParserEntityCheck ( ctxt , 0 , NULL , 0 ) ; } else { if ( ( entity -> etype != XML_INTERNAL_PARAMETER_ENTITY ) && ( entity -> etype != XML_EXTERNAL_PARAMETER_ENTITY ) ) { xmlWarningMsg ( ctxt , XML_WAR_UNDECLARED_ENTITY , "Internal:<S2SV_blank>%%%s;<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>parameter<S2SV_blank>entity\\n" , name , NULL ) ; } else if ( ctxt -> input -> free != deallocblankswrapper ) { input = xmlNewBlanksWrapperInputStream ( ctxt , entity ) ; if ( xmlPushInput ( ctxt , input ) < 0 ) return ; } else { <S2SV_StartBug> input = xmlNewEntityInputStream ( ctxt , entity ) ; <S2SV_EndBug> if ( xmlPushInput ( ctxt , input ) < 0 ) return ; if ( ( entity -> etype == XML_EXTERNAL_PARAMETER_ENTITY ) && ( CMP5 ( CUR_PTR , '<' , '?' , 'x' , 'm' , 'l' ) ) && ( IS_BLANK_CH ( NXT ( 5 ) ) ) ) { xmlParseTextDecl ( ctxt ) ; if ( ctxt -> errNo == XML_ERR_UNSUPPORTED_ENCODING ) { xmlHaltParser ( ctxt ) ; return ; } } } } ctxt -> hasPErefs = 1 ; }
CWE-119 static int xmlParse3986Port ( xmlURIPtr uri , const char * * str ) { const char * cur = * str ; unsigned port = 0 ; if ( ISA_DIGIT ( cur ) ) { while ( ISA_DIGIT ( cur ) ) { port = port * 10 + ( * cur - '0' ) ; cur ++ ; } if ( uri != NULL ) <S2SV_StartBug> uri -> port = port & INT_MAX ; <S2SV_EndBug> * str = cur ; return ( 0 ) ; } return ( 1 ) ; }
CWE-190 bool layer_resize ( int layer , int x_size , int y_size ) { int old_height ; int old_width ; struct map_tile * tile ; int tile_width ; int tile_height ; struct map_tile * tilemap ; struct map_trigger * trigger ; struct map_zone * zone ; <S2SV_StartBug> int x , y , i ; <S2SV_EndBug> old_width = s_map -> layers [ layer ] . width ; old_height = s_map -> layers [ layer ] . height ; <S2SV_StartBug> if ( ! ( tilemap = malloc ( x_size * y_size * sizeof ( struct map_tile ) ) ) ) <S2SV_EndBug> return false ; for ( x = 0 ; x < x_size ; ++ x ) { for ( y = 0 ; y < y_size ; ++ y ) { if ( x < old_width && y < old_height ) { tilemap [ x + y * x_size ] = s_map -> layers [ layer ] . tilemap [ x + y * old_width ] ; } else { tile = & tilemap [ x + y * x_size ] ; tile -> frames_left = tileset_get_delay ( s_map -> tileset , 0 ) ; tile -> tile_index = 0 ; } } } free ( s_map -> layers [ layer ] . tilemap ) ; s_map -> layers [ layer ] . tilemap = tilemap ; s_map -> layers [ layer ] . width = x_size ; s_map -> layers [ layer ] . height = y_size ; tileset_get_size ( s_map -> tileset , & tile_width , & tile_height ) ; s_map -> width = 0 ; s_map -> height = 0 ; for ( i = 0 ; i < s_map -> num_layers ; ++ i ) { if ( ! s_map -> layers [ i ] . is_parallax ) { s_map -> width = fmax ( s_map -> width , s_map -> layers [ i ] . width * tile_width ) ; s_map -> height = fmax ( s_map -> height , s_map -> layers [ i ] . height * tile_height ) ; } } for ( i = ( int ) vector_len ( s_map -> zones ) - 1 ; i >= 0 ; -- i ) { zone = vector_get ( s_map -> zones , i ) ; if ( zone -> bounds . x1 >= s_map -> width || zone -> bounds . y1 >= s_map -> height ) vector_remove ( s_map -> zones , i ) ; else { if ( zone -> bounds . x2 > s_map -> width ) zone -> bounds . x2 = s_map -> width ; if ( zone -> bounds . y2 > s_map -> height ) zone -> bounds . y2 = s_map -> height ; } } for ( i = ( int ) vector_len ( s_map -> triggers ) - 1 ; i >= 0 ; -- i ) { trigger = vector_get ( s_map -> triggers , i ) ; if ( trigger -> x >= s_map -> width || trigger -> y >= s_map -> height ) vector_remove ( s_map -> triggers , i ) ; } return true ; }
CWE-436 static gssize find_auth_end ( FlatpakProxyClient * client , Buffer * buffer ) { <S2SV_StartBug> guchar * match ; <S2SV_EndBug> int i ; if ( client -> auth_end_offset > 0 ) { gsize left = strlen ( AUTH_END_STRING ) - client -> auth_end_offset ; <S2SV_StartBug> gsize to_match = MIN ( left , buffer -> pos ) ; <S2SV_EndBug> <S2SV_StartBug> if ( memcmp ( buffer -> data , & AUTH_END_STRING [ client -> auth_end_offset ] , to_match ) == 0 ) <S2SV_EndBug> { client -> auth_end_offset += to_match ; if ( client -> auth_end_offset == strlen ( AUTH_END_STRING ) ) return to_match ; return - 1 ; } client -> auth_end_offset = - 1 ; } match = memmem ( buffer , buffer -> pos , AUTH_END_STRING , strlen ( AUTH_END_STRING ) ) ; if ( match != NULL ) <S2SV_StartBug> return match - buffer -> data + strlen ( AUTH_END_STRING ) ; <S2SV_EndBug> for ( i = MIN ( strlen ( AUTH_END_STRING ) - 1 , buffer -> pos ) ; i > 0 ; i -- ) { if ( memcmp ( buffer -> data + buffer -> pos - i , AUTH_END_STRING , i ) == 0 ) { client -> auth_end_offset = i ; break ; } } return - 1 ; }
CWE-436 static void flatpak_proxy_client_finalize ( GObject * object ) { FlatpakProxyClient * client = FLATPAK_PROXY_CLIENT ( object ) ; client -> proxy -> clients = g_list_remove ( client -> proxy -> clients , client ) ; <S2SV_StartBug> g_clear_object ( & client -> proxy ) ; <S2SV_EndBug> g_hash_table_destroy ( client -> rewrite_reply ) ; g_hash_table_destroy ( client -> get_owner_reply ) ; g_hash_table_destroy ( client -> unique_id_policy ) ; free_side ( & client -> client_side ) ; free_side ( & client -> bus_side ) ; G_OBJECT_CLASS ( flatpak_proxy_client_parent_class ) -> finalize ( object ) ; }
CWE-436 static void flatpak_proxy_client_init ( FlatpakProxyClient * client ) { init_side ( client , & client -> client_side ) ; init_side ( client , & client -> bus_side ) ; <S2SV_StartBug> client -> auth_end_offset = AUTH_END_INIT_OFFSET ; <S2SV_EndBug> client -> rewrite_reply = g_hash_table_new_full ( g_direct_hash , g_direct_equal , NULL , g_object_unref ) ; client -> get_owner_reply = g_hash_table_new_full ( g_direct_hash , g_direct_equal , NULL , g_free ) ; client -> unique_id_policy = g_hash_table_new_full ( g_str_hash , g_str_equal , g_free , NULL ) ; }
CWE-436 static gboolean side_in_cb ( GSocket * socket , GIOCondition condition , gpointer user_data ) { ProxySide * side = user_data ; FlatpakProxyClient * client = side -> client ; GError * error = NULL ; Buffer * buffer ; gboolean retval = G_SOURCE_CONTINUE ; g_object_ref ( client ) ; while ( ! side -> closed ) { if ( ! side -> got_first_byte ) buffer = buffer_new ( 1 , NULL ) ; else if ( ! client -> authenticated ) buffer = buffer_new ( 64 , NULL ) ; else buffer = side -> current_read_buffer ; if ( ! buffer_read ( side , buffer , socket ) ) { if ( buffer != side -> current_read_buffer ) buffer_unref ( buffer ) ; break ; } if ( ! client -> authenticated ) { if ( buffer -> pos > 0 ) { gboolean found_auth_end = FALSE ; gsize extra_data ; buffer -> size = buffer -> pos ; if ( ! side -> got_first_byte ) { buffer -> send_credentials = TRUE ; side -> got_first_byte = TRUE ; } else if ( side == & client -> client_side ) { gssize auth_end = find_auth_end ( client , buffer ) ; if ( auth_end >= 0 ) { found_auth_end = TRUE ; buffer -> size = auth_end ; extra_data = buffer -> pos - buffer -> size ; if ( extra_data > 0 ) side -> extra_input_data = g_bytes_new ( buffer -> data + buffer -> size , extra_data ) ; } <S2SV_StartBug> } <S2SV_EndBug> got_buffer_from_side ( side , buffer ) ; if ( found_auth_end ) client -> authenticated = TRUE ; } else { buffer_unref ( buffer ) ; } } else if ( buffer -> pos == buffer -> size ) { if ( buffer == & side -> header_buffer ) { gssize required ; required = g_dbus_message_bytes_needed ( buffer -> data , buffer -> size , & error ) ; if ( required < 0 ) { g_warning ( "Invalid<S2SV_blank>message<S2SV_blank>header<S2SV_blank>read" ) ; side_closed ( side ) ; } else { side -> current_read_buffer = buffer_new ( required , buffer ) ; } } else { got_buffer_from_side ( side , buffer ) ; side -> header_buffer . pos = 0 ; side -> current_read_buffer = & side -> header_buffer ; } } } if ( side -> closed ) { side -> in_source = NULL ; retval = G_SOURCE_REMOVE ; } g_object_unref ( client ) ; return retval ; }
CWE-119 static int _FVMenuClose ( FontView * fv ) { int i ; SplineFont * sf = fv -> b . cidmaster ? fv -> b . cidmaster : fv -> b . sf ; if ( ! SFCloseAllInstrs ( fv -> b . sf ) ) return ( false ) ; <S2SV_StartBug> if ( fv -> b . nextsame != NULL || fv -> b . sf -> fv != & fv -> b ) { <S2SV_EndBug> } else if ( SFAnyChanged ( sf ) ) { i = AskChanged ( fv -> b . sf ) ; if ( i == 2 ) return ( false ) ; if ( i == 0 && ! _FVMenuSave ( fv ) ) return ( false ) ; else SFClearAutoSave ( sf ) ; } _FVCloseWindows ( fv ) ; if ( sf -> filename != NULL ) RecentFilesRemember ( sf -> filename ) ; else if ( sf -> origname != NULL ) RecentFilesRemember ( sf -> origname ) ; GDrawDestroyWindow ( fv -> gw ) ; return ( true ) ; }
CWE-119 static int sd_e_h ( GWindow gw , GEvent * event ) { struct sd_data * sd = GDrawGetUserData ( gw ) ; if ( sd == NULL ) return ( true ) ; if ( event -> type == et_close ) { SD_DoCancel ( sd ) ; <S2SV_StartBug> } else if ( event -> type == et_char ) { <S2SV_EndBug> if ( event -> u . chr . keysym == GK_F1 || event -> u . chr . keysym == GK_Help ) { help ( "scripting.html" ) ; return ( true ) ; } return ( false ) ; } else if ( event -> type == et_map ) GDrawRaise ( gw ) ; else if ( event -> type == et_resize ) GDrawRequestExpose ( gw , NULL , false ) ; return ( true ) ; }
CWE-119 static void GTextFieldSave ( GTextField * gt , int utf8 ) { unichar_t * ret ; char * cret ; FILE * file ; unichar_t * pt ; if ( _ggadget_use_gettext ) { char * temp = GWidgetOpenFile8 ( _ ( "Save" ) , NULL , "*.{txt,py}" , NULL , NULL ) ; ret = utf82u_copy ( temp ) ; free ( temp ) ; } else ret = GWidgetSaveAsFile ( GStringGetResource ( _STR_Save , NULL ) , NULL , txt , NULL , NULL ) ; if ( ret == NULL ) return ; cret = u2def_copy ( ret ) ; free ( ret ) ; file = fopen ( cret , "w" ) ; if ( file == NULL ) { if ( _ggadget_use_gettext ) GWidgetError8 ( _ ( "Could<S2SV_blank>not<S2SV_blank>open<S2SV_blank>file" ) , _ ( "Could<S2SV_blank>not<S2SV_blank>open<S2SV_blank>%.100s" ) , cret ) ; else GWidgetError ( errort , error , cret ) ; free ( cret ) ; return ; } free ( cret ) ; if ( utf8 ) { putc ( 0xef , file ) ; putc ( 0xbb , file ) ; putc ( 0xbf , file ) ; for ( pt = gt -> text ; * pt ; ++ pt ) { if ( * pt < 0x80 ) putc ( * pt , file ) ; else if ( * pt < 0x800 ) { putc ( 0xc0 | ( * pt >> 6 ) , file ) ; putc ( 0x80 | ( * pt & 0x3f ) , file ) ; } else if ( * pt >= 0xd800 && * pt < 0xdc00 && pt [ 1 ] >= 0xdc00 && pt [ 1 ] < 0xe000 ) { int u = ( ( * pt >> 6 ) & 0xf ) + 1 , y = ( ( * pt & 3 ) << 4 ) | ( ( pt [ 1 ] >> 6 ) & 0xf ) ; putc ( 0xf0 | ( u >> 2 ) , file ) ; putc ( 0x80 | ( ( u & 3 ) << 4 ) | ( ( * pt >> 2 ) & 0xf ) , file ) ; putc ( 0x80 | y , file ) ; putc ( 0x80 | ( pt [ 1 ] & 0x3f ) , file ) ; } else { putc ( 0xe0 | ( * pt >> 12 ) , file ) ; putc ( 0x80 | ( ( * pt >> 6 ) & 0x3f ) , file ) ; putc ( 0x80 | ( * pt & 0x3f ) , file ) ; } } } else { putc ( 0xfeff >> 8 , file ) ; putc ( 0xfeff & 0xff , file ) ; for ( pt = gt -> text ; * pt ; ++ pt ) { putc ( * pt >> 8 , file ) ; putc ( * pt & 0xff , file ) ; } } fclose ( file ) ; <S2SV_StartBug> } <S2SV_EndBug>
CWE-20 static int fsck_gitmodules_fn ( const char * var , const char * value , void * vdata ) { struct fsck_gitmodules_data * data = vdata ; const char * subsection , * key ; int subsection_len ; char * name ; if ( parse_config_key ( var , "submodule" , & subsection , & subsection_len , & key ) < 0 || ! subsection ) return 0 ; name = xmemdupz ( subsection , subsection_len ) ; if ( check_submodule_name ( name ) < 0 ) data -> ret |= report ( data -> options , data -> obj , FSCK_MSG_GITMODULES_NAME , "disallowed<S2SV_blank>submodule<S2SV_blank>name:<S2SV_blank>%s" , name ) ; if ( ! strcmp ( key , "url" ) && value && looks_like_command_line_option ( value ) ) data -> ret |= report ( data -> options , data -> obj , FSCK_MSG_GITMODULES_URL , "disallowed<S2SV_blank>submodule<S2SV_blank>url:<S2SV_blank>%s" , value ) ; <S2SV_StartBug> free ( name ) ; <S2SV_EndBug> return 0 ; }
CWE-20 static int fsck_gitmodules_fn ( const char * var , const char * value , void * vdata ) { struct fsck_gitmodules_data * data = vdata ; const char * subsection , * key ; int subsection_len ; char * name ; if ( parse_config_key ( var , "submodule" , & subsection , & subsection_len , & key ) < 0 || ! subsection ) return 0 ; name = xmemdupz ( subsection , subsection_len ) ; if ( check_submodule_name ( name ) < 0 ) data -> ret |= report ( data -> options , data -> obj , FSCK_MSG_GITMODULES_NAME , "disallowed<S2SV_blank>submodule<S2SV_blank>name:<S2SV_blank>%s" , name ) ; <S2SV_StartBug> free ( name ) ; <S2SV_EndBug> return 0 ; }
CWE-787 GPMF_ERR IsValidSize ( GPMF_stream * ms , uint32_t size ) { if ( ms ) { <S2SV_StartBug> int32_t nestsize = ( int32_t ) ms -> nest_size [ ms -> nest_level ] ; <S2SV_EndBug> if ( nestsize == 0 && ms -> nest_level == 0 ) nestsize = ms -> buffer_size_longs ; if ( size + 2 <= nestsize ) return GPMF_OK ; } return GPMF_ERROR_BAD_STRUCTURE ; }
CWE-787 int main ( int argc , char * argv [ ] ) { int32_t ret = GPMF_OK ; GPMF_stream metadata_stream , * ms = & metadata_stream ; double metadatalength ; uint32_t * payload = NULL ; if ( argc != 2 ) { printf ( "usage:<S2SV_blank>%s<S2SV_blank><file_with_GPMF>\\n" , argv [ 0 ] ) ; return - 1 ; } size_t mp4 = OpenMP4Source ( argv [ 1 ] , MOV_GPMF_TRAK_TYPE , MOV_GPMF_TRAK_SUBTYPE ) ; <S2SV_StartBug> metadatalength = GetDuration ( mp4 ) ; <S2SV_EndBug> if ( metadatalength > 0.0 ) { uint32_t index , payloads = GetNumberPayloads ( mp4 ) ; # if 1 if ( payloads == 1 ) { uint32_t payloadsize = GetPayloadSize ( mp4 , 0 ) ; payload = GetPayload ( mp4 , payload , 0 ) ; if ( payload == NULL ) goto cleanup ; ret = GPMF_Init ( ms , payload , payloadsize ) ; if ( ret != GPMF_OK ) goto cleanup ; ret = GPMF_Validate ( ms , GPMF_RECURSE_LEVELS ) ; if ( GPMF_OK != ret ) { printf ( "Invalid<S2SV_blank>Structure\\n" ) ; goto cleanup ; } GPMF_ResetState ( ms ) ; do { PrintGPMF ( ms ) ; } while ( GPMF_OK == GPMF_Next ( ms , GPMF_RECURSE_LEVELS ) ) ; GPMF_ResetState ( ms ) ; printf ( "\\n" ) ; } # endif for ( index = 0 ; index < payloads ; index ++ ) { uint32_t payloadsize = GetPayloadSize ( mp4 , index ) ; <S2SV_StartBug> float in = 0.0 , out = 0.0 ; <S2SV_EndBug> payload = GetPayload ( mp4 , payload , index ) ; if ( payload == NULL ) goto cleanup ; ret = GetPayloadTime ( mp4 , index , & in , & out ) ; if ( ret != GPMF_OK ) goto cleanup ; ret = GPMF_Init ( ms , payload , payloadsize ) ; if ( ret != GPMF_OK ) goto cleanup ; # if 1 if ( index == 0 ) { ret = GPMF_FindNext ( ms , GPMF_KEY_STREAM , GPMF_RECURSE_LEVELS ) ; while ( GPMF_OK == ret ) { ret = GPMF_SeekToSamples ( ms ) ; if ( GPMF_OK == ret ) { uint32_t key = GPMF_Key ( ms ) ; GPMF_SampleType type = GPMF_Type ( ms ) ; uint32_t elements = GPMF_ElementsInStruct ( ms ) ; uint32_t samples = GPMF_PayloadSampleCount ( ms ) ; if ( samples ) { printf ( "<S2SV_blank><S2SV_blank>STRM<S2SV_blank>of<S2SV_blank>%c%c%c%c<S2SV_blank>" , PRINTF_4CC ( key ) ) ; if ( type == GPMF_TYPE_COMPLEX ) { GPMF_stream find_stream ; GPMF_CopyState ( ms , & find_stream ) ; if ( GPMF_OK == GPMF_FindPrev ( & find_stream , GPMF_KEY_TYPE , GPMF_CURRENT_LEVEL ) ) { char tmp [ 64 ] ; char * data = ( char * ) GPMF_RawData ( & find_stream ) ; int size = GPMF_RawDataSize ( & find_stream ) ; if ( size < sizeof ( tmp ) ) { memcpy ( tmp , data , size ) ; tmp [ size ] = 0 ; printf ( "of<S2SV_blank>type<S2SV_blank>%s<S2SV_blank>" , tmp ) ; } } } else { printf ( "of<S2SV_blank>type<S2SV_blank>%c<S2SV_blank>" , type ) ; } printf ( "with<S2SV_blank>%d<S2SV_blank>sample%s<S2SV_blank>" , samples , samples > 1 ? "s" : "" ) ; if ( elements > 1 ) printf ( "--<S2SV_blank>%d<S2SV_blank>elements<S2SV_blank>per<S2SV_blank>sample" , elements ) ; printf ( "\\n" ) ; } ret = GPMF_FindNext ( ms , GPMF_KEY_STREAM , GPMF_RECURSE_LEVELS ) ; } else { if ( ret == GPMF_ERROR_BAD_STRUCTURE ) { ret = GPMF_Next ( ms , GPMF_CURRENT_LEVEL ) ; } } } GPMF_ResetState ( ms ) ; printf ( "\\n" ) ; } # endif # if 1 if ( index == 0 ) { if ( GPMF_OK == GPMF_FindNext ( ms , STR2FOURCC ( "GPS5" ) , GPMF_RECURSE_LEVELS ) || GPMF_OK == GPMF_FindNext ( ms , STR2FOURCC ( "GPRI" ) , GPMF_RECURSE_LEVELS ) ) { uint32_t key = GPMF_Key ( ms ) ; uint32_t samples = GPMF_Repeat ( ms ) ; uint32_t elements = GPMF_ElementsInStruct ( ms ) ; uint32_t buffersize = samples * elements * sizeof ( double ) ; GPMF_stream find_stream ; double * ptr , * tmpbuffer = malloc ( buffersize ) ; char units [ 10 ] [ 6 ] = { "" } ; uint32_t unit_samples = 1 ; printf ( "MP4<S2SV_blank>Payload<S2SV_blank>time<S2SV_blank>%.3f<S2SV_blank>to<S2SV_blank>%.3f<S2SV_blank>seconds\\n" , in , out ) ; if ( tmpbuffer && samples ) { uint32_t i , j ; GPMF_CopyState ( ms , & find_stream ) ; if ( GPMF_OK == GPMF_FindPrev ( & find_stream , GPMF_KEY_SI_UNITS , GPMF_CURRENT_LEVEL ) || GPMF_OK == GPMF_FindPrev ( & find_stream , GPMF_KEY_UNITS , GPMF_CURRENT_LEVEL ) ) { char * data = ( char * ) GPMF_RawData ( & find_stream ) ; int ssize = GPMF_StructSize ( & find_stream ) ; unit_samples = GPMF_Repeat ( & find_stream ) ; for ( i = 0 ; i < unit_samples ; i ++ ) { memcpy ( units [ i ] , data , ssize ) ; units [ i ] [ ssize ] = 0 ; data += ssize ; } } GPMF_ScaledData ( ms , tmpbuffer , buffersize , 0 , samples , GPMF_TYPE_DOUBLE ) ; ptr = tmpbuffer ; for ( i = 0 ; i < samples ; i ++ ) { printf ( "%c%c%c%c<S2SV_blank>" , PRINTF_4CC ( key ) ) ; for ( j = 0 ; j < elements ; j ++ ) printf ( "%.3f%s,<S2SV_blank>" , * ptr ++ , units [ j % unit_samples ] ) ; printf ( "\\n" ) ; } free ( tmpbuffer ) ; } } GPMF_ResetState ( ms ) ; printf ( "\\n" ) ; } # endif } # if 1 while ( GPMF_OK == GPMF_FindNext ( ms , GPMF_KEY_STREAM , GPMF_RECURSE_LEVELS ) ) { if ( GPMF_OK == GPMF_SeekToSamples ( ms ) ) { <S2SV_StartBug> uint32_t fourcc = GPMF_Key ( ms ) ; <S2SV_EndBug> <S2SV_StartBug> double rate = GetGPMFSampleRate ( mp4 , fourcc , GPMF_SAMPLE_RATE_PRECISE ) ; <S2SV_EndBug> <S2SV_StartBug> printf ( "%c%c%c%c<S2SV_blank>sampling<S2SV_blank>rate<S2SV_blank>=<S2SV_blank>%f<S2SV_blank>Hz\\n" , PRINTF_4CC ( fourcc ) , rate ) ; <S2SV_EndBug> } } # endif cleanup : if ( payload ) FreePayload ( payload ) ; payload = NULL ; CloseSource ( mp4 ) ; } return ret ; }
CWE-787 int mp4client_main ( int argc , char * * argv ) { char c ; const char * str ; int ret_val = 0 ; u32 i , times [ 100 ] , nb_times , dump_mode ; u32 simulation_time_in_ms = 0 ; u32 initial_service_id = 0 ; Bool auto_exit = GF_FALSE ; Bool logs_set = GF_FALSE ; Bool start_fs = GF_FALSE ; Bool use_rtix = GF_FALSE ; Bool pause_at_first = GF_FALSE ; Bool no_cfg_save = GF_FALSE ; Bool is_cfg_only = GF_FALSE ; Double play_from = 0 ; # ifdef GPAC_MEMORY_TRACKING GF_MemTrackerType mem_track = GF_MemTrackerNone ; # endif Double fps = GF_IMPORT_DEFAULT_FPS ; Bool fill_ar , visible , do_uncache , has_command ; char * url_arg , * out_arg , * the_cfg , * rti_file , * views , * mosaic ; FILE * logfile = NULL ; Float scale = 1 ; # ifndef WIN32 dlopen ( NULL , RTLD_NOW | RTLD_GLOBAL ) ; # endif strcpy ( the_url , "." ) ; memset ( & user , 0 , sizeof ( GF_User ) ) ; dump_mode = DUMP_NONE ; fill_ar = visible = do_uncache = has_command = GF_FALSE ; url_arg = out_arg = the_cfg = rti_file = views = mosaic = NULL ; nb_times = 0 ; times [ 0 ] = 0 ; for ( i = 1 ; i < ( u32 ) argc ; i ++ ) { char * arg = argv [ i ] ; if ( ! strcmp ( arg , "-c" ) || ! strcmp ( arg , "-cfg" ) ) { the_cfg = argv [ i + 1 ] ; i ++ ; } else if ( ! strcmp ( arg , "-mem-track" ) || ! strcmp ( arg , "-mem-track-stack" ) ) { # ifdef GPAC_MEMORY_TRACKING mem_track = ! strcmp ( arg , "-mem-track-stack" ) ? GF_MemTrackerBackTrace : GF_MemTrackerSimple ; # else fprintf ( stderr , "WARNING<S2SV_blank>-<S2SV_blank>GPAC<S2SV_blank>not<S2SV_blank>compiled<S2SV_blank>with<S2SV_blank>Memory<S2SV_blank>Tracker<S2SV_blank>-<S2SV_blank>ignoring<S2SV_blank>\\"%s\\"\\n" , arg ) ; # endif } else if ( ! strcmp ( arg , "-gui" ) ) { gui_mode = 1 ; } else if ( ! strcmp ( arg , "-guid" ) ) { gui_mode = 2 ; } else if ( ! strcmp ( arg , "-h" ) || ! strcmp ( arg , "-help" ) ) { PrintUsage ( ) ; return 0 ; } } # ifdef GPAC_MEMORY_TRACKING gf_sys_init ( mem_track ) ; # else gf_sys_init ( GF_MemTrackerNone ) ; # endif gf_sys_set_args ( argc , ( const char * * ) argv ) ; cfg_file = gf_cfg_init ( the_cfg , NULL ) ; if ( ! cfg_file ) { fprintf ( stderr , "Error:<S2SV_blank>Configuration<S2SV_blank>File<S2SV_blank>not<S2SV_blank>found\\n" ) ; return 1 ; } if ( gf_log_set_tools_levels ( gf_cfg_get_key ( cfg_file , "General" , "Logs" ) ) != GF_OK ) { return 1 ; } if ( gf_cfg_get_key ( cfg_file , "General" , "Logs" ) != NULL ) { logs_set = GF_TRUE ; } if ( ! gui_mode ) { str = gf_cfg_get_key ( cfg_file , "General" , "ForceGUI" ) ; if ( str && ! strcmp ( str , "yes" ) ) gui_mode = 1 ; } for ( i = 1 ; i < ( u32 ) argc ; i ++ ) { char * arg = argv [ i ] ; if ( ! strcmp ( arg , "-rti" ) ) { rti_file = argv [ i + 1 ] ; i ++ ; } else if ( ! strcmp ( arg , "-rtix" ) ) { rti_file = argv [ i + 1 ] ; i ++ ; use_rtix = GF_TRUE ; } else if ( ! stricmp ( arg , "-size" ) ) { if ( sscanf ( argv [ i + 1 ] , "%dx%d" , & forced_width , & forced_height ) != 2 ) { forced_width = forced_height = 0 ; } i ++ ; } else if ( ! strcmp ( arg , "-quiet" ) ) { be_quiet = 1 ; } else if ( ! strcmp ( arg , "-strict-error" ) ) { gf_log_set_strict_error ( 1 ) ; } else if ( ! strcmp ( arg , "-log-file" ) || ! strcmp ( arg , "-lf" ) ) { logfile = gf_fopen ( argv [ i + 1 ] , "wt" ) ; gf_log_set_callback ( logfile , on_gpac_log ) ; i ++ ; } else if ( ! strcmp ( arg , "-logs" ) ) { if ( gf_log_set_tools_levels ( argv [ i + 1 ] ) != GF_OK ) { return 1 ; } logs_set = GF_TRUE ; i ++ ; } else if ( ! strcmp ( arg , "-log-clock" ) || ! strcmp ( arg , "-lc" ) ) { log_time_start = 1 ; } else if ( ! strcmp ( arg , "-log-utc" ) || ! strcmp ( arg , "-lu" ) ) { log_utc_time = 1 ; } # if defined ( __DARWIN__ ) || defined ( __APPLE__ ) else if ( ! strcmp ( arg , "-thread" ) ) threading_flags = 0 ; # else else if ( ! strcmp ( arg , "-no-thread" ) ) threading_flags = GF_TERM_NO_DECODER_THREAD | GF_TERM_NO_COMPOSITOR_THREAD | GF_TERM_WINDOW_NO_THREAD ; # endif else if ( ! strcmp ( arg , "-no-cthread" ) || ! strcmp ( arg , "-no-compositor-thread" ) ) threading_flags |= GF_TERM_NO_COMPOSITOR_THREAD ; else if ( ! strcmp ( arg , "-no-audio" ) ) no_audio = 1 ; else if ( ! strcmp ( arg , "-no-regulation" ) ) no_regulation = 1 ; else if ( ! strcmp ( arg , "-fs" ) ) start_fs = 1 ; else if ( ! strcmp ( arg , "-opt" ) ) { set_cfg_option ( argv [ i + 1 ] ) ; i ++ ; } else if ( ! strcmp ( arg , "-conf" ) ) { set_cfg_option ( argv [ i + 1 ] ) ; is_cfg_only = GF_TRUE ; i ++ ; } else if ( ! strcmp ( arg , "-ifce" ) ) { gf_cfg_set_key ( cfg_file , "Network" , "DefaultMCastInterface" , argv [ i + 1 ] ) ; i ++ ; } else if ( ! stricmp ( arg , "-help" ) ) { PrintUsage ( ) ; return 1 ; } else if ( ! stricmp ( arg , "-noprog" ) ) { no_prog = 1 ; gf_set_progress_callback ( NULL , progress_quiet ) ; } else if ( ! stricmp ( arg , "-no-save" ) || ! stricmp ( arg , "--no-save" ) ) { no_cfg_save = 1 ; } else if ( ! stricmp ( arg , "-ntp-shift" ) ) { s32 shift = atoi ( argv [ i + 1 ] ) ; i ++ ; gf_net_set_ntp_shift ( shift ) ; } else if ( ! stricmp ( arg , "-run-for" ) ) { simulation_time_in_ms = atoi ( argv [ i + 1 ] ) * 1000 ; if ( ! simulation_time_in_ms ) simulation_time_in_ms = 1 ; i ++ ; } else if ( ! strcmp ( arg , "-out" ) ) { out_arg = argv [ i + 1 ] ; i ++ ; } else if ( ! stricmp ( arg , "-fps" ) ) { fps = atof ( argv [ i + 1 ] ) ; i ++ ; } else if ( ! strcmp ( arg , "-avi" ) || ! strcmp ( arg , "-sha" ) ) { dump_mode &= 0xFFFF0000 ; if ( ! strcmp ( arg , "-sha" ) ) dump_mode |= DUMP_SHA1 ; else dump_mode |= DUMP_AVI ; if ( ( url_arg || ( i + 2 < ( u32 ) argc ) ) && get_time_list ( argv [ i + 1 ] , times , & nb_times ) ) { if ( ! strcmp ( arg , "-avi" ) && ( nb_times != 2 ) ) { fprintf ( stderr , "Only<S2SV_blank>one<S2SV_blank>time<S2SV_blank>arg<S2SV_blank>found<S2SV_blank>for<S2SV_blank>-avi<S2SV_blank>-<S2SV_blank>check<S2SV_blank>usage\\n" ) ; return 1 ; } i ++ ; } } else if ( ! strcmp ( arg , "-rgbds" ) ) { dump_mode |= DUMP_RGB_DEPTH_SHAPE ; } else if ( ! strcmp ( arg , "-rgbd" ) ) { dump_mode |= DUMP_RGB_DEPTH ; } else if ( ! strcmp ( arg , "-depth" ) ) { dump_mode |= DUMP_DEPTH_ONLY ; } else if ( ! strcmp ( arg , "-bmp" ) ) { dump_mode &= 0xFFFF0000 ; dump_mode |= DUMP_BMP ; if ( ( url_arg || ( i + 2 < ( u32 ) argc ) ) && get_time_list ( argv [ i + 1 ] , times , & nb_times ) ) i ++ ; } else if ( ! strcmp ( arg , "-png" ) ) { dump_mode &= 0xFFFF0000 ; dump_mode |= DUMP_PNG ; if ( ( url_arg || ( i + 2 < ( u32 ) argc ) ) && get_time_list ( argv [ i + 1 ] , times , & nb_times ) ) i ++ ; } else if ( ! strcmp ( arg , "-raw" ) ) { dump_mode &= 0xFFFF0000 ; dump_mode |= DUMP_RAW ; if ( ( url_arg || ( i + 2 < ( u32 ) argc ) ) && get_time_list ( argv [ i + 1 ] , times , & nb_times ) ) i ++ ; } else if ( ! stricmp ( arg , "-scale" ) ) { sscanf ( argv [ i + 1 ] , "%f" , & scale ) ; i ++ ; } else if ( ! strcmp ( arg , "-c" ) || ! strcmp ( arg , "-cfg" ) ) { i ++ ; } if ( ! gui_mode ) { if ( arg [ 0 ] != '-' ) { if ( url_arg ) { fprintf ( stderr , "Several<S2SV_blank>input<S2SV_blank>URLs<S2SV_blank>provided<S2SV_blank>(\\"%s\\",<S2SV_blank>\\"%s\\").<S2SV_blank>Check<S2SV_blank>your<S2SV_blank>command-line.\\n" , url_arg , arg ) ; return 1 ; } url_arg = arg ; } else if ( ! strcmp ( arg , "-loop" ) ) loop_at_end = 1 ; else if ( ! strcmp ( arg , "-bench" ) ) bench_mode = 1 ; else if ( ! strcmp ( arg , "-vbench" ) ) bench_mode = 2 ; else if ( ! strcmp ( arg , "-sbench" ) ) bench_mode = 3 ; else if ( ! strcmp ( arg , "-no-addon" ) ) enable_add_ons = GF_FALSE ; else if ( ! strcmp ( arg , "-pause" ) ) pause_at_first = 1 ; else if ( ! strcmp ( arg , "-play-from" ) ) { play_from = atof ( ( const char * ) argv [ i + 1 ] ) ; i ++ ; } else if ( ! strcmp ( arg , "-speed" ) ) { playback_speed = FLT2FIX ( atof ( ( const char * ) argv [ i + 1 ] ) ) ; if ( playback_speed <= 0 ) playback_speed = FIX_ONE ; i ++ ; } else if ( ! strcmp ( arg , "-no-wnd" ) ) user . init_flags |= GF_TERM_WINDOWLESS ; else if ( ! strcmp ( arg , "-no-back" ) ) user . init_flags |= GF_TERM_WINDOW_TRANSPARENT ; else if ( ! strcmp ( arg , "-align" ) ) { if ( argv [ i + 1 ] [ 0 ] == 'm' ) align_mode = 1 ; else if ( argv [ i + 1 ] [ 0 ] == 'b' ) align_mode = 2 ; align_mode <<= 8 ; if ( argv [ i + 1 ] [ 1 ] == 'm' ) align_mode |= 1 ; else if ( argv [ i + 1 ] [ 1 ] == 'r' ) align_mode |= 2 ; i ++ ; } else if ( ! strcmp ( arg , "-fill" ) ) { fill_ar = GF_TRUE ; } else if ( ! strcmp ( arg , "-show" ) ) { visible = 1 ; } else if ( ! strcmp ( arg , "-uncache" ) ) { do_uncache = GF_TRUE ; } else if ( ! strcmp ( arg , "-exit" ) ) auto_exit = GF_TRUE ; else if ( ! stricmp ( arg , "-views" ) ) { views = argv [ i + 1 ] ; i ++ ; } else if ( ! stricmp ( arg , "-mosaic" ) ) { mosaic = argv [ i + 1 ] ; i ++ ; } else if ( ! stricmp ( arg , "-com" ) ) { has_command = GF_TRUE ; i ++ ; } else if ( ! stricmp ( arg , "-service" ) ) { initial_service_id = atoi ( argv [ i + 1 ] ) ; i ++ ; } } } if ( is_cfg_only ) { gf_cfg_del ( cfg_file ) ; fprintf ( stderr , "GPAC<S2SV_blank>Config<S2SV_blank>updated\\n" ) ; return 0 ; } if ( do_uncache ) { const char * cache_dir = gf_cfg_get_key ( cfg_file , "General" , "CacheDirectory" ) ; do_flatten_cache ( cache_dir ) ; fprintf ( stderr , "GPAC<S2SV_blank>Cache<S2SV_blank>dir<S2SV_blank>%s<S2SV_blank>flattened\\n" , cache_dir ) ; gf_cfg_del ( cfg_file ) ; return 0 ; } if ( dump_mode && ! url_arg ) { FILE * test ; url_arg = ( char * ) gf_cfg_get_key ( cfg_file , "General" , "StartupFile" ) ; test = url_arg ? gf_fopen ( url_arg , "rt" ) : NULL ; if ( ! test ) url_arg = NULL ; else gf_fclose ( test ) ; if ( ! url_arg ) { fprintf ( stderr , "Missing<S2SV_blank>argument<S2SV_blank>for<S2SV_blank>dump\\n" ) ; PrintUsage ( ) ; if ( logfile ) gf_fclose ( logfile ) ; return 1 ; } } if ( ! gui_mode && ! url_arg && ( gf_cfg_get_key ( cfg_file , "General" , "StartupFile" ) != NULL ) ) { gui_mode = 1 ; } # ifdef WIN32 if ( gui_mode == 1 ) { const char * opt ; TCHAR buffer [ 1024 ] ; DWORD res = GetCurrentDirectory ( 1024 , buffer ) ; buffer [ res ] = 0 ; opt = gf_cfg_get_key ( cfg_file , "General" , "ModulesDirectory" ) ; if ( strstr ( opt , buffer ) ) { gui_mode = 1 ; } else { gui_mode = 2 ; } } # endif if ( gui_mode == 1 ) { hide_shell ( 1 ) ; } if ( gui_mode ) { no_prog = 1 ; gf_set_progress_callback ( NULL , progress_quiet ) ; } if ( ! url_arg && simulation_time_in_ms ) simulation_time_in_ms += gf_sys_clock ( ) ; # if defined ( __DARWIN__ ) || defined ( __APPLE__ ) carbon_init ( ) ; # endif if ( dump_mode ) rti_file = NULL ; if ( ! logs_set ) { gf_log_set_tool_level ( GF_LOG_ALL , GF_LOG_WARNING ) ; } if ( rti_file || logfile || log_utc_time || log_time_start ) gf_log_set_callback ( NULL , on_gpac_log ) ; if ( rti_file ) init_rti_logs ( rti_file , url_arg , use_rtix ) ; { GF_SystemRTInfo rti ; if ( gf_sys_get_rti ( 0 , & rti , 0 ) ) fprintf ( stderr , "System<S2SV_blank>info:<S2SV_blank>%d<S2SV_blank>MB<S2SV_blank>RAM<S2SV_blank>-<S2SV_blank>%d<S2SV_blank>cores\\n" , ( u32 ) ( rti . physical_memory / 1024 / 1024 ) , rti . nb_cores ) ; } if ( dump_mode ) { user . init_flags |= GF_TERM_NO_DECODER_THREAD | GF_TERM_NO_COMPOSITOR_THREAD | GF_TERM_NO_REGULATION ; if ( ! visible ) user . init_flags |= GF_TERM_INIT_HIDE ; gf_cfg_set_key ( cfg_file , "Audio" , "DriverName" , "Raw<S2SV_blank>Audio<S2SV_blank>Output" ) ; no_cfg_save = GF_TRUE ; } else { init_w = forced_width ; init_h = forced_height ; } user . modules = gf_modules_new ( NULL , cfg_file ) ; if ( user . modules ) i = gf_modules_get_count ( user . modules ) ; if ( ! i || ! user . modules ) { fprintf ( stderr , "Error:<S2SV_blank>no<S2SV_blank>modules<S2SV_blank>found<S2SV_blank>-<S2SV_blank>exiting\\n" ) ; if ( user . modules ) gf_modules_del ( user . modules ) ; gf_cfg_del ( cfg_file ) ; gf_sys_close ( ) ; if ( logfile ) gf_fclose ( logfile ) ; return 1 ; } fprintf ( stderr , "Modules<S2SV_blank>Found<S2SV_blank>:<S2SV_blank>%d<S2SV_blank>\\n" , i ) ; str = gf_cfg_get_key ( cfg_file , "General" , "GPACVersion" ) ; if ( ! str || strcmp ( str , GPAC_FULL_VERSION ) ) { gf_cfg_del_section ( cfg_file , "PluginsCache" ) ; gf_cfg_set_key ( cfg_file , "General" , "GPACVersion" , GPAC_FULL_VERSION ) ; } user . config = cfg_file ; user . EventProc = GPAC_EventProc ; user . opaque = user . modules ; if ( threading_flags ) user . init_flags |= threading_flags ; if ( no_audio ) user . init_flags |= GF_TERM_NO_AUDIO ; if ( no_regulation ) user . init_flags |= GF_TERM_NO_REGULATION ; if ( threading_flags & ( GF_TERM_NO_DECODER_THREAD | GF_TERM_NO_COMPOSITOR_THREAD ) ) term_step = GF_TRUE ; if ( dump_mode ) user . init_flags |= GF_TERM_USE_AUDIO_HW_CLOCK ; if ( bench_mode ) { gf_cfg_discard_changes ( user . config ) ; auto_exit = GF_TRUE ; gf_cfg_set_key ( user . config , "Audio" , "DriverName" , "Raw<S2SV_blank>Audio<S2SV_blank>Output" ) ; if ( bench_mode != 2 ) { gf_cfg_set_key ( user . config , "Video" , "DriverName" , "Raw<S2SV_blank>Video<S2SV_blank>Output" ) ; gf_cfg_set_key ( user . config , "RAWVideo" , "RawOutput" , "null" ) ; gf_cfg_set_key ( user . config , "Compositor" , "OpenGLMode" , "disable" ) ; } else { gf_cfg_set_key ( user . config , "Video" , "DisableVSync" , "yes" ) ; } } { char dim [ 50 ] ; sprintf ( dim , "%d" , forced_width ) ; gf_cfg_set_key ( user . config , "Compositor" , "DefaultWidth" , forced_width ? dim : NULL ) ; sprintf ( dim , "%d" , forced_height ) ; gf_cfg_set_key ( user . config , "Compositor" , "DefaultHeight" , forced_height ? dim : NULL ) ; } fprintf ( stderr , "Loading<S2SV_blank>GPAC<S2SV_blank>Terminal\\n" ) ; i = gf_sys_clock ( ) ; term = gf_term_new ( & user ) ; if ( ! term ) { fprintf ( stderr , "\\nInit<S2SV_blank>error<S2SV_blank>-<S2SV_blank>check<S2SV_blank>you<S2SV_blank>have<S2SV_blank>at<S2SV_blank>least<S2SV_blank>one<S2SV_blank>video<S2SV_blank>out<S2SV_blank>and<S2SV_blank>one<S2SV_blank>rasterizer...\\nFound<S2SV_blank>modules:\\n" ) ; list_modules ( user . modules ) ; gf_modules_del ( user . modules ) ; gf_cfg_discard_changes ( cfg_file ) ; gf_cfg_del ( cfg_file ) ; gf_sys_close ( ) ; if ( logfile ) gf_fclose ( logfile ) ; return 1 ; } fprintf ( stderr , "Terminal<S2SV_blank>Loaded<S2SV_blank>in<S2SV_blank>%d<S2SV_blank>ms\\n" , gf_sys_clock ( ) - i ) ; if ( bench_mode ) { display_rti = 2 ; gf_term_set_option ( term , GF_OPT_VIDEO_BENCH , ( bench_mode == 3 ) ? 2 : 1 ) ; if ( bench_mode == 1 ) bench_mode = 2 ; } if ( dump_mode ) { if ( fill_ar ) gf_term_set_option ( term , GF_OPT_ASPECT_RATIO , GF_ASPECT_RATIO_FILL_SCREEN ) ; } else { str = gf_cfg_get_key ( cfg_file , "Video" , "DriverName" ) ; if ( ! bench_mode && ! strcmp ( str , "Raw<S2SV_blank>Video<S2SV_blank>Output" ) ) fprintf ( stderr , "WARNING:<S2SV_blank>using<S2SV_blank>raw<S2SV_blank>output<S2SV_blank>video<S2SV_blank>(memory<S2SV_blank>only)<S2SV_blank>-<S2SV_blank>no<S2SV_blank>display<S2SV_blank>used\\n" ) ; str = gf_cfg_get_key ( cfg_file , "Audio" , "DriverName" ) ; if ( ! str || ! strcmp ( str , "No<S2SV_blank>Audio<S2SV_blank>Output<S2SV_blank>Available" ) ) fprintf ( stderr , "WARNING:<S2SV_blank>no<S2SV_blank>audio<S2SV_blank>output<S2SV_blank>available<S2SV_blank>-<S2SV_blank>make<S2SV_blank>sure<S2SV_blank>no<S2SV_blank>other<S2SV_blank>program<S2SV_blank>is<S2SV_blank>locking<S2SV_blank>the<S2SV_blank>sound<S2SV_blank>card\\n" ) ; str = gf_cfg_get_key ( cfg_file , "General" , "NoMIMETypeFetch" ) ; no_mime_check = ( str && ! stricmp ( str , "yes" ) ) ? 1 : 0 ; } str = gf_cfg_get_key ( cfg_file , "HTTPProxy" , "Enabled" ) ; if ( str && ! strcmp ( str , "yes" ) ) { str = gf_cfg_get_key ( cfg_file , "HTTPProxy" , "Name" ) ; if ( str ) fprintf ( stderr , "HTTP<S2SV_blank>Proxy<S2SV_blank>%s<S2SV_blank>enabled\\n" , str ) ; } if ( rti_file ) { str = gf_cfg_get_key ( cfg_file , "General" , "RTIRefreshPeriod" ) ; if ( str ) { rti_update_time_ms = atoi ( str ) ; } else { gf_cfg_set_key ( cfg_file , "General" , "RTIRefreshPeriod" , "200" ) ; } UpdateRTInfo ( "At<S2SV_blank>GPAC<S2SV_blank>load<S2SV_blank>time\\n" ) ; } Run = 1 ; if ( dump_mode ) { if ( ! nb_times ) { times [ 0 ] = 0 ; nb_times ++ ; } ret_val = dump_file ( url_arg , out_arg , dump_mode , fps , forced_width , forced_height , scale , times , nb_times ) ; Run = 0 ; } else if ( views ) { } else if ( ! gui_mode && url_arg ) { char * ext ; if ( strlen ( url_arg ) >= sizeof ( the_url ) ) { fprintf ( stderr , "Input<S2SV_blank>url<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long,<S2SV_blank>truncating<S2SV_blank>to<S2SV_blank>%d<S2SV_blank>chars.\\n" , url_arg , ( int ) ( sizeof ( the_url ) - 1 ) ) ; strncpy ( the_url , url_arg , sizeof ( the_url ) - 1 ) ; the_url [ sizeof ( the_url ) - 1 ] = 0 ; } else { strcpy ( the_url , url_arg ) ; } ext = strrchr ( the_url , '.' ) ; if ( ext && ( ! stricmp ( ext , ".m3u" ) || ! stricmp ( ext , ".pls" ) ) ) { GF_Err e = GF_OK ; fprintf ( stderr , "Opening<S2SV_blank>Playlist<S2SV_blank>%s\\n" , the_url ) ; strcpy ( pl_path , the_url ) ; if ( ! strncmp ( "http:" , the_url , 5 ) ) { GF_DownloadSession * sess = gf_dm_sess_new ( term -> downloader , the_url , GF_NETIO_SESSION_NOT_THREADED , NULL , NULL , & e ) ; if ( sess ) { e = gf_dm_sess_process ( sess ) ; if ( ! e ) { strncpy ( the_url , gf_dm_sess_get_cache_name ( sess ) , sizeof ( the_url ) - 1 ) ; <S2SV_StartBug> the_url [ sizeof ( the_cfg ) - 1 ] = 0 ; <S2SV_EndBug> } gf_dm_sess_del ( sess ) ; } } playlist = e ? NULL : gf_fopen ( the_url , "rt" ) ; readonly_playlist = 1 ; if ( playlist ) { request_next_playlist_item = GF_TRUE ; } else { if ( e ) fprintf ( stderr , "Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>playlist<S2SV_blank>%s:<S2SV_blank>%s\\n" , the_url , gf_error_to_string ( e ) ) ; fprintf ( stderr , "Hit<S2SV_blank>\'h\'<S2SV_blank>for<S2SV_blank>help\\n\\n" ) ; } } else { fprintf ( stderr , "Opening<S2SV_blank>URL<S2SV_blank>%s\\n" , the_url ) ; if ( pause_at_first ) fprintf ( stderr , "[Status:<S2SV_blank>Paused]\\n" ) ; gf_term_connect_from_time ( term , the_url , ( u64 ) ( play_from * 1000 ) , pause_at_first ) ; } } else { fprintf ( stderr , "Hit<S2SV_blank>\'h\'<S2SV_blank>for<S2SV_blank>help\\n\\n" ) ; str = gf_cfg_get_key ( cfg_file , "General" , "StartupFile" ) ; if ( str ) { strncpy ( the_url , "MP4Client<S2SV_blank>" GPAC_FULL_VERSION , sizeof ( the_url ) - 1 ) ; the_url [ sizeof ( the_url ) - 1 ] = 0 ; gf_term_connect ( term , str ) ; startup_file = 1 ; is_connected = 1 ; } } if ( gui_mode == 2 ) gui_mode = 0 ; if ( start_fs ) gf_term_set_option ( term , GF_OPT_FULLSCREEN , 1 ) ; if ( views ) { char szTemp [ 4046 ] ; sprintf ( szTemp , "views://%s" , views ) ; gf_term_connect ( term , szTemp ) ; } if ( mosaic ) { char szTemp [ 4046 ] ; sprintf ( szTemp , "mosaic://%s" , mosaic ) ; gf_term_connect ( term , szTemp ) ; } if ( bench_mode ) { rti_update_time_ms = 500 ; bench_mode_start = gf_sys_clock ( ) ; } while ( Run ) { if ( ( gui_mode == 1 ) || ! gf_prompt_has_input ( ) ) { if ( reload ) { reload = 0 ; gf_term_disconnect ( term ) ; gf_term_connect ( term , startup_file ? gf_cfg_get_key ( cfg_file , "General" , "StartupFile" ) : the_url ) ; } if ( restart && gf_term_get_option ( term , GF_OPT_IS_OVER ) ) { restart = 0 ; gf_term_play_from_time ( term , 0 , 0 ) ; } if ( request_next_playlist_item ) { c = '\\n' ; request_next_playlist_item = 0 ; goto force_input ; } if ( has_command && is_connected ) { has_command = GF_FALSE ; for ( i = 0 ; i < ( u32 ) argc ; i ++ ) { if ( ! strcmp ( argv [ i ] , "-com" ) ) { gf_term_scene_update ( term , NULL , argv [ i + 1 ] ) ; i ++ ; } } } if ( initial_service_id && is_connected ) { GF_ObjectManager * root_od = gf_term_get_root_object ( term ) ; if ( root_od ) { gf_term_select_service ( term , root_od , initial_service_id ) ; initial_service_id = 0 ; } } if ( ! use_rtix || display_rti ) UpdateRTInfo ( NULL ) ; if ( term_step ) { gf_term_process_step ( term ) ; } else { gf_sleep ( rti_update_time_ms ) ; } if ( auto_exit && eos_seen && gf_term_get_option ( term , GF_OPT_IS_OVER ) ) { Run = GF_FALSE ; } if ( simulation_time_in_ms && ( ( gf_term_get_elapsed_time_in_ms ( term ) > simulation_time_in_ms ) || ( ! url_arg && gf_sys_clock ( ) > simulation_time_in_ms ) ) ) { Run = GF_FALSE ; } continue ; } c = gf_prompt_get_char ( ) ; force_input : switch ( c ) { case 'q' : { GF_Event evt ; memset ( & evt , 0 , sizeof ( GF_Event ) ) ; evt . type = GF_EVENT_QUIT ; gf_term_send_event ( term , & evt ) ; } break ; case 'X' : exit ( 0 ) ; break ; case 'Q' : break ; case 'o' : startup_file = 0 ; gf_term_disconnect ( term ) ; fprintf ( stderr , "Enter<S2SV_blank>the<S2SV_blank>absolute<S2SV_blank>URL\\n" ) ; if ( 1 > scanf ( "%s" , the_url ) ) { fprintf ( stderr , "Cannot<S2SV_blank>read<S2SV_blank>absolute<S2SV_blank>URL,<S2SV_blank>aborting\\n" ) ; break ; } if ( rti_file ) init_rti_logs ( rti_file , the_url , use_rtix ) ; gf_term_connect ( term , the_url ) ; break ; case 'O' : gf_term_disconnect ( term ) ; fprintf ( stderr , "Enter<S2SV_blank>the<S2SV_blank>absolute<S2SV_blank>URL<S2SV_blank>to<S2SV_blank>the<S2SV_blank>playlist\\n" ) ; if ( 1 > scanf ( "%s" , the_url ) ) { fprintf ( stderr , "Cannot<S2SV_blank>read<S2SV_blank>the<S2SV_blank>absolute<S2SV_blank>URL,<S2SV_blank>aborting.\\n" ) ; break ; } playlist = gf_fopen ( the_url , "rt" ) ; if ( playlist ) { if ( 1 > fscanf ( playlist , "%s" , the_url ) ) { fprintf ( stderr , "Cannot<S2SV_blank>read<S2SV_blank>any<S2SV_blank>URL<S2SV_blank>from<S2SV_blank>playlist,<S2SV_blank>aborting.\\n" ) ; gf_fclose ( playlist ) ; break ; } fprintf ( stderr , "Opening<S2SV_blank>URL<S2SV_blank>%s\\n" , the_url ) ; gf_term_connect ( term , the_url ) ; } break ; case '\\n' : case 'N' : if ( playlist ) { int res ; gf_term_disconnect ( term ) ; res = fscanf ( playlist , "%s" , the_url ) ; if ( ( res == EOF ) && loop_at_end ) { fseek ( playlist , 0 , SEEK_SET ) ; res = fscanf ( playlist , "%s" , the_url ) ; } if ( res == EOF ) { fprintf ( stderr , "No<S2SV_blank>more<S2SV_blank>items<S2SV_blank>-<S2SV_blank>exiting\\n" ) ; Run = 0 ; } else if ( the_url [ 0 ] == '#' ) { request_next_playlist_item = GF_TRUE ; } else { fprintf ( stderr , "Opening<S2SV_blank>URL<S2SV_blank>%s\\n" , the_url ) ; gf_term_connect_with_path ( term , the_url , pl_path ) ; } } break ; case 'P' : if ( playlist ) { u32 count ; gf_term_disconnect ( term ) ; if ( 1 > scanf ( "%u" , & count ) ) { fprintf ( stderr , "Cannot<S2SV_blank>read<S2SV_blank>number,<S2SV_blank>aborting.\\n" ) ; break ; } while ( count ) { if ( fscanf ( playlist , "%s" , the_url ) ) { fprintf ( stderr , "Failed<S2SV_blank>to<S2SV_blank>read<S2SV_blank>line,<S2SV_blank>aborting\\n" ) ; break ; } count -- ; } fprintf ( stderr , "Opening<S2SV_blank>URL<S2SV_blank>%s\\n" , the_url ) ; gf_term_connect ( term , the_url ) ; } break ; case 'r' : if ( is_connected ) reload = 1 ; break ; case 'D' : if ( is_connected ) gf_term_disconnect ( term ) ; break ; case 'p' : if ( is_connected ) { Bool is_pause = gf_term_get_option ( term , GF_OPT_PLAY_STATE ) ; fprintf ( stderr , "[Status:<S2SV_blank>%s]\\n" , is_pause ? "Playing" : "Paused" ) ; gf_term_set_option ( term , GF_OPT_PLAY_STATE , is_pause ? GF_STATE_PLAYING : GF_STATE_PAUSED ) ; } break ; case 's' : if ( is_connected ) { gf_term_set_option ( term , GF_OPT_PLAY_STATE , GF_STATE_STEP_PAUSE ) ; fprintf ( stderr , "Step<S2SV_blank>time:<S2SV_blank>" ) ; PrintTime ( gf_term_get_time_in_ms ( term ) ) ; fprintf ( stderr , "\\n" ) ; } break ; case 'z' : case 'T' : if ( ! CanSeek || ( Duration <= 2000 ) ) { fprintf ( stderr , "scene<S2SV_blank>not<S2SV_blank>seekable\\n" ) ; } else { Double res ; s32 seekTo ; fprintf ( stderr , "Duration:<S2SV_blank>" ) ; PrintTime ( Duration ) ; res = gf_term_get_time_in_ms ( term ) ; if ( c == 'z' ) { res *= 100 ; res /= ( s64 ) Duration ; fprintf ( stderr , "<S2SV_blank>(current<S2SV_blank>%.2f<S2SV_blank>%%)\\nEnter<S2SV_blank>Seek<S2SV_blank>percentage:\\n" , res ) ; if ( scanf ( "%d" , & seekTo ) == 1 ) { if ( seekTo > 100 ) seekTo = 100 ; res = ( Double ) ( s64 ) Duration ; res /= 100 ; res *= seekTo ; gf_term_play_from_time ( term , ( u64 ) ( s64 ) res , 0 ) ; } } else { u32 r , h , m , s ; fprintf ( stderr , "<S2SV_blank>-<S2SV_blank>Current<S2SV_blank>Time:<S2SV_blank>" ) ; PrintTime ( ( u64 ) res ) ; fprintf ( stderr , "\\nEnter<S2SV_blank>seek<S2SV_blank>time<S2SV_blank>(Format:<S2SV_blank>s,<S2SV_blank>m:s<S2SV_blank>or<S2SV_blank>h:m:s):\\n" ) ; h = m = s = 0 ; r = scanf ( "%d:%d:%d" , & h , & m , & s ) ; if ( r == 2 ) { s = m ; m = h ; h = 0 ; } else if ( r == 1 ) { s = h ; m = h = 0 ; } if ( r && ( r <= 3 ) ) { u64 time = h * 3600 + m * 60 + s ; gf_term_play_from_time ( term , time * 1000 , 0 ) ; } } } break ; case 't' : { if ( is_connected ) { fprintf ( stderr , "Current<S2SV_blank>Time:<S2SV_blank>" ) ; PrintTime ( gf_term_get_time_in_ms ( term ) ) ; fprintf ( stderr , "<S2SV_blank>-<S2SV_blank>Duration:<S2SV_blank>" ) ; PrintTime ( Duration ) ; fprintf ( stderr , "\\n" ) ; } } break ; case 'w' : if ( is_connected ) PrintWorldInfo ( term ) ; break ; case 'v' : if ( is_connected ) PrintODList ( term , NULL , 0 , 0 , "Root" ) ; break ; case 'i' : if ( is_connected ) { u32 ID ; fprintf ( stderr , "Enter<S2SV_blank>OD<S2SV_blank>ID<S2SV_blank>(0<S2SV_blank>for<S2SV_blank>main<S2SV_blank>OD):<S2SV_blank>" ) ; fflush ( stderr ) ; if ( scanf ( "%ud" , & ID ) == 1 ) { ViewOD ( term , ID , ( u32 ) - 1 , NULL ) ; } else { char str_url [ GF_MAX_PATH ] ; if ( scanf ( "%s" , str_url ) == 1 ) ViewOD ( term , 0 , ( u32 ) - 1 , str_url ) ; } } break ; case 'j' : if ( is_connected ) { u32 num ; do { fprintf ( stderr , "Enter<S2SV_blank>OD<S2SV_blank>number<S2SV_blank>(0<S2SV_blank>for<S2SV_blank>main<S2SV_blank>OD):<S2SV_blank>" ) ; fflush ( stderr ) ; } while ( 1 > scanf ( "%ud" , & num ) ) ; ViewOD ( term , ( u32 ) - 1 , num , NULL ) ; } break ; case 'b' : if ( is_connected ) ViewODs ( term , 1 ) ; break ; case 'm' : if ( is_connected ) ViewODs ( term , 0 ) ; break ; case 'l' : list_modules ( user . modules ) ; break ; case 'n' : if ( is_connected ) set_navigation ( ) ; break ; case 'x' : if ( is_connected ) gf_term_set_option ( term , GF_OPT_NAVIGATION_TYPE , 0 ) ; break ; case 'd' : if ( is_connected ) { GF_ObjectManager * odm = NULL ; char radname [ GF_MAX_PATH ] , * sExt ; GF_Err e ; u32 i , count , odid ; Bool xml_dump , std_out ; radname [ 0 ] = 0 ; do { fprintf ( stderr , "Enter<S2SV_blank>Inline<S2SV_blank>OD<S2SV_blank>ID<S2SV_blank>if<S2SV_blank>any<S2SV_blank>or<S2SV_blank>0<S2SV_blank>:<S2SV_blank>" ) ; fflush ( stderr ) ; } while ( 1 > scanf ( "%ud" , & odid ) ) ; if ( odid ) { GF_ObjectManager * root_odm = gf_term_get_root_object ( term ) ; if ( ! root_odm ) break ; count = gf_term_get_object_count ( term , root_odm ) ; for ( i = 0 ; i < count ; i ++ ) { GF_MediaInfo info ; odm = gf_term_get_object ( term , root_odm , i ) ; if ( gf_term_get_object_info ( term , odm , & info ) == GF_OK ) { if ( info . od -> objectDescriptorID == odid ) break ; } odm = NULL ; } } do { fprintf ( stderr , "Enter<S2SV_blank>file<S2SV_blank>radical<S2SV_blank>name<S2SV_blank>(+\\\'.x\\\'<S2SV_blank>for<S2SV_blank>XML<S2SV_blank>dumping)<S2SV_blank>-<S2SV_blank>\\"std\\"<S2SV_blank>for<S2SV_blank>stderr:<S2SV_blank>" ) ; fflush ( stderr ) ; } while ( 1 > scanf ( "%s" , radname ) ) ; sExt = strrchr ( radname , '.' ) ; xml_dump = 0 ; if ( sExt ) { if ( ! stricmp ( sExt , ".x" ) ) xml_dump = 1 ; sExt [ 0 ] = 0 ; } std_out = strnicmp ( radname , "std" , 3 ) ? 0 : 1 ; e = gf_term_dump_scene ( term , std_out ? NULL : radname , NULL , xml_dump , 0 , odm ) ; fprintf ( stderr , "Dump<S2SV_blank>done<S2SV_blank>(%s)\\n" , gf_error_to_string ( e ) ) ; } break ; case 'c' : PrintGPACConfig ( ) ; break ; case '3' : { Bool use_3d = ! gf_term_get_option ( term , GF_OPT_USE_OPENGL ) ; if ( gf_term_set_option ( term , GF_OPT_USE_OPENGL , use_3d ) == GF_OK ) { fprintf ( stderr , "Using<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>2D<S2SV_blank>drawing\\n" , use_3d ? "OpenGL" : "2D<S2SV_blank>rasterizer" ) ; } } break ; case 'k' : { Bool opt = gf_term_get_option ( term , GF_OPT_STRESS_MODE ) ; opt = ! opt ; fprintf ( stderr , "Turning<S2SV_blank>stress<S2SV_blank>mode<S2SV_blank>%s\\n" , opt ? "on" : "off" ) ; gf_term_set_option ( term , GF_OPT_STRESS_MODE , opt ) ; } break ; case '4' : gf_term_set_option ( term , GF_OPT_ASPECT_RATIO , GF_ASPECT_RATIO_4_3 ) ; break ; case '5' : gf_term_set_option ( term , GF_OPT_ASPECT_RATIO , GF_ASPECT_RATIO_16_9 ) ; break ; case '6' : gf_term_set_option ( term , GF_OPT_ASPECT_RATIO , GF_ASPECT_RATIO_FILL_SCREEN ) ; break ; case '7' : gf_term_set_option ( term , GF_OPT_ASPECT_RATIO , GF_ASPECT_RATIO_KEEP ) ; break ; case 'C' : switch ( gf_term_get_option ( term , GF_OPT_MEDIA_CACHE ) ) { case GF_MEDIA_CACHE_DISABLED : gf_term_set_option ( term , GF_OPT_MEDIA_CACHE , GF_MEDIA_CACHE_ENABLED ) ; break ; case GF_MEDIA_CACHE_ENABLED : gf_term_set_option ( term , GF_OPT_MEDIA_CACHE , GF_MEDIA_CACHE_DISABLED ) ; break ; case GF_MEDIA_CACHE_RUNNING : fprintf ( stderr , "Streaming<S2SV_blank>Cache<S2SV_blank>is<S2SV_blank>running<S2SV_blank>-<S2SV_blank>please<S2SV_blank>stop<S2SV_blank>it<S2SV_blank>first\\n" ) ; continue ; } switch ( gf_term_get_option ( term , GF_OPT_MEDIA_CACHE ) ) { case GF_MEDIA_CACHE_ENABLED : fprintf ( stderr , "Streaming<S2SV_blank>Cache<S2SV_blank>Enabled\\n" ) ; break ; case GF_MEDIA_CACHE_DISABLED : fprintf ( stderr , "Streaming<S2SV_blank>Cache<S2SV_blank>Disabled\\n" ) ; break ; case GF_MEDIA_CACHE_RUNNING : fprintf ( stderr , "Streaming<S2SV_blank>Cache<S2SV_blank>Running\\n" ) ; break ; } break ; case 'S' : case 'A' : if ( gf_term_get_option ( term , GF_OPT_MEDIA_CACHE ) == GF_MEDIA_CACHE_RUNNING ) { gf_term_set_option ( term , GF_OPT_MEDIA_CACHE , ( c == 'S' ) ? GF_MEDIA_CACHE_DISABLED : GF_MEDIA_CACHE_DISCARD ) ; fprintf ( stderr , "Streaming<S2SV_blank>Cache<S2SV_blank>stopped\\n" ) ; } else { fprintf ( stderr , "Streaming<S2SV_blank>Cache<S2SV_blank>not<S2SV_blank>running\\n" ) ; } break ; case 'R' : display_rti = ! display_rti ; ResetCaption ( ) ; break ; case 'F' : if ( display_rti ) display_rti = 0 ; else display_rti = 2 ; ResetCaption ( ) ; break ; case 'u' : { GF_Err e ; char szCom [ 8192 ] ; fprintf ( stderr , "Enter<S2SV_blank>command<S2SV_blank>to<S2SV_blank>send:\\n" ) ; fflush ( stdin ) ; szCom [ 0 ] = 0 ; if ( 1 > scanf ( "%[^\\t\\n]" , szCom ) ) { fprintf ( stderr , "Cannot<S2SV_blank>read<S2SV_blank>command<S2SV_blank>to<S2SV_blank>send,<S2SV_blank>aborting.\\n" ) ; break ; } e = gf_term_scene_update ( term , NULL , szCom ) ; if ( e ) fprintf ( stderr , "Processing<S2SV_blank>command<S2SV_blank>failed:<S2SV_blank>%s\\n" , gf_error_to_string ( e ) ) ; } break ; case 'e' : { GF_Err e ; char jsCode [ 8192 ] ; fprintf ( stderr , "Enter<S2SV_blank>JavaScript<S2SV_blank>code<S2SV_blank>to<S2SV_blank>evaluate:\\n" ) ; fflush ( stdin ) ; jsCode [ 0 ] = 0 ; if ( 1 > scanf ( "%[^\\t\\n]" , jsCode ) ) { fprintf ( stderr , "Cannot<S2SV_blank>read<S2SV_blank>code<S2SV_blank>to<S2SV_blank>evaluate,<S2SV_blank>aborting.\\n" ) ; break ; } e = gf_term_scene_update ( term , "application/ecmascript" , jsCode ) ; if ( e ) fprintf ( stderr , "Processing<S2SV_blank>JS<S2SV_blank>code<S2SV_blank>failed:<S2SV_blank>%s\\n" , gf_error_to_string ( e ) ) ; } break ; case 'L' : { char szLog [ 1024 ] , * cur_logs ; cur_logs = gf_log_get_tools_levels ( ) ; fprintf ( stderr , "Enter<S2SV_blank>new<S2SV_blank>log<S2SV_blank>level<S2SV_blank>(current<S2SV_blank>tools<S2SV_blank>%s):\\n" , cur_logs ) ; gf_free ( cur_logs ) ; if ( scanf ( "%s" , szLog ) < 1 ) { fprintf ( stderr , "Cannot<S2SV_blank>read<S2SV_blank>new<S2SV_blank>log<S2SV_blank>level,<S2SV_blank>aborting.\\n" ) ; break ; } gf_log_modify_tools_levels ( szLog ) ; } break ; case 'g' : { GF_SystemRTInfo rti ; gf_sys_get_rti ( rti_update_time_ms , & rti , 0 ) ; fprintf ( stderr , "GPAC<S2SV_blank>allocated<S2SV_blank>memory<S2SV_blank>" LLD "\\n" , rti . gpac_memory ) ; } break ; case 'M' : { u32 size ; do { fprintf ( stderr , "Enter<S2SV_blank>new<S2SV_blank>video<S2SV_blank>cache<S2SV_blank>memory<S2SV_blank>in<S2SV_blank>kBytes<S2SV_blank>(current<S2SV_blank>%ud):\\n" , gf_term_get_option ( term , GF_OPT_VIDEO_CACHE_SIZE ) ) ; } while ( 1 > scanf ( "%ud" , & size ) ) ; gf_term_set_option ( term , GF_OPT_VIDEO_CACHE_SIZE , size ) ; } break ; case 'H' : { u32 http_bitrate = gf_term_get_option ( term , GF_OPT_HTTP_MAX_RATE ) ; do { fprintf ( stderr , "Enter<S2SV_blank>new<S2SV_blank>http<S2SV_blank>bitrate<S2SV_blank>in<S2SV_blank>bps<S2SV_blank>(0<S2SV_blank>for<S2SV_blank>none)<S2SV_blank>-<S2SV_blank>current<S2SV_blank>limit:<S2SV_blank>%d\\n" , http_bitrate ) ; } while ( 1 > scanf ( "%ud" , & http_bitrate ) ) ; gf_term_set_option ( term , GF_OPT_HTTP_MAX_RATE , http_bitrate ) ; } break ; case 'E' : gf_term_set_option ( term , GF_OPT_RELOAD_CONFIG , 1 ) ; break ; case 'B' : switch_bench ( ! bench_mode ) ; break ; case 'Y' : { char szOpt [ 8192 ] ; fprintf ( stderr , "Enter<S2SV_blank>option<S2SV_blank>to<S2SV_blank>set<S2SV_blank>(Section:Name=Value):\\n" ) ; fflush ( stdin ) ; szOpt [ 0 ] = 0 ; if ( 1 > scanf ( "%[^\\t\\n]" , szOpt ) ) { fprintf ( stderr , "Cannot<S2SV_blank>read<S2SV_blank>option\\n" ) ; break ; } set_cfg_option ( szOpt ) ; } break ; case 'Z' : { char szFileName [ 100 ] ; u32 nb_pass , nb_views , offscreen_view = 0 ; GF_VideoSurface fb ; GF_Err e ; nb_pass = 1 ; nb_views = gf_term_get_option ( term , GF_OPT_NUM_STEREO_VIEWS ) ; if ( nb_views > 1 ) { fprintf ( stderr , "Auto-stereo<S2SV_blank>mode<S2SV_blank>detected<S2SV_blank>-<S2SV_blank>type<S2SV_blank>number<S2SV_blank>of<S2SV_blank>view<S2SV_blank>to<S2SV_blank>dump<S2SV_blank>(0<S2SV_blank>is<S2SV_blank>main<S2SV_blank>output,<S2SV_blank>1<S2SV_blank>to<S2SV_blank>%d<S2SV_blank>offscreen<S2SV_blank>view,<S2SV_blank>%d<S2SV_blank>for<S2SV_blank>all<S2SV_blank>offscreen,<S2SV_blank>%d<S2SV_blank>for<S2SV_blank>all<S2SV_blank>offscreen<S2SV_blank>and<S2SV_blank>main)\\n" , nb_views , nb_views + 1 , nb_views + 2 ) ; if ( scanf ( "%d" , & offscreen_view ) != 1 ) { offscreen_view = 0 ; } if ( offscreen_view == nb_views + 1 ) { offscreen_view = 1 ; nb_pass = nb_views ; } else if ( offscreen_view == nb_views + 2 ) { offscreen_view = 0 ; nb_pass = nb_views + 1 ; } } while ( nb_pass ) { nb_pass -- ; if ( offscreen_view ) { sprintf ( szFileName , "view%d_dump.png" , offscreen_view ) ; e = gf_term_get_offscreen_buffer ( term , & fb , offscreen_view - 1 , 0 ) ; } else { sprintf ( szFileName , "gpac_video_dump_" LLU ".png" , gf_net_get_utc ( ) ) ; e = gf_term_get_screen_buffer ( term , & fb ) ; } offscreen_view ++ ; if ( e ) { fprintf ( stderr , "Error<S2SV_blank>dumping<S2SV_blank>screen<S2SV_blank>buffer<S2SV_blank>%s\\n" , gf_error_to_string ( e ) ) ; nb_pass = 0 ; } else { # ifndef GPAC_DISABLE_AV_PARSERS u32 dst_size = fb . width * fb . height * 4 ; char * dst = ( char * ) gf_malloc ( sizeof ( char ) * dst_size ) ; e = gf_img_png_enc ( fb . video_buffer , fb . width , fb . height , fb . pitch_y , fb . pixel_format , dst , & dst_size ) ; if ( e ) { fprintf ( stderr , "Error<S2SV_blank>encoding<S2SV_blank>PNG<S2SV_blank>%s\\n" , gf_error_to_string ( e ) ) ; nb_pass = 0 ; } else { FILE * png = gf_fopen ( szFileName , "wb" ) ; if ( ! png ) { fprintf ( stderr , "Error<S2SV_blank>writing<S2SV_blank>file<S2SV_blank>%s\\n" , szFileName ) ; nb_pass = 0 ; } else { gf_fwrite ( dst , dst_size , 1 , png ) ; gf_fclose ( png ) ; fprintf ( stderr , "Dump<S2SV_blank>to<S2SV_blank>%s\\n" , szFileName ) ; } } if ( dst ) gf_free ( dst ) ; gf_term_release_screen_buffer ( term , & fb ) ; # endif } } fprintf ( stderr , "Done:<S2SV_blank>%s\\n" , szFileName ) ; } break ; case 'G' : { GF_ObjectManager * root_od , * odm ; u32 index ; char szOpt [ 8192 ] ; fprintf ( stderr , "Enter<S2SV_blank>0-based<S2SV_blank>index<S2SV_blank>of<S2SV_blank>object<S2SV_blank>to<S2SV_blank>select<S2SV_blank>or<S2SV_blank>service<S2SV_blank>ID:\\n" ) ; fflush ( stdin ) ; szOpt [ 0 ] = 0 ; if ( 1 > scanf ( "%[^\\t\\n]" , szOpt ) ) { fprintf ( stderr , "Cannot<S2SV_blank>read<S2SV_blank>OD<S2SV_blank>ID\\n" ) ; break ; } index = atoi ( szOpt ) ; odm = NULL ; root_od = gf_term_get_root_object ( term ) ; if ( root_od ) { if ( gf_term_find_service ( term , root_od , index ) ) { gf_term_select_service ( term , root_od , index ) ; } else { fprintf ( stderr , "Cannot<S2SV_blank>find<S2SV_blank>service<S2SV_blank>%d<S2SV_blank>-<S2SV_blank>trying<S2SV_blank>with<S2SV_blank>object<S2SV_blank>index\\n" , index ) ; odm = gf_term_get_object ( term , root_od , index ) ; if ( odm ) { gf_term_select_object ( term , odm ) ; } else { fprintf ( stderr , "Cannot<S2SV_blank>find<S2SV_blank>object<S2SV_blank>at<S2SV_blank>index<S2SV_blank>%d\\n" , index ) ; } } } } break ; case 'h' : PrintHelp ( ) ; break ; default : break ; } } if ( bench_mode ) { PrintAVInfo ( GF_TRUE ) ; } if ( simulation_time_in_ms ) { gf_log_set_strict_error ( 0 ) ; } i = gf_sys_clock ( ) ; gf_term_disconnect ( term ) ; if ( rti_file ) UpdateRTInfo ( "Disconnected\\n" ) ; fprintf ( stderr , "Deleting<S2SV_blank>terminal...<S2SV_blank>" ) ; if ( playlist ) gf_fclose ( playlist ) ; # if defined ( __DARWIN__ ) || defined ( __APPLE__ ) carbon_uninit ( ) ; # endif gf_term_del ( term ) ; fprintf ( stderr , "done<S2SV_blank>(in<S2SV_blank>%d<S2SV_blank>ms)<S2SV_blank>-<S2SV_blank>ran<S2SV_blank>for<S2SV_blank>%d<S2SV_blank>ms\\n" , gf_sys_clock ( ) - i , gf_sys_clock ( ) ) ; fprintf ( stderr , "GPAC<S2SV_blank>cleanup<S2SV_blank>...\\n" ) ; gf_modules_del ( user . modules ) ; if ( no_cfg_save ) gf_cfg_discard_changes ( cfg_file ) ; gf_cfg_del ( cfg_file ) ; gf_sys_close ( ) ; if ( rti_logs ) gf_fclose ( rti_logs ) ; if ( logfile ) gf_fclose ( logfile ) ; if ( gui_mode ) { hide_shell ( 2 ) ; } # ifdef GPAC_MEMORY_TRACKING if ( mem_track && ( gf_memory_size ( ) || gf_file_handles_count ( ) ) ) { gf_log_set_tool_level ( GF_LOG_MEMORY , GF_LOG_INFO ) ; gf_memory_print ( ) ; return 2 ; } # endif return ret_val ; }
CWE-787 char * gf_text_get_utf8_line ( char * szLine , u32 lineSize , FILE * txt_in , s32 unicode_type ) { u32 i , j , len ; char * sOK ; char szLineConv [ 1024 ] ; unsigned short * sptr ; memset ( szLine , 0 , sizeof ( char ) * lineSize ) ; sOK = fgets ( szLine , lineSize , txt_in ) ; if ( ! sOK ) return NULL ; if ( unicode_type <= 1 ) { j = 0 ; len = ( u32 ) strlen ( szLine ) ; <S2SV_StartBug> for ( i = 0 ; i < len ; i ++ ) { <S2SV_EndBug> if ( ! unicode_type && ( szLine [ i ] & 0x80 ) ) { if ( ( szLine [ i + 1 ] & 0xc0 ) != 0x80 ) { <S2SV_StartBug> szLineConv [ j ] = 0xc0 | ( ( szLine [ i ] >> 6 ) & 0x3 ) ; <S2SV_EndBug> j ++ ; szLine [ i ] &= 0xbf ; } <S2SV_StartBug> else if ( ( szLine [ i ] & 0xe0 ) == 0xc0 ) { <S2SV_EndBug> <S2SV_StartBug> szLineConv [ j ] = szLine [ i ] ; <S2SV_EndBug> i ++ ; j ++ ; } else if ( ( szLine [ i ] & 0xf0 ) == 0xe0 ) { <S2SV_StartBug> szLineConv [ j ] = szLine [ i ] ; <S2SV_EndBug> i ++ ; j ++ ; szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; } else if ( ( szLine [ i ] & 0xf8 ) == 0xf0 ) { <S2SV_StartBug> szLineConv [ j ] = szLine [ i ] ; <S2SV_EndBug> i ++ ; j ++ ; szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; } else { i += 1 ; continue ; } } <S2SV_StartBug> szLineConv [ j ] = szLine [ i ] ; <S2SV_EndBug> j ++ ; } szLineConv [ j ] = 0 ; strcpy ( szLine , szLineConv ) ; return sOK ; } # ifdef GPAC_BIG_ENDIAN if ( unicode_type == 3 ) { # else if ( unicode_type == 2 ) { # endif i = 0 ; while ( 1 ) { char c ; if ( ! szLine [ i ] && ! szLine [ i + 1 ] ) break ; c = szLine [ i + 1 ] ; szLine [ i + 1 ] = szLine [ i ] ; szLine [ i ] = c ; i += 2 ; } } sptr = ( u16 * ) szLine ; i = ( u32 ) gf_utf8_wcstombs ( szLineConv , 1024 , ( const unsigned short * * ) & sptr ) ; if ( i >= ( u32 ) ARRAY_LENGTH ( szLineConv ) ) return NULL ; szLineConv [ i ] = 0 ; strcpy ( szLine , szLineConv ) ; if ( unicode_type == 3 ) fgetc ( txt_in ) ; return sOK ; }
CWE-119 GF_Err cat_multiple_files ( GF_ISOFile * dest , char * fileName , u32 import_flags , Double force_fps , u32 frames_per_sample , char * tmp_dir , Bool force_cat , Bool align_timelines , Bool allow_add_in_command ) { CATEnum cat_enum ; char * sep ; cat_enum . dest = dest ; cat_enum . import_flags = import_flags ; cat_enum . force_fps = force_fps ; cat_enum . frames_per_sample = frames_per_sample ; cat_enum . tmp_dir = tmp_dir ; cat_enum . force_cat = force_cat ; cat_enum . align_timelines = align_timelines ; cat_enum . allow_add_in_command = allow_add_in_command ; <S2SV_StartBug> strcpy ( cat_enum . szPath , fileName ) ; <S2SV_EndBug> sep = strrchr ( cat_enum . szPath , GF_PATH_SEPARATOR ) ; if ( ! sep ) sep = strrchr ( cat_enum . szPath , '/' ) ; if ( ! sep ) { strcpy ( cat_enum . szPath , "." ) ; <S2SV_StartBug> strcpy ( cat_enum . szRad1 , fileName ) ; <S2SV_EndBug> } else { <S2SV_StartBug> strcpy ( cat_enum . szRad1 , sep + 1 ) ; <S2SV_EndBug> sep [ 0 ] = 0 ; } <S2SV_StartBug> sep = strchr ( cat_enum . szRad1 , '*' ) ; <S2SV_EndBug> <S2SV_StartBug> strcpy ( cat_enum . szRad2 , sep + 1 ) ; <S2SV_EndBug> sep [ 0 ] = 0 ; <S2SV_StartBug> sep = strchr ( cat_enum . szRad2 , '%' ) ; <S2SV_EndBug> if ( ! sep ) sep = strchr ( cat_enum . szRad2 , '#' ) ; if ( ! sep ) sep = strchr ( cat_enum . szRad2 , ':' ) ; strcpy ( cat_enum . szOpt , "" ) ; <S2SV_StartBug> if ( sep ) { <S2SV_EndBug> strcpy ( cat_enum . szOpt , sep ) ; sep [ 0 ] = 0 ; } return gf_enum_directory ( cat_enum . szPath , 0 , cat_enumerate , & cat_enum , NULL ) ; }
CWE-119 Bool GPAC_EventProc ( void * ptr , GF_Event * evt ) { if ( ! term ) return 0 ; if ( gui_mode == 1 ) { if ( evt -> type == GF_EVENT_QUIT ) { Run = 0 ; } else if ( evt -> type == GF_EVENT_KEYDOWN ) { switch ( evt -> key . key_code ) { case GF_KEY_C : if ( evt -> key . flags & ( GF_KEY_MOD_CTRL | GF_KEY_MOD_ALT ) ) { hide_shell ( shell_visible ? 1 : 0 ) ; if ( shell_visible ) gui_mode = 2 ; } break ; default : break ; } } return 0 ; } switch ( evt -> type ) { case GF_EVENT_DURATION : Duration = ( u64 ) ( 1000 * ( s64 ) evt -> duration . duration ) ; CanSeek = evt -> duration . can_seek ; break ; case GF_EVENT_MESSAGE : { const char * servName ; if ( ! evt -> message . service || ! strcmp ( evt -> message . service , the_url ) ) { servName = "" ; } else if ( ! strnicmp ( evt -> message . service , "data:" , 5 ) ) { servName = "(embedded<S2SV_blank>data)" ; } else { servName = evt -> message . service ; } if ( ! evt -> message . message ) return 0 ; if ( evt -> message . error ) { if ( ! is_connected ) last_error = evt -> message . error ; if ( evt -> message . error == GF_SCRIPT_INFO ) { GF_LOG ( GF_LOG_INFO , GF_LOG_CONSOLE , ( "%s\\n" , evt -> message . message ) ) ; } else { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONSOLE , ( "%s<S2SV_blank>%s:<S2SV_blank>%s\\n" , servName , evt -> message . message , gf_error_to_string ( evt -> message . error ) ) ) ; } } else if ( ! be_quiet ) GF_LOG ( GF_LOG_INFO , GF_LOG_CONSOLE , ( "%s<S2SV_blank>%s\\n" , servName , evt -> message . message ) ) ; } break ; case GF_EVENT_PROGRESS : { char * szTitle = "" ; if ( evt -> progress . progress_type == 0 ) { szTitle = "Buffer<S2SV_blank>" ; if ( bench_mode && ( bench_mode != 3 ) ) { if ( evt -> progress . done >= evt -> progress . total ) bench_buffer = 0 ; else bench_buffer = 1 + 100 * evt -> progress . done / evt -> progress . total ; break ; } } else if ( evt -> progress . progress_type == 1 ) { if ( bench_mode ) break ; szTitle = "Download<S2SV_blank>" ; } else if ( evt -> progress . progress_type == 2 ) szTitle = "Import<S2SV_blank>" ; gf_set_progress ( szTitle , evt -> progress . done , evt -> progress . total ) ; } break ; case GF_EVENT_DBLCLICK : gf_term_set_option ( term , GF_OPT_FULLSCREEN , ! gf_term_get_option ( term , GF_OPT_FULLSCREEN ) ) ; return 0 ; case GF_EVENT_MOUSEDOWN : if ( evt -> mouse . button == GF_MOUSE_RIGHT ) { right_down = 1 ; last_x = evt -> mouse . x ; last_y = evt -> mouse . y ; } return 0 ; case GF_EVENT_MOUSEUP : if ( evt -> mouse . button == GF_MOUSE_RIGHT ) { right_down = 0 ; last_x = evt -> mouse . x ; last_y = evt -> mouse . y ; } return 0 ; case GF_EVENT_MOUSEMOVE : if ( right_down && ( user . init_flags & GF_TERM_WINDOWLESS ) ) { GF_Event move ; move . move . x = evt -> mouse . x - last_x ; move . move . y = last_y - evt -> mouse . y ; move . type = GF_EVENT_MOVE ; move . move . relative = 1 ; gf_term_user_event ( term , & move ) ; } return 0 ; case GF_EVENT_KEYUP : switch ( evt -> key . key_code ) { case GF_KEY_SPACE : if ( evt -> key . flags & GF_KEY_MOD_CTRL ) switch_bench ( ! bench_mode ) ; break ; } break ; case GF_EVENT_KEYDOWN : gf_term_process_shortcut ( term , evt ) ; switch ( evt -> key . key_code ) { case GF_KEY_SPACE : if ( evt -> key . flags & GF_KEY_MOD_CTRL ) { if ( ! bench_mode ) switch_bench ( ! bench_mode ) ; } break ; case GF_KEY_PAGEDOWN : case GF_KEY_MEDIANEXTTRACK : request_next_playlist_item = 1 ; break ; case GF_KEY_MEDIAPREVIOUSTRACK : break ; case GF_KEY_ESCAPE : gf_term_set_option ( term , GF_OPT_FULLSCREEN , ! gf_term_get_option ( term , GF_OPT_FULLSCREEN ) ) ; break ; case GF_KEY_C : if ( evt -> key . flags & ( GF_KEY_MOD_CTRL | GF_KEY_MOD_ALT ) ) { hide_shell ( shell_visible ? 1 : 0 ) ; if ( ! shell_visible ) gui_mode = 1 ; } break ; case GF_KEY_F : if ( evt -> key . flags & GF_KEY_MOD_CTRL ) fprintf ( stderr , "Rendering<S2SV_blank>rate:<S2SV_blank>%f<S2SV_blank>FPS\\n" , gf_term_get_framerate ( term , 0 ) ) ; break ; case GF_KEY_T : if ( evt -> key . flags & GF_KEY_MOD_CTRL ) fprintf ( stderr , "Scene<S2SV_blank>Time:<S2SV_blank>%f<S2SV_blank>\\n" , gf_term_get_time_in_ms ( term ) / 1000.0 ) ; break ; case GF_KEY_D : if ( evt -> key . flags & GF_KEY_MOD_CTRL ) gf_term_set_option ( term , GF_OPT_DRAW_MODE , ( gf_term_get_option ( term , GF_OPT_DRAW_MODE ) == GF_DRAW_MODE_DEFER ) ? GF_DRAW_MODE_IMMEDIATE : GF_DRAW_MODE_DEFER ) ; break ; case GF_KEY_4 : if ( evt -> key . flags & GF_KEY_MOD_CTRL ) gf_term_set_option ( term , GF_OPT_ASPECT_RATIO , GF_ASPECT_RATIO_4_3 ) ; break ; case GF_KEY_5 : if ( evt -> key . flags & GF_KEY_MOD_CTRL ) gf_term_set_option ( term , GF_OPT_ASPECT_RATIO , GF_ASPECT_RATIO_16_9 ) ; break ; case GF_KEY_6 : if ( evt -> key . flags & GF_KEY_MOD_CTRL ) gf_term_set_option ( term , GF_OPT_ASPECT_RATIO , GF_ASPECT_RATIO_FILL_SCREEN ) ; break ; case GF_KEY_7 : if ( evt -> key . flags & GF_KEY_MOD_CTRL ) gf_term_set_option ( term , GF_OPT_ASPECT_RATIO , GF_ASPECT_RATIO_KEEP ) ; break ; case GF_KEY_O : if ( ( evt -> key . flags & GF_KEY_MOD_CTRL ) && is_connected ) { if ( gf_term_get_option ( term , GF_OPT_MAIN_ADDON ) ) { fprintf ( stderr , "Resuming<S2SV_blank>to<S2SV_blank>main<S2SV_blank>content\\n" ) ; gf_term_set_option ( term , GF_OPT_PLAY_STATE , GF_STATE_PLAY_LIVE ) ; } else { fprintf ( stderr , "Main<S2SV_blank>addon<S2SV_blank>not<S2SV_blank>enabled\\n" ) ; } } break ; case GF_KEY_P : if ( ( evt -> key . flags & GF_KEY_MOD_CTRL ) && is_connected ) { u32 pause_state = gf_term_get_option ( term , GF_OPT_PLAY_STATE ) ; fprintf ( stderr , "[Status:<S2SV_blank>%s]\\n" , pause_state ? "Playing" : "Paused" ) ; if ( ( pause_state == GF_STATE_PAUSED ) && ( evt -> key . flags & GF_KEY_MOD_SHIFT ) ) { gf_term_set_option ( term , GF_OPT_PLAY_STATE , GF_STATE_PLAY_LIVE ) ; } else { gf_term_set_option ( term , GF_OPT_PLAY_STATE , ( pause_state == GF_STATE_PAUSED ) ? GF_STATE_PLAYING : GF_STATE_PAUSED ) ; } } break ; case GF_KEY_S : if ( ( evt -> key . flags & GF_KEY_MOD_CTRL ) && is_connected ) { gf_term_set_option ( term , GF_OPT_PLAY_STATE , GF_STATE_STEP_PAUSE ) ; fprintf ( stderr , "Step<S2SV_blank>time:<S2SV_blank>" ) ; PrintTime ( gf_term_get_time_in_ms ( term ) ) ; fprintf ( stderr , "\\n" ) ; } break ; case GF_KEY_B : if ( ( evt -> key . flags & GF_KEY_MOD_CTRL ) && is_connected ) ViewODs ( term , 1 ) ; break ; case GF_KEY_M : if ( ( evt -> key . flags & GF_KEY_MOD_CTRL ) && is_connected ) ViewODs ( term , 0 ) ; break ; case GF_KEY_H : if ( ( evt -> key . flags & GF_KEY_MOD_CTRL ) && is_connected ) { gf_term_switch_quality ( term , 1 ) ; } break ; case GF_KEY_L : if ( ( evt -> key . flags & GF_KEY_MOD_CTRL ) && is_connected ) { gf_term_switch_quality ( term , 0 ) ; } break ; case GF_KEY_F5 : if ( is_connected ) reload = 1 ; break ; case GF_KEY_A : addon_visible = ! addon_visible ; gf_term_toggle_addons ( term , addon_visible ) ; break ; case GF_KEY_UP : if ( ( evt -> key . flags & VK_MOD ) && is_connected ) { do_set_speed ( playback_speed * 2 ) ; } break ; case GF_KEY_DOWN : if ( ( evt -> key . flags & VK_MOD ) && is_connected ) { do_set_speed ( playback_speed / 2 ) ; } break ; case GF_KEY_LEFT : if ( ( evt -> key . flags & VK_MOD ) && is_connected ) { do_set_speed ( - 1 * playback_speed ) ; } break ; } break ; case GF_EVENT_CONNECT : if ( evt -> connect . is_connected ) { is_connected = 1 ; fprintf ( stderr , "Service<S2SV_blank>Connected\\n" ) ; eos_seen = GF_FALSE ; if ( playback_speed != FIX_ONE ) gf_term_set_speed ( term , playback_speed ) ; } else if ( is_connected ) { fprintf ( stderr , "Service<S2SV_blank>%s\\n" , is_connected ? "Disconnected" : "Connection<S2SV_blank>Failed" ) ; is_connected = 0 ; Duration = 0 ; } if ( init_w && init_h ) { gf_term_set_size ( term , init_w , init_h ) ; } ResetCaption ( ) ; break ; case GF_EVENT_EOS : eos_seen = GF_TRUE ; if ( playlist ) { if ( Duration > 1500 ) request_next_playlist_item = GF_TRUE ; } else if ( loop_at_end ) { restart = 1 ; } break ; case GF_EVENT_SIZE : if ( user . init_flags & GF_TERM_WINDOWLESS ) { GF_Event move ; move . type = GF_EVENT_MOVE ; move . move . align_x = align_mode & 0xFF ; move . move . align_y = ( align_mode >> 8 ) & 0xFF ; move . move . relative = 2 ; gf_term_user_event ( term , & move ) ; } break ; case GF_EVENT_SCENE_SIZE : if ( forced_width && forced_height ) { GF_Event size ; size . type = GF_EVENT_SIZE ; size . size . width = forced_width ; size . size . height = forced_height ; gf_term_user_event ( term , & size ) ; } break ; case GF_EVENT_METADATA : ResetCaption ( ) ; break ; case GF_EVENT_RELOAD : if ( is_connected ) reload = 1 ; break ; case GF_EVENT_DROPFILE : { u32 i , pos ; if ( readonly_playlist ) { gf_fclose ( playlist ) ; playlist = NULL ; } readonly_playlist = 0 ; if ( ! playlist ) { readonly_playlist = 0 ; playlist = gf_temp_file_new ( NULL ) ; } pos = ftell ( playlist ) ; i = 0 ; while ( i < evt -> open_file . nb_files ) { if ( evt -> open_file . files [ i ] != NULL ) { fprintf ( playlist , "%s\\n" , evt -> open_file . files [ i ] ) ; } i ++ ; } fseek ( playlist , pos , SEEK_SET ) ; request_next_playlist_item = 1 ; } return 1 ; case GF_EVENT_QUIT : if ( evt -> message . error ) { fprintf ( stderr , "A<S2SV_blank>fatal<S2SV_blank>error<S2SV_blank>was<S2SV_blank>encoutered:<S2SV_blank>%s<S2SV_blank>(%s)<S2SV_blank>-<S2SV_blank>exiting<S2SV_blank>...\\n" , evt -> message . message ? evt -> message . message : "no<S2SV_blank>details" , gf_error_to_string ( evt -> message . error ) ) ; } Run = 0 ; break ; case GF_EVENT_DISCONNECT : gf_term_disconnect ( term ) ; break ; case GF_EVENT_MIGRATE : { } break ; case GF_EVENT_NAVIGATE_INFO : if ( evt -> navigate . to_url ) fprintf ( stderr , "Go<S2SV_blank>to<S2SV_blank>URL:<S2SV_blank>\\"%s\\"\\r" , evt -> navigate . to_url ) ; break ; case GF_EVENT_NAVIGATE : if ( gf_term_is_supported_url ( term , evt -> navigate . to_url , 1 , no_mime_check ) ) { <S2SV_StartBug> strcpy ( the_url , evt -> navigate . to_url ) ; <S2SV_EndBug> fprintf ( stderr , "Navigating<S2SV_blank>to<S2SV_blank>URL<S2SV_blank>%s\\n" , the_url ) ; gf_term_navigate_to ( term , evt -> navigate . to_url ) ; return 1 ; } else { fprintf ( stderr , "Navigation<S2SV_blank>destination<S2SV_blank>not<S2SV_blank>supported\\nGo<S2SV_blank>to<S2SV_blank>URL:<S2SV_blank>%s\\n" , evt -> navigate . to_url ) ; } break ; case GF_EVENT_SET_CAPTION : gf_term_user_event ( term , evt ) ; break ; case GF_EVENT_AUTHORIZATION : { int maxTries = 1 ; assert ( evt -> type == GF_EVENT_AUTHORIZATION ) ; assert ( evt -> auth . user ) ; assert ( evt -> auth . password ) ; assert ( evt -> auth . site_url ) ; while ( ( ! strlen ( evt -> auth . user ) || ! strlen ( evt -> auth . password ) ) && ( maxTries -- ) >= 0 ) { fprintf ( stderr , "****<S2SV_blank>Authorization<S2SV_blank>required<S2SV_blank>for<S2SV_blank>site<S2SV_blank>%s<S2SV_blank>****\\n" , evt -> auth . site_url ) ; fprintf ( stderr , "login<S2SV_blank><S2SV_blank><S2SV_blank>:<S2SV_blank>" ) ; read_line_input ( evt -> auth . user , 50 , 1 ) ; fprintf ( stderr , "\\npassword:<S2SV_blank>" ) ; read_line_input ( evt -> auth . password , 50 , 0 ) ; fprintf ( stderr , "*********\\n" ) ; } if ( maxTries < 0 ) { fprintf ( stderr , "****<S2SV_blank>No<S2SV_blank>User<S2SV_blank>or<S2SV_blank>password<S2SV_blank>has<S2SV_blank>been<S2SV_blank>filled,<S2SV_blank>aborting<S2SV_blank>***\\n" ) ; return 0 ; } return 1 ; } case GF_EVENT_ADDON_DETECTED : if ( enable_add_ons ) { fprintf ( stderr , "Media<S2SV_blank>Addon<S2SV_blank>%s<S2SV_blank>detected<S2SV_blank>-<S2SV_blank>enabling<S2SV_blank>it\\n" , evt -> addon_connect . addon_url ) ; addon_visible = 1 ; } return enable_add_ons ; } return 0 ; }
CWE-119 int mp4client_main ( int argc , char * * argv ) { char c ; const char * str ; int ret_val = 0 ; u32 i , times [ 100 ] , nb_times , dump_mode ; u32 simulation_time_in_ms = 0 ; u32 initial_service_id = 0 ; Bool auto_exit = GF_FALSE ; Bool logs_set = GF_FALSE ; Bool start_fs = GF_FALSE ; Bool use_rtix = GF_FALSE ; Bool pause_at_first = GF_FALSE ; Bool no_cfg_save = GF_FALSE ; Bool is_cfg_only = GF_FALSE ; Double play_from = 0 ; # ifdef GPAC_MEMORY_TRACKING GF_MemTrackerType mem_track = GF_MemTrackerNone ; # endif Double fps = GF_IMPORT_DEFAULT_FPS ; Bool fill_ar , visible , do_uncache , has_command ; char * url_arg , * out_arg , * the_cfg , * rti_file , * views , * mosaic ; FILE * logfile = NULL ; Float scale = 1 ; # ifndef WIN32 dlopen ( NULL , RTLD_NOW | RTLD_GLOBAL ) ; # endif strcpy ( the_url , "." ) ; memset ( & user , 0 , sizeof ( GF_User ) ) ; dump_mode = DUMP_NONE ; fill_ar = visible = do_uncache = has_command = GF_FALSE ; url_arg = out_arg = the_cfg = rti_file = views = mosaic = NULL ; nb_times = 0 ; times [ 0 ] = 0 ; for ( i = 1 ; i < ( u32 ) argc ; i ++ ) { char * arg = argv [ i ] ; if ( ! strcmp ( arg , "-c" ) || ! strcmp ( arg , "-cfg" ) ) { the_cfg = argv [ i + 1 ] ; i ++ ; } else if ( ! strcmp ( arg , "-mem-track" ) || ! strcmp ( arg , "-mem-track-stack" ) ) { # ifdef GPAC_MEMORY_TRACKING mem_track = ! strcmp ( arg , "-mem-track-stack" ) ? GF_MemTrackerBackTrace : GF_MemTrackerSimple ; # else fprintf ( stderr , "WARNING<S2SV_blank>-<S2SV_blank>GPAC<S2SV_blank>not<S2SV_blank>compiled<S2SV_blank>with<S2SV_blank>Memory<S2SV_blank>Tracker<S2SV_blank>-<S2SV_blank>ignoring<S2SV_blank>\\"%s\\"\\n" , arg ) ; # endif } else if ( ! strcmp ( arg , "-gui" ) ) { gui_mode = 1 ; } else if ( ! strcmp ( arg , "-guid" ) ) { gui_mode = 2 ; } else if ( ! strcmp ( arg , "-h" ) || ! strcmp ( arg , "-help" ) ) { PrintUsage ( ) ; return 0 ; } } # ifdef GPAC_MEMORY_TRACKING gf_sys_init ( mem_track ) ; # else gf_sys_init ( GF_MemTrackerNone ) ; # endif gf_sys_set_args ( argc , ( const char * * ) argv ) ; cfg_file = gf_cfg_init ( the_cfg , NULL ) ; if ( ! cfg_file ) { fprintf ( stderr , "Error:<S2SV_blank>Configuration<S2SV_blank>File<S2SV_blank>not<S2SV_blank>found\\n" ) ; return 1 ; } if ( gf_log_set_tools_levels ( gf_cfg_get_key ( cfg_file , "General" , "Logs" ) ) != GF_OK ) { return 1 ; } if ( gf_cfg_get_key ( cfg_file , "General" , "Logs" ) != NULL ) { logs_set = GF_TRUE ; } if ( ! gui_mode ) { str = gf_cfg_get_key ( cfg_file , "General" , "ForceGUI" ) ; if ( str && ! strcmp ( str , "yes" ) ) gui_mode = 1 ; } for ( i = 1 ; i < ( u32 ) argc ; i ++ ) { char * arg = argv [ i ] ; if ( ! strcmp ( arg , "-rti" ) ) { rti_file = argv [ i + 1 ] ; i ++ ; } else if ( ! strcmp ( arg , "-rtix" ) ) { rti_file = argv [ i + 1 ] ; i ++ ; use_rtix = GF_TRUE ; } else if ( ! stricmp ( arg , "-size" ) ) { if ( sscanf ( argv [ i + 1 ] , "%dx%d" , & forced_width , & forced_height ) != 2 ) { forced_width = forced_height = 0 ; } i ++ ; } else if ( ! strcmp ( arg , "-quiet" ) ) { be_quiet = 1 ; } else if ( ! strcmp ( arg , "-strict-error" ) ) { gf_log_set_strict_error ( 1 ) ; } else if ( ! strcmp ( arg , "-log-file" ) || ! strcmp ( arg , "-lf" ) ) { logfile = gf_fopen ( argv [ i + 1 ] , "wt" ) ; gf_log_set_callback ( logfile , on_gpac_log ) ; i ++ ; } else if ( ! strcmp ( arg , "-logs" ) ) { if ( gf_log_set_tools_levels ( argv [ i + 1 ] ) != GF_OK ) { return 1 ; } logs_set = GF_TRUE ; i ++ ; } else if ( ! strcmp ( arg , "-log-clock" ) || ! strcmp ( arg , "-lc" ) ) { log_time_start = 1 ; } else if ( ! strcmp ( arg , "-log-utc" ) || ! strcmp ( arg , "-lu" ) ) { log_utc_time = 1 ; } # if defined ( __DARWIN__ ) || defined ( __APPLE__ ) else if ( ! strcmp ( arg , "-thread" ) ) threading_flags = 0 ; # else else if ( ! strcmp ( arg , "-no-thread" ) ) threading_flags = GF_TERM_NO_DECODER_THREAD | GF_TERM_NO_COMPOSITOR_THREAD | GF_TERM_WINDOW_NO_THREAD ; # endif else if ( ! strcmp ( arg , "-no-cthread" ) || ! strcmp ( arg , "-no-compositor-thread" ) ) threading_flags |= GF_TERM_NO_COMPOSITOR_THREAD ; else if ( ! strcmp ( arg , "-no-audio" ) ) no_audio = 1 ; else if ( ! strcmp ( arg , "-no-regulation" ) ) no_regulation = 1 ; else if ( ! strcmp ( arg , "-fs" ) ) start_fs = 1 ; else if ( ! strcmp ( arg , "-opt" ) ) { set_cfg_option ( argv [ i + 1 ] ) ; i ++ ; } else if ( ! strcmp ( arg , "-conf" ) ) { set_cfg_option ( argv [ i + 1 ] ) ; is_cfg_only = GF_TRUE ; i ++ ; } else if ( ! strcmp ( arg , "-ifce" ) ) { gf_cfg_set_key ( cfg_file , "Network" , "DefaultMCastInterface" , argv [ i + 1 ] ) ; i ++ ; } else if ( ! stricmp ( arg , "-help" ) ) { PrintUsage ( ) ; return 1 ; } else if ( ! stricmp ( arg , "-noprog" ) ) { no_prog = 1 ; gf_set_progress_callback ( NULL , progress_quiet ) ; } else if ( ! stricmp ( arg , "-no-save" ) || ! stricmp ( arg , "--no-save" ) ) { no_cfg_save = 1 ; } else if ( ! stricmp ( arg , "-ntp-shift" ) ) { s32 shift = atoi ( argv [ i + 1 ] ) ; i ++ ; gf_net_set_ntp_shift ( shift ) ; } else if ( ! stricmp ( arg , "-run-for" ) ) { simulation_time_in_ms = atoi ( argv [ i + 1 ] ) * 1000 ; if ( ! simulation_time_in_ms ) simulation_time_in_ms = 1 ; i ++ ; } else if ( ! strcmp ( arg , "-out" ) ) { out_arg = argv [ i + 1 ] ; i ++ ; } else if ( ! stricmp ( arg , "-fps" ) ) { fps = atof ( argv [ i + 1 ] ) ; i ++ ; } else if ( ! strcmp ( arg , "-avi" ) || ! strcmp ( arg , "-sha" ) ) { dump_mode &= 0xFFFF0000 ; if ( ! strcmp ( arg , "-sha" ) ) dump_mode |= DUMP_SHA1 ; else dump_mode |= DUMP_AVI ; if ( ( url_arg || ( i + 2 < ( u32 ) argc ) ) && get_time_list ( argv [ i + 1 ] , times , & nb_times ) ) { if ( ! strcmp ( arg , "-avi" ) && ( nb_times != 2 ) ) { fprintf ( stderr , "Only<S2SV_blank>one<S2SV_blank>time<S2SV_blank>arg<S2SV_blank>found<S2SV_blank>for<S2SV_blank>-avi<S2SV_blank>-<S2SV_blank>check<S2SV_blank>usage\\n" ) ; return 1 ; } i ++ ; } } else if ( ! strcmp ( arg , "-rgbds" ) ) { dump_mode |= DUMP_RGB_DEPTH_SHAPE ; } else if ( ! strcmp ( arg , "-rgbd" ) ) { dump_mode |= DUMP_RGB_DEPTH ; } else if ( ! strcmp ( arg , "-depth" ) ) { dump_mode |= DUMP_DEPTH_ONLY ; } else if ( ! strcmp ( arg , "-bmp" ) ) { dump_mode &= 0xFFFF0000 ; dump_mode |= DUMP_BMP ; if ( ( url_arg || ( i + 2 < ( u32 ) argc ) ) && get_time_list ( argv [ i + 1 ] , times , & nb_times ) ) i ++ ; } else if ( ! strcmp ( arg , "-png" ) ) { dump_mode &= 0xFFFF0000 ; dump_mode |= DUMP_PNG ; if ( ( url_arg || ( i + 2 < ( u32 ) argc ) ) && get_time_list ( argv [ i + 1 ] , times , & nb_times ) ) i ++ ; } else if ( ! strcmp ( arg , "-raw" ) ) { dump_mode &= 0xFFFF0000 ; dump_mode |= DUMP_RAW ; if ( ( url_arg || ( i + 2 < ( u32 ) argc ) ) && get_time_list ( argv [ i + 1 ] , times , & nb_times ) ) i ++ ; } else if ( ! stricmp ( arg , "-scale" ) ) { sscanf ( argv [ i + 1 ] , "%f" , & scale ) ; i ++ ; } else if ( ! strcmp ( arg , "-c" ) || ! strcmp ( arg , "-cfg" ) ) { i ++ ; } if ( ! gui_mode ) { if ( arg [ 0 ] != '-' ) { if ( url_arg ) { fprintf ( stderr , "Several<S2SV_blank>input<S2SV_blank>URLs<S2SV_blank>provided<S2SV_blank>(\\"%s\\",<S2SV_blank>\\"%s\\").<S2SV_blank>Check<S2SV_blank>your<S2SV_blank>command-line.\\n" , url_arg , arg ) ; return 1 ; } url_arg = arg ; } else if ( ! strcmp ( arg , "-loop" ) ) loop_at_end = 1 ; else if ( ! strcmp ( arg , "-bench" ) ) bench_mode = 1 ; else if ( ! strcmp ( arg , "-vbench" ) ) bench_mode = 2 ; else if ( ! strcmp ( arg , "-sbench" ) ) bench_mode = 3 ; else if ( ! strcmp ( arg , "-no-addon" ) ) enable_add_ons = GF_FALSE ; else if ( ! strcmp ( arg , "-pause" ) ) pause_at_first = 1 ; else if ( ! strcmp ( arg , "-play-from" ) ) { play_from = atof ( ( const char * ) argv [ i + 1 ] ) ; i ++ ; } else if ( ! strcmp ( arg , "-speed" ) ) { playback_speed = FLT2FIX ( atof ( ( const char * ) argv [ i + 1 ] ) ) ; if ( playback_speed <= 0 ) playback_speed = FIX_ONE ; i ++ ; } else if ( ! strcmp ( arg , "-no-wnd" ) ) user . init_flags |= GF_TERM_WINDOWLESS ; else if ( ! strcmp ( arg , "-no-back" ) ) user . init_flags |= GF_TERM_WINDOW_TRANSPARENT ; else if ( ! strcmp ( arg , "-align" ) ) { if ( argv [ i + 1 ] [ 0 ] == 'm' ) align_mode = 1 ; else if ( argv [ i + 1 ] [ 0 ] == 'b' ) align_mode = 2 ; align_mode <<= 8 ; if ( argv [ i + 1 ] [ 1 ] == 'm' ) align_mode |= 1 ; else if ( argv [ i + 1 ] [ 1 ] == 'r' ) align_mode |= 2 ; i ++ ; } else if ( ! strcmp ( arg , "-fill" ) ) { fill_ar = GF_TRUE ; } else if ( ! strcmp ( arg , "-show" ) ) { visible = 1 ; } else if ( ! strcmp ( arg , "-uncache" ) ) { do_uncache = GF_TRUE ; } else if ( ! strcmp ( arg , "-exit" ) ) auto_exit = GF_TRUE ; else if ( ! stricmp ( arg , "-views" ) ) { views = argv [ i + 1 ] ; i ++ ; } else if ( ! stricmp ( arg , "-mosaic" ) ) { mosaic = argv [ i + 1 ] ; i ++ ; } else if ( ! stricmp ( arg , "-com" ) ) { has_command = GF_TRUE ; i ++ ; } else if ( ! stricmp ( arg , "-service" ) ) { initial_service_id = atoi ( argv [ i + 1 ] ) ; i ++ ; } } } if ( is_cfg_only ) { gf_cfg_del ( cfg_file ) ; fprintf ( stderr , "GPAC<S2SV_blank>Config<S2SV_blank>updated\\n" ) ; return 0 ; } if ( do_uncache ) { const char * cache_dir = gf_cfg_get_key ( cfg_file , "General" , "CacheDirectory" ) ; do_flatten_cache ( cache_dir ) ; fprintf ( stderr , "GPAC<S2SV_blank>Cache<S2SV_blank>dir<S2SV_blank>%s<S2SV_blank>flattened\\n" , cache_dir ) ; gf_cfg_del ( cfg_file ) ; return 0 ; } if ( dump_mode && ! url_arg ) { FILE * test ; url_arg = ( char * ) gf_cfg_get_key ( cfg_file , "General" , "StartupFile" ) ; test = url_arg ? gf_fopen ( url_arg , "rt" ) : NULL ; if ( ! test ) url_arg = NULL ; else gf_fclose ( test ) ; if ( ! url_arg ) { fprintf ( stderr , "Missing<S2SV_blank>argument<S2SV_blank>for<S2SV_blank>dump\\n" ) ; PrintUsage ( ) ; if ( logfile ) gf_fclose ( logfile ) ; return 1 ; } } if ( ! gui_mode && ! url_arg && ( gf_cfg_get_key ( cfg_file , "General" , "StartupFile" ) != NULL ) ) { gui_mode = 1 ; } # ifdef WIN32 if ( gui_mode == 1 ) { const char * opt ; TCHAR buffer [ 1024 ] ; DWORD res = GetCurrentDirectory ( 1024 , buffer ) ; buffer [ res ] = 0 ; opt = gf_cfg_get_key ( cfg_file , "General" , "ModulesDirectory" ) ; if ( strstr ( opt , buffer ) ) { gui_mode = 1 ; } else { gui_mode = 2 ; } } # endif if ( gui_mode == 1 ) { hide_shell ( 1 ) ; } if ( gui_mode ) { no_prog = 1 ; gf_set_progress_callback ( NULL , progress_quiet ) ; } if ( ! url_arg && simulation_time_in_ms ) simulation_time_in_ms += gf_sys_clock ( ) ; # if defined ( __DARWIN__ ) || defined ( __APPLE__ ) carbon_init ( ) ; # endif if ( dump_mode ) rti_file = NULL ; if ( ! logs_set ) { gf_log_set_tool_level ( GF_LOG_ALL , GF_LOG_WARNING ) ; } if ( rti_file || logfile || log_utc_time || log_time_start ) gf_log_set_callback ( NULL , on_gpac_log ) ; if ( rti_file ) init_rti_logs ( rti_file , url_arg , use_rtix ) ; { GF_SystemRTInfo rti ; if ( gf_sys_get_rti ( 0 , & rti , 0 ) ) fprintf ( stderr , "System<S2SV_blank>info:<S2SV_blank>%d<S2SV_blank>MB<S2SV_blank>RAM<S2SV_blank>-<S2SV_blank>%d<S2SV_blank>cores\\n" , ( u32 ) ( rti . physical_memory / 1024 / 1024 ) , rti . nb_cores ) ; } if ( dump_mode ) { user . init_flags |= GF_TERM_NO_DECODER_THREAD | GF_TERM_NO_COMPOSITOR_THREAD | GF_TERM_NO_REGULATION ; if ( ! visible ) user . init_flags |= GF_TERM_INIT_HIDE ; gf_cfg_set_key ( cfg_file , "Audio" , "DriverName" , "Raw<S2SV_blank>Audio<S2SV_blank>Output" ) ; no_cfg_save = GF_TRUE ; } else { init_w = forced_width ; init_h = forced_height ; } user . modules = gf_modules_new ( NULL , cfg_file ) ; if ( user . modules ) i = gf_modules_get_count ( user . modules ) ; if ( ! i || ! user . modules ) { fprintf ( stderr , "Error:<S2SV_blank>no<S2SV_blank>modules<S2SV_blank>found<S2SV_blank>-<S2SV_blank>exiting\\n" ) ; if ( user . modules ) gf_modules_del ( user . modules ) ; gf_cfg_del ( cfg_file ) ; gf_sys_close ( ) ; if ( logfile ) gf_fclose ( logfile ) ; return 1 ; } fprintf ( stderr , "Modules<S2SV_blank>Found<S2SV_blank>:<S2SV_blank>%d<S2SV_blank>\\n" , i ) ; str = gf_cfg_get_key ( cfg_file , "General" , "GPACVersion" ) ; if ( ! str || strcmp ( str , GPAC_FULL_VERSION ) ) { gf_cfg_del_section ( cfg_file , "PluginsCache" ) ; gf_cfg_set_key ( cfg_file , "General" , "GPACVersion" , GPAC_FULL_VERSION ) ; } user . config = cfg_file ; user . EventProc = GPAC_EventProc ; user . opaque = user . modules ; if ( threading_flags ) user . init_flags |= threading_flags ; if ( no_audio ) user . init_flags |= GF_TERM_NO_AUDIO ; if ( no_regulation ) user . init_flags |= GF_TERM_NO_REGULATION ; if ( threading_flags & ( GF_TERM_NO_DECODER_THREAD | GF_TERM_NO_COMPOSITOR_THREAD ) ) term_step = GF_TRUE ; if ( dump_mode ) user . init_flags |= GF_TERM_USE_AUDIO_HW_CLOCK ; if ( bench_mode ) { gf_cfg_discard_changes ( user . config ) ; auto_exit = GF_TRUE ; gf_cfg_set_key ( user . config , "Audio" , "DriverName" , "Raw<S2SV_blank>Audio<S2SV_blank>Output" ) ; if ( bench_mode != 2 ) { gf_cfg_set_key ( user . config , "Video" , "DriverName" , "Raw<S2SV_blank>Video<S2SV_blank>Output" ) ; gf_cfg_set_key ( user . config , "RAWVideo" , "RawOutput" , "null" ) ; gf_cfg_set_key ( user . config , "Compositor" , "OpenGLMode" , "disable" ) ; } else { gf_cfg_set_key ( user . config , "Video" , "DisableVSync" , "yes" ) ; } } { char dim [ 50 ] ; sprintf ( dim , "%d" , forced_width ) ; gf_cfg_set_key ( user . config , "Compositor" , "DefaultWidth" , forced_width ? dim : NULL ) ; sprintf ( dim , "%d" , forced_height ) ; gf_cfg_set_key ( user . config , "Compositor" , "DefaultHeight" , forced_height ? dim : NULL ) ; } fprintf ( stderr , "Loading<S2SV_blank>GPAC<S2SV_blank>Terminal\\n" ) ; i = gf_sys_clock ( ) ; term = gf_term_new ( & user ) ; if ( ! term ) { fprintf ( stderr , "\\nInit<S2SV_blank>error<S2SV_blank>-<S2SV_blank>check<S2SV_blank>you<S2SV_blank>have<S2SV_blank>at<S2SV_blank>least<S2SV_blank>one<S2SV_blank>video<S2SV_blank>out<S2SV_blank>and<S2SV_blank>one<S2SV_blank>rasterizer...\\nFound<S2SV_blank>modules:\\n" ) ; list_modules ( user . modules ) ; gf_modules_del ( user . modules ) ; gf_cfg_discard_changes ( cfg_file ) ; gf_cfg_del ( cfg_file ) ; gf_sys_close ( ) ; if ( logfile ) gf_fclose ( logfile ) ; return 1 ; } fprintf ( stderr , "Terminal<S2SV_blank>Loaded<S2SV_blank>in<S2SV_blank>%d<S2SV_blank>ms\\n" , gf_sys_clock ( ) - i ) ; if ( bench_mode ) { display_rti = 2 ; gf_term_set_option ( term , GF_OPT_VIDEO_BENCH , ( bench_mode == 3 ) ? 2 : 1 ) ; if ( bench_mode == 1 ) bench_mode = 2 ; } if ( dump_mode ) { if ( fill_ar ) gf_term_set_option ( term , GF_OPT_ASPECT_RATIO , GF_ASPECT_RATIO_FILL_SCREEN ) ; } else { str = gf_cfg_get_key ( cfg_file , "Video" , "DriverName" ) ; if ( ! bench_mode && ! strcmp ( str , "Raw<S2SV_blank>Video<S2SV_blank>Output" ) ) fprintf ( stderr , "WARNING:<S2SV_blank>using<S2SV_blank>raw<S2SV_blank>output<S2SV_blank>video<S2SV_blank>(memory<S2SV_blank>only)<S2SV_blank>-<S2SV_blank>no<S2SV_blank>display<S2SV_blank>used\\n" ) ; str = gf_cfg_get_key ( cfg_file , "Audio" , "DriverName" ) ; if ( ! str || ! strcmp ( str , "No<S2SV_blank>Audio<S2SV_blank>Output<S2SV_blank>Available" ) ) fprintf ( stderr , "WARNING:<S2SV_blank>no<S2SV_blank>audio<S2SV_blank>output<S2SV_blank>available<S2SV_blank>-<S2SV_blank>make<S2SV_blank>sure<S2SV_blank>no<S2SV_blank>other<S2SV_blank>program<S2SV_blank>is<S2SV_blank>locking<S2SV_blank>the<S2SV_blank>sound<S2SV_blank>card\\n" ) ; str = gf_cfg_get_key ( cfg_file , "General" , "NoMIMETypeFetch" ) ; no_mime_check = ( str && ! stricmp ( str , "yes" ) ) ? 1 : 0 ; } str = gf_cfg_get_key ( cfg_file , "HTTPProxy" , "Enabled" ) ; if ( str && ! strcmp ( str , "yes" ) ) { str = gf_cfg_get_key ( cfg_file , "HTTPProxy" , "Name" ) ; if ( str ) fprintf ( stderr , "HTTP<S2SV_blank>Proxy<S2SV_blank>%s<S2SV_blank>enabled\\n" , str ) ; } if ( rti_file ) { str = gf_cfg_get_key ( cfg_file , "General" , "RTIRefreshPeriod" ) ; if ( str ) { rti_update_time_ms = atoi ( str ) ; } else { gf_cfg_set_key ( cfg_file , "General" , "RTIRefreshPeriod" , "200" ) ; } UpdateRTInfo ( "At<S2SV_blank>GPAC<S2SV_blank>load<S2SV_blank>time\\n" ) ; } Run = 1 ; if ( dump_mode ) { if ( ! nb_times ) { times [ 0 ] = 0 ; nb_times ++ ; } ret_val = dump_file ( url_arg , out_arg , dump_mode , fps , forced_width , forced_height , scale , times , nb_times ) ; Run = 0 ; } else if ( views ) { } else if ( ! gui_mode && url_arg ) { char * ext ; <S2SV_StartBug> strcpy ( the_url , url_arg ) ; <S2SV_EndBug> ext = strrchr ( the_url , '.' ) ; if ( ext && ( ! stricmp ( ext , ".m3u" ) || ! stricmp ( ext , ".pls" ) ) ) { GF_Err e = GF_OK ; fprintf ( stderr , "Opening<S2SV_blank>Playlist<S2SV_blank>%s\\n" , the_url ) ; strcpy ( pl_path , the_url ) ; if ( ! strncmp ( "http:" , the_url , 5 ) ) { GF_DownloadSession * sess = gf_dm_sess_new ( term -> downloader , the_url , GF_NETIO_SESSION_NOT_THREADED , NULL , NULL , & e ) ; if ( sess ) { e = gf_dm_sess_process ( sess ) ; <S2SV_StartBug> if ( ! e ) strcpy ( the_url , gf_dm_sess_get_cache_name ( sess ) ) ; <S2SV_EndBug> gf_dm_sess_del ( sess ) ; } } playlist = e ? NULL : gf_fopen ( the_url , "rt" ) ; readonly_playlist = 1 ; if ( playlist ) { request_next_playlist_item = GF_TRUE ; } else { if ( e ) fprintf ( stderr , "Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>playlist<S2SV_blank>%s:<S2SV_blank>%s\\n" , the_url , gf_error_to_string ( e ) ) ; fprintf ( stderr , "Hit<S2SV_blank>\'h\'<S2SV_blank>for<S2SV_blank>help\\n\\n" ) ; } } else { fprintf ( stderr , "Opening<S2SV_blank>URL<S2SV_blank>%s\\n" , the_url ) ; if ( pause_at_first ) fprintf ( stderr , "[Status:<S2SV_blank>Paused]\\n" ) ; gf_term_connect_from_time ( term , the_url , ( u64 ) ( play_from * 1000 ) , pause_at_first ) ; } } else { fprintf ( stderr , "Hit<S2SV_blank>\'h\'<S2SV_blank>for<S2SV_blank>help\\n\\n" ) ; str = gf_cfg_get_key ( cfg_file , "General" , "StartupFile" ) ; if ( str ) { <S2SV_StartBug> strcpy ( the_url , "MP4Client<S2SV_blank>" GPAC_FULL_VERSION ) ; <S2SV_EndBug> gf_term_connect ( term , str ) ; startup_file = 1 ; is_connected = 1 ; } } if ( gui_mode == 2 ) gui_mode = 0 ; if ( start_fs ) gf_term_set_option ( term , GF_OPT_FULLSCREEN , 1 ) ; if ( views ) { char szTemp [ 4046 ] ; sprintf ( szTemp , "views://%s" , views ) ; gf_term_connect ( term , szTemp ) ; } if ( mosaic ) { char szTemp [ 4046 ] ; sprintf ( szTemp , "mosaic://%s" , mosaic ) ; gf_term_connect ( term , szTemp ) ; } if ( bench_mode ) { rti_update_time_ms = 500 ; bench_mode_start = gf_sys_clock ( ) ; } while ( Run ) { if ( ( gui_mode == 1 ) || ! gf_prompt_has_input ( ) ) { if ( reload ) { reload = 0 ; gf_term_disconnect ( term ) ; gf_term_connect ( term , startup_file ? gf_cfg_get_key ( cfg_file , "General" , "StartupFile" ) : the_url ) ; } if ( restart && gf_term_get_option ( term , GF_OPT_IS_OVER ) ) { restart = 0 ; gf_term_play_from_time ( term , 0 , 0 ) ; } if ( request_next_playlist_item ) { c = '\\n' ; request_next_playlist_item = 0 ; goto force_input ; } if ( has_command && is_connected ) { has_command = GF_FALSE ; for ( i = 0 ; i < ( u32 ) argc ; i ++ ) { if ( ! strcmp ( argv [ i ] , "-com" ) ) { gf_term_scene_update ( term , NULL , argv [ i + 1 ] ) ; i ++ ; } } } if ( initial_service_id && is_connected ) { GF_ObjectManager * root_od = gf_term_get_root_object ( term ) ; if ( root_od ) { gf_term_select_service ( term , root_od , initial_service_id ) ; initial_service_id = 0 ; } } if ( ! use_rtix || display_rti ) UpdateRTInfo ( NULL ) ; if ( term_step ) { gf_term_process_step ( term ) ; } else { gf_sleep ( rti_update_time_ms ) ; } if ( auto_exit && eos_seen && gf_term_get_option ( term , GF_OPT_IS_OVER ) ) { Run = GF_FALSE ; } if ( simulation_time_in_ms && ( ( gf_term_get_elapsed_time_in_ms ( term ) > simulation_time_in_ms ) || ( ! url_arg && gf_sys_clock ( ) > simulation_time_in_ms ) ) ) { Run = GF_FALSE ; } continue ; } c = gf_prompt_get_char ( ) ; force_input : switch ( c ) { case 'q' : { GF_Event evt ; memset ( & evt , 0 , sizeof ( GF_Event ) ) ; evt . type = GF_EVENT_QUIT ; gf_term_send_event ( term , & evt ) ; } break ; case 'X' : exit ( 0 ) ; break ; case 'Q' : break ; case 'o' : startup_file = 0 ; gf_term_disconnect ( term ) ; fprintf ( stderr , "Enter<S2SV_blank>the<S2SV_blank>absolute<S2SV_blank>URL\\n" ) ; if ( 1 > scanf ( "%s" , the_url ) ) { fprintf ( stderr , "Cannot<S2SV_blank>read<S2SV_blank>absolute<S2SV_blank>URL,<S2SV_blank>aborting\\n" ) ; break ; } if ( rti_file ) init_rti_logs ( rti_file , the_url , use_rtix ) ; gf_term_connect ( term , the_url ) ; break ; case 'O' : gf_term_disconnect ( term ) ; fprintf ( stderr , "Enter<S2SV_blank>the<S2SV_blank>absolute<S2SV_blank>URL<S2SV_blank>to<S2SV_blank>the<S2SV_blank>playlist\\n" ) ; if ( 1 > scanf ( "%s" , the_url ) ) { fprintf ( stderr , "Cannot<S2SV_blank>read<S2SV_blank>the<S2SV_blank>absolute<S2SV_blank>URL,<S2SV_blank>aborting.\\n" ) ; break ; } playlist = gf_fopen ( the_url , "rt" ) ; if ( playlist ) { if ( 1 > fscanf ( playlist , "%s" , the_url ) ) { fprintf ( stderr , "Cannot<S2SV_blank>read<S2SV_blank>any<S2SV_blank>URL<S2SV_blank>from<S2SV_blank>playlist,<S2SV_blank>aborting.\\n" ) ; gf_fclose ( playlist ) ; break ; } fprintf ( stderr , "Opening<S2SV_blank>URL<S2SV_blank>%s\\n" , the_url ) ; gf_term_connect ( term , the_url ) ; } break ; case '\\n' : case 'N' : if ( playlist ) { int res ; gf_term_disconnect ( term ) ; res = fscanf ( playlist , "%s" , the_url ) ; if ( ( res == EOF ) && loop_at_end ) { fseek ( playlist , 0 , SEEK_SET ) ; res = fscanf ( playlist , "%s" , the_url ) ; } if ( res == EOF ) { fprintf ( stderr , "No<S2SV_blank>more<S2SV_blank>items<S2SV_blank>-<S2SV_blank>exiting\\n" ) ; Run = 0 ; } else if ( the_url [ 0 ] == '#' ) { request_next_playlist_item = GF_TRUE ; } else { fprintf ( stderr , "Opening<S2SV_blank>URL<S2SV_blank>%s\\n" , the_url ) ; gf_term_connect_with_path ( term , the_url , pl_path ) ; } } break ; case 'P' : if ( playlist ) { u32 count ; gf_term_disconnect ( term ) ; if ( 1 > scanf ( "%u" , & count ) ) { fprintf ( stderr , "Cannot<S2SV_blank>read<S2SV_blank>number,<S2SV_blank>aborting.\\n" ) ; break ; } while ( count ) { if ( fscanf ( playlist , "%s" , the_url ) ) { fprintf ( stderr , "Failed<S2SV_blank>to<S2SV_blank>read<S2SV_blank>line,<S2SV_blank>aborting\\n" ) ; break ; } count -- ; } fprintf ( stderr , "Opening<S2SV_blank>URL<S2SV_blank>%s\\n" , the_url ) ; gf_term_connect ( term , the_url ) ; } break ; case 'r' : if ( is_connected ) reload = 1 ; break ; case 'D' : if ( is_connected ) gf_term_disconnect ( term ) ; break ; case 'p' : if ( is_connected ) { Bool is_pause = gf_term_get_option ( term , GF_OPT_PLAY_STATE ) ; fprintf ( stderr , "[Status:<S2SV_blank>%s]\\n" , is_pause ? "Playing" : "Paused" ) ; gf_term_set_option ( term , GF_OPT_PLAY_STATE , is_pause ? GF_STATE_PLAYING : GF_STATE_PAUSED ) ; } break ; case 's' : if ( is_connected ) { gf_term_set_option ( term , GF_OPT_PLAY_STATE , GF_STATE_STEP_PAUSE ) ; fprintf ( stderr , "Step<S2SV_blank>time:<S2SV_blank>" ) ; PrintTime ( gf_term_get_time_in_ms ( term ) ) ; fprintf ( stderr , "\\n" ) ; } break ; case 'z' : case 'T' : if ( ! CanSeek || ( Duration <= 2000 ) ) { fprintf ( stderr , "scene<S2SV_blank>not<S2SV_blank>seekable\\n" ) ; } else { Double res ; s32 seekTo ; fprintf ( stderr , "Duration:<S2SV_blank>" ) ; PrintTime ( Duration ) ; res = gf_term_get_time_in_ms ( term ) ; if ( c == 'z' ) { res *= 100 ; res /= ( s64 ) Duration ; fprintf ( stderr , "<S2SV_blank>(current<S2SV_blank>%.2f<S2SV_blank>%%)\\nEnter<S2SV_blank>Seek<S2SV_blank>percentage:\\n" , res ) ; if ( scanf ( "%d" , & seekTo ) == 1 ) { if ( seekTo > 100 ) seekTo = 100 ; res = ( Double ) ( s64 ) Duration ; res /= 100 ; res *= seekTo ; gf_term_play_from_time ( term , ( u64 ) ( s64 ) res , 0 ) ; } } else { u32 r , h , m , s ; fprintf ( stderr , "<S2SV_blank>-<S2SV_blank>Current<S2SV_blank>Time:<S2SV_blank>" ) ; PrintTime ( ( u64 ) res ) ; fprintf ( stderr , "\\nEnter<S2SV_blank>seek<S2SV_blank>time<S2SV_blank>(Format:<S2SV_blank>s,<S2SV_blank>m:s<S2SV_blank>or<S2SV_blank>h:m:s):\\n" ) ; h = m = s = 0 ; r = scanf ( "%d:%d:%d" , & h , & m , & s ) ; if ( r == 2 ) { s = m ; m = h ; h = 0 ; } else if ( r == 1 ) { s = h ; m = h = 0 ; } if ( r && ( r <= 3 ) ) { u64 time = h * 3600 + m * 60 + s ; gf_term_play_from_time ( term , time * 1000 , 0 ) ; } } } break ; case 't' : { if ( is_connected ) { fprintf ( stderr , "Current<S2SV_blank>Time:<S2SV_blank>" ) ; PrintTime ( gf_term_get_time_in_ms ( term ) ) ; fprintf ( stderr , "<S2SV_blank>-<S2SV_blank>Duration:<S2SV_blank>" ) ; PrintTime ( Duration ) ; fprintf ( stderr , "\\n" ) ; } } break ; case 'w' : if ( is_connected ) PrintWorldInfo ( term ) ; break ; case 'v' : if ( is_connected ) PrintODList ( term , NULL , 0 , 0 , "Root" ) ; break ; case 'i' : if ( is_connected ) { u32 ID ; fprintf ( stderr , "Enter<S2SV_blank>OD<S2SV_blank>ID<S2SV_blank>(0<S2SV_blank>for<S2SV_blank>main<S2SV_blank>OD):<S2SV_blank>" ) ; fflush ( stderr ) ; if ( scanf ( "%ud" , & ID ) == 1 ) { ViewOD ( term , ID , ( u32 ) - 1 , NULL ) ; } else { char str_url [ GF_MAX_PATH ] ; if ( scanf ( "%s" , str_url ) == 1 ) ViewOD ( term , 0 , ( u32 ) - 1 , str_url ) ; } } break ; case 'j' : if ( is_connected ) { u32 num ; do { fprintf ( stderr , "Enter<S2SV_blank>OD<S2SV_blank>number<S2SV_blank>(0<S2SV_blank>for<S2SV_blank>main<S2SV_blank>OD):<S2SV_blank>" ) ; fflush ( stderr ) ; } while ( 1 > scanf ( "%ud" , & num ) ) ; ViewOD ( term , ( u32 ) - 1 , num , NULL ) ; } break ; case 'b' : if ( is_connected ) ViewODs ( term , 1 ) ; break ; case 'm' : if ( is_connected ) ViewODs ( term , 0 ) ; break ; case 'l' : list_modules ( user . modules ) ; break ; case 'n' : if ( is_connected ) set_navigation ( ) ; break ; case 'x' : if ( is_connected ) gf_term_set_option ( term , GF_OPT_NAVIGATION_TYPE , 0 ) ; break ; case 'd' : if ( is_connected ) { GF_ObjectManager * odm = NULL ; char radname [ GF_MAX_PATH ] , * sExt ; GF_Err e ; u32 i , count , odid ; Bool xml_dump , std_out ; radname [ 0 ] = 0 ; do { fprintf ( stderr , "Enter<S2SV_blank>Inline<S2SV_blank>OD<S2SV_blank>ID<S2SV_blank>if<S2SV_blank>any<S2SV_blank>or<S2SV_blank>0<S2SV_blank>:<S2SV_blank>" ) ; fflush ( stderr ) ; } while ( 1 > scanf ( "%ud" , & odid ) ) ; if ( odid ) { GF_ObjectManager * root_odm = gf_term_get_root_object ( term ) ; if ( ! root_odm ) break ; count = gf_term_get_object_count ( term , root_odm ) ; for ( i = 0 ; i < count ; i ++ ) { GF_MediaInfo info ; odm = gf_term_get_object ( term , root_odm , i ) ; if ( gf_term_get_object_info ( term , odm , & info ) == GF_OK ) { if ( info . od -> objectDescriptorID == odid ) break ; } odm = NULL ; } } do { fprintf ( stderr , "Enter<S2SV_blank>file<S2SV_blank>radical<S2SV_blank>name<S2SV_blank>(+\\\'.x\\\'<S2SV_blank>for<S2SV_blank>XML<S2SV_blank>dumping)<S2SV_blank>-<S2SV_blank>\\"std\\"<S2SV_blank>for<S2SV_blank>stderr:<S2SV_blank>" ) ; fflush ( stderr ) ; } while ( 1 > scanf ( "%s" , radname ) ) ; sExt = strrchr ( radname , '.' ) ; xml_dump = 0 ; if ( sExt ) { if ( ! stricmp ( sExt , ".x" ) ) xml_dump = 1 ; sExt [ 0 ] = 0 ; } std_out = strnicmp ( radname , "std" , 3 ) ? 0 : 1 ; e = gf_term_dump_scene ( term , std_out ? NULL : radname , NULL , xml_dump , 0 , odm ) ; fprintf ( stderr , "Dump<S2SV_blank>done<S2SV_blank>(%s)\\n" , gf_error_to_string ( e ) ) ; } break ; case 'c' : PrintGPACConfig ( ) ; break ; case '3' : { Bool use_3d = ! gf_term_get_option ( term , GF_OPT_USE_OPENGL ) ; if ( gf_term_set_option ( term , GF_OPT_USE_OPENGL , use_3d ) == GF_OK ) { fprintf ( stderr , "Using<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>2D<S2SV_blank>drawing\\n" , use_3d ? "OpenGL" : "2D<S2SV_blank>rasterizer" ) ; } } break ; case 'k' : { Bool opt = gf_term_get_option ( term , GF_OPT_STRESS_MODE ) ; opt = ! opt ; fprintf ( stderr , "Turning<S2SV_blank>stress<S2SV_blank>mode<S2SV_blank>%s\\n" , opt ? "on" : "off" ) ; gf_term_set_option ( term , GF_OPT_STRESS_MODE , opt ) ; } break ; case '4' : gf_term_set_option ( term , GF_OPT_ASPECT_RATIO , GF_ASPECT_RATIO_4_3 ) ; break ; case '5' : gf_term_set_option ( term , GF_OPT_ASPECT_RATIO , GF_ASPECT_RATIO_16_9 ) ; break ; case '6' : gf_term_set_option ( term , GF_OPT_ASPECT_RATIO , GF_ASPECT_RATIO_FILL_SCREEN ) ; break ; case '7' : gf_term_set_option ( term , GF_OPT_ASPECT_RATIO , GF_ASPECT_RATIO_KEEP ) ; break ; case 'C' : switch ( gf_term_get_option ( term , GF_OPT_MEDIA_CACHE ) ) { case GF_MEDIA_CACHE_DISABLED : gf_term_set_option ( term , GF_OPT_MEDIA_CACHE , GF_MEDIA_CACHE_ENABLED ) ; break ; case GF_MEDIA_CACHE_ENABLED : gf_term_set_option ( term , GF_OPT_MEDIA_CACHE , GF_MEDIA_CACHE_DISABLED ) ; break ; case GF_MEDIA_CACHE_RUNNING : fprintf ( stderr , "Streaming<S2SV_blank>Cache<S2SV_blank>is<S2SV_blank>running<S2SV_blank>-<S2SV_blank>please<S2SV_blank>stop<S2SV_blank>it<S2SV_blank>first\\n" ) ; continue ; } switch ( gf_term_get_option ( term , GF_OPT_MEDIA_CACHE ) ) { case GF_MEDIA_CACHE_ENABLED : fprintf ( stderr , "Streaming<S2SV_blank>Cache<S2SV_blank>Enabled\\n" ) ; break ; case GF_MEDIA_CACHE_DISABLED : fprintf ( stderr , "Streaming<S2SV_blank>Cache<S2SV_blank>Disabled\\n" ) ; break ; case GF_MEDIA_CACHE_RUNNING : fprintf ( stderr , "Streaming<S2SV_blank>Cache<S2SV_blank>Running\\n" ) ; break ; } break ; case 'S' : case 'A' : if ( gf_term_get_option ( term , GF_OPT_MEDIA_CACHE ) == GF_MEDIA_CACHE_RUNNING ) { gf_term_set_option ( term , GF_OPT_MEDIA_CACHE , ( c == 'S' ) ? GF_MEDIA_CACHE_DISABLED : GF_MEDIA_CACHE_DISCARD ) ; fprintf ( stderr , "Streaming<S2SV_blank>Cache<S2SV_blank>stopped\\n" ) ; } else { fprintf ( stderr , "Streaming<S2SV_blank>Cache<S2SV_blank>not<S2SV_blank>running\\n" ) ; } break ; case 'R' : display_rti = ! display_rti ; ResetCaption ( ) ; break ; case 'F' : if ( display_rti ) display_rti = 0 ; else display_rti = 2 ; ResetCaption ( ) ; break ; case 'u' : { GF_Err e ; char szCom [ 8192 ] ; fprintf ( stderr , "Enter<S2SV_blank>command<S2SV_blank>to<S2SV_blank>send:\\n" ) ; fflush ( stdin ) ; szCom [ 0 ] = 0 ; if ( 1 > scanf ( "%[^\\t\\n]" , szCom ) ) { fprintf ( stderr , "Cannot<S2SV_blank>read<S2SV_blank>command<S2SV_blank>to<S2SV_blank>send,<S2SV_blank>aborting.\\n" ) ; break ; } e = gf_term_scene_update ( term , NULL , szCom ) ; if ( e ) fprintf ( stderr , "Processing<S2SV_blank>command<S2SV_blank>failed:<S2SV_blank>%s\\n" , gf_error_to_string ( e ) ) ; } break ; case 'e' : { GF_Err e ; char jsCode [ 8192 ] ; fprintf ( stderr , "Enter<S2SV_blank>JavaScript<S2SV_blank>code<S2SV_blank>to<S2SV_blank>evaluate:\\n" ) ; fflush ( stdin ) ; jsCode [ 0 ] = 0 ; if ( 1 > scanf ( "%[^\\t\\n]" , jsCode ) ) { fprintf ( stderr , "Cannot<S2SV_blank>read<S2SV_blank>code<S2SV_blank>to<S2SV_blank>evaluate,<S2SV_blank>aborting.\\n" ) ; break ; } e = gf_term_scene_update ( term , "application/ecmascript" , jsCode ) ; if ( e ) fprintf ( stderr , "Processing<S2SV_blank>JS<S2SV_blank>code<S2SV_blank>failed:<S2SV_blank>%s\\n" , gf_error_to_string ( e ) ) ; } break ; case 'L' : { char szLog [ 1024 ] , * cur_logs ; cur_logs = gf_log_get_tools_levels ( ) ; fprintf ( stderr , "Enter<S2SV_blank>new<S2SV_blank>log<S2SV_blank>level<S2SV_blank>(current<S2SV_blank>tools<S2SV_blank>%s):\\n" , cur_logs ) ; gf_free ( cur_logs ) ; if ( scanf ( "%s" , szLog ) < 1 ) { fprintf ( stderr , "Cannot<S2SV_blank>read<S2SV_blank>new<S2SV_blank>log<S2SV_blank>level,<S2SV_blank>aborting.\\n" ) ; break ; } gf_log_modify_tools_levels ( szLog ) ; } break ; case 'g' : { GF_SystemRTInfo rti ; gf_sys_get_rti ( rti_update_time_ms , & rti , 0 ) ; fprintf ( stderr , "GPAC<S2SV_blank>allocated<S2SV_blank>memory<S2SV_blank>" LLD "\\n" , rti . gpac_memory ) ; } break ; case 'M' : { u32 size ; do { fprintf ( stderr , "Enter<S2SV_blank>new<S2SV_blank>video<S2SV_blank>cache<S2SV_blank>memory<S2SV_blank>in<S2SV_blank>kBytes<S2SV_blank>(current<S2SV_blank>%ud):\\n" , gf_term_get_option ( term , GF_OPT_VIDEO_CACHE_SIZE ) ) ; } while ( 1 > scanf ( "%ud" , & size ) ) ; gf_term_set_option ( term , GF_OPT_VIDEO_CACHE_SIZE , size ) ; } break ; case 'H' : { u32 http_bitrate = gf_term_get_option ( term , GF_OPT_HTTP_MAX_RATE ) ; do { fprintf ( stderr , "Enter<S2SV_blank>new<S2SV_blank>http<S2SV_blank>bitrate<S2SV_blank>in<S2SV_blank>bps<S2SV_blank>(0<S2SV_blank>for<S2SV_blank>none)<S2SV_blank>-<S2SV_blank>current<S2SV_blank>limit:<S2SV_blank>%d\\n" , http_bitrate ) ; } while ( 1 > scanf ( "%ud" , & http_bitrate ) ) ; gf_term_set_option ( term , GF_OPT_HTTP_MAX_RATE , http_bitrate ) ; } break ; case 'E' : gf_term_set_option ( term , GF_OPT_RELOAD_CONFIG , 1 ) ; break ; case 'B' : switch_bench ( ! bench_mode ) ; break ; case 'Y' : { char szOpt [ 8192 ] ; fprintf ( stderr , "Enter<S2SV_blank>option<S2SV_blank>to<S2SV_blank>set<S2SV_blank>(Section:Name=Value):\\n" ) ; fflush ( stdin ) ; szOpt [ 0 ] = 0 ; if ( 1 > scanf ( "%[^\\t\\n]" , szOpt ) ) { fprintf ( stderr , "Cannot<S2SV_blank>read<S2SV_blank>option\\n" ) ; break ; } set_cfg_option ( szOpt ) ; } break ; case 'Z' : { char szFileName [ 100 ] ; u32 nb_pass , nb_views , offscreen_view = 0 ; GF_VideoSurface fb ; GF_Err e ; nb_pass = 1 ; nb_views = gf_term_get_option ( term , GF_OPT_NUM_STEREO_VIEWS ) ; if ( nb_views > 1 ) { fprintf ( stderr , "Auto-stereo<S2SV_blank>mode<S2SV_blank>detected<S2SV_blank>-<S2SV_blank>type<S2SV_blank>number<S2SV_blank>of<S2SV_blank>view<S2SV_blank>to<S2SV_blank>dump<S2SV_blank>(0<S2SV_blank>is<S2SV_blank>main<S2SV_blank>output,<S2SV_blank>1<S2SV_blank>to<S2SV_blank>%d<S2SV_blank>offscreen<S2SV_blank>view,<S2SV_blank>%d<S2SV_blank>for<S2SV_blank>all<S2SV_blank>offscreen,<S2SV_blank>%d<S2SV_blank>for<S2SV_blank>all<S2SV_blank>offscreen<S2SV_blank>and<S2SV_blank>main)\\n" , nb_views , nb_views + 1 , nb_views + 2 ) ; if ( scanf ( "%d" , & offscreen_view ) != 1 ) { offscreen_view = 0 ; } if ( offscreen_view == nb_views + 1 ) { offscreen_view = 1 ; nb_pass = nb_views ; } else if ( offscreen_view == nb_views + 2 ) { offscreen_view = 0 ; nb_pass = nb_views + 1 ; } } while ( nb_pass ) { nb_pass -- ; if ( offscreen_view ) { sprintf ( szFileName , "view%d_dump.png" , offscreen_view ) ; e = gf_term_get_offscreen_buffer ( term , & fb , offscreen_view - 1 , 0 ) ; } else { sprintf ( szFileName , "gpac_video_dump_" LLU ".png" , gf_net_get_utc ( ) ) ; e = gf_term_get_screen_buffer ( term , & fb ) ; } offscreen_view ++ ; if ( e ) { fprintf ( stderr , "Error<S2SV_blank>dumping<S2SV_blank>screen<S2SV_blank>buffer<S2SV_blank>%s\\n" , gf_error_to_string ( e ) ) ; nb_pass = 0 ; } else { # ifndef GPAC_DISABLE_AV_PARSERS u32 dst_size = fb . width * fb . height * 4 ; char * dst = ( char * ) gf_malloc ( sizeof ( char ) * dst_size ) ; e = gf_img_png_enc ( fb . video_buffer , fb . width , fb . height , fb . pitch_y , fb . pixel_format , dst , & dst_size ) ; if ( e ) { fprintf ( stderr , "Error<S2SV_blank>encoding<S2SV_blank>PNG<S2SV_blank>%s\\n" , gf_error_to_string ( e ) ) ; nb_pass = 0 ; } else { FILE * png = gf_fopen ( szFileName , "wb" ) ; if ( ! png ) { fprintf ( stderr , "Error<S2SV_blank>writing<S2SV_blank>file<S2SV_blank>%s\\n" , szFileName ) ; nb_pass = 0 ; } else { gf_fwrite ( dst , dst_size , 1 , png ) ; gf_fclose ( png ) ; fprintf ( stderr , "Dump<S2SV_blank>to<S2SV_blank>%s\\n" , szFileName ) ; } } if ( dst ) gf_free ( dst ) ; gf_term_release_screen_buffer ( term , & fb ) ; # endif } } fprintf ( stderr , "Done:<S2SV_blank>%s\\n" , szFileName ) ; } break ; case 'G' : { GF_ObjectManager * root_od , * odm ; u32 index ; char szOpt [ 8192 ] ; fprintf ( stderr , "Enter<S2SV_blank>0-based<S2SV_blank>index<S2SV_blank>of<S2SV_blank>object<S2SV_blank>to<S2SV_blank>select<S2SV_blank>or<S2SV_blank>service<S2SV_blank>ID:\\n" ) ; fflush ( stdin ) ; szOpt [ 0 ] = 0 ; if ( 1 > scanf ( "%[^\\t\\n]" , szOpt ) ) { fprintf ( stderr , "Cannot<S2SV_blank>read<S2SV_blank>OD<S2SV_blank>ID\\n" ) ; break ; } index = atoi ( szOpt ) ; odm = NULL ; root_od = gf_term_get_root_object ( term ) ; if ( root_od ) { if ( gf_term_find_service ( term , root_od , index ) ) { gf_term_select_service ( term , root_od , index ) ; } else { fprintf ( stderr , "Cannot<S2SV_blank>find<S2SV_blank>service<S2SV_blank>%d<S2SV_blank>-<S2SV_blank>trying<S2SV_blank>with<S2SV_blank>object<S2SV_blank>index\\n" , index ) ; odm = gf_term_get_object ( term , root_od , index ) ; if ( odm ) { gf_term_select_object ( term , odm ) ; } else { fprintf ( stderr , "Cannot<S2SV_blank>find<S2SV_blank>object<S2SV_blank>at<S2SV_blank>index<S2SV_blank>%d\\n" , index ) ; } } } } break ; case 'h' : PrintHelp ( ) ; break ; default : break ; } } if ( bench_mode ) { PrintAVInfo ( GF_TRUE ) ; } if ( simulation_time_in_ms ) { gf_log_set_strict_error ( 0 ) ; } i = gf_sys_clock ( ) ; gf_term_disconnect ( term ) ; if ( rti_file ) UpdateRTInfo ( "Disconnected\\n" ) ; fprintf ( stderr , "Deleting<S2SV_blank>terminal...<S2SV_blank>" ) ; if ( playlist ) gf_fclose ( playlist ) ; # if defined ( __DARWIN__ ) || defined ( __APPLE__ ) carbon_uninit ( ) ; # endif gf_term_del ( term ) ; fprintf ( stderr , "done<S2SV_blank>(in<S2SV_blank>%d<S2SV_blank>ms)<S2SV_blank>-<S2SV_blank>ran<S2SV_blank>for<S2SV_blank>%d<S2SV_blank>ms\\n" , gf_sys_clock ( ) - i , gf_sys_clock ( ) ) ; fprintf ( stderr , "GPAC<S2SV_blank>cleanup<S2SV_blank>...\\n" ) ; gf_modules_del ( user . modules ) ; if ( no_cfg_save ) gf_cfg_discard_changes ( cfg_file ) ; gf_cfg_del ( cfg_file ) ; gf_sys_close ( ) ; if ( rti_logs ) gf_fclose ( rti_logs ) ; if ( logfile ) gf_fclose ( logfile ) ; if ( gui_mode ) { hide_shell ( 2 ) ; } # ifdef GPAC_MEMORY_TRACKING if ( mem_track && ( gf_memory_size ( ) || gf_file_handles_count ( ) ) ) { gf_log_set_tool_level ( GF_LOG_MEMORY , GF_LOG_INFO ) ; gf_memory_print ( ) ; return 2 ; } # endif return ret_val ; }
CWE-119 void set_cfg_option ( char * opt_string ) { char * sep , * sep2 , szSec [ 1024 ] , szKey [ 1024 ] , szVal [ 1024 ] ; sep = strchr ( opt_string , ':' ) ; if ( ! sep ) { fprintf ( stderr , "Badly<S2SV_blank>formatted<S2SV_blank>option<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>expected<S2SV_blank>Section:Name=Value\\n" , opt_string ) ; return ; } { const size_t sepIdx = sep - opt_string ; <S2SV_StartBug> strncpy ( szSec , opt_string , sepIdx ) ; <S2SV_EndBug> szSec [ sepIdx ] = 0 ; } sep ++ ; sep2 = strchr ( sep , '=' ) ; if ( ! sep2 ) { fprintf ( stderr , "Badly<S2SV_blank>formatted<S2SV_blank>option<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>expected<S2SV_blank>Section:Name=Value\\n" , opt_string ) ; return ; } { const size_t sepIdx = sep2 - sep ; <S2SV_StartBug> strncpy ( szKey , sep , sepIdx ) ; <S2SV_EndBug> szKey [ sepIdx ] = 0 ; <S2SV_StartBug> strcpy ( szVal , sep2 + 1 ) ; <S2SV_EndBug> } if ( ! stricmp ( szKey , "*" ) ) { if ( stricmp ( szVal , "null" ) ) { fprintf ( stderr , "Badly<S2SV_blank>formatted<S2SV_blank>option<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>expected<S2SV_blank>Section:*=null\\n" , opt_string ) ; return ; } gf_cfg_del_section ( cfg_file , szSec ) ; return ; } if ( ! stricmp ( szVal , "null" ) ) { szVal [ 0 ] = 0 ; } gf_cfg_set_key ( cfg_file , szSec , szKey , szVal [ 0 ] ? szVal : NULL ) ; }
CWE-119 static Bool FFD_CanHandleURL ( GF_InputService * plug , const char * url ) { Bool has_audio , has_video ; s32 i ; AVFormatContext * ctx ; AVOutputFormat * fmt_out ; Bool ret = GF_FALSE ; <S2SV_StartBug> char * ext , szName [ 1000 ] , szExt [ 20 ] ; <S2SV_EndBug> const char * szExtList ; FFDemux * ffd ; if ( ! plug || ! url ) return GF_FALSE ; if ( ! strnicmp ( url , "rtsp://" , 7 ) ) return GF_FALSE ; if ( ! strnicmp ( url , "rtspu://" , 8 ) ) return GF_FALSE ; if ( ! strnicmp ( url , "rtp://" , 6 ) ) return GF_FALSE ; if ( ! strnicmp ( url , "plato://" , 8 ) ) return GF_FALSE ; if ( ! strnicmp ( url , "udp://" , 6 ) ) return GF_FALSE ; if ( ! strnicmp ( url , "tcp://" , 6 ) ) return GF_FALSE ; if ( ! strnicmp ( url , "data:" , 5 ) ) return GF_FALSE ; ffd = ( FFDemux * ) plug -> priv ; <S2SV_StartBug> strcpy ( szName , url ) ; <S2SV_EndBug> ext = strrchr ( szName , '#' ) ; if ( ext ) ext [ 0 ] = 0 ; ext = strrchr ( szName , '?' ) ; if ( ext ) ext [ 0 ] = 0 ; ext = strrchr ( szName , '.' ) ; if ( ext && strlen ( ext ) > 19 ) ext = NULL ; <S2SV_StartBug> if ( ext && strlen ( ext ) > 1 ) { <S2SV_EndBug> strcpy ( szExt , & ext [ 1 ] ) ; strlwr ( szExt ) ; # ifndef FFMPEG_DEMUX_ENABLE_MPEG2TS if ( strstr ( "ts<S2SV_blank>m2t<S2SV_blank>mts<S2SV_blank>dmb<S2SV_blank>trp" , szExt ) ) return GF_FALSE ; # endif if ( ! strcmp ( szExt , "mp4" ) || ! strcmp ( szExt , "mpg4" ) || ! strcmp ( szExt , "m4a" ) || ! strcmp ( szExt , "m21" ) || ! strcmp ( szExt , "m4v" ) || ! strcmp ( szExt , "m4a" ) || ! strcmp ( szExt , "m4s" ) || ! strcmp ( szExt , "3gs" ) || ! strcmp ( szExt , "3gp" ) || ! strcmp ( szExt , "3gpp" ) || ! strcmp ( szExt , "3gp2" ) || ! strcmp ( szExt , "3g2" ) || ! strcmp ( szExt , "mp3" ) || ! strcmp ( szExt , "ac3" ) || ! strcmp ( szExt , "amr" ) || ! strcmp ( szExt , "bt" ) || ! strcmp ( szExt , "wrl" ) || ! strcmp ( szExt , "x3dv" ) || ! strcmp ( szExt , "xmt" ) || ! strcmp ( szExt , "xmta" ) || ! strcmp ( szExt , "x3d" ) || ! strcmp ( szExt , "jpg" ) || ! strcmp ( szExt , "jpeg" ) || ! strcmp ( szExt , "png" ) ) return GF_FALSE ; { u32 i ; for ( i = 0 ; FFD_MIME_TYPES [ i ] ; i += 3 ) { if ( gf_service_check_mime_register ( plug , FFD_MIME_TYPES [ i ] , FFD_MIME_TYPES [ i + 1 ] , FFD_MIME_TYPES [ i + 2 ] , ext ) ) return GF_TRUE ; } } } ffd_parse_options ( ffd , url ) ; ctx = NULL ; if ( open_file ( & ctx , szName , NULL , ffd -> options ? & ffd -> options : NULL ) < 0 ) { AVInputFormat * av_in = NULL ; if ( ext && ! strcmp ( szExt , "cmp" ) ) av_in = av_find_input_format ( "m4v" ) ; if ( open_file ( & ctx , szName , av_in , ffd -> options ? & ffd -> options : NULL ) < 0 ) { return GF_FALSE ; } } if ( ! ctx ) goto exit ; if ( av_find_stream_info ( ctx ) < 0 ) goto exit ; has_video = has_audio = GF_FALSE ; for ( i = 0 ; i < ( s32 ) ctx -> nb_streams ; i ++ ) { AVCodecContext * enc = ctx -> streams [ i ] -> codec ; switch ( enc -> codec_type ) { case AVMEDIA_TYPE_AUDIO : if ( ! has_audio ) has_audio = GF_TRUE ; break ; case AVMEDIA_TYPE_VIDEO : if ( ! has_video ) has_video = GF_TRUE ; break ; default : break ; } } if ( ! has_audio && ! has_video ) goto exit ; ret = GF_TRUE ; # if ( ( LIBAVFORMAT_VERSION_MAJOR == 52 ) && ( LIBAVFORMAT_VERSION_MINOR <= 47 ) ) || ( LIBAVFORMAT_VERSION_MAJOR < 52 ) fmt_out = guess_stream_format ( NULL , url , NULL ) ; # else fmt_out = av_guess_format ( NULL , url , NULL ) ; # endif if ( fmt_out ) gf_service_register_mime ( plug , fmt_out -> mime_type , fmt_out -> extensions , fmt_out -> name ) ; else { ext = strrchr ( szName , '.' ) ; if ( ext ) { strcpy ( szExt , & ext [ 1 ] ) ; strlwr ( szExt ) ; szExtList = gf_modules_get_option ( ( GF_BaseInterface * ) plug , "MimeTypes" , "application/x-ffmpeg" ) ; if ( ! szExtList ) { gf_service_register_mime ( plug , "application/x-ffmpeg" , szExt , "Other<S2SV_blank>Movies<S2SV_blank>(FFMPEG)" ) ; } else if ( ! strstr ( szExtList , szExt ) ) { u32 len ; char * buf ; len = ( u32 ) ( strlen ( szExtList ) + strlen ( szExt ) + 10 ) ; buf = ( char * ) gf_malloc ( sizeof ( char ) * len ) ; sprintf ( buf , "\\"%s<S2SV_blank>" , szExt ) ; strcat ( buf , & szExtList [ 1 ] ) ; gf_modules_set_option ( ( GF_BaseInterface * ) plug , "MimeTypes" , "application/x-ffmpeg" , buf ) ; gf_free ( buf ) ; } } } exit : # if FF_API_CLOSE_INPUT_FILE if ( ctx ) av_close_input_file ( ctx ) ; # else if ( ctx ) avformat_close_input ( & ctx ) ; # endif return ret ; }
CWE-787 char * gf_text_get_utf8_line ( char * szLine , u32 lineSize , FILE * txt_in , s32 unicode_type ) { u32 i , j , len ; char * sOK ; char szLineConv [ 1024 ] ; unsigned short * sptr ; memset ( szLine , 0 , sizeof ( char ) * lineSize ) ; sOK = fgets ( szLine , lineSize , txt_in ) ; if ( ! sOK ) return NULL ; if ( unicode_type <= 1 ) { j = 0 ; len = ( u32 ) strlen ( szLine ) ; for ( i = 0 ; i < len ; i ++ ) { if ( ! unicode_type && ( szLine [ i ] & 0x80 ) ) { if ( ( szLine [ i + 1 ] & 0xc0 ) != 0x80 ) { szLineConv [ j ] = 0xc0 | ( ( szLine [ i ] >> 6 ) & 0x3 ) ; j ++ ; szLine [ i ] &= 0xbf ; } else if ( ( szLine [ i ] & 0xe0 ) == 0xc0 ) { szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; } else if ( ( szLine [ i ] & 0xf0 ) == 0xe0 ) { szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; } else if ( ( szLine [ i ] & 0xf8 ) == 0xf0 ) { szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; } else { i += 1 ; continue ; } } szLineConv [ j ] = szLine [ i ] ; j ++ ; } szLineConv [ j ] = 0 ; strcpy ( szLine , szLineConv ) ; return sOK ; } # ifdef GPAC_BIG_ENDIAN if ( unicode_type == 3 ) { # else if ( unicode_type == 2 ) { # endif i = 0 ; while ( 1 ) { char c ; if ( ! szLine [ i ] && ! szLine [ i + 1 ] ) break ; c = szLine [ i + 1 ] ; szLine [ i + 1 ] = szLine [ i ] ; szLine [ i ] = c ; i += 2 ; } } sptr = ( u16 * ) szLine ; i = ( u32 ) gf_utf8_wcstombs ( szLineConv , 1024 , ( const unsigned short * * ) & sptr ) ; <S2SV_StartBug> szLineConv [ i ] = 0 ; <S2SV_EndBug> strcpy ( szLine , szLineConv ) ; if ( unicode_type == 3 ) fgetc ( txt_in ) ; return sOK ; }
CWE-125 GF_Err urn_Read ( GF_Box * s , GF_BitStream * bs ) { u32 i , to_read ; char * tmpName ; GF_DataEntryURNBox * ptr = ( GF_DataEntryURNBox * ) s ; if ( ! ptr -> size ) return GF_OK ; to_read = ( u32 ) ptr -> size ; tmpName = ( char * ) gf_malloc ( sizeof ( char ) * to_read ) ; if ( ! tmpName ) return GF_OUT_OF_MEM ; gf_bs_read_data ( bs , tmpName , to_read ) ; i = 0 ; <S2SV_StartBug> while ( ( tmpName [ i ] != 0 ) && ( i < to_read ) ) { <S2SV_EndBug> i ++ ; } if ( i == to_read ) { gf_free ( tmpName ) ; return GF_ISOM_INVALID_FILE ; } if ( i == to_read - 1 ) { ptr -> nameURN = tmpName ; ptr -> location = NULL ; return GF_OK ; } ptr -> nameURN = ( char * ) gf_malloc ( sizeof ( char ) * ( i + 1 ) ) ; if ( ! ptr -> nameURN ) { gf_free ( tmpName ) ; return GF_OUT_OF_MEM ; } ptr -> location = ( char * ) gf_malloc ( sizeof ( char ) * ( to_read - i - 1 ) ) ; if ( ! ptr -> location ) { gf_free ( tmpName ) ; gf_free ( ptr -> nameURN ) ; ptr -> nameURN = NULL ; return GF_OUT_OF_MEM ; } memcpy ( ptr -> nameURN , tmpName , i + 1 ) ; memcpy ( ptr -> location , tmpName + i + 1 , ( to_read - i - 1 ) ) ; gf_free ( tmpName ) ; return GF_OK ; }
CWE-400 GF_Err dinf_Read ( GF_Box * s , GF_BitStream * bs ) { GF_Err e = gf_isom_box_array_read ( s , bs , dinf_AddBox ) ; if ( e ) { return e ; } if ( ! ( ( GF_DataInformationBox * ) s ) -> dref ) { <S2SV_StartBug> GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( "[iso<S2SV_blank>file]<S2SV_blank>Missing<S2SV_blank>dref<S2SV_blank>box<S2SV_blank>in<S2SV_blank>dinf\\n" ) ) ; <S2SV_EndBug> <S2SV_StartBug> ( ( GF_DataInformationBox * ) s ) -> dref = ( GF_DataReferenceBox * ) gf_isom_box_new ( GF_ISOM_BOX_TYPE_DREF ) ; <S2SV_EndBug> } return GF_OK ; }
CWE-310 static unsigned int do_decrypt ( const RIJNDAEL_context * ctx , unsigned char * bx , const unsigned char * ax ) { # ifdef USE_AMD64_ASM return _gcry_aes_amd64_decrypt_block ( ctx -> keyschdec , bx , ax , ctx -> rounds , <S2SV_StartBug> & dec_tables ) ; <S2SV_EndBug> # elif defined ( USE_ARM_ASM ) return _gcry_aes_arm_decrypt_block ( ctx -> keyschdec , bx , ax , ctx -> rounds , <S2SV_StartBug> & dec_tables ) ; <S2SV_EndBug> # else return do_decrypt_fn ( ctx , bx , ax ) ; # endif }
CWE-310 static unsigned int do_encrypt ( const RIJNDAEL_context * ctx , unsigned char * bx , const unsigned char * ax ) { # ifdef USE_AMD64_ASM return _gcry_aes_amd64_encrypt_block ( ctx -> keyschenc , bx , ax , ctx -> rounds , <S2SV_StartBug> encT ) ; <S2SV_EndBug> # elif defined ( USE_ARM_ASM ) <S2SV_StartBug> return _gcry_aes_arm_encrypt_block ( ctx -> keyschenc , bx , ax , ctx -> rounds , encT ) ; <S2SV_EndBug> # else return do_encrypt_fn ( ctx , bx , ax ) ; # endif }
CWE-310 static void prefetch_dec ( void ) <S2SV_StartBug> { <S2SV_EndBug> prefetch_table ( ( const void * ) & dec_tables , sizeof ( dec_tables ) ) ; }
CWE-310 static void prefetch_enc ( void ) { <S2SV_StartBug> prefetch_table ( ( const void * ) encT , sizeof ( encT ) ) ; <S2SV_EndBug> }
CWE-310 <S2SV_StartBug> static void prefetch_table ( const volatile byte * tab , size_t len ) <S2SV_EndBug> { size_t i ; <S2SV_StartBug> for ( i = 0 ; i < len ; i += 8 * 32 ) <S2SV_EndBug> { ( void ) tab [ i + 0 * 32 ] ; ( void ) tab [ i + 1 * 32 ] ; ( void ) tab [ i + 2 * 32 ] ; ( void ) tab [ i + 3 * 32 ] ; ( void ) tab [ i + 4 * 32 ] ; ( void ) tab [ i + 5 * 32 ] ; ( void ) tab [ i + 6 * 32 ] ; ( void ) tab [ i + 7 * 32 ] ; } <S2SV_StartBug> ( void ) tab [ len - 1 ] ; <S2SV_EndBug> }
CWE-119 void edge_sparse_csr_reader_double ( const char * i_csr_file_in , unsigned int * * o_row_idx , unsigned int * * o_column_idx , double * * o_values , unsigned int * o_row_count , unsigned int * o_column_count , unsigned int * o_element_count ) { FILE * l_csr_file_handle ; const unsigned int l_line_length = 512 ; char l_line [ 512 + 1 ] ; unsigned int l_header_read = 0 ; unsigned int * l_row_idx_id = NULL ; unsigned int l_i = 0 ; l_csr_file_handle = fopen ( i_csr_file_in , "r" ) ; if ( l_csr_file_handle == NULL ) { fprintf ( stderr , "cannot<S2SV_blank>open<S2SV_blank>CSR<S2SV_blank>file!\\n" ) ; return ; } while ( fgets ( l_line , l_line_length , l_csr_file_handle ) != NULL ) { if ( strlen ( l_line ) == l_line_length ) { fprintf ( stderr , "could<S2SV_blank>not<S2SV_blank>read<S2SV_blank>file<S2SV_blank>length!\\n" ) ; return ; } if ( l_line [ 0 ] == '%' ) { continue ; } else { if ( l_header_read == 0 ) { <S2SV_StartBug> if ( sscanf ( l_line , "%u<S2SV_blank>%u<S2SV_blank>%u" , o_row_count , o_column_count , o_element_count ) == 3 ) { <S2SV_EndBug> * o_column_idx = ( unsigned int * ) malloc ( sizeof ( unsigned int ) * ( * o_element_count ) ) ; * o_row_idx = ( unsigned int * ) malloc ( sizeof ( unsigned int ) * ( * o_row_count + 1 ) ) ; * o_values = ( double * ) malloc ( sizeof ( double ) * ( * o_element_count ) ) ; l_row_idx_id = ( unsigned int * ) malloc ( sizeof ( unsigned int ) * ( * o_row_count ) ) ; if ( ( * o_row_idx == NULL ) || ( * o_column_idx == NULL ) || ( * o_values == NULL ) || ( l_row_idx_id == NULL ) ) { fprintf ( stderr , "could<S2SV_blank>not<S2SV_blank>allocate<S2SV_blank>sp<S2SV_blank>data!\\n" ) ; return ; } memset ( * o_row_idx , 0 , sizeof ( unsigned int ) * ( * o_row_count + 1 ) ) ; memset ( * o_column_idx , 0 , sizeof ( unsigned int ) * ( * o_element_count ) ) ; memset ( * o_values , 0 , sizeof ( double ) * ( * o_element_count ) ) ; memset ( l_row_idx_id , 0 , sizeof ( unsigned int ) * ( * o_row_count ) ) ; for ( l_i = 0 ; l_i < ( * o_row_count + 1 ) ; l_i ++ ) ( * o_row_idx ) [ l_i ] = ( * o_element_count ) ; ( * o_row_idx ) [ 0 ] = 0 ; l_i = 0 ; l_header_read = 1 ; } else { fprintf ( stderr , "could<S2SV_blank>not<S2SV_blank>csr<S2SV_blank>description!\\n" ) ; return ; } } else { unsigned int l_row , l_column ; double l_value ; if ( sscanf ( l_line , "%u<S2SV_blank>%u<S2SV_blank>%lf" , & l_row , & l_column , & l_value ) != 3 ) { fprintf ( stderr , "could<S2SV_blank>not<S2SV_blank>read<S2SV_blank>element!\\n" ) ; return ; } l_row -- ; l_column -- ; ( * o_column_idx ) [ l_i ] = l_column ; ( * o_values ) [ l_i ] = l_value ; l_i ++ ; l_row_idx_id [ l_row ] = 1 ; ( * o_row_idx ) [ l_row + 1 ] = l_i ; } } } fclose ( l_csr_file_handle ) ; if ( l_i != ( * o_element_count ) ) { fprintf ( stderr , "we<S2SV_blank>were<S2SV_blank>not<S2SV_blank>able<S2SV_blank>to<S2SV_blank>read<S2SV_blank>all<S2SV_blank>elements!\\n" ) ; return ; } for ( l_i = 0 ; l_i < ( * o_row_count ) ; l_i ++ ) { if ( l_row_idx_id [ l_i ] == 0 ) { ( * o_row_idx ) [ l_i + 1 ] = ( * o_row_idx ) [ l_i ] ; } } if ( l_row_idx_id != NULL ) { free ( l_row_idx_id ) ; } }
CWE-119 int my_csr_reader ( const char * i_csr_file_in , unsigned int * * o_row_idx , unsigned int * * o_column_idx , REALTYPE * * o_values , unsigned int * o_row_count , unsigned int * o_column_count , unsigned int * o_element_count ) { FILE * l_csr_file_handle ; const unsigned int l_line_length = 512 ; char l_line [ 512 + 1 ] ; unsigned int l_header_read = 0 ; unsigned int * l_row_idx_id = NULL ; unsigned int l_i = 0 ; l_csr_file_handle = fopen ( i_csr_file_in , "r" ) ; if ( l_csr_file_handle == NULL ) { fprintf ( stderr , "cannot<S2SV_blank>open<S2SV_blank>CSR<S2SV_blank>file!\\n" ) ; return - 1 ; } while ( fgets ( l_line , l_line_length , l_csr_file_handle ) != NULL ) { if ( strlen ( l_line ) == l_line_length ) { fprintf ( stderr , "could<S2SV_blank>not<S2SV_blank>read<S2SV_blank>file<S2SV_blank>length!\\n" ) ; return - 1 ; } if ( l_line [ 0 ] == '%' ) { continue ; } else { if ( l_header_read == 0 ) { <S2SV_StartBug> if ( sscanf ( l_line , "%u<S2SV_blank>%u<S2SV_blank>%u" , o_row_count , o_column_count , o_element_count ) == 3 ) { <S2SV_EndBug> * o_column_idx = ( unsigned int * ) malloc ( sizeof ( unsigned int ) * ( * o_element_count ) ) ; * o_row_idx = ( unsigned int * ) malloc ( sizeof ( unsigned int ) * ( * o_row_count + 1 ) ) ; * o_values = ( REALTYPE * ) malloc ( sizeof ( double ) * ( * o_element_count ) ) ; l_row_idx_id = ( unsigned int * ) malloc ( sizeof ( unsigned int ) * ( * o_row_count ) ) ; if ( ( * o_row_idx == NULL ) || ( * o_column_idx == NULL ) || ( * o_values == NULL ) || ( l_row_idx_id == NULL ) ) { fprintf ( stderr , "could<S2SV_blank>not<S2SV_blank>allocate<S2SV_blank>sp<S2SV_blank>data!\\n" ) ; return - 1 ; } memset ( * o_row_idx , 0 , sizeof ( unsigned int ) * ( * o_row_count + 1 ) ) ; memset ( * o_column_idx , 0 , sizeof ( unsigned int ) * ( * o_element_count ) ) ; memset ( * o_values , 0 , sizeof ( double ) * ( * o_element_count ) ) ; memset ( l_row_idx_id , 0 , sizeof ( unsigned int ) * ( * o_row_count ) ) ; for ( l_i = 0 ; l_i < ( * o_row_count + 1 ) ; l_i ++ ) ( * o_row_idx ) [ l_i ] = ( * o_element_count ) ; ( * o_row_idx ) [ 0 ] = 0 ; l_i = 0 ; l_header_read = 1 ; } else { fprintf ( stderr , "could<S2SV_blank>not<S2SV_blank>csr<S2SV_blank>description!\\n" ) ; return - 1 ; } } else { unsigned int l_row , l_column ; REALTYPE l_value ; if ( sscanf ( l_line , "%u<S2SV_blank>%u<S2SV_blank>%lf" , & l_row , & l_column , & l_value ) != 3 ) { fprintf ( stderr , "could<S2SV_blank>not<S2SV_blank>read<S2SV_blank>element!\\n" ) ; return - 1 ; } l_row -- ; l_column -- ; ( * o_column_idx ) [ l_i ] = l_column ; ( * o_values ) [ l_i ] = l_value ; l_i ++ ; l_row_idx_id [ l_row ] = 1 ; ( * o_row_idx ) [ l_row + 1 ] = l_i ; } } } fclose ( l_csr_file_handle ) ; if ( l_i != ( * o_element_count ) ) { fprintf ( stderr , "we<S2SV_blank>were<S2SV_blank>not<S2SV_blank>able<S2SV_blank>to<S2SV_blank>read<S2SV_blank>all<S2SV_blank>elements!\\n" ) ; return - 1 ; } for ( l_i = 0 ; l_i < ( * o_row_count ) ; l_i ++ ) { if ( l_row_idx_id [ l_i ] == 0 ) { ( * o_row_idx ) [ l_i + 1 ] = ( * o_row_idx ) [ l_i ] ; } } if ( l_row_idx_id != NULL ) { free ( l_row_idx_id ) ; } return 0 ; }
CWE-119 LIBXSMM_API_INTERN void libxsmm_sparse_csc_reader ( libxsmm_generated_code * io_generated_code , const char * i_csc_file_in , unsigned int * * o_row_idx , unsigned int * * o_column_idx , double * * o_values , unsigned int * o_row_count , unsigned int * o_column_count , unsigned int * o_element_count ) { FILE * l_csc_file_handle ; const unsigned int l_line_length = 512 ; char l_line [ 512 + 1 ] ; unsigned int l_header_read = 0 ; unsigned int * l_column_idx_id = NULL ; unsigned int l_i = 0 ; l_csc_file_handle = fopen ( i_csc_file_in , "r" ) ; if ( l_csc_file_handle == NULL ) { LIBXSMM_HANDLE_ERROR ( io_generated_code , LIBXSMM_ERR_CSC_INPUT ) ; return ; } while ( fgets ( l_line , l_line_length , l_csc_file_handle ) != NULL ) { if ( strlen ( l_line ) == l_line_length ) { free ( * o_row_idx ) ; free ( * o_column_idx ) ; free ( * o_values ) ; free ( l_column_idx_id ) ; * o_row_idx = 0 ; * o_column_idx = 0 ; * o_values = 0 ; fclose ( l_csc_file_handle ) ; LIBXSMM_HANDLE_ERROR ( io_generated_code , LIBXSMM_ERR_CSC_READ_LEN ) ; return ; } if ( l_line [ 0 ] == '%' ) { continue ; } else { if ( l_header_read == 0 ) { <S2SV_StartBug> if ( sscanf ( l_line , "%u<S2SV_blank>%u<S2SV_blank>%u" , o_row_count , o_column_count , o_element_count ) == 3 ) { <S2SV_EndBug> * o_row_idx = ( unsigned int * ) malloc ( sizeof ( unsigned int ) * ( * o_element_count ) ) ; * o_column_idx = ( unsigned int * ) malloc ( sizeof ( unsigned int ) * ( ( size_t ) ( * o_column_count ) + 1 ) ) ; * o_values = ( double * ) malloc ( sizeof ( double ) * ( * o_element_count ) ) ; l_column_idx_id = ( unsigned int * ) malloc ( sizeof ( unsigned int ) * ( * o_column_count ) ) ; if ( ( * o_row_idx == NULL ) || ( * o_column_idx == NULL ) || ( * o_values == NULL ) || ( l_column_idx_id == NULL ) ) { free ( * o_row_idx ) ; free ( * o_column_idx ) ; free ( * o_values ) ; free ( l_column_idx_id ) ; * o_row_idx = 0 ; * o_column_idx = 0 ; * o_values = 0 ; fclose ( l_csc_file_handle ) ; LIBXSMM_HANDLE_ERROR ( io_generated_code , LIBXSMM_ERR_CSC_ALLOC_DATA ) ; return ; } memset ( * o_row_idx , 0 , sizeof ( unsigned int ) * ( * o_element_count ) ) ; memset ( * o_column_idx , 0 , sizeof ( unsigned int ) * ( ( size_t ) ( * o_column_count ) + 1 ) ) ; memset ( * o_values , 0 , sizeof ( double ) * ( * o_element_count ) ) ; memset ( l_column_idx_id , 0 , sizeof ( unsigned int ) * ( * o_column_count ) ) ; for ( l_i = 0 ; l_i <= * o_column_count ; ++ l_i ) { ( * o_column_idx ) [ l_i ] = * o_element_count ; } ( * o_column_idx ) [ 0 ] = 0 ; l_i = 0 ; l_header_read = 1 ; } else { LIBXSMM_HANDLE_ERROR ( io_generated_code , LIBXSMM_ERR_CSC_READ_DESC ) ; fclose ( l_csc_file_handle ) ; return ; } } else { unsigned int l_row = 0 , l_column = 0 ; double l_value = 0 ; if ( sscanf ( l_line , "%u<S2SV_blank>%u<S2SV_blank>%lf" , & l_row , & l_column , & l_value ) != 3 ) { free ( * o_row_idx ) ; free ( * o_column_idx ) ; free ( * o_values ) ; free ( l_column_idx_id ) ; * o_row_idx = 0 ; * o_column_idx = 0 ; * o_values = 0 ; fclose ( l_csc_file_handle ) ; LIBXSMM_HANDLE_ERROR ( io_generated_code , LIBXSMM_ERR_CSC_READ_ELEMS ) ; return ; } <S2SV_StartBug> l_row -- ; <S2SV_EndBug> l_column -- ; ( * o_row_idx ) [ l_i ] = l_row ; ( * o_values ) [ l_i ] = l_value ; l_i ++ ; l_column_idx_id [ l_column ] = 1 ; ( * o_column_idx ) [ l_column + 1 ] = l_i ; } } } fclose ( l_csc_file_handle ) ; if ( l_i != ( * o_element_count ) ) { free ( * o_row_idx ) ; free ( * o_column_idx ) ; free ( * o_values ) ; free ( l_column_idx_id ) ; * o_row_idx = 0 ; * o_column_idx = 0 ; * o_values = 0 ; LIBXSMM_HANDLE_ERROR ( io_generated_code , LIBXSMM_ERR_CSC_LEN ) ; return ; } if ( l_column_idx_id != NULL ) { for ( l_i = 0 ; l_i < ( * o_column_count ) ; l_i ++ ) { if ( l_column_idx_id [ l_i ] == 0 ) { ( * o_column_idx ) [ l_i + 1 ] = ( * o_column_idx ) [ l_i ] ; } } free ( l_column_idx_id ) ; } }
CWE-119 LIBXSMM_API_INTERN void libxsmm_sparse_csr_reader ( libxsmm_generated_code * io_generated_code , const char * i_csr_file_in , unsigned int * * o_row_idx , unsigned int * * o_column_idx , double * * o_values , unsigned int * o_row_count , unsigned int * o_column_count , unsigned int * o_element_count ) { FILE * l_csr_file_handle ; const unsigned int l_line_length = 512 ; char l_line [ 512 + 1 ] ; unsigned int l_header_read = 0 ; unsigned int * l_row_idx_id = NULL ; unsigned int l_i = 0 ; l_csr_file_handle = fopen ( i_csr_file_in , "r" ) ; if ( l_csr_file_handle == NULL ) { LIBXSMM_HANDLE_ERROR ( io_generated_code , LIBXSMM_ERR_CSR_INPUT ) ; return ; } while ( fgets ( l_line , l_line_length , l_csr_file_handle ) != NULL ) { if ( strlen ( l_line ) == l_line_length ) { free ( * o_row_idx ) ; free ( * o_column_idx ) ; free ( * o_values ) ; free ( l_row_idx_id ) ; * o_row_idx = 0 ; * o_column_idx = 0 ; * o_values = 0 ; fclose ( l_csr_file_handle ) ; LIBXSMM_HANDLE_ERROR ( io_generated_code , LIBXSMM_ERR_CSR_READ_LEN ) ; return ; } if ( l_line [ 0 ] == '%' ) { continue ; } else { if ( l_header_read == 0 ) { <S2SV_StartBug> if ( sscanf ( l_line , "%u<S2SV_blank>%u<S2SV_blank>%u" , o_row_count , o_column_count , o_element_count ) == 3 ) { <S2SV_EndBug> * o_column_idx = ( unsigned int * ) malloc ( sizeof ( unsigned int ) * ( * o_element_count ) ) ; * o_row_idx = ( unsigned int * ) malloc ( sizeof ( unsigned int ) * ( ( size_t ) ( * o_row_count ) + 1 ) ) ; * o_values = ( double * ) malloc ( sizeof ( double ) * ( * o_element_count ) ) ; l_row_idx_id = ( unsigned int * ) malloc ( sizeof ( unsigned int ) * ( * o_row_count ) ) ; if ( ( * o_row_idx == NULL ) || ( * o_column_idx == NULL ) || ( * o_values == NULL ) || ( l_row_idx_id == NULL ) ) { free ( * o_row_idx ) ; free ( * o_column_idx ) ; free ( * o_values ) ; free ( l_row_idx_id ) ; * o_row_idx = 0 ; * o_column_idx = 0 ; * o_values = 0 ; fclose ( l_csr_file_handle ) ; LIBXSMM_HANDLE_ERROR ( io_generated_code , LIBXSMM_ERR_CSC_ALLOC_DATA ) ; return ; } memset ( * o_row_idx , 0 , sizeof ( unsigned int ) * ( ( size_t ) ( * o_row_count ) + 1 ) ) ; memset ( * o_column_idx , 0 , sizeof ( unsigned int ) * ( * o_element_count ) ) ; memset ( * o_values , 0 , sizeof ( double ) * ( * o_element_count ) ) ; memset ( l_row_idx_id , 0 , sizeof ( unsigned int ) * ( * o_row_count ) ) ; for ( l_i = 0 ; l_i <= * o_row_count ; ++ l_i ) ( * o_row_idx ) [ l_i ] = ( * o_element_count ) ; ( * o_row_idx ) [ 0 ] = 0 ; l_i = 0 ; l_header_read = 1 ; } else { LIBXSMM_HANDLE_ERROR ( io_generated_code , LIBXSMM_ERR_CSR_READ_DESC ) ; fclose ( l_csr_file_handle ) ; return ; } } else { unsigned int l_row = 0 , l_column = 0 ; double l_value = 0 ; if ( sscanf ( l_line , "%u<S2SV_blank>%u<S2SV_blank>%lf" , & l_row , & l_column , & l_value ) != 3 ) { free ( * o_row_idx ) ; free ( * o_column_idx ) ; free ( * o_values ) ; free ( l_row_idx_id ) ; * o_row_idx = 0 ; * o_column_idx = 0 ; * o_values = 0 ; fclose ( l_csr_file_handle ) ; LIBXSMM_HANDLE_ERROR ( io_generated_code , LIBXSMM_ERR_CSR_READ_ELEMS ) ; return ; } <S2SV_StartBug> l_row -- ; <S2SV_EndBug> l_column -- ; ( * o_column_idx ) [ l_i ] = l_column ; ( * o_values ) [ l_i ] = l_value ; l_i ++ ; l_row_idx_id [ l_row ] = 1 ; ( * o_row_idx ) [ l_row + 1 ] = l_i ; } } } fclose ( l_csr_file_handle ) ; if ( l_i != ( * o_element_count ) ) { free ( * o_row_idx ) ; free ( * o_column_idx ) ; free ( * o_values ) ; free ( l_row_idx_id ) ; * o_row_idx = 0 ; * o_column_idx = 0 ; * o_values = 0 ; LIBXSMM_HANDLE_ERROR ( io_generated_code , LIBXSMM_ERR_CSR_LEN ) ; return ; } if ( l_row_idx_id != NULL ) { for ( l_i = 0 ; l_i < ( * o_row_count ) ; l_i ++ ) { if ( l_row_idx_id [ l_i ] == 0 ) { ( * o_row_idx ) [ l_i + 1 ] = ( * o_row_idx ) [ l_i ] ; } } free ( l_row_idx_id ) ; } }
CWE-20 int treeRead ( struct READER * reader , struct DATAOBJECT * data ) { int i , j , err , olen , elements , size , x , y , z , b , e , dy , dz , sx , sy , sz , dzy , szy ; char * input , * output ; uint8_t node_type , node_level ; uint16_t entries_used ; uint32_t size_of_chunk ; uint32_t filter_mask ; uint64_t address_of_left_sibling , address_of_right_sibling , start [ 4 ] , child_pointer , key , store ; char buf [ 4 ] ; UNUSED ( node_level ) ; UNUSED ( address_of_right_sibling ) ; UNUSED ( address_of_left_sibling ) ; UNUSED ( key ) ; if ( data -> ds . dimensionality > 3 ) { log ( "TREE<S2SV_blank>dimensions<S2SV_blank>><S2SV_blank>3" ) ; return MYSOFA_INVALID_FORMAT ; } if ( fread ( buf , 1 , 4 , reader -> fhd ) != 4 || strncmp ( buf , "TREE" , 4 ) ) { log ( "cannot<S2SV_blank>read<S2SV_blank>signature<S2SV_blank>of<S2SV_blank>TREE\\n" ) ; return MYSOFA_INVALID_FORMAT ; } log ( "%08lX<S2SV_blank>%.4s\\n" , ( uint64_t ) ftell ( reader -> fhd ) - 4 , buf ) ; node_type = ( uint8_t ) fgetc ( reader -> fhd ) ; node_level = ( uint8_t ) fgetc ( reader -> fhd ) ; entries_used = ( uint16_t ) readValue ( reader , 2 ) ; if ( entries_used > 0x1000 ) return MYSOFA_UNSUPPORTED_FORMAT ; address_of_left_sibling = readValue ( reader , reader -> superblock . size_of_offsets ) ; address_of_right_sibling = readValue ( reader , reader -> superblock . size_of_offsets ) ; elements = 1 ; for ( j = 0 ; j < data -> ds . dimensionality ; j ++ ) elements *= data -> datalayout_chunk [ j ] ; dy = data -> datalayout_chunk [ 1 ] ; dz = data -> datalayout_chunk [ 2 ] ; sx = data -> ds . dimension_size [ 0 ] ; sy = data -> ds . dimension_size [ 1 ] ; sz = data -> ds . dimension_size [ 2 ] ; dzy = dz * dy ; szy = sz * sy ; size = data -> datalayout_chunk [ data -> ds . dimensionality ] ; log ( "elements<S2SV_blank>%d<S2SV_blank>size<S2SV_blank>%d\\n" , elements , size ) ; if ( ! ( output = malloc ( elements * size ) ) ) { return MYSOFA_NO_MEMORY ; } for ( e = 0 ; e < entries_used * 2 ; e ++ ) { if ( node_type == 0 ) { key = readValue ( reader , reader -> superblock . size_of_lengths ) ; } else { size_of_chunk = ( uint32_t ) readValue ( reader , 4 ) ; filter_mask = ( uint32_t ) readValue ( reader , 4 ) ; if ( filter_mask ) { log ( "TREE<S2SV_blank>all<S2SV_blank>filters<S2SV_blank>must<S2SV_blank>be<S2SV_blank>enabled\\n" ) ; free ( output ) ; return MYSOFA_INVALID_FORMAT ; } for ( j = 0 ; j < data -> ds . dimensionality ; j ++ ) { start [ j ] = readValue ( reader , 8 ) ; log ( "start<S2SV_blank>%d<S2SV_blank>%lu\\n" , j , start [ j ] ) ; } if ( readValue ( reader , 8 ) ) { break ; } child_pointer = readValue ( reader , reader -> superblock . size_of_offsets ) ; log ( "<S2SV_blank>data<S2SV_blank>at<S2SV_blank>%lX<S2SV_blank>len<S2SV_blank>%u\\n" , child_pointer , size_of_chunk ) ; store = ftell ( reader -> fhd ) ; if ( fseek ( reader -> fhd , child_pointer , SEEK_SET ) < 0 ) { free ( output ) ; return errno ; } if ( ! ( input = malloc ( size_of_chunk ) ) ) { free ( output ) ; return MYSOFA_NO_MEMORY ; } if ( fread ( input , 1 , size_of_chunk , reader -> fhd ) != size_of_chunk ) { free ( output ) ; free ( input ) ; return MYSOFA_INVALID_FORMAT ; } olen = elements * size ; err = gunzip ( size_of_chunk , input , & olen , output ) ; free ( input ) ; log ( "<S2SV_blank><S2SV_blank><S2SV_blank>gunzip<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%d\\n" , err , olen , elements * size ) ; if ( err || olen != elements * size ) { free ( output ) ; return MYSOFA_INVALID_FORMAT ; } switch ( data -> ds . dimensionality ) { case 1 : for ( i = 0 ; i < olen ; i ++ ) { b = i / elements ; x = i % elements + start [ 0 ] ; <S2SV_StartBug> if ( x < sx ) { <S2SV_EndBug> <S2SV_StartBug> j = x * size + b ; <S2SV_EndBug> ( ( char * ) data -> data ) [ j ] = output [ i ] ; } } break ; case 2 : for ( i = 0 ; i < olen ; i ++ ) { b = i / elements ; x = i % elements ; y = x % dy + start [ 1 ] ; x = x / dy + start [ 0 ] ; <S2SV_StartBug> if ( y < sy && x < sx ) { <S2SV_EndBug> <S2SV_StartBug> j = ( ( x * sy + y ) * size ) + b ; <S2SV_EndBug> ( ( char * ) data -> data ) [ j ] = output [ i ] ; } } break ; case 3 : for ( i = 0 ; i < olen ; i ++ ) { b = i / elements ; x = i % elements ; z = x % dz + start [ 2 ] ; y = ( x / dz ) % dy + start [ 1 ] ; x = ( x / dzy ) + start [ 0 ] ; <S2SV_StartBug> if ( z < sz && y < sy && x < sx ) { <S2SV_EndBug> j = ( x * szy + y * sz + z ) * size + b ; <S2SV_StartBug> ( ( char * ) data -> data ) [ j ] = output [ i ] ; <S2SV_EndBug> } } break ; default : log ( "invalid<S2SV_blank>dim\\n" ) ; return MYSOFA_INTERNAL_ERROR ; } if ( fseek ( reader -> fhd , store , SEEK_SET ) < 0 ) { free ( output ) ; return errno ; } } } free ( output ) ; if ( fseek ( reader -> fhd , 4 , SEEK_CUR ) < 0 ) return errno ; return MYSOFA_OK ; }
CWE-416 static void destroy_server_connect ( SERVER_CONNECT_REC * conn ) { IRC_SERVER_CONNECT_REC * ircconn ; ircconn = IRC_SERVER_CONNECT ( conn ) ; if ( ircconn == NULL ) return ; g_free_not_null ( ircconn -> usermode ) ; g_free_not_null ( ircconn -> alternate_nick ) ; <S2SV_StartBug> } <S2SV_EndBug>
CWE-416 static void sig_server_connect_copy ( SERVER_CONNECT_REC * * dest , IRC_SERVER_CONNECT_REC * src ) { IRC_SERVER_CONNECT_REC * rec ; g_return_if_fail ( dest != NULL ) ; if ( ! IS_IRC_SERVER_CONNECT ( src ) ) return ; rec = g_new0 ( IRC_SERVER_CONNECT_REC , 1 ) ; rec -> chat_type = IRC_PROTOCOL ; rec -> max_cmds_at_once = src -> max_cmds_at_once ; rec -> cmd_queue_speed = src -> cmd_queue_speed ; rec -> max_query_chans = src -> max_query_chans ; rec -> max_kicks = src -> max_kicks ; rec -> max_modes = src -> max_modes ; rec -> max_msgs = src -> max_msgs ; rec -> max_whois = src -> max_whois ; rec -> usermode = g_strdup ( src -> usermode ) ; rec -> alternate_nick = g_strdup ( src -> alternate_nick ) ; rec -> sasl_mechanism = src -> sasl_mechanism ; <S2SV_StartBug> rec -> sasl_username = src -> sasl_username ; <S2SV_EndBug> <S2SV_StartBug> rec -> sasl_password = src -> sasl_password ; <S2SV_EndBug> * dest = ( SERVER_CONNECT_REC * ) rec ; }
CWE-416 static void sig_server_setup_fill_chatnet ( IRC_SERVER_CONNECT_REC * conn , IRC_CHATNET_REC * ircnet ) { if ( ! IS_IRC_SERVER_CONNECT ( conn ) ) return ; g_return_if_fail ( IS_IRCNET ( ircnet ) ) ; if ( ircnet -> alternate_nick != NULL ) { g_free_and_null ( conn -> alternate_nick ) ; conn -> alternate_nick = g_strdup ( ircnet -> alternate_nick ) ; } if ( ircnet -> usermode != NULL ) { g_free_and_null ( conn -> usermode ) ; conn -> usermode = g_strdup ( ircnet -> usermode ) ; } if ( ircnet -> max_kicks > 0 ) conn -> max_kicks = ircnet -> max_kicks ; if ( ircnet -> max_msgs > 0 ) conn -> max_msgs = ircnet -> max_msgs ; if ( ircnet -> max_modes > 0 ) conn -> max_modes = ircnet -> max_modes ; if ( ircnet -> max_whois > 0 ) conn -> max_whois = ircnet -> max_whois ; if ( ircnet -> max_cmds_at_once > 0 ) conn -> max_cmds_at_once = ircnet -> max_cmds_at_once ; if ( ircnet -> cmd_queue_speed > 0 ) conn -> cmd_queue_speed = ircnet -> cmd_queue_speed ; if ( ircnet -> max_query_chans > 0 ) conn -> max_query_chans = ircnet -> max_query_chans ; conn -> sasl_mechanism = SASL_MECHANISM_NONE ; conn -> sasl_username = NULL ; conn -> sasl_password = NULL ; if ( ircnet -> sasl_mechanism != NULL ) { if ( ! g_ascii_strcasecmp ( ircnet -> sasl_mechanism , "plain" ) ) { conn -> sasl_mechanism = SASL_MECHANISM_PLAIN ; if ( ircnet -> sasl_username != NULL && * ircnet -> sasl_username && ircnet -> sasl_password != NULL && * ircnet -> sasl_password ) { <S2SV_StartBug> conn -> sasl_username = ircnet -> sasl_username ; <S2SV_EndBug> conn -> sasl_password = ircnet -> sasl_password ; } else g_warning ( "The<S2SV_blank>fields<S2SV_blank>sasl_username<S2SV_blank>and<S2SV_blank>sasl_password<S2SV_blank>are<S2SV_blank>either<S2SV_blank>missing<S2SV_blank>or<S2SV_blank>empty" ) ; } else if ( ! g_ascii_strcasecmp ( ircnet -> sasl_mechanism , "external" ) ) { conn -> sasl_mechanism = SASL_MECHANISM_EXTERNAL ; } else g_warning ( "Unsupported<S2SV_blank>SASL<S2SV_blank>mechanism<S2SV_blank>\\"%s\\"<S2SV_blank>selected" , ircnet -> sasl_mechanism ) ; } }
CWE-362 static void * vips_foreign_load_start ( VipsImage * out , void * a , void * b ) { VipsForeignLoad * load = VIPS_FOREIGN_LOAD ( b ) ; <S2SV_StartBug> VipsForeignLoadClass * class = VIPS_FOREIGN_LOAD_GET_CLASS ( load ) ; <S2SV_EndBug> if ( ! load -> real ) { if ( ! ( load -> real = vips_foreign_load_temp ( load ) ) ) return ( NULL ) ; # ifdef DEBUG printf ( "vips_foreign_load_start:<S2SV_blank>triggering<S2SV_blank>->load()\\n" ) ; # endif load -> real -> progress_signal = load -> out ; g_object_set_qdata ( G_OBJECT ( load -> real ) , vips__foreign_load_operation , load ) ; if ( class -> load ( load ) || <S2SV_StartBug> vips_image_pio_input ( load -> real ) ) <S2SV_EndBug> return ( NULL ) ; if ( ! vips_foreign_load_iscompat ( load -> real , out ) ) <S2SV_StartBug> return ( NULL ) ; <S2SV_EndBug> vips_image_pipelinev ( load -> out , load -> out -> dhint , load -> real , NULL ) ; } return ( vips_region_new ( load -> real ) ) ; }
CWE-476 static int fetch_token ( OnigToken * tok , UChar * * src , UChar * end , ScanEnv * env ) { int r , num ; OnigCodePoint c ; OnigEncoding enc = env -> enc ; const OnigSyntaxType * syn = env -> syntax ; UChar * prev ; UChar * p = * src ; PFETCH_READY ; start : if ( PEND ) { tok -> type = TK_EOT ; return tok -> type ; } tok -> type = TK_STRING ; tok -> base = 0 ; tok -> backp = p ; PFETCH ( c ) ; if ( IS_MC_ESC_CODE ( c , syn ) ) { if ( PEND ) return ONIGERR_END_PATTERN_AT_ESCAPE ; tok -> backp = p ; PFETCH ( c ) ; tok -> u . c = c ; tok -> escaped = 1 ; switch ( c ) { case '*' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_ASTERISK_ZERO_INF ) ) break ; tok -> type = TK_OP_REPEAT ; tok -> u . repeat . lower = 0 ; tok -> u . repeat . upper = REPEAT_INFINITE ; goto greedy_check ; break ; case '+' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_PLUS_ONE_INF ) ) break ; tok -> type = TK_OP_REPEAT ; tok -> u . repeat . lower = 1 ; tok -> u . repeat . upper = REPEAT_INFINITE ; goto greedy_check ; break ; case '?' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_QMARK_ZERO_ONE ) ) break ; tok -> type = TK_OP_REPEAT ; tok -> u . repeat . lower = 0 ; tok -> u . repeat . upper = 1 ; greedy_check : if ( ! PEND && PPEEK_IS ( '?' ) && IS_SYNTAX_OP ( syn , ONIG_SYN_OP_QMARK_NON_GREEDY ) ) { PFETCH ( c ) ; tok -> u . repeat . greedy = 0 ; tok -> u . repeat . possessive = 0 ; } else { possessive_check : if ( ! PEND && PPEEK_IS ( '+' ) && ( ( IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_PLUS_POSSESSIVE_REPEAT ) && tok -> type != TK_INTERVAL ) || ( IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_PLUS_POSSESSIVE_INTERVAL ) && tok -> type == TK_INTERVAL ) ) ) { PFETCH ( c ) ; tok -> u . repeat . greedy = 1 ; tok -> u . repeat . possessive = 1 ; } else { tok -> u . repeat . greedy = 1 ; tok -> u . repeat . possessive = 0 ; } } break ; case '{' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_BRACE_INTERVAL ) ) break ; r = fetch_range_quantifier ( & p , end , tok , env ) ; if ( r < 0 ) return r ; if ( r == 0 ) goto greedy_check ; else if ( r == 2 ) { if ( IS_SYNTAX_BV ( syn , ONIG_SYN_FIXED_INTERVAL_IS_GREEDY_ONLY ) ) goto possessive_check ; goto greedy_check ; } break ; case '|' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_VBAR_ALT ) ) break ; tok -> type = TK_ALT ; break ; case '(' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_LPAREN_SUBEXP ) ) break ; tok -> type = TK_SUBEXP_OPEN ; break ; case ')' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_LPAREN_SUBEXP ) ) break ; tok -> type = TK_SUBEXP_CLOSE ; break ; case 'w' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_W_WORD ) ) break ; tok -> type = TK_CHAR_TYPE ; tok -> u . prop . ctype = ONIGENC_CTYPE_WORD ; tok -> u . prop . not = 0 ; break ; case 'W' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_W_WORD ) ) break ; tok -> type = TK_CHAR_TYPE ; tok -> u . prop . ctype = ONIGENC_CTYPE_WORD ; tok -> u . prop . not = 1 ; break ; case 'b' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_B_WORD_BOUND ) ) break ; tok -> type = TK_ANCHOR ; tok -> u . anchor . subtype = ANCHOR_WORD_BOUND ; tok -> u . anchor . ascii_range = IS_ASCII_RANGE ( env -> option ) && ! IS_WORD_BOUND_ALL_RANGE ( env -> option ) ; break ; case 'B' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_B_WORD_BOUND ) ) break ; tok -> type = TK_ANCHOR ; tok -> u . anchor . subtype = ANCHOR_NOT_WORD_BOUND ; tok -> u . anchor . ascii_range = IS_ASCII_RANGE ( env -> option ) && ! IS_WORD_BOUND_ALL_RANGE ( env -> option ) ; break ; # ifdef USE_WORD_BEGIN_END case '<' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_LTGT_WORD_BEGIN_END ) ) break ; tok -> type = TK_ANCHOR ; tok -> u . anchor . subtype = ANCHOR_WORD_BEGIN ; tok -> u . anchor . ascii_range = IS_ASCII_RANGE ( env -> option ) ; break ; case '>' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_LTGT_WORD_BEGIN_END ) ) break ; tok -> type = TK_ANCHOR ; tok -> u . anchor . subtype = ANCHOR_WORD_END ; tok -> u . anchor . ascii_range = IS_ASCII_RANGE ( env -> option ) ; break ; # endif case 's' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_S_WHITE_SPACE ) ) break ; tok -> type = TK_CHAR_TYPE ; tok -> u . prop . ctype = ONIGENC_CTYPE_SPACE ; tok -> u . prop . not = 0 ; break ; case 'S' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_S_WHITE_SPACE ) ) break ; tok -> type = TK_CHAR_TYPE ; tok -> u . prop . ctype = ONIGENC_CTYPE_SPACE ; tok -> u . prop . not = 1 ; break ; case 'd' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_D_DIGIT ) ) break ; tok -> type = TK_CHAR_TYPE ; tok -> u . prop . ctype = ONIGENC_CTYPE_DIGIT ; tok -> u . prop . not = 0 ; break ; case 'D' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_D_DIGIT ) ) break ; tok -> type = TK_CHAR_TYPE ; tok -> u . prop . ctype = ONIGENC_CTYPE_DIGIT ; tok -> u . prop . not = 1 ; break ; case 'h' : if ( ! IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_ESC_H_XDIGIT ) ) break ; tok -> type = TK_CHAR_TYPE ; tok -> u . prop . ctype = ONIGENC_CTYPE_XDIGIT ; tok -> u . prop . not = 0 ; break ; case 'H' : if ( ! IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_ESC_H_XDIGIT ) ) break ; tok -> type = TK_CHAR_TYPE ; tok -> u . prop . ctype = ONIGENC_CTYPE_XDIGIT ; tok -> u . prop . not = 1 ; break ; case 'A' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_AZ_BUF_ANCHOR ) ) break ; begin_buf : tok -> type = TK_ANCHOR ; tok -> u . anchor . subtype = ANCHOR_BEGIN_BUF ; break ; case 'Z' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_AZ_BUF_ANCHOR ) ) break ; tok -> type = TK_ANCHOR ; tok -> u . anchor . subtype = ANCHOR_SEMI_END_BUF ; break ; case 'z' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_AZ_BUF_ANCHOR ) ) break ; end_buf : tok -> type = TK_ANCHOR ; tok -> u . anchor . subtype = ANCHOR_END_BUF ; break ; case 'G' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_CAPITAL_G_BEGIN_ANCHOR ) ) break ; tok -> type = TK_ANCHOR ; tok -> u . anchor . subtype = ANCHOR_BEGIN_POSITION ; break ; case '`' : if ( ! IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_ESC_GNU_BUF_ANCHOR ) ) break ; goto begin_buf ; break ; case '\\'' : if ( ! IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_ESC_GNU_BUF_ANCHOR ) ) break ; goto end_buf ; break ; case 'x' : if ( PEND ) break ; prev = p ; if ( PPEEK_IS ( '{' ) && IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_X_BRACE_HEX8 ) ) { PINC ; num = scan_unsigned_hexadecimal_number ( & p , end , 0 , 8 , enc ) ; if ( num < 0 ) return ONIGERR_TOO_BIG_WIDE_CHAR_VALUE ; if ( ! PEND ) { if ( ONIGENC_IS_CODE_XDIGIT ( enc , PPEEK ) ) return ONIGERR_TOO_LONG_WIDE_CHAR_VALUE ; } if ( ( p > prev + enclen ( enc , prev , end ) ) && ! PEND && PPEEK_IS ( '}' ) ) { PINC ; tok -> type = TK_CODE_POINT ; tok -> u . code = ( OnigCodePoint ) num ; } else { p = prev ; } } else if ( IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_X_HEX2 ) ) { num = scan_unsigned_hexadecimal_number ( & p , end , 0 , 2 , enc ) ; if ( num < 0 ) return ONIGERR_TOO_BIG_NUMBER ; if ( p == prev ) { num = 0 ; } tok -> type = TK_RAW_BYTE ; tok -> base = 16 ; tok -> u . c = num ; } break ; case 'u' : if ( PEND ) break ; prev = p ; if ( IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_ESC_U_HEX4 ) ) { num = scan_unsigned_hexadecimal_number ( & p , end , 4 , 4 , enc ) ; if ( num < - 1 ) return ONIGERR_TOO_SHORT_DIGITS ; else if ( num < 0 ) return ONIGERR_TOO_BIG_NUMBER ; if ( p == prev ) { num = 0 ; } tok -> type = TK_CODE_POINT ; tok -> base = 16 ; tok -> u . code = ( OnigCodePoint ) num ; } break ; case 'o' : if ( PEND ) break ; prev = p ; if ( PPEEK_IS ( '{' ) && IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_O_BRACE_OCTAL ) ) { PINC ; num = scan_unsigned_octal_number ( & p , end , 11 , enc ) ; if ( num < 0 ) return ONIGERR_TOO_BIG_WIDE_CHAR_VALUE ; if ( ! PEND ) { OnigCodePoint c = PPEEK ; if ( ONIGENC_IS_CODE_DIGIT ( enc , c ) && c < '8' ) return ONIGERR_TOO_LONG_WIDE_CHAR_VALUE ; } if ( ( p > prev + enclen ( enc , prev , end ) ) && ! PEND && PPEEK_IS ( '}' ) ) { PINC ; tok -> type = TK_CODE_POINT ; tok -> u . code = ( OnigCodePoint ) num ; } else { p = prev ; } } break ; case '1' : case '2' : case '3' : case '4' : case '5' : case '6' : case '7' : case '8' : case '9' : PUNFETCH ; prev = p ; num = onig_scan_unsigned_number ( & p , end , enc ) ; if ( num < 0 || num > ONIG_MAX_BACKREF_NUM ) { goto skip_backref ; } if ( IS_SYNTAX_OP ( syn , ONIG_SYN_OP_DECIMAL_BACKREF ) && ( num <= env -> num_mem || num <= 9 ) ) { if ( IS_SYNTAX_BV ( syn , ONIG_SYN_STRICT_CHECK_BACKREF ) ) { if ( num > env -> num_mem || IS_NULL ( SCANENV_MEM_NODES ( env ) [ num ] ) ) return ONIGERR_INVALID_BACKREF ; } tok -> type = TK_BACKREF ; tok -> u . backref . num = 1 ; tok -> u . backref . ref1 = num ; tok -> u . backref . by_name = 0 ; # ifdef USE_BACKREF_WITH_LEVEL tok -> u . backref . exist_level = 0 ; # endif break ; } skip_backref : if ( c == '8' || c == '9' ) { p = prev ; PINC ; break ; } p = prev ; case '0' : if ( IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_OCTAL3 ) ) { prev = p ; num = scan_unsigned_octal_number ( & p , end , ( c == '0' ? 2 : 3 ) , enc ) ; if ( num < 0 || 0xff < num ) return ONIGERR_TOO_BIG_NUMBER ; if ( p == prev ) { num = 0 ; } tok -> type = TK_RAW_BYTE ; tok -> base = 8 ; tok -> u . c = num ; } else if ( c != '0' ) { PINC ; } break ; # ifdef USE_NAMED_GROUP case 'k' : if ( ! PEND && IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_ESC_K_NAMED_BACKREF ) ) { PFETCH ( c ) ; if ( c == '<' || c == '\\'' ) { r = fetch_named_backref_token ( c , tok , & p , end , env ) ; if ( r < 0 ) return r ; } else { PUNFETCH ; onig_syntax_warn ( env , "invalid<S2SV_blank>back<S2SV_blank>reference" ) ; } } break ; # endif # if defined ( USE_SUBEXP_CALL ) || defined ( USE_NAMED_GROUP ) case 'g' : # ifdef USE_NAMED_GROUP if ( ! PEND && IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_ESC_G_BRACE_BACKREF ) ) { PFETCH ( c ) ; if ( c == '{' ) { r = fetch_named_backref_token ( c , tok , & p , end , env ) ; if ( r < 0 ) return r ; } else PUNFETCH ; } # endif # ifdef USE_SUBEXP_CALL if ( ! PEND && IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_ESC_G_SUBEXP_CALL ) ) { PFETCH ( c ) ; if ( c == '<' || c == '\\'' ) { int gnum = - 1 , rel = 0 ; UChar * name_end ; OnigCodePoint cnext ; cnext = PPEEK ; if ( cnext == '0' ) { PINC ; if ( PPEEK_IS ( get_name_end_code_point ( c ) ) ) { PINC ; name_end = p ; gnum = 0 ; } } else if ( cnext == '+' ) { PINC ; rel = 1 ; } prev = p ; if ( gnum < 0 ) { r = fetch_name ( ( OnigCodePoint ) c , & p , end , & name_end , env , & gnum , 1 ) ; if ( r < 0 ) return r ; } tok -> type = TK_CALL ; tok -> u . call . name = prev ; tok -> u . call . name_end = name_end ; tok -> u . call . gnum = gnum ; tok -> u . call . rel = rel ; } else { onig_syntax_warn ( env , "invalid<S2SV_blank>subexp<S2SV_blank>call" ) ; PUNFETCH ; } } # endif break ; # endif case 'Q' : if ( IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_ESC_CAPITAL_Q_QUOTE ) ) { tok -> type = TK_QUOTE_OPEN ; } break ; case 'p' : case 'P' : if ( PPEEK_IS ( '{' ) && IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_ESC_P_BRACE_CHAR_PROPERTY ) ) { PINC ; tok -> type = TK_CHAR_PROPERTY ; tok -> u . prop . not = ( c == 'P' ? 1 : 0 ) ; if ( ! PEND && IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_ESC_P_BRACE_CIRCUMFLEX_NOT ) ) { PFETCH ( c ) ; if ( c == '^' ) { tok -> u . prop . not = ( tok -> u . prop . not == 0 ? 1 : 0 ) ; } else PUNFETCH ; } } else { onig_syntax_warn ( env , "invalid<S2SV_blank>Unicode<S2SV_blank>Property<S2SV_blank>\\\\%c" , c ) ; } break ; case 'R' : if ( IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_ESC_CAPITAL_R_LINEBREAK ) ) { tok -> type = TK_LINEBREAK ; } break ; case 'X' : if ( IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_ESC_CAPITAL_X_EXTENDED_GRAPHEME_CLUSTER ) ) { tok -> type = TK_EXTENDED_GRAPHEME_CLUSTER ; } break ; case 'K' : if ( IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_ESC_CAPITAL_K_KEEP ) ) { tok -> type = TK_KEEP ; } break ; default : { OnigCodePoint c2 ; PUNFETCH ; num = fetch_escaped_value ( & p , end , env , & c2 ) ; if ( num < 0 ) return num ; if ( ( OnigCodePoint ) tok -> u . c != c2 ) { tok -> type = TK_CODE_POINT ; tok -> u . code = ( OnigCodePoint ) c2 ; } else { p = tok -> backp + enclen ( enc , tok -> backp , end ) ; } } break ; } } else { tok -> u . c = c ; tok -> escaped = 0 ; # ifdef USE_VARIABLE_META_CHARS if ( ( c != ONIG_INEFFECTIVE_META_CHAR ) && IS_SYNTAX_OP ( syn , ONIG_SYN_OP_VARIABLE_META_CHARACTERS ) ) { if ( c == MC_ANYCHAR ( syn ) ) goto any_char ; else if ( c == MC_ANYTIME ( syn ) ) goto anytime ; else if ( c == MC_ZERO_OR_ONE_TIME ( syn ) ) goto zero_or_one_time ; else if ( c == MC_ONE_OR_MORE_TIME ( syn ) ) goto one_or_more_time ; else if ( c == MC_ANYCHAR_ANYTIME ( syn ) ) { tok -> type = TK_ANYCHAR_ANYTIME ; goto out ; } } # endif switch ( c ) { case '.' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_DOT_ANYCHAR ) ) break ; # ifdef USE_VARIABLE_META_CHARS any_char : # endif tok -> type = TK_ANYCHAR ; break ; case '*' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ASTERISK_ZERO_INF ) ) break ; # ifdef USE_VARIABLE_META_CHARS anytime : # endif tok -> type = TK_OP_REPEAT ; tok -> u . repeat . lower = 0 ; tok -> u . repeat . upper = REPEAT_INFINITE ; goto greedy_check ; break ; case '+' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_PLUS_ONE_INF ) ) break ; # ifdef USE_VARIABLE_META_CHARS one_or_more_time : # endif tok -> type = TK_OP_REPEAT ; tok -> u . repeat . lower = 1 ; tok -> u . repeat . upper = REPEAT_INFINITE ; goto greedy_check ; break ; case '?' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_QMARK_ZERO_ONE ) ) break ; # ifdef USE_VARIABLE_META_CHARS zero_or_one_time : # endif tok -> type = TK_OP_REPEAT ; tok -> u . repeat . lower = 0 ; tok -> u . repeat . upper = 1 ; goto greedy_check ; break ; case '{' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_BRACE_INTERVAL ) ) break ; r = fetch_range_quantifier ( & p , end , tok , env ) ; if ( r < 0 ) return r ; if ( r == 0 ) goto greedy_check ; else if ( r == 2 ) { if ( IS_SYNTAX_BV ( syn , ONIG_SYN_FIXED_INTERVAL_IS_GREEDY_ONLY ) ) goto possessive_check ; goto greedy_check ; } break ; case '|' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_VBAR_ALT ) ) break ; tok -> type = TK_ALT ; break ; case '(' : if ( PPEEK_IS ( '?' ) && IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_QMARK_GROUP_EFFECT ) ) { PINC ; if ( PPEEK_IS ( '#' ) ) { PFETCH ( c ) ; while ( 1 ) { if ( PEND ) return ONIGERR_END_PATTERN_IN_GROUP ; PFETCH ( c ) ; if ( c == MC_ESC ( syn ) ) { if ( ! PEND ) PFETCH ( c ) ; } else { if ( c == ')' ) break ; } } goto start ; } # ifdef USE_PERL_SUBEXP_CALL c = PPEEK ; if ( ( c == '&' || c == 'R' || ONIGENC_IS_CODE_DIGIT ( enc , c ) ) && IS_SYNTAX_OP2 ( env -> syntax , ONIG_SYN_OP2_QMARK_SUBEXP_CALL ) ) { int gnum ; UChar * name ; UChar * name_end ; if ( c == 'R' || c == '0' ) { PINC ; <S2SV_StartBug> if ( ! PPEEK_IS ( ')' ) ) return ONIGERR_INVALID_GROUP_NAME ; <S2SV_EndBug> PINC ; name_end = name = p ; gnum = 0 ; } else { int numref = 1 ; if ( c == '&' ) { PINC ; numref = 0 ; } name = p ; r = fetch_name ( ( OnigCodePoint ) '(' , & p , end , & name_end , env , & gnum , numref ) ; if ( r < 0 ) return r ; } tok -> type = TK_CALL ; tok -> u . call . name = name ; tok -> u . call . name_end = name_end ; tok -> u . call . gnum = gnum ; tok -> u . call . rel = 0 ; break ; } else if ( ( c == '-' || c == '+' ) && IS_SYNTAX_OP2 ( env -> syntax , ONIG_SYN_OP2_QMARK_SUBEXP_CALL ) ) { int gnum ; UChar * name ; UChar * name_end ; OnigCodePoint cnext ; PFETCH_READY ; PINC ; cnext = PPEEK ; if ( ONIGENC_IS_CODE_DIGIT ( enc , cnext ) ) { if ( c == '-' ) PUNFETCH ; name = p ; r = fetch_name ( ( OnigCodePoint ) '(' , & p , end , & name_end , env , & gnum , 1 ) ; if ( r < 0 ) return r ; tok -> type = TK_CALL ; tok -> u . call . name = name ; tok -> u . call . name_end = name_end ; tok -> u . call . gnum = gnum ; tok -> u . call . rel = 1 ; break ; } } # endif # ifdef USE_CAPITAL_P_NAMED_GROUP if ( PPEEK_IS ( 'P' ) && IS_SYNTAX_OP2 ( env -> syntax , ONIG_SYN_OP2_QMARK_CAPITAL_P_NAMED_GROUP ) ) { int gnum ; UChar * name ; UChar * name_end ; PFETCH_READY ; PINC ; if ( PEND ) return ONIGERR_UNDEFINED_GROUP_OPTION ; PFETCH ( c ) ; if ( c == '=' ) { r = fetch_named_backref_token ( ( OnigCodePoint ) '(' , tok , & p , end , env ) ; if ( r < 0 ) return r ; break ; } else if ( c == '>' ) { name = p ; r = fetch_name ( ( OnigCodePoint ) '(' , & p , end , & name_end , env , & gnum , 0 ) ; if ( r < 0 ) return r ; tok -> type = TK_CALL ; tok -> u . call . name = name ; tok -> u . call . name_end = name_end ; tok -> u . call . gnum = gnum ; tok -> u . call . rel = 0 ; break ; } } # endif PUNFETCH ; } if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_LPAREN_SUBEXP ) ) break ; tok -> type = TK_SUBEXP_OPEN ; break ; case ')' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_LPAREN_SUBEXP ) ) break ; tok -> type = TK_SUBEXP_CLOSE ; break ; case '^' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_LINE_ANCHOR ) ) break ; tok -> type = TK_ANCHOR ; tok -> u . anchor . subtype = ( IS_SINGLELINE ( env -> option ) ? ANCHOR_BEGIN_BUF : ANCHOR_BEGIN_LINE ) ; break ; case '$' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_LINE_ANCHOR ) ) break ; tok -> type = TK_ANCHOR ; tok -> u . anchor . subtype = ( IS_SINGLELINE ( env -> option ) ? ANCHOR_SEMI_END_BUF : ANCHOR_END_LINE ) ; break ; case '[' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_BRACKET_CC ) ) break ; tok -> type = TK_CC_OPEN ; break ; case ']' : if ( * src > env -> pattern ) CLOSE_BRACKET_WITHOUT_ESC_WARN ( env , ( UChar * ) "]" ) ; break ; case '#' : if ( IS_EXTEND ( env -> option ) ) { while ( ! PEND ) { PFETCH ( c ) ; if ( ONIGENC_IS_CODE_NEWLINE ( enc , c ) ) break ; } goto start ; break ; } break ; case '<S2SV_blank>' : case '\\t' : case '\\n' : case '\\r' : case '\\f' : if ( IS_EXTEND ( env -> option ) ) goto start ; break ; default : break ; } } # ifdef USE_VARIABLE_META_CHARS out : # endif * src = p ; return tok -> type ; }
CWE-119 int tmx_check_pretran ( sip_msg_t * msg ) { unsigned int chid ; unsigned int slotid ; int dsize ; struct via_param * vbr ; str scallid ; str scseqmet ; str scseqnum ; str sftag ; str svbranch = { NULL , 0 } ; pretran_t * it ; if ( _tmx_ptran_table == NULL ) { LM_ERR ( "pretran<S2SV_blank>hash<S2SV_blank>table<S2SV_blank>not<S2SV_blank>initialized<S2SV_blank>yet\\n" ) ; return - 1 ; } if ( get_route_type ( ) != REQUEST_ROUTE ) { LM_ERR ( "invalid<S2SV_blank>usage<S2SV_blank>-<S2SV_blank>not<S2SV_blank>in<S2SV_blank>request<S2SV_blank>route\\n" ) ; return - 1 ; } if ( msg -> first_line . type != SIP_REQUEST ) { LM_ERR ( "invalid<S2SV_blank>usage<S2SV_blank>-<S2SV_blank>not<S2SV_blank>a<S2SV_blank>sip<S2SV_blank>request\\n" ) ; return - 1 ; } if ( parse_headers ( msg , HDR_FROM_F | HDR_VIA1_F | HDR_CALLID_F | HDR_CSEQ_F , 0 ) < 0 ) { LM_ERR ( "failed<S2SV_blank>to<S2SV_blank>parse<S2SV_blank>required<S2SV_blank>headers\\n" ) ; return - 1 ; } if ( msg -> cseq == NULL || msg -> cseq -> parsed == NULL ) { LM_ERR ( "failed<S2SV_blank>to<S2SV_blank>parse<S2SV_blank>cseq<S2SV_blank>headers\\n" ) ; return - 1 ; } if ( get_cseq ( msg ) -> method_id == METHOD_ACK || get_cseq ( msg ) -> method_id == METHOD_CANCEL ) { LM_DBG ( "no<S2SV_blank>pre-transaction<S2SV_blank>management<S2SV_blank>for<S2SV_blank>ACK<S2SV_blank>or<S2SV_blank>CANCEL\\n" ) ; return - 1 ; } if ( msg -> via1 == 0 ) { LM_ERR ( "failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>Via<S2SV_blank>header\\n" ) ; return - 1 ; } if ( parse_from_header ( msg ) < 0 || get_from ( msg ) -> tag_value . len == 0 ) { LM_ERR ( "failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>From<S2SV_blank>header\\n" ) ; return - 1 ; } if ( msg -> callid == NULL || msg -> callid -> body . s == NULL ) { LM_ERR ( "failed<S2SV_blank>to<S2SV_blank>parse<S2SV_blank>callid<S2SV_blank>headers\\n" ) ; return - 1 ; } vbr = msg -> via1 -> branch ; scallid = msg -> callid -> body ; trim ( & scallid ) ; scseqmet = get_cseq ( msg ) -> method ; trim ( & scseqmet ) ; scseqnum = get_cseq ( msg ) -> number ; trim ( & scseqnum ) ; sftag = get_from ( msg ) -> tag_value ; trim ( & sftag ) ; chid = get_hash1_raw ( msg -> callid -> body . s , msg -> callid -> body . len ) ; slotid = chid & ( _tmx_ptran_size - 1 ) ; if ( unlikely ( _tmx_proc_ptran == NULL ) ) { _tmx_proc_ptran = ( pretran_t * ) shm_malloc ( sizeof ( pretran_t ) ) ; if ( _tmx_proc_ptran == NULL ) { LM_ERR ( "not<S2SV_blank>enough<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>pretran<S2SV_blank>structure\\n" ) ; return - 1 ; } memset ( _tmx_proc_ptran , 0 , sizeof ( pretran_t ) ) ; _tmx_proc_ptran -> pid = my_pid ( ) ; } dsize = scallid . len + scseqnum . len + scseqmet . len + sftag . len + 4 ; if ( likely ( vbr != NULL ) ) { svbranch = vbr -> value ; trim ( & svbranch ) ; <S2SV_StartBug> dsize += svbranch . len ; <S2SV_EndBug> } if ( dsize < 256 ) dsize = 256 ; tmx_pretran_unlink ( ) ; if ( dsize > _tmx_proc_ptran -> dbuf . len ) { if ( _tmx_proc_ptran -> dbuf . s ) shm_free ( _tmx_proc_ptran -> dbuf . s ) ; _tmx_proc_ptran -> dbuf . s = ( char * ) shm_malloc ( dsize ) ; if ( _tmx_proc_ptran -> dbuf . s == NULL ) { LM_ERR ( "not<S2SV_blank>enough<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>pretran<S2SV_blank>data\\n" ) ; return - 1 ; } _tmx_proc_ptran -> dbuf . len = dsize ; } _tmx_proc_ptran -> hid = chid ; _tmx_proc_ptran -> cseqmetid = ( get_cseq ( msg ) ) -> method_id ; _tmx_proc_ptran -> callid . s = _tmx_proc_ptran -> dbuf . s ; memcpy ( _tmx_proc_ptran -> callid . s , scallid . s , scallid . len ) ; _tmx_proc_ptran -> callid . len = scallid . len ; _tmx_proc_ptran -> callid . s [ _tmx_proc_ptran -> callid . len ] = '\\0' ; _tmx_proc_ptran -> ftag . s = _tmx_proc_ptran -> callid . s + _tmx_proc_ptran -> callid . len + 1 ; memcpy ( _tmx_proc_ptran -> ftag . s , sftag . s , sftag . len ) ; _tmx_proc_ptran -> ftag . len = sftag . len ; _tmx_proc_ptran -> ftag . s [ _tmx_proc_ptran -> ftag . len ] = '\\0' ; _tmx_proc_ptran -> cseqnum . s = _tmx_proc_ptran -> ftag . s + _tmx_proc_ptran -> ftag . len + 1 ; memcpy ( _tmx_proc_ptran -> cseqnum . s , scseqnum . s , scseqnum . len ) ; _tmx_proc_ptran -> cseqnum . len = scseqnum . len ; _tmx_proc_ptran -> cseqnum . s [ _tmx_proc_ptran -> cseqnum . len ] = '\\0' ; _tmx_proc_ptran -> cseqmet . s = _tmx_proc_ptran -> cseqnum . s + _tmx_proc_ptran -> cseqnum . len + 1 ; memcpy ( _tmx_proc_ptran -> cseqmet . s , scseqmet . s , scseqmet . len ) ; _tmx_proc_ptran -> cseqmet . len = scseqmet . len ; _tmx_proc_ptran -> cseqmet . s [ _tmx_proc_ptran -> cseqmet . len ] = '\\0' ; if ( likely ( vbr != NULL ) ) { _tmx_proc_ptran -> vbranch . s = _tmx_proc_ptran -> cseqmet . s + _tmx_proc_ptran -> cseqmet . len + 1 ; memcpy ( _tmx_proc_ptran -> vbranch . s , svbranch . s , svbranch . len ) ; _tmx_proc_ptran -> vbranch . len = svbranch . len ; _tmx_proc_ptran -> vbranch . s [ _tmx_proc_ptran -> vbranch . len ] = '\\0' ; } else { _tmx_proc_ptran -> vbranch . s = NULL ; _tmx_proc_ptran -> vbranch . len = 0 ; } lock_get ( & _tmx_ptran_table [ slotid ] . lock ) ; it = _tmx_ptran_table [ slotid ] . plist ; tmx_pretran_link_safe ( slotid ) ; for ( ; it != NULL ; it = it -> next ) { if ( _tmx_proc_ptran -> hid != it -> hid || _tmx_proc_ptran -> cseqmetid != it -> cseqmetid || _tmx_proc_ptran -> callid . len != it -> callid . len || _tmx_proc_ptran -> ftag . len != it -> ftag . len || _tmx_proc_ptran -> cseqmet . len != it -> cseqmet . len || _tmx_proc_ptran -> cseqnum . len != it -> cseqnum . len ) continue ; if ( _tmx_proc_ptran -> vbranch . s != NULL && it -> vbranch . s != NULL ) { if ( _tmx_proc_ptran -> vbranch . len != it -> vbranch . len ) continue ; if ( _tmx_proc_ptran -> vbranch . s [ it -> vbranch . len - 1 ] != it -> vbranch . s [ it -> vbranch . len - 1 ] ) continue ; if ( memcmp ( _tmx_proc_ptran -> vbranch . s , it -> vbranch . s , it -> vbranch . len ) != 0 ) continue ; } if ( memcmp ( _tmx_proc_ptran -> callid . s , it -> callid . s , it -> callid . len ) != 0 || memcmp ( _tmx_proc_ptran -> ftag . s , it -> ftag . s , it -> ftag . len ) != 0 || memcmp ( _tmx_proc_ptran -> cseqnum . s , it -> cseqnum . s , it -> cseqnum . len ) != 0 ) continue ; if ( ( it -> cseqmetid == METHOD_OTHER || it -> cseqmetid == METHOD_UNDEF ) && memcmp ( _tmx_proc_ptran -> cseqmet . s , it -> cseqmet . s , it -> cseqmet . len ) != 0 ) continue ; LM_DBG ( "matched<S2SV_blank>another<S2SV_blank>pre-transaction<S2SV_blank>by<S2SV_blank>pid<S2SV_blank>%d<S2SV_blank>for<S2SV_blank>[%.*s]\\n" , it -> pid , it -> callid . len , it -> callid . s ) ; lock_release ( & _tmx_ptran_table [ slotid ] . lock ) ; return 1 ; } lock_release ( & _tmx_ptran_table [ slotid ] . lock ) ; return 0 ; }
CWE-362 static void create_watching_parent ( void ) { pid_t child ; sigset_t ourset ; struct sigaction oldact [ 3 ] ; int status = 0 ; int retval ; retval = pam_open_session ( pamh , 0 ) ; if ( is_pam_failure ( retval ) ) { cleanup_pam ( retval ) ; errx ( EXIT_FAILURE , _ ( "cannot<S2SV_blank>open<S2SV_blank>session:<S2SV_blank>%s" ) , pam_strerror ( pamh , retval ) ) ; } else _pam_session_opened = 1 ; memset ( oldact , 0 , sizeof ( oldact ) ) ; child = fork ( ) ; if ( child == ( pid_t ) - 1 ) { cleanup_pam ( PAM_ABORT ) ; err ( EXIT_FAILURE , _ ( "cannot<S2SV_blank>create<S2SV_blank>child<S2SV_blank>process" ) ) ; } if ( child == 0 ) return ; if ( chdir ( "/" ) != 0 ) warn ( _ ( "cannot<S2SV_blank>change<S2SV_blank>directory<S2SV_blank>to<S2SV_blank>%s" ) , "/" ) ; sigfillset ( & ourset ) ; if ( sigprocmask ( SIG_BLOCK , & ourset , NULL ) ) { warn ( _ ( "cannot<S2SV_blank>block<S2SV_blank>signals" ) ) ; caught_signal = true ; } if ( ! caught_signal ) { struct sigaction action ; action . sa_handler = su_catch_sig ; sigemptyset ( & action . sa_mask ) ; action . sa_flags = 0 ; sigemptyset ( & ourset ) ; if ( ! same_session ) { if ( sigaddset ( & ourset , SIGINT ) || sigaddset ( & ourset , SIGQUIT ) ) { warn ( _ ( "cannot<S2SV_blank>set<S2SV_blank>signal<S2SV_blank>handler" ) ) ; caught_signal = true ; } } if ( ! caught_signal && ( sigaddset ( & ourset , SIGTERM ) || sigaddset ( & ourset , SIGALRM ) || sigaction ( SIGTERM , & action , & oldact [ 0 ] ) || sigprocmask ( SIG_UNBLOCK , & ourset , NULL ) ) ) { warn ( _ ( "cannot<S2SV_blank>set<S2SV_blank>signal<S2SV_blank>handler" ) ) ; caught_signal = true ; } if ( ! caught_signal && ! same_session && ( sigaction ( SIGINT , & action , & oldact [ 1 ] ) || sigaction ( SIGQUIT , & action , & oldact [ 2 ] ) ) ) { warn ( _ ( "cannot<S2SV_blank>set<S2SV_blank>signal<S2SV_blank>handler" ) ) ; caught_signal = true ; } } if ( ! caught_signal ) { pid_t pid ; for ( ; ; ) { pid = waitpid ( child , & status , WUNTRACED ) ; if ( pid != ( pid_t ) - 1 && WIFSTOPPED ( status ) ) { kill ( getpid ( ) , SIGSTOP ) ; kill ( pid , SIGCONT ) ; } else break ; } if ( pid != ( pid_t ) - 1 ) { if ( WIFSIGNALED ( status ) ) { fprintf ( stderr , "%s%s\\n" , strsignal ( WTERMSIG ( status ) ) , WCOREDUMP ( status ) ? _ ( "<S2SV_blank>(core<S2SV_blank>dumped)" ) : "" ) ; status = WTERMSIG ( status ) + 128 ; } else status = WEXITSTATUS ( status ) ; <S2SV_StartBug> } <S2SV_EndBug> else if ( caught_signal ) status = caught_signal + 128 ; else status = 1 ; } else status = 1 ; <S2SV_StartBug> if ( caught_signal ) <S2SV_EndBug> { fprintf ( stderr , _ ( "\\nSession<S2SV_blank>terminated,<S2SV_blank>killing<S2SV_blank>shell..." ) ) ; kill ( child , SIGTERM ) ; } cleanup_pam ( PAM_SUCCESS ) ; if ( caught_signal ) { <S2SV_StartBug> sleep ( 2 ) ; <S2SV_EndBug> kill ( child , SIGKILL ) ; <S2SV_StartBug> fprintf ( stderr , _ ( "<S2SV_blank>...killed.\\n" ) ) ; <S2SV_EndBug> switch ( caught_signal ) { case SIGTERM : sigaction ( SIGTERM , & oldact [ 0 ] , NULL ) ; break ; case SIGINT : sigaction ( SIGINT , & oldact [ 1 ] , NULL ) ; break ; case SIGQUIT : sigaction ( SIGQUIT , & oldact [ 2 ] , NULL ) ; break ; default : caught_signal = SIGKILL ; break ; } kill ( getpid ( ) , caught_signal ) ; } exit ( status ) ; }
CWE-119 int main ( int argc , char * argv [ ] ) { opj_dinfo_t * dinfo ; opj_event_mgr_t event_mgr ; int tnum ; unsigned int snum ; opj_mj2_t * movie ; mj2_tk_t * track ; mj2_sample_t * sample ; unsigned char * frame_codestream ; FILE * file , * outfile ; char outfilename [ 50 ] ; mj2_dparameters_t parameters ; if ( argc != 3 ) { printf ( "Usage:<S2SV_blank>%s<S2SV_blank>mj2filename<S2SV_blank>output_location\\n" , argv [ 0 ] ) ; printf ( "Example:<S2SV_blank>%s<S2SV_blank>foreman.mj2<S2SV_blank>output/foreman\\n" , argv [ 0 ] ) ; return 1 ; } file = fopen ( argv [ 1 ] , "rb" ) ; if ( ! file ) { fprintf ( stderr , "failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading\\n" , argv [ 1 ] ) ; return 1 ; } memset ( & event_mgr , 0 , sizeof ( opj_event_mgr_t ) ) ; event_mgr . error_handler = error_callback ; event_mgr . warning_handler = warning_callback ; event_mgr . info_handler = info_callback ; dinfo = mj2_create_decompress ( ) ; opj_set_event_mgr ( ( opj_common_ptr ) dinfo , & event_mgr , stderr ) ; memset ( & parameters , 0 , sizeof ( mj2_dparameters_t ) ) ; movie = ( opj_mj2_t * ) dinfo -> mj2_handle ; mj2_setup_decoder ( movie , & parameters ) ; if ( mj2_read_struct ( file , movie ) ) { return 1 ; } tnum = 0 ; while ( movie -> tk [ tnum ] . track_type != 0 ) { tnum ++ ; } track = & movie -> tk [ tnum ] ; fprintf ( stdout , "Extracting<S2SV_blank>%d<S2SV_blank>frames<S2SV_blank>from<S2SV_blank>file...\\n" , track -> num_samples ) ; for ( snum = 0 ; snum < track -> num_samples ; snum ++ ) { sample = & track -> sample [ snum ] ; frame_codestream = ( unsigned char * ) malloc ( sample -> sample_size - 8 ) ; fseek ( file , sample -> offset + 8 , SEEK_SET ) ; fread ( frame_codestream , sample -> sample_size - 8 , 1 , file ) ; <S2SV_StartBug> sprintf ( outfilename , "%s_%05d.j2k" , argv [ 2 ] , snum ) ; <S2SV_EndBug> outfile = fopen ( outfilename , "wb" ) ; if ( ! outfile ) { fprintf ( stderr , "failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing\\n" , outfilename ) ; return 1 ; } fwrite ( frame_codestream , sample -> sample_size - 8 , 1 , outfile ) ; fclose ( outfile ) ; free ( frame_codestream ) ; } fclose ( file ) ; fprintf ( stdout , "%d<S2SV_blank>frames<S2SV_blank>correctly<S2SV_blank>extracted\\n" , snum ) ; if ( dinfo ) { mj2_destroy_decompress ( ( opj_mj2_t * ) dinfo -> mj2_handle ) ; } return 0 ; }
CWE-416 extern int onig_new_deluxe ( regex_t * * reg , const UChar * pattern , const UChar * pattern_end , OnigCompileInfo * ci , OnigErrorInfo * einfo ) { int r ; UChar * cpat , * cpat_end ; if ( IS_NOT_NULL ( einfo ) ) einfo -> par = ( UChar * ) NULL ; if ( ci -> pattern_enc != ci -> target_enc ) { <S2SV_StartBug> r = conv_encoding ( ci -> pattern_enc , ci -> target_enc , pattern , pattern_end , <S2SV_EndBug> & cpat , & cpat_end ) ; if ( r != 0 ) return r ; } else { cpat = ( UChar * ) pattern ; cpat_end = ( UChar * ) pattern_end ; } * reg = ( regex_t * ) xmalloc ( sizeof ( regex_t ) ) ; if ( IS_NULL ( * reg ) ) { r = ONIGERR_MEMORY ; goto err2 ; } r = onig_reg_init ( * reg , ci -> option , ci -> case_fold_flag , ci -> target_enc , ci -> syntax ) ; if ( r != 0 ) goto err ; r = onig_compile ( * reg , cpat , cpat_end , einfo ) ; if ( r != 0 ) { err : onig_free ( * reg ) ; * reg = NULL ; } err2 : if ( cpat != pattern ) xfree ( cpat ) ; return r ; }
CWE-400 static int parse_exp ( Node * * np , PToken * tok , int term , UChar * * src , UChar * end , ScanEnv * env , int group_head ) { <S2SV_StartBug> int r , len , group = 0 ; <S2SV_EndBug> Node * qn ; <S2SV_StartBug> Node * * tp ; <S2SV_EndBug> * np = NULL ; if ( tok -> type == ( enum TokenSyms ) term ) <S2SV_StartBug> goto end_of_token ; <S2SV_EndBug> switch ( tok -> type ) { case TK_ALT : case TK_EOT : end_of_token : * np = node_new_empty ( ) ; CHECK_NULL_RETURN_MEMERR ( * np ) ; return tok -> type ; break ; case TK_SUBEXP_OPEN : r = parse_bag ( np , tok , TK_SUBEXP_CLOSE , src , end , env ) ; if ( r < 0 ) return r ; if ( r == 1 ) { if ( group_head == 0 ) group = 1 ; else { Node * target = * np ; * np = node_new_group ( target ) ; if ( IS_NULL ( * np ) ) { onig_node_free ( target ) ; return ONIGERR_MEMORY ; } group = 2 ; } } else if ( r == 2 ) { Node * target ; OnigOptionType prev = env -> options ; env -> options = BAG_ ( * np ) -> o . options ; r = fetch_token ( tok , src , end , env ) ; if ( r < 0 ) return r ; r = parse_subexp ( & target , tok , term , src , end , env , 0 ) ; env -> options = prev ; if ( r < 0 ) { onig_node_free ( target ) ; return r ; } NODE_BODY ( * np ) = target ; return tok -> type ; } break ; case TK_SUBEXP_CLOSE : if ( ! IS_SYNTAX_BV ( env -> syntax , ONIG_SYN_ALLOW_UNMATCHED_CLOSE_SUBEXP ) ) return ONIGERR_UNMATCHED_CLOSE_PARENTHESIS ; if ( tok -> escaped ) goto tk_raw_byte ; else goto tk_byte ; break ; case TK_STRING : tk_byte : { * np = node_new_str ( tok -> backp , * src ) ; CHECK_NULL_RETURN_MEMERR ( * np ) ; while ( 1 ) { r = fetch_token ( tok , src , end , env ) ; if ( r < 0 ) return r ; if ( r != TK_STRING ) break ; r = onig_node_str_cat ( * np , tok -> backp , * src ) ; if ( r < 0 ) return r ; } string_end : tp = np ; goto repeat ; } break ; case TK_RAW_BYTE : tk_raw_byte : { * np = node_new_str_raw_char ( ( UChar ) tok -> u . c ) ; CHECK_NULL_RETURN_MEMERR ( * np ) ; len = 1 ; while ( 1 ) { if ( len >= ONIGENC_MBC_MINLEN ( env -> enc ) ) { if ( len == enclen ( env -> enc , STR_ ( * np ) -> s ) ) { r = fetch_token ( tok , src , end , env ) ; goto tk_raw_byte_end ; } } r = fetch_token ( tok , src , end , env ) ; if ( r < 0 ) return r ; if ( r != TK_RAW_BYTE ) return ONIGERR_TOO_SHORT_MULTI_BYTE_STRING ; r = node_str_cat_char ( * np , ( UChar ) tok -> u . c ) ; if ( r < 0 ) return r ; len ++ ; } tk_raw_byte_end : if ( ! ONIGENC_IS_VALID_MBC_STRING ( env -> enc , STR_ ( * np ) -> s , STR_ ( * np ) -> end ) ) return ONIGERR_INVALID_WIDE_CHAR_VALUE ; NODE_STRING_CLEAR_RAW ( * np ) ; goto string_end ; } break ; case TK_CODE_POINT : { UChar buf [ ONIGENC_CODE_TO_MBC_MAXLEN ] ; len = ONIGENC_CODE_TO_MBC ( env -> enc , tok -> u . code , buf ) ; if ( len < 0 ) return len ; # ifdef NUMBERED_CHAR_IS_NOT_CASE_AMBIG * np = node_new_str_raw ( buf , buf + len ) ; # else * np = node_new_str ( buf , buf + len ) ; # endif CHECK_NULL_RETURN_MEMERR ( * np ) ; } break ; case TK_QUOTE_OPEN : { OnigCodePoint end_op [ 2 ] ; UChar * qstart , * qend , * nextp ; end_op [ 0 ] = ( OnigCodePoint ) MC_ESC ( env -> syntax ) ; end_op [ 1 ] = ( OnigCodePoint ) 'E' ; qstart = * src ; qend = find_str_position ( end_op , 2 , qstart , end , & nextp , env -> enc ) ; if ( IS_NULL ( qend ) ) { nextp = qend = end ; } * np = node_new_str ( qstart , qend ) ; CHECK_NULL_RETURN_MEMERR ( * np ) ; * src = nextp ; } break ; case TK_CHAR_TYPE : { switch ( tok -> u . prop . ctype ) { case ONIGENC_CTYPE_WORD : * np = node_new_ctype ( tok -> u . prop . ctype , tok -> u . prop . not , env -> options ) ; CHECK_NULL_RETURN_MEMERR ( * np ) ; break ; case ONIGENC_CTYPE_SPACE : case ONIGENC_CTYPE_DIGIT : case ONIGENC_CTYPE_XDIGIT : { CClassNode * cc ; * np = node_new_cclass ( ) ; CHECK_NULL_RETURN_MEMERR ( * np ) ; cc = CCLASS_ ( * np ) ; add_ctype_to_cc ( cc , tok -> u . prop . ctype , 0 , env ) ; if ( tok -> u . prop . not != 0 ) NCCLASS_SET_NOT ( cc ) ; } break ; default : return ONIGERR_PARSER_BUG ; break ; } } break ; case TK_CHAR_PROPERTY : r = parse_char_property ( np , tok , src , end , env ) ; if ( r != 0 ) return r ; break ; case TK_CC_OPEN : { CClassNode * cc ; r = parse_char_class ( np , tok , src , end , env ) ; if ( r != 0 ) return r ; cc = CCLASS_ ( * np ) ; if ( IS_IGNORECASE ( env -> options ) ) { IApplyCaseFoldArg iarg ; iarg . env = env ; iarg . cc = cc ; iarg . alt_root = NULL_NODE ; iarg . ptail = & ( iarg . alt_root ) ; r = ONIGENC_APPLY_ALL_CASE_FOLD ( env -> enc , env -> case_fold_flag , i_apply_case_fold , & iarg ) ; if ( r != 0 ) { onig_node_free ( iarg . alt_root ) ; return r ; } if ( IS_NOT_NULL ( iarg . alt_root ) ) { Node * work = onig_node_new_alt ( * np , iarg . alt_root ) ; if ( IS_NULL ( work ) ) { onig_node_free ( iarg . alt_root ) ; return ONIGERR_MEMORY ; } * np = work ; } } } break ; case TK_ANYCHAR : * np = node_new_anychar ( ) ; CHECK_NULL_RETURN_MEMERR ( * np ) ; break ; case TK_ANYCHAR_ANYTIME : * np = node_new_anychar ( ) ; CHECK_NULL_RETURN_MEMERR ( * np ) ; qn = node_new_quantifier ( 0 , INFINITE_REPEAT , 0 ) ; CHECK_NULL_RETURN_MEMERR ( qn ) ; NODE_BODY ( qn ) = * np ; * np = qn ; break ; case TK_BACKREF : len = tok -> u . backref . num ; * np = node_new_backref ( len , ( len > 1 ? tok -> u . backref . refs : & ( tok -> u . backref . ref1 ) ) , tok -> u . backref . by_name , # ifdef USE_BACKREF_WITH_LEVEL tok -> u . backref . exist_level , tok -> u . backref . level , # endif env ) ; CHECK_NULL_RETURN_MEMERR ( * np ) ; break ; # ifdef USE_CALL case TK_CALL : { int gnum = tok -> u . call . gnum ; * np = node_new_call ( tok -> u . call . name , tok -> u . call . name_end , gnum , tok -> u . call . by_number ) ; CHECK_NULL_RETURN_MEMERR ( * np ) ; env -> num_call ++ ; if ( tok -> u . call . by_number != 0 && gnum == 0 ) { env -> has_call_zero = 1 ; } } break ; # endif case TK_ANCHOR : { int ascii_mode = IS_WORD_ASCII ( env -> options ) && IS_WORD_ANCHOR_TYPE ( tok -> u . anchor ) ? 1 : 0 ; * np = onig_node_new_anchor ( tok -> u . anchor , ascii_mode ) ; CHECK_NULL_RETURN_MEMERR ( * np ) ; } break ; case TK_REPEAT : case TK_INTERVAL : if ( IS_SYNTAX_BV ( env -> syntax , ONIG_SYN_CONTEXT_INDEP_REPEAT_OPS ) ) { if ( IS_SYNTAX_BV ( env -> syntax , ONIG_SYN_CONTEXT_INVALID_REPEAT_OPS ) ) return ONIGERR_TARGET_OF_REPEAT_OPERATOR_NOT_SPECIFIED ; else { * np = node_new_empty ( ) ; CHECK_NULL_RETURN_MEMERR ( * np ) ; } } else { goto tk_byte ; } break ; case TK_KEEP : r = node_new_keep ( np , env ) ; if ( r < 0 ) return r ; break ; case TK_GENERAL_NEWLINE : r = node_new_general_newline ( np , env ) ; if ( r < 0 ) return r ; break ; case TK_NO_NEWLINE : r = node_new_no_newline ( np , env ) ; if ( r < 0 ) return r ; break ; case TK_TRUE_ANYCHAR : r = node_new_true_anychar ( np , env ) ; if ( r < 0 ) return r ; break ; case TK_TEXT_SEGMENT : r = make_text_segment ( np , env ) ; if ( r < 0 ) return r ; break ; default : return ONIGERR_PARSER_BUG ; break ; } { tp = np ; re_entry : r = fetch_token ( tok , src , end , env ) ; if ( r < 0 ) return r ; repeat : if ( r == TK_REPEAT || r == TK_INTERVAL ) { Node * target ; if ( is_invalid_quantifier_target ( * tp ) ) return ONIGERR_TARGET_OF_REPEAT_OPERATOR_INVALID ; <S2SV_StartBug> qn = node_new_quantifier ( tok -> u . repeat . lower , tok -> u . repeat . upper , <S2SV_EndBug> r == TK_INTERVAL ) ; CHECK_NULL_RETURN_MEMERR ( qn ) ; QUANT_ ( qn ) -> greedy = tok -> u . repeat . greedy ; if ( group == 2 ) { target = node_drop_group ( * tp ) ; * tp = NULL_NODE ; } else { target = * tp ; } r = set_quantifier ( qn , target , group , env ) ; if ( r < 0 ) { onig_node_free ( qn ) ; return r ; } if ( tok -> u . repeat . possessive != 0 ) { Node * en ; en = node_new_bag ( BAG_STOP_BACKTRACK ) ; if ( IS_NULL ( en ) ) { onig_node_free ( qn ) ; return ONIGERR_MEMORY ; } NODE_BODY ( en ) = qn ; qn = en ; } if ( r == 0 ) { * tp = qn ; } else if ( r == 1 ) { onig_node_free ( qn ) ; * tp = target ; } else if ( r == 2 ) { Node * tmp ; * tp = node_new_list ( * tp , NULL ) ; if ( IS_NULL ( * tp ) ) { onig_node_free ( qn ) ; return ONIGERR_MEMORY ; } tmp = NODE_CDR ( * tp ) = node_new_list ( qn , NULL ) ; if ( IS_NULL ( tmp ) ) { onig_node_free ( qn ) ; return ONIGERR_MEMORY ; } tp = & ( NODE_CAR ( tmp ) ) ; } group = 0 ; goto re_entry ; } } return r ; }
CWE-476 static int compile_bag_node ( BagNode * node , regex_t * reg , ScanEnv * env ) { int r , len ; switch ( node -> type ) { case BAG_MEMORY : r = compile_bag_memory_node ( node , reg , env ) ; break ; case BAG_OPTION : r = compile_option_node ( node , reg , env ) ; break ; case BAG_STOP_BACKTRACK : if ( NODE_IS_STOP_BT_SIMPLE_REPEAT ( node ) ) { QuantNode * qn = QUANT_ ( NODE_BAG_BODY ( node ) ) ; r = compile_tree_n_times ( NODE_QUANT_BODY ( qn ) , qn -> lower , reg , env ) ; if ( r != 0 ) return r ; len = compile_length_tree ( NODE_QUANT_BODY ( qn ) , reg ) ; if ( len < 0 ) return len ; r = add_op ( reg , OP_PUSH ) ; if ( r != 0 ) return r ; COP ( reg ) -> push . addr = SIZE_INC_OP + len + SIZE_OP_POP_OUT + SIZE_OP_JUMP ; r = compile_tree ( NODE_QUANT_BODY ( qn ) , reg , env ) ; if ( r != 0 ) return r ; r = add_op ( reg , OP_POP_OUT ) ; if ( r != 0 ) return r ; r = add_op ( reg , OP_JUMP ) ; if ( r != 0 ) return r ; COP ( reg ) -> jump . addr = - ( ( int ) SIZE_OP_PUSH + len + ( int ) SIZE_OP_POP_OUT ) ; } else { r = add_op ( reg , OP_ATOMIC_START ) ; if ( r != 0 ) return r ; r = compile_tree ( NODE_BAG_BODY ( node ) , reg , env ) ; if ( r != 0 ) return r ; r = add_op ( reg , OP_ATOMIC_END ) ; } break ; case BAG_IF_ELSE : { <S2SV_StartBug> int cond_len , then_len , jump_len ; <S2SV_EndBug> Node * cond = NODE_BAG_BODY ( node ) ; Node * Then = node -> te . Then ; Node * Else = node -> te . Else ; r = add_op ( reg , OP_ATOMIC_START ) ; if ( r != 0 ) return r ; cond_len = compile_length_tree ( cond , reg ) ; if ( cond_len < 0 ) return cond_len ; if ( IS_NOT_NULL ( Then ) ) { then_len = compile_length_tree ( Then , reg ) ; if ( then_len < 0 ) return then_len ; } else then_len = 0 ; <S2SV_StartBug> jump_len = cond_len + then_len + SIZE_OP_ATOMIC_END ; <S2SV_EndBug> if ( IS_NOT_NULL ( Else ) ) jump_len += SIZE_OP_JUMP ; r = add_op ( reg , OP_PUSH ) ; if ( r != 0 ) return r ; COP ( reg ) -> push . addr = SIZE_INC_OP + jump_len ; r = compile_tree ( cond , reg , env ) ; if ( r != 0 ) return r ; r = add_op ( reg , OP_ATOMIC_END ) ; if ( r != 0 ) return r ; if ( IS_NOT_NULL ( Then ) ) { r = compile_tree ( Then , reg , env ) ; if ( r != 0 ) return r ; } if ( IS_NOT_NULL ( Else ) ) { <S2SV_StartBug> int else_len = compile_length_tree ( Else , reg ) ; <S2SV_EndBug> r = add_op ( reg , OP_JUMP ) ; if ( r != 0 ) return r ; <S2SV_StartBug> COP ( reg ) -> jump . addr = else_len + SIZE_INC_OP ; <S2SV_EndBug> <S2SV_StartBug> r = compile_tree ( Else , reg , env ) ; <S2SV_EndBug> } } break ; } return r ; }
CWE-476 static int compile_length_bag_node ( BagNode * node , regex_t * reg ) { int len ; int tlen ; if ( node -> type == BAG_OPTION ) return compile_length_option_node ( node , reg ) ; if ( NODE_BAG_BODY ( node ) ) { tlen = compile_length_tree ( NODE_BAG_BODY ( node ) , reg ) ; if ( tlen < 0 ) return tlen ; } else tlen = 0 ; switch ( node -> type ) { case BAG_MEMORY : # ifdef USE_CALL if ( node -> m . regnum == 0 && NODE_IS_CALLED ( node ) ) { len = tlen + SIZE_OP_CALL + SIZE_OP_JUMP + SIZE_OP_RETURN ; return len ; } if ( NODE_IS_CALLED ( node ) ) { len = SIZE_OP_MEMORY_START_PUSH + tlen + SIZE_OP_CALL + SIZE_OP_JUMP + SIZE_OP_RETURN ; if ( MEM_STATUS_AT0 ( reg -> bt_mem_end , node -> m . regnum ) ) len += ( NODE_IS_RECURSION ( node ) ? SIZE_OP_MEMORY_END_PUSH_REC : SIZE_OP_MEMORY_END_PUSH ) ; else len += ( NODE_IS_RECURSION ( node ) ? SIZE_OP_MEMORY_END_REC : SIZE_OP_MEMORY_END ) ; } else if ( NODE_IS_RECURSION ( node ) ) { len = SIZE_OP_MEMORY_START_PUSH ; len += tlen + ( MEM_STATUS_AT0 ( reg -> bt_mem_end , node -> m . regnum ) ? SIZE_OP_MEMORY_END_PUSH_REC : SIZE_OP_MEMORY_END_REC ) ; } else # endif { if ( MEM_STATUS_AT0 ( reg -> bt_mem_start , node -> m . regnum ) ) len = SIZE_OP_MEMORY_START_PUSH ; else len = SIZE_OP_MEMORY_START ; len += tlen + ( MEM_STATUS_AT0 ( reg -> bt_mem_end , node -> m . regnum ) ? SIZE_OP_MEMORY_END_PUSH : SIZE_OP_MEMORY_END ) ; } break ; case BAG_STOP_BACKTRACK : if ( NODE_IS_STOP_BT_SIMPLE_REPEAT ( node ) ) { int v ; QuantNode * qn ; qn = QUANT_ ( NODE_BAG_BODY ( node ) ) ; tlen = compile_length_tree ( NODE_QUANT_BODY ( qn ) , reg ) ; if ( tlen < 0 ) return tlen ; v = onig_positive_int_multiply ( qn -> lower , tlen ) ; if ( v < 0 ) return ONIGERR_TOO_BIG_NUMBER_FOR_REPEAT_RANGE ; len = v + SIZE_OP_PUSH + tlen + SIZE_OP_POP_OUT + SIZE_OP_JUMP ; } else { len = SIZE_OP_ATOMIC_START + tlen + SIZE_OP_ATOMIC_END ; } break ; case BAG_IF_ELSE : { Node * cond = NODE_BAG_BODY ( node ) ; Node * Then = node -> te . Then ; Node * Else = node -> te . Else ; len = compile_length_tree ( cond , reg ) ; if ( len < 0 ) return len ; len += SIZE_OP_PUSH ; len += SIZE_OP_ATOMIC_START + SIZE_OP_ATOMIC_END ; if ( IS_NOT_NULL ( Then ) ) { tlen = compile_length_tree ( Then , reg ) ; if ( tlen < 0 ) return tlen ; len += tlen ; } <S2SV_StartBug> if ( IS_NOT_NULL ( Else ) ) { <S2SV_EndBug> <S2SV_StartBug> len += SIZE_OP_JUMP ; <S2SV_EndBug> tlen = compile_length_tree ( Else , reg ) ; if ( tlen < 0 ) return tlen ; len += tlen ; } } break ; case BAG_OPTION : len = 0 ; break ; } return len ; }
CWE-119 void faad_resetbits ( bitfile * ld , int bits ) { uint32_t tmp ; int words = bits >> 5 ; int remainder = bits & 0x1F ; <S2SV_StartBug> ld -> bytes_left = ld -> buffer_size - words * 4 ; <S2SV_EndBug> if ( ld -> bytes_left >= 4 ) { tmp = getdword ( & ld -> start [ words ] ) ; ld -> bytes_left -= 4 ; } else { tmp = getdword_n ( & ld -> start [ words ] , ld -> bytes_left ) ; ld -> bytes_left = 0 ; } ld -> bufa = tmp ; if ( ld -> bytes_left >= 4 ) { tmp = getdword ( & ld -> start [ words + 1 ] ) ; ld -> bytes_left -= 4 ; } else { tmp = getdword_n ( & ld -> start [ words + 1 ] , ld -> bytes_left ) ; ld -> bytes_left = 0 ; } ld -> bufb = tmp ; ld -> bits_left = 32 - remainder ; ld -> tail = & ld -> start [ words + 2 ] ; ld -> error = 0 ; }
CWE-119 static uint8_t excluded_channels ( bitfile * ld , drc_info * drc ) { uint8_t i , n = 0 ; uint8_t num_excl_chan = 7 ; for ( i = 0 ; i < 7 ; i ++ ) { drc -> exclude_mask [ i ] = faad_get1bit ( ld DEBUGVAR ( 1 , 103 , "excluded_channels():<S2SV_blank>exclude_mask" ) ) ; } n ++ ; while ( ( drc -> additional_excluded_chns [ n - 1 ] = faad_get1bit ( ld DEBUGVAR ( 1 , 104 , "excluded_channels():<S2SV_blank>additional_excluded_chns" ) ) ) == 1 ) { <S2SV_StartBug> for ( i = num_excl_chan ; i < num_excl_chan + 7 ; i ++ ) <S2SV_EndBug> { drc -> exclude_mask [ i ] = faad_get1bit ( ld DEBUGVAR ( 1 , 105 , "excluded_channels():<S2SV_blank>exclude_mask" ) ) ; } n ++ ; num_excl_chan += 7 ; } return n ; }
CWE-415 static Gif_Stream * read_gif ( Gif_Reader * grr , int read_flags , const char * landmark , Gif_ReadErrorHandler handler ) { Gif_Stream * gfs ; Gif_Image * gfi ; Gif_Context gfc ; int unknown_block_type = 0 ; if ( gifgetc ( grr ) != 'G' || gifgetc ( grr ) != 'I' || gifgetc ( grr ) != 'F' ) return 0 ; ( void ) gifgetc ( grr ) ; ( void ) gifgetc ( grr ) ; ( void ) gifgetc ( grr ) ; gfs = Gif_NewStream ( ) ; gfi = Gif_NewImage ( ) ; gfc . stream = gfs ; gfc . prefix = Gif_NewArray ( Gif_Code , GIF_MAX_CODE ) ; gfc . suffix = Gif_NewArray ( uint8_t , GIF_MAX_CODE ) ; gfc . length = Gif_NewArray ( uint16_t , GIF_MAX_CODE ) ; gfc . handler = handler ; gfc . gfi = gfi ; gfc . errors [ 0 ] = gfc . errors [ 1 ] = 0 ; if ( ! gfs || ! gfi || ! gfc . prefix || ! gfc . suffix || ! gfc . length ) goto done ; gfs -> landmark = landmark ; GIF_DEBUG ( ( "\\nGIF<S2SV_blank>" ) ) ; if ( ! read_logical_screen_descriptor ( gfs , grr ) ) goto done ; GIF_DEBUG ( ( "logscrdesc<S2SV_blank>" ) ) ; while ( ! gifeof ( grr ) ) { uint8_t block = gifgetbyte ( grr ) ; switch ( block ) { case ',' : GIF_DEBUG ( ( "imageread<S2SV_blank>%d<S2SV_blank>" , gfs -> nimages ) ) ; gfi -> identifier = last_name ; last_name = 0 ; if ( ! Gif_AddImage ( gfs , gfi ) ) goto done ; else if ( ! read_image ( grr , & gfc , gfi , read_flags ) ) { Gif_RemoveImage ( gfs , gfs -> nimages - 1 ) ; gfi = 0 ; goto done ; } gfc . gfi = gfi = Gif_NewImage ( ) ; if ( ! gfi ) goto done ; break ; case ';' : GIF_DEBUG ( ( "term\\n" ) ) ; goto done ; case '!' : block = gifgetbyte ( grr ) ; GIF_DEBUG ( ( "ext(0x%02X)<S2SV_blank>" , block ) ) ; switch ( block ) { case 0xF9 : read_graphic_control_extension ( & gfc , gfi , grr ) ; break ; case 0xCE : last_name = suck_data ( last_name , 0 , grr ) ; break ; case 0xFE : if ( ! read_comment_extension ( gfi , grr ) ) goto done ; break ; case 0xFF : read_application_extension ( & gfc , grr ) ; break ; default : read_unknown_extension ( & gfc , grr , block , 0 , 0 ) ; break ; } break ; default : if ( ! unknown_block_type ) { char buf [ 256 ] ; sprintf ( buf , "unknown<S2SV_blank>block<S2SV_blank>type<S2SV_blank>%d<S2SV_blank>at<S2SV_blank>file<S2SV_blank>offset<S2SV_blank>%u" , block , grr -> pos - 1 ) ; gif_read_error ( & gfc , 1 , buf ) ; unknown_block_type = 1 ; } break ; } } done : if ( gfs && gfi ) { Gif_Extension * gfex ; gfs -> end_comment = gfi -> comment ; gfi -> comment = 0 ; gfs -> end_extension_list = gfi -> extension_list ; gfi -> extension_list = 0 ; for ( gfex = gfs -> end_extension_list ; gfex ; gfex = gfex -> next ) gfex -> image = NULL ; } Gif_DeleteImage ( gfi ) ; Gif_DeleteArray ( last_name ) ; Gif_DeleteArray ( gfc . prefix ) ; Gif_DeleteArray ( gfc . suffix ) ; Gif_DeleteArray ( gfc . length ) ; gfc . gfi = 0 ; <S2SV_StartBug> if ( gfs ) <S2SV_EndBug> gfs -> errors = gfc . errors [ 1 ] ; if ( gfs && gfc . errors [ 1 ] == 0 && ! ( read_flags & GIF_READ_TRAILING_GARBAGE_OK ) && ! grr -> eofer ( grr ) ) gif_read_error ( & gfc , 0 , "trailing<S2SV_blank>garbage<S2SV_blank>after<S2SV_blank>GIF<S2SV_blank>ignored" ) ; gif_read_error ( & gfc , - 1 , 0 ) ; return gfs ; }
CWE-617 krb5_error_code kdc_process_s4u2self_req ( kdc_realm_t * kdc_active_realm , krb5_kdc_req * request , krb5_const_principal client_princ , krb5_const_principal header_srv_princ , krb5_boolean issuing_referral , const krb5_db_entry * server , krb5_keyblock * tgs_subkey , krb5_keyblock * tgs_session , krb5_timestamp kdc_time , krb5_pa_s4u_x509_user * * s4u_x509_user , krb5_db_entry * * princ_ptr , const char * * status ) { krb5_error_code code ; krb5_boolean is_local_tgt ; krb5_pa_data * pa_data ; int flags ; krb5_db_entry * princ ; * princ_ptr = NULL ; pa_data = krb5int_find_pa_data ( kdc_context , request -> padata , KRB5_PADATA_S4U_X509_USER ) ; if ( pa_data != NULL ) { code = kdc_process_s4u_x509_user ( kdc_context , request , pa_data , tgs_subkey , tgs_session , s4u_x509_user , status ) ; if ( code != 0 ) return code ; } else { pa_data = krb5int_find_pa_data ( kdc_context , request -> padata , KRB5_PADATA_FOR_USER ) ; if ( pa_data != NULL ) { code = kdc_process_for_user ( kdc_active_realm , pa_data , tgs_session , s4u_x509_user , status ) ; if ( code != 0 ) return code ; } else return 0 ; } flags = 0 ; switch ( krb5_princ_type ( kdc_context , request -> server ) ) { case KRB5_NT_SRV_HST : if ( krb5_princ_size ( kdc_context , request -> server ) == 2 ) flags |= KRB5_PRINCIPAL_COMPARE_IGNORE_REALM ; break ; case KRB5_NT_ENTERPRISE_PRINCIPAL : flags |= KRB5_PRINCIPAL_COMPARE_ENTERPRISE ; break ; default : break ; } if ( ! krb5_principal_compare_flags ( kdc_context , request -> server , client_princ , flags ) ) { * status = "INVALID_S4U2SELF_REQUEST" ; return KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN ; } if ( request -> kdc_options & AS_INVALID_OPTIONS ) { * status = "INVALID<S2SV_blank>AS<S2SV_blank>OPTIONS" ; return KRB5KDC_ERR_BADOPTION ; } is_local_tgt = ! is_cross_tgs_principal ( header_srv_princ ) ; if ( is_local_tgt && issuing_referral ) { * status = "LOOKING_UP_SERVER" ; return KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN ; } if ( is_local_principal ( kdc_active_realm , ( * s4u_x509_user ) -> user_id . user ) ) { krb5_db_entry no_server ; krb5_pa_data * * e_data = NULL ; if ( ! is_local_tgt && ! issuing_referral ) { * status = "NOT_CROSS_REALM_REQUEST" ; return KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN ; } code = krb5_db_get_principal ( kdc_context , ( * s4u_x509_user ) -> user_id . user , KRB5_KDB_FLAG_INCLUDE_PAC , & princ ) ; if ( code == KRB5_KDB_NOENTRY ) { * status = "UNKNOWN_S4U2SELF_PRINCIPAL" ; return KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN ; } else if ( code ) { * status = "LOOKING_UP_S4U2SELF_PRINCIPAL" ; return code ; } memset ( & no_server , 0 , sizeof ( no_server ) ) ; <S2SV_StartBug> code = validate_as_request ( kdc_active_realm , request , * princ , <S2SV_EndBug> no_server , kdc_time , status , & e_data ) ; if ( code ) { krb5_db_free_principal ( kdc_context , princ ) ; krb5_free_pa_data ( kdc_context , e_data ) ; return code ; } * princ_ptr = princ ; } else if ( is_local_tgt ) { * status = "S4U2SELF_CLIENT_NOT_OURS" ; return KRB5KDC_ERR_POLICY ; } return 0 ; }
CWE-617 static krb5_error_code s4u_identify_user ( krb5_context context , krb5_creds * in_creds , krb5_data * subject_cert , krb5_principal * canon_user ) { krb5_error_code code ; krb5_preauthtype ptypes [ 1 ] = { KRB5_PADATA_S4U_X509_USER } ; krb5_creds creds ; int use_master = 0 ; krb5_get_init_creds_opt * opts = NULL ; krb5_principal_data client ; krb5_s4u_userid userid ; * canon_user = NULL ; if ( in_creds -> client == NULL && subject_cert == NULL ) { return EINVAL ; } if ( in_creds -> client != NULL && in_creds -> client -> type != KRB5_NT_ENTERPRISE_PRINCIPAL ) { int anonymous ; anonymous = krb5_principal_compare ( context , in_creds -> client , krb5_anonymous_principal ( ) ) ; return krb5_copy_principal ( context , anonymous ? in_creds -> server : in_creds -> client , canon_user ) ; } memset ( & creds , 0 , sizeof ( creds ) ) ; memset ( & userid , 0 , sizeof ( userid ) ) ; if ( subject_cert != NULL ) userid . subject_cert = * subject_cert ; code = krb5_get_init_creds_opt_alloc ( context , & opts ) ; if ( code != 0 ) goto cleanup ; krb5_get_init_creds_opt_set_tkt_life ( opts , 15 ) ; krb5_get_init_creds_opt_set_renew_life ( opts , 0 ) ; krb5_get_init_creds_opt_set_forwardable ( opts , 0 ) ; krb5_get_init_creds_opt_set_proxiable ( opts , 0 ) ; krb5_get_init_creds_opt_set_canonicalize ( opts , 1 ) ; krb5_get_init_creds_opt_set_preauth_list ( opts , ptypes , 1 ) ; if ( in_creds -> client != NULL ) { client = * in_creds -> client ; client . realm = in_creds -> server -> realm ; } else { client . magic = KV5M_PRINCIPAL ; client . realm = in_creds -> server -> realm ; client . data = NULL ; client . length = 0 ; client . type = KRB5_NT_ENTERPRISE_PRINCIPAL ; } code = k5_get_init_creds ( context , & creds , & client , NULL , NULL , 0 , NULL , opts , krb5_get_as_key_noop , & userid , & use_master , NULL ) ; <S2SV_StartBug> if ( code == 0 || code == KRB5_PREAUTH_FAILED ) { <S2SV_EndBug> * canon_user = userid . user ; userid . user = NULL ; code = 0 ; } cleanup : krb5_free_cred_contents ( context , & creds ) ; if ( opts != NULL ) krb5_get_init_creds_opt_free ( context , opts ) ; if ( userid . user != NULL ) krb5_free_principal ( context , userid . user ) ; return code ; }
CWE-90 kadm5_ret_t kadm5_create_principal_3 ( void * server_handle , kadm5_principal_ent_t entry , long mask , int n_ks_tuple , krb5_key_salt_tuple * ks_tuple , char * password ) { krb5_db_entry * kdb ; osa_princ_ent_rec adb ; kadm5_policy_ent_rec polent ; krb5_boolean have_polent = FALSE ; krb5_timestamp now ; krb5_tl_data * tl_data_tail ; unsigned int ret ; kadm5_server_handle_t handle = server_handle ; krb5_keyblock * act_mkey ; krb5_kvno act_kvno ; int new_n_ks_tuple = 0 ; krb5_key_salt_tuple * new_ks_tuple = NULL ; CHECK_HANDLE ( server_handle ) ; krb5_clear_error_message ( handle -> context ) ; check_1_6_dummy ( entry , mask , n_ks_tuple , ks_tuple , & password ) ; if ( entry == NULL ) return EINVAL ; if ( ! ( mask & KADM5_PRINCIPAL ) || ( mask & KADM5_MOD_NAME ) || ( mask & KADM5_MOD_TIME ) || ( mask & KADM5_LAST_PWD_CHANGE ) || ( mask & KADM5_MKVNO ) || ( mask & KADM5_AUX_ATTRIBUTES ) || ( mask & KADM5_LAST_SUCCESS ) || ( mask & KADM5_LAST_FAILED ) || ( mask & KADM5_FAIL_AUTH_COUNT ) ) return KADM5_BAD_MASK ; if ( ( mask & KADM5_KEY_DATA ) && entry -> n_key_data != 0 ) return KADM5_BAD_MASK ; if ( ( mask & KADM5_POLICY ) && entry -> policy == NULL ) return KADM5_BAD_MASK ; if ( ( mask & KADM5_POLICY ) && ( mask & KADM5_POLICY_CLR ) ) return KADM5_BAD_MASK ; if ( ( mask & ~ ALL_PRINC_MASK ) ) <S2SV_StartBug> return KADM5_BAD_MASK ; <S2SV_EndBug> ret = kdb_get_entry ( handle , entry -> principal , & kdb , & adb ) ; switch ( ret ) { case KADM5_UNK_PRINC : break ; case 0 : kdb_free_entry ( handle , kdb , & adb ) ; return KADM5_DUP ; default : return ret ; } kdb = calloc ( 1 , sizeof ( * kdb ) ) ; if ( kdb == NULL ) return ENOMEM ; memset ( & adb , 0 , sizeof ( osa_princ_ent_rec ) ) ; if ( ( mask & KADM5_POLICY ) ) { ret = get_policy ( handle , entry -> policy , & polent , & have_polent ) ; if ( ret ) goto cleanup ; } if ( password ) { ret = passwd_check ( handle , password , have_polent ? & polent : NULL , entry -> principal ) ; if ( ret ) goto cleanup ; } if ( ( ret = krb5_timeofday ( handle -> context , & now ) ) ) goto cleanup ; kdb -> magic = KRB5_KDB_MAGIC_NUMBER ; kdb -> len = KRB5_KDB_V1_BASE_LENGTH ; if ( ( mask & KADM5_ATTRIBUTES ) ) kdb -> attributes = entry -> attributes ; else kdb -> attributes = handle -> params . flags ; if ( ( mask & KADM5_MAX_LIFE ) ) kdb -> max_life = entry -> max_life ; else kdb -> max_life = handle -> params . max_life ; if ( mask & KADM5_MAX_RLIFE ) kdb -> max_renewable_life = entry -> max_renewable_life ; else kdb -> max_renewable_life = handle -> params . max_rlife ; if ( ( mask & KADM5_PRINC_EXPIRE_TIME ) ) kdb -> expiration = entry -> princ_expire_time ; else kdb -> expiration = handle -> params . expiration ; kdb -> pw_expiration = 0 ; if ( have_polent ) { if ( polent . pw_max_life ) kdb -> pw_expiration = ts_incr ( now , polent . pw_max_life ) ; else kdb -> pw_expiration = 0 ; } if ( ( mask & KADM5_PW_EXPIRATION ) ) kdb -> pw_expiration = entry -> pw_expiration ; kdb -> last_success = 0 ; kdb -> last_failed = 0 ; kdb -> fail_auth_count = 0 ; ret = krb5_copy_principal ( handle -> context , entry -> principal , & kdb -> princ ) ; if ( ret ) goto cleanup ; if ( ( ret = krb5_dbe_update_last_pwd_change ( handle -> context , kdb , now ) ) ) goto cleanup ; if ( mask & KADM5_TL_DATA ) { for ( tl_data_tail = entry -> tl_data ; tl_data_tail ; tl_data_tail = tl_data_tail -> tl_data_next ) { ret = krb5_dbe_update_tl_data ( handle -> context , kdb , tl_data_tail ) ; if ( ret ) goto cleanup ; } } ret = apply_keysalt_policy ( handle , entry -> policy , n_ks_tuple , ks_tuple , & new_n_ks_tuple , & new_ks_tuple ) ; if ( ret ) goto cleanup ; ret = kdb_get_active_mkey ( handle , & act_kvno , & act_mkey ) ; if ( ret ) goto cleanup ; if ( mask & KADM5_KEY_DATA ) { assert ( entry -> n_key_data == 0 ) ; } else if ( password ) { ret = krb5_dbe_cpw ( handle -> context , act_mkey , new_ks_tuple , new_n_ks_tuple , password , ( mask & KADM5_KVNO ) ? entry -> kvno : 1 , FALSE , kdb ) ; } else { ret = krb5_dbe_crk ( handle -> context , & master_keyblock , new_ks_tuple , new_n_ks_tuple , FALSE , kdb ) ; } if ( ret ) goto cleanup ; ret = krb5_dbe_update_mkvno ( handle -> context , kdb , act_kvno ) ; if ( ret ) goto cleanup ; ret = k5_kadm5_hook_create ( handle -> context , handle -> hook_handles , KADM5_HOOK_STAGE_PRECOMMIT , entry , mask , new_n_ks_tuple , new_ks_tuple , password ) ; if ( ret ) goto cleanup ; adb . admin_history_kvno = INITIAL_HIST_KVNO ; if ( mask & KADM5_POLICY ) { adb . aux_attributes = KADM5_POLICY ; adb . policy = entry -> policy ; } kdb -> mask = mask | KADM5_KEY_DATA | KADM5_PRINCIPAL ; ret = kdb_put_entry ( handle , kdb , & adb ) ; ( void ) k5_kadm5_hook_create ( handle -> context , handle -> hook_handles , KADM5_HOOK_STAGE_POSTCOMMIT , entry , mask , new_n_ks_tuple , new_ks_tuple , password ) ; cleanup : free ( new_ks_tuple ) ; krb5_db_free_principal ( handle -> context , kdb ) ; if ( have_polent ) ( void ) kadm5_free_policy_ent ( handle -> lhandle , & polent ) ; return ret ; }
CWE-90 krb5_error_code krb5_ldap_put_principal ( krb5_context context , krb5_db_entry * entry , char * * db_args ) { int l = 0 , kerberos_principal_object_type = 0 ; unsigned int ntrees = 0 , tre = 0 ; krb5_error_code st = 0 , tempst = 0 ; LDAP * ld = NULL ; LDAPMessage * result = NULL , * ent = NULL ; char * * subtreelist = NULL ; char * user = NULL , * subtree = NULL , * principal_dn = NULL ; <S2SV_StartBug> char * * values = NULL , * strval [ 10 ] = { NULL } , errbuf [ 1024 ] ; <S2SV_EndBug> char * filtuser = NULL ; struct berval * * bersecretkey = NULL ; LDAPMod * * mods = NULL ; krb5_boolean create_standalone = FALSE ; <S2SV_StartBug> krb5_boolean krb_identity_exists = FALSE , establish_links = FALSE ; <S2SV_EndBug> char * standalone_principal_dn = NULL ; krb5_tl_data * tl_data = NULL ; krb5_key_data * * keys = NULL ; kdb5_dal_handle * dal_handle = NULL ; krb5_ldap_context * ldap_context = NULL ; krb5_ldap_server_handle * ldap_server_handle = NULL ; osa_princ_ent_rec princ_ent = { 0 } ; xargs_t xargs = { 0 } ; char * polname = NULL ; OPERATION optype ; krb5_boolean found_entry = FALSE ; krb5_clear_error_message ( context ) ; SETUP_CONTEXT ( ) ; if ( ldap_context -> lrparams == NULL || ldap_context -> container_dn == NULL ) return EINVAL ; GET_HANDLE ( ) ; if ( ! is_principal_in_realm ( ldap_context , entry -> princ ) ) { st = EINVAL ; k5_setmsg ( context , st , _ ( "Principal<S2SV_blank>does<S2SV_blank>not<S2SV_blank>belong<S2SV_blank>to<S2SV_blank>the<S2SV_blank>default<S2SV_blank>realm" ) ) ; goto cleanup ; } if ( ( ( st = krb5_unparse_name ( context , entry -> princ , & user ) ) != 0 ) || ( ( st = krb5_ldap_unparse_principal_name ( user ) ) != 0 ) ) goto cleanup ; filtuser = ldap_filter_correct ( user ) ; if ( filtuser == NULL ) { st = ENOMEM ; goto cleanup ; } if ( entry -> mask & KADM5_PRINCIPAL ) optype = ADD_PRINCIPAL ; else optype = MODIFY_PRINCIPAL ; if ( ( ( st = krb5_get_princ_type ( context , entry , & kerberos_principal_object_type ) ) != 0 ) || ( ( st = krb5_get_userdn ( context , entry , & principal_dn ) ) != 0 ) ) goto cleanup ; if ( ( st = process_db_args ( context , db_args , & xargs , optype ) ) != 0 ) goto cleanup ; if ( entry -> mask & KADM5_LOAD ) { unsigned int tree = 0 ; int numlentries = 0 ; char * filter = NULL ; if ( asprintf ( & filter , FILTER "%s))" , filtuser ) < 0 ) { filter = NULL ; st = ENOMEM ; goto cleanup ; } if ( ( st = krb5_get_subtree_info ( ldap_context , & subtreelist , & ntrees ) ) != 0 ) goto cleanup ; found_entry = FALSE ; for ( tree = 0 ; found_entry == FALSE && tree < ntrees ; ++ tree ) { if ( principal_dn == NULL ) { LDAP_SEARCH_1 ( subtreelist [ tree ] , ldap_context -> lrparams -> search_scope , filter , principal_attributes , IGNORE_STATUS ) ; } else { LDAP_SEARCH_1 ( principal_dn , LDAP_SCOPE_BASE , filter , principal_attributes , IGNORE_STATUS ) ; } if ( st == LDAP_SUCCESS ) { numlentries = ldap_count_entries ( ld , result ) ; if ( numlentries > 1 ) { free ( filter ) ; st = EINVAL ; k5_setmsg ( context , st , _ ( "operation<S2SV_blank>can<S2SV_blank>not<S2SV_blank>continue,<S2SV_blank>more<S2SV_blank>than<S2SV_blank>one<S2SV_blank>" "entry<S2SV_blank>with<S2SV_blank>principal<S2SV_blank>name<S2SV_blank>\\"%s\\"<S2SV_blank>found" ) , user ) ; goto cleanup ; } else if ( numlentries == 1 ) { found_entry = TRUE ; if ( principal_dn == NULL ) { ent = ldap_first_entry ( ld , result ) ; if ( ent != NULL ) { if ( ( principal_dn = ldap_get_dn ( ld , ent ) ) == NULL ) { ldap_get_option ( ld , LDAP_OPT_RESULT_CODE , & st ) ; st = set_ldap_error ( context , st , 0 ) ; free ( filter ) ; goto cleanup ; } } } } } else if ( st != LDAP_NO_SUCH_OBJECT ) { st = set_ldap_error ( context , st , 0 ) ; free ( filter ) ; goto cleanup ; } ldap_msgfree ( result ) ; result = NULL ; } free ( filter ) ; if ( found_entry == FALSE && principal_dn != NULL ) { create_standalone = TRUE ; standalone_principal_dn = strdup ( principal_dn ) ; CHECK_NULL ( standalone_principal_dn ) ; } } if ( principal_dn == NULL && xargs . dn == NULL ) { if ( entry -> princ -> length == 2 && entry -> princ -> data [ 0 ] . length == strlen ( "krbtgt" ) && strncmp ( entry -> princ -> data [ 0 ] . data , "krbtgt" , entry -> princ -> data [ 0 ] . length ) == 0 ) { subtree = strdup ( ldap_context -> lrparams -> realmdn ) ; } else if ( xargs . containerdn ) { if ( ( st = checkattributevalue ( ld , xargs . containerdn , NULL , NULL , NULL ) ) != 0 ) { if ( st == KRB5_KDB_NOENTRY || st == KRB5_KDB_CONSTRAINT_VIOLATION ) { int ost = st ; st = EINVAL ; k5_wrapmsg ( context , ost , st , _ ( "\'%s\'<S2SV_blank>not<S2SV_blank>found" ) , xargs . containerdn ) ; } goto cleanup ; } subtree = strdup ( xargs . containerdn ) ; } else if ( ldap_context -> lrparams -> containerref && strlen ( ldap_context -> lrparams -> containerref ) != 0 ) { subtree = strdup ( ldap_context -> lrparams -> containerref ) ; } else { subtree = strdup ( ldap_context -> lrparams -> realmdn ) ; } CHECK_NULL ( subtree ) ; if ( asprintf ( & standalone_principal_dn , "krbprincipalname=%s,%s" , filtuser , subtree ) < 0 ) standalone_principal_dn = NULL ; CHECK_NULL ( standalone_principal_dn ) ; create_standalone = TRUE ; free ( subtree ) ; subtree = NULL ; } if ( xargs . dn_from_kbd == TRUE ) { <S2SV_StartBug> int dnlen = 0 , subtreelen = 0 ; <S2SV_EndBug> char * dn = NULL ; krb5_boolean outofsubtree = TRUE ; if ( xargs . dn != NULL ) { dn = xargs . dn ; } else if ( xargs . linkdn != NULL ) { dn = xargs . linkdn ; } else if ( standalone_principal_dn != NULL ) { dn = standalone_principal_dn ; } if ( subtreelist == NULL ) { st = krb5_get_subtree_info ( ldap_context , & subtreelist , & ntrees ) ; if ( st ) <S2SV_StartBug> goto cleanup ; <S2SV_EndBug> } for ( tre = 0 ; tre < ntrees ; ++ tre ) { if ( subtreelist [ tre ] == NULL || strlen ( subtreelist [ tre ] ) == 0 ) { outofsubtree = FALSE ; break ; } else { dnlen = strlen ( dn ) ; subtreelen = strlen ( subtreelist [ tre ] ) ; if ( ( dnlen >= subtreelen ) && ( strcasecmp ( ( dn + dnlen - subtreelen ) , subtreelist [ tre ] ) == 0 ) ) { outofsubtree = FALSE ; break ; } } } if ( outofsubtree == TRUE ) { st = EINVAL ; k5_setmsg ( context , st , _ ( "DN<S2SV_blank>is<S2SV_blank>out<S2SV_blank>of<S2SV_blank>the<S2SV_blank>realm<S2SV_blank>subtree" ) ) ; goto cleanup ; } if ( standalone_principal_dn == NULL ) { char * attributes [ ] = { "krbticketpolicyreference" , "krbprincipalname" , NULL } ; ldap_msgfree ( result ) ; result = NULL ; LDAP_SEARCH_1 ( dn , LDAP_SCOPE_BASE , 0 , attributes , IGNORE_STATUS ) ; if ( st == LDAP_SUCCESS ) { ent = ldap_first_entry ( ld , result ) ; if ( ent != NULL ) { if ( ( values = ldap_get_values ( ld , ent , "krbticketpolicyreference" ) ) != NULL ) { ldap_value_free ( values ) ; } if ( ( values = ldap_get_values ( ld , ent , "krbprincipalname" ) ) != NULL ) { krb_identity_exists = TRUE ; ldap_value_free ( values ) ; } } } else { st = set_ldap_error ( context , st , OP_SEARCH ) ; goto cleanup ; } } } if ( xargs . dn != NULL && krb_identity_exists == TRUE ) { st = EINVAL ; snprintf ( errbuf , sizeof ( errbuf ) , _ ( "ldap<S2SV_blank>object<S2SV_blank>is<S2SV_blank>already<S2SV_blank>kerberized" ) ) ; k5_setmsg ( context , st , "%s" , errbuf ) ; goto cleanup ; } if ( xargs . linkdn != NULL ) { if ( optype == MODIFY_PRINCIPAL && kerberos_principal_object_type != KDB_STANDALONE_PRINCIPAL_OBJECT ) { st = EINVAL ; snprintf ( errbuf , sizeof ( errbuf ) , _ ( "link<S2SV_blank>information<S2SV_blank>can<S2SV_blank>not<S2SV_blank>be<S2SV_blank>set/updated<S2SV_blank>as<S2SV_blank>the<S2SV_blank>" "kerberos<S2SV_blank>principal<S2SV_blank>belongs<S2SV_blank>to<S2SV_blank>an<S2SV_blank>ldap<S2SV_blank>object" ) ) ; k5_setmsg ( context , st , "%s" , errbuf ) ; goto cleanup ; } { char * * linkdns = NULL ; int j = 0 ; if ( ( st = krb5_get_linkdn ( context , entry , & linkdns ) ) != 0 ) { snprintf ( errbuf , sizeof ( errbuf ) , _ ( "Failed<S2SV_blank>getting<S2SV_blank>object<S2SV_blank>references" ) ) ; k5_setmsg ( context , st , "%s" , errbuf ) ; goto cleanup ; } if ( linkdns != NULL ) { st = EINVAL ; snprintf ( errbuf , sizeof ( errbuf ) , _ ( "kerberos<S2SV_blank>principal<S2SV_blank>is<S2SV_blank>already<S2SV_blank>linked<S2SV_blank>to<S2SV_blank>a<S2SV_blank>ldap<S2SV_blank>" "object" ) ) ; k5_setmsg ( context , st , "%s" , errbuf ) ; for ( j = 0 ; linkdns [ j ] != NULL ; ++ j ) free ( linkdns [ j ] ) ; free ( linkdns ) ; goto cleanup ; } } establish_links = TRUE ; } if ( entry -> mask & KADM5_LAST_SUCCESS ) { memset ( strval , 0 , sizeof ( strval ) ) ; if ( ( strval [ 0 ] = getstringtime ( entry -> last_success ) ) == NULL ) goto cleanup ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , "krbLastSuccessfulAuth" , LDAP_MOD_REPLACE , strval ) ) != 0 ) { free ( strval [ 0 ] ) ; goto cleanup ; } free ( strval [ 0 ] ) ; } if ( entry -> mask & KADM5_LAST_FAILED ) { memset ( strval , 0 , sizeof ( strval ) ) ; if ( ( strval [ 0 ] = getstringtime ( entry -> last_failed ) ) == NULL ) goto cleanup ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , "krbLastFailedAuth" , LDAP_MOD_REPLACE , strval ) ) != 0 ) { free ( strval [ 0 ] ) ; goto cleanup ; } free ( strval [ 0 ] ) ; } if ( entry -> mask & KADM5_FAIL_AUTH_COUNT ) { krb5_kvno fail_auth_count ; fail_auth_count = entry -> fail_auth_count ; if ( entry -> mask & KADM5_FAIL_AUTH_COUNT_INCREMENT ) fail_auth_count ++ ; st = krb5_add_int_mem_ldap_mod ( & mods , "krbLoginFailedCount" , LDAP_MOD_REPLACE , fail_auth_count ) ; if ( st != 0 ) goto cleanup ; } else if ( entry -> mask & KADM5_FAIL_AUTH_COUNT_INCREMENT ) { int attr_mask = 0 ; krb5_boolean has_fail_count ; st = krb5_get_attributes_mask ( context , entry , & attr_mask ) ; if ( st != 0 ) goto cleanup ; has_fail_count = ( ( attr_mask & KDB_FAIL_AUTH_COUNT_ATTR ) != 0 ) ; # ifdef LDAP_MOD_INCREMENT if ( ldap_server_handle -> server_info -> modify_increment && has_fail_count ) { st = krb5_add_int_mem_ldap_mod ( & mods , "krbLoginFailedCount" , LDAP_MOD_INCREMENT , 1 ) ; if ( st != 0 ) goto cleanup ; } else { # endif if ( has_fail_count ) { st = krb5_add_int_mem_ldap_mod ( & mods , "krbLoginFailedCount" , LDAP_MOD_DELETE , entry -> fail_auth_count ) ; if ( st != 0 ) goto cleanup ; } st = krb5_add_int_mem_ldap_mod ( & mods , "krbLoginFailedCount" , LDAP_MOD_ADD , entry -> fail_auth_count + 1 ) ; if ( st != 0 ) goto cleanup ; # ifdef LDAP_MOD_INCREMENT } # endif } else if ( optype == ADD_PRINCIPAL ) { st = krb5_add_int_mem_ldap_mod ( & mods , "krbLoginFailedCount" , LDAP_MOD_ADD , 0 ) ; } if ( entry -> mask & KADM5_MAX_LIFE ) { if ( ( st = krb5_add_int_mem_ldap_mod ( & mods , "krbmaxticketlife" , LDAP_MOD_REPLACE , entry -> max_life ) ) != 0 ) goto cleanup ; } if ( entry -> mask & KADM5_MAX_RLIFE ) { if ( ( st = krb5_add_int_mem_ldap_mod ( & mods , "krbmaxrenewableage" , LDAP_MOD_REPLACE , entry -> max_renewable_life ) ) != 0 ) goto cleanup ; } if ( entry -> mask & KADM5_ATTRIBUTES ) { if ( ( st = krb5_add_int_mem_ldap_mod ( & mods , "krbticketflags" , LDAP_MOD_REPLACE , entry -> attributes ) ) != 0 ) goto cleanup ; } if ( entry -> mask & KADM5_PRINCIPAL ) { memset ( strval , 0 , sizeof ( strval ) ) ; strval [ 0 ] = user ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , "krbprincipalname" , LDAP_MOD_REPLACE , strval ) ) != 0 ) goto cleanup ; } if ( entry -> mask & KADM5_PRINC_EXPIRE_TIME ) { memset ( strval , 0 , sizeof ( strval ) ) ; if ( ( strval [ 0 ] = getstringtime ( entry -> expiration ) ) == NULL ) goto cleanup ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , "krbprincipalexpiration" , LDAP_MOD_REPLACE , strval ) ) != 0 ) { free ( strval [ 0 ] ) ; goto cleanup ; } free ( strval [ 0 ] ) ; } if ( entry -> mask & KADM5_PW_EXPIRATION ) { memset ( strval , 0 , sizeof ( strval ) ) ; if ( ( strval [ 0 ] = getstringtime ( entry -> pw_expiration ) ) == NULL ) goto cleanup ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , "krbpasswordexpiration" , LDAP_MOD_REPLACE , strval ) ) != 0 ) { free ( strval [ 0 ] ) ; goto cleanup ; } free ( strval [ 0 ] ) ; } if ( entry -> mask & KADM5_POLICY || entry -> mask & KADM5_KEY_HIST ) { memset ( & princ_ent , 0 , sizeof ( princ_ent ) ) ; for ( tl_data = entry -> tl_data ; tl_data ; tl_data = tl_data -> tl_data_next ) { if ( tl_data -> tl_data_type == KRB5_TL_KADM_DATA ) { if ( ( st = krb5_lookup_tl_kadm_data ( tl_data , & princ_ent ) ) != 0 ) { goto cleanup ; } break ; } } } if ( entry -> mask & KADM5_POLICY ) { if ( princ_ent . aux_attributes & KADM5_POLICY ) { memset ( strval , 0 , sizeof ( strval ) ) ; if ( ( st = krb5_ldap_name_to_policydn ( context , princ_ent . policy , & polname ) ) != 0 ) goto cleanup ; strval [ 0 ] = polname ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , "krbpwdpolicyreference" , LDAP_MOD_REPLACE , strval ) ) != 0 ) goto cleanup ; } else { st = EINVAL ; k5_setmsg ( context , st , "Password<S2SV_blank>policy<S2SV_blank>value<S2SV_blank>null" ) ; goto cleanup ; } } else if ( entry -> mask & KADM5_LOAD && found_entry == TRUE ) { if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , "krbpwdpolicyreference" , LDAP_MOD_REPLACE , NULL ) ) != 0 ) goto cleanup ; } if ( entry -> mask & KADM5_POLICY_CLR ) { if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , "krbpwdpolicyreference" , LDAP_MOD_DELETE , NULL ) ) != 0 ) goto cleanup ; } if ( entry -> mask & KADM5_KEY_HIST ) { bersecretkey = krb5_encode_histkey ( & princ_ent ) ; if ( bersecretkey == NULL ) { st = ENOMEM ; goto cleanup ; } st = krb5_add_ber_mem_ldap_mod ( & mods , "krbpwdhistory" , LDAP_MOD_REPLACE | LDAP_MOD_BVALUES , bersecretkey ) ; if ( st != 0 ) goto cleanup ; free_berdata ( bersecretkey ) ; bersecretkey = NULL ; } if ( entry -> mask & KADM5_KEY_DATA || entry -> mask & KADM5_KVNO ) { krb5_kvno mkvno ; if ( ( st = krb5_dbe_lookup_mkvno ( context , entry , & mkvno ) ) != 0 ) goto cleanup ; bersecretkey = krb5_encode_krbsecretkey ( entry -> key_data , entry -> n_key_data , mkvno ) ; if ( bersecretkey == NULL ) { st = ENOMEM ; goto cleanup ; } if ( bersecretkey [ 0 ] != NULL || ! create_standalone ) { st = krb5_add_ber_mem_ldap_mod ( & mods , "krbprincipalkey" , LDAP_MOD_REPLACE | LDAP_MOD_BVALUES , bersecretkey ) ; if ( st != 0 ) goto cleanup ; } if ( ! ( entry -> mask & KADM5_PRINCIPAL ) ) { memset ( strval , 0 , sizeof ( strval ) ) ; if ( ( strval [ 0 ] = getstringtime ( entry -> pw_expiration ) ) == NULL ) goto cleanup ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , "krbpasswordexpiration" , LDAP_MOD_REPLACE , strval ) ) != 0 ) { free ( strval [ 0 ] ) ; goto cleanup ; } free ( strval [ 0 ] ) ; } { krb5_timestamp last_pw_changed ; if ( ( st = krb5_dbe_lookup_last_pwd_change ( context , entry , & last_pw_changed ) ) != 0 ) goto cleanup ; memset ( strval , 0 , sizeof ( strval ) ) ; if ( ( strval [ 0 ] = getstringtime ( last_pw_changed ) ) == NULL ) goto cleanup ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , "krbLastPwdChange" , LDAP_MOD_REPLACE , strval ) ) != 0 ) { free ( strval [ 0 ] ) ; goto cleanup ; } free ( strval [ 0 ] ) ; } } st = update_ldap_mod_auth_ind ( context , entry , & mods ) ; if ( st != 0 ) goto cleanup ; if ( entry -> tl_data != NULL ) { int count = 0 ; struct berval * * ber_tl_data = NULL ; krb5_tl_data * ptr ; krb5_timestamp unlock_time ; for ( ptr = entry -> tl_data ; ptr != NULL ; ptr = ptr -> tl_data_next ) { if ( ptr -> tl_data_type == KRB5_TL_LAST_PWD_CHANGE # ifdef SECURID || ptr -> tl_data_type == KRB5_TL_DB_ARGS # endif || ptr -> tl_data_type == KRB5_TL_KADM_DATA || ptr -> tl_data_type == KDB_TL_USER_INFO || ptr -> tl_data_type == KRB5_TL_CONSTRAINED_DELEGATION_ACL || ptr -> tl_data_type == KRB5_TL_LAST_ADMIN_UNLOCK ) continue ; count ++ ; } if ( count != 0 ) { int j ; ber_tl_data = ( struct berval * * ) calloc ( count + 1 , sizeof ( struct berval * ) ) ; if ( ber_tl_data == NULL ) { st = ENOMEM ; goto cleanup ; } for ( j = 0 , ptr = entry -> tl_data ; ptr != NULL ; ptr = ptr -> tl_data_next ) { if ( ptr -> tl_data_type == KRB5_TL_LAST_PWD_CHANGE # ifdef SECURID || ptr -> tl_data_type == KRB5_TL_DB_ARGS # endif || ptr -> tl_data_type == KRB5_TL_KADM_DATA || ptr -> tl_data_type == KDB_TL_USER_INFO || ptr -> tl_data_type == KRB5_TL_CONSTRAINED_DELEGATION_ACL || ptr -> tl_data_type == KRB5_TL_LAST_ADMIN_UNLOCK ) continue ; if ( ( st = tl_data2berval ( ptr , & ber_tl_data [ j ] ) ) != 0 ) break ; j ++ ; } if ( st == 0 ) { ber_tl_data [ count ] = NULL ; st = krb5_add_ber_mem_ldap_mod ( & mods , "krbExtraData" , LDAP_MOD_REPLACE | LDAP_MOD_BVALUES , ber_tl_data ) ; } free_berdata ( ber_tl_data ) ; if ( st != 0 ) goto cleanup ; } if ( ( st = krb5_dbe_lookup_last_admin_unlock ( context , entry , & unlock_time ) ) != 0 ) goto cleanup ; if ( unlock_time != 0 ) { memset ( strval , 0 , sizeof ( strval ) ) ; if ( ( strval [ 0 ] = getstringtime ( unlock_time ) ) == NULL ) goto cleanup ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , "krbLastAdminUnlock" , LDAP_MOD_REPLACE , strval ) ) != 0 ) { free ( strval [ 0 ] ) ; goto cleanup ; } free ( strval [ 0 ] ) ; } } if ( xargs . tktpolicydn != NULL ) { int tmask = 0 ; if ( strlen ( xargs . tktpolicydn ) != 0 ) { st = checkattributevalue ( ld , xargs . tktpolicydn , "objectclass" , policyclass , & tmask ) ; CHECK_CLASS_VALIDITY ( st , tmask , _ ( "ticket<S2SV_blank>policy<S2SV_blank>object<S2SV_blank>value:<S2SV_blank>" ) ) ; strval [ 0 ] = xargs . tktpolicydn ; strval [ 1 ] = NULL ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , "krbticketpolicyreference" , LDAP_MOD_REPLACE , strval ) ) != 0 ) goto cleanup ; } else { if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , "krbticketpolicyreference" , LDAP_MOD_DELETE , NULL ) ) != 0 ) goto cleanup ; } } if ( establish_links == TRUE ) { memset ( strval , 0 , sizeof ( strval ) ) ; strval [ 0 ] = xargs . linkdn ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , "krbObjectReferences" , LDAP_MOD_REPLACE , strval ) ) != 0 ) goto cleanup ; } if ( mods == NULL ) goto cleanup ; if ( create_standalone == TRUE ) { memset ( strval , 0 , sizeof ( strval ) ) ; strval [ 0 ] = "krbprincipal" ; strval [ 1 ] = "krbprincipalaux" ; strval [ 2 ] = "krbTicketPolicyAux" ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , "objectclass" , LDAP_MOD_ADD , strval ) ) != 0 ) goto cleanup ; st = ldap_add_ext_s ( ld , standalone_principal_dn , mods , NULL , NULL ) ; if ( st == LDAP_ALREADY_EXISTS && entry -> mask & KADM5_LOAD ) { st = ldap_delete_ext_s ( ld , standalone_principal_dn , NULL , NULL ) ; if ( st != LDAP_SUCCESS ) { snprintf ( errbuf , sizeof ( errbuf ) , _ ( "Principal<S2SV_blank>delete<S2SV_blank>failed<S2SV_blank>(trying<S2SV_blank>to<S2SV_blank>replace<S2SV_blank>" "entry):<S2SV_blank>%s" ) , ldap_err2string ( st ) ) ; st = translate_ldap_error ( st , OP_ADD ) ; k5_setmsg ( context , st , "%s" , errbuf ) ; goto cleanup ; } else { st = ldap_add_ext_s ( ld , standalone_principal_dn , mods , NULL , NULL ) ; } } if ( st != LDAP_SUCCESS ) { snprintf ( errbuf , sizeof ( errbuf ) , _ ( "Principal<S2SV_blank>add<S2SV_blank>failed:<S2SV_blank>%s" ) , ldap_err2string ( st ) ) ; st = translate_ldap_error ( st , OP_ADD ) ; k5_setmsg ( context , st , "%s" , errbuf ) ; goto cleanup ; } } else { { char * attrvalues [ ] = { "krbprincipalaux" , "krbTicketPolicyAux" , NULL } ; int p , q , r = 0 , amask = 0 ; if ( ( st = checkattributevalue ( ld , ( xargs . dn ) ? xargs . dn : principal_dn , "objectclass" , attrvalues , & amask ) ) != 0 ) goto cleanup ; memset ( strval , 0 , sizeof ( strval ) ) ; for ( p = 1 , q = 0 ; p <= 2 ; p <<= 1 , ++ q ) { if ( ( p & amask ) == 0 ) strval [ r ++ ] = attrvalues [ q ] ; } if ( r != 0 ) { if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , "objectclass" , LDAP_MOD_ADD , strval ) ) != 0 ) goto cleanup ; } } if ( xargs . dn != NULL ) st = ldap_modify_ext_s ( ld , xargs . dn , mods , NULL , NULL ) ; else st = ldap_modify_ext_s ( ld , principal_dn , mods , NULL , NULL ) ; if ( st != LDAP_SUCCESS ) { snprintf ( errbuf , sizeof ( errbuf ) , _ ( "User<S2SV_blank>modification<S2SV_blank>failed:<S2SV_blank>%s" ) , ldap_err2string ( st ) ) ; st = translate_ldap_error ( st , OP_MOD ) ; k5_setmsg ( context , st , "%s" , errbuf ) ; goto cleanup ; } if ( entry -> mask & KADM5_FAIL_AUTH_COUNT_INCREMENT ) entry -> fail_auth_count ++ ; } cleanup : if ( user ) free ( user ) ; if ( filtuser ) free ( filtuser ) ; free_xargs ( xargs ) ; if ( standalone_principal_dn ) free ( standalone_principal_dn ) ; if ( principal_dn ) free ( principal_dn ) ; if ( polname != NULL ) free ( polname ) ; for ( tre = 0 ; tre < ntrees ; tre ++ ) free ( subtreelist [ tre ] ) ; free ( subtreelist ) ; if ( subtree ) free ( subtree ) ; if ( bersecretkey ) { for ( l = 0 ; bersecretkey [ l ] ; ++ l ) { if ( bersecretkey [ l ] -> bv_val ) free ( bersecretkey [ l ] -> bv_val ) ; free ( bersecretkey [ l ] ) ; } free ( bersecretkey ) ; } if ( keys ) free ( keys ) ; ldap_mods_free ( mods , 1 ) ; ldap_osa_free_princ_ent ( & princ_ent ) ; ldap_msgfree ( result ) ; krb5_ldap_put_handle_to_pool ( ldap_context , ldap_server_handle ) ; return ( st ) ; }
CWE-787 static int kwajd_read_headers ( struct mspack_system * sys , struct mspack_file * fh , struct mskwajd_header * hdr ) { unsigned char buf [ 16 ] ; int i ; if ( sys -> read ( fh , & buf [ 0 ] , kwajh_SIZEOF ) != kwajh_SIZEOF ) { return MSPACK_ERR_READ ; } if ( ( ( unsigned int ) EndGetI32 ( & buf [ kwajh_Signature1 ] ) != 0x4A41574B ) || ( ( unsigned int ) EndGetI32 ( & buf [ kwajh_Signature2 ] ) != 0xD127F088 ) ) { return MSPACK_ERR_SIGNATURE ; } hdr -> comp_type = EndGetI16 ( & buf [ kwajh_CompMethod ] ) ; hdr -> data_offset = EndGetI16 ( & buf [ kwajh_DataOffset ] ) ; hdr -> headers = EndGetI16 ( & buf [ kwajh_Flags ] ) ; hdr -> length = 0 ; hdr -> filename = NULL ; hdr -> extra = NULL ; hdr -> extra_length = 0 ; if ( hdr -> headers & MSKWAJ_HDR_HASLENGTH ) { if ( sys -> read ( fh , & buf [ 0 ] , 4 ) != 4 ) return MSPACK_ERR_READ ; hdr -> length = EndGetI32 ( & buf [ 0 ] ) ; } if ( hdr -> headers & MSKWAJ_HDR_HASUNKNOWN1 ) { if ( sys -> read ( fh , & buf [ 0 ] , 2 ) != 2 ) return MSPACK_ERR_READ ; } if ( hdr -> headers & MSKWAJ_HDR_HASUNKNOWN2 ) { if ( sys -> read ( fh , & buf [ 0 ] , 2 ) != 2 ) return MSPACK_ERR_READ ; i = EndGetI16 ( & buf [ 0 ] ) ; if ( sys -> seek ( fh , ( off_t ) i , MSPACK_SYS_SEEK_CUR ) ) return MSPACK_ERR_SEEK ; } if ( hdr -> headers & ( MSKWAJ_HDR_HASFILENAME | MSKWAJ_HDR_HASFILEEXT ) ) { <S2SV_StartBug> off_t pos = sys -> tell ( fh ) ; <S2SV_EndBug> char * fn = ( char * ) sys -> alloc ( sys , ( size_t ) 13 ) ; <S2SV_StartBug> if ( ! fn ) return MSPACK_ERR_NOMEMORY ; <S2SV_EndBug> <S2SV_StartBug> hdr -> filename = fn ; <S2SV_EndBug> if ( hdr -> headers & MSKWAJ_HDR_HASFILENAME ) { <S2SV_StartBug> if ( sys -> read ( fh , & buf [ 0 ] , 9 ) != 9 ) return MSPACK_ERR_READ ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < 9 ; i ++ , fn ++ ) if ( ! ( * fn = buf [ i ] ) ) break ; <S2SV_EndBug> <S2SV_StartBug> pos += ( i < 9 ) ? i + 1 : 9 ; <S2SV_EndBug> if ( sys -> seek ( fh , pos , MSPACK_SYS_SEEK_START ) ) <S2SV_StartBug> return MSPACK_ERR_SEEK ; <S2SV_EndBug> } if ( hdr -> headers & MSKWAJ_HDR_HASFILEEXT ) { * fn ++ = '.' ; <S2SV_StartBug> if ( sys -> read ( fh , & buf [ 0 ] , 4 ) != 4 ) return MSPACK_ERR_READ ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < 4 ; i ++ , fn ++ ) if ( ! ( * fn = buf [ i ] ) ) break ; <S2SV_EndBug> <S2SV_StartBug> pos += ( i < 4 ) ? i + 1 : 4 ; <S2SV_EndBug> if ( sys -> seek ( fh , pos , MSPACK_SYS_SEEK_START ) ) <S2SV_StartBug> return MSPACK_ERR_SEEK ; <S2SV_EndBug> } * fn = '\\0' ; } if ( hdr -> headers & MSKWAJ_HDR_HASEXTRATEXT ) { if ( sys -> read ( fh , & buf [ 0 ] , 2 ) != 2 ) return MSPACK_ERR_READ ; i = EndGetI16 ( & buf [ 0 ] ) ; hdr -> extra = ( char * ) sys -> alloc ( sys , ( size_t ) i + 1 ) ; if ( ! hdr -> extra ) return MSPACK_ERR_NOMEMORY ; if ( sys -> read ( fh , hdr -> extra , i ) != i ) return MSPACK_ERR_READ ; hdr -> extra [ i ] = '\\0' ; hdr -> extra_length = i ; } return MSPACK_ERR_OK ; }
CWE-119 static int chmd_read_headers ( struct mspack_system * sys , struct mspack_file * fh , struct mschmd_header * chm , int entire ) { unsigned int section , name_len , x , errors , num_chunks ; unsigned char buf [ 0x54 ] , * chunk = NULL , * name , * p , * end ; struct mschmd_file * fi , * link = NULL ; off_t offset , length ; int num_entries ; chm -> files = NULL ; chm -> sysfiles = NULL ; chm -> chunk_cache = NULL ; chm -> sec0 . base . chm = chm ; chm -> sec0 . base . id = 0 ; chm -> sec1 . base . chm = chm ; chm -> sec1 . base . id = 1 ; chm -> sec1 . content = NULL ; chm -> sec1 . control = NULL ; chm -> sec1 . spaninfo = NULL ; chm -> sec1 . rtable = NULL ; if ( sys -> read ( fh , & buf [ 0 ] , chmhead_SIZEOF ) != chmhead_SIZEOF ) { return MSPACK_ERR_READ ; } if ( EndGetI32 ( & buf [ chmhead_Signature ] ) != 0x46535449 ) { return MSPACK_ERR_SIGNATURE ; } if ( memcmp ( & buf [ chmhead_GUID1 ] , & guids [ 0 ] , 32L ) != 0 ) { D ( ( "incorrect<S2SV_blank>GUIDs" ) ) return MSPACK_ERR_SIGNATURE ; } chm -> version = EndGetI32 ( & buf [ chmhead_Version ] ) ; chm -> timestamp = EndGetM32 ( & buf [ chmhead_Timestamp ] ) ; chm -> language = EndGetI32 ( & buf [ chmhead_LanguageID ] ) ; if ( chm -> version > 3 ) { sys -> message ( fh , "WARNING;<S2SV_blank>CHM<S2SV_blank>version<S2SV_blank>><S2SV_blank>3" ) ; } if ( sys -> read ( fh , & buf [ 0 ] , chmhst3_SIZEOF ) != chmhst3_SIZEOF ) { return MSPACK_ERR_READ ; } if ( read_off64 ( & offset , & buf [ chmhst_OffsetHS0 ] , sys , fh ) || read_off64 ( & chm -> dir_offset , & buf [ chmhst_OffsetHS1 ] , sys , fh ) || read_off64 ( & chm -> sec0 . offset , & buf [ chmhst3_OffsetCS0 ] , sys , fh ) ) { return MSPACK_ERR_DATAFORMAT ; } if ( sys -> seek ( fh , offset , MSPACK_SYS_SEEK_START ) ) { return MSPACK_ERR_SEEK ; } if ( sys -> read ( fh , & buf [ 0 ] , chmhs0_SIZEOF ) != chmhs0_SIZEOF ) { return MSPACK_ERR_READ ; } if ( read_off64 ( & chm -> length , & buf [ chmhs0_FileLen ] , sys , fh ) ) { return MSPACK_ERR_DATAFORMAT ; } if ( sys -> seek ( fh , chm -> dir_offset , MSPACK_SYS_SEEK_START ) ) { return MSPACK_ERR_SEEK ; } if ( sys -> read ( fh , & buf [ 0 ] , chmhs1_SIZEOF ) != chmhs1_SIZEOF ) { return MSPACK_ERR_READ ; } chm -> dir_offset = sys -> tell ( fh ) ; chm -> chunk_size = EndGetI32 ( & buf [ chmhs1_ChunkSize ] ) ; chm -> density = EndGetI32 ( & buf [ chmhs1_Density ] ) ; chm -> depth = EndGetI32 ( & buf [ chmhs1_Depth ] ) ; chm -> index_root = EndGetI32 ( & buf [ chmhs1_IndexRoot ] ) ; chm -> num_chunks = EndGetI32 ( & buf [ chmhs1_NumChunks ] ) ; chm -> first_pmgl = EndGetI32 ( & buf [ chmhs1_FirstPMGL ] ) ; chm -> last_pmgl = EndGetI32 ( & buf [ chmhs1_LastPMGL ] ) ; if ( chm -> version < 3 ) { chm -> sec0 . offset = chm -> dir_offset + ( chm -> chunk_size * chm -> num_chunks ) ; } if ( chm -> sec0 . offset > chm -> length ) { D ( ( "content<S2SV_blank>section<S2SV_blank>begins<S2SV_blank>after<S2SV_blank>file<S2SV_blank>has<S2SV_blank>ended" ) ) return MSPACK_ERR_DATAFORMAT ; } if ( chm -> chunk_size < ( pmgl_Entries + 2 ) ) { D ( ( "chunk<S2SV_blank>size<S2SV_blank>not<S2SV_blank>large<S2SV_blank>enough" ) ) return MSPACK_ERR_DATAFORMAT ; } if ( chm -> num_chunks == 0 ) { D ( ( "no<S2SV_blank>chunks" ) ) return MSPACK_ERR_DATAFORMAT ; } if ( chm -> num_chunks > 100000 ) { D ( ( "more<S2SV_blank>than<S2SV_blank>100,000<S2SV_blank>chunks" ) ) return MSPACK_ERR_DATAFORMAT ; } if ( ( off_t ) chm -> chunk_size * ( off_t ) chm -> num_chunks > chm -> length ) { D ( ( "chunks<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>entire<S2SV_blank>file" ) ) return MSPACK_ERR_DATAFORMAT ; } if ( ( chm -> chunk_size & ( chm -> chunk_size - 1 ) ) != 0 ) { sys -> message ( fh , "WARNING;<S2SV_blank>chunk<S2SV_blank>size<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>power<S2SV_blank>of<S2SV_blank>two" ) ; } if ( chm -> first_pmgl != 0 ) { sys -> message ( fh , "WARNING;<S2SV_blank>first<S2SV_blank>PMGL<S2SV_blank>chunk<S2SV_blank>is<S2SV_blank>not<S2SV_blank>zero" ) ; } if ( chm -> first_pmgl > chm -> last_pmgl ) { D ( ( "first<S2SV_blank>pmgl<S2SV_blank>chunk<S2SV_blank>is<S2SV_blank>after<S2SV_blank>last<S2SV_blank>pmgl<S2SV_blank>chunk" ) ) return MSPACK_ERR_DATAFORMAT ; } if ( chm -> index_root != 0xFFFFFFFF && chm -> index_root >= chm -> num_chunks ) { D ( ( "index_root<S2SV_blank>outside<S2SV_blank>valid<S2SV_blank>range" ) ) return MSPACK_ERR_DATAFORMAT ; } if ( ! entire ) { return MSPACK_ERR_OK ; } if ( ( x = chm -> first_pmgl ) != 0 ) { if ( sys -> seek ( fh , ( off_t ) ( x * chm -> chunk_size ) , MSPACK_SYS_SEEK_CUR ) ) { return MSPACK_ERR_SEEK ; } } num_chunks = chm -> last_pmgl - x + 1 ; if ( ! ( chunk = ( unsigned char * ) sys -> alloc ( sys , ( size_t ) chm -> chunk_size ) ) ) { return MSPACK_ERR_NOMEMORY ; } errors = 0 ; while ( num_chunks -- ) { if ( sys -> read ( fh , chunk , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { sys -> free ( chunk ) ; return MSPACK_ERR_READ ; } if ( EndGetI32 ( & chunk [ pmgl_Signature ] ) != 0x4C474D50 ) continue ; if ( EndGetI32 ( & chunk [ pmgl_QuickRefSize ] ) < 2 ) { sys -> message ( fh , "WARNING;<S2SV_blank>PMGL<S2SV_blank>quickref<S2SV_blank>area<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small" ) ; } if ( EndGetI32 ( & chunk [ pmgl_QuickRefSize ] ) > ( ( int ) chm -> chunk_size - pmgl_Entries ) ) { sys -> message ( fh , "WARNING;<S2SV_blank>PMGL<S2SV_blank>quickref<S2SV_blank>area<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large" ) ; } p = & chunk [ pmgl_Entries ] ; end = & chunk [ chm -> chunk_size - 2 ] ; num_entries = EndGetI16 ( end ) ; while ( num_entries -- ) { READ_ENCINT ( name_len ) ; if ( name_len > ( unsigned int ) ( end - p ) ) goto chunk_end ; name = p ; p += name_len ; READ_ENCINT ( section ) ; READ_ENCINT ( offset ) ; READ_ENCINT ( length ) ; if ( name_len < 2 || ! name [ 0 ] || ! name [ 1 ] ) continue ; if ( ( offset == 0 ) && ( length == 0 ) ) { if ( ( name_len > 0 ) && ( name [ name_len - 1 ] == '/' ) ) continue ; } if ( section > 1 ) { sys -> message ( fh , "invalid<S2SV_blank>section<S2SV_blank>number<S2SV_blank>\'%u\'." , section ) ; continue ; } if ( ! ( fi = ( struct mschmd_file * ) sys -> alloc ( sys , sizeof ( struct mschmd_file ) + name_len + 1 ) ) ) { sys -> free ( chunk ) ; return MSPACK_ERR_NOMEMORY ; } fi -> next = NULL ; fi -> filename = ( char * ) & fi [ 1 ] ; fi -> section = ( ( section == 0 ) ? ( struct mschmd_section * ) ( & chm -> sec0 ) : ( struct mschmd_section * ) ( & chm -> sec1 ) ) ; fi -> offset = offset ; fi -> length = length ; sys -> copy ( name , fi -> filename , ( size_t ) name_len ) ; fi -> filename [ name_len ] = '\\0' ; if ( name [ 0 ] == ':' && name [ 1 ] == ':' ) { <S2SV_StartBug> if ( memcmp ( & name [ 2 ] , & content_name [ 2 ] , 31L ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> if ( memcmp ( & name [ 33 ] , & content_name [ 33 ] , 8L ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> chm -> sec1 . content = fi ; <S2SV_EndBug> } <S2SV_StartBug> else if ( memcmp ( & name [ 33 ] , & control_name [ 33 ] , 11L ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> chm -> sec1 . control = fi ; <S2SV_EndBug> } <S2SV_StartBug> else if ( memcmp ( & name [ 33 ] , & spaninfo_name [ 33 ] , 8L ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> chm -> sec1 . spaninfo = fi ; <S2SV_EndBug> } else if ( memcmp ( & name [ 33 ] , & rtable_name [ 33 ] , 72L ) == 0 ) { chm -> sec1 . rtable = fi ; <S2SV_StartBug> } <S2SV_EndBug> } fi -> next = chm -> sysfiles ; chm -> sysfiles = fi ; } else { if ( link ) link -> next = fi ; else chm -> files = fi ; link = fi ; } } chunk_end : if ( num_entries >= 0 ) { D ( ( "chunk<S2SV_blank>ended<S2SV_blank>before<S2SV_blank>all<S2SV_blank>entries<S2SV_blank>could<S2SV_blank>be<S2SV_blank>read" ) ) errors ++ ; } } sys -> free ( chunk ) ; return ( errors > 0 ) ? MSPACK_ERR_DATAFORMAT : MSPACK_ERR_OK ; }
CWE-20 static int chmd_read_headers ( struct mspack_system * sys , struct mspack_file * fh , struct mschmd_header * chm , int entire ) { unsigned int section , name_len , x , errors , num_chunks ; unsigned char buf [ 0x54 ] , * chunk = NULL , * name , * p , * end ; struct mschmd_file * fi , * link = NULL ; off_t offset , length ; int num_entries ; chm -> files = NULL ; chm -> sysfiles = NULL ; chm -> chunk_cache = NULL ; chm -> sec0 . base . chm = chm ; chm -> sec0 . base . id = 0 ; chm -> sec1 . base . chm = chm ; chm -> sec1 . base . id = 1 ; chm -> sec1 . content = NULL ; chm -> sec1 . control = NULL ; chm -> sec1 . spaninfo = NULL ; chm -> sec1 . rtable = NULL ; if ( sys -> read ( fh , & buf [ 0 ] , chmhead_SIZEOF ) != chmhead_SIZEOF ) { return MSPACK_ERR_READ ; } if ( EndGetI32 ( & buf [ chmhead_Signature ] ) != 0x46535449 ) { return MSPACK_ERR_SIGNATURE ; } if ( mspack_memcmp ( & buf [ chmhead_GUID1 ] , & guids [ 0 ] , 32L ) != 0 ) { D ( ( "incorrect<S2SV_blank>GUIDs" ) ) return MSPACK_ERR_SIGNATURE ; } chm -> version = EndGetI32 ( & buf [ chmhead_Version ] ) ; chm -> timestamp = EndGetM32 ( & buf [ chmhead_Timestamp ] ) ; chm -> language = EndGetI32 ( & buf [ chmhead_LanguageID ] ) ; if ( chm -> version > 3 ) { sys -> message ( fh , "WARNING;<S2SV_blank>CHM<S2SV_blank>version<S2SV_blank>><S2SV_blank>3" ) ; } if ( sys -> read ( fh , & buf [ 0 ] , chmhst3_SIZEOF ) != chmhst3_SIZEOF ) { return MSPACK_ERR_READ ; } if ( read_off64 ( & offset , & buf [ chmhst_OffsetHS0 ] , sys , fh ) || read_off64 ( & chm -> dir_offset , & buf [ chmhst_OffsetHS1 ] , sys , fh ) || read_off64 ( & chm -> sec0 . offset , & buf [ chmhst3_OffsetCS0 ] , sys , fh ) ) { return MSPACK_ERR_DATAFORMAT ; } if ( sys -> seek ( fh , offset , MSPACK_SYS_SEEK_START ) ) { return MSPACK_ERR_SEEK ; } if ( sys -> read ( fh , & buf [ 0 ] , chmhs0_SIZEOF ) != chmhs0_SIZEOF ) { return MSPACK_ERR_READ ; } if ( read_off64 ( & chm -> length , & buf [ chmhs0_FileLen ] , sys , fh ) ) { return MSPACK_ERR_DATAFORMAT ; } if ( sys -> seek ( fh , chm -> dir_offset , MSPACK_SYS_SEEK_START ) ) { return MSPACK_ERR_SEEK ; } if ( sys -> read ( fh , & buf [ 0 ] , chmhs1_SIZEOF ) != chmhs1_SIZEOF ) { return MSPACK_ERR_READ ; } chm -> dir_offset = sys -> tell ( fh ) ; chm -> chunk_size = EndGetI32 ( & buf [ chmhs1_ChunkSize ] ) ; chm -> density = EndGetI32 ( & buf [ chmhs1_Density ] ) ; chm -> depth = EndGetI32 ( & buf [ chmhs1_Depth ] ) ; chm -> index_root = EndGetI32 ( & buf [ chmhs1_IndexRoot ] ) ; chm -> num_chunks = EndGetI32 ( & buf [ chmhs1_NumChunks ] ) ; chm -> first_pmgl = EndGetI32 ( & buf [ chmhs1_FirstPMGL ] ) ; chm -> last_pmgl = EndGetI32 ( & buf [ chmhs1_LastPMGL ] ) ; if ( chm -> version < 3 ) { chm -> sec0 . offset = chm -> dir_offset + ( chm -> chunk_size * chm -> num_chunks ) ; } if ( chm -> sec0 . offset > chm -> length ) { D ( ( "content<S2SV_blank>section<S2SV_blank>begins<S2SV_blank>after<S2SV_blank>file<S2SV_blank>has<S2SV_blank>ended" ) ) return MSPACK_ERR_DATAFORMAT ; } if ( chm -> chunk_size < ( pmgl_Entries + 2 ) ) { D ( ( "chunk<S2SV_blank>size<S2SV_blank>not<S2SV_blank>large<S2SV_blank>enough" ) ) return MSPACK_ERR_DATAFORMAT ; } if ( chm -> num_chunks == 0 ) { D ( ( "no<S2SV_blank>chunks" ) ) return MSPACK_ERR_DATAFORMAT ; } if ( chm -> num_chunks > 100000 ) { D ( ( "more<S2SV_blank>than<S2SV_blank>100,000<S2SV_blank>chunks" ) ) return MSPACK_ERR_DATAFORMAT ; } if ( ( off_t ) chm -> chunk_size * ( off_t ) chm -> num_chunks > chm -> length ) { D ( ( "chunks<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>entire<S2SV_blank>file" ) ) return MSPACK_ERR_DATAFORMAT ; } if ( ( chm -> chunk_size & ( chm -> chunk_size - 1 ) ) != 0 ) { sys -> message ( fh , "WARNING;<S2SV_blank>chunk<S2SV_blank>size<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>power<S2SV_blank>of<S2SV_blank>two" ) ; } if ( chm -> first_pmgl != 0 ) { sys -> message ( fh , "WARNING;<S2SV_blank>first<S2SV_blank>PMGL<S2SV_blank>chunk<S2SV_blank>is<S2SV_blank>not<S2SV_blank>zero" ) ; } if ( chm -> first_pmgl > chm -> last_pmgl ) { D ( ( "first<S2SV_blank>pmgl<S2SV_blank>chunk<S2SV_blank>is<S2SV_blank>after<S2SV_blank>last<S2SV_blank>pmgl<S2SV_blank>chunk" ) ) return MSPACK_ERR_DATAFORMAT ; } <S2SV_StartBug> if ( chm -> index_root != 0xFFFFFFFF && chm -> index_root > chm -> num_chunks ) { <S2SV_EndBug> D ( ( "index_root<S2SV_blank>outside<S2SV_blank>valid<S2SV_blank>range" ) ) return MSPACK_ERR_DATAFORMAT ; } if ( ! entire ) { return MSPACK_ERR_OK ; } if ( ( x = chm -> first_pmgl ) != 0 ) { if ( sys -> seek ( fh , ( off_t ) ( x * chm -> chunk_size ) , MSPACK_SYS_SEEK_CUR ) ) { return MSPACK_ERR_SEEK ; } } num_chunks = chm -> last_pmgl - x + 1 ; if ( ! ( chunk = ( unsigned char * ) sys -> alloc ( sys , ( size_t ) chm -> chunk_size ) ) ) { return MSPACK_ERR_NOMEMORY ; } errors = 0 ; while ( num_chunks -- ) { if ( sys -> read ( fh , chunk , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { sys -> free ( chunk ) ; return MSPACK_ERR_READ ; } if ( EndGetI32 ( & chunk [ pmgl_Signature ] ) != 0x4C474D50 ) continue ; if ( EndGetI32 ( & chunk [ pmgl_QuickRefSize ] ) < 2 ) { sys -> message ( fh , "WARNING;<S2SV_blank>PMGL<S2SV_blank>quickref<S2SV_blank>area<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small" ) ; } if ( EndGetI32 ( & chunk [ pmgl_QuickRefSize ] ) > ( ( int ) chm -> chunk_size - pmgl_Entries ) ) { sys -> message ( fh , "WARNING;<S2SV_blank>PMGL<S2SV_blank>quickref<S2SV_blank>area<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large" ) ; } p = & chunk [ pmgl_Entries ] ; end = & chunk [ chm -> chunk_size - 2 ] ; num_entries = EndGetI16 ( end ) ; while ( num_entries -- ) { READ_ENCINT ( name_len ) ; if ( name_len > ( unsigned int ) ( end - p ) ) goto chunk_end ; <S2SV_StartBug> name = p ; p += name_len ; <S2SV_EndBug> READ_ENCINT ( section ) ; READ_ENCINT ( offset ) ; READ_ENCINT ( length ) ; if ( ( offset == 0 ) && ( length == 0 ) ) { if ( ( name_len > 0 ) && ( name [ name_len - 1 ] == '/' ) ) continue ; } if ( section > 1 ) { sys -> message ( fh , "invalid<S2SV_blank>section<S2SV_blank>number<S2SV_blank>\'%u\'." , section ) ; continue ; } if ( ! ( fi = ( struct mschmd_file * ) sys -> alloc ( sys , sizeof ( struct mschmd_file ) + name_len + 1 ) ) ) { sys -> free ( chunk ) ; return MSPACK_ERR_NOMEMORY ; } fi -> next = NULL ; fi -> filename = ( char * ) & fi [ 1 ] ; fi -> section = ( ( section == 0 ) ? ( struct mschmd_section * ) ( & chm -> sec0 ) : ( struct mschmd_section * ) ( & chm -> sec1 ) ) ; fi -> offset = offset ; fi -> length = length ; sys -> copy ( name , fi -> filename , ( size_t ) name_len ) ; fi -> filename [ name_len ] = '\\0' ; if ( name [ 0 ] == ':' && name [ 1 ] == ':' ) { if ( mspack_memcmp ( & name [ 2 ] , & content_name [ 2 ] , 31L ) == 0 ) { if ( mspack_memcmp ( & name [ 33 ] , & content_name [ 33 ] , 8L ) == 0 ) { chm -> sec1 . content = fi ; } else if ( mspack_memcmp ( & name [ 33 ] , & control_name [ 33 ] , 11L ) == 0 ) { chm -> sec1 . control = fi ; } else if ( mspack_memcmp ( & name [ 33 ] , & spaninfo_name [ 33 ] , 8L ) == 0 ) { chm -> sec1 . spaninfo = fi ; } else if ( mspack_memcmp ( & name [ 33 ] , & rtable_name [ 33 ] , 72L ) == 0 ) { chm -> sec1 . rtable = fi ; } } fi -> next = chm -> sysfiles ; chm -> sysfiles = fi ; } else { if ( link ) link -> next = fi ; else chm -> files = fi ; link = fi ; } } chunk_end : if ( num_entries >= 0 ) { D ( ( "chunk<S2SV_blank>ended<S2SV_blank>before<S2SV_blank>all<S2SV_blank>entries<S2SV_blank>could<S2SV_blank>be<S2SV_blank>read" ) ) errors ++ ; } } sys -> free ( chunk ) ; return ( errors > 0 ) ? MSPACK_ERR_DATAFORMAT : MSPACK_ERR_OK ; }
CWE-20 static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { struct mspack_system * sys = self -> system ; unsigned char * buf ; <S2SV_StartBug> if ( chunk_num > chm -> num_chunks ) return NULL ; <S2SV_EndBug> if ( ! chm -> chunk_cache ) { size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } memset ( chm -> chunk_cache , 0 , size ) ; } if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { self -> error = MSPACK_ERR_READ ; sys -> free ( buf ) ; return NULL ; } if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } return chm -> chunk_cache [ chunk_num ] = buf ; }
CWE-22 <S2SV_StartBug> static char * create_output_name ( unsigned char * fname , unsigned char * dir , <S2SV_EndBug> int lower , int isunix , int utf8 ) { unsigned char * p , * name , c , * fe , sep , slash ; unsigned int x ; sep = ( isunix ) ? '/' : '\\\\' ; slash = ( isunix ) ? '\\\\' : '/' ; x = strlen ( ( char * ) fname ) ; <S2SV_StartBug> if ( utf8 ) x *= 3 ; <S2SV_EndBug> if ( dir ) x += strlen ( ( char * ) dir ) ; if ( ! ( name = ( unsigned char * ) malloc ( x + 2 ) ) ) { <S2SV_StartBug> fprintf ( stderr , "out<S2SV_blank>of<S2SV_blank>memory!\\n" ) ; <S2SV_EndBug> return NULL ; } * name = '\\0' ; if ( dir ) { strcpy ( ( char * ) name , ( char * ) dir ) ; strcat ( ( char * ) name , "/" ) ; } <S2SV_StartBug> while ( * fname == sep ) fname ++ ; <S2SV_EndBug> <S2SV_StartBug> p = & name [ strlen ( ( char * ) name ) ] ; <S2SV_EndBug> fe = & fname [ strlen ( ( char * ) fname ) ] ; if ( utf8 ) { do { <S2SV_StartBug> if ( fname >= fe ) { <S2SV_EndBug> free ( name ) ; return NULL ; } if ( ( c = * fname ++ ) < 0x80 ) x = c ; else { if ( ( c >= 0xC0 ) && ( c < 0xE0 ) ) { <S2SV_StartBug> x = ( c & 0x1F ) << 6 ; <S2SV_EndBug> x |= * fname ++ & 0x3F ; } else if ( ( c >= 0xE0 ) && ( c < 0xF0 ) ) { x = ( c & 0xF ) << 12 ; x |= ( * fname ++ & 0x3F ) << 6 ; x |= * fname ++ & 0x3F ; } else x = '?' ; } if ( x == sep ) x = '/' ; else if ( x == slash ) x = '\\\\' ; else if ( lower ) x = ( unsigned int ) tolower ( ( int ) x ) ; if ( x < 0x80 ) { * p ++ = ( unsigned char ) x ; } else if ( x < 0x800 ) { * p ++ = 0xC0 | ( x >> 6 ) ; * p ++ = 0x80 | ( x & 0x3F ) ; } else { * p ++ = 0xE0 | ( x >> 12 ) ; * p ++ = 0x80 | ( ( x >> 6 ) & 0x3F ) ; * p ++ = 0x80 | ( x & 0x3F ) ; } <S2SV_StartBug> } while ( x ) ; <S2SV_EndBug> } else { do { c = * fname ++ ; if ( c == sep ) c = '/' ; else if ( c == slash ) c = '\\\\' ; else if ( lower ) c = ( unsigned char ) tolower ( ( int ) c ) ; } while ( ( * p ++ = c ) ) ; } return ( char * ) name ; }
CWE-22 int main ( int argc , char * argv [ ] ) { struct mschm_decompressor * chmd ; struct mschmd_header * chm ; struct mschmd_file * file , * * f ; unsigned int numf , i ; setbuf ( stdout , NULL ) ; setbuf ( stderr , NULL ) ; user_umask = umask ( 0 ) ; umask ( user_umask ) ; MSPACK_SYS_SELFTEST ( i ) ; if ( i ) return 0 ; if ( ( chmd = mspack_create_chm_decompressor ( NULL ) ) ) { for ( argv ++ ; * argv ; argv ++ ) { printf ( "%s\\n" , * argv ) ; if ( ( chm = chmd -> open ( chmd , * argv ) ) ) { for ( numf = 0 , file = chm -> files ; file ; file = file -> next ) numf ++ ; if ( ( f = ( struct mschmd_file * * ) calloc ( numf , sizeof ( struct mschmd_file * ) ) ) ) { for ( i = 0 , file = chm -> files ; file ; file = file -> next ) f [ i ++ ] = file ; qsort ( f , numf , sizeof ( struct mschmd_file * ) , & sortfunc ) ; for ( i = 0 ; i < numf ; i ++ ) { <S2SV_StartBug> char * outname = create_output_name ( ( unsigned char * ) f [ i ] -> filename , NULL , 0 , 1 , 0 ) ; <S2SV_EndBug> printf ( "Extracting<S2SV_blank>%s\\n" , outname ) ; ensure_filepath ( outname ) ; if ( chmd -> extract ( chmd , f [ i ] , outname ) ) { printf ( "%s:<S2SV_blank>extract<S2SV_blank>error<S2SV_blank>on<S2SV_blank>\\"%s\\":<S2SV_blank>%s\\n" , * argv , f [ i ] -> filename , ERROR ( chmd ) ) ; } free ( outname ) ; } free ( f ) ; } chmd -> close ( chmd , chm ) ; } else { printf ( "%s:<S2SV_blank>can\'t<S2SV_blank>open<S2SV_blank>--<S2SV_blank>%s\\n" , * argv , ERROR ( chmd ) ) ; } } mspack_destroy_chm_decompressor ( chmd ) ; } return 0 ; }
CWE-476 static int chmd_read_headers ( struct mspack_system * sys , struct mspack_file * fh , struct mschmd_header * chm , int entire ) { unsigned int section , name_len , x , errors , num_chunks ; unsigned char buf [ 0x54 ] , * chunk = NULL , * name , * p , * end ; struct mschmd_file * fi , * link = NULL ; off_t offset , length ; int num_entries ; chm -> files = NULL ; chm -> sysfiles = NULL ; chm -> chunk_cache = NULL ; chm -> sec0 . base . chm = chm ; chm -> sec0 . base . id = 0 ; chm -> sec1 . base . chm = chm ; chm -> sec1 . base . id = 1 ; chm -> sec1 . content = NULL ; chm -> sec1 . control = NULL ; chm -> sec1 . spaninfo = NULL ; chm -> sec1 . rtable = NULL ; if ( sys -> read ( fh , & buf [ 0 ] , chmhead_SIZEOF ) != chmhead_SIZEOF ) { return MSPACK_ERR_READ ; } if ( EndGetI32 ( & buf [ chmhead_Signature ] ) != 0x46535449 ) { return MSPACK_ERR_SIGNATURE ; } if ( mspack_memcmp ( & buf [ chmhead_GUID1 ] , & guids [ 0 ] , 32L ) != 0 ) { D ( ( "incorrect<S2SV_blank>GUIDs" ) ) return MSPACK_ERR_SIGNATURE ; } chm -> version = EndGetI32 ( & buf [ chmhead_Version ] ) ; chm -> timestamp = EndGetM32 ( & buf [ chmhead_Timestamp ] ) ; chm -> language = EndGetI32 ( & buf [ chmhead_LanguageID ] ) ; if ( chm -> version > 3 ) { sys -> message ( fh , "WARNING;<S2SV_blank>CHM<S2SV_blank>version<S2SV_blank>><S2SV_blank>3" ) ; } if ( sys -> read ( fh , & buf [ 0 ] , chmhst3_SIZEOF ) != chmhst3_SIZEOF ) { return MSPACK_ERR_READ ; } if ( read_off64 ( & offset , & buf [ chmhst_OffsetHS0 ] , sys , fh ) || read_off64 ( & chm -> dir_offset , & buf [ chmhst_OffsetHS1 ] , sys , fh ) || read_off64 ( & chm -> sec0 . offset , & buf [ chmhst3_OffsetCS0 ] , sys , fh ) ) { return MSPACK_ERR_DATAFORMAT ; } if ( sys -> seek ( fh , offset , MSPACK_SYS_SEEK_START ) ) { return MSPACK_ERR_SEEK ; } if ( sys -> read ( fh , & buf [ 0 ] , chmhs0_SIZEOF ) != chmhs0_SIZEOF ) { return MSPACK_ERR_READ ; } if ( read_off64 ( & chm -> length , & buf [ chmhs0_FileLen ] , sys , fh ) ) { return MSPACK_ERR_DATAFORMAT ; } if ( sys -> seek ( fh , chm -> dir_offset , MSPACK_SYS_SEEK_START ) ) { return MSPACK_ERR_SEEK ; } if ( sys -> read ( fh , & buf [ 0 ] , chmhs1_SIZEOF ) != chmhs1_SIZEOF ) { return MSPACK_ERR_READ ; } chm -> dir_offset = sys -> tell ( fh ) ; chm -> chunk_size = EndGetI32 ( & buf [ chmhs1_ChunkSize ] ) ; chm -> density = EndGetI32 ( & buf [ chmhs1_Density ] ) ; chm -> depth = EndGetI32 ( & buf [ chmhs1_Depth ] ) ; chm -> index_root = EndGetI32 ( & buf [ chmhs1_IndexRoot ] ) ; chm -> num_chunks = EndGetI32 ( & buf [ chmhs1_NumChunks ] ) ; chm -> first_pmgl = EndGetI32 ( & buf [ chmhs1_FirstPMGL ] ) ; chm -> last_pmgl = EndGetI32 ( & buf [ chmhs1_LastPMGL ] ) ; if ( chm -> version < 3 ) { chm -> sec0 . offset = chm -> dir_offset + ( chm -> chunk_size * chm -> num_chunks ) ; } if ( chm -> sec0 . offset > chm -> length ) { D ( ( "content<S2SV_blank>section<S2SV_blank>begins<S2SV_blank>after<S2SV_blank>file<S2SV_blank>has<S2SV_blank>ended" ) ) return MSPACK_ERR_DATAFORMAT ; } if ( chm -> chunk_size < ( pmgl_Entries + 2 ) ) { D ( ( "chunk<S2SV_blank>size<S2SV_blank>not<S2SV_blank>large<S2SV_blank>enough" ) ) return MSPACK_ERR_DATAFORMAT ; } if ( chm -> num_chunks == 0 ) { D ( ( "no<S2SV_blank>chunks" ) ) return MSPACK_ERR_DATAFORMAT ; } if ( chm -> num_chunks > 100000 ) { D ( ( "more<S2SV_blank>than<S2SV_blank>100,000<S2SV_blank>chunks" ) ) return MSPACK_ERR_DATAFORMAT ; } if ( ( off_t ) chm -> chunk_size * ( off_t ) chm -> num_chunks > chm -> length ) { D ( ( "chunks<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>entire<S2SV_blank>file" ) ) return MSPACK_ERR_DATAFORMAT ; } if ( ( chm -> chunk_size & ( chm -> chunk_size - 1 ) ) != 0 ) { sys -> message ( fh , "WARNING;<S2SV_blank>chunk<S2SV_blank>size<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>power<S2SV_blank>of<S2SV_blank>two" ) ; } if ( chm -> first_pmgl != 0 ) { sys -> message ( fh , "WARNING;<S2SV_blank>first<S2SV_blank>PMGL<S2SV_blank>chunk<S2SV_blank>is<S2SV_blank>not<S2SV_blank>zero" ) ; } if ( chm -> first_pmgl > chm -> last_pmgl ) { D ( ( "first<S2SV_blank>pmgl<S2SV_blank>chunk<S2SV_blank>is<S2SV_blank>after<S2SV_blank>last<S2SV_blank>pmgl<S2SV_blank>chunk" ) ) return MSPACK_ERR_DATAFORMAT ; } if ( chm -> index_root != 0xFFFFFFFF && chm -> index_root >= chm -> num_chunks ) { D ( ( "index_root<S2SV_blank>outside<S2SV_blank>valid<S2SV_blank>range" ) ) return MSPACK_ERR_DATAFORMAT ; } if ( ! entire ) { return MSPACK_ERR_OK ; } if ( ( x = chm -> first_pmgl ) != 0 ) { if ( sys -> seek ( fh , ( off_t ) ( x * chm -> chunk_size ) , MSPACK_SYS_SEEK_CUR ) ) { return MSPACK_ERR_SEEK ; } } num_chunks = chm -> last_pmgl - x + 1 ; if ( ! ( chunk = ( unsigned char * ) sys -> alloc ( sys , ( size_t ) chm -> chunk_size ) ) ) { return MSPACK_ERR_NOMEMORY ; } errors = 0 ; while ( num_chunks -- ) { if ( sys -> read ( fh , chunk , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { sys -> free ( chunk ) ; return MSPACK_ERR_READ ; } if ( EndGetI32 ( & chunk [ pmgl_Signature ] ) != 0x4C474D50 ) continue ; if ( EndGetI32 ( & chunk [ pmgl_QuickRefSize ] ) < 2 ) { sys -> message ( fh , "WARNING;<S2SV_blank>PMGL<S2SV_blank>quickref<S2SV_blank>area<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small" ) ; } if ( EndGetI32 ( & chunk [ pmgl_QuickRefSize ] ) > ( ( int ) chm -> chunk_size - pmgl_Entries ) ) { sys -> message ( fh , "WARNING;<S2SV_blank>PMGL<S2SV_blank>quickref<S2SV_blank>area<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large" ) ; } p = & chunk [ pmgl_Entries ] ; end = & chunk [ chm -> chunk_size - 2 ] ; num_entries = EndGetI16 ( end ) ; while ( num_entries -- ) { READ_ENCINT ( name_len ) ; if ( name_len > ( unsigned int ) ( end - p ) ) goto chunk_end ; <S2SV_StartBug> if ( name_len == 0 ) goto chunk_end ; <S2SV_EndBug> name = p ; p += name_len ; READ_ENCINT ( section ) ; READ_ENCINT ( offset ) ; <S2SV_StartBug> READ_ENCINT ( length ) ; <S2SV_EndBug> if ( ( offset == 0 ) && ( length == 0 ) ) { if ( ( name_len > 0 ) && ( name [ name_len - 1 ] == '/' ) ) continue ; } if ( section > 1 ) { sys -> message ( fh , "invalid<S2SV_blank>section<S2SV_blank>number<S2SV_blank>\'%u\'." , section ) ; continue ; } if ( ! ( fi = ( struct mschmd_file * ) sys -> alloc ( sys , sizeof ( struct mschmd_file ) + name_len + 1 ) ) ) { sys -> free ( chunk ) ; return MSPACK_ERR_NOMEMORY ; } fi -> next = NULL ; fi -> filename = ( char * ) & fi [ 1 ] ; fi -> section = ( ( section == 0 ) ? ( struct mschmd_section * ) ( & chm -> sec0 ) : ( struct mschmd_section * ) ( & chm -> sec1 ) ) ; fi -> offset = offset ; fi -> length = length ; sys -> copy ( name , fi -> filename , ( size_t ) name_len ) ; fi -> filename [ name_len ] = '\\0' ; if ( name [ 0 ] == ':' && name [ 1 ] == ':' ) { if ( mspack_memcmp ( & name [ 2 ] , & content_name [ 2 ] , 31L ) == 0 ) { if ( mspack_memcmp ( & name [ 33 ] , & content_name [ 33 ] , 8L ) == 0 ) { chm -> sec1 . content = fi ; } else if ( mspack_memcmp ( & name [ 33 ] , & control_name [ 33 ] , 11L ) == 0 ) { chm -> sec1 . control = fi ; } else if ( mspack_memcmp ( & name [ 33 ] , & spaninfo_name [ 33 ] , 8L ) == 0 ) { chm -> sec1 . spaninfo = fi ; } else if ( mspack_memcmp ( & name [ 33 ] , & rtable_name [ 33 ] , 72L ) == 0 ) { chm -> sec1 . rtable = fi ; } } fi -> next = chm -> sysfiles ; chm -> sysfiles = fi ; } else { if ( link ) link -> next = fi ; else chm -> files = fi ; link = fi ; } } chunk_end : if ( num_entries >= 0 ) { D ( ( "chunk<S2SV_blank>ended<S2SV_blank>before<S2SV_blank>all<S2SV_blank>entries<S2SV_blank>could<S2SV_blank>be<S2SV_blank>read" ) ) errors ++ ; } } sys -> free ( chunk ) ; return ( errors > 0 ) ? MSPACK_ERR_DATAFORMAT : MSPACK_ERR_OK ; }
CWE-399 static int archive_read_format_zip_cleanup ( struct archive_read * a ) { struct zip * zip ; struct zip_entry * zip_entry , * next_zip_entry ; zip = ( struct zip * ) ( a -> format -> data ) ; # ifdef HAVE_ZLIB_H if ( zip -> stream_valid ) inflateEnd ( & zip -> stream ) ; # endif <S2SV_StartBug> # if HAVA_LZMA_H && HAVE_LIBLZMA <S2SV_EndBug> if ( zip -> zipx_lzma_valid ) { lzma_end ( & zip -> zipx_lzma_stream ) ; } # endif # ifdef HAVE_BZLIB_H if ( zip -> bzstream_valid ) { BZ2_bzDecompressEnd ( & zip -> bzstream ) ; } # endif free ( zip -> uncompressed_buffer ) ; if ( zip -> ppmd8_valid ) __archive_ppmd8_functions . Ppmd8_Free ( & zip -> ppmd8 ) ; if ( zip -> zip_entries ) { zip_entry = zip -> zip_entries ; while ( zip_entry != NULL ) { next_zip_entry = zip_entry -> next ; archive_string_free ( & zip_entry -> rsrcname ) ; free ( zip_entry ) ; zip_entry = next_zip_entry ; } } free ( zip -> decrypted_buffer ) ; if ( zip -> cctx_valid ) archive_decrypto_aes_ctr_release ( & zip -> cctx ) ; if ( zip -> hctx_valid ) archive_hmac_sha1_cleanup ( & zip -> hctx ) ; free ( zip -> iv ) ; free ( zip -> erd ) ; free ( zip -> v_data ) ; archive_string_free ( & zip -> format_name ) ; free ( zip ) ; ( a -> format -> data ) = NULL ; return ( ARCHIVE_OK ) ; }
CWE-415 BGD_DECLARE ( void ) gdImageGifCtx ( gdImagePtr im , gdIOCtxPtr out ) { <S2SV_StartBug> gdImagePtr pim = 0 , tim = im ; <S2SV_EndBug> int interlace , BitsPerPixel ; interlace = im -> interlace ; if ( im -> trueColor ) { <S2SV_StartBug> pim = gdImageCreatePaletteFromTrueColor ( im , 1 , 256 ) ; <S2SV_EndBug> if ( ! pim ) { return ; } tim = pim ; } BitsPerPixel = colorstobpp ( tim -> colorsTotal ) ; GIFEncode ( out , tim -> sx , tim -> sy , interlace , 0 , tim -> transparent , BitsPerPixel , tim -> red , tim -> green , tim -> blue , tim ) ; if ( pim ) { gdImageDestroy ( pim ) ; } <S2SV_StartBug> } <S2SV_EndBug>
CWE-415 BGD_DECLARE ( void * ) gdImageGifPtr ( gdImagePtr im , int * size ) { void * rv ; gdIOCtx * out = gdNewDynamicCtx ( 2048 , NULL ) ; if ( out == NULL ) return NULL ; <S2SV_StartBug> gdImageGifCtx ( im , out ) ; <S2SV_EndBug> <S2SV_StartBug> rv = gdDPExtractData ( out , size ) ; <S2SV_EndBug> out -> gd_free ( out ) ; return rv ; }
CWE-415 BGD_DECLARE ( void ) gdImageWBMPCtx ( gdImagePtr image , int fg , gdIOCtx * out ) { <S2SV_StartBug> int x , y , pos ; <S2SV_EndBug> Wbmp * wbmp ; if ( ( wbmp = createwbmp ( gdImageSX ( image ) , gdImageSY ( image ) , WBMP_WHITE ) ) == NULL ) { gd_error ( "Could<S2SV_blank>not<S2SV_blank>create<S2SV_blank>WBMP\\n" ) ; return ; } pos = 0 ; for ( y = 0 ; y < gdImageSY ( image ) ; y ++ ) { for ( x = 0 ; x < gdImageSX ( image ) ; x ++ ) { <S2SV_StartBug> if ( gdImageGetPixel ( image , x , y ) == fg ) { <S2SV_EndBug> wbmp -> bitmap [ pos ] = WBMP_BLACK ; } pos ++ ; } } if ( writewbmp ( wbmp , & gd_putout , out ) ) { gd_error ( "Could<S2SV_blank>not<S2SV_blank>save<S2SV_blank>WBMP\\n" ) ; } freewbmp ( wbmp ) ; }
CWE-415 BGD_DECLARE ( void * ) gdImageWBMPPtr ( gdImagePtr im , int * size , int fg ) { void * rv ; gdIOCtx * out = gdNewDynamicCtx ( 2048 , NULL ) ; if ( out == NULL ) return NULL ; <S2SV_StartBug> gdImageWBMPCtx ( im , fg , out ) ; <S2SV_EndBug> <S2SV_StartBug> rv = gdDPExtractData ( out , size ) ; <S2SV_EndBug> out -> gd_free ( out ) ; return rv ; }
CWE-125 static int ng_pkt ( git_pkt * * out , const char * line , size_t len ) { git_pkt_ng * pkt ; const char * ptr ; size_t alloclen ; pkt = git__malloc ( sizeof ( * pkt ) ) ; GITERR_CHECK_ALLOC ( pkt ) ; pkt -> ref = NULL ; pkt -> type = GIT_PKT_NG ; <S2SV_StartBug> line += 3 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( ptr = strchr ( line , '<S2SV_blank>' ) ) ) <S2SV_EndBug> goto out_err ; len = ptr - line ; GITERR_CHECK_ALLOC_ADD ( & alloclen , len , 1 ) ; pkt -> ref = git__malloc ( alloclen ) ; GITERR_CHECK_ALLOC ( pkt -> ref ) ; memcpy ( pkt -> ref , line , len ) ; pkt -> ref [ len ] = '\\0' ; <S2SV_StartBug> line = ptr + 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( ptr = strchr ( line , '\\n' ) ) ) <S2SV_EndBug> goto out_err ; len = ptr - line ; GITERR_CHECK_ALLOC_ADD ( & alloclen , len , 1 ) ; pkt -> msg = git__malloc ( alloclen ) ; GITERR_CHECK_ALLOC ( pkt -> msg ) ; memcpy ( pkt -> msg , line , len ) ; pkt -> msg [ len ] = '\\0' ; * out = ( git_pkt * ) pkt ; return 0 ; out_err : giterr_set ( GITERR_NET , "invalid<S2SV_blank>packet<S2SV_blank>line" ) ; git__free ( pkt -> ref ) ; git__free ( pkt ) ; return - 1 ; }
CWE-125 int git_delta_apply ( void * * out , size_t * out_len , const unsigned char * base , size_t base_len , const unsigned char * delta , size_t delta_len ) { const unsigned char * delta_end = delta + delta_len ; size_t base_sz , res_sz , alloc_sz ; unsigned char * res_dp ; * out = NULL ; * out_len = 0 ; if ( ( hdr_sz ( & base_sz , & delta , delta_end ) < 0 ) || ( base_sz != base_len ) ) { giterr_set ( GITERR_INVALID , "failed<S2SV_blank>to<S2SV_blank>apply<S2SV_blank>delta:<S2SV_blank>base<S2SV_blank>size<S2SV_blank>does<S2SV_blank>not<S2SV_blank>match<S2SV_blank>given<S2SV_blank>data" ) ; return - 1 ; } if ( hdr_sz ( & res_sz , & delta , delta_end ) < 0 ) { giterr_set ( GITERR_INVALID , "failed<S2SV_blank>to<S2SV_blank>apply<S2SV_blank>delta:<S2SV_blank>base<S2SV_blank>size<S2SV_blank>does<S2SV_blank>not<S2SV_blank>match<S2SV_blank>given<S2SV_blank>data" ) ; return - 1 ; } GITERR_CHECK_ALLOC_ADD ( & alloc_sz , res_sz , 1 ) ; res_dp = git__malloc ( alloc_sz ) ; GITERR_CHECK_ALLOC ( res_dp ) ; res_dp [ res_sz ] = '\\0' ; * out = res_dp ; * out_len = res_sz ; while ( delta < delta_end ) { unsigned char cmd = * delta ++ ; if ( cmd & 0x80 ) { size_t off = 0 , len = 0 ; if ( cmd & 0x01 ) off = * delta ++ ; if ( cmd & 0x02 ) off |= * delta ++ << 8UL ; if ( cmd & 0x04 ) off |= * delta ++ << 16UL ; <S2SV_StartBug> if ( cmd & 0x08 ) off |= * delta ++ << 24UL ; <S2SV_EndBug> if ( cmd & 0x10 ) len = * delta ++ ; if ( cmd & 0x20 ) len |= * delta ++ << 8UL ; if ( cmd & 0x40 ) len |= * delta ++ << 16UL ; if ( ! len ) len = 0x10000 ; if ( base_len < off + len || res_sz < len ) goto fail ; memcpy ( res_dp , base + off , len ) ; res_dp += len ; res_sz -= len ; } else if ( cmd ) { if ( delta_end - delta < cmd || res_sz < cmd ) goto fail ; memcpy ( res_dp , delta , cmd ) ; delta += cmd ; res_dp += cmd ; res_sz -= cmd ; } else { goto fail ; } } if ( delta != delta_end || res_sz ) goto fail ; return 0 ; fail : git__free ( * out ) ; * out = NULL ; * out_len = 0 ; giterr_set ( GITERR_INVALID , "failed<S2SV_blank>to<S2SV_blank>apply<S2SV_blank>delta" ) ; return - 1 ; }
CWE-125 int git_delta_apply ( void * * out , size_t * out_len , const unsigned char * base , size_t base_len , const unsigned char * delta , size_t delta_len ) { const unsigned char * delta_end = delta + delta_len ; size_t base_sz , res_sz , alloc_sz ; unsigned char * res_dp ; * out = NULL ; * out_len = 0 ; if ( ( hdr_sz ( & base_sz , & delta , delta_end ) < 0 ) || ( base_sz != base_len ) ) { giterr_set ( GITERR_INVALID , "failed<S2SV_blank>to<S2SV_blank>apply<S2SV_blank>delta:<S2SV_blank>base<S2SV_blank>size<S2SV_blank>does<S2SV_blank>not<S2SV_blank>match<S2SV_blank>given<S2SV_blank>data" ) ; return - 1 ; } if ( hdr_sz ( & res_sz , & delta , delta_end ) < 0 ) { giterr_set ( GITERR_INVALID , "failed<S2SV_blank>to<S2SV_blank>apply<S2SV_blank>delta:<S2SV_blank>base<S2SV_blank>size<S2SV_blank>does<S2SV_blank>not<S2SV_blank>match<S2SV_blank>given<S2SV_blank>data" ) ; return - 1 ; } GITERR_CHECK_ALLOC_ADD ( & alloc_sz , res_sz , 1 ) ; res_dp = git__malloc ( alloc_sz ) ; GITERR_CHECK_ALLOC ( res_dp ) ; res_dp [ res_sz ] = '\\0' ; * out = res_dp ; * out_len = res_sz ; while ( delta < delta_end ) { unsigned char cmd = * delta ++ ; if ( cmd & 0x80 ) { size_t off = 0 , len = 0 ; <S2SV_StartBug> if ( cmd & 0x01 ) off = * delta ++ ; <S2SV_EndBug> <S2SV_StartBug> if ( cmd & 0x02 ) off |= * delta ++ << 8UL ; <S2SV_EndBug> <S2SV_StartBug> if ( cmd & 0x04 ) off |= * delta ++ << 16UL ; <S2SV_EndBug> <S2SV_StartBug> if ( cmd & 0x08 ) off |= ( ( unsigned ) * delta ++ << 24UL ) ; <S2SV_EndBug> <S2SV_StartBug> if ( cmd & 0x10 ) len = * delta ++ ; <S2SV_EndBug> <S2SV_StartBug> if ( cmd & 0x20 ) len |= * delta ++ << 8UL ; <S2SV_EndBug> <S2SV_StartBug> if ( cmd & 0x40 ) len |= * delta ++ << 16UL ; <S2SV_EndBug> <S2SV_StartBug> if ( ! len ) len = 0x10000 ; <S2SV_EndBug> if ( base_len < off + len || res_sz < len ) goto fail ; memcpy ( res_dp , base + off , len ) ; res_dp += len ; res_sz -= len ; } else if ( cmd ) { if ( delta_end - delta < cmd || res_sz < cmd ) goto fail ; memcpy ( res_dp , delta , cmd ) ; delta += cmd ; res_dp += cmd ; res_sz -= cmd ; } else { goto fail ; } } if ( delta != delta_end || res_sz ) goto fail ; return 0 ; fail : git__free ( * out ) ; * out = NULL ; * out_len = 0 ; giterr_set ( GITERR_INVALID , "failed<S2SV_blank>to<S2SV_blank>apply<S2SV_blank>delta" ) ; return - 1 ; }
CWE-125 int git_delta_apply ( void * * out , size_t * out_len , const unsigned char * base , size_t base_len , const unsigned char * delta , size_t delta_len ) { const unsigned char * delta_end = delta + delta_len ; size_t base_sz , res_sz , alloc_sz ; unsigned char * res_dp ; * out = NULL ; * out_len = 0 ; if ( ( hdr_sz ( & base_sz , & delta , delta_end ) < 0 ) || ( base_sz != base_len ) ) { giterr_set ( GITERR_INVALID , "failed<S2SV_blank>to<S2SV_blank>apply<S2SV_blank>delta:<S2SV_blank>base<S2SV_blank>size<S2SV_blank>does<S2SV_blank>not<S2SV_blank>match<S2SV_blank>given<S2SV_blank>data" ) ; return - 1 ; } if ( hdr_sz ( & res_sz , & delta , delta_end ) < 0 ) { giterr_set ( GITERR_INVALID , "failed<S2SV_blank>to<S2SV_blank>apply<S2SV_blank>delta:<S2SV_blank>base<S2SV_blank>size<S2SV_blank>does<S2SV_blank>not<S2SV_blank>match<S2SV_blank>given<S2SV_blank>data" ) ; return - 1 ; } GITERR_CHECK_ALLOC_ADD ( & alloc_sz , res_sz , 1 ) ; res_dp = git__malloc ( alloc_sz ) ; GITERR_CHECK_ALLOC ( res_dp ) ; res_dp [ res_sz ] = '\\0' ; * out = res_dp ; * out_len = res_sz ; while ( delta < delta_end ) { unsigned char cmd = * delta ++ ; if ( cmd & 0x80 ) { <S2SV_StartBug> size_t off = 0 , len = 0 ; <S2SV_EndBug> # define ADD_DELTA ( o , shift ) { if ( delta < delta_end ) ( o ) |= ( ( unsigned ) * delta ++ << shift ) ; else goto fail ; } if ( cmd & 0x01 ) ADD_DELTA ( off , 0UL ) ; if ( cmd & 0x02 ) ADD_DELTA ( off , 8UL ) ; if ( cmd & 0x04 ) ADD_DELTA ( off , 16UL ) ; if ( cmd & 0x08 ) ADD_DELTA ( off , 24UL ) ; if ( cmd & 0x10 ) ADD_DELTA ( len , 0UL ) ; if ( cmd & 0x20 ) ADD_DELTA ( len , 8UL ) ; if ( cmd & 0x40 ) ADD_DELTA ( len , 16UL ) ; if ( ! len ) len = 0x10000 ; # undef ADD_DELTA <S2SV_StartBug> if ( base_len < off + len || res_sz < len ) <S2SV_EndBug> goto fail ; memcpy ( res_dp , base + off , len ) ; res_dp += len ; res_sz -= len ; } else if ( cmd ) { if ( delta_end - delta < cmd || res_sz < cmd ) goto fail ; memcpy ( res_dp , delta , cmd ) ; delta += cmd ; res_dp += cmd ; res_sz -= cmd ; } else { goto fail ; } } if ( delta != delta_end || res_sz ) goto fail ; return 0 ; fail : git__free ( * out ) ; * out = NULL ; * out_len = 0 ; giterr_set ( GITERR_INVALID , "failed<S2SV_blank>to<S2SV_blank>apply<S2SV_blank>delta" ) ; return - 1 ; }
CWE-125 static int matchCurrentInput ( const InString * input , int pos , const widechar * passInstructions , int passIC ) { int k ; int kk = pos ; <S2SV_StartBug> for ( k = passIC + 2 ; k < passIC + 2 + passInstructions [ passIC + 1 ] ; k ++ ) <S2SV_EndBug> if ( input -> chars [ kk ] == ENDSEGMENT || passInstructions [ k ] != input -> chars [ kk ++ ] ) return 0 ; return 1 ; }
CWE-295 static int int_x509_param_set_hosts ( X509_VERIFY_PARAM_ID * id , int mode , const char * name , size_t namelen ) { char * copy ; <S2SV_StartBug> if ( name && memchr ( name , '\\0' , namelen ) ) <S2SV_EndBug> return 0 ; if ( mode == SET_HOST && id -> hosts ) { string_stack_free ( id -> hosts ) ; id -> hosts = NULL ; } if ( name == NULL || namelen == 0 ) return 1 ; copy = strndup ( name , namelen ) ; if ( copy == NULL ) return 0 ; if ( id -> hosts == NULL && ( id -> hosts = sk_OPENSSL_STRING_new_null ( ) ) == NULL ) { free ( copy ) ; return 0 ; } if ( ! sk_OPENSSL_STRING_push ( id -> hosts , copy ) ) { free ( copy ) ; if ( sk_OPENSSL_STRING_num ( id -> hosts ) == 0 ) { sk_OPENSSL_STRING_free ( id -> hosts ) ; id -> hosts = NULL ; } return 0 ; } return 1 ; }
CWE-200 void * vips_malloc ( VipsObject * object , size_t size ) { void * buf ; <S2SV_StartBug> buf = g_malloc ( size ) ; <S2SV_EndBug> if ( object ) { g_signal_connect ( object , "postclose" , G_CALLBACK ( vips_malloc_cb ) , buf ) ; object -> local_memory += size ; } return ( buf ) ; }
CWE-200 void * vips_tracked_malloc ( size_t size ) { void * buf ; vips_tracked_init ( ) ; size += 16 ; <S2SV_StartBug> if ( ! ( buf = g_try_malloc ( size ) ) ) { <S2SV_EndBug> # ifdef DEBUG g_assert_not_reached ( ) ; # endif vips_error ( "vips_tracked" , _ ( "out<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>---<S2SV_blank>size<S2SV_blank>==<S2SV_blank>%dMB" ) , ( int ) ( size / ( 1024.0 * 1024.0 ) ) ) ; g_warning ( _ ( "out<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>---<S2SV_blank>size<S2SV_blank>==<S2SV_blank>%dMB" ) , ( int ) ( size / ( 1024.0 * 1024.0 ) ) ) ; return ( NULL ) ; } g_mutex_lock ( vips_tracked_mutex ) ; * ( ( size_t * ) buf ) = size ; buf = ( void * ) ( ( char * ) buf + 16 ) ; vips_tracked_mem += size ; if ( vips_tracked_mem > vips_tracked_mem_highwater ) vips_tracked_mem_highwater = vips_tracked_mem ; vips_tracked_allocs += 1 ; # ifdef DEBUG_VERBOSE printf ( "vips_tracked_malloc:<S2SV_blank>%p,<S2SV_blank>%zd<S2SV_blank>bytes\\n" , buf , size ) ; # endif g_mutex_unlock ( vips_tracked_mutex ) ; VIPS_GATE_MALLOC ( size ) ; return ( buf ) ; }
CWE-254 int virDomainGetTime ( virDomainPtr dom , long long * seconds , unsigned int * nseconds , unsigned int flags ) { VIR_DOMAIN_DEBUG ( dom , "seconds=%p,<S2SV_blank>nseconds=%p,<S2SV_blank>flags=%x" , seconds , nseconds , flags ) ; virResetLastError ( ) ; <S2SV_StartBug> virCheckDomainReturn ( dom , - 1 ) ; <S2SV_EndBug> if ( dom -> conn -> driver -> domainGetTime ) { int ret = dom -> conn -> driver -> domainGetTime ( dom , seconds , nseconds , flags ) ; if ( ret < 0 ) goto error ; return ret ; } virReportUnsupportedError ( ) ; error : virDispatchError ( dom -> conn ) ; return - 1 ; }
CWE-125 int libevt_record_values_read_event ( libevt_record_values_t * record_values , uint8_t * record_data , size_t record_data_size , uint8_t strict_mode , libcerror_error_t * * error ) { static char * function = "libevt_record_values_read_event" ; size_t record_data_offset = 0 ; size_t strings_data_offset = 0 ; ssize_t value_data_size = 0 ; uint32_t data_offset = 0 ; uint32_t data_size = 0 ; uint32_t members_data_size = 0 ; uint32_t size = 0 ; uint32_t size_copy = 0 ; uint32_t strings_offset = 0 ; uint32_t strings_size = 0 ; uint32_t user_sid_offset = 0 ; uint32_t user_sid_size = 0 ; # if defined ( HAVE_DEBUG_OUTPUT ) uint32_t value_32bit = 0 ; uint16_t value_16bit = 0 ; # endif if ( record_values == NULL ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_ARGUMENTS , LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE , "%s:<S2SV_blank>invalid<S2SV_blank>record<S2SV_blank>values." , function ) ; return ( - 1 ) ; } if ( record_data == NULL ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_ARGUMENTS , LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE , "%s:<S2SV_blank>invalid<S2SV_blank>record<S2SV_blank>data." , function ) ; return ( - 1 ) ; } if ( record_data_size > ( size_t ) SSIZE_MAX ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_ARGUMENTS , LIBCERROR_ARGUMENT_ERROR_VALUE_EXCEEDS_MAXIMUM , "%s:<S2SV_blank>invalid<S2SV_blank>record<S2SV_blank>data<S2SV_blank>size<S2SV_blank>value<S2SV_blank>exceeds<S2SV_blank>maximum." , function ) ; return ( - 1 ) ; } if ( record_data_size < ( sizeof ( evt_record_event_header_t ) + 4 ) ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , "%s:<S2SV_blank>record<S2SV_blank>data<S2SV_blank>size<S2SV_blank>value<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds." , function ) ; return ( - 1 ) ; } byte_stream_copy_to_uint32_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> size , size ) ; byte_stream_copy_to_uint32_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> record_number , record_values -> number ) ; byte_stream_copy_to_uint32_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> creation_time , record_values -> creation_time ) ; byte_stream_copy_to_uint32_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> written_time , record_values -> written_time ) ; byte_stream_copy_to_uint32_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> event_identifier , record_values -> event_identifier ) ; byte_stream_copy_to_uint16_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> event_type , record_values -> event_type ) ; byte_stream_copy_to_uint16_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> event_category , record_values -> event_category ) ; byte_stream_copy_to_uint32_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> strings_offset , strings_offset ) ; byte_stream_copy_to_uint32_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> user_sid_size , user_sid_size ) ; byte_stream_copy_to_uint32_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> user_sid_offset , user_sid_offset ) ; byte_stream_copy_to_uint32_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> data_size , data_size ) ; byte_stream_copy_to_uint32_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> data_offset , data_offset ) ; byte_stream_copy_to_uint32_little_endian ( & ( record_data [ record_data_size - 4 ] ) , size_copy ) ; # if defined ( HAVE_DEBUG_OUTPUT ) if ( libcnotify_verbose != 0 ) { libcnotify_printf ( "%s:<S2SV_blank>size\\t\\t\\t\\t\\t:<S2SV_blank>%" PRIu32 "\\n" , function , size ) ; libcnotify_printf ( "%s:<S2SV_blank>signature\\t\\t\\t\\t:<S2SV_blank>%c%c%c%c\\n" , function , ( ( evt_record_event_header_t * ) record_data ) -> signature [ 0 ] , ( ( evt_record_event_header_t * ) record_data ) -> signature [ 1 ] , ( ( evt_record_event_header_t * ) record_data ) -> signature [ 2 ] , ( ( evt_record_event_header_t * ) record_data ) -> signature [ 3 ] ) ; libcnotify_printf ( "%s:<S2SV_blank>record<S2SV_blank>number\\t\\t\\t\\t:<S2SV_blank>%" PRIu32 "\\n" , function , record_values -> number ) ; if ( libevt_debug_print_posix_time_value ( function , "creation<S2SV_blank>time\\t\\t\\t\\t" , ( ( evt_record_event_header_t * ) record_data ) -> creation_time , 4 , LIBFDATETIME_ENDIAN_LITTLE , LIBFDATETIME_POSIX_TIME_VALUE_TYPE_SECONDS_32BIT_SIGNED , LIBFDATETIME_STRING_FORMAT_TYPE_CTIME | LIBFDATETIME_STRING_FORMAT_FLAG_DATE_TIME , error ) != 1 ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_PRINT_FAILED , "%s:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>print<S2SV_blank>POSIX<S2SV_blank>time<S2SV_blank>value." , function ) ; goto on_error ; } if ( libevt_debug_print_posix_time_value ( function , "written<S2SV_blank>time\\t\\t\\t\\t" , ( ( evt_record_event_header_t * ) record_data ) -> written_time , 4 , LIBFDATETIME_ENDIAN_LITTLE , LIBFDATETIME_POSIX_TIME_VALUE_TYPE_SECONDS_32BIT_SIGNED , LIBFDATETIME_STRING_FORMAT_TYPE_CTIME | LIBFDATETIME_STRING_FORMAT_FLAG_DATE_TIME , error ) != 1 ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_PRINT_FAILED , "%s:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>print<S2SV_blank>POSIX<S2SV_blank>time<S2SV_blank>value." , function ) ; goto on_error ; } libcnotify_printf ( "%s:<S2SV_blank>event<S2SV_blank>identifier\\t\\t\\t:<S2SV_blank>0x%08" PRIx32 "\\n" , function , record_values -> event_identifier ) ; libcnotify_printf ( "%s:<S2SV_blank>event<S2SV_blank>identifier:<S2SV_blank>code\\t\\t\\t:<S2SV_blank>%" PRIu32 "\\n" , function , record_values -> event_identifier & 0x0000ffffUL ) ; libcnotify_printf ( "%s:<S2SV_blank>event<S2SV_blank>identifier:<S2SV_blank>facility\\t\\t:<S2SV_blank>%" PRIu32 "\\n" , function , ( record_values -> event_identifier & 0x0fff0000UL ) >> 16 ) ; libcnotify_printf ( "%s:<S2SV_blank>event<S2SV_blank>identifier:<S2SV_blank>reserved\\t\\t:<S2SV_blank>%" PRIu32 "\\n" , function , ( record_values -> event_identifier & 0x10000000UL ) >> 28 ) ; libcnotify_printf ( "%s:<S2SV_blank>event<S2SV_blank>identifier:<S2SV_blank>customer<S2SV_blank>flags\\t:<S2SV_blank>%" PRIu32 "\\n" , function , ( record_values -> event_identifier & 0x20000000UL ) >> 29 ) ; libcnotify_printf ( "%s:<S2SV_blank>event<S2SV_blank>identifier:<S2SV_blank>severity\\t\\t:<S2SV_blank>%" PRIu32 "<S2SV_blank>(" , function , ( record_values -> event_identifier & 0xc0000000UL ) >> 30 ) ; libevt_debug_print_event_identifier_severity ( record_values -> event_identifier ) ; libcnotify_printf ( ")\\n" ) ; libcnotify_printf ( "%s:<S2SV_blank>event<S2SV_blank>type\\t\\t\\t\\t:<S2SV_blank>%" PRIu16 "<S2SV_blank>(" , function , record_values -> event_type ) ; libevt_debug_print_event_type ( record_values -> event_type ) ; libcnotify_printf ( ")\\n" ) ; byte_stream_copy_to_uint16_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> number_of_strings , value_16bit ) ; libcnotify_printf ( "%s:<S2SV_blank>number<S2SV_blank>of<S2SV_blank>strings\\t\\t\\t:<S2SV_blank>%" PRIu16 "\\n" , function , value_16bit ) ; libcnotify_printf ( "%s:<S2SV_blank>event<S2SV_blank>category\\t\\t\\t\\t:<S2SV_blank>%" PRIu16 "\\n" , function , record_values -> event_category ) ; byte_stream_copy_to_uint16_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> event_flags , value_16bit ) ; libcnotify_printf ( "%s:<S2SV_blank>event<S2SV_blank>flags\\t\\t\\t\\t:<S2SV_blank>0x%04" PRIx16 "\\n" , function , value_16bit ) ; byte_stream_copy_to_uint32_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> closing_record_number , value_32bit ) ; libcnotify_printf ( "%s:<S2SV_blank>closing<S2SV_blank>record<S2SV_blank>values<S2SV_blank>number\\t\\t:<S2SV_blank>%" PRIu32 "\\n" , function , value_32bit ) ; libcnotify_printf ( "%s:<S2SV_blank>strings<S2SV_blank>offset\\t\\t\\t\\t:<S2SV_blank>%" PRIu32 "\\n" , function , strings_offset ) ; libcnotify_printf ( "%s:<S2SV_blank>user<S2SV_blank>security<S2SV_blank>identifier<S2SV_blank>(SID)<S2SV_blank>size\\t:<S2SV_blank>%" PRIu32 "\\n" , function , user_sid_size ) ; libcnotify_printf ( "%s:<S2SV_blank>user<S2SV_blank>security<S2SV_blank>identifier<S2SV_blank>(SID)<S2SV_blank>offset\\t:<S2SV_blank>%" PRIu32 "\\n" , function , user_sid_offset ) ; libcnotify_printf ( "%s:<S2SV_blank>data<S2SV_blank>size\\t\\t\\t\\t:<S2SV_blank>%" PRIu32 "\\n" , function , data_size ) ; libcnotify_printf ( "%s:<S2SV_blank>data<S2SV_blank>offset\\t\\t\\t\\t:<S2SV_blank>%" PRIu32 "\\n" , function , data_offset ) ; } # endif record_data_offset = sizeof ( evt_record_event_header_t ) ; if ( ( user_sid_offset == 0 ) && ( user_sid_size != 0 ) ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , "%s:<S2SV_blank>user<S2SV_blank>SID<S2SV_blank>offset<S2SV_blank>or<S2SV_blank>size<S2SV_blank>value<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds." , function ) ; goto on_error ; } if ( user_sid_offset != 0 ) { if ( ( ( size_t ) user_sid_offset < record_data_offset ) || ( ( size_t ) user_sid_offset >= ( record_data_size - 4 ) ) ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , "%s:<S2SV_blank>user<S2SV_blank>SID<S2SV_blank>offset<S2SV_blank>value<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds." , function ) ; goto on_error ; } if ( user_sid_size != 0 ) { if ( ( size_t ) ( user_sid_offset + user_sid_size ) > ( record_data_size - 4 ) ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , "%s:<S2SV_blank>user<S2SV_blank>SID<S2SV_blank>size<S2SV_blank>value<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds." , function ) ; goto on_error ; } } } if ( ( ( size_t ) strings_offset < user_sid_offset ) || ( ( size_t ) strings_offset >= ( record_data_size - 4 ) ) ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , "%s:<S2SV_blank>strings<S2SV_blank>offset<S2SV_blank>value<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds." , function ) ; goto on_error ; } if ( ( ( size_t ) data_offset < strings_offset ) || ( ( size_t ) data_offset >= ( record_data_size - 4 ) ) ) { if ( data_size != 0 ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , "%s:<S2SV_blank>data<S2SV_blank>offset<S2SV_blank>value<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds." , function ) ; goto on_error ; } data_offset = ( uint32_t ) record_data_size - 4 ; } if ( ( ( size_t ) strings_offset >= ( record_data_size - 4 ) ) && ( strings_offset != data_offset ) ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , "%s:<S2SV_blank>strings<S2SV_blank>offset<S2SV_blank>value<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds." , function ) ; goto on_error ; } if ( strings_offset != 0 ) { if ( strings_offset < record_data_offset ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , "%s:<S2SV_blank>strings<S2SV_blank>offset<S2SV_blank>value<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds." , function ) ; goto on_error ; } } if ( user_sid_offset != 0 ) { members_data_size = user_sid_offset - ( uint32_t ) record_data_offset ; } else if ( strings_offset != 0 ) { members_data_size = strings_offset - ( uint32_t ) record_data_offset ; } if ( strings_offset != 0 ) { strings_size = data_offset - strings_offset ; } if ( data_size != 0 ) { if ( ( size_t ) ( data_offset + data_size ) > ( record_data_size - 4 ) ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , "%s:<S2SV_blank>data<S2SV_blank>size<S2SV_blank>value<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds." , function ) ; goto on_error ; } } if ( members_data_size != 0 ) { # if defined ( HAVE_DEBUG_OUTPUT ) if ( libcnotify_verbose != 0 ) { libcnotify_printf ( "%s:<S2SV_blank>members<S2SV_blank>data:\\n" , function ) ; libcnotify_print_data ( & ( record_data [ record_data_offset ] ) , members_data_size , LIBCNOTIFY_PRINT_DATA_FLAG_GROUP_DATA ) ; } # endif if ( libfvalue_value_type_initialize ( & ( record_values -> source_name ) , LIBFVALUE_VALUE_TYPE_STRING_UTF16 , error ) != 1 ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED , "%s:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>create<S2SV_blank>source<S2SV_blank>name<S2SV_blank>value." , function ) ; goto on_error ; } value_data_size = libfvalue_value_type_set_data_string ( record_values -> source_name , & ( record_data [ record_data_offset ] ) , members_data_size , LIBFVALUE_CODEPAGE_UTF16_LITTLE_ENDIAN , LIBFVALUE_VALUE_DATA_FLAG_MANAGED , error ) ; if ( value_data_size == - 1 ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_SET_FAILED , "%s:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>set<S2SV_blank>data<S2SV_blank>of<S2SV_blank>source<S2SV_blank>name<S2SV_blank>value." , function ) ; goto on_error ; } # if defined ( HAVE_DEBUG_OUTPUT ) if ( libcnotify_verbose != 0 ) { libcnotify_printf ( "%s:<S2SV_blank>source<S2SV_blank>name\\t\\t\\t\\t:<S2SV_blank>" , function ) ; if ( libfvalue_value_print ( record_values -> source_name , 0 , 0 , error ) != 1 ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_PRINT_FAILED , "%s:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>print<S2SV_blank>source<S2SV_blank>name<S2SV_blank>value." , function ) ; goto on_error ; } libcnotify_printf ( "\\n" ) ; } # endif record_data_offset += value_data_size ; members_data_size -= ( uint32_t ) value_data_size ; if ( libfvalue_value_type_initialize ( & ( record_values -> computer_name ) , LIBFVALUE_VALUE_TYPE_STRING_UTF16 , error ) != 1 ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED , "%s:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>create<S2SV_blank>computer<S2SV_blank>name<S2SV_blank>value." , function ) ; goto on_error ; } value_data_size = libfvalue_value_type_set_data_string ( record_values -> computer_name , & ( record_data [ record_data_offset ] ) , members_data_size , LIBFVALUE_CODEPAGE_UTF16_LITTLE_ENDIAN , LIBFVALUE_VALUE_DATA_FLAG_MANAGED , error ) ; if ( value_data_size == - 1 ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_SET_FAILED , "%s:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>set<S2SV_blank>data<S2SV_blank>of<S2SV_blank>computer<S2SV_blank>name<S2SV_blank>value." , function ) ; goto on_error ; } # if defined ( HAVE_DEBUG_OUTPUT ) if ( libcnotify_verbose != 0 ) { libcnotify_printf ( "%s:<S2SV_blank>computer<S2SV_blank>name\\t\\t\\t\\t:<S2SV_blank>" , function ) ; if ( libfvalue_value_print ( record_values -> computer_name , 0 , 0 , error ) != 1 ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_PRINT_FAILED , "%s:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>print<S2SV_blank>computer<S2SV_blank>name<S2SV_blank>value." , function ) ; goto on_error ; } libcnotify_printf ( "\\n" ) ; } # endif record_data_offset += value_data_size ; members_data_size -= ( uint32_t ) value_data_size ; if ( members_data_size > 0 ) { # if defined ( HAVE_DEBUG_OUTPUT ) if ( libcnotify_verbose != 0 ) { libcnotify_printf ( "%s:<S2SV_blank>members<S2SV_blank>trailing<S2SV_blank>data:\\n" , function ) ; libcnotify_print_data ( & ( record_data [ record_data_offset ] ) , members_data_size , LIBCNOTIFY_PRINT_DATA_FLAG_GROUP_DATA ) ; } # endif record_data_offset += members_data_size ; } } if ( user_sid_size != 0 ) { <S2SV_StartBug> if ( libfvalue_value_type_initialize ( <S2SV_EndBug> & ( record_values -> user_security_identifier ) , LIBFVALUE_VALUE_TYPE_NT_SECURITY_IDENTIFIER , error ) != 1 ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED , "%s:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>create<S2SV_blank>user<S2SV_blank>security<S2SV_blank>identifier<S2SV_blank>(SID)<S2SV_blank>value." , function ) ; goto on_error ; } if ( libfvalue_value_set_data ( record_values -> user_security_identifier , & ( record_data [ user_sid_offset ] ) , ( size_t ) user_sid_size , LIBFVALUE_ENDIAN_LITTLE , LIBFVALUE_VALUE_DATA_FLAG_MANAGED , error ) != 1 ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_SET_FAILED , "%s:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>set<S2SV_blank>data<S2SV_blank>of<S2SV_blank>user<S2SV_blank>security<S2SV_blank>identifier<S2SV_blank>(SID)<S2SV_blank>value." , function ) ; goto on_error ; } # if defined ( HAVE_DEBUG_OUTPUT ) if ( libcnotify_verbose != 0 ) { libcnotify_printf ( "%s:<S2SV_blank>user<S2SV_blank>security<S2SV_blank>identifier<S2SV_blank>(SID)\\t\\t:<S2SV_blank>" , function ) ; if ( libfvalue_value_print ( record_values -> user_security_identifier , 0 , 0 , error ) != 1 ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_PRINT_FAILED , "%s:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>print<S2SV_blank>user<S2SV_blank>security<S2SV_blank>identifier<S2SV_blank>(SID)<S2SV_blank>value." , function ) ; goto on_error ; } libcnotify_printf ( "\\n" ) ; } # endif record_data_offset += user_sid_size ; } if ( strings_size != 0 ) <S2SV_StartBug> { <S2SV_EndBug> # if defined ( HAVE_DEBUG_OUTPUT ) if ( libcnotify_verbose != 0 ) { libcnotify_printf ( "%s:<S2SV_blank>strings<S2SV_blank>data:\\n" , function ) ; libcnotify_print_data ( & ( record_data [ strings_offset ] ) , strings_size , LIBCNOTIFY_PRINT_DATA_FLAG_GROUP_DATA ) ; } # endif if ( size_copy == 0 ) { strings_data_offset = strings_offset + strings_size - 2 ; while ( strings_data_offset > strings_offset ) { if ( ( record_data [ strings_data_offset ] != 0 ) || ( record_data [ strings_data_offset + 1 ] != 0 ) ) { strings_size += 2 ; break ; } strings_data_offset -= 2 ; strings_size -= 2 ; } } if ( libfvalue_value_type_initialize ( & ( record_values -> strings ) , LIBFVALUE_VALUE_TYPE_STRING_UTF16 , error ) != 1 ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED , "%s:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>create<S2SV_blank>strings<S2SV_blank>value." , function ) ; goto on_error ; } value_data_size = libfvalue_value_type_set_data_strings_array ( record_values -> strings , & ( record_data [ strings_offset ] ) , strings_size , LIBFVALUE_CODEPAGE_UTF16_LITTLE_ENDIAN , error ) ; if ( value_data_size == - 1 ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_SET_FAILED , "%s:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>set<S2SV_blank>data<S2SV_blank>of<S2SV_blank>strings<S2SV_blank>value." , function ) ; goto on_error ; } record_data_offset += strings_size ; } if ( data_size != 0 ) { <S2SV_StartBug> # if defined ( HAVE_DEBUG_OUTPUT ) <S2SV_EndBug> if ( libcnotify_verbose != 0 ) { libcnotify_printf ( "%s:<S2SV_blank>data:\\n" , function ) ; libcnotify_print_data ( <S2SV_StartBug> & ( record_data [ data_offset ] ) , <S2SV_EndBug> ( size_t ) data_size , LIBCNOTIFY_PRINT_DATA_FLAG_GROUP_DATA ) ; } # endif if ( libfvalue_value_type_initialize ( & ( record_values -> data ) , LIBFVALUE_VALUE_TYPE_BINARY_DATA , error ) != 1 ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED , "%s:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>create<S2SV_blank>data<S2SV_blank>value." , function ) ; goto on_error ; } if ( libfvalue_value_set_data ( record_values -> data , & ( record_data [ record_data_offset ] ) , ( size_t ) data_size , LIBFVALUE_ENDIAN_LITTLE , LIBFVALUE_VALUE_DATA_FLAG_MANAGED , error ) != 1 ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_SET_FAILED , "%s:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>set<S2SV_blank>data<S2SV_blank>of<S2SV_blank>data<S2SV_blank>value." , function ) ; goto on_error ; } # if defined ( HAVE_DEBUG_OUTPUT ) record_data_offset += data_size ; # endif } # if defined ( HAVE_DEBUG_OUTPUT ) if ( libcnotify_verbose != 0 ) { if ( record_data_offset < ( record_data_size - 4 ) ) { libcnotify_printf ( "%s:<S2SV_blank>padding:\\n" , function ) ; libcnotify_print_data ( & ( record_data [ record_data_offset ] ) , ( size_t ) record_data_size - record_data_offset - 4 , LIBCNOTIFY_PRINT_DATA_FLAG_GROUP_DATA ) ; } libcnotify_printf ( "%s:<S2SV_blank>size<S2SV_blank>copy\\t\\t\\t\\t:<S2SV_blank>%" PRIu32 "\\n" , function , size_copy ) ; libcnotify_printf ( "\\n" ) ; } # endif if ( ( strict_mode == 0 ) && ( size_copy == 0 ) ) { size_copy = size ; } if ( size != size_copy ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_INPUT , LIBCERROR_INPUT_ERROR_VALUE_MISMATCH , "%s:<S2SV_blank>value<S2SV_blank>mismatch<S2SV_blank>for<S2SV_blank>size<S2SV_blank>and<S2SV_blank>size<S2SV_blank>copy." , function ) ; goto on_error ; } if ( record_data_size != ( size_t ) size ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_INPUT , LIBCERROR_INPUT_ERROR_VALUE_MISMATCH , "%s:<S2SV_blank>value<S2SV_blank>mismatch<S2SV_blank>for<S2SV_blank>record_values<S2SV_blank>data<S2SV_blank>size<S2SV_blank>and<S2SV_blank>size." , function ) ; goto on_error ; } return ( 1 ) ; on_error : if ( record_values -> data != NULL ) { libfvalue_value_free ( & ( record_values -> data ) , NULL ) ; } if ( record_values -> strings != NULL ) { libfvalue_value_free ( & ( record_values -> strings ) , NULL ) ; } if ( record_values -> user_security_identifier != NULL ) { libfvalue_value_free ( & ( record_values -> user_security_identifier ) , NULL ) ; } if ( record_values -> computer_name != NULL ) { libfvalue_value_free ( & ( record_values -> computer_name ) , NULL ) ; } if ( record_values -> source_name != NULL ) { libfvalue_value_free ( & ( record_values -> source_name ) , NULL ) ; } return ( - 1 ) ; }
CWE-190 static int burl_normalize_2F_to_slash_fix ( buffer * b , int qs , int i ) { char * const s = b -> ptr ; const int blen = ( int ) buffer_string_length ( b ) ; const int used = qs < 0 ? blen : qs ; int j = i ; for ( ; i < used ; ++ i , ++ j ) { s [ j ] = s [ i ] ; if ( s [ i ] == '%' && s [ i + 1 ] == '2' && s [ i + 2 ] == 'F' ) { s [ j ] = '/' ; i += 2 ; } } if ( qs >= 0 ) { <S2SV_StartBug> memmove ( s + j , s + qs , blen - qs ) ; <S2SV_EndBug> <S2SV_StartBug> j += blen - qs ; <S2SV_EndBug> } buffer_string_set_length ( b , j ) ; return qs ; }
CWE-190 static void test_burl_normalize ( void ) { buffer * psrc = buffer_init ( ) ; buffer * ptmp = buffer_init ( ) ; int flags ; flags = HTTP_PARSEOPT_URL_NORMALIZE_UNRESERVED ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "no-slash" ) , CONST_STR_LEN ( "no-slash" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/" ) , CONST_STR_LEN ( "/" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/abc" ) , CONST_STR_LEN ( "/abc" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/abc/" ) , CONST_STR_LEN ( "/abc/" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/abc/def" ) , CONST_STR_LEN ( "/abc/def" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/abc?" ) , CONST_STR_LEN ( "/abc?" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/abc?d" ) , CONST_STR_LEN ( "/abc?d" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/abc?d=" ) , CONST_STR_LEN ( "/abc?d=" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/abc?d=e" ) , CONST_STR_LEN ( "/abc?d=e" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/abc?d=e&" ) , CONST_STR_LEN ( "/abc?d=e&" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/abc?d=e&f" ) , CONST_STR_LEN ( "/abc?d=e&f" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/abc?d=e&f=g" ) , CONST_STR_LEN ( "/abc?d=e&f=g" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/abc?d=e&f=g#" ) , CONST_STR_LEN ( "/abc?d=e&f=g" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/abc?d=e&f=g#any" ) , CONST_STR_LEN ( "/abc?d=e&f=g" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/%2F" ) , CONST_STR_LEN ( "/%2F" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/%2f" ) , CONST_STR_LEN ( "/%2F" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/%20" ) , CONST_STR_LEN ( "/%20" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/%2b" ) , CONST_STR_LEN ( "/%2B" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/%2B" ) , CONST_STR_LEN ( "/%2B" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/%3a" ) , CONST_STR_LEN ( "/%3A" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/%3A" ) , CONST_STR_LEN ( "/%3A" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/~test%20_" ) , CONST_STR_LEN ( "/~test%20%C3%A4_" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/\\375" ) , "" , ( size_t ) - 2 ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/\\376" ) , "" , ( size_t ) - 2 ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/\\377" ) , "" , ( size_t ) - 2 ) ; flags = HTTP_PARSEOPT_URL_NORMALIZE_REQUIRED ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/" ) , CONST_STR_LEN ( "/" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/abc" ) , CONST_STR_LEN ( "/abc" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/abc/" ) , CONST_STR_LEN ( "/abc/" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/abc/def" ) , CONST_STR_LEN ( "/abc/def" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/abc?" ) , CONST_STR_LEN ( "/abc?" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/abc?d" ) , CONST_STR_LEN ( "/abc?d" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/abc?d=" ) , CONST_STR_LEN ( "/abc?d=" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/abc?d=e" ) , CONST_STR_LEN ( "/abc?d=e" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/abc?d=e&" ) , CONST_STR_LEN ( "/abc?d=e&" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/abc?d=e&f" ) , CONST_STR_LEN ( "/abc?d=e&f" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/abc?d=e&f=g" ) , CONST_STR_LEN ( "/abc?d=e&f=g" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/abc?d=e&f=g#" ) , CONST_STR_LEN ( "/abc?d=e&f=g" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/abc?d=e&f=g#any" ) , CONST_STR_LEN ( "/abc?d=e&f=g" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/%2F" ) , CONST_STR_LEN ( "/%2F" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/%2f" ) , CONST_STR_LEN ( "/%2F" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/%20" ) , CONST_STR_LEN ( "/%20" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/%2b" ) , CONST_STR_LEN ( "/+" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/%2B" ) , CONST_STR_LEN ( "/+" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/%3a" ) , CONST_STR_LEN ( "/:" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/%3A" ) , CONST_STR_LEN ( "/:" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/~test%20_" ) , CONST_STR_LEN ( "/~test%20%C3%A4_" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/\\375" ) , "" , ( size_t ) - 2 ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/\\376" ) , "" , ( size_t ) - 2 ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/\\377" ) , "" , ( size_t ) - 2 ) ; flags |= HTTP_PARSEOPT_URL_NORMALIZE_CTRLS_REJECT ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/\\a" ) , "" , ( size_t ) - 2 ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/\\t" ) , "" , ( size_t ) - 2 ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/\\r" ) , "" , ( size_t ) - 2 ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/\\177" ) , "" , ( size_t ) - 2 ) ; # if defined ( __WIN32 ) || defined ( __CYGWIN__ ) flags |= HTTP_PARSEOPT_URL_NORMALIZE_PATH_BACKSLASH_TRANS ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/a\\\\b" ) , CONST_STR_LEN ( "/a/b" ) ) ; # endif flags |= HTTP_PARSEOPT_URL_NORMALIZE_PATH_2F_DECODE ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/a/b?c=/" ) , CONST_STR_LEN ( "/a/b?c=/" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/a/b?c=%2f" ) , CONST_STR_LEN ( "/a/b?c=/" ) ) ; <S2SV_StartBug> run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/a%2fb" ) , CONST_STR_LEN ( "/a/b" ) ) ; <S2SV_EndBug> run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/a%2Fb" ) , CONST_STR_LEN ( "/a/b" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/a%2fb?c=/" ) , CONST_STR_LEN ( "/a/b?c=/" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/a%2fb?c=%2f" ) , CONST_STR_LEN ( "/a/b?c=/" ) ) ; flags &= ~ HTTP_PARSEOPT_URL_NORMALIZE_PATH_2F_DECODE ; flags |= HTTP_PARSEOPT_URL_NORMALIZE_PATH_2F_REJECT ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/a%2fb" ) , "" , ( size_t ) - 2 ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/a%2Fb" ) , "" , ( size_t ) - 2 ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/a/b?c=%2f" ) , CONST_STR_LEN ( "/a/b?c=/" ) ) ; flags &= ~ HTTP_PARSEOPT_URL_NORMALIZE_PATH_2F_REJECT ; flags |= HTTP_PARSEOPT_URL_NORMALIZE_PATH_DOTSEG_REMOVE ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "./a/b" ) , CONST_STR_LEN ( "/a/b" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "../a/b" ) , CONST_STR_LEN ( "/a/b" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/a/./b" ) , CONST_STR_LEN ( "/a/b" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/a/../b" ) , CONST_STR_LEN ( "/b" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/a/b/." ) , CONST_STR_LEN ( "/a/b/" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/a/b/.." ) , CONST_STR_LEN ( "/a/" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/a/../b/.." ) , CONST_STR_LEN ( "/" ) ) ; flags &= ~ HTTP_PARSEOPT_URL_NORMALIZE_PATH_DOTSEG_REMOVE ; flags |= HTTP_PARSEOPT_URL_NORMALIZE_PATH_DOTSEG_REJECT ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "./a/b" ) , "" , ( size_t ) - 2 ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "../a/b" ) , "" , ( size_t ) - 2 ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/a/./b" ) , "" , ( size_t ) - 2 ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/a/../b" ) , "" , ( size_t ) - 2 ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/a/b/." ) , "" , ( size_t ) - 2 ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/a/b/.." ) , "" , ( size_t ) - 2 ) ; flags &= ~ HTTP_PARSEOPT_URL_NORMALIZE_PATH_DOTSEG_REJECT ; flags |= HTTP_PARSEOPT_URL_NORMALIZE_QUERY_20_PLUS ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/a/b?c=d+e" ) , CONST_STR_LEN ( "/a/b?c=d+e" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/a/b?c=d%20e" ) , CONST_STR_LEN ( "/a/b?c=d+e" ) ) ; flags &= ~ HTTP_PARSEOPT_URL_NORMALIZE_QUERY_20_PLUS ; buffer_free ( psrc ) ; buffer_free ( ptmp ) ; }
CWE-119 SQLRETURN SQLSetDescField ( SQLHDESC descriptor_handle , SQLSMALLINT rec_number , SQLSMALLINT field_identifier , SQLPOINTER value , SQLINTEGER buffer_length ) { DMHDESC descriptor = ( DMHDESC ) descriptor_handle ; SQLRETURN ret ; SQLCHAR s1 [ 100 + LOG_MESSAGE_LEN ] ; int isStrField = 0 ; if ( ! __validate_desc ( descriptor ) ) { dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , "Error:<S2SV_blank>SQL_INVALID_HANDLE" ) ; return SQL_INVALID_HANDLE ; } function_entry ( descriptor ) ; if ( log_info . log_flag ) { <S2SV_StartBug> sprintf ( descriptor -> msg , "\\n\\t\\tEntry:\\\n<S2SV_blank>\\n\\t\\t\\tDescriptor<S2SV_blank>=<S2SV_blank>%p\\\n<S2SV_blank>\\n\\t\\t\\tRec<S2SV_blank>Number<S2SV_blank>=<S2SV_blank>%d\\\n<S2SV_blank>\\n\\t\\t\\tField<S2SV_blank>Ident<S2SV_blank>=<S2SV_blank>%s\\\n<S2SV_blank>\\n\\t\\t\\tValue<S2SV_blank>=<S2SV_blank>%p\\\n<S2SV_blank>\\n\\t\\t\\tBuffer<S2SV_blank>Length<S2SV_blank>=<S2SV_blank>%d" , <S2SV_EndBug> descriptor , rec_number , __desc_attr_as_string ( s1 , field_identifier ) , value , ( int ) buffer_length ) ; dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , descriptor -> msg ) ; } thread_protect ( SQL_HANDLE_DESC , descriptor ) ; if ( descriptor -> connection -> state < STATE_C4 ) { dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , "Error:<S2SV_blank>HY010" ) ; __post_internal_error ( & descriptor -> error , ERROR_HY010 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } if ( __check_stmt_from_desc ( descriptor , STATE_S8 ) || __check_stmt_from_desc ( descriptor , STATE_S9 ) || __check_stmt_from_desc ( descriptor , STATE_S10 ) || __check_stmt_from_desc ( descriptor , STATE_S11 ) || __check_stmt_from_desc ( descriptor , STATE_S12 ) || __check_stmt_from_desc ( descriptor , STATE_S13 ) || __check_stmt_from_desc ( descriptor , STATE_S14 ) || __check_stmt_from_desc ( descriptor , STATE_S15 ) ) { dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , "Error:<S2SV_blank>HY010" ) ; __post_internal_error ( & descriptor -> error , ERROR_HY010 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } if ( rec_number < 0 ) { __post_internal_error ( & descriptor -> error , ERROR_07009 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } switch ( field_identifier ) { case SQL_DESC_ALLOC_TYPE : case SQL_DESC_ARRAY_SIZE : case SQL_DESC_ARRAY_STATUS_PTR : case SQL_DESC_BIND_OFFSET_PTR : case SQL_DESC_BIND_TYPE : case SQL_DESC_COUNT : case SQL_DESC_ROWS_PROCESSED_PTR : case SQL_DESC_AUTO_UNIQUE_VALUE : case SQL_DESC_CASE_SENSITIVE : case SQL_DESC_CONCISE_TYPE : case SQL_DESC_DATA_PTR : case SQL_DESC_DATETIME_INTERVAL_CODE : case SQL_DESC_DATETIME_INTERVAL_PRECISION : case SQL_DESC_DISPLAY_SIZE : case SQL_DESC_FIXED_PREC_SCALE : case SQL_DESC_INDICATOR_PTR : case SQL_DESC_LENGTH : case SQL_DESC_NULLABLE : case SQL_DESC_NUM_PREC_RADIX : case SQL_DESC_OCTET_LENGTH : case SQL_DESC_OCTET_LENGTH_PTR : case SQL_DESC_PARAMETER_TYPE : case SQL_DESC_PRECISION : case SQL_DESC_ROWVER : case SQL_DESC_SCALE : case SQL_DESC_SEARCHABLE : case SQL_DESC_TYPE : case SQL_DESC_UNNAMED : case SQL_DESC_UNSIGNED : case SQL_DESC_UPDATABLE : isStrField = 0 ; break ; case SQL_DESC_BASE_COLUMN_NAME : case SQL_DESC_BASE_TABLE_NAME : case SQL_DESC_CATALOG_NAME : case SQL_DESC_LABEL : case SQL_DESC_LITERAL_PREFIX : case SQL_DESC_LITERAL_SUFFIX : case SQL_DESC_LOCAL_TYPE_NAME : case SQL_DESC_NAME : case SQL_DESC_SCHEMA_NAME : case SQL_DESC_TABLE_NAME : case SQL_DESC_TYPE_NAME : isStrField = 1 ; break ; default : isStrField = buffer_length != SQL_IS_POINTER && buffer_length != SQL_IS_INTEGER && buffer_length != SQL_IS_UINTEGER && buffer_length != SQL_IS_SMALLINT && buffer_length != SQL_IS_USMALLINT ; } if ( isStrField && buffer_length < 0 && buffer_length != SQL_NTS ) { __post_internal_error ( & descriptor -> error , ERROR_HY090 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } <S2SV_StartBug> if ( field_identifier == SQL_DESC_COUNT && ( SQLINTEGER ) value < 0 ) <S2SV_EndBug> { __post_internal_error ( & descriptor -> error , ERROR_07009 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } <S2SV_StartBug> if ( field_identifier == SQL_DESC_PARAMETER_TYPE && value != SQL_PARAM_INPUT <S2SV_EndBug> <S2SV_StartBug> && value != SQL_PARAM_OUTPUT && value != SQL_PARAM_INPUT_OUTPUT && <S2SV_EndBug> <S2SV_StartBug> value != SQL_PARAM_INPUT_OUTPUT_STREAM && value != SQL_PARAM_OUTPUT_STREAM ) <S2SV_EndBug> { __post_internal_error ( & descriptor -> error , ERROR_HY105 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } if ( CHECK_SQLSETDESCFIELD ( descriptor -> connection ) ) { ret = SQLSETDESCFIELD ( descriptor -> connection , descriptor -> driver_desc , rec_number , field_identifier , value , buffer_length ) ; } else if ( CHECK_SQLSETDESCFIELDW ( descriptor -> connection ) ) { SQLWCHAR * s1 = NULL ; if ( isStrField ) { s1 = ansi_to_unicode_alloc ( value , buffer_length , descriptor -> connection , NULL ) ; if ( SQL_NTS != buffer_length ) { buffer_length *= sizeof ( SQLWCHAR ) ; } } else { s1 = value ; } ret = SQLSETDESCFIELDW ( descriptor -> connection , descriptor -> driver_desc , rec_number , field_identifier , s1 , buffer_length ) ; if ( isStrField ) { if ( s1 ) free ( s1 ) ; } } else { dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , "Error:<S2SV_blank>IM001" ) ; __post_internal_error ( & descriptor -> error , ERROR_IM001 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } if ( log_info . log_flag ) { sprintf ( descriptor -> msg , "\\n\\t\\tExit:[%s]" , __get_return_status ( ret , s1 ) ) ; dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , descriptor -> msg ) ; } return function_return ( SQL_HANDLE_DESC , descriptor , ret ) ; }
CWE-119 SQLRETURN SQLSetDescFieldW ( SQLHDESC descriptor_handle , SQLSMALLINT rec_number , SQLSMALLINT field_identifier , SQLPOINTER value , SQLINTEGER buffer_length ) { DMHDESC descriptor = ( DMHDESC ) descriptor_handle ; SQLRETURN ret ; SQLCHAR s1 [ 100 + LOG_MESSAGE_LEN ] ; int isStrField = 0 ; if ( ! __validate_desc ( descriptor ) ) { dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , "Error:<S2SV_blank>SQL_INVALID_HANDLE" ) ; # ifdef WITH_HANDLE_REDIRECT { DMHDESC parent_desc ; parent_desc = find_parent_handle ( descriptor , SQL_HANDLE_DESC ) ; if ( parent_desc ) { dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , "Info:<S2SV_blank>found<S2SV_blank>parent<S2SV_blank>handle" ) ; if ( CHECK_SQLSETDESCFIELDW ( parent_desc -> connection ) ) { dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , "Info:<S2SV_blank>calling<S2SV_blank>redirected<S2SV_blank>driver<S2SV_blank>function" ) ; return SQLSETDESCFIELDW ( parent_desc -> connection , descriptor , rec_number , field_identifier , value , buffer_length ) ; } } } # endif return SQL_INVALID_HANDLE ; } function_entry ( descriptor ) ; if ( log_info . log_flag ) { <S2SV_StartBug> sprintf ( descriptor -> msg , "\\n\\t\\tEntry:\\\n<S2SV_blank>\\n\\t\\t\\tDescriptor<S2SV_blank>=<S2SV_blank>%p\\\n<S2SV_blank>\\n\\t\\t\\tRec<S2SV_blank>Number<S2SV_blank>=<S2SV_blank>%d\\\n<S2SV_blank>\\n\\t\\t\\tField<S2SV_blank>Ident<S2SV_blank>=<S2SV_blank>%s\\\n<S2SV_blank>\\n\\t\\t\\tValue<S2SV_blank>=<S2SV_blank>%p\\\n<S2SV_blank>\\n\\t\\t\\tBuffer<S2SV_blank>Length<S2SV_blank>=<S2SV_blank>%d" , <S2SV_EndBug> descriptor , rec_number , __desc_attr_as_string ( s1 , field_identifier ) , value , ( int ) buffer_length ) ; dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , descriptor -> msg ) ; } thread_protect ( SQL_HANDLE_DESC , descriptor ) ; if ( descriptor -> connection -> state < STATE_C4 ) { dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , "Error:<S2SV_blank>HY010" ) ; __post_internal_error ( & descriptor -> error , ERROR_HY010 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } if ( __check_stmt_from_desc ( descriptor , STATE_S8 ) || __check_stmt_from_desc ( descriptor , STATE_S9 ) || __check_stmt_from_desc ( descriptor , STATE_S10 ) || __check_stmt_from_desc ( descriptor , STATE_S11 ) || __check_stmt_from_desc ( descriptor , STATE_S12 ) || __check_stmt_from_desc ( descriptor , STATE_S13 ) || __check_stmt_from_desc ( descriptor , STATE_S14 ) || __check_stmt_from_desc ( descriptor , STATE_S15 ) ) { dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , "Error:<S2SV_blank>HY010" ) ; __post_internal_error ( & descriptor -> error , ERROR_HY010 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } if ( rec_number < 0 ) { __post_internal_error ( & descriptor -> error , ERROR_07009 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } switch ( field_identifier ) { case SQL_DESC_ALLOC_TYPE : case SQL_DESC_ARRAY_SIZE : case SQL_DESC_ARRAY_STATUS_PTR : case SQL_DESC_BIND_OFFSET_PTR : case SQL_DESC_BIND_TYPE : case SQL_DESC_COUNT : case SQL_DESC_ROWS_PROCESSED_PTR : case SQL_DESC_AUTO_UNIQUE_VALUE : case SQL_DESC_CASE_SENSITIVE : case SQL_DESC_CONCISE_TYPE : case SQL_DESC_DATA_PTR : case SQL_DESC_DATETIME_INTERVAL_CODE : case SQL_DESC_DATETIME_INTERVAL_PRECISION : case SQL_DESC_DISPLAY_SIZE : case SQL_DESC_FIXED_PREC_SCALE : case SQL_DESC_INDICATOR_PTR : case SQL_DESC_LENGTH : case SQL_DESC_NULLABLE : case SQL_DESC_NUM_PREC_RADIX : case SQL_DESC_OCTET_LENGTH : case SQL_DESC_OCTET_LENGTH_PTR : case SQL_DESC_PARAMETER_TYPE : case SQL_DESC_PRECISION : case SQL_DESC_ROWVER : case SQL_DESC_SCALE : case SQL_DESC_SEARCHABLE : case SQL_DESC_TYPE : case SQL_DESC_UNNAMED : case SQL_DESC_UNSIGNED : case SQL_DESC_UPDATABLE : isStrField = 0 ; break ; case SQL_DESC_BASE_COLUMN_NAME : case SQL_DESC_BASE_TABLE_NAME : case SQL_DESC_CATALOG_NAME : case SQL_DESC_LABEL : case SQL_DESC_LITERAL_PREFIX : case SQL_DESC_LITERAL_SUFFIX : case SQL_DESC_LOCAL_TYPE_NAME : case SQL_DESC_NAME : case SQL_DESC_SCHEMA_NAME : case SQL_DESC_TABLE_NAME : case SQL_DESC_TYPE_NAME : isStrField = 1 ; break ; default : isStrField = buffer_length != SQL_IS_POINTER && buffer_length != SQL_IS_INTEGER && buffer_length != SQL_IS_UINTEGER && buffer_length != SQL_IS_SMALLINT && buffer_length != SQL_IS_USMALLINT ; } if ( isStrField && buffer_length < 0 && buffer_length != SQL_NTS ) { __post_internal_error ( & descriptor -> error , ERROR_HY090 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } <S2SV_StartBug> if ( field_identifier == SQL_DESC_COUNT && ( SQLINTEGER ) value < 0 ) <S2SV_EndBug> { __post_internal_error ( & descriptor -> error , ERROR_07009 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } <S2SV_StartBug> if ( field_identifier == SQL_DESC_PARAMETER_TYPE && value != SQL_PARAM_INPUT <S2SV_EndBug> <S2SV_StartBug> && value != SQL_PARAM_OUTPUT && value != SQL_PARAM_INPUT_OUTPUT && <S2SV_EndBug> <S2SV_StartBug> value != SQL_PARAM_INPUT_OUTPUT_STREAM && value != SQL_PARAM_OUTPUT_STREAM ) <S2SV_EndBug> { __post_internal_error ( & descriptor -> error , ERROR_HY105 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } if ( descriptor -> connection -> unicode_driver || CHECK_SQLSETDESCFIELDW ( descriptor -> connection ) ) { if ( ! CHECK_SQLSETDESCFIELDW ( descriptor -> connection ) ) { dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , "Error:<S2SV_blank>IM001" ) ; __post_internal_error ( & descriptor -> error , ERROR_IM001 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } ret = SQLSETDESCFIELDW ( descriptor -> connection , descriptor -> driver_desc , rec_number , field_identifier , value , buffer_length ) ; if ( log_info . log_flag ) { sprintf ( descriptor -> msg , "\\n\\t\\tExit:[%s]" , __get_return_status ( ret , s1 ) ) ; dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , descriptor -> msg ) ; } } else { SQLCHAR * ascii_str = NULL ; if ( ! CHECK_SQLSETDESCFIELD ( descriptor -> connection ) ) { dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , "Error:<S2SV_blank>IM001" ) ; __post_internal_error ( & descriptor -> error , ERROR_IM001 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } switch ( field_identifier ) { case SQL_DESC_NAME : ascii_str = ( SQLCHAR * ) unicode_to_ansi_alloc ( value , buffer_length , descriptor -> connection , NULL ) ; value = ascii_str ; buffer_length = strlen ( ( char * ) ascii_str ) ; break ; default : break ; } ret = SQLSETDESCFIELD ( descriptor -> connection , descriptor -> driver_desc , rec_number , field_identifier , value , buffer_length ) ; if ( log_info . log_flag ) { sprintf ( descriptor -> msg , "\\n\\t\\tExit:[%s]" , __get_return_status ( ret , s1 ) ) ; dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , descriptor -> msg ) ; } if ( ascii_str ) { free ( ascii_str ) ; } } return function_return ( SQL_HANDLE_DESC , descriptor , ret ) ; }
CWE-119 static int ExecuteSQL ( SQLHDBC hDbc , char * szSQL , char cDelimiter , int bColumnNames , int bHTMLTable ) { SQLHSTMT hStmt ; SQLTCHAR szSepLine [ 32001 ] ; SQLTCHAR szUcSQL [ 32001 ] ; SQLSMALLINT cols ; SQLINTEGER ret ; SQLLEN nRows = 0 ; szSepLine [ 0 ] = 0 ; ansi_to_unicode ( szSQL , szUcSQL ) ; if ( SQLAllocStmt ( hDbc , & hStmt ) != SQL_SUCCESS ) { if ( bVerbose ) DumpODBCLog ( hEnv , hDbc , 0 ) ; fprintf ( stderr , "[ISQL]ERROR:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>SQLAllocStmt\\n" ) ; return 0 ; } if ( buseED ) { ret = SQLExecDirect ( hStmt , szUcSQL , SQL_NTS ) ; if ( ret == SQL_NO_DATA ) { fprintf ( stderr , "[ISQL]INFO:<S2SV_blank>SQLExecDirect<S2SV_blank>returned<S2SV_blank>SQL_NO_DATA\\n" ) ; } else if ( ret == SQL_SUCCESS_WITH_INFO ) { if ( bVerbose ) DumpODBCLog ( hEnv , hDbc , hStmt ) ; fprintf ( stderr , "[ISQL]INFO:<S2SV_blank>SQLExecDirect<S2SV_blank>returned<S2SV_blank>SQL_SUCCESS_WITH_INFO\\n" ) ; } else if ( ret != SQL_SUCCESS ) { if ( bVerbose ) DumpODBCLog ( hEnv , hDbc , hStmt ) ; fprintf ( stderr , "[ISQL]ERROR:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>SQLExecDirect\\n" ) ; SQLFreeStmt ( hStmt , SQL_DROP ) ; <S2SV_StartBug> free ( szSepLine ) ; <S2SV_EndBug> return 0 ; } } else { if ( SQLPrepare ( hStmt , szUcSQL , SQL_NTS ) != SQL_SUCCESS ) { if ( bVerbose ) DumpODBCLog ( hEnv , hDbc , hStmt ) ; fprintf ( stderr , "[ISQL]ERROR:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>SQLPrepare\\n" ) ; SQLFreeStmt ( hStmt , SQL_DROP ) ; return 0 ; } ret = SQLExecute ( hStmt ) ; if ( ret == SQL_NO_DATA ) { fprintf ( stderr , "[ISQL]INFO:<S2SV_blank>SQLExecute<S2SV_blank>returned<S2SV_blank>SQL_NO_DATA\\n" ) ; } else if ( ret == SQL_SUCCESS_WITH_INFO ) { if ( bVerbose ) DumpODBCLog ( hEnv , hDbc , hStmt ) ; fprintf ( stderr , "[ISQL]INFO:<S2SV_blank>SQLExecute<S2SV_blank>returned<S2SV_blank>SQL_SUCCESS_WITH_INFO\\n" ) ; } else if ( ret != SQL_SUCCESS ) { if ( bVerbose ) DumpODBCLog ( hEnv , hDbc , hStmt ) ; fprintf ( stderr , "[ISQL]ERROR:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>SQLExecute\\n" ) ; SQLFreeStmt ( hStmt , SQL_DROP ) ; return 0 ; } } do { if ( SQLNumResultCols ( hStmt , & cols ) != SQL_SUCCESS ) { if ( bVerbose ) DumpODBCLog ( hEnv , hDbc , hStmt ) ; fprintf ( stderr , "[ISQL]ERROR:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>SQLNumResultCols\\n" ) ; SQLFreeStmt ( hStmt , SQL_DROP ) ; return 0 ; } if ( cols > 0 ) { if ( bHTMLTable ) WriteHeaderHTMLTable ( hStmt ) ; else if ( cDelimiter == 0 ) UWriteHeaderNormal ( hStmt , szSepLine ) ; else if ( cDelimiter && bColumnNames ) WriteHeaderDelimited ( hStmt , cDelimiter ) ; if ( bHTMLTable ) WriteBodyHTMLTable ( hStmt ) ; else if ( cDelimiter == 0 ) nRows = WriteBodyNormal ( hStmt ) ; else WriteBodyDelimited ( hStmt , cDelimiter ) ; } if ( bHTMLTable ) WriteFooterHTMLTable ( hStmt ) ; else if ( cDelimiter == 0 ) UWriteFooterNormal ( hStmt , szSepLine , nRows ) ; } while ( SQL_SUCCEEDED ( SQLMoreResults ( hStmt ) ) ) ; SQLFreeStmt ( hStmt , SQL_DROP ) ; return 1 ; }
CWE-119 char * _multi_string_alloc_and_copy ( LPCWSTR in ) { char * chr ; int len = 0 ; if ( ! in ) { <S2SV_StartBug> return in ; <S2SV_EndBug> } while ( in [ len ] != 0 || in [ len + 1 ] != 0 ) { len ++ ; } chr = malloc ( len + 2 ) ; len = 0 ; while ( in [ len ] != 0 || in [ len + 1 ] != 0 ) { chr [ len ] = 0xFF & in [ len ] ; len ++ ; } chr [ len ++ ] = '\\0' ; chr [ len ++ ] = '\\0' ; return chr ; }
CWE-119 SQLWCHAR * _multi_string_alloc_and_expand ( LPCSTR in ) { SQLWCHAR * chr ; int len = 0 ; if ( ! in ) { <S2SV_StartBug> return in ; <S2SV_EndBug> } while ( in [ len ] != 0 || in [ len + 1 ] != 0 ) { len ++ ; } chr = malloc ( sizeof ( SQLWCHAR ) * ( len + 2 ) ) ; len = 0 ; while ( in [ len ] != 0 || in [ len + 1 ] != 0 ) { chr [ len ] = in [ len ] ; len ++ ; } chr [ len ++ ] = 0 ; chr [ len ++ ] = 0 ; return chr ; }
CWE-119 char * _single_string_alloc_and_copy ( LPCWSTR in ) { char * chr ; int len = 0 ; if ( ! in ) { <S2SV_StartBug> return in ; <S2SV_EndBug> } while ( in [ len ] != 0 ) { len ++ ; } chr = malloc ( len + 1 ) ; len = 0 ; while ( in [ len ] != 0 ) { chr [ len ] = 0xFF & in [ len ] ; len ++ ; } chr [ len ++ ] = '\\0' ; return chr ; }
CWE-119 SQLWCHAR * _single_string_alloc_and_expand ( LPCSTR in ) { SQLWCHAR * chr ; int len = 0 ; if ( ! in ) { <S2SV_StartBug> return in ; <S2SV_EndBug> } while ( in [ len ] != 0 ) { len ++ ; } chr = malloc ( sizeof ( SQLWCHAR ) * ( len + 1 ) ) ; len = 0 ; while ( in [ len ] != 0 ) { chr [ len ] = in [ len ] ; len ++ ; } chr [ len ++ ] = 0 ; return chr ; }
CWE-119 BOOL SQLWriteFileDSN ( LPCSTR pszFileName , LPCSTR pszAppName , LPCSTR pszKeyName , LPCSTR pszString ) { HINI hIni ; char szFileName [ ODBC_FILENAME_MAX + 1 ] ; if ( pszFileName [ 0 ] == '/' ) { <S2SV_StartBug> strncpy ( szFileName , sizeof ( szFileName ) - 5 , pszFileName ) ; <S2SV_EndBug> } else { char szPath [ ODBC_FILENAME_MAX + 1 ] ; * szPath = '\\0' ; _odbcinst_FileINI ( szPath ) ; snprintf ( szFileName , sizeof ( szFileName ) - 5 , "%s/%s" , szPath , pszFileName ) ; } if ( strlen ( szFileName ) < 4 || strcmp ( szFileName + strlen ( szFileName ) - 4 , ".dsn" ) ) { strcat ( szFileName , ".dsn" ) ; } # ifdef __OS2__ if ( iniOpen ( & hIni , szFileName , "#;" , '[' , ']' , '=' , TRUE , 0L ) != INI_SUCCESS ) # else if ( iniOpen ( & hIni , szFileName , "#;" , '[' , ']' , '=' , TRUE ) != INI_SUCCESS ) # endif { inst_logPushMsg ( __FILE__ , __FILE__ , __LINE__ , LOG_CRITICAL , ODBC_ERROR_INVALID_PATH , "" ) ; return FALSE ; } if ( pszString == NULL && pszKeyName == NULL ) { if ( iniObjectSeek ( hIni , ( char * ) pszAppName ) == INI_SUCCESS ) { iniObjectDelete ( hIni ) ; } } else if ( pszString == NULL ) { if ( iniPropertySeek ( hIni , ( char * ) pszAppName , ( char * ) pszKeyName , "" ) == INI_SUCCESS ) { iniPropertyDelete ( hIni ) ; } } else { if ( iniObjectSeek ( hIni , ( char * ) pszAppName ) != INI_SUCCESS ) { iniObjectInsert ( hIni , ( char * ) pszAppName ) ; } if ( iniPropertySeek ( hIni , ( char * ) pszAppName , ( char * ) pszKeyName , "" ) == INI_SUCCESS ) { iniObjectSeek ( hIni , ( char * ) pszAppName ) ; iniPropertyUpdate ( hIni , ( char * ) pszKeyName , ( char * ) pszString ) ; } else { iniObjectSeek ( hIni , ( char * ) pszAppName ) ; iniPropertyInsert ( hIni , ( char * ) pszKeyName , ( char * ) pszString ) ; } } if ( iniCommit ( hIni ) != INI_SUCCESS ) { iniClose ( hIni ) ; inst_logPushMsg ( __FILE__ , __FILE__ , __LINE__ , LOG_CRITICAL , ODBC_ERROR_REQUEST_FAILED , "" ) ; return FALSE ; } iniClose ( hIni ) ; return TRUE ; }
CWE-704 static void merge_param ( HashTable * params , zval * zdata , zval * * * current_param , zval * * * current_args TSRMLS_DC ) { zval * * ptr , * * zdata_ptr ; php_http_array_hashkey_t hkey = php_http_array_hashkey_init ( 0 ) ; # if 0 { zval tmp ; INIT_PZVAL_ARRAY ( & tmp , params ) ; fprintf ( stderr , "params<S2SV_blank>=<S2SV_blank>" ) ; zend_print_zval_r ( & tmp , 1 TSRMLS_CC ) ; fprintf ( stderr , "\\n" ) ; } # endif hkey . type = zend_hash_get_current_key_ex ( Z_ARRVAL_P ( zdata ) , & hkey . str , & hkey . len , & hkey . num , hkey . dup , NULL ) ; if ( ( hkey . type == HASH_KEY_IS_STRING && ! zend_hash_exists ( params , hkey . str , hkey . len ) ) || ( hkey . type == HASH_KEY_IS_LONG && ! zend_hash_index_exists ( params , hkey . num ) ) ) { zval * tmp , * arg , * * args ; zend_hash_get_current_data ( Z_ARRVAL_P ( zdata ) , ( void * ) & ptr ) ; Z_ADDREF_PP ( ptr ) ; MAKE_STD_ZVAL ( tmp ) ; array_init ( tmp ) ; add_assoc_zval_ex ( tmp , ZEND_STRS ( "value" ) , * ptr ) ; MAKE_STD_ZVAL ( arg ) ; array_init ( arg ) ; zend_hash_update ( Z_ARRVAL_P ( tmp ) , "arguments" , sizeof ( "arguments" ) , ( void * ) & arg , sizeof ( zval * ) , ( void * ) & args ) ; * current_args = args ; if ( hkey . type == HASH_KEY_IS_STRING ) { zend_hash_update ( params , hkey . str , hkey . len , ( void * ) & tmp , sizeof ( zval * ) , ( void * ) & ptr ) ; } else { zend_hash_index_update ( params , hkey . num , ( void * ) & tmp , sizeof ( zval * ) , ( void * ) & ptr ) ; } } else { if ( hkey . type == HASH_KEY_IS_STRING ) { zend_hash_find ( params , hkey . str , hkey . len , ( void * ) & ptr ) ; } else { zend_hash_index_find ( params , hkey . num , ( void * ) & ptr ) ; } zdata_ptr = & zdata ; if ( Z_TYPE_PP ( ptr ) == IS_ARRAY && SUCCESS == zend_hash_find ( Z_ARRVAL_PP ( ptr ) , "value" , sizeof ( "value" ) , ( void * ) & ptr ) && SUCCESS == zend_hash_get_current_data ( Z_ARRVAL_PP ( zdata_ptr ) , ( void * ) & zdata_ptr ) ) { zval * * test_ptr ; while ( Z_TYPE_PP ( zdata_ptr ) == IS_ARRAY && SUCCESS == zend_hash_get_current_data ( Z_ARRVAL_PP ( zdata_ptr ) , ( void * ) & test_ptr ) ) { <S2SV_StartBug> if ( Z_TYPE_PP ( test_ptr ) == IS_ARRAY ) { <S2SV_EndBug> if ( HASH_KEY_IS_STRING == zend_hash_get_current_key_ex ( Z_ARRVAL_PP ( zdata_ptr ) , & hkey . str , & hkey . len , & hkey . num , hkey . dup , NULL ) ) { if ( SUCCESS == zend_hash_find ( Z_ARRVAL_PP ( ptr ) , hkey . str , hkey . len , ( void * ) & ptr ) ) { zdata_ptr = test_ptr ; } else { Z_ADDREF_PP ( test_ptr ) ; zend_hash_update ( Z_ARRVAL_PP ( ptr ) , hkey . str , hkey . len , ( void * ) test_ptr , sizeof ( zval * ) , ( void * ) & ptr ) ; break ; } } else { if ( SUCCESS == zend_hash_index_find ( Z_ARRVAL_PP ( ptr ) , hkey . num , ( void * ) & ptr ) ) { zdata_ptr = test_ptr ; } else if ( hkey . num ) { Z_ADDREF_PP ( test_ptr ) ; zend_hash_index_update ( Z_ARRVAL_PP ( ptr ) , hkey . num , ( void * ) test_ptr , sizeof ( zval * ) , ( void * ) & ptr ) ; break ; } else { Z_ADDREF_PP ( test_ptr ) ; zend_hash_next_index_insert ( Z_ARRVAL_PP ( ptr ) , ( void * ) test_ptr , sizeof ( zval * ) , ( void * ) & ptr ) ; break ; } } } else { Z_ADDREF_PP ( test_ptr ) ; if ( Z_TYPE_PP ( ptr ) != IS_ARRAY ) { zval_dtor ( * ptr ) ; array_init ( * ptr ) ; } if ( HASH_KEY_IS_STRING == zend_hash_get_current_key_ex ( Z_ARRVAL_PP ( zdata_ptr ) , & hkey . str , & hkey . len , & hkey . num , hkey . dup , NULL ) ) { zend_hash_update ( Z_ARRVAL_PP ( ptr ) , hkey . str , hkey . len , ( void * ) test_ptr , sizeof ( zval * ) , ( void * ) & ptr ) ; } else if ( hkey . num ) { zend_hash_index_update ( Z_ARRVAL_PP ( ptr ) , hkey . num , ( void * ) test_ptr , sizeof ( zval * ) , ( void * ) & ptr ) ; } else { zend_hash_next_index_insert ( Z_ARRVAL_PP ( ptr ) , ( void * ) test_ptr , sizeof ( zval * ) , ( void * ) & ptr ) ; } break ; } } } } while ( Z_TYPE_PP ( ptr ) == IS_ARRAY && SUCCESS == zend_hash_get_current_data ( Z_ARRVAL_PP ( ptr ) , ( void * ) & ptr ) ) ; * current_param = ptr ; }
CWE-119 void jpc_qmfb_join_colgrp ( jpc_fix_t * a , int numrows , int stride , int parity ) { int bufsize = JPC_CEILDIVPOW2 ( numrows , 1 ) ; jpc_fix_t joinbuf [ QMFB_JOINBUFSIZE * JPC_QMFB_COLGRPSIZE ] ; jpc_fix_t * buf = joinbuf ; jpc_fix_t * srcptr ; jpc_fix_t * dstptr ; register jpc_fix_t * srcptr2 ; register jpc_fix_t * dstptr2 ; register int n ; register int i ; int hstartcol ; if ( bufsize > QMFB_JOINBUFSIZE ) { if ( ! ( buf = jas_alloc3 ( bufsize , JPC_QMFB_COLGRPSIZE , sizeof ( jpc_fix_t ) ) ) ) { abort ( ) ; } } hstartcol = ( numrows + 1 - parity ) >> 1 ; n = hstartcol ; srcptr = & a [ 0 ] ; dstptr = buf ; while ( n -- > 0 ) { dstptr2 = dstptr ; srcptr2 = srcptr ; for ( i = 0 ; i < JPC_QMFB_COLGRPSIZE ; ++ i ) { * dstptr2 = * srcptr2 ; ++ dstptr2 ; ++ srcptr2 ; } srcptr += stride ; dstptr += JPC_QMFB_COLGRPSIZE ; } srcptr = & a [ hstartcol * stride ] ; dstptr = & a [ ( 1 - parity ) * stride ] ; n = numrows - hstartcol ; while ( n -- > 0 ) { dstptr2 = dstptr ; srcptr2 = srcptr ; for ( i = 0 ; i < JPC_QMFB_COLGRPSIZE ; ++ i ) { * dstptr2 = * srcptr2 ; ++ dstptr2 ; ++ srcptr2 ; } dstptr += 2 * stride ; srcptr += stride ; } srcptr = buf ; dstptr = & a [ parity * stride ] ; n = hstartcol ; while ( n -- > 0 ) { dstptr2 = dstptr ; srcptr2 = srcptr ; for ( i = 0 ; i < JPC_QMFB_COLGRPSIZE ; ++ i ) { * dstptr2 = * srcptr2 ; ++ dstptr2 ; ++ srcptr2 ; } dstptr += 2 * stride ; srcptr += JPC_QMFB_COLGRPSIZE ; } if ( buf != joinbuf ) { jas_free ( buf ) ; } }
CWE-119 void jpc_qmfb_split_col ( jpc_fix_t * a , int numrows , int stride , int parity ) { int bufsize = JPC_CEILDIVPOW2 ( numrows , 1 ) ; jpc_fix_t splitbuf [ QMFB_SPLITBUFSIZE ] ; jpc_fix_t * buf = splitbuf ; register jpc_fix_t * srcptr ; register jpc_fix_t * dstptr ; register int n ; register int m ; <S2SV_StartBug> int hstartcol ; <S2SV_EndBug> if ( bufsize > QMFB_SPLITBUFSIZE ) { if ( ! ( buf = jas_alloc2 ( bufsize , sizeof ( jpc_fix_t ) ) ) ) { abort ( ) ; } } if ( numrows >= 2 ) { <S2SV_StartBug> hstartcol = ( numrows + 1 - parity ) >> 1 ; <S2SV_EndBug> <S2SV_StartBug> m = numrows - hstartcol ; <S2SV_EndBug> n = m ; dstptr = buf ; srcptr = & a [ ( 1 - parity ) * stride ] ; while ( n -- > 0 ) { * dstptr = * srcptr ; ++ dstptr ; srcptr += stride << 1 ; } dstptr = & a [ ( 1 - parity ) * stride ] ; srcptr = & a [ ( 2 - parity ) * stride ] ; n = numrows - m - ( ! parity ) ; while ( n -- > 0 ) { * dstptr = * srcptr ; dstptr += stride ; srcptr += stride << 1 ; } <S2SV_StartBug> dstptr = & a [ hstartcol * stride ] ; <S2SV_EndBug> srcptr = buf ; n = m ; while ( n -- > 0 ) { * dstptr = * srcptr ; dstptr += stride ; ++ srcptr ; } } if ( buf != splitbuf ) { jas_free ( buf ) ; } }
CWE-119 void jpc_qmfb_split_colgrp ( jpc_fix_t * a , int numrows , int stride , int parity ) { int bufsize = JPC_CEILDIVPOW2 ( numrows , 1 ) ; jpc_fix_t splitbuf [ QMFB_SPLITBUFSIZE * JPC_QMFB_COLGRPSIZE ] ; jpc_fix_t * buf = splitbuf ; jpc_fix_t * srcptr ; jpc_fix_t * dstptr ; register jpc_fix_t * srcptr2 ; register jpc_fix_t * dstptr2 ; register int n ; register int i ; int m ; <S2SV_StartBug> int hstartcol ; <S2SV_EndBug> if ( bufsize > QMFB_SPLITBUFSIZE ) { <S2SV_StartBug> if ( ! ( buf = jas_alloc2 ( bufsize , sizeof ( jpc_fix_t ) ) ) ) { <S2SV_EndBug> abort ( ) ; } } if ( numrows >= 2 ) { <S2SV_StartBug> hstartcol = ( numrows + 1 - parity ) >> 1 ; <S2SV_EndBug> <S2SV_StartBug> m = numrows - hstartcol ; <S2SV_EndBug> n = m ; dstptr = buf ; srcptr = & a [ ( 1 - parity ) * stride ] ; while ( n -- > 0 ) { dstptr2 = dstptr ; srcptr2 = srcptr ; for ( i = 0 ; i < JPC_QMFB_COLGRPSIZE ; ++ i ) { * dstptr2 = * srcptr2 ; ++ dstptr2 ; ++ srcptr2 ; } dstptr += JPC_QMFB_COLGRPSIZE ; srcptr += stride << 1 ; } dstptr = & a [ ( 1 - parity ) * stride ] ; srcptr = & a [ ( 2 - parity ) * stride ] ; n = numrows - m - ( ! parity ) ; while ( n -- > 0 ) { dstptr2 = dstptr ; srcptr2 = srcptr ; for ( i = 0 ; i < JPC_QMFB_COLGRPSIZE ; ++ i ) { * dstptr2 = * srcptr2 ; ++ dstptr2 ; ++ srcptr2 ; } dstptr += stride ; srcptr += stride << 1 ; } <S2SV_StartBug> dstptr = & a [ hstartcol * stride ] ; <S2SV_EndBug> srcptr = buf ; n = m ; while ( n -- > 0 ) { dstptr2 = dstptr ; srcptr2 = srcptr ; for ( i = 0 ; i < JPC_QMFB_COLGRPSIZE ; ++ i ) { * dstptr2 = * srcptr2 ; ++ dstptr2 ; ++ srcptr2 ; } dstptr += stride ; srcptr += JPC_QMFB_COLGRPSIZE ; } } if ( buf != splitbuf ) { jas_free ( buf ) ; } }
CWE-119 void jpc_qmfb_split_colres ( jpc_fix_t * a , int numrows , int numcols , int stride , int parity ) { int bufsize = JPC_CEILDIVPOW2 ( numrows , 1 ) ; jpc_fix_t splitbuf [ QMFB_SPLITBUFSIZE * JPC_QMFB_COLGRPSIZE ] ; jpc_fix_t * buf = splitbuf ; jpc_fix_t * srcptr ; jpc_fix_t * dstptr ; register jpc_fix_t * srcptr2 ; register jpc_fix_t * dstptr2 ; register int n ; register int i ; int m ; int hstartcol ; if ( bufsize > QMFB_SPLITBUFSIZE ) { <S2SV_StartBug> if ( ! ( buf = jas_alloc2 ( bufsize , sizeof ( jpc_fix_t ) ) ) ) { <S2SV_EndBug> abort ( ) ; } } if ( numrows >= 2 ) { hstartcol = ( numrows + 1 - parity ) >> 1 ; m = numrows - hstartcol ; n = m ; dstptr = buf ; srcptr = & a [ ( 1 - parity ) * stride ] ; while ( n -- > 0 ) { dstptr2 = dstptr ; srcptr2 = srcptr ; for ( i = 0 ; i < numcols ; ++ i ) { * dstptr2 = * srcptr2 ; ++ dstptr2 ; ++ srcptr2 ; } dstptr += numcols ; srcptr += stride << 1 ; } dstptr = & a [ ( 1 - parity ) * stride ] ; srcptr = & a [ ( 2 - parity ) * stride ] ; n = numrows - m - ( ! parity ) ; while ( n -- > 0 ) { dstptr2 = dstptr ; srcptr2 = srcptr ; for ( i = 0 ; i < numcols ; ++ i ) { * dstptr2 = * srcptr2 ; ++ dstptr2 ; ++ srcptr2 ; } dstptr += stride ; srcptr += stride << 1 ; } dstptr = & a [ hstartcol * stride ] ; srcptr = buf ; n = m ; while ( n -- > 0 ) { dstptr2 = dstptr ; srcptr2 = srcptr ; for ( i = 0 ; i < numcols ; ++ i ) { * dstptr2 = * srcptr2 ; ++ dstptr2 ; ++ srcptr2 ; } dstptr += stride ; srcptr += numcols ; } } if ( buf != splitbuf ) { jas_free ( buf ) ; } }
CWE-125 static int jpc_pi_nextcprl ( register jpc_pi_t * pi ) { int rlvlno ; jpc_pirlvl_t * pirlvl ; jpc_pchg_t * pchg ; int prchind ; int prcvind ; int * prclyrno ; uint_fast32_t trx0 ; uint_fast32_t try0 ; uint_fast32_t r ; uint_fast32_t rpx ; uint_fast32_t rpy ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { goto skip ; } else { pi -> prgvolfirst = 0 ; } for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < JAS_CAST ( int , pchg -> compnoend ) && pi -> compno < pi -> numcomps ; ++ pi -> compno , ++ pi -> picomp ) { <S2SV_StartBug> pirlvl = pi -> picomp -> pirlvls ; <S2SV_EndBug> pi -> xstep = pi -> picomp -> hsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << ( pirlvl -> prcwidthexpn + pi -> picomp -> numrlvls - 1 ) ) ; pi -> ystep = pi -> picomp -> vsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << ( pirlvl -> prcheightexpn + pi -> picomp -> numrlvls - 1 ) ) ; for ( rlvlno = 1 , pirlvl = & pi -> picomp -> pirlvls [ 1 ] ; rlvlno < pi -> picomp -> numrlvls ; ++ rlvlno , ++ pirlvl ) { pi -> xstep = JAS_MIN ( pi -> xstep , pi -> picomp -> hsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << ( pirlvl -> prcwidthexpn + pi -> picomp -> numrlvls - rlvlno - 1 ) ) ) ; pi -> ystep = JAS_MIN ( pi -> ystep , pi -> picomp -> vsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << ( pirlvl -> prcheightexpn + pi -> picomp -> numrlvls - rlvlno - 1 ) ) ) ; } for ( pi -> y = pi -> ystart ; pi -> y < pi -> yend ; pi -> y += pi -> ystep - ( pi -> y % pi -> ystep ) ) { for ( pi -> x = pi -> xstart ; pi -> x < pi -> xend ; pi -> x += pi -> xstep - ( pi -> x % pi -> xstep ) ) { for ( pi -> rlvlno = pchg -> rlvlnostart , pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; pi -> rlvlno < pi -> picomp -> numrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno , ++ pi -> pirlvl ) { if ( pi -> pirlvl -> numprcs == 0 ) { continue ; } r = pi -> picomp -> numrlvls - 1 - pi -> rlvlno ; trx0 = JPC_CEILDIV ( pi -> xstart , pi -> picomp -> hsamp << r ) ; try0 = JPC_CEILDIV ( pi -> ystart , pi -> picomp -> vsamp << r ) ; rpx = r + pi -> pirlvl -> prcwidthexpn ; rpy = r + pi -> pirlvl -> prcheightexpn ; <S2SV_StartBug> if ( ( ( pi -> x == pi -> xstart && ( ( trx0 << r ) % ( 1 << rpx ) ) ) || <S2SV_EndBug> ! ( pi -> x % ( pi -> picomp -> hsamp << rpx ) ) ) && <S2SV_StartBug> ( ( pi -> y == pi -> ystart && ( ( try0 << r ) % ( 1 << rpy ) ) ) || <S2SV_EndBug> ! ( pi -> y % ( pi -> picomp -> vsamp << rpy ) ) ) ) { prchind = JPC_FLOORDIVPOW2 ( JPC_CEILDIV ( pi -> x , pi -> picomp -> hsamp << r ) , pi -> pirlvl -> prcwidthexpn ) - JPC_FLOORDIVPOW2 ( trx0 , pi -> pirlvl -> prcwidthexpn ) ; prcvind = JPC_FLOORDIVPOW2 ( JPC_CEILDIV ( pi -> y , pi -> picomp -> vsamp << r ) , pi -> pirlvl -> prcheightexpn ) - JPC_FLOORDIVPOW2 ( try0 , pi -> pirlvl -> prcheightexpn ) ; pi -> prcno = prcvind * pi -> pirlvl -> numhprcs + prchind ; assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; if ( pi -> lyrno >= * prclyrno ) { ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } } } return 1 ; }
CWE-125 static int jpc_pi_nextpcrl ( register jpc_pi_t * pi ) { int rlvlno ; jpc_pirlvl_t * pirlvl ; jpc_pchg_t * pchg ; int prchind ; int prcvind ; int * prclyrno ; int compno ; jpc_picomp_t * picomp ; int xstep ; int ystep ; uint_fast32_t trx0 ; uint_fast32_t try0 ; uint_fast32_t r ; uint_fast32_t rpx ; uint_fast32_t rpy ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { goto skip ; } else { pi -> xstep = 0 ; pi -> ystep = 0 ; for ( compno = 0 , picomp = pi -> picomps ; compno < pi -> numcomps ; ++ compno , ++ picomp ) { for ( rlvlno = 0 , pirlvl = picomp -> pirlvls ; rlvlno < picomp -> numrlvls ; ++ rlvlno , ++ pirlvl ) { <S2SV_StartBug> xstep = picomp -> hsamp * ( 1 << <S2SV_EndBug> ( pirlvl -> prcwidthexpn + picomp -> numrlvls - rlvlno - 1 ) ) ; <S2SV_StartBug> ystep = picomp -> vsamp * ( 1 << <S2SV_EndBug> ( pirlvl -> prcheightexpn + picomp -> numrlvls - rlvlno - 1 ) ) ; pi -> xstep = ( ! pi -> xstep ) ? xstep : JAS_MIN ( pi -> xstep , xstep ) ; pi -> ystep = ( ! pi -> ystep ) ? ystep : JAS_MIN ( pi -> ystep , ystep ) ; } } pi -> prgvolfirst = 0 ; } for ( pi -> y = pi -> ystart ; pi -> y < pi -> yend ; pi -> y += pi -> ystep - ( pi -> y % pi -> ystep ) ) { for ( pi -> x = pi -> xstart ; pi -> x < pi -> xend ; pi -> x += pi -> xstep - ( pi -> x % pi -> xstep ) ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { for ( pi -> rlvlno = pchg -> rlvlnostart , pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; pi -> rlvlno < pi -> picomp -> numrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno , ++ pi -> pirlvl ) { if ( pi -> pirlvl -> numprcs == 0 ) { continue ; } r = pi -> picomp -> numrlvls - 1 - pi -> rlvlno ; trx0 = JPC_CEILDIV ( pi -> xstart , pi -> picomp -> hsamp << r ) ; try0 = JPC_CEILDIV ( pi -> ystart , pi -> picomp -> vsamp << r ) ; rpx = r + pi -> pirlvl -> prcwidthexpn ; rpy = r + pi -> pirlvl -> prcheightexpn ; <S2SV_StartBug> if ( ( ( pi -> x == pi -> xstart && ( ( trx0 << r ) % ( 1 << rpx ) ) ) || <S2SV_EndBug> ! ( pi -> x % ( pi -> picomp -> hsamp << rpx ) ) ) && <S2SV_StartBug> ( ( pi -> y == pi -> ystart && ( ( try0 << r ) % ( 1 << rpy ) ) ) || <S2SV_EndBug> ! ( pi -> y % ( pi -> picomp -> vsamp << rpy ) ) ) ) { prchind = JPC_FLOORDIVPOW2 ( JPC_CEILDIV ( pi -> x , pi -> picomp -> hsamp << r ) , pi -> pirlvl -> prcwidthexpn ) - JPC_FLOORDIVPOW2 ( trx0 , pi -> pirlvl -> prcwidthexpn ) ; prcvind = JPC_FLOORDIVPOW2 ( JPC_CEILDIV ( pi -> y , pi -> picomp -> vsamp << r ) , pi -> pirlvl -> prcheightexpn ) - JPC_FLOORDIVPOW2 ( try0 , pi -> pirlvl -> prcheightexpn ) ; pi -> prcno = prcvind * pi -> pirlvl -> numhprcs + prchind ; assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; if ( pi -> lyrno >= * prclyrno ) { ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } } } return 1 ; }
CWE-125 static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { jpc_pchg_t * pchg ; int * prclyrno ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; goto skip ; } else { pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl -> numprcs ; ++ pi -> prcno , ++ prclyrno ) { if ( pi -> lyrno >= * prclyrno ) { * prclyrno = pi -> lyrno ; ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } return 1 ; }
CWE-125 static int jpc_pi_nextrpcl ( register jpc_pi_t * pi ) { int rlvlno ; jpc_pirlvl_t * pirlvl ; jpc_pchg_t * pchg ; int prchind ; int prcvind ; int * prclyrno ; int compno ; jpc_picomp_t * picomp ; int xstep ; int ystep ; uint_fast32_t r ; uint_fast32_t rpx ; uint_fast32_t rpy ; uint_fast32_t trx0 ; uint_fast32_t try0 ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { goto skip ; } else { pi -> xstep = 0 ; pi -> ystep = 0 ; for ( compno = 0 , picomp = pi -> picomps ; compno < pi -> numcomps ; ++ compno , ++ picomp ) { for ( rlvlno = 0 , pirlvl = picomp -> pirlvls ; rlvlno < picomp -> numrlvls ; ++ rlvlno , ++ pirlvl ) { <S2SV_StartBug> xstep = picomp -> hsamp * ( 1 << ( pirlvl -> prcwidthexpn + <S2SV_EndBug> picomp -> numrlvls - rlvlno - 1 ) ) ; <S2SV_StartBug> ystep = picomp -> vsamp * ( 1 << ( pirlvl -> prcheightexpn + <S2SV_EndBug> picomp -> numrlvls - rlvlno - 1 ) ) ; pi -> xstep = ( ! pi -> xstep ) ? xstep : JAS_MIN ( pi -> xstep , xstep ) ; pi -> ystep = ( ! pi -> ystep ) ? ystep : JAS_MIN ( pi -> ystep , ystep ) ; } } pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pchg -> rlvlnoend && pi -> rlvlno < pi -> maxrlvls ; ++ pi -> rlvlno ) { for ( pi -> y = pi -> ystart ; pi -> y < pi -> yend ; pi -> y += pi -> ystep - ( pi -> y % pi -> ystep ) ) { for ( pi -> x = pi -> xstart ; pi -> x < pi -> xend ; pi -> x += pi -> xstep - ( pi -> x % pi -> xstep ) ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < JAS_CAST ( int , pchg -> compnoend ) && pi -> compno < pi -> numcomps ; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; if ( pi -> pirlvl -> numprcs == 0 ) { continue ; } r = pi -> picomp -> numrlvls - 1 - pi -> rlvlno ; rpx = r + pi -> pirlvl -> prcwidthexpn ; rpy = r + pi -> pirlvl -> prcheightexpn ; trx0 = JPC_CEILDIV ( pi -> xstart , pi -> picomp -> hsamp << r ) ; try0 = JPC_CEILDIV ( pi -> ystart , pi -> picomp -> vsamp << r ) ; <S2SV_StartBug> if ( ( ( pi -> x == pi -> xstart && ( ( trx0 << r ) % ( 1 << rpx ) ) ) <S2SV_EndBug> <S2SV_StartBug> || ! ( pi -> x % ( 1 << rpx ) ) ) && <S2SV_EndBug> <S2SV_StartBug> ( ( pi -> y == pi -> ystart && ( ( try0 << r ) % ( 1 << rpy ) ) ) <S2SV_EndBug> <S2SV_StartBug> || ! ( pi -> y % ( 1 << rpy ) ) ) ) { <S2SV_EndBug> prchind = JPC_FLOORDIVPOW2 ( JPC_CEILDIV ( pi -> x , pi -> picomp -> hsamp << r ) , pi -> pirlvl -> prcwidthexpn ) - JPC_FLOORDIVPOW2 ( trx0 , pi -> pirlvl -> prcwidthexpn ) ; prcvind = JPC_FLOORDIVPOW2 ( JPC_CEILDIV ( pi -> y , pi -> picomp -> vsamp << r ) , pi -> pirlvl -> prcheightexpn ) - JPC_FLOORDIVPOW2 ( try0 , pi -> pirlvl -> prcheightexpn ) ; pi -> prcno = prcvind * pi -> pirlvl -> numhprcs + prchind ; assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; if ( pi -> lyrno >= * prclyrno ) { ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } } } return 1 ; }
CWE-125 int jpc_dec_decodepkts ( jpc_dec_t * dec , jas_stream_t * pkthdrstream , jas_stream_t * in ) { jpc_dec_tile_t * tile ; jpc_pi_t * pi ; int ret ; tile = dec -> curtile ; pi = tile -> pi ; for ( ; ; ) { if ( ! tile -> pkthdrstream || jas_stream_peekc ( tile -> pkthdrstream ) == EOF ) { switch ( jpc_dec_lookahead ( in ) ) { case JPC_MS_EOC : case JPC_MS_SOT : return 0 ; break ; case JPC_MS_SOP : case JPC_MS_EPH : case 0 : break ; default : return - 1 ; break ; } } if ( ( ret = jpc_pi_next ( pi ) ) ) { return ret ; } if ( dec -> maxpkts >= 0 && dec -> numpkts >= dec -> maxpkts ) { jas_eprintf ( "warning:<S2SV_blank>stopping<S2SV_blank>decode<S2SV_blank>prematurely<S2SV_blank>as<S2SV_blank>requested\\n" ) ; return 0 ; } if ( jas_getdbglevel ( ) >= 1 ) { jas_eprintf ( "packet<S2SV_blank>offset=%08ld<S2SV_blank>prg=%d<S2SV_blank>cmptno=%02d<S2SV_blank>" "rlvlno=%02d<S2SV_blank>prcno=%03d<S2SV_blank>lyrno=%02d\\n" , ( long ) jas_stream_getrwcount ( in ) , jpc_pi_prg ( pi ) , jpc_pi_cmptno ( pi ) , jpc_pi_rlvlno ( pi ) , jpc_pi_prcno ( pi ) , jpc_pi_lyrno ( pi ) ) ; } if ( jpc_dec_decodepkt ( dec , pkthdrstream , in , jpc_pi_cmptno ( pi ) , jpc_pi_rlvlno ( pi ) , jpc_pi_prcno ( pi ) , jpc_pi_lyrno ( pi ) ) ) { return - 1 ; } ++ dec -> numpkts ; } return 0 ; }
CWE-125 static int jpc_pi_nextrpcl ( register jpc_pi_t * pi ) { int rlvlno ; jpc_pirlvl_t * pirlvl ; jpc_pchg_t * pchg ; int prchind ; int prcvind ; int * prclyrno ; int compno ; jpc_picomp_t * picomp ; int xstep ; int ystep ; uint_fast32_t r ; uint_fast32_t rpx ; uint_fast32_t rpy ; uint_fast32_t trx0 ; uint_fast32_t try0 ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { goto skip ; } else { pi -> xstep = 0 ; pi -> ystep = 0 ; for ( compno = 0 , picomp = pi -> picomps ; compno < pi -> numcomps ; ++ compno , ++ picomp ) { for ( rlvlno = 0 , pirlvl = picomp -> pirlvls ; rlvlno < picomp -> numrlvls ; ++ rlvlno , ++ pirlvl ) { <S2SV_StartBug> if ( pirlvl -> prcwidthexpn + pi -> picomp -> numrlvls > <S2SV_EndBug> JAS_UINTFAST32_NUMBITS - 2 || <S2SV_StartBug> pirlvl -> prcheightexpn + pi -> picomp -> numrlvls > <S2SV_EndBug> JAS_UINTFAST32_NUMBITS - 2 ) { return - 1 ; } xstep = picomp -> hsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << ( pirlvl -> prcwidthexpn + picomp -> numrlvls - rlvlno - 1 ) ) ; ystep = picomp -> vsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << ( pirlvl -> prcheightexpn + picomp -> numrlvls - rlvlno - 1 ) ) ; pi -> xstep = ( ! pi -> xstep ) ? xstep : JAS_MIN ( pi -> xstep , xstep ) ; pi -> ystep = ( ! pi -> ystep ) ? ystep : JAS_MIN ( pi -> ystep , ystep ) ; } } pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pchg -> rlvlnoend && pi -> rlvlno < pi -> maxrlvls ; ++ pi -> rlvlno ) { for ( pi -> y = pi -> ystart ; pi -> y < pi -> yend ; pi -> y += pi -> ystep - ( pi -> y % pi -> ystep ) ) { for ( pi -> x = pi -> xstart ; pi -> x < pi -> xend ; pi -> x += pi -> xstep - ( pi -> x % pi -> xstep ) ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < JAS_CAST ( int , pchg -> compnoend ) && pi -> compno < pi -> numcomps ; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; if ( pi -> pirlvl -> numprcs == 0 ) { continue ; } r = pi -> picomp -> numrlvls - 1 - pi -> rlvlno ; rpx = r + pi -> pirlvl -> prcwidthexpn ; rpy = r + pi -> pirlvl -> prcheightexpn ; trx0 = JPC_CEILDIV ( pi -> xstart , pi -> picomp -> hsamp << r ) ; try0 = JPC_CEILDIV ( pi -> ystart , pi -> picomp -> vsamp << r ) ; if ( ( ( pi -> x == pi -> xstart && ( ( trx0 << r ) % ( JAS_CAST ( uint_fast32_t , 1 ) << rpx ) ) ) || ! ( pi -> x % ( JAS_CAST ( uint_fast32_t , 1 ) << rpx ) ) ) && ( ( pi -> y == pi -> ystart && ( ( try0 << r ) % ( JAS_CAST ( uint_fast32_t , 1 ) << rpy ) ) ) || ! ( pi -> y % ( JAS_CAST ( uint_fast32_t , 1 ) << rpy ) ) ) ) { prchind = JPC_FLOORDIVPOW2 ( JPC_CEILDIV ( pi -> x , pi -> picomp -> hsamp << r ) , pi -> pirlvl -> prcwidthexpn ) - JPC_FLOORDIVPOW2 ( trx0 , pi -> pirlvl -> prcwidthexpn ) ; prcvind = JPC_FLOORDIVPOW2 ( JPC_CEILDIV ( pi -> y , pi -> picomp -> vsamp << r ) , pi -> pirlvl -> prcheightexpn ) - JPC_FLOORDIVPOW2 ( try0 , pi -> pirlvl -> prcheightexpn ) ; pi -> prcno = prcvind * pi -> pirlvl -> numhprcs + prchind ; assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; if ( pi -> lyrno >= * prclyrno ) { ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } } } return 1 ; }
CWE-125 static inline void get_conn_text ( const conn * c , const int af , char * addr , struct sockaddr * sock_addr ) { char addr_text [ MAXPATHLEN ] ; addr_text [ 0 ] = '\\0' ; const char * protoname = "?" ; unsigned short port = 0 ; <S2SV_StartBug> switch ( af ) { <S2SV_EndBug> case AF_INET : ( void ) inet_ntop ( af , & ( ( struct sockaddr_in * ) sock_addr ) -> sin_addr , addr_text , sizeof ( addr_text ) - 1 ) ; port = ntohs ( ( ( struct sockaddr_in * ) sock_addr ) -> sin_port ) ; protoname = IS_UDP ( c -> transport ) ? "udp" : "tcp" ; break ; case AF_INET6 : addr_text [ 0 ] = '[' ; addr_text [ 1 ] = '\\0' ; if ( inet_ntop ( af , & ( ( struct sockaddr_in6 * ) sock_addr ) -> sin6_addr , addr_text + 1 , sizeof ( addr_text ) - 2 ) ) { strcat ( addr_text , "]" ) ; } port = ntohs ( ( ( struct sockaddr_in6 * ) sock_addr ) -> sin6_port ) ; protoname = IS_UDP ( c -> transport ) ? "udp6" : "tcp6" ; break ; case AF_UNIX : <S2SV_StartBug> strncpy ( addr_text , <S2SV_EndBug> <S2SV_StartBug> ( ( struct sockaddr_un * ) sock_addr ) -> sun_path , <S2SV_EndBug> sizeof ( addr_text ) - 1 ) ; addr_text [ sizeof ( addr_text ) - 1 ] = '\\0' ; protoname = "unix" ; break ; } if ( strlen ( addr_text ) < 2 ) { sprintf ( addr_text , "<AF<S2SV_blank>%d>" , af ) ; } if ( port ) { sprintf ( addr , "%s:%s:%u" , protoname , addr_text , port ) ; } else { sprintf ( addr , "%s:%s" , protoname , addr_text ) ; } }
CWE-190 static inline void process_get_command ( conn * c , token_t * tokens , size_t ntokens , bool return_cas ) { char * key ; size_t nkey ; int i = 0 ; item * it ; token_t * key_token = & tokens [ KEY_TOKEN ] ; char * suffix ; assert ( c != NULL ) ; do { while ( key_token -> length != 0 ) { key = key_token -> value ; nkey = key_token -> length ; if ( nkey > KEY_MAX_LENGTH ) { out_string ( c , "CLIENT_ERROR<S2SV_blank>bad<S2SV_blank>command<S2SV_blank>line<S2SV_blank>format" ) ; while ( i -- > 0 ) { item_remove ( * ( c -> ilist + i ) ) ; } return ; } <S2SV_StartBug> it = item_get ( key , nkey , c , DO_UPDATE ) ; <S2SV_EndBug> if ( settings . detail_enabled ) { stats_prefix_record_get ( key , nkey , NULL != it ) ; } if ( it ) { if ( i >= c -> isize ) { item * * new_list = realloc ( c -> ilist , sizeof ( item * ) * c -> isize * 2 ) ; if ( new_list ) { c -> isize *= 2 ; c -> ilist = new_list ; } else { STATS_LOCK ( ) ; stats . malloc_fails ++ ; STATS_UNLOCK ( ) ; item_remove ( it ) ; break ; } } if ( return_cas || ! settings . inline_ascii_response ) { MEMCACHED_COMMAND_GET ( c -> sfd , ITEM_key ( it ) , it -> nkey , it -> nbytes , ITEM_get_cas ( it ) ) ; if ( i >= c -> suffixsize ) { char * * new_suffix_list = realloc ( c -> suffixlist , sizeof ( char * ) * c -> suffixsize * 2 ) ; if ( new_suffix_list ) { c -> suffixsize *= 2 ; c -> suffixlist = new_suffix_list ; } else { STATS_LOCK ( ) ; stats . malloc_fails ++ ; STATS_UNLOCK ( ) ; item_remove ( it ) ; break ; } } suffix = do_cache_alloc ( c -> thread -> suffix_cache ) ; if ( suffix == NULL ) { STATS_LOCK ( ) ; stats . malloc_fails ++ ; STATS_UNLOCK ( ) ; out_of_memory ( c , "SERVER_ERROR<S2SV_blank>out<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>making<S2SV_blank>CAS<S2SV_blank>suffix" ) ; item_remove ( it ) ; while ( i -- > 0 ) { item_remove ( * ( c -> ilist + i ) ) ; } return ; } * ( c -> suffixlist + i ) = suffix ; int suffix_len = make_ascii_get_suffix ( suffix , it , return_cas ) ; if ( add_iov ( c , "VALUE<S2SV_blank>" , 6 ) != 0 || add_iov ( c , ITEM_key ( it ) , it -> nkey ) != 0 || ( settings . inline_ascii_response && add_iov ( c , ITEM_suffix ( it ) , it -> nsuffix - 2 ) != 0 ) || add_iov ( c , suffix , suffix_len ) != 0 ) { item_remove ( it ) ; break ; } if ( ( it -> it_flags & ITEM_CHUNKED ) == 0 ) { add_iov ( c , ITEM_data ( it ) , it -> nbytes ) ; } else if ( add_chunked_item_iovs ( c , it , it -> nbytes ) != 0 ) { item_remove ( it ) ; break ; } } else { MEMCACHED_COMMAND_GET ( c -> sfd , ITEM_key ( it ) , it -> nkey , it -> nbytes , ITEM_get_cas ( it ) ) ; if ( add_iov ( c , "VALUE<S2SV_blank>" , 6 ) != 0 || add_iov ( c , ITEM_key ( it ) , it -> nkey ) != 0 ) { item_remove ( it ) ; break ; } if ( ( it -> it_flags & ITEM_CHUNKED ) == 0 ) { if ( add_iov ( c , ITEM_suffix ( it ) , it -> nsuffix + it -> nbytes ) != 0 ) { item_remove ( it ) ; break ; } } else if ( add_iov ( c , ITEM_suffix ( it ) , it -> nsuffix ) != 0 || add_chunked_item_iovs ( c , it , it -> nbytes ) != 0 ) { item_remove ( it ) ; break ; } } if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ">%d<S2SV_blank>sending<S2SV_blank>key<S2SV_blank>" , c -> sfd ) ; for ( ii = 0 ; ii < it -> nkey ; ++ ii ) { fprintf ( stderr , "%c" , key [ ii ] ) ; } fprintf ( stderr , "\\n" ) ; } pthread_mutex_lock ( & c -> thread -> stats . mutex ) ; c -> thread -> stats . slab_stats [ ITEM_clsid ( it ) ] . get_hits ++ ; c -> thread -> stats . get_cmds ++ ; pthread_mutex_unlock ( & c -> thread -> stats . mutex ) ; * ( c -> ilist + i ) = it ; i ++ ; } else { pthread_mutex_lock ( & c -> thread -> stats . mutex ) ; c -> thread -> stats . get_misses ++ ; c -> thread -> stats . get_cmds ++ ; pthread_mutex_unlock ( & c -> thread -> stats . mutex ) ; MEMCACHED_COMMAND_GET ( c -> sfd , key , nkey , - 1 , 0 ) ; } key_token ++ ; } if ( key_token -> value != NULL ) { ntokens = tokenize_command ( key_token -> value , tokens , MAX_TOKENS ) ; key_token = tokens ; } } while ( key_token -> value != NULL ) ; c -> icurr = c -> ilist ; c -> ileft = i ; if ( return_cas || ! settings . inline_ascii_response ) { c -> suffixcurr = c -> suffixlist ; c -> suffixleft = i ; } if ( settings . verbose > 1 ) fprintf ( stderr , ">%d<S2SV_blank>END\\n" , c -> sfd ) ; if ( key_token -> value != NULL || add_iov ( c , "END\\r\\n" , 5 ) != 0 || ( IS_UDP ( c -> transport ) && build_udp_headers ( c ) != 0 ) ) { out_of_memory ( c , "SERVER_ERROR<S2SV_blank>out<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>writing<S2SV_blank>get<S2SV_blank>response" ) ; } else { conn_set_state ( c , conn_mwrite ) ; c -> msgcurr = 0 ; } }
CWE-476 static void process_lru_command ( conn * c , token_t * tokens , const size_t ntokens ) { uint32_t pct_hot ; uint32_t pct_warm ; double hot_factor ; int32_t ttl ; double factor ; set_noreply_maybe ( c , tokens , ntokens ) ; if ( strcmp ( tokens [ 1 ] . value , "tune" ) == 0 && ntokens >= 7 ) { if ( ! safe_strtoul ( tokens [ 2 ] . value , & pct_hot ) || ! safe_strtoul ( tokens [ 3 ] . value , & pct_warm ) || ! safe_strtod ( tokens [ 4 ] . value , & hot_factor ) || ! safe_strtod ( tokens [ 5 ] . value , & factor ) ) { out_string ( c , "ERROR" ) ; } else { if ( pct_hot + pct_warm > 80 ) { out_string ( c , "ERROR<S2SV_blank>hot<S2SV_blank>and<S2SV_blank>warm<S2SV_blank>pcts<S2SV_blank>must<S2SV_blank>not<S2SV_blank>exceed<S2SV_blank>80" ) ; } else if ( factor <= 0 || hot_factor <= 0 ) { out_string ( c , "ERROR<S2SV_blank>hot/warm<S2SV_blank>age<S2SV_blank>factors<S2SV_blank>must<S2SV_blank>be<S2SV_blank>greater<S2SV_blank>than<S2SV_blank>0" ) ; } else { settings . hot_lru_pct = pct_hot ; settings . warm_lru_pct = pct_warm ; settings . hot_max_factor = hot_factor ; settings . warm_max_factor = factor ; out_string ( c , "OK" ) ; } } <S2SV_StartBug> } else if ( strcmp ( tokens [ 1 ] . value , "mode" ) == 0 && ntokens >= 3 && <S2SV_EndBug> settings . lru_maintainer_thread ) { if ( strcmp ( tokens [ 2 ] . value , "flat" ) == 0 ) { settings . lru_segmented = false ; out_string ( c , "OK" ) ; } else if ( strcmp ( tokens [ 2 ] . value , "segmented" ) == 0 ) { settings . lru_segmented = true ; out_string ( c , "OK" ) ; } else { out_string ( c , "ERROR" ) ; } <S2SV_StartBug> } else if ( strcmp ( tokens [ 1 ] . value , "temp_ttl" ) == 0 && ntokens >= 3 && <S2SV_EndBug> settings . lru_maintainer_thread ) { if ( ! safe_strtol ( tokens [ 2 ] . value , & ttl ) ) { out_string ( c , "ERROR" ) ; } else { if ( ttl < 0 ) { settings . temp_lru = false ; } else { settings . temp_lru = true ; settings . temporary_ttl = ttl ; } out_string ( c , "OK" ) ; } } else { out_string ( c , "ERROR" ) ; } }
CWE-20 int main ( int argc , char * * argv ) { int c ; bool lock_memory = false ; bool do_daemonize = false ; bool preallocate = false ; int maxcore = 0 ; char * username = NULL ; char * pid_file = NULL ; struct passwd * pw ; struct rlimit rlim ; char * buf ; char unit = '\\0' ; int size_max = 0 ; int retval = EXIT_SUCCESS ; static int * l_socket = NULL ; static int * u_socket = NULL ; bool protocol_specified = false ; bool tcp_specified = false ; bool udp_specified = false ; bool start_lru_maintainer = true ; bool start_lru_crawler = true ; bool start_assoc_maint = true ; enum hashfunc_type hash_type = MURMUR3_HASH ; uint32_t tocrawl ; uint32_t slab_sizes [ MAX_NUMBER_OF_SLAB_CLASSES ] ; bool use_slab_sizes = false ; char * slab_sizes_unparsed = NULL ; bool slab_chunk_size_changed = false ; # ifdef EXTSTORE void * storage = NULL ; char * storage_file = NULL ; struct extstore_conf ext_cf ; # endif char * subopts , * subopts_orig ; char * subopts_value ; enum { MAXCONNS_FAST = 0 , HASHPOWER_INIT , NO_HASHEXPAND , SLAB_REASSIGN , SLAB_AUTOMOVE , SLAB_AUTOMOVE_RATIO , SLAB_AUTOMOVE_WINDOW , TAIL_REPAIR_TIME , HASH_ALGORITHM , LRU_CRAWLER , LRU_CRAWLER_SLEEP , LRU_CRAWLER_TOCRAWL , LRU_MAINTAINER , HOT_LRU_PCT , WARM_LRU_PCT , HOT_MAX_FACTOR , WARM_MAX_FACTOR , TEMPORARY_TTL , IDLE_TIMEOUT , WATCHER_LOGBUF_SIZE , WORKER_LOGBUF_SIZE , SLAB_SIZES , SLAB_CHUNK_MAX , TRACK_SIZES , NO_INLINE_ASCII_RESP , MODERN , NO_MODERN , NO_CHUNKED_ITEMS , NO_SLAB_REASSIGN , NO_SLAB_AUTOMOVE , NO_MAXCONNS_FAST , INLINE_ASCII_RESP , NO_LRU_CRAWLER , NO_LRU_MAINTAINER , NO_DROP_PRIVILEGES , # ifdef MEMCACHED_DEBUG RELAXED_PRIVILEGES , # endif # ifdef EXTSTORE EXT_PAGE_SIZE , EXT_PAGE_COUNT , EXT_WBUF_SIZE , EXT_THREADS , EXT_IO_DEPTH , EXT_PATH , EXT_ITEM_SIZE , EXT_ITEM_AGE , EXT_LOW_TTL , EXT_RECACHE_RATE , EXT_COMPACT_UNDER , EXT_DROP_UNDER , EXT_MAX_FRAG , EXT_DROP_UNREAD , SLAB_AUTOMOVE_FREERATIO , # endif } ; char * const subopts_tokens [ ] = { [ MAXCONNS_FAST ] = "maxconns_fast" , [ HASHPOWER_INIT ] = "hashpower" , [ NO_HASHEXPAND ] = "no_hashexpand" , [ SLAB_REASSIGN ] = "slab_reassign" , [ SLAB_AUTOMOVE ] = "slab_automove" , [ SLAB_AUTOMOVE_RATIO ] = "slab_automove_ratio" , [ SLAB_AUTOMOVE_WINDOW ] = "slab_automove_window" , [ TAIL_REPAIR_TIME ] = "tail_repair_time" , [ HASH_ALGORITHM ] = "hash_algorithm" , [ LRU_CRAWLER ] = "lru_crawler" , [ LRU_CRAWLER_SLEEP ] = "lru_crawler_sleep" , [ LRU_CRAWLER_TOCRAWL ] = "lru_crawler_tocrawl" , [ LRU_MAINTAINER ] = "lru_maintainer" , [ HOT_LRU_PCT ] = "hot_lru_pct" , [ WARM_LRU_PCT ] = "warm_lru_pct" , [ HOT_MAX_FACTOR ] = "hot_max_factor" , [ WARM_MAX_FACTOR ] = "warm_max_factor" , [ TEMPORARY_TTL ] = "temporary_ttl" , [ IDLE_TIMEOUT ] = "idle_timeout" , [ WATCHER_LOGBUF_SIZE ] = "watcher_logbuf_size" , [ WORKER_LOGBUF_SIZE ] = "worker_logbuf_size" , [ SLAB_SIZES ] = "slab_sizes" , [ SLAB_CHUNK_MAX ] = "slab_chunk_max" , [ TRACK_SIZES ] = "track_sizes" , [ NO_INLINE_ASCII_RESP ] = "no_inline_ascii_resp" , [ MODERN ] = "modern" , [ NO_MODERN ] = "no_modern" , [ NO_CHUNKED_ITEMS ] = "no_chunked_items" , [ NO_SLAB_REASSIGN ] = "no_slab_reassign" , [ NO_SLAB_AUTOMOVE ] = "no_slab_automove" , [ NO_MAXCONNS_FAST ] = "no_maxconns_fast" , [ INLINE_ASCII_RESP ] = "inline_ascii_resp" , [ NO_LRU_CRAWLER ] = "no_lru_crawler" , [ NO_LRU_MAINTAINER ] = "no_lru_maintainer" , [ NO_DROP_PRIVILEGES ] = "no_drop_privileges" , # ifdef MEMCACHED_DEBUG [ RELAXED_PRIVILEGES ] = "relaxed_privileges" , # endif # ifdef EXTSTORE [ EXT_PAGE_SIZE ] = "ext_page_size" , [ EXT_PAGE_COUNT ] = "ext_page_count" , [ EXT_WBUF_SIZE ] = "ext_wbuf_size" , [ EXT_THREADS ] = "ext_threads" , [ EXT_IO_DEPTH ] = "ext_io_depth" , [ EXT_PATH ] = "ext_path" , [ EXT_ITEM_SIZE ] = "ext_item_size" , [ EXT_ITEM_AGE ] = "ext_item_age" , [ EXT_LOW_TTL ] = "ext_low_ttl" , [ EXT_RECACHE_RATE ] = "ext_recache_rate" , [ EXT_COMPACT_UNDER ] = "ext_compact_under" , [ EXT_DROP_UNDER ] = "ext_drop_under" , [ EXT_MAX_FRAG ] = "ext_max_frag" , [ EXT_DROP_UNREAD ] = "ext_drop_unread" , [ SLAB_AUTOMOVE_FREERATIO ] = "slab_automove_freeratio" , # endif NULL } ; if ( ! sanitycheck ( ) ) { return EX_OSERR ; } signal ( SIGINT , sig_handler ) ; signal ( SIGTERM , sig_handler ) ; settings_init ( ) ; # ifdef EXTSTORE settings . ext_item_size = 512 ; settings . ext_item_age = UINT_MAX ; settings . ext_low_ttl = 0 ; settings . ext_recache_rate = 2000 ; settings . ext_max_frag = 0.8 ; settings . ext_drop_unread = false ; settings . ext_wbuf_size = 1024 * 1024 * 4 ; settings . ext_compact_under = 0 ; settings . ext_drop_under = 0 ; settings . slab_automove_freeratio = 0.01 ; ext_cf . page_size = 1024 * 1024 * 64 ; ext_cf . page_count = 64 ; ext_cf . wbuf_size = settings . ext_wbuf_size ; ext_cf . io_threadcount = 1 ; ext_cf . io_depth = 1 ; ext_cf . page_buckets = 4 ; ext_cf . wbuf_count = ext_cf . page_buckets ; # endif init_lru_maintainer ( ) ; setbuf ( stderr , NULL ) ; char * shortopts = "a:" "A" "p:" "s:" "U:" "m:" "M" "c:" "k" "hiV" "r" "v" "d" "l:" "u:" "P:" "f:" "n:" "t:" "D:" "L" "R:" "C" "b:" "B:" "I:" "S" "F" "X" "o:" ; # ifdef HAVE_GETOPT_LONG const struct option longopts [ ] = { { "unix-mask" , required_argument , 0 , 'a' } , { "enable-shutdown" , no_argument , 0 , 'A' } , { "port" , required_argument , 0 , 'p' } , { "unix-socket" , required_argument , 0 , 's' } , { "udp-port" , required_argument , 0 , 'U' } , { "memory-limit" , required_argument , 0 , 'm' } , { "disable-evictions" , no_argument , 0 , 'M' } , { "conn-limit" , required_argument , 0 , 'c' } , { "lock-memory" , no_argument , 0 , 'k' } , { "help" , no_argument , 0 , 'h' } , { "license" , no_argument , 0 , 'i' } , { "version" , no_argument , 0 , 'V' } , { "enable-coredumps" , no_argument , 0 , 'r' } , { "verbose" , optional_argument , 0 , 'v' } , { "daemon" , no_argument , 0 , 'd' } , { "listen" , required_argument , 0 , 'l' } , { "user" , required_argument , 0 , 'u' } , { "pidfile" , required_argument , 0 , 'P' } , { "slab-growth-factor" , required_argument , 0 , 'f' } , { "slab-min-size" , required_argument , 0 , 'n' } , { "threads" , required_argument , 0 , 't' } , { "enable-largepages" , no_argument , 0 , 'L' } , { "max-reqs-per-event" , required_argument , 0 , 'R' } , { "disable-cas" , no_argument , 0 , 'C' } , { "listen-backlog" , required_argument , 0 , 'b' } , { "protocol" , required_argument , 0 , 'B' } , { "max-item-size" , required_argument , 0 , 'I' } , { "enable-sasl" , no_argument , 0 , 'S' } , { "disable-flush-all" , no_argument , 0 , 'F' } , { "disable-dumping" , no_argument , 0 , 'X' } , { "extended" , required_argument , 0 , 'o' } , { 0 , 0 , 0 , 0 } } ; int optindex ; while ( - 1 != ( c = getopt_long ( argc , argv , shortopts , longopts , & optindex ) ) ) { # else while ( - 1 != ( c = getopt ( argc , argv , shortopts ) ) ) { # endif switch ( c ) { case 'A' : settings . shutdown_command = true ; break ; case 'a' : settings . access = strtol ( optarg , NULL , 8 ) ; break ; case 'U' : settings . udpport = atoi ( optarg ) ; udp_specified = true ; break ; case 'p' : settings . port = atoi ( optarg ) ; tcp_specified = true ; break ; case 's' : settings . socketpath = optarg ; break ; case 'm' : settings . maxbytes = ( ( size_t ) atoi ( optarg ) ) * 1024 * 1024 ; break ; case 'M' : settings . evict_to_free = 0 ; break ; case 'c' : settings . maxconns = atoi ( optarg ) ; if ( settings . maxconns <= 0 ) { fprintf ( stderr , "Maximum<S2SV_blank>connections<S2SV_blank>must<S2SV_blank>be<S2SV_blank>greater<S2SV_blank>than<S2SV_blank>0\\n" ) ; return 1 ; } break ; case 'h' : usage ( ) ; exit ( EXIT_SUCCESS ) ; case 'i' : usage_license ( ) ; exit ( EXIT_SUCCESS ) ; case 'V' : printf ( PACKAGE "<S2SV_blank>" VERSION "\\n" ) ; exit ( EXIT_SUCCESS ) ; case 'k' : lock_memory = true ; break ; case 'v' : settings . verbose ++ ; break ; case 'l' : if ( settings . inter != NULL ) { if ( strstr ( settings . inter , optarg ) != NULL ) { break ; } size_t len = strlen ( settings . inter ) + strlen ( optarg ) + 2 ; char * p = malloc ( len ) ; if ( p == NULL ) { fprintf ( stderr , "Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory\\n" ) ; return 1 ; } snprintf ( p , len , "%s,%s" , settings . inter , optarg ) ; free ( settings . inter ) ; settings . inter = p ; } else { settings . inter = strdup ( optarg ) ; } break ; case 'd' : do_daemonize = true ; break ; case 'r' : maxcore = 1 ; break ; case 'R' : settings . reqs_per_event = atoi ( optarg ) ; if ( settings . reqs_per_event == 0 ) { fprintf ( stderr , "Number<S2SV_blank>of<S2SV_blank>requests<S2SV_blank>per<S2SV_blank>event<S2SV_blank>must<S2SV_blank>be<S2SV_blank>greater<S2SV_blank>than<S2SV_blank>0\\n" ) ; return 1 ; } break ; case 'u' : username = optarg ; break ; case 'P' : pid_file = optarg ; break ; case 'f' : settings . factor = atof ( optarg ) ; if ( settings . factor <= 1.0 ) { fprintf ( stderr , "Factor<S2SV_blank>must<S2SV_blank>be<S2SV_blank>greater<S2SV_blank>than<S2SV_blank>1\\n" ) ; return 1 ; } break ; case 'n' : settings . chunk_size = atoi ( optarg ) ; if ( settings . chunk_size == 0 ) { fprintf ( stderr , "Chunk<S2SV_blank>size<S2SV_blank>must<S2SV_blank>be<S2SV_blank>greater<S2SV_blank>than<S2SV_blank>0\\n" ) ; return 1 ; } break ; case 't' : settings . num_threads = atoi ( optarg ) ; if ( settings . num_threads <= 0 ) { fprintf ( stderr , "Number<S2SV_blank>of<S2SV_blank>threads<S2SV_blank>must<S2SV_blank>be<S2SV_blank>greater<S2SV_blank>than<S2SV_blank>0\\n" ) ; return 1 ; } if ( settings . num_threads > 64 ) { fprintf ( stderr , "WARNING:<S2SV_blank>Setting<S2SV_blank>a<S2SV_blank>high<S2SV_blank>number<S2SV_blank>of<S2SV_blank>worker" "threads<S2SV_blank>is<S2SV_blank>not<S2SV_blank>recommended.\\n" "<S2SV_blank>Set<S2SV_blank>this<S2SV_blank>value<S2SV_blank>to<S2SV_blank>the<S2SV_blank>number<S2SV_blank>of<S2SV_blank>cores<S2SV_blank>in" "<S2SV_blank>your<S2SV_blank>machine<S2SV_blank>or<S2SV_blank>less.\\n" ) ; } break ; case 'D' : if ( ! optarg || ! optarg [ 0 ] ) { fprintf ( stderr , "No<S2SV_blank>delimiter<S2SV_blank>specified\\n" ) ; return 1 ; } settings . prefix_delimiter = optarg [ 0 ] ; settings . detail_enabled = 1 ; break ; case 'L' : if ( enable_large_pages ( ) == 0 ) { preallocate = true ; } else { fprintf ( stderr , "Cannot<S2SV_blank>enable<S2SV_blank>large<S2SV_blank>pages<S2SV_blank>on<S2SV_blank>this<S2SV_blank>system\\n" "(There<S2SV_blank>is<S2SV_blank>no<S2SV_blank>Linux<S2SV_blank>support<S2SV_blank>as<S2SV_blank>of<S2SV_blank>this<S2SV_blank>version)\\n" ) ; return 1 ; } break ; case 'C' : settings . use_cas = false ; break ; case 'b' : settings . backlog = atoi ( optarg ) ; break ; case 'B' : protocol_specified = true ; if ( strcmp ( optarg , "auto" ) == 0 ) { settings . binding_protocol = negotiating_prot ; } else if ( strcmp ( optarg , "binary" ) == 0 ) { settings . binding_protocol = binary_prot ; } else if ( strcmp ( optarg , "ascii" ) == 0 ) { settings . binding_protocol = ascii_prot ; } else { fprintf ( stderr , "Invalid<S2SV_blank>value<S2SV_blank>for<S2SV_blank>binding<S2SV_blank>protocol:<S2SV_blank>%s\\n" "<S2SV_blank>--<S2SV_blank>should<S2SV_blank>be<S2SV_blank>one<S2SV_blank>of<S2SV_blank>auto,<S2SV_blank>binary,<S2SV_blank>or<S2SV_blank>ascii\\n" , optarg ) ; exit ( EX_USAGE ) ; } break ; case 'I' : buf = strdup ( optarg ) ; unit = buf [ strlen ( buf ) - 1 ] ; if ( unit == 'k' || unit == 'm' || unit == 'K' || unit == 'M' ) { buf [ strlen ( buf ) - 1 ] = '\\0' ; size_max = atoi ( buf ) ; if ( unit == 'k' || unit == 'K' ) size_max *= 1024 ; if ( unit == 'm' || unit == 'M' ) size_max *= 1024 * 1024 ; settings . item_size_max = size_max ; } else { settings . item_size_max = atoi ( buf ) ; } free ( buf ) ; break ; case 'S' : # ifndef ENABLE_SASL fprintf ( stderr , "This<S2SV_blank>server<S2SV_blank>is<S2SV_blank>not<S2SV_blank>built<S2SV_blank>with<S2SV_blank>SASL<S2SV_blank>support.\\n" ) ; exit ( EX_USAGE ) ; # endif settings . sasl = true ; break ; case 'F' : settings . flush_enabled = false ; break ; case 'X' : settings . dump_enabled = false ; break ; case 'o' : subopts_orig = subopts = strdup ( optarg ) ; while ( * subopts != '\\0' ) { switch ( getsubopt ( & subopts , subopts_tokens , & subopts_value ) ) { case MAXCONNS_FAST : settings . maxconns_fast = true ; break ; case HASHPOWER_INIT : if ( subopts_value == NULL ) { fprintf ( stderr , "Missing<S2SV_blank>numeric<S2SV_blank>argument<S2SV_blank>for<S2SV_blank>hashpower\\n" ) ; return 1 ; } settings . hashpower_init = atoi ( subopts_value ) ; if ( settings . hashpower_init < 12 ) { fprintf ( stderr , "Initial<S2SV_blank>hashtable<S2SV_blank>multiplier<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>too<S2SV_blank>low\\n" , settings . hashpower_init ) ; return 1 ; } else if ( settings . hashpower_init > 32 ) { fprintf ( stderr , "Initial<S2SV_blank>hashtable<S2SV_blank>multiplier<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>too<S2SV_blank>high\\n" "Choose<S2SV_blank>a<S2SV_blank>value<S2SV_blank>based<S2SV_blank>on<S2SV_blank>\\"STAT<S2SV_blank>hash_power_level\\"<S2SV_blank>from<S2SV_blank>a<S2SV_blank>running<S2SV_blank>instance\\n" , settings . hashpower_init ) ; return 1 ; } break ; case NO_HASHEXPAND : start_assoc_maint = false ; break ; case SLAB_REASSIGN : settings . slab_reassign = true ; break ; case SLAB_AUTOMOVE : if ( subopts_value == NULL ) { settings . slab_automove = 1 ; break ; } settings . slab_automove = atoi ( subopts_value ) ; if ( settings . slab_automove < 0 || settings . slab_automove > 2 ) { fprintf ( stderr , "slab_automove<S2SV_blank>must<S2SV_blank>be<S2SV_blank>between<S2SV_blank>0<S2SV_blank>and<S2SV_blank>2\\n" ) ; return 1 ; } break ; case SLAB_AUTOMOVE_RATIO : if ( subopts_value == NULL ) { fprintf ( stderr , "Missing<S2SV_blank>slab_automove_ratio<S2SV_blank>argument\\n" ) ; return 1 ; } settings . slab_automove_ratio = atof ( subopts_value ) ; if ( settings . slab_automove_ratio <= 0 || settings . slab_automove_ratio > 1 ) { fprintf ( stderr , "slab_automove_ratio<S2SV_blank>must<S2SV_blank>be<S2SV_blank>><S2SV_blank>0<S2SV_blank>and<S2SV_blank><<S2SV_blank>1\\n" ) ; return 1 ; } break ; case SLAB_AUTOMOVE_WINDOW : if ( subopts_value == NULL ) { fprintf ( stderr , "Missing<S2SV_blank>slab_automove_window<S2SV_blank>argument\\n" ) ; return 1 ; } settings . slab_automove_window = atoi ( subopts_value ) ; if ( settings . slab_automove_window < 3 ) { fprintf ( stderr , "slab_automove_window<S2SV_blank>must<S2SV_blank>be<S2SV_blank>><S2SV_blank>2\\n" ) ; return 1 ; } break ; case TAIL_REPAIR_TIME : if ( subopts_value == NULL ) { fprintf ( stderr , "Missing<S2SV_blank>numeric<S2SV_blank>argument<S2SV_blank>for<S2SV_blank>tail_repair_time\\n" ) ; return 1 ; } settings . tail_repair_time = atoi ( subopts_value ) ; if ( settings . tail_repair_time < 10 ) { fprintf ( stderr , "Cannot<S2SV_blank>set<S2SV_blank>tail_repair_time<S2SV_blank>to<S2SV_blank>less<S2SV_blank>than<S2SV_blank>10<S2SV_blank>seconds\\n" ) ; return 1 ; } break ; case HASH_ALGORITHM : if ( subopts_value == NULL ) { fprintf ( stderr , "Missing<S2SV_blank>hash_algorithm<S2SV_blank>argument\\n" ) ; return 1 ; } ; if ( strcmp ( subopts_value , "jenkins" ) == 0 ) { hash_type = JENKINS_HASH ; } else if ( strcmp ( subopts_value , "murmur3" ) == 0 ) { hash_type = MURMUR3_HASH ; } else { fprintf ( stderr , "Unknown<S2SV_blank>hash_algorithm<S2SV_blank>option<S2SV_blank>(jenkins,<S2SV_blank>murmur3)\\n" ) ; return 1 ; } break ; case LRU_CRAWLER : start_lru_crawler = true ; break ; case LRU_CRAWLER_SLEEP : if ( subopts_value == NULL ) { fprintf ( stderr , "Missing<S2SV_blank>lru_crawler_sleep<S2SV_blank>value\\n" ) ; return 1 ; } settings . lru_crawler_sleep = atoi ( subopts_value ) ; if ( settings . lru_crawler_sleep > 1000000 || settings . lru_crawler_sleep < 0 ) { fprintf ( stderr , "LRU<S2SV_blank>crawler<S2SV_blank>sleep<S2SV_blank>must<S2SV_blank>be<S2SV_blank>between<S2SV_blank>0<S2SV_blank>and<S2SV_blank>1<S2SV_blank>second\\n" ) ; return 1 ; } break ; case LRU_CRAWLER_TOCRAWL : if ( subopts_value == NULL ) { fprintf ( stderr , "Missing<S2SV_blank>lru_crawler_tocrawl<S2SV_blank>value\\n" ) ; return 1 ; } if ( ! safe_strtoul ( subopts_value , & tocrawl ) ) { fprintf ( stderr , "lru_crawler_tocrawl<S2SV_blank>takes<S2SV_blank>a<S2SV_blank>numeric<S2SV_blank>32bit<S2SV_blank>value\\n" ) ; return 1 ; } settings . lru_crawler_tocrawl = tocrawl ; break ; case LRU_MAINTAINER : start_lru_maintainer = true ; settings . lru_segmented = true ; break ; case HOT_LRU_PCT : if ( subopts_value == NULL ) { fprintf ( stderr , "Missing<S2SV_blank>hot_lru_pct<S2SV_blank>argument\\n" ) ; return 1 ; } settings . hot_lru_pct = atoi ( subopts_value ) ; if ( settings . hot_lru_pct < 1 || settings . hot_lru_pct >= 80 ) { fprintf ( stderr , "hot_lru_pct<S2SV_blank>must<S2SV_blank>be<S2SV_blank>><S2SV_blank>1<S2SV_blank>and<S2SV_blank><<S2SV_blank>80\\n" ) ; return 1 ; } break ; case WARM_LRU_PCT : if ( subopts_value == NULL ) { fprintf ( stderr , "Missing<S2SV_blank>warm_lru_pct<S2SV_blank>argument\\n" ) ; return 1 ; } settings . warm_lru_pct = atoi ( subopts_value ) ; if ( settings . warm_lru_pct < 1 || settings . warm_lru_pct >= 80 ) { fprintf ( stderr , "warm_lru_pct<S2SV_blank>must<S2SV_blank>be<S2SV_blank>><S2SV_blank>1<S2SV_blank>and<S2SV_blank><<S2SV_blank>80\\n" ) ; return 1 ; } break ; case HOT_MAX_FACTOR : if ( subopts_value == NULL ) { fprintf ( stderr , "Missing<S2SV_blank>hot_max_factor<S2SV_blank>argument\\n" ) ; return 1 ; } settings . hot_max_factor = atof ( subopts_value ) ; if ( settings . hot_max_factor <= 0 ) { fprintf ( stderr , "hot_max_factor<S2SV_blank>must<S2SV_blank>be<S2SV_blank>><S2SV_blank>0\\n" ) ; return 1 ; } break ; case WARM_MAX_FACTOR : if ( subopts_value == NULL ) { fprintf ( stderr , "Missing<S2SV_blank>warm_max_factor<S2SV_blank>argument\\n" ) ; return 1 ; } settings . warm_max_factor = atof ( subopts_value ) ; if ( settings . warm_max_factor <= 0 ) { fprintf ( stderr , "warm_max_factor<S2SV_blank>must<S2SV_blank>be<S2SV_blank>><S2SV_blank>0\\n" ) ; return 1 ; } break ; case TEMPORARY_TTL : if ( subopts_value == NULL ) { fprintf ( stderr , "Missing<S2SV_blank>temporary_ttl<S2SV_blank>argument\\n" ) ; return 1 ; } settings . temp_lru = true ; settings . temporary_ttl = atoi ( subopts_value ) ; break ; case IDLE_TIMEOUT : if ( subopts_value == NULL ) { fprintf ( stderr , "Missing<S2SV_blank>numeric<S2SV_blank>argument<S2SV_blank>for<S2SV_blank>idle_timeout\\n" ) ; return 1 ; } settings . idle_timeout = atoi ( subopts_value ) ; break ; case WATCHER_LOGBUF_SIZE : if ( subopts_value == NULL ) { fprintf ( stderr , "Missing<S2SV_blank>watcher_logbuf_size<S2SV_blank>argument\\n" ) ; return 1 ; } if ( ! safe_strtoul ( subopts_value , & settings . logger_watcher_buf_size ) ) { fprintf ( stderr , "could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>watcher_logbuf_size\\n" ) ; return 1 ; } settings . logger_watcher_buf_size *= 1024 ; break ; case WORKER_LOGBUF_SIZE : if ( subopts_value == NULL ) { fprintf ( stderr , "Missing<S2SV_blank>worker_logbuf_size<S2SV_blank>argument\\n" ) ; return 1 ; } if ( ! safe_strtoul ( subopts_value , & settings . logger_buf_size ) ) { fprintf ( stderr , "could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>worker_logbuf_size\\n" ) ; return 1 ; } settings . logger_buf_size *= 1024 ; case SLAB_SIZES : slab_sizes_unparsed = subopts_value ; break ; case SLAB_CHUNK_MAX : if ( subopts_value == NULL ) { fprintf ( stderr , "Missing<S2SV_blank>slab_chunk_max<S2SV_blank>argument\\n" ) ; } if ( ! safe_strtol ( subopts_value , & settings . slab_chunk_size_max ) ) { fprintf ( stderr , "could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>slab_chunk_max\\n" ) ; } slab_chunk_size_changed = true ; break ; case TRACK_SIZES : item_stats_sizes_init ( ) ; break ; case NO_INLINE_ASCII_RESP : settings . inline_ascii_response = false ; break ; case INLINE_ASCII_RESP : settings . inline_ascii_response = true ; break ; case NO_CHUNKED_ITEMS : settings . slab_chunk_size_max = settings . slab_page_size ; break ; case NO_SLAB_REASSIGN : settings . slab_reassign = false ; break ; case NO_SLAB_AUTOMOVE : settings . slab_automove = 0 ; break ; case NO_MAXCONNS_FAST : settings . maxconns_fast = false ; break ; case NO_LRU_CRAWLER : settings . lru_crawler = false ; start_lru_crawler = false ; break ; case NO_LRU_MAINTAINER : start_lru_maintainer = false ; settings . lru_segmented = false ; break ; # ifdef EXTSTORE case EXT_PAGE_SIZE : if ( subopts_value == NULL ) { fprintf ( stderr , "Missing<S2SV_blank>ext_page_size<S2SV_blank>argument\\n" ) ; return 1 ; } if ( ! safe_strtoul ( subopts_value , & ext_cf . page_size ) ) { fprintf ( stderr , "could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_page_size\\n" ) ; return 1 ; } ext_cf . page_size *= 1024 * 1024 ; break ; case EXT_PAGE_COUNT : if ( subopts_value == NULL ) { fprintf ( stderr , "Missing<S2SV_blank>ext_page_count<S2SV_blank>argument\\n" ) ; return 1 ; } if ( ! safe_strtoul ( subopts_value , & ext_cf . page_count ) ) { fprintf ( stderr , "could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_page_count\\n" ) ; return 1 ; } break ; case EXT_WBUF_SIZE : if ( subopts_value == NULL ) { fprintf ( stderr , "Missing<S2SV_blank>ext_wbuf_size<S2SV_blank>argument\\n" ) ; return 1 ; } if ( ! safe_strtoul ( subopts_value , & ext_cf . wbuf_size ) ) { fprintf ( stderr , "could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_wbuf_size\\n" ) ; return 1 ; } ext_cf . wbuf_size *= 1024 * 1024 ; settings . ext_wbuf_size = ext_cf . wbuf_size ; break ; case EXT_THREADS : if ( subopts_value == NULL ) { fprintf ( stderr , "Missing<S2SV_blank>ext_threads<S2SV_blank>argument\\n" ) ; return 1 ; } if ( ! safe_strtoul ( subopts_value , & ext_cf . io_threadcount ) ) { fprintf ( stderr , "could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_threads\\n" ) ; return 1 ; } break ; case EXT_IO_DEPTH : if ( subopts_value == NULL ) { fprintf ( stderr , "Missing<S2SV_blank>ext_io_depth<S2SV_blank>argument\\n" ) ; return 1 ; } if ( ! safe_strtoul ( subopts_value , & ext_cf . io_depth ) ) { fprintf ( stderr , "could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_io_depth\\n" ) ; return 1 ; } break ; case EXT_ITEM_SIZE : if ( subopts_value == NULL ) { fprintf ( stderr , "Missing<S2SV_blank>ext_item_size<S2SV_blank>argument\\n" ) ; return 1 ; } if ( ! safe_strtoul ( subopts_value , & settings . ext_item_size ) ) { fprintf ( stderr , "could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_item_size\\n" ) ; return 1 ; } break ; case EXT_ITEM_AGE : if ( subopts_value == NULL ) { fprintf ( stderr , "Missing<S2SV_blank>ext_item_age<S2SV_blank>argument\\n" ) ; return 1 ; } if ( ! safe_strtoul ( subopts_value , & settings . ext_item_age ) ) { fprintf ( stderr , "could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_item_age\\n" ) ; return 1 ; } break ; case EXT_LOW_TTL : if ( subopts_value == NULL ) { fprintf ( stderr , "Missing<S2SV_blank>ext_low_ttl<S2SV_blank>argument\\n" ) ; return 1 ; } if ( ! safe_strtoul ( subopts_value , & settings . ext_low_ttl ) ) { fprintf ( stderr , "could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_low_ttl\\n" ) ; return 1 ; } break ; case EXT_RECACHE_RATE : if ( subopts_value == NULL ) { fprintf ( stderr , "Missing<S2SV_blank>ext_recache_rate<S2SV_blank>argument\\n" ) ; return 1 ; } if ( ! safe_strtoul ( subopts_value , & settings . ext_recache_rate ) ) { fprintf ( stderr , "could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_recache_rate\\n" ) ; return 1 ; } break ; case EXT_COMPACT_UNDER : if ( subopts_value == NULL ) { fprintf ( stderr , "Missing<S2SV_blank>ext_compact_under<S2SV_blank>argument\\n" ) ; return 1 ; } if ( ! safe_strtoul ( subopts_value , & settings . ext_compact_under ) ) { fprintf ( stderr , "could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_compact_under\\n" ) ; return 1 ; } break ; case EXT_DROP_UNDER : if ( subopts_value == NULL ) { fprintf ( stderr , "Missing<S2SV_blank>ext_drop_under<S2SV_blank>argument\\n" ) ; return 1 ; } if ( ! safe_strtoul ( subopts_value , & settings . ext_drop_under ) ) { fprintf ( stderr , "could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_drop_under\\n" ) ; return 1 ; } break ; case EXT_MAX_FRAG : if ( subopts_value == NULL ) { fprintf ( stderr , "Missing<S2SV_blank>ext_max_frag<S2SV_blank>argument\\n" ) ; return 1 ; } if ( ! safe_strtod ( subopts_value , & settings . ext_max_frag ) ) { fprintf ( stderr , "could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_max_frag\\n" ) ; return 1 ; } break ; case SLAB_AUTOMOVE_FREERATIO : if ( subopts_value == NULL ) { fprintf ( stderr , "Missing<S2SV_blank>slab_automove_freeratio<S2SV_blank>argument\\n" ) ; return 1 ; } if ( ! safe_strtod ( subopts_value , & settings . slab_automove_freeratio ) ) { fprintf ( stderr , "could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>slab_automove_freeratio\\n" ) ; return 1 ; } break ; case EXT_DROP_UNREAD : settings . ext_drop_unread = true ; break ; case EXT_PATH : storage_file = strdup ( subopts_value ) ; break ; # endif case MODERN : break ; case NO_MODERN : if ( ! slab_chunk_size_changed ) { settings . slab_chunk_size_max = settings . slab_page_size ; } settings . slab_reassign = false ; settings . slab_automove = 0 ; settings . maxconns_fast = false ; settings . inline_ascii_response = true ; settings . lru_segmented = false ; hash_type = JENKINS_HASH ; start_lru_crawler = false ; start_lru_maintainer = false ; break ; case NO_DROP_PRIVILEGES : settings . drop_privileges = false ; break ; # ifdef MEMCACHED_DEBUG case RELAXED_PRIVILEGES : settings . relaxed_privileges = true ; break ; # endif default : printf ( "Illegal<S2SV_blank>suboption<S2SV_blank>\\"%s\\"\\n" , subopts_value ) ; return 1 ; } } free ( subopts_orig ) ; break ; default : fprintf ( stderr , "Illegal<S2SV_blank>argument<S2SV_blank>\\"%c\\"\\n" , c ) ; return 1 ; } } if ( settings . item_size_max < 1024 ) { fprintf ( stderr , "Item<S2SV_blank>max<S2SV_blank>size<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>less<S2SV_blank>than<S2SV_blank>1024<S2SV_blank>bytes.\\n" ) ; exit ( EX_USAGE ) ; } if ( settings . item_size_max > ( settings . maxbytes / 2 ) ) { fprintf ( stderr , "Cannot<S2SV_blank>set<S2SV_blank>item<S2SV_blank>size<S2SV_blank>limit<S2SV_blank>higher<S2SV_blank>than<S2SV_blank>1/2<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>max.\\n" ) ; exit ( EX_USAGE ) ; } if ( settings . item_size_max > ( 1024 * 1024 * 1024 ) ) { fprintf ( stderr , "Cannot<S2SV_blank>set<S2SV_blank>item<S2SV_blank>size<S2SV_blank>limit<S2SV_blank>higher<S2SV_blank>than<S2SV_blank>a<S2SV_blank>gigabyte.\\n" ) ; exit ( EX_USAGE ) ; } if ( settings . item_size_max > 1024 * 1024 ) { if ( ! slab_chunk_size_changed ) { settings . slab_chunk_size_max = settings . slab_page_size / 2 ; } } if ( settings . slab_chunk_size_max > settings . item_size_max ) { fprintf ( stderr , "slab_chunk_max<S2SV_blank>(bytes:<S2SV_blank>%d)<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>-I<S2SV_blank>(item_size_max<S2SV_blank>%d)\\n" , settings . slab_chunk_size_max , settings . item_size_max ) ; exit ( EX_USAGE ) ; } if ( settings . item_size_max % settings . slab_chunk_size_max != 0 ) { fprintf ( stderr , "-I<S2SV_blank>(item_size_max:<S2SV_blank>%d)<S2SV_blank>must<S2SV_blank>be<S2SV_blank>evenly<S2SV_blank>divisible<S2SV_blank>by<S2SV_blank>slab_chunk_max<S2SV_blank>(bytes:<S2SV_blank>%d)\\n" , settings . item_size_max , settings . slab_chunk_size_max ) ; exit ( EX_USAGE ) ; } if ( settings . slab_page_size % settings . slab_chunk_size_max != 0 ) { fprintf ( stderr , "slab_chunk_max<S2SV_blank>(bytes:<S2SV_blank>%d)<S2SV_blank>must<S2SV_blank>divide<S2SV_blank>evenly<S2SV_blank>into<S2SV_blank>%d<S2SV_blank>(slab_page_size)\\n" , settings . slab_chunk_size_max , settings . slab_page_size ) ; exit ( EX_USAGE ) ; } # ifdef EXTSTORE if ( storage_file ) { if ( settings . item_size_max > ext_cf . wbuf_size ) { fprintf ( stderr , "-I<S2SV_blank>(item_size_max:<S2SV_blank>%d)<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>ext_wbuf_size:<S2SV_blank>%d\\n" , settings . item_size_max , ext_cf . wbuf_size ) ; exit ( EX_USAGE ) ; } if ( settings . inline_ascii_response ) { fprintf ( stderr , "Cannot<S2SV_blank>use<S2SV_blank>inline_ascii_response<S2SV_blank>with<S2SV_blank>extstore<S2SV_blank>enabled\\n" ) ; exit ( EX_USAGE ) ; } if ( settings . udpport ) { fprintf ( stderr , "Cannot<S2SV_blank>use<S2SV_blank>UDP<S2SV_blank>with<S2SV_blank>extstore<S2SV_blank>enabled<S2SV_blank>(-U<S2SV_blank>0<S2SV_blank>to<S2SV_blank>disable)\\n" ) ; exit ( EX_USAGE ) ; } } # endif if ( slab_sizes_unparsed != NULL ) { if ( _parse_slab_sizes ( slab_sizes_unparsed , slab_sizes ) ) { use_slab_sizes = true ; } else { exit ( EX_USAGE ) ; } } if ( settings . hot_lru_pct + settings . warm_lru_pct > 80 ) { fprintf ( stderr , "hot_lru_pct<S2SV_blank>+<S2SV_blank>warm_lru_pct<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>more<S2SV_blank>than<S2SV_blank>80%%<S2SV_blank>combined\\n" ) ; exit ( EX_USAGE ) ; } if ( settings . temp_lru && ! start_lru_maintainer ) { fprintf ( stderr , "temporary_ttl<S2SV_blank>requires<S2SV_blank>lru_maintainer<S2SV_blank>to<S2SV_blank>be<S2SV_blank>enabled\\n" ) ; exit ( EX_USAGE ) ; } if ( hash_init ( hash_type ) != 0 ) { fprintf ( stderr , "Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>hash_algorithm!\\n" ) ; exit ( EX_USAGE ) ; } if ( settings . inter != NULL && strchr ( settings . inter , ',' ) ) { settings . num_threads_per_udp = 1 ; } else { settings . num_threads_per_udp = settings . num_threads ; } if ( settings . sasl ) { if ( ! protocol_specified ) { settings . binding_protocol = binary_prot ; } else { if ( settings . binding_protocol != binary_prot ) { fprintf ( stderr , "ERROR:<S2SV_blank>You<S2SV_blank>cannot<S2SV_blank>allow<S2SV_blank>the<S2SV_blank>ASCII<S2SV_blank>protocol<S2SV_blank>while<S2SV_blank>using<S2SV_blank>SASL.\\n" ) ; exit ( EX_USAGE ) ; } } } <S2SV_StartBug> if ( tcp_specified && settings . port != 0 && ! udp_specified ) { <S2SV_EndBug> settings . udpport = settings . port ; } else if ( udp_specified && settings . udpport != 0 && ! tcp_specified ) { settings . port = settings . udpport ; } if ( maxcore != 0 ) { struct rlimit rlim_new ; if ( getrlimit ( RLIMIT_CORE , & rlim ) == 0 ) { rlim_new . rlim_cur = rlim_new . rlim_max = RLIM_INFINITY ; if ( setrlimit ( RLIMIT_CORE , & rlim_new ) != 0 ) { rlim_new . rlim_cur = rlim_new . rlim_max = rlim . rlim_max ; ( void ) setrlimit ( RLIMIT_CORE , & rlim_new ) ; } } if ( ( getrlimit ( RLIMIT_CORE , & rlim ) != 0 ) || rlim . rlim_cur == 0 ) { fprintf ( stderr , "failed<S2SV_blank>to<S2SV_blank>ensure<S2SV_blank>corefile<S2SV_blank>creation\\n" ) ; exit ( EX_OSERR ) ; } } if ( getrlimit ( RLIMIT_NOFILE , & rlim ) != 0 ) { fprintf ( stderr , "failed<S2SV_blank>to<S2SV_blank>getrlimit<S2SV_blank>number<S2SV_blank>of<S2SV_blank>files\\n" ) ; exit ( EX_OSERR ) ; } else { rlim . rlim_cur = settings . maxconns ; rlim . rlim_max = settings . maxconns ; if ( setrlimit ( RLIMIT_NOFILE , & rlim ) != 0 ) { fprintf ( stderr , "failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>rlimit<S2SV_blank>for<S2SV_blank>open<S2SV_blank>files.<S2SV_blank>Try<S2SV_blank>starting<S2SV_blank>as<S2SV_blank>root<S2SV_blank>or<S2SV_blank>requesting<S2SV_blank>smaller<S2SV_blank>maxconns<S2SV_blank>value.\\n" ) ; exit ( EX_OSERR ) ; } } if ( getuid ( ) == 0 || geteuid ( ) == 0 ) { if ( username == 0 || * username == '\\0' ) { fprintf ( stderr , "can\'t<S2SV_blank>run<S2SV_blank>as<S2SV_blank>root<S2SV_blank>without<S2SV_blank>the<S2SV_blank>-u<S2SV_blank>switch\\n" ) ; exit ( EX_USAGE ) ; } if ( ( pw = getpwnam ( username ) ) == 0 ) { fprintf ( stderr , "can\'t<S2SV_blank>find<S2SV_blank>the<S2SV_blank>user<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>switch<S2SV_blank>to\\n" , username ) ; exit ( EX_NOUSER ) ; } if ( setgid ( pw -> pw_gid ) < 0 || setuid ( pw -> pw_uid ) < 0 ) { fprintf ( stderr , "failed<S2SV_blank>to<S2SV_blank>assume<S2SV_blank>identity<S2SV_blank>of<S2SV_blank>user<S2SV_blank>%s\\n" , username ) ; exit ( EX_OSERR ) ; } } if ( settings . sasl ) { init_sasl ( ) ; } if ( do_daemonize ) { if ( sigignore ( SIGHUP ) == - 1 ) { perror ( "Failed<S2SV_blank>to<S2SV_blank>ignore<S2SV_blank>SIGHUP" ) ; } if ( daemonize ( maxcore , settings . verbose ) == - 1 ) { fprintf ( stderr , "failed<S2SV_blank>to<S2SV_blank>daemon()<S2SV_blank>in<S2SV_blank>order<S2SV_blank>to<S2SV_blank>daemonize\\n" ) ; exit ( EXIT_FAILURE ) ; } } if ( lock_memory ) { # ifdef HAVE_MLOCKALL int res = mlockall ( MCL_CURRENT | MCL_FUTURE ) ; if ( res != 0 ) { fprintf ( stderr , "warning:<S2SV_blank>-k<S2SV_blank>invalid,<S2SV_blank>mlockall()<S2SV_blank>failed:<S2SV_blank>%s\\n" , strerror ( errno ) ) ; } # else fprintf ( stderr , "warning:<S2SV_blank>-k<S2SV_blank>invalid,<S2SV_blank>mlockall()<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>on<S2SV_blank>this<S2SV_blank>platform.<S2SV_blank><S2SV_blank>proceeding<S2SV_blank>without.\\n" ) ; # endif } # if defined ( LIBEVENT_VERSION_NUMBER ) && LIBEVENT_VERSION_NUMBER >= 0x02000101 struct event_config * ev_config ; ev_config = event_config_new ( ) ; event_config_set_flag ( ev_config , EVENT_BASE_FLAG_NOLOCK ) ; main_base = event_base_new_with_config ( ev_config ) ; event_config_free ( ev_config ) ; # else main_base = event_init ( ) ; # endif logger_init ( ) ; stats_init ( ) ; assoc_init ( settings . hashpower_init ) ; conn_init ( ) ; slabs_init ( settings . maxbytes , settings . factor , preallocate , use_slab_sizes ? slab_sizes : NULL ) ; # ifdef EXTSTORE if ( storage_file ) { enum extstore_res eres ; if ( settings . ext_compact_under == 0 ) { settings . ext_compact_under = ext_cf . page_count / 4 ; settings . ext_drop_under = ext_cf . page_count / 4 ; } crc32c_init ( ) ; for ( int x = 0 ; x < MAX_NUMBER_OF_SLAB_CLASSES ; x ++ ) { settings . ext_free_memchunks [ x ] = 0 ; } storage = extstore_init ( storage_file , & ext_cf , & eres ) ; if ( storage == NULL ) { fprintf ( stderr , "Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>external<S2SV_blank>storage:<S2SV_blank>%s\\n" , extstore_err ( eres ) ) ; if ( eres == EXTSTORE_INIT_OPEN_FAIL ) { perror ( "extstore<S2SV_blank>open" ) ; } exit ( EXIT_FAILURE ) ; } ext_storage = storage ; slabs_prefill_global ( ) ; } # endif if ( sigignore ( SIGPIPE ) == - 1 ) { perror ( "failed<S2SV_blank>to<S2SV_blank>ignore<S2SV_blank>SIGPIPE;<S2SV_blank>sigaction" ) ; exit ( EX_OSERR ) ; } # ifdef EXTSTORE slabs_set_storage ( storage ) ; memcached_thread_init ( settings . num_threads , storage ) ; init_lru_crawler ( storage ) ; # else memcached_thread_init ( settings . num_threads , NULL ) ; init_lru_crawler ( NULL ) ; # endif if ( start_assoc_maint && start_assoc_maintenance_thread ( ) == - 1 ) { exit ( EXIT_FAILURE ) ; } if ( start_lru_crawler && start_item_crawler_thread ( ) != 0 ) { fprintf ( stderr , "Failed<S2SV_blank>to<S2SV_blank>enable<S2SV_blank>LRU<S2SV_blank>crawler<S2SV_blank>thread\\n" ) ; exit ( EXIT_FAILURE ) ; } # ifdef EXTSTORE if ( storage && start_storage_compact_thread ( storage ) != 0 ) { fprintf ( stderr , "Failed<S2SV_blank>to<S2SV_blank>start<S2SV_blank>storage<S2SV_blank>compaction<S2SV_blank>thread\\n" ) ; exit ( EXIT_FAILURE ) ; } if ( start_lru_maintainer && start_lru_maintainer_thread ( storage ) != 0 ) { # else if ( start_lru_maintainer && start_lru_maintainer_thread ( NULL ) != 0 ) { # endif fprintf ( stderr , "Failed<S2SV_blank>to<S2SV_blank>enable<S2SV_blank>LRU<S2SV_blank>maintainer<S2SV_blank>thread\\n" ) ; return 1 ; } if ( settings . slab_reassign && start_slab_maintenance_thread ( ) == - 1 ) { exit ( EXIT_FAILURE ) ; } if ( settings . idle_timeout && start_conn_timeout_thread ( ) == - 1 ) { exit ( EXIT_FAILURE ) ; } clock_handler ( 0 , 0 , 0 ) ; if ( settings . socketpath != NULL ) { errno = 0 ; if ( server_socket_unix ( settings . socketpath , settings . access ) ) { vperror ( "failed<S2SV_blank>to<S2SV_blank>listen<S2SV_blank>on<S2SV_blank>UNIX<S2SV_blank>socket:<S2SV_blank>%s" , settings . socketpath ) ; exit ( EX_OSERR ) ; } } if ( settings . socketpath == NULL ) { const char * portnumber_filename = getenv ( "MEMCACHED_PORT_FILENAME" ) ; char * temp_portnumber_filename = NULL ; size_t len ; FILE * portnumber_file = NULL ; if ( portnumber_filename != NULL ) { len = strlen ( portnumber_filename ) + 4 + 1 ; temp_portnumber_filename = malloc ( len ) ; snprintf ( temp_portnumber_filename , len , "%s.lck" , portnumber_filename ) ; portnumber_file = fopen ( temp_portnumber_filename , "a" ) ; if ( portnumber_file == NULL ) { fprintf ( stderr , "Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>\\"%s\\":<S2SV_blank>%s\\n" , temp_portnumber_filename , strerror ( errno ) ) ; } } errno = 0 ; if ( settings . port && server_sockets ( settings . port , tcp_transport , portnumber_file ) ) { vperror ( "failed<S2SV_blank>to<S2SV_blank>listen<S2SV_blank>on<S2SV_blank>TCP<S2SV_blank>port<S2SV_blank>%d" , settings . port ) ; exit ( EX_OSERR ) ; } errno = 0 ; if ( settings . udpport && server_sockets ( settings . udpport , udp_transport , portnumber_file ) ) { vperror ( "failed<S2SV_blank>to<S2SV_blank>listen<S2SV_blank>on<S2SV_blank>UDP<S2SV_blank>port<S2SV_blank>%d" , settings . udpport ) ; exit ( EX_OSERR ) ; } if ( portnumber_file ) { fclose ( portnumber_file ) ; rename ( temp_portnumber_filename , portnumber_filename ) ; } if ( temp_portnumber_filename ) free ( temp_portnumber_filename ) ; } usleep ( 1000 ) ; if ( stats_state . curr_conns + stats_state . reserved_fds >= settings . maxconns - 1 ) { fprintf ( stderr , "Maxconns<S2SV_blank>setting<S2SV_blank>is<S2SV_blank>too<S2SV_blank>low,<S2SV_blank>use<S2SV_blank>-c<S2SV_blank>to<S2SV_blank>increase.\\n" ) ; exit ( EXIT_FAILURE ) ; } if ( pid_file != NULL ) { save_pid ( pid_file ) ; } if ( settings . drop_privileges ) { drop_privileges ( ) ; } uriencode_init ( ) ; if ( event_base_loop ( main_base , 0 ) != 0 ) { retval = EXIT_FAILURE ; } stop_assoc_maintenance_thread ( ) ; if ( do_daemonize ) remove_pidfile ( pid_file ) ; if ( settings . inter ) free ( settings . inter ) ; if ( l_socket ) free ( l_socket ) ; if ( u_socket ) free ( u_socket ) ; event_base_free ( main_base ) ; return retval ; }
CWE-20 static void settings_init ( void ) { settings . use_cas = true ; settings . access = 0700 ; settings . port = 11211 ; <S2SV_StartBug> settings . udpport = 11211 ; <S2SV_EndBug> settings . inter = NULL ; settings . maxbytes = 64 * 1024 * 1024 ; settings . maxconns = 1024 ; settings . verbose = 0 ; settings . oldest_live = 0 ; settings . oldest_cas = 0 ; settings . evict_to_free = 1 ; settings . socketpath = NULL ; settings . factor = 1.25 ; settings . chunk_size = 48 ; settings . num_threads = 4 ; settings . num_threads_per_udp = 0 ; settings . prefix_delimiter = ':' ; settings . detail_enabled = 0 ; settings . reqs_per_event = 20 ; settings . backlog = 1024 ; settings . binding_protocol = negotiating_prot ; settings . item_size_max = 1024 * 1024 ; settings . slab_page_size = 1024 * 1024 ; settings . slab_chunk_size_max = settings . slab_page_size / 2 ; settings . sasl = false ; settings . maxconns_fast = true ; settings . lru_crawler = false ; settings . lru_crawler_sleep = 100 ; settings . lru_crawler_tocrawl = 0 ; settings . lru_maintainer_thread = false ; settings . lru_segmented = true ; settings . hot_lru_pct = 20 ; settings . warm_lru_pct = 40 ; settings . hot_max_factor = 0.2 ; settings . warm_max_factor = 2.0 ; settings . inline_ascii_response = false ; settings . temp_lru = false ; settings . temporary_ttl = 61 ; settings . idle_timeout = 0 ; settings . hashpower_init = 0 ; settings . slab_reassign = true ; settings . slab_automove = 1 ; settings . slab_automove_ratio = 0.8 ; settings . slab_automove_window = 30 ; settings . shutdown_command = false ; settings . tail_repair_time = TAIL_REPAIR_TIME_DEFAULT ; settings . flush_enabled = true ; settings . dump_enabled = true ; settings . crawls_persleep = 1000 ; settings . logger_watcher_buf_size = LOGGER_WATCHER_BUF_SIZE ; settings . logger_buf_size = LOGGER_BUF_SIZE ; settings . drop_privileges = true ; # ifdef MEMCACHED_DEBUG settings . relaxed_privileges = false ; # endif }
CWE-119 void ParseNameValue ( const char * buffer , int bufsize , struct NameValueParserData * data ) { struct xmlparser parser ; <S2SV_StartBug> data -> l_head = NULL ; <S2SV_EndBug> data -> portListing = NULL ; data -> portListingLength = 0 ; parser . xmlstart = buffer ; parser . xmlsize = bufsize ; parser . data = data ; parser . starteltfunc = NameValueParserStartElt ; parser . endeltfunc = NameValueParserEndElt ; parser . datafunc = NameValueParserGetData ; parser . attfunc = 0 ; parsexml ( & parser ) ; }
CWE-119 void ParseNameValue ( const char * buffer , int bufsize , struct NameValueParserData * data ) { struct xmlparser parser ; <S2SV_StartBug> data -> l_head = NULL ; <S2SV_EndBug> data -> portListing = NULL ; data -> portListingLength = 0 ; parser . xmlstart = buffer ; parser . xmlsize = bufsize ; parser . data = data ; parser . starteltfunc = NameValueParserStartElt ; parser . endeltfunc = NameValueParserEndElt ; parser . datafunc = NameValueParserGetData ; parser . attfunc = 0 ; parsexml ( & parser ) ; }
CWE-416 static int updateDevice ( const struct header * headers , time_t t ) { struct device * * pp = & devlist ; struct device * p = * pp ; while ( p ) { if ( p -> headers [ HEADER_NT ] . l == headers [ HEADER_NT ] . l && ( 0 == memcmp ( p -> headers [ HEADER_NT ] . p , headers [ HEADER_NT ] . p , headers [ HEADER_NT ] . l ) ) && p -> headers [ HEADER_USN ] . l == headers [ HEADER_USN ] . l && ( 0 == memcmp ( p -> headers [ HEADER_USN ] . p , headers [ HEADER_USN ] . p , headers [ HEADER_USN ] . l ) ) ) { syslog ( LOG_DEBUG , "device<S2SV_blank>updated<S2SV_blank>:<S2SV_blank>%.*s" , headers [ HEADER_USN ] . l , headers [ HEADER_USN ] . p ) ; p -> t = t ; if ( headers [ HEADER_LOCATION ] . l > p -> headers [ HEADER_LOCATION ] . l ) { struct device * tmp ; tmp = realloc ( p , sizeof ( struct device ) + headers [ 0 ] . l + headers [ 1 ] . l + headers [ 2 ] . l ) ; if ( ! tmp ) { syslog ( LOG_ERR , "updateDevice()<S2SV_blank>:<S2SV_blank>memory<S2SV_blank>allocation<S2SV_blank>error" ) ; <S2SV_StartBug> free ( p ) ; <S2SV_EndBug> return 0 ; } p = tmp ; * pp = p ; } memcpy ( p -> data + p -> headers [ 0 ] . l + p -> headers [ 1 ] . l , headers [ 2 ] . p , headers [ 2 ] . l ) ; return 0 ; } pp = & p -> next ; p = * pp ; } syslog ( LOG_INFO , "new<S2SV_blank>device<S2SV_blank>discovered<S2SV_blank>:<S2SV_blank>%.*s" , headers [ HEADER_USN ] . l , headers [ HEADER_USN ] . p ) ; { char * pc ; int i ; p = malloc ( sizeof ( struct device ) + headers [ 0 ] . l + headers [ 1 ] . l + headers [ 2 ] . l ) ; if ( ! p ) { syslog ( LOG_ERR , "updateDevice():<S2SV_blank>cannot<S2SV_blank>allocate<S2SV_blank>memory" ) ; return - 1 ; } p -> next = devlist ; p -> t = t ; pc = p -> data ; for ( i = 0 ; i < 3 ; i ++ ) { p -> headers [ i ] . p = pc ; p -> headers [ i ] . l = headers [ i ] . l ; memcpy ( pc , headers [ i ] . p , headers [ i ] . l ) ; pc += headers [ i ] . l ; } devlist = p ; sendNotifications ( NOTIF_NEW , p , NULL ) ; } return 1 ; }
CWE-476 int upnp_redirect ( const char * rhost , unsigned short eport , const char * iaddr , unsigned short iport , const char * protocol , const char * desc , unsigned int leaseduration ) { int proto , r ; char iaddr_old [ 32 ] ; char rhost_old [ 32 ] ; unsigned short iport_old ; struct in_addr address ; unsigned int timestamp ; proto = proto_atoi ( protocol ) ; if ( inet_aton ( iaddr , & address ) <= 0 ) { syslog ( LOG_ERR , "inet_aton(%s)<S2SV_blank>FAILED" , iaddr ) ; return - 1 ; } if ( ! check_upnp_rule_against_permissions ( upnppermlist , num_upnpperm , eport , address , iport ) ) { syslog ( LOG_INFO , "redirection<S2SV_blank>permission<S2SV_blank>check<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>" "%hu->%s:%hu<S2SV_blank>%s" , eport , iaddr , iport , protocol ) ; return - 3 ; } <S2SV_StartBug> rhost_old [ 0 ] = '\\0' ; <S2SV_EndBug> r = get_redirect_rule ( ext_if_name , eport , proto , iaddr_old , sizeof ( iaddr_old ) , & iport_old , 0 , 0 , rhost_old , sizeof ( rhost_old ) , & timestamp , 0 , 0 ) ; if ( r == 0 ) { if ( strcmp ( iaddr , iaddr_old ) == 0 && ( ( rhost == NULL && rhost_old [ 0 ] == '\\0' ) || ( rhost && ( strcmp ( rhost , "*" ) == 0 ) && rhost_old [ 0 ] == '\\0' ) || ( rhost && ( strcmp ( rhost , rhost_old ) == 0 ) ) ) ) { syslog ( LOG_INFO , "updating<S2SV_blank>existing<S2SV_blank>port<S2SV_blank>mapping<S2SV_blank>%hu<S2SV_blank>%s<S2SV_blank>(rhost<S2SV_blank>\'%s\')<S2SV_blank>=><S2SV_blank>%s:%hu" , eport , protocol , rhost_old , iaddr_old , iport_old ) ; timestamp = ( leaseduration > 0 ) ? upnp_time ( ) + leaseduration : 0 ; if ( iport != iport_old ) { r = update_portmapping ( ext_if_name , eport , proto , iport , desc , timestamp ) ; } else { r = update_portmapping_desc_timestamp ( ext_if_name , eport , proto , desc , timestamp ) ; } # ifdef ENABLE_LEASEFILE if ( r == 0 ) { lease_file_remove ( eport , proto ) ; lease_file_add ( eport , iaddr , iport , proto , desc , timestamp ) ; } # endif return r ; } else { syslog ( LOG_INFO , "port<S2SV_blank>%hu<S2SV_blank>%s<S2SV_blank>(rhost<S2SV_blank>\'%s\')<S2SV_blank>already<S2SV_blank>redirected<S2SV_blank>to<S2SV_blank>%s:%hu" , eport , protocol , rhost_old , iaddr_old , iport_old ) ; return - 2 ; } # ifdef CHECK_PORTINUSE } else if ( port_in_use ( ext_if_name , eport , proto , iaddr , iport ) > 0 ) { syslog ( LOG_INFO , "port<S2SV_blank>%hu<S2SV_blank>protocol<S2SV_blank>%s<S2SV_blank>already<S2SV_blank>in<S2SV_blank>use" , eport , protocol ) ; return - 4 ; # endif } else { timestamp = ( leaseduration > 0 ) ? upnp_time ( ) + leaseduration : 0 ; syslog ( LOG_INFO , "redirecting<S2SV_blank>port<S2SV_blank>%hu<S2SV_blank>to<S2SV_blank>%s:%hu<S2SV_blank>protocol<S2SV_blank>%s<S2SV_blank>for:<S2SV_blank>%s" , eport , iaddr , iport , protocol , desc ) ; return upnp_redirect_internal ( rhost , eport , iaddr , iport , proto , desc , timestamp ) ; } }
CWE-119 static void WritePixel ( struct ngiflib_img * i , struct ngiflib_decode_context * context , u8 v ) { struct ngiflib_gif * p = i -> parent ; if ( v != i -> gce . transparent_color || ! i -> gce . transparent_flag ) { # ifndef NGIFLIB_INDEXED_ONLY if ( p -> mode & NGIFLIB_MODE_INDEXED ) { # endif * context -> frbuff_p . p8 = v ; # ifndef NGIFLIB_INDEXED_ONLY } else * context -> frbuff_p . p32 = GifIndexToTrueColor ( i -> palette , v ) ; # endif } if ( -- ( context -> Xtogo ) <= 0 ) { # ifdef NGIFLIB_ENABLE_CALLBACKS if ( p -> line_cb ) p -> line_cb ( p , context -> line_p , context -> curY ) ; # endif context -> Xtogo = i -> width ; switch ( context -> pass ) { case 0 : context -> curY ++ ; break ; case 1 : context -> curY += 8 ; <S2SV_StartBug> if ( context -> curY >= p -> height ) { <S2SV_EndBug> context -> pass ++ ; context -> curY = i -> posY + 4 ; } break ; case 2 : context -> curY += 8 ; <S2SV_StartBug> if ( context -> curY >= p -> height ) { <S2SV_EndBug> context -> pass ++ ; context -> curY = i -> posY + 2 ; } break ; case 3 : context -> curY += 4 ; <S2SV_StartBug> if ( context -> curY >= p -> height ) { <S2SV_EndBug> context -> pass ++ ; context -> curY = i -> posY + 1 ; } break ; case 4 : context -> curY += 2 ; <S2SV_StartBug> break ; <S2SV_EndBug> } # ifndef NGIFLIB_INDEXED_ONLY if ( p -> mode & NGIFLIB_MODE_INDEXED ) { # endif # ifdef NGIFLIB_ENABLE_CALLBACKS context -> line_p . p8 = p -> frbuff . p8 + ( u32 ) context -> curY * p -> width ; context -> frbuff_p . p8 = context -> line_p . p8 + i -> posX ; # else context -> frbuff_p . p8 = p -> frbuff . p8 + ( u32 ) context -> curY * p -> width + i -> posX ; # endif # ifndef NGIFLIB_INDEXED_ONLY } else { # ifdef NGIFLIB_ENABLE_CALLBACKS context -> line_p . p32 = p -> frbuff . p32 + ( u32 ) context -> curY * p -> width ; context -> frbuff_p . p32 = context -> line_p . p32 + i -> posX ; # else context -> frbuff_p . p32 = p -> frbuff . p32 + ( u32 ) context -> curY * p -> width + i -> posX ; # endif } # endif } else { # ifndef NGIFLIB_INDEXED_ONLY if ( p -> mode & NGIFLIB_MODE_INDEXED ) { # endif context -> frbuff_p . p8 ++ ; # ifndef NGIFLIB_INDEXED_ONLY } else { context -> frbuff_p . p32 ++ ; } # endif } }
CWE-119 static void WritePixels ( struct ngiflib_img * i , struct ngiflib_decode_context * context , const u8 * pixels , u16 n ) { u16 tocopy ; struct ngiflib_gif * p = i -> parent ; while ( n > 0 ) { tocopy = ( context -> Xtogo < n ) ? context -> Xtogo : n ; if ( ! i -> gce . transparent_flag ) { # ifndef NGIFLIB_INDEXED_ONLY if ( p -> mode & NGIFLIB_MODE_INDEXED ) { # endif ngiflib_memcpy ( context -> frbuff_p . p8 , pixels , tocopy ) ; pixels += tocopy ; context -> frbuff_p . p8 += tocopy ; # ifndef NGIFLIB_INDEXED_ONLY } else { int j ; for ( j = ( int ) tocopy ; j > 0 ; j -- ) { * ( context -> frbuff_p . p32 ++ ) = GifIndexToTrueColor ( i -> palette , * pixels ++ ) ; } } # endif } else { int j ; # ifndef NGIFLIB_INDEXED_ONLY if ( p -> mode & NGIFLIB_MODE_INDEXED ) { # endif for ( j = ( int ) tocopy ; j > 0 ; j -- ) { if ( * pixels != i -> gce . transparent_color ) * context -> frbuff_p . p8 = * pixels ; pixels ++ ; context -> frbuff_p . p8 ++ ; } # ifndef NGIFLIB_INDEXED_ONLY } else { for ( j = ( int ) tocopy ; j > 0 ; j -- ) { if ( * pixels != i -> gce . transparent_color ) { * context -> frbuff_p . p32 = GifIndexToTrueColor ( i -> palette , * pixels ) ; } pixels ++ ; context -> frbuff_p . p32 ++ ; } } # endif } context -> Xtogo -= tocopy ; if ( context -> Xtogo == 0 ) { # ifdef NGIFLIB_ENABLE_CALLBACKS if ( p -> line_cb ) p -> line_cb ( p , context -> line_p , context -> curY ) ; # endif context -> Xtogo = i -> width ; switch ( context -> pass ) { case 0 : context -> curY ++ ; break ; case 1 : context -> curY += 8 ; <S2SV_StartBug> if ( context -> curY >= p -> height ) { <S2SV_EndBug> context -> pass ++ ; context -> curY = i -> posY + 4 ; } break ; case 2 : context -> curY += 8 ; <S2SV_StartBug> if ( context -> curY >= p -> height ) { <S2SV_EndBug> context -> pass ++ ; context -> curY = i -> posY + 2 ; } break ; case 3 : context -> curY += 4 ; <S2SV_StartBug> if ( context -> curY >= p -> height ) { <S2SV_EndBug> context -> pass ++ ; context -> curY = i -> posY + 1 ; } break ; case 4 : context -> curY += 2 ; <S2SV_StartBug> break ; <S2SV_EndBug> } # ifndef NGIFLIB_INDEXED_ONLY if ( p -> mode & NGIFLIB_MODE_INDEXED ) { # endif # ifdef NGIFLIB_ENABLE_CALLBACKS context -> line_p . p8 = p -> frbuff . p8 + ( u32 ) context -> curY * p -> width ; context -> frbuff_p . p8 = context -> line_p . p8 + i -> posX ; # else context -> frbuff_p . p8 = p -> frbuff . p8 + ( u32 ) context -> curY * p -> width + i -> posX ; # endif # ifndef NGIFLIB_INDEXED_ONLY } else { # ifdef NGIFLIB_ENABLE_CALLBACKS context -> line_p . p32 = p -> frbuff . p32 + ( u32 ) context -> curY * p -> width ; context -> frbuff_p . p32 = context -> line_p . p32 + i -> posX ; # else context -> frbuff_p . p32 = p -> frbuff . p32 + ( u32 ) context -> curY * p -> width + i -> posX ; # endif } # endif } n -= tocopy ; } }
CWE-119 static int DecodeGifImg ( struct ngiflib_img * i ) { struct ngiflib_decode_context context ; long npix ; u8 * stackp ; u8 * stack_top ; u16 clr ; u16 eof ; u16 free ; u16 act_code = 0 ; u16 old_code = 0 ; u16 read_byt ; u16 ab_prfx [ 4096 ] ; u8 ab_suffx [ 4096 ] ; u8 ab_stack [ 4096 ] ; u8 flags ; u8 casspecial = 0 ; if ( ! i ) return - 1 ; i -> posX = GetWord ( i -> parent ) ; i -> posY = GetWord ( i -> parent ) ; i -> width = GetWord ( i -> parent ) ; i -> height = GetWord ( i -> parent ) ; <S2SV_StartBug> context . Xtogo = i -> width ; <S2SV_EndBug> context . curY = i -> posY ; # ifdef NGIFLIB_INDEXED_ONLY # ifdef NGIFLIB_ENABLE_CALLBACKS context . line_p . p8 = i -> parent -> frbuff . p8 + ( u32 ) i -> posY * i -> parent -> width ; context . frbuff_p . p8 = context . line_p . p8 + i -> posX ; # else context . frbuff_p . p8 = i -> parent -> frbuff . p8 + ( u32 ) i -> posY * i -> parent -> width + i -> posX ; # endif # else if ( i -> parent -> mode & NGIFLIB_MODE_INDEXED ) { # ifdef NGIFLIB_ENABLE_CALLBACKS context . line_p . p8 = i -> parent -> frbuff . p8 + ( u32 ) i -> posY * i -> parent -> width ; context . frbuff_p . p8 = context . line_p . p8 + i -> posX ; # else context . frbuff_p . p8 = i -> parent -> frbuff . p8 + ( u32 ) i -> posY * i -> parent -> width + i -> posX ; # endif } else { # ifdef NGIFLIB_ENABLE_CALLBACKS context . line_p . p32 = i -> parent -> frbuff . p32 + ( u32 ) i -> posY * i -> parent -> width ; context . frbuff_p . p32 = context . line_p . p32 + i -> posX ; # else context . frbuff_p . p32 = i -> parent -> frbuff . p32 + ( u32 ) i -> posY * i -> parent -> width + i -> posX ; # endif } # endif npix = ( long ) i -> width * i -> height ; flags = GetByte ( i -> parent ) ; i -> interlaced = ( flags & 64 ) >> 6 ; context . pass = i -> interlaced ? 1 : 0 ; i -> sort_flag = ( flags & 32 ) >> 5 ; i -> localpalbits = ( flags & 7 ) + 1 ; if ( flags & 128 ) { int k ; int localpalsize = 1 << i -> localpalbits ; # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent && i -> parent -> log ) fprintf ( i -> parent -> log , "Local<S2SV_blank>palette\\n" ) ; # endif i -> palette = ( struct ngiflib_rgb * ) ngiflib_malloc ( sizeof ( struct ngiflib_rgb ) * localpalsize ) ; for ( k = 0 ; k < localpalsize ; k ++ ) { i -> palette [ k ] . r = GetByte ( i -> parent ) ; i -> palette [ k ] . g = GetByte ( i -> parent ) ; i -> palette [ k ] . b = GetByte ( i -> parent ) ; } # ifdef NGIFLIB_ENABLE_CALLBACKS if ( i -> parent -> palette_cb ) i -> parent -> palette_cb ( i -> parent , i -> palette , localpalsize ) ; # endif } else { i -> palette = i -> parent -> palette ; i -> localpalbits = i -> parent -> imgbits ; } i -> ncolors = 1 << i -> localpalbits ; i -> imgbits = GetByte ( i -> parent ) ; # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent && i -> parent -> log ) { if ( i -> interlaced ) fprintf ( i -> parent -> log , "interlaced<S2SV_blank>" ) ; fprintf ( i -> parent -> log , "img<S2SV_blank>pos(%hu,%hu)<S2SV_blank>size<S2SV_blank>%hux%hu<S2SV_blank>palbits=%hhu<S2SV_blank>imgbits=%hhu<S2SV_blank>ncolors=%hu\\n" , i -> posX , i -> posY , i -> width , i -> height , i -> localpalbits , i -> imgbits , i -> ncolors ) ; } # endif if ( i -> imgbits == 1 ) { i -> imgbits = 2 ; } clr = 1 << i -> imgbits ; eof = clr + 1 ; free = clr + 2 ; context . nbbit = i -> imgbits + 1 ; context . max = clr + clr - 1 ; stackp = stack_top = ab_stack + 4096 ; context . restbits = 0 ; context . restbyte = 0 ; context . lbyte = 0 ; for ( ; ; ) { act_code = GetGifWord ( i , & context ) ; if ( act_code == eof ) { # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent && i -> parent -> log ) fprintf ( i -> parent -> log , "End<S2SV_blank>of<S2SV_blank>image<S2SV_blank>code\\n" ) ; # endif return 0 ; } if ( npix == 0 ) { # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent && i -> parent -> log ) fprintf ( i -> parent -> log , "assez<S2SV_blank>de<S2SV_blank>pixels,<S2SV_blank>On<S2SV_blank>se<S2SV_blank>casse<S2SV_blank>!\\n" ) ; # endif return 1 ; } if ( act_code == clr ) { # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent && i -> parent -> log ) fprintf ( i -> parent -> log , "Code<S2SV_blank>clear<S2SV_blank>(free=%hu)<S2SV_blank>npix=%ld\\n" , free , npix ) ; # endif free = clr + 2 ; context . nbbit = i -> imgbits + 1 ; context . max = clr + clr - 1 ; act_code = GetGifWord ( i , & context ) ; casspecial = ( u8 ) act_code ; old_code = act_code ; WritePixel ( i , & context , casspecial ) ; npix -- ; } else { read_byt = act_code ; if ( act_code >= free ) { * ( -- stackp ) = casspecial ; act_code = old_code ; } while ( act_code > clr ) { * ( -- stackp ) = ab_suffx [ act_code ] ; act_code = ab_prfx [ act_code ] ; } casspecial = ( u8 ) act_code ; * ( -- stackp ) = casspecial ; WritePixels ( i , & context , stackp , stack_top - stackp ) ; npix -= ( stack_top - stackp ) ; stackp = stack_top ; if ( free < 4096 ) { ab_prfx [ free ] = old_code ; ab_suffx [ free ] = ( u8 ) act_code ; free ++ ; if ( ( free > context . max ) && ( context . nbbit < 12 ) ) { context . nbbit ++ ; context . max += context . max + 1 ; } } old_code = read_byt ; } } return 0 ; }
CWE-119 static int DecodeGifImg ( struct ngiflib_img * i ) { struct ngiflib_decode_context context ; long npix ; u8 * stackp ; u8 * stack_top ; u16 clr ; u16 eof ; u16 free ; u16 act_code = 0 ; u16 old_code = 0 ; u16 read_byt ; u16 ab_prfx [ 4096 ] ; u8 ab_suffx [ 4096 ] ; u8 ab_stack [ 4096 ] ; u8 flags ; u8 casspecial = 0 ; if ( ! i ) return - 1 ; i -> posX = GetWord ( i -> parent ) ; i -> posY = GetWord ( i -> parent ) ; i -> width = GetWord ( i -> parent ) ; i -> height = GetWord ( i -> parent ) ; if ( ( i -> width > i -> parent -> width ) || ( i -> height > i -> parent -> height ) ) { # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent -> log ) fprintf ( i -> parent -> log , "***<S2SV_blank>ERROR<S2SV_blank>***<S2SV_blank>Image<S2SV_blank>bigger<S2SV_blank>than<S2SV_blank>global<S2SV_blank>GIF<S2SV_blank>canvas<S2SV_blank>!\\n" ) ; # endif return - 1 ; } if ( ( i -> posX + i -> width ) > i -> parent -> width ) { # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent -> log ) fprintf ( i -> parent -> log , "***<S2SV_blank>WARNING<S2SV_blank>***<S2SV_blank>Adjusting<S2SV_blank>X<S2SV_blank>position\\n" ) ; # endif i -> posX = i -> parent -> width - i -> width ; } if ( ( i -> posY + i -> height ) > i -> parent -> height ) { # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent -> log ) fprintf ( i -> parent -> log , "***<S2SV_blank>WARNING<S2SV_blank>***<S2SV_blank>Adjusting<S2SV_blank>Y<S2SV_blank>position\\n" ) ; # endif i -> posY = i -> parent -> height - i -> height ; } context . Xtogo = i -> width ; context . curY = i -> posY ; # ifdef NGIFLIB_INDEXED_ONLY # ifdef NGIFLIB_ENABLE_CALLBACKS context . line_p . p8 = i -> parent -> frbuff . p8 + ( u32 ) i -> posY * i -> parent -> width ; context . frbuff_p . p8 = context . line_p . p8 + i -> posX ; # else context . frbuff_p . p8 = i -> parent -> frbuff . p8 + ( u32 ) i -> posY * i -> parent -> width + i -> posX ; # endif # else if ( i -> parent -> mode & NGIFLIB_MODE_INDEXED ) { # ifdef NGIFLIB_ENABLE_CALLBACKS context . line_p . p8 = i -> parent -> frbuff . p8 + ( u32 ) i -> posY * i -> parent -> width ; context . frbuff_p . p8 = context . line_p . p8 + i -> posX ; # else context . frbuff_p . p8 = i -> parent -> frbuff . p8 + ( u32 ) i -> posY * i -> parent -> width + i -> posX ; # endif } else { # ifdef NGIFLIB_ENABLE_CALLBACKS context . line_p . p32 = i -> parent -> frbuff . p32 + ( u32 ) i -> posY * i -> parent -> width ; context . frbuff_p . p32 = context . line_p . p32 + i -> posX ; # else context . frbuff_p . p32 = i -> parent -> frbuff . p32 + ( u32 ) i -> posY * i -> parent -> width + i -> posX ; # endif } # endif npix = ( long ) i -> width * i -> height ; flags = GetByte ( i -> parent ) ; i -> interlaced = ( flags & 64 ) >> 6 ; context . pass = i -> interlaced ? 1 : 0 ; i -> sort_flag = ( flags & 32 ) >> 5 ; i -> localpalbits = ( flags & 7 ) + 1 ; if ( flags & 128 ) { int k ; int localpalsize = 1 << i -> localpalbits ; # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent && i -> parent -> log ) fprintf ( i -> parent -> log , "Local<S2SV_blank>palette\\n" ) ; # endif i -> palette = ( struct ngiflib_rgb * ) ngiflib_malloc ( sizeof ( struct ngiflib_rgb ) * localpalsize ) ; for ( k = 0 ; k < localpalsize ; k ++ ) { i -> palette [ k ] . r = GetByte ( i -> parent ) ; i -> palette [ k ] . g = GetByte ( i -> parent ) ; i -> palette [ k ] . b = GetByte ( i -> parent ) ; } # ifdef NGIFLIB_ENABLE_CALLBACKS if ( i -> parent -> palette_cb ) i -> parent -> palette_cb ( i -> parent , i -> palette , localpalsize ) ; # endif } else { i -> palette = i -> parent -> palette ; i -> localpalbits = i -> parent -> imgbits ; } i -> ncolors = 1 << i -> localpalbits ; i -> imgbits = GetByte ( i -> parent ) ; # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent && i -> parent -> log ) { if ( i -> interlaced ) fprintf ( i -> parent -> log , "interlaced<S2SV_blank>" ) ; fprintf ( i -> parent -> log , "img<S2SV_blank>pos(%hu,%hu)<S2SV_blank>size<S2SV_blank>%hux%hu<S2SV_blank>palbits=%hhu<S2SV_blank>imgbits=%hhu<S2SV_blank>ncolors=%hu\\n" , i -> posX , i -> posY , i -> width , i -> height , i -> localpalbits , i -> imgbits , i -> ncolors ) ; } # endif if ( i -> imgbits == 1 ) { i -> imgbits = 2 ; } clr = 1 << i -> imgbits ; eof = clr + 1 ; free = clr + 2 ; context . nbbit = i -> imgbits + 1 ; context . max = clr + clr - 1 ; stackp = stack_top = ab_stack + 4096 ; context . restbits = 0 ; context . restbyte = 0 ; context . lbyte = 0 ; for ( ; ; ) { act_code = GetGifWord ( i , & context ) ; if ( act_code == eof ) { # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent && i -> parent -> log ) fprintf ( i -> parent -> log , "End<S2SV_blank>of<S2SV_blank>image<S2SV_blank>code\\n" ) ; # endif return 0 ; } if ( npix == 0 ) { # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent && i -> parent -> log ) fprintf ( i -> parent -> log , "assez<S2SV_blank>de<S2SV_blank>pixels,<S2SV_blank>On<S2SV_blank>se<S2SV_blank>casse<S2SV_blank>!\\n" ) ; # endif return 1 ; } if ( act_code == clr ) { # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent && i -> parent -> log ) fprintf ( i -> parent -> log , "Code<S2SV_blank>clear<S2SV_blank>(free=%hu)<S2SV_blank>npix=%ld\\n" , free , npix ) ; # endif free = clr + 2 ; context . nbbit = i -> imgbits + 1 ; context . max = clr + clr - 1 ; act_code = GetGifWord ( i , & context ) ; casspecial = ( u8 ) act_code ; old_code = act_code ; <S2SV_StartBug> WritePixel ( i , & context , casspecial ) ; npix -- ; <S2SV_EndBug> } else { read_byt = act_code ; if ( act_code >= free ) { * ( -- stackp ) = casspecial ; act_code = old_code ; } while ( act_code > clr ) { * ( -- stackp ) = ab_suffx [ act_code ] ; act_code = ab_prfx [ act_code ] ; } casspecial = ( u8 ) act_code ; * ( -- stackp ) = casspecial ; <S2SV_StartBug> WritePixels ( i , & context , stackp , stack_top - stackp ) ; <S2SV_EndBug> npix -= ( stack_top - stackp ) ; stackp = stack_top ; if ( free < 4096 ) { ab_prfx [ free ] = old_code ; ab_suffx [ free ] = ( u8 ) act_code ; free ++ ; if ( ( free > context . max ) && ( context . nbbit < 12 ) ) { context . nbbit ++ ; context . max += context . max + 1 ; } } old_code = read_byt ; } } return 0 ; }
CWE-125 static bool _bson_iter_next_internal ( bson_iter_t * iter , uint32_t next_keylen , const char * * key , uint32_t * bson_type , bool * unsupported ) { const uint8_t * data ; uint32_t o ; unsigned int len ; BSON_ASSERT ( iter ) ; * unsupported = false ; if ( ! iter -> raw ) { * key = NULL ; * bson_type = BSON_TYPE_EOD ; return false ; } data = iter -> raw ; len = iter -> len ; iter -> off = iter -> next_off ; iter -> type = iter -> off ; iter -> key = iter -> off + 1 ; iter -> d1 = 0 ; iter -> d2 = 0 ; iter -> d3 = 0 ; iter -> d4 = 0 ; if ( next_keylen == 0 ) { for ( o = iter -> key ; o < len ; o ++ ) { if ( ! data [ o ] ) { iter -> d1 = ++ o ; goto fill_data_fields ; } } } else { o = iter -> key + next_keylen + 1 ; iter -> d1 = o ; goto fill_data_fields ; } goto mark_invalid ; fill_data_fields : * key = bson_iter_key_unsafe ( iter ) ; * bson_type = ITER_TYPE ( iter ) ; switch ( * bson_type ) { case BSON_TYPE_DATE_TIME : case BSON_TYPE_DOUBLE : case BSON_TYPE_INT64 : case BSON_TYPE_TIMESTAMP : iter -> next_off = o + 8 ; break ; case BSON_TYPE_CODE : case BSON_TYPE_SYMBOL : case BSON_TYPE_UTF8 : { uint32_t l ; if ( ( o + 4 ) >= len ) { iter -> err_off = o ; goto mark_invalid ; } iter -> d2 = o + 4 ; memcpy ( & l , iter -> raw + iter -> d1 , sizeof ( l ) ) ; l = BSON_UINT32_FROM_LE ( l ) ; if ( l > ( len - ( o + 4 ) ) ) { iter -> err_off = o ; goto mark_invalid ; } iter -> next_off = o + 4 + l ; if ( BSON_UNLIKELY ( ( l == 0 ) || ( iter -> next_off >= len ) ) ) { iter -> err_off = o ; goto mark_invalid ; } if ( BSON_UNLIKELY ( ( iter -> raw + iter -> d2 ) [ l - 1 ] != '\\0' ) ) { iter -> err_off = o + 4 + l - 1 ; goto mark_invalid ; } } break ; case BSON_TYPE_BINARY : { bson_subtype_t subtype ; uint32_t l ; if ( o >= ( len - 4 ) ) { iter -> err_off = o ; goto mark_invalid ; } iter -> d2 = o + 4 ; iter -> d3 = o + 5 ; memcpy ( & l , iter -> raw + iter -> d1 , sizeof ( l ) ) ; l = BSON_UINT32_FROM_LE ( l ) ; <S2SV_StartBug> if ( l >= ( len - o ) ) { <S2SV_EndBug> iter -> err_off = o ; goto mark_invalid ; } subtype = * ( iter -> raw + iter -> d2 ) ; if ( subtype == BSON_SUBTYPE_BINARY_DEPRECATED ) { int32_t binary_len ; if ( l < 4 ) { iter -> err_off = o ; goto mark_invalid ; } memcpy ( & binary_len , ( iter -> raw + iter -> d3 ) , sizeof ( binary_len ) ) ; binary_len = BSON_UINT32_FROM_LE ( binary_len ) ; if ( binary_len + 4 != l ) { iter -> err_off = iter -> d3 ; goto mark_invalid ; } } iter -> next_off = o + 5 + l ; } break ; case BSON_TYPE_ARRAY : case BSON_TYPE_DOCUMENT : { uint32_t l ; if ( o >= ( len - 4 ) ) { iter -> err_off = o ; goto mark_invalid ; } memcpy ( & l , iter -> raw + iter -> d1 , sizeof ( l ) ) ; l = BSON_UINT32_FROM_LE ( l ) ; if ( ( l > len ) || ( l > ( len - o ) ) ) { iter -> err_off = o ; goto mark_invalid ; } iter -> next_off = o + l ; } break ; case BSON_TYPE_OID : iter -> next_off = o + 12 ; break ; case BSON_TYPE_BOOL : { char val ; if ( iter -> d1 >= len ) { iter -> err_off = o ; goto mark_invalid ; } memcpy ( & val , iter -> raw + iter -> d1 , 1 ) ; if ( val != 0x00 && val != 0x01 ) { iter -> err_off = o ; goto mark_invalid ; } iter -> next_off = o + 1 ; } break ; case BSON_TYPE_REGEX : { bool eor = false ; bool eoo = false ; for ( ; o < len ; o ++ ) { if ( ! data [ o ] ) { iter -> d2 = ++ o ; eor = true ; break ; } } if ( ! eor ) { iter -> err_off = iter -> next_off ; goto mark_invalid ; } for ( ; o < len ; o ++ ) { if ( ! data [ o ] ) { eoo = true ; break ; } } if ( ! eoo ) { iter -> err_off = iter -> next_off ; goto mark_invalid ; } iter -> next_off = o + 1 ; } break ; case BSON_TYPE_DBPOINTER : { uint32_t l ; if ( o >= ( len - 4 ) ) { iter -> err_off = o ; goto mark_invalid ; } iter -> d2 = o + 4 ; memcpy ( & l , iter -> raw + iter -> d1 , sizeof ( l ) ) ; l = BSON_UINT32_FROM_LE ( l ) ; if ( l == 0 || l > ( len - o - 4 ) ) { iter -> err_off = o ; goto mark_invalid ; } if ( * ( iter -> raw + o + l + 3 ) ) { iter -> err_off = o + l + 3 ; goto mark_invalid ; } iter -> d3 = o + 4 + l ; iter -> next_off = o + 4 + l + 12 ; } break ; case BSON_TYPE_CODEWSCOPE : { uint32_t l ; uint32_t doclen ; if ( ( len < 19 ) || ( o >= ( len - 14 ) ) ) { iter -> err_off = o ; goto mark_invalid ; } iter -> d2 = o + 4 ; iter -> d3 = o + 8 ; memcpy ( & l , iter -> raw + iter -> d1 , sizeof ( l ) ) ; l = BSON_UINT32_FROM_LE ( l ) ; if ( ( l < 14 ) || ( l >= ( len - o ) ) ) { iter -> err_off = o ; goto mark_invalid ; } iter -> next_off = o + l ; if ( iter -> next_off >= len ) { iter -> err_off = o ; goto mark_invalid ; } memcpy ( & l , iter -> raw + iter -> d2 , sizeof ( l ) ) ; l = BSON_UINT32_FROM_LE ( l ) ; if ( l == 0 || l >= ( len - o - 4 - 4 ) ) { iter -> err_off = o ; goto mark_invalid ; } if ( ( o + 4 + 4 + l + 4 ) >= iter -> next_off ) { iter -> err_off = o + 4 ; goto mark_invalid ; } iter -> d4 = o + 4 + 4 + l ; memcpy ( & doclen , iter -> raw + iter -> d4 , sizeof ( doclen ) ) ; doclen = BSON_UINT32_FROM_LE ( doclen ) ; if ( ( o + 4 + 4 + l + doclen ) != iter -> next_off ) { iter -> err_off = o + 4 + 4 + l ; goto mark_invalid ; } } break ; case BSON_TYPE_INT32 : iter -> next_off = o + 4 ; break ; case BSON_TYPE_DECIMAL128 : iter -> next_off = o + 16 ; break ; case BSON_TYPE_MAXKEY : case BSON_TYPE_MINKEY : case BSON_TYPE_NULL : case BSON_TYPE_UNDEFINED : iter -> next_off = o ; break ; default : * unsupported = true ; case BSON_TYPE_EOD : iter -> err_off = o ; goto mark_invalid ; } if ( iter -> next_off >= len ) { iter -> err_off = o ; goto mark_invalid ; } iter -> err_off = 0 ; return true ; mark_invalid : iter -> raw = NULL ; iter -> len = 0 ; iter -> next_off = 0 ; return false ; }
CWE-125 static void test_bson_validate ( void ) { char filename [ 64 ] ; size_t offset ; bson_t * b ; int i ; bson_error_t error ; for ( i = 1 ; i <= 38 ; i ++ ) { bson_snprintf ( filename , sizeof filename , "test%u.bson" , i ) ; b = get_bson ( filename ) ; BSON_ASSERT ( bson_validate ( b , BSON_VALIDATE_NONE , & offset ) ) ; bson_destroy ( b ) ; } b = get_bson ( "codewscope.bson" ) ; BSON_ASSERT ( bson_validate ( b , BSON_VALIDATE_NONE , & offset ) ) ; bson_destroy ( b ) ; b = get_bson ( "empty_key.bson" ) ; BSON_ASSERT ( bson_validate ( b , BSON_VALIDATE_NONE | BSON_VALIDATE_UTF8 | BSON_VALIDATE_DOLLAR_KEYS | BSON_VALIDATE_DOT_KEYS , & offset ) ) ; bson_destroy ( b ) ; # define VALIDATE_TEST ( _filename , _flags , _offset , _flag , _msg ) b = get_bson ( _filename ) ; BSON_ASSERT ( ! bson_validate ( b , _flags , & offset ) ) ; ASSERT_CMPSIZE_T ( offset , == , ( size_t ) _offset ) ; BSON_ASSERT ( ! bson_validate_with_error ( b , _flags , & error ) ) ; ASSERT_ERROR_CONTAINS ( error , BSON_ERROR_INVALID , _flag , _msg ) ; bson_destroy ( b ) VALIDATE_TEST ( "overflow2.bson" , BSON_VALIDATE_NONE , 9 , BSON_VALIDATE_NONE , "corrupt<S2SV_blank>BSON" ) ; VALIDATE_TEST ( "trailingnull.bson" , BSON_VALIDATE_NONE , 14 , BSON_VALIDATE_NONE , "corrupt<S2SV_blank>BSON" ) ; VALIDATE_TEST ( "dollarquery.bson" , BSON_VALIDATE_DOLLAR_KEYS | BSON_VALIDATE_DOT_KEYS , 4 , BSON_VALIDATE_DOLLAR_KEYS , "keys<S2SV_blank>cannot<S2SV_blank>begin<S2SV_blank>with<S2SV_blank>\\"$\\":<S2SV_blank>\\"$query\\"" ) ; VALIDATE_TEST ( "dotquery.bson" , BSON_VALIDATE_DOLLAR_KEYS | BSON_VALIDATE_DOT_KEYS , 4 , BSON_VALIDATE_DOT_KEYS , "keys<S2SV_blank>cannot<S2SV_blank>contain<S2SV_blank>\\".\\":<S2SV_blank>\\"abc.def\\"" ) ; VALIDATE_TEST ( "overflow3.bson" , BSON_VALIDATE_NONE , 9 , BSON_VALIDATE_NONE , "corrupt<S2SV_blank>BSON" ) ; VALIDATE_TEST ( "overflow3.bson" , BSON_VALIDATE_UTF8 , 9 , BSON_VALIDATE_NONE , "corrupt<S2SV_blank>BSON" ) ; VALIDATE_TEST ( "overflow4.bson" , BSON_VALIDATE_NONE , 9 , BSON_VALIDATE_NONE , "corrupt<S2SV_blank>BSON" ) ; VALIDATE_TEST ( "empty_key.bson" , BSON_VALIDATE_EMPTY_KEYS , 4 , BSON_VALIDATE_EMPTY_KEYS , "empty<S2SV_blank>key" ) ; VALIDATE_TEST ( "test40.bson" , BSON_VALIDATE_NONE , 6 , BSON_VALIDATE_NONE , "corrupt<S2SV_blank>BSON" ) ; VALIDATE_TEST ( "test41.bson" , BSON_VALIDATE_NONE , 6 , BSON_VALIDATE_NONE , "corrupt<S2SV_blank>BSON" ) ; VALIDATE_TEST ( "test42.bson" , BSON_VALIDATE_NONE , 6 , BSON_VALIDATE_NONE , "corrupt<S2SV_blank>BSON" ) ; VALIDATE_TEST ( "test43.bson" , BSON_VALIDATE_NONE , 6 , BSON_VALIDATE_NONE , "corrupt<S2SV_blank>BSON" ) ; VALIDATE_TEST ( "test44.bson" , BSON_VALIDATE_NONE , 6 , BSON_VALIDATE_NONE , "corrupt<S2SV_blank>BSON" ) ; VALIDATE_TEST ( "test45.bson" , BSON_VALIDATE_NONE , 6 , BSON_VALIDATE_NONE , "corrupt<S2SV_blank>BSON" ) ; VALIDATE_TEST ( "test46.bson" , BSON_VALIDATE_NONE , 6 , BSON_VALIDATE_NONE , "corrupt<S2SV_blank>BSON" ) ; VALIDATE_TEST ( "test47.bson" , BSON_VALIDATE_NONE , 6 , BSON_VALIDATE_NONE , "corrupt<S2SV_blank>BSON" ) ; VALIDATE_TEST ( "test48.bson" , BSON_VALIDATE_NONE , 6 , BSON_VALIDATE_NONE , "corrupt<S2SV_blank>BSON" ) ; VALIDATE_TEST ( "test49.bson" , BSON_VALIDATE_NONE , 6 , BSON_VALIDATE_NONE , "corrupt<S2SV_blank>BSON" ) ; VALIDATE_TEST ( "test50.bson" , BSON_VALIDATE_NONE , 10 , BSON_VALIDATE_NONE , "corrupt<S2SV_blank>code-with-scope" ) ; VALIDATE_TEST ( "test51.bson" , BSON_VALIDATE_NONE , 10 , BSON_VALIDATE_NONE , "corrupt<S2SV_blank>code-with-scope" ) ; VALIDATE_TEST ( "test52.bson" , BSON_VALIDATE_NONE , 9 , BSON_VALIDATE_NONE , "corrupt<S2SV_blank>BSON" ) ; VALIDATE_TEST ( "test53.bson" , BSON_VALIDATE_NONE , 6 , BSON_VALIDATE_NONE , "corrupt<S2SV_blank>BSON" ) ; VALIDATE_TEST ( "test54.bson" , BSON_VALIDATE_NONE , 12 , BSON_VALIDATE_NONE , "corrupt<S2SV_blank>BSON" ) ; <S2SV_StartBug> b = BCON_NEW ( "my_dbref" , <S2SV_EndBug> "{" , "$ref" , BCON_UTF8 ( "collection" ) , "$id" , BCON_INT32 ( 1 ) , "}" ) ; BSON_ASSERT ( bson_validate_with_error ( b , BSON_VALIDATE_NONE , & error ) ) ; BSON_ASSERT ( bson_validate_with_error ( b , BSON_VALIDATE_DOLLAR_KEYS , & error ) ) ; bson_destroy ( b ) ; b = BCON_NEW ( "my_dbref" , "{" , "$id" , BCON_INT32 ( 1 ) , "}" ) ; BSON_ASSERT ( bson_validate_with_error ( b , BSON_VALIDATE_NONE , & error ) ) ; BSON_ASSERT ( ! bson_validate_with_error ( b , BSON_VALIDATE_DOLLAR_KEYS , & error ) ) ; ASSERT_ERROR_CONTAINS ( error , BSON_ERROR_INVALID , BSON_VALIDATE_DOLLAR_KEYS , "keys<S2SV_blank>cannot<S2SV_blank>begin<S2SV_blank>with<S2SV_blank>\\"$\\":<S2SV_blank>\\"$id\\"" ) ; bson_destroy ( b ) ; b = BCON_NEW ( "my_dbref" , "{" , "$ref" , BCON_UTF8 ( "collection" ) , "$ref" , BCON_UTF8 ( "collection" ) , "}" ) ; BSON_ASSERT ( bson_validate_with_error ( b , BSON_VALIDATE_NONE , & error ) ) ; BSON_ASSERT ( ! bson_validate_with_error ( b , BSON_VALIDATE_DOLLAR_KEYS , & error ) ) ; ASSERT_ERROR_CONTAINS ( error , BSON_ERROR_INVALID , BSON_VALIDATE_DOLLAR_KEYS , "keys<S2SV_blank>cannot<S2SV_blank>begin<S2SV_blank>with<S2SV_blank>\\"$\\":<S2SV_blank>\\"$ref\\"" ) ; bson_destroy ( b ) ; b = BCON_NEW ( "my_dbref" , "{" , "$ref" , BCON_UTF8 ( "collection" ) , "extra" , BCON_INT32 ( 2 ) , "$id" , BCON_INT32 ( 1 ) , "}" ) ; BSON_ASSERT ( bson_validate_with_error ( b , BSON_VALIDATE_NONE , & error ) ) ; BSON_ASSERT ( ! bson_validate_with_error ( b , BSON_VALIDATE_DOLLAR_KEYS , & error ) ) ; ASSERT_ERROR_CONTAINS ( error , BSON_ERROR_INVALID , BSON_VALIDATE_DOLLAR_KEYS , "invalid<S2SV_blank>key<S2SV_blank>within<S2SV_blank>DBRef<S2SV_blank>subdocument:<S2SV_blank>\\"extra\\"" ) ; bson_destroy ( b ) ; # undef VALIDATE_TEST }
CWE-125 static mrb_value fiber_switch ( mrb_state * mrb , mrb_value self , mrb_int len , const mrb_value * a , mrb_bool resume , mrb_bool vmexec ) { struct mrb_context * c = fiber_check ( mrb , self ) ; struct mrb_context * old_c = mrb -> c ; <S2SV_StartBug> mrb_value value ; <S2SV_EndBug> <S2SV_StartBug> fiber_check_cfunc ( mrb , c ) ; <S2SV_EndBug> <S2SV_StartBug> if ( resume && c -> status == MRB_FIBER_TRANSFERRED ) { <S2SV_EndBug> mrb_raise ( mrb , E_FIBER_ERROR , "resuming<S2SV_blank>transferred<S2SV_blank>fiber" ) ; } <S2SV_StartBug> if ( c -> status == MRB_FIBER_RUNNING || c -> status == MRB_FIBER_RESUMED ) { <S2SV_EndBug> mrb_raise ( mrb , E_FIBER_ERROR , "double<S2SV_blank>resume<S2SV_blank>(fib)" ) ; } <S2SV_StartBug> if ( c -> status == MRB_FIBER_TERMINATED ) { <S2SV_EndBug> mrb_raise ( mrb , E_FIBER_ERROR , "resuming<S2SV_blank>dead<S2SV_blank>fiber" ) ; } <S2SV_StartBug> mrb -> c -> status = resume ? MRB_FIBER_RESUMED : MRB_FIBER_TRANSFERRED ; <S2SV_EndBug> c -> prev = resume ? mrb -> c : ( c -> prev ? c -> prev : mrb -> root_c ) ; <S2SV_StartBug> if ( c -> status == MRB_FIBER_CREATED ) { <S2SV_EndBug> mrb_value * b , * e ; <S2SV_StartBug> if ( len >= c -> stend - c -> stack ) { <S2SV_EndBug> mrb_raise ( mrb , E_FIBER_ERROR , "too<S2SV_blank>many<S2SV_blank>arguments<S2SV_blank>to<S2SV_blank>fiber" ) ; } b = c -> stack + 1 ; e = b + len ; while ( b < e ) { * b ++ = * a ++ ; } c -> cibase -> argc = ( int ) len ; value = c -> stack [ 0 ] = MRB_PROC_ENV ( c -> ci -> proc ) -> stack [ 0 ] ; } else { value = fiber_result ( mrb , a , len ) ; } <S2SV_StartBug> fiber_switch_context ( mrb , c ) ; <S2SV_EndBug> if ( vmexec ) { c -> vmexec = TRUE ; value = mrb_vm_exec ( mrb , c -> ci [ - 1 ] . proc , c -> ci -> pc ) ; mrb -> c = old_c ; } else { MARK_CONTEXT_MODIFY ( c ) ; } return value ; }
CWE-416 mrb_value mrb_io_initialize_copy ( mrb_state * mrb , mrb_value copy ) { mrb_value orig ; mrb_value buf ; struct mrb_io * fptr_copy ; struct mrb_io * fptr_orig ; mrb_bool failed = TRUE ; mrb_get_args ( mrb , "o" , & orig ) ; <S2SV_StartBug> fptr_copy = ( struct mrb_io * ) DATA_PTR ( copy ) ; <S2SV_EndBug> if ( fptr_copy != NULL ) { fptr_finalize ( mrb , fptr_copy , FALSE ) ; mrb_free ( mrb , fptr_copy ) ; } <S2SV_StartBug> fptr_copy = ( struct mrb_io * ) mrb_io_alloc ( mrb ) ; <S2SV_EndBug> fptr_orig = io_get_open_fptr ( mrb , orig ) ; DATA_TYPE ( copy ) = & mrb_io_type ; DATA_PTR ( copy ) = fptr_copy ; buf = mrb_iv_get ( mrb , orig , mrb_intern_cstr ( mrb , "@buf" ) ) ; mrb_iv_set ( mrb , copy , mrb_intern_cstr ( mrb , "@buf" ) , buf ) ; fptr_copy -> fd = mrb_dup ( mrb , fptr_orig -> fd , & failed ) ; if ( failed ) { mrb_sys_fail ( mrb , 0 ) ; } mrb_fd_cloexec ( mrb , fptr_copy -> fd ) ; if ( fptr_orig -> fd2 != - 1 ) { fptr_copy -> fd2 = mrb_dup ( mrb , fptr_orig -> fd2 , & failed ) ; if ( failed ) { close ( fptr_copy -> fd ) ; mrb_sys_fail ( mrb , 0 ) ; } mrb_fd_cloexec ( mrb , fptr_copy -> fd2 ) ; } fptr_copy -> pid = fptr_orig -> pid ; fptr_copy -> readable = fptr_orig -> readable ; fptr_copy -> writable = fptr_orig -> writable ; fptr_copy -> sync = fptr_orig -> sync ; fptr_copy -> is_socket = fptr_orig -> is_socket ; return copy ; }
CWE-119 static int msg_parse_fetch ( struct ImapHeader * h , char * s ) { char tmp [ SHORT_STRING ] ; char * ptmp = NULL ; if ( ! s ) return - 1 ; while ( * s ) { SKIPWS ( s ) ; if ( mutt_str_strncasecmp ( "FLAGS" , s , 5 ) == 0 ) { s = msg_parse_flags ( h , s ) ; if ( ! s ) return - 1 ; } else if ( mutt_str_strncasecmp ( "UID" , s , 3 ) == 0 ) { s += 3 ; SKIPWS ( s ) ; if ( mutt_str_atoui ( s , & h -> data -> uid ) < 0 ) return - 1 ; s = imap_next_word ( s ) ; } else if ( mutt_str_strncasecmp ( "INTERNALDATE" , s , 12 ) == 0 ) { s += 12 ; SKIPWS ( s ) ; if ( * s != \'\\"\' ) { mutt_debug ( 1 , "bogus<S2SV_blank>INTERNALDATE<S2SV_blank>entry:<S2SV_blank>%s\\n" , s ) ; return - 1 ; } s ++ ; ptmp = tmp ; <S2SV_StartBug> while ( * s && * s != \'\\"\' ) <S2SV_EndBug> * ptmp ++ = * s ++ ; if ( * s != \'\\"\' ) return - 1 ; s ++ ; * ptmp = '\\0' ; h -> received = mutt_date_parse_imap ( tmp ) ; } else if ( mutt_str_strncasecmp ( "RFC822.SIZE" , s , 11 ) == 0 ) { s += 11 ; SKIPWS ( s ) ; ptmp = tmp ; <S2SV_StartBug> while ( isdigit ( ( unsigned char ) * s ) ) <S2SV_EndBug> * ptmp ++ = * s ++ ; * ptmp = '\\0' ; if ( mutt_str_atol ( tmp , & h -> content_length ) < 0 ) return - 1 ; } else if ( ( mutt_str_strncasecmp ( "BODY" , s , 4 ) == 0 ) || ( mutt_str_strncasecmp ( "RFC822.HEADER" , s , 13 ) == 0 ) ) { return - 2 ; } else if ( * s == ')' ) s ++ ; else if ( * s ) { imap_error ( "msg_parse_fetch" , s ) ; return - 1 ; } } return 0 ; }
CWE-20 static int cmd_handle_untagged ( struct ImapData * idata ) { unsigned int count = 0 ; char * s = imap_next_word ( idata -> buf ) ; char * pn = imap_next_word ( s ) ; if ( ( idata -> state >= IMAP_SELECTED ) && isdigit ( ( unsigned char ) * s ) ) { pn = s ; s = imap_next_word ( s ) ; if ( mutt_str_strncasecmp ( "EXISTS" , s , 6 ) == 0 ) { mutt_debug ( 2 , "Handling<S2SV_blank>EXISTS\\n" ) ; if ( mutt_str_atoui ( pn , & count ) < 0 ) { mutt_debug ( 1 , "Malformed<S2SV_blank>EXISTS:<S2SV_blank>\'%s\'\\n" , pn ) ; } if ( ! ( idata -> reopen & IMAP_EXPUNGE_PENDING ) && count < idata -> max_msn ) { mutt_debug ( 1 , "Message<S2SV_blank>count<S2SV_blank>is<S2SV_blank>out<S2SV_blank>of<S2SV_blank>sync\\n" ) ; return 0 ; } else if ( count == idata -> max_msn ) mutt_debug ( 3 , "superfluous<S2SV_blank>EXISTS<S2SV_blank>message.\\n" ) ; else { if ( ! ( idata -> reopen & IMAP_EXPUNGE_PENDING ) ) { mutt_debug ( 2 , "New<S2SV_blank>mail<S2SV_blank>in<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>%d<S2SV_blank>messages<S2SV_blank>total.\\n" , idata -> mailbox , count ) ; idata -> reopen |= IMAP_NEWMAIL_PENDING ; } idata -> new_mail_count = count ; } } else if ( mutt_str_strncasecmp ( "EXPUNGE" , s , 7 ) == 0 ) cmd_parse_expunge ( idata , pn ) ; else if ( mutt_str_strncasecmp ( "FETCH" , s , 5 ) == 0 ) cmd_parse_fetch ( idata , pn ) ; } else if ( mutt_str_strncasecmp ( "CAPABILITY" , s , 10 ) == 0 ) cmd_parse_capability ( idata , s ) ; else if ( mutt_str_strncasecmp ( "OK<S2SV_blank>[CAPABILITY" , s , 14 ) == 0 ) cmd_parse_capability ( idata , pn ) ; else if ( mutt_str_strncasecmp ( "OK<S2SV_blank>[CAPABILITY" , pn , 14 ) == 0 ) cmd_parse_capability ( idata , imap_next_word ( pn ) ) ; else if ( mutt_str_strncasecmp ( "LIST" , s , 4 ) == 0 ) cmd_parse_list ( idata , s ) ; else if ( mutt_str_strncasecmp ( "LSUB" , s , 4 ) == 0 ) cmd_parse_lsub ( idata , s ) ; else if ( mutt_str_strncasecmp ( "MYRIGHTS" , s , 8 ) == 0 ) cmd_parse_myrights ( idata , s ) ; else if ( mutt_str_strncasecmp ( "SEARCH" , s , 6 ) == 0 ) cmd_parse_search ( idata , s ) ; else if ( mutt_str_strncasecmp ( "STATUS" , s , 6 ) == 0 ) cmd_parse_status ( idata , s ) ; else if ( mutt_str_strncasecmp ( "ENABLED" , s , 7 ) == 0 ) cmd_parse_enabled ( idata , s ) ; else if ( mutt_str_strncasecmp ( "BYE" , s , 3 ) == 0 ) { mutt_debug ( 2 , "Handling<S2SV_blank>BYE\\n" ) ; if ( idata -> status == IMAP_BYE ) return 0 ; s += 3 ; SKIPWS ( s ) ; mutt_error ( "%s" , s ) ; cmd_handle_fatal ( idata ) ; return - 1 ; } else if ( ImapServernoise && ( mutt_str_strncasecmp ( "NO" , s , 2 ) == 0 ) ) { mutt_debug ( 2 , "Handling<S2SV_blank>untagged<S2SV_blank>NO\\n" ) ; <S2SV_StartBug> mutt_error ( "%s" , s + 3 ) ; <S2SV_EndBug> } return 0 ; }
CWE-20 static void cmd_parse_status ( struct ImapData * idata , char * s ) { char * value = NULL ; struct Buffy * inc = NULL ; struct ImapMbox mx ; struct ImapStatus * status = NULL ; unsigned int olduv , oldun ; unsigned int litlen ; short new = 0 ; short new_msg_count = 0 ; char * mailbox = imap_next_word ( s ) ; if ( imap_get_literal_count ( mailbox , & litlen ) == 0 ) { if ( imap_cmd_step ( idata ) != IMAP_CMD_CONTINUE ) { <S2SV_StartBug> idata -> status = IMAP_FATAL ; <S2SV_EndBug> return ; } mailbox = idata -> buf ; s = mailbox + litlen ; * s = '\\0' ; s ++ ; SKIPWS ( s ) ; } else { s = imap_next_word ( mailbox ) ; * ( s - 1 ) = '\\0' ; imap_unmunge_mbox_name ( idata , mailbox ) ; } status = imap_mboxcache_get ( idata , mailbox , 1 ) ; olduv = status -> uidvalidity ; oldun = status -> uidnext ; if ( * s ++ != '(' ) { mutt_debug ( 1 , "Error<S2SV_blank>parsing<S2SV_blank>STATUS\\n" ) ; return ; } while ( * s && * s != ')' ) { value = imap_next_word ( s ) ; errno = 0 ; const unsigned long ulcount = strtoul ( value , & value , 10 ) ; if ( ( ( errno == ERANGE ) && ( ulcount == ULONG_MAX ) ) || ( ( unsigned int ) ulcount != ulcount ) ) { mutt_debug ( 1 , "Error<S2SV_blank>parsing<S2SV_blank>STATUS<S2SV_blank>number\\n" ) ; return ; } const unsigned int count = ( unsigned int ) ulcount ; if ( mutt_str_strncmp ( "MESSAGES" , s , 8 ) == 0 ) { status -> messages = count ; new_msg_count = 1 ; } else if ( mutt_str_strncmp ( "RECENT" , s , 6 ) == 0 ) status -> recent = count ; else if ( mutt_str_strncmp ( "UIDNEXT" , s , 7 ) == 0 ) status -> uidnext = count ; else if ( mutt_str_strncmp ( "UIDVALIDITY" , s , 11 ) == 0 ) status -> uidvalidity = count ; else if ( mutt_str_strncmp ( "UNSEEN" , s , 6 ) == 0 ) status -> unseen = count ; s = value ; if ( * s && * s != ')' ) s = imap_next_word ( s ) ; } mutt_debug ( 3 , "%s<S2SV_blank>(UIDVALIDITY:<S2SV_blank>%u,<S2SV_blank>UIDNEXT:<S2SV_blank>%u)<S2SV_blank>%d<S2SV_blank>messages,<S2SV_blank>%d<S2SV_blank>recent,<S2SV_blank>%d<S2SV_blank>unseen\\n" , status -> name , status -> uidvalidity , status -> uidnext , status -> messages , status -> recent , status -> unseen ) ; if ( idata -> cmddata && idata -> cmdtype == IMAP_CT_STATUS ) { memcpy ( idata -> cmddata , status , sizeof ( struct ImapStatus ) ) ; return ; } mutt_debug ( 3 , "Running<S2SV_blank>default<S2SV_blank>STATUS<S2SV_blank>handler\\n" ) ; for ( inc = Incoming ; inc ; inc = inc -> next ) { if ( inc -> magic != MUTT_IMAP ) continue ; if ( imap_parse_path ( inc -> path , & mx ) < 0 ) { mutt_debug ( 1 , "Error<S2SV_blank>parsing<S2SV_blank>mailbox<S2SV_blank>%s,<S2SV_blank>skipping\\n" , inc -> path ) ; continue ; } if ( imap_account_match ( & idata -> conn -> account , & mx . account ) ) { if ( mx . mbox ) { value = mutt_str_strdup ( mx . mbox ) ; imap_fix_path ( idata , mx . mbox , value , mutt_str_strlen ( value ) + 1 ) ; FREE ( & mx . mbox ) ; } else value = mutt_str_strdup ( "INBOX" ) ; if ( value && ( imap_mxcmp ( mailbox , value ) == 0 ) ) { mutt_debug ( 3 , "Found<S2SV_blank>%s<S2SV_blank>in<S2SV_blank>buffy<S2SV_blank>list<S2SV_blank>(OV:<S2SV_blank>%u<S2SV_blank>ON:<S2SV_blank>%u<S2SV_blank>U:<S2SV_blank>%d)\\n" , mailbox , olduv , oldun , status -> unseen ) ; if ( MailCheckRecent ) { if ( olduv && olduv == status -> uidvalidity ) { if ( oldun < status -> uidnext ) new = ( status -> unseen > 0 ) ; } else if ( ! olduv && ! oldun ) { new = ( status -> recent > 0 ) ; } else new = ( status -> unseen > 0 ) ; } else new = ( status -> unseen > 0 ) ; # ifdef USE_SIDEBAR if ( ( inc -> new != new ) || ( inc -> msg_count != status -> messages ) || ( inc -> msg_unread != status -> unseen ) ) { mutt_menu_set_current_redraw ( REDRAW_SIDEBAR ) ; } # endif inc -> new = new ; if ( new_msg_count ) inc -> msg_count = status -> messages ; inc -> msg_unread = status -> unseen ; if ( inc -> new ) { status -> uidnext = oldun ; } FREE ( & value ) ; return ; } FREE ( & value ) ; } FREE ( & mx . mbox ) ; } }
CWE-119 int nntp_add_group ( char * line , void * data ) { struct NntpServer * nserv = data ; struct NntpData * nntp_data = NULL ; <S2SV_StartBug> char group [ LONG_STRING ] ; <S2SV_EndBug> char desc [ HUGE_STRING ] = "" ; char mod ; anum_t first , last ; if ( ! nserv || ! line ) return 0 ; <S2SV_StartBug> if ( sscanf ( line , "%s<S2SV_blank>" ANUM "<S2SV_blank>" ANUM "<S2SV_blank>%c<S2SV_blank>%[^\\n]" , group , & last , & first , & mod , desc ) < 4 ) <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> nntp_data = nntp_data_find ( nserv , group ) ; nntp_data -> deleted = false ; nntp_data -> first_message = first ; nntp_data -> last_message = last ; nntp_data -> allowed = ( mod == 'y' ) || ( mod == 'm' ) ; mutt_str_replace ( & nntp_data -> desc , desc ) ; if ( nntp_data -> newsrc_ent || nntp_data -> last_cached ) nntp_group_unread_stat ( nntp_data ) ; else if ( nntp_data -> last_message && nntp_data -> first_message <= nntp_data -> last_message ) nntp_data -> unread = nntp_data -> last_message - nntp_data -> first_message + 1 ; else nntp_data -> unread = 0 ; return 0 ; }
CWE-191 void imap_quote_string ( char * dest , size_t dlen , const char * src , bool quote_backtick ) { const char * quote = "`\\"\\\\" ; if ( ! quote_backtick ) quote ++ ; char * pt = dest ; const char * s = src ; * pt ++ = \'"\' ; dlen -= 2 ; for ( ; * s && dlen ; s ++ ) { if ( strchr ( quote , * s ) ) { <S2SV_StartBug> dlen -= 2 ; <S2SV_EndBug> if ( dlen == 0 ) break ; * pt ++ = '\\\\' ; * pt ++ = * s ; } else { * pt ++ = * s ; dlen -- ; } } * pt ++ = \'"\' ; * pt = '\\0' ; }
CWE-119 enum ImapAuthRes imap_auth_cram_md5 ( struct ImapData * idata , const char * method ) { char ibuf [ LONG_STRING * 2 ] , obuf [ LONG_STRING ] ; unsigned char hmac_response [ MD5_DIGEST_LEN ] ; int len ; int rc ; if ( ! mutt_bit_isset ( idata -> capabilities , ACRAM_MD5 ) ) return IMAP_AUTH_UNAVAIL ; mutt_message ( _ ( "Authenticating<S2SV_blank>(CRAM-MD5)..." ) ) ; if ( mutt_account_getlogin ( & idata -> conn -> account ) < 0 ) return IMAP_AUTH_FAILURE ; if ( mutt_account_getpass ( & idata -> conn -> account ) < 0 ) return IMAP_AUTH_FAILURE ; imap_cmd_start ( idata , "AUTHENTICATE<S2SV_blank>CRAM-MD5" ) ; do rc = imap_cmd_step ( idata ) ; while ( rc == IMAP_CMD_CONTINUE ) ; if ( rc != IMAP_CMD_RESPOND ) { mutt_debug ( 1 , "Invalid<S2SV_blank>response<S2SV_blank>from<S2SV_blank>server:<S2SV_blank>%s\\n" , ibuf ) ; goto bail ; } <S2SV_StartBug> len = mutt_b64_decode ( obuf , idata -> buf + 2 ) ; <S2SV_EndBug> if ( len == - 1 ) { mutt_debug ( 1 , "Error<S2SV_blank>decoding<S2SV_blank>base64<S2SV_blank>response.\\n" ) ; goto bail ; } obuf [ len ] = '\\0' ; mutt_debug ( 2 , "CRAM<S2SV_blank>challenge:<S2SV_blank>%s\\n" , obuf ) ; hmac_md5 ( idata -> conn -> account . pass , obuf , hmac_response ) ; int off = snprintf ( obuf , sizeof ( obuf ) , "%s<S2SV_blank>" , idata -> conn -> account . user ) ; mutt_md5_toascii ( hmac_response , obuf + off ) ; mutt_debug ( 2 , "CRAM<S2SV_blank>response:<S2SV_blank>%s\\n" , obuf ) ; mutt_b64_encode ( ibuf , obuf , strlen ( obuf ) , sizeof ( ibuf ) - 2 ) ; mutt_str_strcat ( ibuf , sizeof ( ibuf ) , "\\r\\n" ) ; mutt_socket_send ( idata -> conn , ibuf ) ; do rc = imap_cmd_step ( idata ) ; while ( rc == IMAP_CMD_CONTINUE ) ; if ( rc != IMAP_CMD_OK ) { mutt_debug ( 1 , "Error<S2SV_blank>receiving<S2SV_blank>server<S2SV_blank>response.\\n" ) ; goto bail ; } if ( imap_code ( idata -> buf ) ) return IMAP_AUTH_SUCCESS ; bail : mutt_error ( _ ( "CRAM-MD5<S2SV_blank>authentication<S2SV_blank>failed." ) ) ; return IMAP_AUTH_FAILURE ; }
CWE-119 enum ImapAuthRes imap_auth_gss ( struct ImapData * idata , const char * method ) { gss_buffer_desc request_buf , send_token ; gss_buffer_t sec_token ; gss_name_t target_name ; gss_ctx_id_t context ; gss_OID mech_name ; char server_conf_flags ; gss_qop_t quality ; int cflags ; OM_uint32 maj_stat , min_stat ; char buf1 [ GSS_BUFSIZE ] , buf2 [ GSS_BUFSIZE ] ; unsigned long buf_size ; int rc ; if ( ! mutt_bit_isset ( idata -> capabilities , AGSSAPI ) ) return IMAP_AUTH_UNAVAIL ; if ( mutt_account_getuser ( & idata -> conn -> account ) < 0 ) return IMAP_AUTH_FAILURE ; snprintf ( buf1 , sizeof ( buf1 ) , "imap@%s" , idata -> conn -> account . host ) ; request_buf . value = buf1 ; request_buf . length = strlen ( buf1 ) ; maj_stat = gss_import_name ( & min_stat , & request_buf , gss_nt_service_name , & target_name ) ; if ( maj_stat != GSS_S_COMPLETE ) { mutt_debug ( 2 , "Couldn\'t<S2SV_blank>get<S2SV_blank>service<S2SV_blank>name<S2SV_blank>for<S2SV_blank>[%s]\\n" , buf1 ) ; return IMAP_AUTH_UNAVAIL ; } else if ( DebugLevel >= 2 ) { gss_display_name ( & min_stat , target_name , & request_buf , & mech_name ) ; mutt_debug ( 2 , "Using<S2SV_blank>service<S2SV_blank>name<S2SV_blank>[%s]\\n" , ( char * ) request_buf . value ) ; gss_release_buffer ( & min_stat , & request_buf ) ; } sec_token = GSS_C_NO_BUFFER ; context = GSS_C_NO_CONTEXT ; maj_stat = gss_init_sec_context ( & min_stat , GSS_C_NO_CREDENTIAL , & context , target_name , GSS_C_NO_OID , GSS_C_MUTUAL_FLAG | GSS_C_SEQUENCE_FLAG , 0 , GSS_C_NO_CHANNEL_BINDINGS , sec_token , NULL , & send_token , ( unsigned int * ) & cflags , NULL ) ; if ( maj_stat != GSS_S_COMPLETE && maj_stat != GSS_S_CONTINUE_NEEDED ) { print_gss_error ( maj_stat , min_stat ) ; mutt_debug ( 1 , "Error<S2SV_blank>acquiring<S2SV_blank>credentials<S2SV_blank>-<S2SV_blank>no<S2SV_blank>TGT?\\n" ) ; gss_release_name ( & min_stat , & target_name ) ; return IMAP_AUTH_UNAVAIL ; } mutt_message ( _ ( "Authenticating<S2SV_blank>(GSSAPI)..." ) ) ; imap_cmd_start ( idata , "AUTHENTICATE<S2SV_blank>GSSAPI" ) ; do rc = imap_cmd_step ( idata ) ; while ( rc == IMAP_CMD_CONTINUE ) ; if ( rc != IMAP_CMD_RESPOND ) { mutt_debug ( 2 , "Invalid<S2SV_blank>response<S2SV_blank>from<S2SV_blank>server:<S2SV_blank>%s\\n" , buf1 ) ; gss_release_name ( & min_stat , & target_name ) ; goto bail ; } mutt_debug ( 2 , "Sending<S2SV_blank>credentials\\n" ) ; mutt_b64_encode ( buf1 , send_token . value , send_token . length , sizeof ( buf1 ) - 2 ) ; gss_release_buffer ( & min_stat , & send_token ) ; mutt_str_strcat ( buf1 , sizeof ( buf1 ) , "\\r\\n" ) ; mutt_socket_send ( idata -> conn , buf1 ) ; while ( maj_stat == GSS_S_CONTINUE_NEEDED ) { do rc = imap_cmd_step ( idata ) ; while ( rc == IMAP_CMD_CONTINUE ) ; if ( rc != IMAP_CMD_RESPOND ) { mutt_debug ( 1 , "#1<S2SV_blank>Error<S2SV_blank>receiving<S2SV_blank>server<S2SV_blank>response.\\n" ) ; gss_release_name ( & min_stat , & target_name ) ; goto bail ; } <S2SV_StartBug> request_buf . length = mutt_b64_decode ( buf2 , idata -> buf + 2 ) ; <S2SV_EndBug> request_buf . value = buf2 ; sec_token = & request_buf ; maj_stat = gss_init_sec_context ( & min_stat , GSS_C_NO_CREDENTIAL , & context , target_name , GSS_C_NO_OID , GSS_C_MUTUAL_FLAG | GSS_C_SEQUENCE_FLAG , 0 , GSS_C_NO_CHANNEL_BINDINGS , sec_token , NULL , & send_token , ( unsigned int * ) & cflags , NULL ) ; if ( maj_stat != GSS_S_COMPLETE && maj_stat != GSS_S_CONTINUE_NEEDED ) { print_gss_error ( maj_stat , min_stat ) ; mutt_debug ( 1 , "Error<S2SV_blank>exchanging<S2SV_blank>credentials\\n" ) ; gss_release_name ( & min_stat , & target_name ) ; goto err_abort_cmd ; } mutt_b64_encode ( buf1 , send_token . value , send_token . length , sizeof ( buf1 ) - 2 ) ; gss_release_buffer ( & min_stat , & send_token ) ; mutt_str_strcat ( buf1 , sizeof ( buf1 ) , "\\r\\n" ) ; mutt_socket_send ( idata -> conn , buf1 ) ; } gss_release_name ( & min_stat , & target_name ) ; do rc = imap_cmd_step ( idata ) ; while ( rc == IMAP_CMD_CONTINUE ) ; if ( rc != IMAP_CMD_RESPOND ) { mutt_debug ( 1 , "#2<S2SV_blank>Error<S2SV_blank>receiving<S2SV_blank>server<S2SV_blank>response.\\n" ) ; goto bail ; } <S2SV_StartBug> request_buf . length = mutt_b64_decode ( buf2 , idata -> buf + 2 ) ; <S2SV_EndBug> request_buf . value = buf2 ; maj_stat = gss_unwrap ( & min_stat , context , & request_buf , & send_token , & cflags , & quality ) ; if ( maj_stat != GSS_S_COMPLETE ) { print_gss_error ( maj_stat , min_stat ) ; mutt_debug ( 2 , "Couldn\'t<S2SV_blank>unwrap<S2SV_blank>security<S2SV_blank>level<S2SV_blank>data\\n" ) ; gss_release_buffer ( & min_stat , & send_token ) ; goto err_abort_cmd ; } mutt_debug ( 2 , "Credential<S2SV_blank>exchange<S2SV_blank>complete\\n" ) ; server_conf_flags = ( ( char * ) send_token . value ) [ 0 ] ; if ( ! ( ( ( char * ) send_token . value ) [ 0 ] & GSS_AUTH_P_NONE ) ) { mutt_debug ( 2 , "Server<S2SV_blank>requires<S2SV_blank>integrity<S2SV_blank>or<S2SV_blank>privacy\\n" ) ; gss_release_buffer ( & min_stat , & send_token ) ; goto err_abort_cmd ; } ( ( char * ) send_token . value ) [ 0 ] = '\\0' ; buf_size = ntohl ( * ( ( long * ) send_token . value ) ) ; gss_release_buffer ( & min_stat , & send_token ) ; mutt_debug ( 2 , "Unwrapped<S2SV_blank>security<S2SV_blank>level<S2SV_blank>flags:<S2SV_blank>%c%c%c\\n" , ( server_conf_flags & GSS_AUTH_P_NONE ) ? 'N' : '-' , ( server_conf_flags & GSS_AUTH_P_INTEGRITY ) ? 'I' : '-' , ( server_conf_flags & GSS_AUTH_P_PRIVACY ) ? 'P' : '-' ) ; mutt_debug ( 2 , "Maximum<S2SV_blank>GSS<S2SV_blank>token<S2SV_blank>size<S2SV_blank>is<S2SV_blank>%ld\\n" , buf_size ) ; buf_size = htonl ( buf_size ) ; memcpy ( buf1 , & buf_size , 4 ) ; buf1 [ 0 ] = GSS_AUTH_P_NONE ; strncpy ( buf1 + 4 , idata -> conn -> account . user , sizeof ( buf1 ) - 4 ) ; request_buf . value = buf1 ; request_buf . length = 4 + strlen ( idata -> conn -> account . user ) ; maj_stat = gss_wrap ( & min_stat , context , 0 , GSS_C_QOP_DEFAULT , & request_buf , & cflags , & send_token ) ; if ( maj_stat != GSS_S_COMPLETE ) { mutt_debug ( 2 , "Error<S2SV_blank>creating<S2SV_blank>login<S2SV_blank>request\\n" ) ; goto err_abort_cmd ; } mutt_b64_encode ( buf1 , send_token . value , send_token . length , sizeof ( buf1 ) - 2 ) ; mutt_debug ( 2 , "Requesting<S2SV_blank>authorisation<S2SV_blank>as<S2SV_blank>%s\\n" , idata -> conn -> account . user ) ; mutt_str_strcat ( buf1 , sizeof ( buf1 ) , "\\r\\n" ) ; mutt_socket_send ( idata -> conn , buf1 ) ; do rc = imap_cmd_step ( idata ) ; while ( rc == IMAP_CMD_CONTINUE ) ; if ( rc == IMAP_CMD_RESPOND ) { mutt_debug ( 1 , "Unexpected<S2SV_blank>server<S2SV_blank>continuation<S2SV_blank>request.\\n" ) ; goto err_abort_cmd ; } if ( imap_code ( idata -> buf ) ) { mutt_debug ( 2 , "Releasing<S2SV_blank>GSS<S2SV_blank>credentials\\n" ) ; maj_stat = gss_delete_sec_context ( & min_stat , & context , & send_token ) ; if ( maj_stat != GSS_S_COMPLETE ) mutt_debug ( 1 , "Error<S2SV_blank>releasing<S2SV_blank>credentials\\n" ) ; gss_release_buffer ( & min_stat , & send_token ) ; return IMAP_AUTH_SUCCESS ; } else goto bail ; err_abort_cmd : mutt_socket_send ( idata -> conn , "*\\r\\n" ) ; do rc = imap_cmd_step ( idata ) ; while ( rc == IMAP_CMD_CONTINUE ) ; bail : mutt_error ( _ ( "GSSAPI<S2SV_blank>authentication<S2SV_blank>failed." ) ) ; return IMAP_AUTH_FAILURE ; }
CWE-119 <S2SV_StartBug> int mutt_b64_decode ( char * out , const char * in ) <S2SV_EndBug> { int len = 0 ; unsigned char digit4 ; do { const unsigned char digit1 = in [ 0 ] ; if ( ( digit1 > 127 ) || ( base64val ( digit1 ) == BAD ) ) return - 1 ; const unsigned char digit2 = in [ 1 ] ; if ( ( digit2 > 127 ) || ( base64val ( digit2 ) == BAD ) ) return - 1 ; const unsigned char digit3 = in [ 2 ] ; if ( ( digit3 > 127 ) || ( ( digit3 != '=' ) && ( base64val ( digit3 ) == BAD ) ) ) return - 1 ; digit4 = in [ 3 ] ; if ( ( digit4 > 127 ) || ( ( digit4 != '=' ) && ( base64val ( digit4 ) == BAD ) ) ) return - 1 ; in += 4 ; <S2SV_StartBug> * out ++ = ( base64val ( digit1 ) << 2 ) | ( base64val ( digit2 ) >> 4 ) ; <S2SV_EndBug> len ++ ; if ( digit3 != '=' ) { <S2SV_StartBug> * out ++ = ( ( base64val ( digit2 ) << 4 ) & 0xf0 ) | ( base64val ( digit3 ) >> 2 ) ; <S2SV_EndBug> len ++ ; if ( digit4 != '=' ) { <S2SV_StartBug> * out ++ = ( ( base64val ( digit3 ) << 6 ) & 0xc0 ) | base64val ( digit4 ) ; <S2SV_EndBug> len ++ ; } } } while ( * in && digit4 != '=' ) ; return len ; }
CWE-119 static char * rfc2047_decode_word ( const char * s , size_t len , enum ContentEncoding enc ) { const char * it = s ; const char * end = s + len ; if ( enc == ENCQUOTEDPRINTABLE ) { struct Buffer buf = { 0 } ; for ( ; it < end ; ++ it ) { if ( * it == '_' ) { mutt_buffer_addch ( & buf , '<S2SV_blank>' ) ; } else if ( ( * it == '=' ) && ( ! ( it [ 1 ] & ~ 127 ) && hexval ( it [ 1 ] ) != - 1 ) && ( ! ( it [ 2 ] & ~ 127 ) && hexval ( it [ 2 ] ) != - 1 ) ) { mutt_buffer_addch ( & buf , ( hexval ( it [ 1 ] ) << 4 ) | hexval ( it [ 2 ] ) ) ; it += 2 ; } else { mutt_buffer_addch ( & buf , * it ) ; } } mutt_buffer_addch ( & buf , '\\0' ) ; return buf . data ; } else if ( enc == ENCBASE64 ) { <S2SV_StartBug> char * out = mutt_mem_malloc ( 3 * len / 4 + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> int dlen = mutt_b64_decode ( out , it ) ; <S2SV_EndBug> if ( dlen == - 1 ) { FREE ( & out ) ; return NULL ; } out [ dlen ] = '\\0' ; return out ; } assert ( 0 ) ; return NULL ; }
CWE-119 void test_base64_decode ( void ) { char buffer [ 16 ] ; <S2SV_StartBug> int len = mutt_b64_decode ( buffer , encoded ) ; <S2SV_EndBug> if ( ! TEST_CHECK ( len == sizeof ( clear ) - 1 ) ) { TEST_MSG ( "Expected:<S2SV_blank>%zu" , sizeof ( clear ) - 1 ) ; TEST_MSG ( "Actual<S2SV_blank><S2SV_blank>:<S2SV_blank>%zu" , len ) ; } buffer [ len ] = '\\0' ; if ( ! TEST_CHECK ( strcmp ( buffer , clear ) == 0 ) ) { TEST_MSG ( "Expected:<S2SV_blank>%s" , clear ) ; TEST_MSG ( "Actual<S2SV_blank><S2SV_blank>:<S2SV_blank>%s" , buffer ) ; } }
CWE-119 void test_base64_lengths ( void ) { const char * in = "FuseMuse" ; char out1 [ 32 ] ; char out2 [ 32 ] ; size_t enclen ; int declen ; enclen = mutt_b64_encode ( out1 , in , 0 , 32 ) ; if ( ! TEST_CHECK ( enclen == 0 ) ) { TEST_MSG ( "Expected:<S2SV_blank>%zu" , 0 ) ; TEST_MSG ( "Actual<S2SV_blank><S2SV_blank>:<S2SV_blank>%zu" , enclen ) ; } out1 [ 0 ] = '\\0' ; <S2SV_StartBug> declen = mutt_b64_decode ( out2 , out1 ) ; <S2SV_EndBug> if ( ! TEST_CHECK ( declen == - 1 ) ) { TEST_MSG ( "Expected:<S2SV_blank>%zu" , - 1 ) ; TEST_MSG ( "Actual<S2SV_blank><S2SV_blank>:<S2SV_blank>%zu" , declen ) ; } for ( size_t i = 1 ; i <= 8 ; ++ i ) { enclen = mutt_b64_encode ( out1 , in , i , 32 ) ; size_t exp = ( ( i + 2 ) / 3 ) << 2 ; if ( ! TEST_CHECK ( enclen == exp ) ) { TEST_MSG ( "Expected:<S2SV_blank>%zu" , exp ) ; TEST_MSG ( "Actual<S2SV_blank><S2SV_blank>:<S2SV_blank>%zu" , enclen ) ; } <S2SV_StartBug> declen = mutt_b64_decode ( out2 , out1 ) ; <S2SV_EndBug> if ( ! TEST_CHECK ( declen == i ) ) { TEST_MSG ( "Expected:<S2SV_blank>%zu" , i ) ; TEST_MSG ( "Actual<S2SV_blank><S2SV_blank>:<S2SV_blank>%zu" , declen ) ; } out2 [ declen ] = '\\0' ; if ( ! TEST_CHECK ( strncmp ( out2 , in , i ) == 0 ) ) { TEST_MSG ( "Expected:<S2SV_blank>%s" , in ) ; TEST_MSG ( "Actual<S2SV_blank><S2SV_blank>:<S2SV_blank>%s" , out2 ) ; } } }
CWE-824 static int fetch_uidl ( char * line , void * data ) { int i , index ; struct Context * ctx = ( struct Context * ) data ; struct PopData * pop_data = ( struct PopData * ) ctx -> data ; char * endp = NULL ; errno = 0 ; index = strtol ( line , & endp , 10 ) ; if ( errno ) return - 1 ; while ( * endp == '<S2SV_blank>' ) endp ++ ; memmove ( line , endp , strlen ( endp ) + 1 ) ; <S2SV_StartBug> for ( i = 0 ; i < ctx -> msgcount ; i ++ ) <S2SV_EndBug> if ( mutt_str_strcmp ( line , ctx -> hdrs [ i ] -> data ) == 0 ) break ; if ( i == ctx -> msgcount ) { mutt_debug ( 1 , "new<S2SV_blank>header<S2SV_blank>%d<S2SV_blank>%s\\n" , index , line ) ; if ( i >= ctx -> hdrmax ) mx_alloc_memory ( ctx ) ; ctx -> msgcount ++ ; ctx -> hdrs [ i ] = mutt_header_new ( ) ; ctx -> hdrs [ i ] -> data = mutt_str_strdup ( line ) ; } else if ( ctx -> hdrs [ i ] -> index != index - 1 ) pop_data -> clear_cache = true ; ctx -> hdrs [ i ] -> refno = index ; ctx -> hdrs [ i ] -> index = index - 1 ; return 0 ; }
CWE-77 int imap_subscribe ( char * path , bool subscribe ) { struct ImapData * idata = NULL ; char buf [ LONG_STRING ] ; char mbox [ LONG_STRING ] ; char errstr [ STRING ] ; struct Buffer err , token ; struct ImapMbox mx ; <S2SV_StartBug> if ( ! mx_is_imap ( path ) || imap_parse_path ( path , & mx ) || ! mx . mbox ) <S2SV_EndBug> { mutt_error ( _ ( "Bad<S2SV_blank>mailbox<S2SV_blank>name" ) ) ; return - 1 ; } idata = imap_conn_find ( & ( mx . account ) , 0 ) ; if ( ! idata ) goto fail ; imap_fix_path ( idata , mx . mbox , buf , sizeof ( buf ) ) ; if ( ! * buf ) mutt_str_strfcpy ( buf , "INBOX" , sizeof ( buf ) ) ; if ( ImapCheckSubscribed ) { mutt_buffer_init ( & token ) ; mutt_buffer_init ( & err ) ; err . data = errstr ; err . dsize = sizeof ( errstr ) ; <S2SV_StartBug> snprintf ( mbox , sizeof ( mbox ) , "%smailboxes<S2SV_blank>\\"%s\\"" , subscribe ? "" : "un" , path ) ; <S2SV_EndBug> if ( mutt_parse_rc_line ( mbox , & token , & err ) ) mutt_debug ( 1 , "Error<S2SV_blank>adding<S2SV_blank>subscribed<S2SV_blank>mailbox:<S2SV_blank>%s\\n" , errstr ) ; FREE ( & token . data ) ; } if ( subscribe ) mutt_message ( _ ( "Subscribing<S2SV_blank>to<S2SV_blank>%s..." ) , buf ) ; else mutt_message ( _ ( "Unsubscribing<S2SV_blank>from<S2SV_blank>%s..." ) , buf ) ; imap_munge_mbox_name ( idata , mbox , sizeof ( mbox ) , buf ) ; snprintf ( buf , sizeof ( buf ) , "%sSUBSCRIBE<S2SV_blank>%s" , subscribe ? "" : "UN" , mbox ) ; if ( imap_exec ( idata , buf , 0 ) < 0 ) goto fail ; imap_unmunge_mbox_name ( idata , mx . mbox ) ; if ( subscribe ) mutt_message ( _ ( "Subscribed<S2SV_blank>to<S2SV_blank>%s" ) , mx . mbox ) ; else mutt_message ( _ ( "Unsubscribed<S2SV_blank>from<S2SV_blank>%s" ) , mx . mbox ) ; FREE ( & mx . mbox ) ; return 0 ; fail : FREE ( & mx . mbox ) ; return - 1 ; }
CWE-22 static int msg_cache_check ( const char * id , struct BodyCache * bcache , void * data ) { struct Context * ctx = ( struct Context * ) data ; if ( ! ctx ) return - 1 ; struct PopData * pop_data = ( struct PopData * ) ctx -> data ; if ( ! pop_data ) return - 1 ; # ifdef USE_HCACHE if ( strcmp ( HC_FNAME "." HC_FEXT , id ) == 0 ) return 0 ; # endif for ( int i = 0 ; i < ctx -> msgcount ; i ++ ) { if ( ctx -> hdrs [ i ] -> data && ( mutt_str_strcmp ( ctx -> hdrs [ i ] -> data , id ) == 0 ) ) return 0 ; } <S2SV_StartBug> return mutt_bcache_del ( bcache , id ) ; <S2SV_EndBug> }
CWE-22 static int pop_fetch_headers ( struct Context * ctx ) { struct PopData * pop_data = ( struct PopData * ) ctx -> data ; struct Progress progress ; # ifdef USE_HCACHE header_cache_t * hc = pop_hcache_open ( pop_data , ctx -> path ) ; # endif time ( & pop_data -> check_time ) ; pop_data -> clear_cache = false ; for ( int i = 0 ; i < ctx -> msgcount ; i ++ ) ctx -> hdrs [ i ] -> refno = - 1 ; const int old_count = ctx -> msgcount ; int ret = pop_fetch_data ( pop_data , "UIDL\\r\\n" , NULL , fetch_uidl , ctx ) ; const int new_count = ctx -> msgcount ; ctx -> msgcount = old_count ; if ( pop_data -> cmd_uidl == 2 ) { if ( ret == 0 ) { pop_data -> cmd_uidl = 1 ; mutt_debug ( 1 , "set<S2SV_blank>UIDL<S2SV_blank>capability\\n" ) ; } if ( ret == - 2 && pop_data -> cmd_uidl == 2 ) { pop_data -> cmd_uidl = 0 ; mutt_debug ( 1 , "unset<S2SV_blank>UIDL<S2SV_blank>capability\\n" ) ; snprintf ( pop_data -> err_msg , sizeof ( pop_data -> err_msg ) , "%s" , _ ( "Command<S2SV_blank>UIDL<S2SV_blank>is<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>server." ) ) ; } } if ( ! ctx -> quiet ) { mutt_progress_init ( & progress , _ ( "Fetching<S2SV_blank>message<S2SV_blank>headers..." ) , MUTT_PROGRESS_MSG , ReadInc , new_count - old_count ) ; } if ( ret == 0 ) { int i , deleted ; for ( i = 0 , deleted = 0 ; i < old_count ; i ++ ) { if ( ctx -> hdrs [ i ] -> refno == - 1 ) { ctx -> hdrs [ i ] -> deleted = true ; deleted ++ ; } } if ( deleted > 0 ) { mutt_error ( ngettext ( "%d<S2SV_blank>message<S2SV_blank>has<S2SV_blank>been<S2SV_blank>lost.<S2SV_blank>Try<S2SV_blank>reopening<S2SV_blank>the<S2SV_blank>mailbox." , "%d<S2SV_blank>messages<S2SV_blank>have<S2SV_blank>been<S2SV_blank>lost.<S2SV_blank>Try<S2SV_blank>reopening<S2SV_blank>the<S2SV_blank>mailbox." , deleted ) , deleted ) ; } bool hcached = false ; for ( i = old_count ; i < new_count ; i ++ ) { if ( ! ctx -> quiet ) mutt_progress_update ( & progress , i + 1 - old_count , - 1 ) ; # ifdef USE_HCACHE void * data = mutt_hcache_fetch ( hc , ctx -> hdrs [ i ] -> data , strlen ( ctx -> hdrs [ i ] -> data ) ) ; if ( data ) { char * uidl = mutt_str_strdup ( ctx -> hdrs [ i ] -> data ) ; int refno = ctx -> hdrs [ i ] -> refno ; int index = ctx -> hdrs [ i ] -> index ; struct Header * h = mutt_hcache_restore ( ( unsigned char * ) data ) ; mutt_hcache_free ( hc , & data ) ; mutt_header_free ( & ctx -> hdrs [ i ] ) ; ctx -> hdrs [ i ] = h ; ctx -> hdrs [ i ] -> refno = refno ; ctx -> hdrs [ i ] -> index = index ; ctx -> hdrs [ i ] -> data = uidl ; ret = 0 ; hcached = true ; } else # endif if ( ( ret = pop_read_header ( pop_data , ctx -> hdrs [ i ] ) ) < 0 ) break ; # ifdef USE_HCACHE else { mutt_hcache_store ( hc , ctx -> hdrs [ i ] -> data , strlen ( ctx -> hdrs [ i ] -> data ) , ctx -> hdrs [ i ] , 0 ) ; } # endif const bool bcached = <S2SV_StartBug> ( mutt_bcache_exists ( pop_data -> bcache , ctx -> hdrs [ i ] -> data ) == 0 ) ; <S2SV_EndBug> ctx -> hdrs [ i ] -> old = false ; ctx -> hdrs [ i ] -> read = false ; if ( hcached ) { if ( bcached ) ctx -> hdrs [ i ] -> read = true ; else if ( MarkOld ) ctx -> hdrs [ i ] -> old = true ; } else { if ( bcached ) ctx -> hdrs [ i ] -> read = true ; } ctx -> msgcount ++ ; } if ( i > old_count ) mx_update_context ( ctx , i - old_count ) ; } # ifdef USE_HCACHE mutt_hcache_close ( hc ) ; # endif if ( ret < 0 ) { for ( int i = ctx -> msgcount ; i < new_count ; i ++ ) mutt_header_free ( & ctx -> hdrs [ i ] ) ; return ret ; } if ( MessageCacheClean ) mutt_bcache_list ( pop_data -> bcache , msg_cache_check , ( void * ) ctx ) ; mutt_clear_error ( ) ; return ( new_count - old_count ) ; }
CWE-22 static int pop_fetch_message ( struct Context * ctx , struct Message * msg , int msgno ) { void * uidl = NULL ; char buf [ LONG_STRING ] ; char path [ PATH_MAX ] ; struct Progress progressbar ; struct PopData * pop_data = ( struct PopData * ) ctx -> data ; struct PopCache * cache = NULL ; struct Header * h = ctx -> hdrs [ msgno ] ; unsigned short bcache = 1 ; <S2SV_StartBug> msg -> fp = mutt_bcache_get ( pop_data -> bcache , h -> data ) ; <S2SV_EndBug> if ( msg -> fp ) return 0 ; cache = & pop_data -> cache [ h -> index % POP_CACHE_LEN ] ; if ( cache -> path ) { if ( cache -> index == h -> index ) { msg -> fp = fopen ( cache -> path , "r" ) ; if ( msg -> fp ) return 0 ; mutt_perror ( cache -> path ) ; return - 1 ; } else { unlink ( cache -> path ) ; FREE ( & cache -> path ) ; } } while ( true ) { if ( pop_reconnect ( ctx ) < 0 ) return - 1 ; if ( h -> refno < 0 ) { mutt_error ( _ ( "The<S2SV_blank>message<S2SV_blank>index<S2SV_blank>is<S2SV_blank>incorrect.<S2SV_blank>Try<S2SV_blank>reopening<S2SV_blank>the<S2SV_blank>mailbox." ) ) ; return - 1 ; } mutt_progress_init ( & progressbar , _ ( "Fetching<S2SV_blank>message..." ) , MUTT_PROGRESS_SIZE , NetInc , h -> content -> length + h -> content -> offset - 1 ) ; <S2SV_StartBug> msg -> fp = mutt_bcache_put ( pop_data -> bcache , h -> data ) ; <S2SV_EndBug> if ( ! msg -> fp ) { bcache = 0 ; mutt_mktemp ( path , sizeof ( path ) ) ; msg -> fp = mutt_file_fopen ( path , "w+" ) ; if ( ! msg -> fp ) { mutt_perror ( path ) ; return - 1 ; } } snprintf ( buf , sizeof ( buf ) , "RETR<S2SV_blank>%d\\r\\n" , h -> refno ) ; const int ret = pop_fetch_data ( pop_data , buf , & progressbar , fetch_message , msg -> fp ) ; if ( ret == 0 ) break ; mutt_file_fclose ( & msg -> fp ) ; if ( ! bcache ) unlink ( path ) ; if ( ret == - 2 ) { mutt_error ( "%s" , pop_data -> err_msg ) ; return - 1 ; } if ( ret == - 3 ) { mutt_error ( _ ( "Can\'t<S2SV_blank>write<S2SV_blank>message<S2SV_blank>to<S2SV_blank>temporary<S2SV_blank>file!" ) ) ; return - 1 ; } } if ( bcache ) <S2SV_StartBug> mutt_bcache_commit ( pop_data -> bcache , h -> data ) ; <S2SV_EndBug> else { cache -> index = h -> index ; cache -> path = mutt_str_strdup ( path ) ; } rewind ( msg -> fp ) ; uidl = h -> data ; if ( ctx -> subj_hash && h -> env -> real_subj ) mutt_hash_delete ( ctx -> subj_hash , h -> env -> real_subj , h ) ; mutt_label_hash_remove ( ctx , h ) ; mutt_env_free ( & h -> env ) ; h -> env = mutt_rfc822_read_header ( msg -> fp , h , 0 , 0 ) ; if ( ctx -> subj_hash && h -> env -> real_subj ) mutt_hash_insert ( ctx -> subj_hash , h -> env -> real_subj , h ) ; mutt_label_hash_add ( ctx , h ) ; h -> data = uidl ; h -> lines = 0 ; fgets ( buf , sizeof ( buf ) , msg -> fp ) ; while ( ! feof ( msg -> fp ) ) { ctx -> hdrs [ msgno ] -> lines ++ ; fgets ( buf , sizeof ( buf ) , msg -> fp ) ; } h -> content -> length = ftello ( msg -> fp ) - h -> content -> offset ; if ( ! WithCrypto ) h -> security = crypt_query ( h -> content ) ; mutt_clear_error ( ) ; rewind ( msg -> fp ) ; return 0 ; }
CWE-22 static int pop_sync_mailbox ( struct Context * ctx , int * index_hint ) { int i , j , ret = 0 ; char buf [ LONG_STRING ] ; struct PopData * pop_data = ( struct PopData * ) ctx -> data ; struct Progress progress ; # ifdef USE_HCACHE header_cache_t * hc = NULL ; # endif pop_data -> check_time = 0 ; while ( true ) { if ( pop_reconnect ( ctx ) < 0 ) return - 1 ; mutt_progress_init ( & progress , _ ( "Marking<S2SV_blank>messages<S2SV_blank>deleted..." ) , MUTT_PROGRESS_MSG , WriteInc , ctx -> deleted ) ; # ifdef USE_HCACHE hc = pop_hcache_open ( pop_data , ctx -> path ) ; # endif for ( i = 0 , j = 0 , ret = 0 ; ret == 0 && i < ctx -> msgcount ; i ++ ) { if ( ctx -> hdrs [ i ] -> deleted && ctx -> hdrs [ i ] -> refno != - 1 ) { j ++ ; if ( ! ctx -> quiet ) mutt_progress_update ( & progress , j , - 1 ) ; snprintf ( buf , sizeof ( buf ) , "DELE<S2SV_blank>%d\\r\\n" , ctx -> hdrs [ i ] -> refno ) ; ret = pop_query ( pop_data , buf , sizeof ( buf ) ) ; if ( ret == 0 ) { <S2SV_StartBug> mutt_bcache_del ( pop_data -> bcache , ctx -> hdrs [ i ] -> data ) ; <S2SV_EndBug> # ifdef USE_HCACHE mutt_hcache_delete ( hc , ctx -> hdrs [ i ] -> data , strlen ( ctx -> hdrs [ i ] -> data ) ) ; # endif } } # ifdef USE_HCACHE if ( ctx -> hdrs [ i ] -> changed ) { mutt_hcache_store ( hc , ctx -> hdrs [ i ] -> data , strlen ( ctx -> hdrs [ i ] -> data ) , ctx -> hdrs [ i ] , 0 ) ; } # endif } # ifdef USE_HCACHE mutt_hcache_close ( hc ) ; # endif if ( ret == 0 ) { mutt_str_strfcpy ( buf , "QUIT\\r\\n" , sizeof ( buf ) ) ; ret = pop_query ( pop_data , buf , sizeof ( buf ) ) ; } if ( ret == 0 ) { pop_data -> clear_cache = true ; pop_clear_cache ( pop_data ) ; pop_data -> status = POP_DISCONNECTED ; return 0 ; } if ( ret == - 2 ) { mutt_error ( "%s" , pop_data -> err_msg ) ; return - 1 ; } } }
CWE-20 static int nntp_fetch_headers ( struct Context * ctx , void * hc , anum_t first , anum_t last , int restore ) { struct NntpData * nntp_data = ctx -> data ; struct FetchCtx fc ; struct Header * hdr = NULL ; char buf [ HUGE_STRING ] ; int rc = 0 ; int oldmsgcount = ctx -> msgcount ; anum_t current ; anum_t first_over = first ; # ifdef USE_HCACHE void * hdata = NULL ; # endif if ( ! last || first > last ) return 0 ; fc . ctx = ctx ; fc . first = first ; fc . last = last ; fc . restore = restore ; <S2SV_StartBug> fc . messages = mutt_mem_calloc ( last - first + 1 , sizeof ( unsigned char ) ) ; <S2SV_EndBug> # ifdef USE_HCACHE fc . hc = hc ; # endif if ( NntpListgroup && nntp_data -> nserv -> hasLISTGROUP && ! nntp_data -> deleted ) { if ( ! ctx -> quiet ) mutt_message ( _ ( "Fetching<S2SV_blank>list<S2SV_blank>of<S2SV_blank>articles..." ) ) ; if ( nntp_data -> nserv -> hasLISTGROUPrange ) snprintf ( buf , sizeof ( buf ) , "LISTGROUP<S2SV_blank>%s<S2SV_blank>%u-%u\\r\\n" , nntp_data -> group , first , last ) ; else snprintf ( buf , sizeof ( buf ) , "LISTGROUP<S2SV_blank>%s\\r\\n" , nntp_data -> group ) ; rc = nntp_fetch_lines ( nntp_data , buf , sizeof ( buf ) , NULL , fetch_numbers , & fc ) ; if ( rc > 0 ) { mutt_error ( "LISTGROUP:<S2SV_blank>%s" , buf ) ; } if ( rc == 0 ) { for ( current = first ; current <= last && rc == 0 ; current ++ ) { if ( fc . messages [ current - first ] ) continue ; snprintf ( buf , sizeof ( buf ) , "%u" , current ) ; if ( nntp_data -> bcache ) { mutt_debug ( 2 , "#1<S2SV_blank>mutt_bcache_del<S2SV_blank>%s\\n" , buf ) ; mutt_bcache_del ( nntp_data -> bcache , buf ) ; } # ifdef USE_HCACHE if ( fc . hc ) { mutt_debug ( 2 , "mutt_hcache_delete<S2SV_blank>%s\\n" , buf ) ; mutt_hcache_delete ( fc . hc , buf , strlen ( buf ) ) ; } # endif } } } else { for ( current = first ; current <= last ; current ++ ) fc . messages [ current - first ] = 1 ; } if ( ! ctx -> quiet ) { mutt_progress_init ( & fc . progress , _ ( "Fetching<S2SV_blank>message<S2SV_blank>headers..." ) , MUTT_PROGRESS_MSG , ReadInc , last - first + 1 ) ; } for ( current = first ; current <= last && rc == 0 ; current ++ ) { if ( ! ctx -> quiet ) mutt_progress_update ( & fc . progress , current - first + 1 , - 1 ) ; # ifdef USE_HCACHE snprintf ( buf , sizeof ( buf ) , "%u" , current ) ; # endif if ( ! fc . messages [ current - first ] ) continue ; if ( ctx -> msgcount >= ctx -> hdrmax ) mx_alloc_memory ( ctx ) ; # ifdef USE_HCACHE hdata = mutt_hcache_fetch ( fc . hc , buf , strlen ( buf ) ) ; if ( hdata ) { mutt_debug ( 2 , "mutt_hcache_fetch<S2SV_blank>%s\\n" , buf ) ; ctx -> hdrs [ ctx -> msgcount ] = hdr = mutt_hcache_restore ( hdata ) ; mutt_hcache_free ( fc . hc , & hdata ) ; hdr -> data = 0 ; if ( hdr -> deleted && ! restore ) { mutt_header_free ( & hdr ) ; if ( nntp_data -> bcache ) { mutt_debug ( 2 , "#2<S2SV_blank>mutt_bcache_del<S2SV_blank>%s\\n" , buf ) ; mutt_bcache_del ( nntp_data -> bcache , buf ) ; } continue ; } hdr -> read = false ; hdr -> old = false ; } else # endif if ( nntp_data -> deleted ) continue ; else if ( nntp_data -> nserv -> hasOVER || nntp_data -> nserv -> hasXOVER ) { if ( NntpListgroup && nntp_data -> nserv -> hasLISTGROUP ) break ; else continue ; } else { FILE * fp = mutt_file_mkstemp ( ) ; if ( ! fp ) { mutt_perror ( "mutt_file_mkstemp()<S2SV_blank>failed!" ) ; rc = - 1 ; break ; } snprintf ( buf , sizeof ( buf ) , "HEAD<S2SV_blank>%u\\r\\n" , current ) ; rc = nntp_fetch_lines ( nntp_data , buf , sizeof ( buf ) , NULL , fetch_tempfile , fp ) ; if ( rc ) { mutt_file_fclose ( & fp ) ; if ( rc < 0 ) break ; if ( mutt_str_strncmp ( "423" , buf , 3 ) != 0 ) { mutt_error ( "HEAD:<S2SV_blank>%s" , buf ) ; break ; } if ( nntp_data -> bcache ) { snprintf ( buf , sizeof ( buf ) , "%u" , current ) ; mutt_debug ( 2 , "#3<S2SV_blank>mutt_bcache_del<S2SV_blank>%s\\n" , buf ) ; mutt_bcache_del ( nntp_data -> bcache , buf ) ; } rc = 0 ; continue ; } hdr = ctx -> hdrs [ ctx -> msgcount ] = mutt_header_new ( ) ; hdr -> env = mutt_rfc822_read_header ( fp , hdr , 0 , 0 ) ; hdr -> received = hdr -> date_sent ; mutt_file_fclose ( & fp ) ; } hdr -> index = ctx -> msgcount ++ ; hdr -> read = false ; hdr -> old = false ; hdr -> deleted = false ; hdr -> data = mutt_mem_calloc ( 1 , sizeof ( struct NntpHeaderData ) ) ; NHDR ( hdr ) -> article_num = current ; if ( restore ) hdr -> changed = true ; else { nntp_article_status ( ctx , hdr , NULL , NHDR ( hdr ) -> article_num ) ; if ( ! hdr -> read ) nntp_parse_xref ( ctx , hdr ) ; } if ( current > nntp_data -> last_loaded ) nntp_data -> last_loaded = current ; first_over = current + 1 ; } if ( ! NntpListgroup || ! nntp_data -> nserv -> hasLISTGROUP ) current = first_over ; if ( current <= last && rc == 0 && ! nntp_data -> deleted ) { char * cmd = nntp_data -> nserv -> hasOVER ? "OVER" : "XOVER" ; snprintf ( buf , sizeof ( buf ) , "%s<S2SV_blank>%u-%u\\r\\n" , cmd , current , last ) ; rc = nntp_fetch_lines ( nntp_data , buf , sizeof ( buf ) , NULL , parse_overview_line , & fc ) ; if ( rc > 0 ) { mutt_error ( "%s:<S2SV_blank>%s" , cmd , buf ) ; } } if ( ctx -> msgcount > oldmsgcount ) mx_update_context ( ctx , ctx -> msgcount - oldmsgcount ) ; FREE ( & fc . messages ) ; if ( rc != 0 ) return - 1 ; mutt_clear_error ( ) ; return 0 ; }
CWE-119 void imap_quote_string ( char * dest , size_t dlen , const char * src , bool quote_backtick ) { const char * quote = "`\\"\\\\" ; if ( ! quote_backtick ) quote ++ ; char * pt = dest ; const char * s = src ; * pt ++ = \'"\' ; <S2SV_StartBug> dlen -= 2 ; <S2SV_EndBug> for ( ; * s && dlen ; s ++ ) { if ( strchr ( quote , * s ) ) { if ( dlen < 2 ) break ; dlen -= 2 ; * pt ++ = '\\\\' ; * pt ++ = * s ; } else { * pt ++ = * s ; dlen -- ; } } * pt ++ = \'"\' ; * pt = '\\0' ; }
CWE-77 enum ImapAuthRes imap_auth_login ( struct ImapData * idata , const char * method ) { char q_user [ SHORT_STRING ] , q_pass [ SHORT_STRING ] ; char buf [ STRING ] ; int rc ; if ( mutt_bit_isset ( idata -> capabilities , LOGINDISABLED ) ) { mutt_message ( _ ( "LOGIN<S2SV_blank>disabled<S2SV_blank>on<S2SV_blank>this<S2SV_blank>server." ) ) ; return IMAP_AUTH_UNAVAIL ; } if ( mutt_account_getuser ( & idata -> conn -> account ) < 0 ) return IMAP_AUTH_FAILURE ; if ( mutt_account_getpass ( & idata -> conn -> account ) < 0 ) return IMAP_AUTH_FAILURE ; mutt_message ( _ ( "Logging<S2SV_blank>in..." ) ) ; <S2SV_StartBug> imap_quote_string ( q_user , sizeof ( q_user ) , idata -> conn -> account . user ) ; <S2SV_EndBug> <S2SV_StartBug> imap_quote_string ( q_pass , sizeof ( q_pass ) , idata -> conn -> account . pass ) ; <S2SV_EndBug> if ( DebugLevel < IMAP_LOG_PASS ) mutt_debug ( 2 , "Sending<S2SV_blank>LOGIN<S2SV_blank>command<S2SV_blank>for<S2SV_blank>%s...\\n" , idata -> conn -> account . user ) ; snprintf ( buf , sizeof ( buf ) , "LOGIN<S2SV_blank>%s<S2SV_blank>%s" , q_user , q_pass ) ; rc = imap_exec ( idata , buf , IMAP_CMD_FAIL_OK | IMAP_CMD_PASS ) ; if ( ! rc ) { mutt_clear_error ( ) ; return IMAP_AUTH_SUCCESS ; } mutt_error ( _ ( "Login<S2SV_blank>failed." ) ) ; return IMAP_AUTH_FAILURE ; }
CWE-77 static void cmd_parse_lsub ( struct ImapData * idata , char * s ) { char buf [ STRING ] ; char errstr [ STRING ] ; struct Buffer err , token ; struct Url url ; struct ImapList list ; if ( idata -> cmddata && idata -> cmdtype == IMAP_CT_LIST ) { cmd_parse_list ( idata , s ) ; return ; } if ( ! ImapCheckSubscribed ) return ; idata -> cmdtype = IMAP_CT_LIST ; idata -> cmddata = & list ; cmd_parse_list ( idata , s ) ; idata -> cmddata = NULL ; if ( ! list . name || list . noselect ) return ; mutt_debug ( 3 , "Subscribing<S2SV_blank>to<S2SV_blank>%s\\n" , list . name ) ; mutt_str_strfcpy ( buf , "mailboxes<S2SV_blank>\\"" , sizeof ( buf ) ) ; mutt_account_tourl ( & idata -> conn -> account , & url ) ; <S2SV_StartBug> imap_quote_string ( errstr , sizeof ( errstr ) , list . name ) ; <S2SV_EndBug> url . path = errstr + 1 ; url . path [ strlen ( url . path ) - 1 ] = '\\0' ; if ( mutt_str_strcmp ( url . user , ImapUser ) == 0 ) url . user = NULL ; url_tostring ( & url , buf + 11 , sizeof ( buf ) - 11 , 0 ) ; mutt_str_strcat ( buf , sizeof ( buf ) , "\\"" ) ; mutt_buffer_init ( & token ) ; mutt_buffer_init ( & err ) ; err . data = errstr ; err . dsize = sizeof ( errstr ) ; if ( mutt_parse_rc_line ( buf , & token , & err ) ) mutt_debug ( 1 , "Error<S2SV_blank>adding<S2SV_blank>subscribed<S2SV_blank>mailbox:<S2SV_blank>%s\\n" , errstr ) ; FREE ( & token . data ) ; }
CWE-77 static int compile_search ( struct Context * ctx , const struct Pattern * pat , struct Buffer * buf ) { if ( do_search ( pat , 0 ) == 0 ) return 0 ; if ( pat -> not ) mutt_buffer_addstr ( buf , "NOT<S2SV_blank>" ) ; if ( pat -> child ) { int clauses ; clauses = do_search ( pat -> child , 1 ) ; if ( clauses > 0 ) { const struct Pattern * clause = pat -> child ; mutt_buffer_addch ( buf , '(' ) ; while ( clauses ) { if ( do_search ( clause , 0 ) ) { if ( pat -> op == MUTT_OR && clauses > 1 ) mutt_buffer_addstr ( buf , "OR<S2SV_blank>" ) ; clauses -- ; if ( compile_search ( ctx , clause , buf ) < 0 ) return - 1 ; if ( clauses ) mutt_buffer_addch ( buf , '<S2SV_blank>' ) ; } clause = clause -> next ; } mutt_buffer_addch ( buf , ')' ) ; } } else { char term [ STRING ] ; char * delim = NULL ; switch ( pat -> op ) { case MUTT_HEADER : mutt_buffer_addstr ( buf , "HEADER<S2SV_blank>" ) ; delim = strchr ( pat -> p . str , ':' ) ; if ( ! delim ) { mutt_error ( _ ( "Header<S2SV_blank>search<S2SV_blank>without<S2SV_blank>header<S2SV_blank>name:<S2SV_blank>%s" ) , pat -> p . str ) ; return - 1 ; } * delim = '\\0' ; <S2SV_StartBug> imap_quote_string ( term , sizeof ( term ) , pat -> p . str ) ; <S2SV_EndBug> mutt_buffer_addstr ( buf , term ) ; mutt_buffer_addch ( buf , '<S2SV_blank>' ) ; * delim = ':' ; delim ++ ; SKIPWS ( delim ) ; <S2SV_StartBug> imap_quote_string ( term , sizeof ( term ) , delim ) ; <S2SV_EndBug> mutt_buffer_addstr ( buf , term ) ; break ; case MUTT_BODY : mutt_buffer_addstr ( buf , "BODY<S2SV_blank>" ) ; <S2SV_StartBug> imap_quote_string ( term , sizeof ( term ) , pat -> p . str ) ; <S2SV_EndBug> mutt_buffer_addstr ( buf , term ) ; break ; case MUTT_WHOLE_MSG : mutt_buffer_addstr ( buf , "TEXT<S2SV_blank>" ) ; <S2SV_StartBug> imap_quote_string ( term , sizeof ( term ) , pat -> p . str ) ; <S2SV_EndBug> mutt_buffer_addstr ( buf , term ) ; break ; case MUTT_SERVERSEARCH : { struct ImapData * idata = ctx -> data ; if ( ! mutt_bit_isset ( idata -> capabilities , X_GM_EXT1 ) ) { mutt_error ( _ ( "Server-side<S2SV_blank>custom<S2SV_blank>search<S2SV_blank>not<S2SV_blank>supported:<S2SV_blank>%s" ) , pat -> p . str ) ; return - 1 ; } } mutt_buffer_addstr ( buf , "X-GM-RAW<S2SV_blank>" ) ; <S2SV_StartBug> imap_quote_string ( term , sizeof ( term ) , pat -> p . str ) ; <S2SV_EndBug> mutt_buffer_addstr ( buf , term ) ; break ; } } return 0 ; }
CWE-77 void imap_munge_mbox_name ( struct ImapData * idata , char * dest , size_t dlen , const char * src ) { char * buf = mutt_str_strdup ( src ) ; imap_utf_encode ( idata , & buf ) ; <S2SV_StartBug> imap_quote_string ( dest , dlen , buf ) ; <S2SV_EndBug> FREE ( & buf ) ; }
CWE-77 <S2SV_StartBug> void imap_quote_string ( char * dest , size_t dlen , const char * src ) <S2SV_EndBug> { static const char quote [ ] = "\\"\\\\" ; char * pt = dest ; const char * s = src ; * pt ++ = \'"\' ; dlen -= 2 ; for ( ; * s && dlen ; s ++ ) { if ( strchr ( quote , * s ) ) { dlen -= 2 ; if ( dlen == 0 ) break ; * pt ++ = '\\\\' ; * pt ++ = * s ; } else { * pt ++ = * s ; dlen -- ; } } * pt ++ = \'"\' ; * pt = '\\0' ; }
CWE-284 void fslib_copy_libs ( const char * full_path ) { assert ( full_path ) ; if ( arg_debug || arg_debug_private_lib ) printf ( "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>fslib_copy_libs<S2SV_blank>%s\\n" , full_path ) ; if ( access ( full_path , R_OK ) ) { if ( arg_debug || arg_debug_private_lib ) printf ( "cannot<S2SV_blank>find<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>private-lib,<S2SV_blank>skipping...\\n" , full_path ) ; return ; } unlink ( RUN_LIB_FILE ) ; create_empty_file_as_root ( RUN_LIB_FILE , 0644 ) ; if ( chown ( RUN_LIB_FILE , getuid ( ) , getgid ( ) ) ) errExit ( "chown" ) ; if ( arg_debug || arg_debug_private_lib ) printf ( "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>running<S2SV_blank>fldd<S2SV_blank>%s\\n" , full_path ) ; sbox_run ( SBOX_USER | SBOX_SECCOMP | SBOX_CAPS_NONE , 3 , PATH_FLDD , full_path , RUN_LIB_FILE ) ; FILE * fp = fopen ( RUN_LIB_FILE , "r" ) ; if ( ! fp ) errExit ( "fopen" ) ; char buf [ MAXBUF ] ; while ( fgets ( buf , MAXBUF , fp ) ) { char * ptr = strchr ( buf , '\\n' ) ; if ( ptr ) * ptr = '\\0' ; fslib_duplicate ( buf ) ; } fclose ( fp ) ; <S2SV_StartBug> } <S2SV_EndBug>
CWE-284 void preproc_mount_mnt_dir ( void ) { if ( ! tmpfs_mounted ) { if ( arg_debug ) printf ( "Mounting<S2SV_blank>tmpfs<S2SV_blank>on<S2SV_blank>%s<S2SV_blank>directory\\n" , RUN_MNT_DIR ) ; if ( mount ( "tmpfs" , RUN_MNT_DIR , "tmpfs" , MS_NOSUID | MS_STRICTATIME , "mode=755,gid=0" ) < 0 ) errExit ( "mounting<S2SV_blank>/run/firejail/mnt" ) ; tmpfs_mounted = 1 ; fs_logger2 ( "tmpfs" , RUN_MNT_DIR ) ; # ifdef HAVE_SECCOMP <S2SV_StartBug> if ( arg_seccomp_block_secondary ) <S2SV_EndBug> copy_file ( PATH_SECCOMP_BLOCK_SECONDARY , RUN_SECCOMP_BLOCK_SECONDARY , getuid ( ) , getgid ( ) , 0644 ) ; else { copy_file ( PATH_SECCOMP_32 , RUN_SECCOMP_32 , getuid ( ) , getgid ( ) , 0644 ) ; } if ( arg_allow_debuggers ) copy_file ( PATH_SECCOMP_DEFAULT_DEBUG , RUN_SECCOMP_CFG , getuid ( ) , getgid ( ) , 0644 ) ; else copy_file ( PATH_SECCOMP_DEFAULT , RUN_SECCOMP_CFG , getuid ( ) , getgid ( ) , 0644 ) ; if ( arg_memory_deny_write_execute ) copy_file ( PATH_SECCOMP_MDWX , RUN_SECCOMP_MDWX , getuid ( ) , getgid ( ) , 0644 ) ; create_empty_file_as_root ( RUN_SECCOMP_PROTOCOL , 0644 ) ; if ( set_perms ( RUN_SECCOMP_PROTOCOL , getuid ( ) , getgid ( ) , 0644 ) ) errExit ( "set_perms" ) ; create_empty_file_as_root ( RUN_SECCOMP_POSTEXEC , 0644 ) ; if ( set_perms ( RUN_SECCOMP_POSTEXEC , getuid ( ) , getgid ( ) , 0644 ) ) errExit ( "set_perms" ) ; # endif } }
CWE-284 int sandbox ( void * sandbox_arg ) { ( void ) sandbox_arg ; pid_t child_pid = getpid ( ) ; if ( arg_debug ) printf ( "Initializing<S2SV_blank>child<S2SV_blank>process\\n" ) ; close ( parent_to_child_fds [ 1 ] ) ; close ( child_to_parent_fds [ 0 ] ) ; wait_for_other ( parent_to_child_fds [ 0 ] ) ; if ( arg_debug && child_pid == 1 ) printf ( "PID<S2SV_blank>namespace<S2SV_blank>installed\\n" ) ; if ( cfg . hostname ) { if ( sethostname ( cfg . hostname , strlen ( cfg . hostname ) ) < 0 ) errExit ( "sethostname" ) ; } if ( mount ( NULL , "/" , NULL , MS_SLAVE | MS_REC , NULL ) < 0 ) { chk_chroot ( ) ; } preproc_mount_mnt_dir ( ) ; if ( mount ( LIBDIR "/firejail" , RUN_FIREJAIL_LIB_DIR , "none" , MS_BIND , NULL ) < 0 ) errExit ( "mounting<S2SV_blank>" RUN_FIREJAIL_LIB_DIR ) ; if ( cfg . name ) fs_logger2 ( "sandbox<S2SV_blank>name:" , cfg . name ) ; fs_logger2int ( "sandbox<S2SV_blank>pid:" , ( int ) sandbox_pid ) ; if ( cfg . chrootdir ) fs_logger ( "sandbox<S2SV_blank>filesystem:<S2SV_blank>chroot" ) ; else if ( arg_overlay ) fs_logger ( "sandbox<S2SV_blank>filesystem:<S2SV_blank>overlay" ) ; else fs_logger ( "sandbox<S2SV_blank>filesystem:<S2SV_blank>local" ) ; fs_logger ( "install<S2SV_blank>mount<S2SV_blank>namespace" ) ; if ( arg_netfilter && any_bridge_configured ( ) ) { netfilter ( arg_netfilter_file ) ; } if ( arg_netfilter6 && any_bridge_configured ( ) ) { netfilter6 ( arg_netfilter6_file ) ; } int gw_cfg_failed = 0 ; if ( arg_nonetwork ) { net_if_up ( "lo" ) ; if ( arg_debug ) printf ( "Network<S2SV_blank>namespace<S2SV_blank>enabled,<S2SV_blank>only<S2SV_blank>loopback<S2SV_blank>interface<S2SV_blank>available\\n" ) ; } else if ( arg_netns ) { netns ( arg_netns ) ; if ( arg_debug ) printf ( "Network<S2SV_blank>namespace<S2SV_blank>\'%s\'<S2SV_blank>activated\\n" , arg_netns ) ; } else if ( any_bridge_configured ( ) || any_interface_configured ( ) ) { net_if_up ( "lo" ) ; if ( mac_not_zero ( cfg . bridge0 . macsandbox ) ) net_config_mac ( cfg . bridge0 . devsandbox , cfg . bridge0 . macsandbox ) ; sandbox_if_up ( & cfg . bridge0 ) ; if ( mac_not_zero ( cfg . bridge1 . macsandbox ) ) net_config_mac ( cfg . bridge1 . devsandbox , cfg . bridge1 . macsandbox ) ; sandbox_if_up ( & cfg . bridge1 ) ; if ( mac_not_zero ( cfg . bridge2 . macsandbox ) ) net_config_mac ( cfg . bridge2 . devsandbox , cfg . bridge2 . macsandbox ) ; sandbox_if_up ( & cfg . bridge2 ) ; if ( mac_not_zero ( cfg . bridge3 . macsandbox ) ) net_config_mac ( cfg . bridge3 . devsandbox , cfg . bridge3 . macsandbox ) ; sandbox_if_up ( & cfg . bridge3 ) ; if ( cfg . interface0 . configured && cfg . interface0 . ip ) { if ( arg_debug ) printf ( "Configuring<S2SV_blank>%d.%d.%d.%d<S2SV_blank>address<S2SV_blank>on<S2SV_blank>interface<S2SV_blank>%s\\n" , PRINT_IP ( cfg . interface0 . ip ) , cfg . interface0 . dev ) ; net_config_interface ( cfg . interface0 . dev , cfg . interface0 . ip , cfg . interface0 . mask , cfg . interface0 . mtu ) ; } if ( cfg . interface1 . configured && cfg . interface1 . ip ) { if ( arg_debug ) printf ( "Configuring<S2SV_blank>%d.%d.%d.%d<S2SV_blank>address<S2SV_blank>on<S2SV_blank>interface<S2SV_blank>%s\\n" , PRINT_IP ( cfg . interface1 . ip ) , cfg . interface1 . dev ) ; net_config_interface ( cfg . interface1 . dev , cfg . interface1 . ip , cfg . interface1 . mask , cfg . interface1 . mtu ) ; } if ( cfg . interface2 . configured && cfg . interface2 . ip ) { if ( arg_debug ) printf ( "Configuring<S2SV_blank>%d.%d.%d.%d<S2SV_blank>address<S2SV_blank>on<S2SV_blank>interface<S2SV_blank>%s\\n" , PRINT_IP ( cfg . interface2 . ip ) , cfg . interface2 . dev ) ; net_config_interface ( cfg . interface2 . dev , cfg . interface2 . ip , cfg . interface2 . mask , cfg . interface2 . mtu ) ; } if ( cfg . interface3 . configured && cfg . interface3 . ip ) { if ( arg_debug ) printf ( "Configuring<S2SV_blank>%d.%d.%d.%d<S2SV_blank>address<S2SV_blank>on<S2SV_blank>interface<S2SV_blank>%s\\n" , PRINT_IP ( cfg . interface3 . ip ) , cfg . interface3 . dev ) ; net_config_interface ( cfg . interface3 . dev , cfg . interface3 . ip , cfg . interface3 . mask , cfg . interface3 . mtu ) ; } if ( cfg . defaultgw ) { if ( net_add_route ( 0 , 0 , cfg . defaultgw ) ) { fwarning ( "cannot<S2SV_blank>configure<S2SV_blank>default<S2SV_blank>route\\n" ) ; gw_cfg_failed = 1 ; } } if ( arg_debug ) printf ( "Network<S2SV_blank>namespace<S2SV_blank>enabled\\n" ) ; } if ( ! arg_quiet ) { if ( any_bridge_configured ( ) || any_interface_configured ( ) || cfg . defaultgw || cfg . dns1 ) { fmessage ( "\\n" ) ; if ( any_bridge_configured ( ) || any_interface_configured ( ) ) { if ( arg_scan ) sbox_run ( SBOX_ROOT | SBOX_CAPS_NETWORK | SBOX_SECCOMP , 3 , PATH_FNET , "printif" , "scan" ) ; else sbox_run ( SBOX_ROOT | SBOX_CAPS_NETWORK | SBOX_SECCOMP , 2 , PATH_FNET , "printif" ) ; } if ( cfg . defaultgw != 0 ) { if ( gw_cfg_failed ) fmessage ( "Default<S2SV_blank>gateway<S2SV_blank>configuration<S2SV_blank>failed\\n" ) ; else fmessage ( "Default<S2SV_blank>gateway<S2SV_blank>%d.%d.%d.%d\\n" , PRINT_IP ( cfg . defaultgw ) ) ; } if ( cfg . dns1 != NULL ) fmessage ( "DNS<S2SV_blank>server<S2SV_blank>%s\\n" , cfg . dns1 ) ; if ( cfg . dns2 != NULL ) fmessage ( "DNS<S2SV_blank>server<S2SV_blank>%s\\n" , cfg . dns2 ) ; if ( cfg . dns3 != NULL ) fmessage ( "DNS<S2SV_blank>server<S2SV_blank>%s\\n" , cfg . dns3 ) ; if ( cfg . dns4 != NULL ) fmessage ( "DNS<S2SV_blank>server<S2SV_blank>%s\\n" , cfg . dns4 ) ; fmessage ( "\\n" ) ; } } if ( arg_nonetwork || any_bridge_configured ( ) || any_interface_configured ( ) ) { } else { EUID_USER ( ) ; env_ibus_load ( ) ; EUID_ROOT ( ) ; } # ifdef HAVE_SECCOMP if ( cfg . protocol ) { if ( arg_debug ) printf ( "Build<S2SV_blank>protocol<S2SV_blank>filter:<S2SV_blank>%s\\n" , cfg . protocol ) ; int rv = sbox_run ( SBOX_USER | SBOX_CAPS_NONE | SBOX_SECCOMP , 5 , PATH_FSECCOMP , "protocol" , "build" , cfg . protocol , RUN_SECCOMP_PROTOCOL ) ; if ( rv ) exit ( rv ) ; } if ( arg_seccomp && ( cfg . seccomp_list || cfg . seccomp_list_drop || cfg . seccomp_list_keep ) ) arg_seccomp_postexec = 1 ; # endif bool need_preload = arg_trace || arg_tracelog || arg_seccomp_postexec ; if ( getuid ( ) != 0 && ( arg_appimage || cfg . chrootdir || arg_overlay ) ) { enforce_filters ( ) ; need_preload = arg_trace || arg_tracelog ; } if ( need_preload ) fs_trace_preload ( ) ; if ( cfg . hosts_file ) fs_store_hosts_file ( ) ; # ifdef HAVE_CHROOT if ( cfg . chrootdir ) { fs_chroot ( cfg . chrootdir ) ; if ( need_preload ) fs_trace_preload ( ) ; } else # endif # ifdef HAVE_OVERLAYFS if ( arg_overlay ) fs_overlayfs ( ) ; else # endif fs_basic_fs ( ) ; if ( arg_private ) { if ( cfg . home_private ) { if ( cfg . chrootdir ) fwarning ( "private=directory<S2SV_blank>feature<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>chroot\\n" ) ; else if ( arg_overlay ) fwarning ( "private=directory<S2SV_blank>feature<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>overlay\\n" ) ; else fs_private_homedir ( ) ; } else if ( cfg . home_private_keep ) { if ( cfg . chrootdir ) fwarning ( "private-home=<S2SV_blank>feature<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>chroot\\n" ) ; else if ( arg_overlay ) fwarning ( "private-home=<S2SV_blank>feature<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>overlay\\n" ) ; else fs_private_home_list ( ) ; } else fs_private ( ) ; } if ( arg_private_dev ) fs_private_dev ( ) ; if ( arg_private_etc ) { if ( cfg . chrootdir ) fwarning ( "private-etc<S2SV_blank>feature<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>chroot\\n" ) ; else if ( arg_overlay ) fwarning ( "private-etc<S2SV_blank>feature<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>overlay\\n" ) ; else { fs_private_dir_list ( "/etc" , RUN_ETC_DIR , cfg . etc_private_keep ) ; if ( need_preload ) fs_trace_preload ( ) ; } } if ( arg_private_opt ) { if ( cfg . chrootdir ) fwarning ( "private-opt<S2SV_blank>feature<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>chroot\\n" ) ; else if ( arg_overlay ) fwarning ( "private-opt<S2SV_blank>feature<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>overlay\\n" ) ; else { fs_private_dir_list ( "/opt" , RUN_OPT_DIR , cfg . opt_private_keep ) ; } } if ( arg_private_srv ) { if ( cfg . chrootdir ) fwarning ( "private-srv<S2SV_blank>feature<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>chroot\\n" ) ; else if ( arg_overlay ) fwarning ( "private-srv<S2SV_blank>feature<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>overlay\\n" ) ; else { fs_private_dir_list ( "/srv" , RUN_SRV_DIR , cfg . srv_private_keep ) ; } } if ( arg_private_bin && ! arg_appimage ) { if ( cfg . chrootdir ) fwarning ( "private-bin<S2SV_blank>feature<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>chroot\\n" ) ; else if ( arg_overlay ) fwarning ( "private-bin<S2SV_blank>feature<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>overlay\\n" ) ; else { if ( arg_x11_xorg ) { EUID_USER ( ) ; char * tmp ; if ( asprintf ( & tmp , "%s,xauth" , cfg . bin_private_keep ) == - 1 ) errExit ( "asprintf" ) ; cfg . bin_private_keep = tmp ; EUID_ROOT ( ) ; } fs_private_bin_list ( ) ; } } if ( arg_private_lib && ! arg_appimage ) { if ( cfg . chrootdir ) fwarning ( "private-lib<S2SV_blank>feature<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>chroot\\n" ) ; else if ( arg_overlay ) fwarning ( "private-lib<S2SV_blank>feature<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>overlay\\n" ) ; else { fs_private_lib ( ) ; } } if ( arg_private_cache ) { if ( cfg . chrootdir ) fwarning ( "private-cache<S2SV_blank>feature<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>chroot\\n" ) ; else if ( arg_overlay ) fwarning ( "private-cache<S2SV_blank>feature<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>overlay\\n" ) ; else fs_private_cache ( ) ; } if ( arg_private_tmp ) { EUID_USER ( ) ; fs_private_tmp ( ) ; EUID_ROOT ( ) ; } if ( arg_nodbus ) dbus_session_disable ( ) ; if ( cfg . hostname ) fs_hostname ( cfg . hostname ) ; if ( cfg . hosts_file ) fs_mount_hosts_file ( ) ; if ( arg_netns ) netns_mounts ( arg_netns ) ; fs_proc_sys_dev_boot ( ) ; if ( checkcfg ( CFG_DISABLE_MNT ) ) fs_mnt ( 1 ) ; else if ( arg_disable_mnt ) fs_mnt ( 0 ) ; fs_whitelist ( ) ; fs_blacklist ( ) ; if ( arg_nosound ) { pulseaudio_disable ( ) ; fs_dev_disable_sound ( ) ; } else if ( ! arg_noautopulse ) pulseaudio_init ( ) ; if ( arg_no3d ) fs_dev_disable_3d ( ) ; if ( arg_notv ) fs_dev_disable_tv ( ) ; if ( arg_nodvd ) fs_dev_disable_dvd ( ) ; if ( arg_nou2f ) fs_dev_disable_u2f ( ) ; if ( arg_novideo ) fs_dev_disable_video ( ) ; if ( need_preload ) fs_trace ( ) ; fs_resolvconf ( ) ; fs_logger_print ( ) ; fs_logger_change_owner ( ) ; EUID_USER ( ) ; int cwd = 0 ; if ( cfg . cwd ) { if ( chdir ( cfg . cwd ) == 0 ) cwd = 1 ; } if ( ! cwd ) { if ( chdir ( "/" ) < 0 ) errExit ( "chdir" ) ; if ( cfg . homedir ) { struct stat s ; if ( stat ( cfg . homedir , & s ) == 0 ) { if ( chdir ( cfg . homedir ) < 0 ) errExit ( "chdir" ) ; } } } if ( arg_debug ) { char * cpath = get_current_dir_name ( ) ; if ( cpath ) { printf ( "Current<S2SV_blank>directory:<S2SV_blank>%s\\n" , cpath ) ; free ( cpath ) ; } } EUID_ROOT ( ) ; fs_x11 ( ) ; if ( arg_x11_xorg ) x11_xorg ( ) ; save_umask ( ) ; save_nonewprivs ( ) ; <S2SV_StartBug> set_caps ( ) ; <S2SV_EndBug> save_cpu ( ) ; save_cgroup ( ) ; # ifdef HAVE_SECCOMP # ifdef SYS_socket if ( cfg . protocol ) { if ( arg_debug ) printf ( "Install<S2SV_blank>protocol<S2SV_blank>filter:<S2SV_blank>%s\\n" , cfg . protocol ) ; seccomp_load ( RUN_SECCOMP_PROTOCOL ) ; protocol_filter_save ( ) ; } else { int rv = unlink ( RUN_SECCOMP_PROTOCOL ) ; ( void ) rv ; } # endif if ( arg_seccomp == 1 ) { if ( cfg . seccomp_list_keep ) seccomp_filter_keep ( ) ; else seccomp_filter_drop ( ) ; } else { int rv = unlink ( RUN_SECCOMP_CFG ) ; rv |= unlink ( RUN_SECCOMP_32 ) ; ( void ) rv ; } if ( arg_memory_deny_write_execute ) { if ( arg_debug ) printf ( "Install<S2SV_blank>memory<S2SV_blank>write&execute<S2SV_blank>filter\\n" ) ; seccomp_load ( RUN_SECCOMP_MDWX ) ; } else { int rv = unlink ( RUN_SECCOMP_MDWX ) ; ( void ) rv ; } <S2SV_StartBug> # endif <S2SV_EndBug> FILE * rj = create_ready_for_join_file ( ) ; save_nogroups ( ) ; if ( arg_noroot ) { int rv = unshare ( CLONE_NEWUSER ) ; if ( rv == - 1 ) { fwarning ( "cannot<S2SV_blank>create<S2SV_blank>a<S2SV_blank>new<S2SV_blank>user<S2SV_blank>namespace,<S2SV_blank>going<S2SV_blank>forward<S2SV_blank>without<S2SV_blank>it...\\n" ) ; arg_noroot = 0 ; } } notify_other ( child_to_parent_fds [ 1 ] ) ; close ( child_to_parent_fds [ 1 ] ) ; wait_for_other ( parent_to_child_fds [ 0 ] ) ; close ( parent_to_child_fds [ 0 ] ) ; if ( arg_noroot ) { if ( arg_debug ) printf ( "noroot<S2SV_blank>user<S2SV_blank>namespace<S2SV_blank>installed\\n" ) ; set_caps ( ) ; } if ( arg_nonewprivs ) { prctl ( PR_SET_NO_NEW_PRIVS , 1 , 0 , 0 , 0 ) ; if ( prctl ( PR_GET_NO_NEW_PRIVS , 0 , 0 , 0 , 0 ) != 1 ) { fwarning ( "cannot<S2SV_blank>set<S2SV_blank>NO_NEW_PRIVS,<S2SV_blank>it<S2SV_blank>requires<S2SV_blank>a<S2SV_blank>Linux<S2SV_blank>kernel<S2SV_blank>version<S2SV_blank>3.5<S2SV_blank>or<S2SV_blank>newer.\\n" ) ; if ( force_nonewprivs ) { fprintf ( stderr , "Error:<S2SV_blank>NO_NEW_PRIVS<S2SV_blank>required<S2SV_blank>for<S2SV_blank>this<S2SV_blank>sandbox,<S2SV_blank>exiting<S2SV_blank>...\\n" ) ; exit ( 1 ) ; } } else if ( arg_debug ) printf ( "NO_NEW_PRIVS<S2SV_blank>set\\n" ) ; } drop_privs ( arg_nogroups ) ; prctl ( PR_SET_PDEATHSIG , SIGKILL , 0 , 0 , 0 ) ; if ( cfg . cpus ) set_cpu_affinity ( ) ; pid_t app_pid = fork ( ) ; if ( app_pid == - 1 ) errExit ( "fork" ) ; if ( app_pid == 0 ) { # ifdef HAVE_APPARMOR if ( checkcfg ( CFG_APPARMOR ) && arg_apparmor ) { errno = 0 ; if ( aa_change_onexec ( "firejail-default" ) ) { fwarning ( "Cannot<S2SV_blank>confine<S2SV_blank>the<S2SV_blank>application<S2SV_blank>using<S2SV_blank>AppArmor.\\n" "Maybe<S2SV_blank>firejail-default<S2SV_blank>AppArmor<S2SV_blank>profile<S2SV_blank>is<S2SV_blank>not<S2SV_blank>loaded<S2SV_blank>into<S2SV_blank>the<S2SV_blank>kernel.\\n" "As<S2SV_blank>root,<S2SV_blank>run<S2SV_blank>\\"aa-enforce<S2SV_blank>firejail-default\\"<S2SV_blank>to<S2SV_blank>load<S2SV_blank>it.\\n" ) ; } else if ( arg_debug ) printf ( "AppArmor<S2SV_blank>enabled\\n" ) ; } # endif if ( arg_nice ) set_nice ( cfg . nice ) ; set_rlimits ( ) ; start_application ( 0 , rj ) ; } fclose ( rj ) ; int status = monitor_application ( app_pid ) ; flush_stdin ( ) ; if ( WIFEXITED ( status ) ) { return WEXITSTATUS ( status ) ; } else { return - 1 ; } }
CWE-200 char * url_decode_r ( char * to , char * url , size_t size ) { char * s = url , * d = to , * e = & to [ size - 1 ] ; while ( * s && d < e ) { if ( unlikely ( * s == '%' ) ) { if ( likely ( s [ 1 ] && s [ 2 ] ) ) { <S2SV_StartBug> * d ++ = from_hex ( s [ 1 ] ) << 4 | from_hex ( s [ 2 ] ) ; <S2SV_EndBug> s += 2 ; } } else if ( unlikely ( * s == '+' ) ) * d ++ = '<S2SV_blank>' ; else * d ++ = * s ; s ++ ; } * d = '\\0' ; return to ; }
CWE-200 inline int web_client_api_request_v1_data ( RRDHOST * host , struct web_client * w , char * url ) { debug ( D_WEB_CLIENT , "%llu:<S2SV_blank>API<S2SV_blank>v1<S2SV_blank>data<S2SV_blank>with<S2SV_blank>URL<S2SV_blank>\'%s\'" , w -> id , url ) ; int ret = 400 ; BUFFER * dimensions = NULL ; buffer_flush ( w -> response . data ) ; char * google_version = "0.6" , * google_reqId = "0" , * google_sig = "0" , * google_out = "json" , * responseHandler = NULL , * outFileName = NULL ; time_t last_timestamp_in_data = 0 , google_timestamp = 0 ; char * chart = NULL , * before_str = NULL , * after_str = NULL , * group_time_str = NULL , * points_str = NULL ; int group = RRDR_GROUPING_AVERAGE ; uint32_t format = DATASOURCE_JSON ; uint32_t options = 0x00000000 ; while ( url ) { char * value = mystrsep ( & url , "?&" ) ; if ( ! value || ! * value ) continue ; char * name = mystrsep ( & value , "=" ) ; if ( ! name || ! * name ) continue ; if ( ! value || ! * value ) continue ; debug ( D_WEB_CLIENT , "%llu:<S2SV_blank>API<S2SV_blank>v1<S2SV_blank>data<S2SV_blank>query<S2SV_blank>param<S2SV_blank>\'%s\'<S2SV_blank>with<S2SV_blank>value<S2SV_blank>\'%s\'" , w -> id , name , value ) ; if ( ! strcmp ( name , "chart" ) ) chart = value ; else if ( ! strcmp ( name , "dimension" ) || ! strcmp ( name , "dim" ) || ! strcmp ( name , "dimensions" ) || ! strcmp ( name , "dims" ) ) { if ( ! dimensions ) dimensions = buffer_create ( 100 ) ; buffer_strcat ( dimensions , "|" ) ; buffer_strcat ( dimensions , value ) ; } else if ( ! strcmp ( name , "after" ) ) after_str = value ; else if ( ! strcmp ( name , "before" ) ) before_str = value ; else if ( ! strcmp ( name , "points" ) ) points_str = value ; else if ( ! strcmp ( name , "gtime" ) ) group_time_str = value ; else if ( ! strcmp ( name , "group" ) ) { group = web_client_api_request_v1_data_group ( value , RRDR_GROUPING_AVERAGE ) ; } else if ( ! strcmp ( name , "format" ) ) { format = web_client_api_request_v1_data_format ( value ) ; } else if ( ! strcmp ( name , "options" ) ) { options |= web_client_api_request_v1_data_options ( value ) ; } else if ( ! strcmp ( name , "callback" ) ) { responseHandler = value ; } else if ( ! strcmp ( name , "filename" ) ) { outFileName = value ; } else if ( ! strcmp ( name , "tqx" ) ) { char * tqx_name , * tqx_value ; while ( value ) { tqx_value = mystrsep ( & value , ";" ) ; if ( ! tqx_value || ! * tqx_value ) continue ; tqx_name = mystrsep ( & tqx_value , ":" ) ; if ( ! tqx_name || ! * tqx_name ) continue ; if ( ! tqx_value || ! * tqx_value ) continue ; if ( ! strcmp ( tqx_name , "version" ) ) google_version = tqx_value ; else if ( ! strcmp ( tqx_name , "reqId" ) ) google_reqId = tqx_value ; else if ( ! strcmp ( tqx_name , "sig" ) ) { google_sig = tqx_value ; google_timestamp = strtoul ( google_sig , NULL , 0 ) ; } else if ( ! strcmp ( tqx_name , "out" ) ) { google_out = tqx_value ; format = web_client_api_request_v1_data_google_format ( google_out ) ; } else if ( ! strcmp ( tqx_name , "responseHandler" ) ) responseHandler = tqx_value ; else if ( ! strcmp ( tqx_name , "outFileName" ) ) outFileName = tqx_value ; } } } <S2SV_StartBug> if ( ! chart || ! * chart ) { <S2SV_EndBug> buffer_sprintf ( w -> response . data , "No<S2SV_blank>chart<S2SV_blank>id<S2SV_blank>is<S2SV_blank>given<S2SV_blank>at<S2SV_blank>the<S2SV_blank>request." ) ; goto cleanup ; } RRDSET * st = rrdset_find ( host , chart ) ; if ( ! st ) st = rrdset_find_byname ( host , chart ) ; if ( ! st ) { buffer_strcat ( w -> response . data , "Chart<S2SV_blank>is<S2SV_blank>not<S2SV_blank>found:<S2SV_blank>" ) ; buffer_strcat_htmlescape ( w -> response . data , chart ) ; ret = 404 ; goto cleanup ; } st -> last_accessed_time = now_realtime_sec ( ) ; long long before = ( before_str && * before_str ) ? str2l ( before_str ) : 0 ; long long after = ( after_str && * after_str ) ? str2l ( after_str ) : 0 ; int points = ( points_str && * points_str ) ? str2i ( points_str ) : 0 ; long group_time = ( group_time_str && * group_time_str ) ? str2l ( group_time_str ) : 0 ; debug ( D_WEB_CLIENT , "%llu:<S2SV_blank>API<S2SV_blank>command<S2SV_blank>\'data\'<S2SV_blank>for<S2SV_blank>chart<S2SV_blank>\'%s\',<S2SV_blank>dimensions<S2SV_blank>\'%s\',<S2SV_blank>after<S2SV_blank>\'%lld\',<S2SV_blank>before<S2SV_blank>\'%lld\',<S2SV_blank>points<S2SV_blank>\'%d\',<S2SV_blank>group<S2SV_blank>\'%d\',<S2SV_blank>format<S2SV_blank>\'%u\',<S2SV_blank>options<S2SV_blank>\'0x%08x\'" , w -> id , chart , ( dimensions ) ? buffer_tostring ( dimensions ) : "" , after , before , points , group , format , options ) ; if ( outFileName && * outFileName ) { buffer_sprintf ( w -> response . header , "Content-Disposition:<S2SV_blank>attachment;<S2SV_blank>filename=\\"%s\\"\\r\\n" , outFileName ) ; debug ( D_WEB_CLIENT , "%llu:<S2SV_blank>generating<S2SV_blank>outfilename<S2SV_blank>header:<S2SV_blank>\'%s\'" , w -> id , outFileName ) ; } if ( format == DATASOURCE_DATATABLE_JSONP ) { if ( responseHandler == NULL ) responseHandler = "google.visualization.Query.setResponse" ; debug ( D_WEB_CLIENT_ACCESS , "%llu:<S2SV_blank>GOOGLE<S2SV_blank>JSON/JSONP:<S2SV_blank>version<S2SV_blank>=<S2SV_blank>\'%s\',<S2SV_blank>reqId<S2SV_blank>=<S2SV_blank>\'%s\',<S2SV_blank>sig<S2SV_blank>=<S2SV_blank>\'%s\',<S2SV_blank>out<S2SV_blank>=<S2SV_blank>\'%s\',<S2SV_blank>responseHandler<S2SV_blank>=<S2SV_blank>\'%s\',<S2SV_blank>outFileName<S2SV_blank>=<S2SV_blank>\'%s\'" , w -> id , google_version , google_reqId , google_sig , google_out , responseHandler , outFileName ) ; buffer_sprintf ( w -> response . data , "%s({version:\'%s\',reqId:\'%s\',status:\'ok\',sig:\'%ld\',table:" , responseHandler , google_version , google_reqId , st -> last_updated . tv_sec ) ; } else if ( format == DATASOURCE_JSONP ) { if ( responseHandler == NULL ) responseHandler = "callback" ; buffer_strcat ( w -> response . data , responseHandler ) ; buffer_strcat ( w -> response . data , "(" ) ; } ret = rrdset2anything_api_v1 ( st , w -> response . data , dimensions , format , points , after , before , group , group_time , options , & last_timestamp_in_data ) ; if ( format == DATASOURCE_DATATABLE_JSONP ) { if ( google_timestamp < last_timestamp_in_data ) buffer_strcat ( w -> response . data , "});" ) ; else { buffer_flush ( w -> response . data ) ; buffer_sprintf ( w -> response . data , "%s({version:\'%s\',reqId:\'%s\',status:\'error\',errors:[{reason:\'not_modified\',message:\'Data<S2SV_blank>not<S2SV_blank>modified\'}]});" , responseHandler , google_version , google_reqId ) ; } } else if ( format == DATASOURCE_JSONP ) buffer_strcat ( w -> response . data , ");" ) ; cleanup : buffer_free ( dimensions ) ; return ret ; }
CWE-119 static void decode_residue ( vorb * f , float * residue_buffers [ ] , int ch , int n , int rn , uint8 * do_not_decode ) { int i , j , pass ; Residue * r = f -> residue_config + rn ; int rtype = f -> residue_types [ rn ] ; int c = r -> classbook ; int classwords = f -> codebooks [ c ] . dimensions ; <S2SV_StartBug> int n_read = r -> end - r -> begin ; <S2SV_EndBug> int part_read = n_read / r -> part_size ; int temp_alloc_point = temp_alloc_save ( f ) ; # ifndef STB_VORBIS_DIVIDES_IN_RESIDUE uint8 * * * part_classdata = ( uint8 * * * ) temp_block_array ( f , f -> channels , part_read * sizeof ( * * part_classdata ) ) ; # else int * * classifications = ( int * * ) temp_block_array ( f , f -> channels , part_read * sizeof ( * * classifications ) ) ; # endif CHECK ( f ) ; for ( i = 0 ; i < ch ; ++ i ) if ( ! do_not_decode [ i ] ) memset ( residue_buffers [ i ] , 0 , sizeof ( float ) * n ) ; if ( rtype == 2 && ch != 1 ) { for ( j = 0 ; j < ch ; ++ j ) if ( ! do_not_decode [ j ] ) break ; if ( j == ch ) goto done ; for ( pass = 0 ; pass < 8 ; ++ pass ) { int pcount = 0 , class_set = 0 ; if ( ch == 2 ) { while ( pcount < part_read ) { int z = r -> begin + pcount * r -> part_size ; int c_inter = ( z & 1 ) , p_inter = z >> 1 ; if ( pass == 0 ) { Codebook * c = f -> codebooks + r -> classbook ; int q ; DECODE ( q , f , c ) ; if ( q == EOP ) goto done ; # ifndef STB_VORBIS_DIVIDES_IN_RESIDUE part_classdata [ 0 ] [ class_set ] = r -> classdata [ q ] ; # else for ( i = classwords - 1 ; i >= 0 ; -- i ) { classifications [ 0 ] [ i + pcount ] = q % r -> classifications ; q /= r -> classifications ; } # endif } for ( i = 0 ; i < classwords && pcount < part_read ; ++ i , ++ pcount ) { int z = r -> begin + pcount * r -> part_size ; # ifndef STB_VORBIS_DIVIDES_IN_RESIDUE int c = part_classdata [ 0 ] [ class_set ] [ i ] ; # else int c = classifications [ 0 ] [ pcount ] ; # endif int b = r -> residue_books [ c ] [ pass ] ; if ( b >= 0 ) { Codebook * book = f -> codebooks + b ; # ifdef STB_VORBIS_DIVIDES_IN_CODEBOOK if ( ! codebook_decode_deinterleave_repeat ( f , book , residue_buffers , ch , & c_inter , & p_inter , n , r -> part_size ) ) goto done ; # else if ( ! codebook_decode_deinterleave_repeat ( f , book , residue_buffers , ch , & c_inter , & p_inter , n , r -> part_size ) ) goto done ; # endif } else { z += r -> part_size ; c_inter = z & 1 ; p_inter = z >> 1 ; } } # ifndef STB_VORBIS_DIVIDES_IN_RESIDUE ++ class_set ; # endif } } else if ( ch == 1 ) { while ( pcount < part_read ) { int z = r -> begin + pcount * r -> part_size ; int c_inter = 0 , p_inter = z ; if ( pass == 0 ) { Codebook * c = f -> codebooks + r -> classbook ; int q ; DECODE ( q , f , c ) ; if ( q == EOP ) goto done ; # ifndef STB_VORBIS_DIVIDES_IN_RESIDUE part_classdata [ 0 ] [ class_set ] = r -> classdata [ q ] ; # else for ( i = classwords - 1 ; i >= 0 ; -- i ) { classifications [ 0 ] [ i + pcount ] = q % r -> classifications ; q /= r -> classifications ; } # endif } for ( i = 0 ; i < classwords && pcount < part_read ; ++ i , ++ pcount ) { int z = r -> begin + pcount * r -> part_size ; # ifndef STB_VORBIS_DIVIDES_IN_RESIDUE int c = part_classdata [ 0 ] [ class_set ] [ i ] ; # else int c = classifications [ 0 ] [ pcount ] ; # endif int b = r -> residue_books [ c ] [ pass ] ; if ( b >= 0 ) { Codebook * book = f -> codebooks + b ; if ( ! codebook_decode_deinterleave_repeat ( f , book , residue_buffers , ch , & c_inter , & p_inter , n , r -> part_size ) ) goto done ; } else { z += r -> part_size ; c_inter = 0 ; p_inter = z ; } } # ifndef STB_VORBIS_DIVIDES_IN_RESIDUE ++ class_set ; # endif } } else { while ( pcount < part_read ) { int z = r -> begin + pcount * r -> part_size ; int c_inter = z % ch , p_inter = z / ch ; if ( pass == 0 ) { Codebook * c = f -> codebooks + r -> classbook ; int q ; DECODE ( q , f , c ) ; if ( q == EOP ) goto done ; # ifndef STB_VORBIS_DIVIDES_IN_RESIDUE part_classdata [ 0 ] [ class_set ] = r -> classdata [ q ] ; # else for ( i = classwords - 1 ; i >= 0 ; -- i ) { classifications [ 0 ] [ i + pcount ] = q % r -> classifications ; q /= r -> classifications ; } # endif } for ( i = 0 ; i < classwords && pcount < part_read ; ++ i , ++ pcount ) { int z = r -> begin + pcount * r -> part_size ; # ifndef STB_VORBIS_DIVIDES_IN_RESIDUE int c = part_classdata [ 0 ] [ class_set ] [ i ] ; # else int c = classifications [ 0 ] [ pcount ] ; # endif int b = r -> residue_books [ c ] [ pass ] ; if ( b >= 0 ) { Codebook * book = f -> codebooks + b ; if ( ! codebook_decode_deinterleave_repeat ( f , book , residue_buffers , ch , & c_inter , & p_inter , n , r -> part_size ) ) goto done ; } else { z += r -> part_size ; c_inter = z % ch ; p_inter = z / ch ; } } # ifndef STB_VORBIS_DIVIDES_IN_RESIDUE ++ class_set ; # endif } } } goto done ; } CHECK ( f ) ; for ( pass = 0 ; pass < 8 ; ++ pass ) { int pcount = 0 , class_set = 0 ; while ( pcount < part_read ) { if ( pass == 0 ) { for ( j = 0 ; j < ch ; ++ j ) { if ( ! do_not_decode [ j ] ) { Codebook * c = f -> codebooks + r -> classbook ; int temp ; DECODE ( temp , f , c ) ; if ( temp == EOP ) goto done ; # ifndef STB_VORBIS_DIVIDES_IN_RESIDUE part_classdata [ j ] [ class_set ] = r -> classdata [ temp ] ; # else for ( i = classwords - 1 ; i >= 0 ; -- i ) { classifications [ j ] [ i + pcount ] = temp % r -> classifications ; temp /= r -> classifications ; } # endif } } } for ( i = 0 ; i < classwords && pcount < part_read ; ++ i , ++ pcount ) { for ( j = 0 ; j < ch ; ++ j ) { if ( ! do_not_decode [ j ] ) { # ifndef STB_VORBIS_DIVIDES_IN_RESIDUE int c = part_classdata [ j ] [ class_set ] [ i ] ; # else int c = classifications [ j ] [ pcount ] ; # endif int b = r -> residue_books [ c ] [ pass ] ; if ( b >= 0 ) { float * target = residue_buffers [ j ] ; int offset = r -> begin + pcount * r -> part_size ; int n = r -> part_size ; Codebook * book = f -> codebooks + b ; if ( ! residue_decode ( f , book , target , offset , n , rtype ) ) goto done ; } } } } # ifndef STB_VORBIS_DIVIDES_IN_RESIDUE ++ class_set ; # endif } } done : CHECK ( f ) ; # ifndef STB_VORBIS_DIVIDES_IN_RESIDUE temp_free ( f , part_classdata ) ; # else temp_free ( f , classifications ) ; # endif temp_alloc_restore ( f , temp_alloc_point ) ; }
CWE-119 static int start_decoder ( vorb * f ) { uint8 header [ 6 ] , x , y ; int len , i , j , k , max_submaps = 0 ; int longest_floorlist = 0 ; if ( ! start_page ( f ) ) return FALSE ; if ( ! ( f -> page_flag & PAGEFLAG_first_page ) ) return error ( f , VORBIS_invalid_first_page ) ; if ( f -> page_flag & PAGEFLAG_last_page ) return error ( f , VORBIS_invalid_first_page ) ; if ( f -> page_flag & PAGEFLAG_continued_packet ) return error ( f , VORBIS_invalid_first_page ) ; if ( f -> segment_count != 1 ) return error ( f , VORBIS_invalid_first_page ) ; if ( f -> segments [ 0 ] != 30 ) return error ( f , VORBIS_invalid_first_page ) ; if ( get8 ( f ) != VORBIS_packet_id ) return error ( f , VORBIS_invalid_first_page ) ; if ( ! getn ( f , header , 6 ) ) return error ( f , VORBIS_unexpected_eof ) ; if ( ! vorbis_validate ( header ) ) return error ( f , VORBIS_invalid_first_page ) ; if ( get32 ( f ) != 0 ) return error ( f , VORBIS_invalid_first_page ) ; f -> channels = get8 ( f ) ; if ( ! f -> channels ) return error ( f , VORBIS_invalid_first_page ) ; if ( f -> channels > STB_VORBIS_MAX_CHANNELS ) return error ( f , VORBIS_too_many_channels ) ; f -> sample_rate = get32 ( f ) ; if ( ! f -> sample_rate ) return error ( f , VORBIS_invalid_first_page ) ; get32 ( f ) ; get32 ( f ) ; get32 ( f ) ; x = get8 ( f ) ; { int log0 , log1 ; log0 = x & 15 ; log1 = x >> 4 ; f -> blocksize_0 = 1 << log0 ; f -> blocksize_1 = 1 << log1 ; if ( log0 < 6 || log0 > 13 ) return error ( f , VORBIS_invalid_setup ) ; if ( log1 < 6 || log1 > 13 ) return error ( f , VORBIS_invalid_setup ) ; if ( log0 > log1 ) return error ( f , VORBIS_invalid_setup ) ; } x = get8 ( f ) ; if ( ! ( x & 1 ) ) return error ( f , VORBIS_invalid_first_page ) ; if ( ! start_page ( f ) ) return FALSE ; if ( ! start_packet ( f ) ) return FALSE ; do { len = next_segment ( f ) ; skip ( f , len ) ; f -> bytes_in_seg = 0 ; } while ( len ) ; if ( ! start_packet ( f ) ) return FALSE ; # ifndef STB_VORBIS_NO_PUSHDATA_API if ( IS_PUSH_MODE ( f ) ) { if ( ! is_whole_packet_present ( f , TRUE ) ) { if ( f -> error == VORBIS_invalid_stream ) f -> error = VORBIS_invalid_setup ; return FALSE ; } } # endif crc32_init ( ) ; if ( get8_packet ( f ) != VORBIS_packet_setup ) return error ( f , VORBIS_invalid_setup ) ; for ( i = 0 ; i < 6 ; ++ i ) header [ i ] = get8_packet ( f ) ; if ( ! vorbis_validate ( header ) ) return error ( f , VORBIS_invalid_setup ) ; f -> codebook_count = get_bits ( f , 8 ) + 1 ; f -> codebooks = ( Codebook * ) setup_malloc ( f , sizeof ( * f -> codebooks ) * f -> codebook_count ) ; if ( f -> codebooks == NULL ) return error ( f , VORBIS_outofmem ) ; memset ( f -> codebooks , 0 , sizeof ( * f -> codebooks ) * f -> codebook_count ) ; for ( i = 0 ; i < f -> codebook_count ; ++ i ) { uint32 * values ; int ordered , sorted_count ; int total = 0 ; uint8 * lengths ; Codebook * c = f -> codebooks + i ; CHECK ( f ) ; x = get_bits ( f , 8 ) ; if ( x != 0x42 ) return error ( f , VORBIS_invalid_setup ) ; x = get_bits ( f , 8 ) ; if ( x != 0x43 ) return error ( f , VORBIS_invalid_setup ) ; x = get_bits ( f , 8 ) ; if ( x != 0x56 ) return error ( f , VORBIS_invalid_setup ) ; x = get_bits ( f , 8 ) ; c -> dimensions = ( get_bits ( f , 8 ) << 8 ) + x ; x = get_bits ( f , 8 ) ; y = get_bits ( f , 8 ) ; c -> entries = ( get_bits ( f , 8 ) << 16 ) + ( y << 8 ) + x ; ordered = get_bits ( f , 1 ) ; c -> sparse = ordered ? 0 : get_bits ( f , 1 ) ; if ( c -> dimensions == 0 && c -> entries != 0 ) return error ( f , VORBIS_invalid_setup ) ; if ( c -> sparse ) lengths = ( uint8 * ) setup_temp_malloc ( f , c -> entries ) ; else lengths = c -> codeword_lengths = ( uint8 * ) setup_malloc ( f , c -> entries ) ; if ( ! lengths ) return error ( f , VORBIS_outofmem ) ; if ( ordered ) { int current_entry = 0 ; int current_length = get_bits ( f , 5 ) + 1 ; while ( current_entry < c -> entries ) { int limit = c -> entries - current_entry ; int n = get_bits ( f , ilog ( limit ) ) ; if ( current_entry + n > ( int ) c -> entries ) { return error ( f , VORBIS_invalid_setup ) ; } memset ( lengths + current_entry , current_length , n ) ; current_entry += n ; ++ current_length ; } } else { for ( j = 0 ; j < c -> entries ; ++ j ) { int present = c -> sparse ? get_bits ( f , 1 ) : 1 ; if ( present ) { lengths [ j ] = get_bits ( f , 5 ) + 1 ; ++ total ; if ( lengths [ j ] == 32 ) return error ( f , VORBIS_invalid_setup ) ; } else { lengths [ j ] = NO_CODE ; } } } if ( c -> sparse && total >= c -> entries >> 2 ) { if ( c -> entries > ( int ) f -> setup_temp_memory_required ) f -> setup_temp_memory_required = c -> entries ; c -> codeword_lengths = ( uint8 * ) setup_malloc ( f , c -> entries ) ; if ( c -> codeword_lengths == NULL ) return error ( f , VORBIS_outofmem ) ; memcpy ( c -> codeword_lengths , lengths , c -> entries ) ; setup_temp_free ( f , lengths , c -> entries ) ; lengths = c -> codeword_lengths ; c -> sparse = 0 ; } if ( c -> sparse ) { sorted_count = total ; } else { sorted_count = 0 ; # ifndef STB_VORBIS_NO_HUFFMAN_BINARY_SEARCH for ( j = 0 ; j < c -> entries ; ++ j ) if ( lengths [ j ] > STB_VORBIS_FAST_HUFFMAN_LENGTH && lengths [ j ] != NO_CODE ) ++ sorted_count ; # endif } c -> sorted_entries = sorted_count ; values = NULL ; CHECK ( f ) ; if ( ! c -> sparse ) { c -> codewords = ( uint32 * ) setup_malloc ( f , sizeof ( c -> codewords [ 0 ] ) * c -> entries ) ; if ( ! c -> codewords ) return error ( f , VORBIS_outofmem ) ; } else { unsigned int size ; if ( c -> sorted_entries ) { c -> codeword_lengths = ( uint8 * ) setup_malloc ( f , c -> sorted_entries ) ; if ( ! c -> codeword_lengths ) return error ( f , VORBIS_outofmem ) ; c -> codewords = ( uint32 * ) setup_temp_malloc ( f , sizeof ( * c -> codewords ) * c -> sorted_entries ) ; if ( ! c -> codewords ) return error ( f , VORBIS_outofmem ) ; values = ( uint32 * ) setup_temp_malloc ( f , sizeof ( * values ) * c -> sorted_entries ) ; if ( ! values ) return error ( f , VORBIS_outofmem ) ; } size = c -> entries + ( sizeof ( * c -> codewords ) + sizeof ( * values ) ) * c -> sorted_entries ; if ( size > f -> setup_temp_memory_required ) f -> setup_temp_memory_required = size ; } if ( ! compute_codewords ( c , lengths , c -> entries , values ) ) { if ( c -> sparse ) setup_temp_free ( f , values , 0 ) ; return error ( f , VORBIS_invalid_setup ) ; } if ( c -> sorted_entries ) { c -> sorted_codewords = ( uint32 * ) setup_malloc ( f , sizeof ( * c -> sorted_codewords ) * ( c -> sorted_entries + 1 ) ) ; if ( c -> sorted_codewords == NULL ) return error ( f , VORBIS_outofmem ) ; c -> sorted_values = ( int * ) setup_malloc ( f , sizeof ( * c -> sorted_values ) * ( c -> sorted_entries + 1 ) ) ; if ( c -> sorted_values == NULL ) return error ( f , VORBIS_outofmem ) ; ++ c -> sorted_values ; c -> sorted_values [ - 1 ] = - 1 ; compute_sorted_huffman ( c , lengths , values ) ; } if ( c -> sparse ) { setup_temp_free ( f , values , sizeof ( * values ) * c -> sorted_entries ) ; setup_temp_free ( f , c -> codewords , sizeof ( * c -> codewords ) * c -> sorted_entries ) ; setup_temp_free ( f , lengths , c -> entries ) ; c -> codewords = NULL ; } compute_accelerated_huffman ( c ) ; CHECK ( f ) ; c -> lookup_type = get_bits ( f , 4 ) ; if ( c -> lookup_type > 2 ) return error ( f , VORBIS_invalid_setup ) ; if ( c -> lookup_type > 0 ) { uint16 * mults ; c -> minimum_value = float32_unpack ( get_bits ( f , 32 ) ) ; c -> delta_value = float32_unpack ( get_bits ( f , 32 ) ) ; c -> value_bits = get_bits ( f , 4 ) + 1 ; c -> sequence_p = get_bits ( f , 1 ) ; if ( c -> lookup_type == 1 ) { c -> lookup_values = lookup1_values ( c -> entries , c -> dimensions ) ; } else { c -> lookup_values = c -> entries * c -> dimensions ; } if ( c -> lookup_values == 0 ) return error ( f , VORBIS_invalid_setup ) ; mults = ( uint16 * ) setup_temp_malloc ( f , sizeof ( mults [ 0 ] ) * c -> lookup_values ) ; if ( mults == NULL ) return error ( f , VORBIS_outofmem ) ; for ( j = 0 ; j < ( int ) c -> lookup_values ; ++ j ) { int q = get_bits ( f , c -> value_bits ) ; if ( q == EOP ) { setup_temp_free ( f , mults , sizeof ( mults [ 0 ] ) * c -> lookup_values ) ; return error ( f , VORBIS_invalid_setup ) ; } mults [ j ] = q ; } # ifndef STB_VORBIS_DIVIDES_IN_CODEBOOK if ( c -> lookup_type == 1 ) { int len , sparse = c -> sparse ; float last = 0 ; if ( sparse ) { if ( c -> sorted_entries == 0 ) goto skip ; c -> multiplicands = ( codetype * ) setup_malloc ( f , sizeof ( c -> multiplicands [ 0 ] ) * c -> sorted_entries * c -> dimensions ) ; } else c -> multiplicands = ( codetype * ) setup_malloc ( f , sizeof ( c -> multiplicands [ 0 ] ) * c -> entries * c -> dimensions ) ; if ( c -> multiplicands == NULL ) { setup_temp_free ( f , mults , sizeof ( mults [ 0 ] ) * c -> lookup_values ) ; return error ( f , VORBIS_outofmem ) ; } len = sparse ? c -> sorted_entries : c -> entries ; for ( j = 0 ; j < len ; ++ j ) { unsigned int z = sparse ? c -> sorted_values [ j ] : j ; unsigned int div = 1 ; for ( k = 0 ; k < c -> dimensions ; ++ k ) { int off = ( z / div ) % c -> lookup_values ; float val = mults [ off ] ; val = mults [ off ] * c -> delta_value + c -> minimum_value + last ; c -> multiplicands [ j * c -> dimensions + k ] = val ; if ( c -> sequence_p ) last = val ; if ( k + 1 < c -> dimensions ) { if ( div > UINT_MAX / ( unsigned int ) c -> lookup_values ) { setup_temp_free ( f , mults , sizeof ( mults [ 0 ] ) * c -> lookup_values ) ; return error ( f , VORBIS_invalid_setup ) ; } div *= c -> lookup_values ; } } } c -> lookup_type = 2 ; } else # endif { float last = 0 ; CHECK ( f ) ; c -> multiplicands = ( codetype * ) setup_malloc ( f , sizeof ( c -> multiplicands [ 0 ] ) * c -> lookup_values ) ; if ( c -> multiplicands == NULL ) { setup_temp_free ( f , mults , sizeof ( mults [ 0 ] ) * c -> lookup_values ) ; return error ( f , VORBIS_outofmem ) ; } for ( j = 0 ; j < ( int ) c -> lookup_values ; ++ j ) { float val = mults [ j ] * c -> delta_value + c -> minimum_value + last ; c -> multiplicands [ j ] = val ; if ( c -> sequence_p ) last = val ; } } # ifndef STB_VORBIS_DIVIDES_IN_CODEBOOK skip : ; # endif setup_temp_free ( f , mults , sizeof ( mults [ 0 ] ) * c -> lookup_values ) ; CHECK ( f ) ; } CHECK ( f ) ; } x = get_bits ( f , 6 ) + 1 ; for ( i = 0 ; i < x ; ++ i ) { uint32 z = get_bits ( f , 16 ) ; if ( z != 0 ) return error ( f , VORBIS_invalid_setup ) ; } f -> floor_count = get_bits ( f , 6 ) + 1 ; f -> floor_config = ( Floor * ) setup_malloc ( f , f -> floor_count * sizeof ( * f -> floor_config ) ) ; if ( f -> floor_config == NULL ) return error ( f , VORBIS_outofmem ) ; for ( i = 0 ; i < f -> floor_count ; ++ i ) { f -> floor_types [ i ] = get_bits ( f , 16 ) ; if ( f -> floor_types [ i ] > 1 ) return error ( f , VORBIS_invalid_setup ) ; if ( f -> floor_types [ i ] == 0 ) { Floor0 * g = & f -> floor_config [ i ] . floor0 ; g -> order = get_bits ( f , 8 ) ; g -> rate = get_bits ( f , 16 ) ; g -> bark_map_size = get_bits ( f , 16 ) ; g -> amplitude_bits = get_bits ( f , 6 ) ; g -> amplitude_offset = get_bits ( f , 8 ) ; g -> number_of_books = get_bits ( f , 4 ) + 1 ; for ( j = 0 ; j < g -> number_of_books ; ++ j ) g -> book_list [ j ] = get_bits ( f , 8 ) ; return error ( f , VORBIS_feature_not_supported ) ; } else { stbv__floor_ordering p [ 31 * 8 + 2 ] ; Floor1 * g = & f -> floor_config [ i ] . floor1 ; int max_class = - 1 ; g -> partitions = get_bits ( f , 5 ) ; for ( j = 0 ; j < g -> partitions ; ++ j ) { g -> partition_class_list [ j ] = get_bits ( f , 4 ) ; if ( g -> partition_class_list [ j ] > max_class ) max_class = g -> partition_class_list [ j ] ; } for ( j = 0 ; j <= max_class ; ++ j ) { g -> class_dimensions [ j ] = get_bits ( f , 3 ) + 1 ; g -> class_subclasses [ j ] = get_bits ( f , 2 ) ; if ( g -> class_subclasses [ j ] ) { g -> class_masterbooks [ j ] = get_bits ( f , 8 ) ; if ( g -> class_masterbooks [ j ] >= f -> codebook_count ) return error ( f , VORBIS_invalid_setup ) ; } for ( k = 0 ; k < 1 << g -> class_subclasses [ j ] ; ++ k ) { g -> subclass_books [ j ] [ k ] = get_bits ( f , 8 ) - 1 ; if ( g -> subclass_books [ j ] [ k ] >= f -> codebook_count ) return error ( f , VORBIS_invalid_setup ) ; } } g -> floor1_multiplier = get_bits ( f , 2 ) + 1 ; g -> rangebits = get_bits ( f , 4 ) ; g -> Xlist [ 0 ] = 0 ; g -> Xlist [ 1 ] = 1 << g -> rangebits ; g -> values = 2 ; for ( j = 0 ; j < g -> partitions ; ++ j ) { int c = g -> partition_class_list [ j ] ; for ( k = 0 ; k < g -> class_dimensions [ c ] ; ++ k ) { g -> Xlist [ g -> values ] = get_bits ( f , g -> rangebits ) ; ++ g -> values ; } } for ( j = 0 ; j < g -> values ; ++ j ) { p [ j ] . x = g -> Xlist [ j ] ; p [ j ] . id = j ; } qsort ( p , g -> values , sizeof ( p [ 0 ] ) , point_compare ) ; for ( j = 0 ; j < g -> values ; ++ j ) g -> sorted_order [ j ] = ( uint8 ) p [ j ] . id ; for ( j = 2 ; j < g -> values ; ++ j ) { int low , hi ; neighbors ( g -> Xlist , j , & low , & hi ) ; g -> neighbors [ j ] [ 0 ] = low ; g -> neighbors [ j ] [ 1 ] = hi ; } if ( g -> values > longest_floorlist ) longest_floorlist = g -> values ; } } f -> residue_count = get_bits ( f , 6 ) + 1 ; f -> residue_config = ( Residue * ) setup_malloc ( f , f -> residue_count * sizeof ( f -> residue_config [ 0 ] ) ) ; if ( f -> residue_config == NULL ) return error ( f , VORBIS_outofmem ) ; memset ( f -> residue_config , 0 , f -> residue_count * sizeof ( f -> residue_config [ 0 ] ) ) ; for ( i = 0 ; i < f -> residue_count ; ++ i ) { uint8 residue_cascade [ 64 ] ; Residue * r = f -> residue_config + i ; f -> residue_types [ i ] = get_bits ( f , 16 ) ; if ( f -> residue_types [ i ] > 2 ) return error ( f , VORBIS_invalid_setup ) ; r -> begin = get_bits ( f , 24 ) ; r -> end = get_bits ( f , 24 ) ; if ( r -> end < r -> begin ) return error ( f , VORBIS_invalid_setup ) ; r -> part_size = get_bits ( f , 24 ) + 1 ; r -> classifications = get_bits ( f , 6 ) + 1 ; r -> classbook = get_bits ( f , 8 ) ; if ( r -> classbook >= f -> codebook_count ) return error ( f , VORBIS_invalid_setup ) ; for ( j = 0 ; j < r -> classifications ; ++ j ) { uint8 high_bits = 0 ; uint8 low_bits = get_bits ( f , 3 ) ; if ( get_bits ( f , 1 ) ) high_bits = get_bits ( f , 5 ) ; residue_cascade [ j ] = high_bits * 8 + low_bits ; } r -> residue_books = ( short ( * ) [ 8 ] ) setup_malloc ( f , sizeof ( r -> residue_books [ 0 ] ) * r -> classifications ) ; if ( r -> residue_books == NULL ) return error ( f , VORBIS_outofmem ) ; for ( j = 0 ; j < r -> classifications ; ++ j ) { for ( k = 0 ; k < 8 ; ++ k ) { if ( residue_cascade [ j ] & ( 1 << k ) ) { r -> residue_books [ j ] [ k ] = get_bits ( f , 8 ) ; if ( r -> residue_books [ j ] [ k ] >= f -> codebook_count ) return error ( f , VORBIS_invalid_setup ) ; } else { r -> residue_books [ j ] [ k ] = - 1 ; } } } r -> classdata = ( uint8 * * ) setup_malloc ( f , sizeof ( * r -> classdata ) * f -> codebooks [ r -> classbook ] . entries ) ; if ( ! r -> classdata ) return error ( f , VORBIS_outofmem ) ; memset ( r -> classdata , 0 , sizeof ( * r -> classdata ) * f -> codebooks [ r -> classbook ] . entries ) ; for ( j = 0 ; j < f -> codebooks [ r -> classbook ] . entries ; ++ j ) { int classwords = f -> codebooks [ r -> classbook ] . dimensions ; int temp = j ; r -> classdata [ j ] = ( uint8 * ) setup_malloc ( f , sizeof ( r -> classdata [ j ] [ 0 ] ) * classwords ) ; if ( r -> classdata [ j ] == NULL ) return error ( f , VORBIS_outofmem ) ; for ( k = classwords - 1 ; k >= 0 ; -- k ) { r -> classdata [ j ] [ k ] = temp % r -> classifications ; temp /= r -> classifications ; } } } f -> mapping_count = get_bits ( f , 6 ) + 1 ; f -> mapping = ( Mapping * ) setup_malloc ( f , f -> mapping_count * sizeof ( * f -> mapping ) ) ; if ( f -> mapping == NULL ) return error ( f , VORBIS_outofmem ) ; memset ( f -> mapping , 0 , f -> mapping_count * sizeof ( * f -> mapping ) ) ; for ( i = 0 ; i < f -> mapping_count ; ++ i ) { Mapping * m = f -> mapping + i ; int mapping_type = get_bits ( f , 16 ) ; if ( mapping_type != 0 ) return error ( f , VORBIS_invalid_setup ) ; m -> chan = ( MappingChannel * ) setup_malloc ( f , f -> channels * sizeof ( * m -> chan ) ) ; if ( m -> chan == NULL ) return error ( f , VORBIS_outofmem ) ; if ( get_bits ( f , 1 ) ) m -> submaps = get_bits ( f , 4 ) + 1 ; else m -> submaps = 1 ; if ( m -> submaps > max_submaps ) max_submaps = m -> submaps ; if ( get_bits ( f , 1 ) ) { m -> coupling_steps = get_bits ( f , 8 ) + 1 ; for ( k = 0 ; k < m -> coupling_steps ; ++ k ) { m -> chan [ k ] . magnitude = get_bits ( f , ilog ( f -> channels - 1 ) ) ; m -> chan [ k ] . angle = get_bits ( f , ilog ( f -> channels - 1 ) ) ; if ( m -> chan [ k ] . magnitude >= f -> channels ) return error ( f , VORBIS_invalid_setup ) ; if ( m -> chan [ k ] . angle >= f -> channels ) return error ( f , VORBIS_invalid_setup ) ; if ( m -> chan [ k ] . magnitude == m -> chan [ k ] . angle ) return error ( f , VORBIS_invalid_setup ) ; } } else m -> coupling_steps = 0 ; if ( get_bits ( f , 2 ) ) return error ( f , VORBIS_invalid_setup ) ; if ( m -> submaps > 1 ) { for ( j = 0 ; j < f -> channels ; ++ j ) { m -> chan [ j ] . mux = get_bits ( f , 4 ) ; if ( m -> chan [ j ] . mux >= m -> submaps ) return error ( f , VORBIS_invalid_setup ) ; } } else for ( j = 0 ; j < f -> channels ; ++ j ) m -> chan [ j ] . mux = 0 ; for ( j = 0 ; j < m -> submaps ; ++ j ) { get_bits ( f , 8 ) ; m -> submap_floor [ j ] = get_bits ( f , 8 ) ; m -> submap_residue [ j ] = get_bits ( f , 8 ) ; if ( m -> submap_floor [ j ] >= f -> floor_count ) return error ( f , VORBIS_invalid_setup ) ; if ( m -> submap_residue [ j ] >= f -> residue_count ) return error ( f , VORBIS_invalid_setup ) ; } } f -> mode_count = get_bits ( f , 6 ) + 1 ; for ( i = 0 ; i < f -> mode_count ; ++ i ) { Mode * m = f -> mode_config + i ; m -> blockflag = get_bits ( f , 1 ) ; m -> windowtype = get_bits ( f , 16 ) ; m -> transformtype = get_bits ( f , 16 ) ; m -> mapping = get_bits ( f , 8 ) ; if ( m -> windowtype != 0 ) return error ( f , VORBIS_invalid_setup ) ; if ( m -> transformtype != 0 ) return error ( f , VORBIS_invalid_setup ) ; if ( m -> mapping >= f -> mapping_count ) return error ( f , VORBIS_invalid_setup ) ; } flush_packet ( f ) ; f -> previous_length = 0 ; for ( i = 0 ; i < f -> channels ; ++ i ) { f -> channel_buffers [ i ] = ( float * ) setup_malloc ( f , sizeof ( float ) * f -> blocksize_1 ) ; f -> previous_window [ i ] = ( float * ) setup_malloc ( f , sizeof ( float ) * f -> blocksize_1 / 2 ) ; f -> finalY [ i ] = ( int16 * ) setup_malloc ( f , sizeof ( int16 ) * longest_floorlist ) ; if ( f -> channel_buffers [ i ] == NULL || f -> previous_window [ i ] == NULL || f -> finalY [ i ] == NULL ) return error ( f , VORBIS_outofmem ) ; # ifdef STB_VORBIS_NO_DEFER_FLOOR f -> floor_buffers [ i ] = ( float * ) setup_malloc ( f , sizeof ( float ) * f -> blocksize_1 / 2 ) ; if ( f -> floor_buffers [ i ] == NULL ) return error ( f , VORBIS_outofmem ) ; # endif } if ( ! init_blocksize ( f , 0 , f -> blocksize_0 ) ) return FALSE ; if ( ! init_blocksize ( f , 1 , f -> blocksize_1 ) ) return FALSE ; f -> blocksize [ 0 ] = f -> blocksize_0 ; f -> blocksize [ 1 ] = f -> blocksize_1 ; # ifdef STB_VORBIS_DIVIDE_TABLE if ( integer_divide_table [ 1 ] [ 1 ] == 0 ) for ( i = 0 ; i < DIVTAB_NUMER ; ++ i ) for ( j = 1 ; j < DIVTAB_DENOM ; ++ j ) integer_divide_table [ i ] [ j ] = i / j ; # endif { uint32 imdct_mem = ( f -> blocksize_1 * sizeof ( float ) >> 1 ) ; uint32 classify_mem ; int i , max_part_read = 0 ; for ( i = 0 ; i < f -> residue_count ; ++ i ) { Residue * r = f -> residue_config + i ; <S2SV_StartBug> int n_read = r -> end - r -> begin ; <S2SV_EndBug> int part_read = n_read / r -> part_size ; if ( part_read > max_part_read ) max_part_read = part_read ; } # ifndef STB_VORBIS_DIVIDES_IN_RESIDUE classify_mem = f -> channels * ( sizeof ( void * ) + max_part_read * sizeof ( uint8 * ) ) ; # else classify_mem = f -> channels * ( sizeof ( void * ) + max_part_read * sizeof ( int * ) ) ; # endif f -> temp_memory_required = classify_mem ; if ( imdct_mem > f -> temp_memory_required ) f -> temp_memory_required = imdct_mem ; } f -> first_decode = TRUE ; if ( f -> alloc . alloc_buffer ) { assert ( f -> temp_offset == f -> alloc . alloc_buffer_length_in_bytes ) ; if ( f -> setup_offset + sizeof ( * f ) + f -> temp_memory_required > ( unsigned ) f -> temp_offset ) return error ( f , VORBIS_outofmem ) ; } f -> first_audio_page_offset = stb_vorbis_get_file_offset ( f ) ; return TRUE ; }
CWE-119 static __forceinline void draw_line ( float * output , int x0 , int y0 , int x1 , int y1 , int n ) { int dy = y1 - y0 ; int adx = x1 - x0 ; int ady = abs ( dy ) ; int base ; int x = x0 , y = y0 ; int err = 0 ; int sy ; # ifdef STB_VORBIS_DIVIDE_TABLE if ( adx < DIVTAB_DENOM && ady < DIVTAB_NUMER ) { if ( dy < 0 ) { base = - integer_divide_table [ ady ] [ adx ] ; sy = base - 1 ; } else { base = integer_divide_table [ ady ] [ adx ] ; sy = base + 1 ; } } else { base = dy / adx ; if ( dy < 0 ) sy = base - 1 ; else sy = base + 1 ; } # else base = dy / adx ; if ( dy < 0 ) sy = base - 1 ; else sy = base + 1 ; # endif ady -= abs ( base ) * adx ; if ( x1 > n ) x1 = n ; if ( x < x1 ) { <S2SV_StartBug> LINE_OP ( output [ x ] , inverse_db_table [ y ] ) ; <S2SV_EndBug> for ( ++ x ; x < x1 ; ++ x ) { err += ady ; if ( err >= adx ) { err -= adx ; y += sy ; } else y += base ; <S2SV_StartBug> LINE_OP ( output [ x ] , inverse_db_table [ y ] ) ; <S2SV_EndBug> } } }
CWE-119 static float * get_window ( vorb * f , int len ) { len <<= 1 ; if ( len == f -> blocksize_0 ) return f -> window [ 0 ] ; if ( len == f -> blocksize_1 ) return f -> window [ 1 ] ; <S2SV_StartBug> assert ( 0 ) ; <S2SV_EndBug> return NULL ; }
CWE-119 static int lookup1_values ( int entries , int dim ) { int r = ( int ) floor ( exp ( ( float ) log ( ( float ) entries ) / dim ) ) ; if ( ( int ) floor ( pow ( ( float ) r + 1 , dim ) ) <= entries ) ++ r ; <S2SV_StartBug> assert ( pow ( ( float ) r + 1 , dim ) > entries ) ; <S2SV_EndBug> <S2SV_StartBug> assert ( ( int ) floor ( pow ( ( float ) r , dim ) ) <= entries ) ; <S2SV_EndBug> return r ; }
CWE-119 static int start_decoder ( vorb * f ) { uint8 header [ 6 ] , x , y ; int len , i , j , k , max_submaps = 0 ; int longest_floorlist = 0 ; if ( ! start_page ( f ) ) return FALSE ; if ( ! ( f -> page_flag & PAGEFLAG_first_page ) ) return error ( f , VORBIS_invalid_first_page ) ; if ( f -> page_flag & PAGEFLAG_last_page ) return error ( f , VORBIS_invalid_first_page ) ; if ( f -> page_flag & PAGEFLAG_continued_packet ) return error ( f , VORBIS_invalid_first_page ) ; if ( f -> segment_count != 1 ) return error ( f , VORBIS_invalid_first_page ) ; if ( f -> segments [ 0 ] != 30 ) { if ( f -> segments [ 0 ] == 64 && getn ( f , header , 6 ) && header [ 0 ] == 'f' && header [ 1 ] == 'i' && header [ 2 ] == 's' && header [ 3 ] == 'h' && header [ 4 ] == 'e' && header [ 5 ] == 'a' && get8 ( f ) == 'd' && get8 ( f ) == '\\0' ) return error ( f , VORBIS_ogg_skeleton_not_supported ) ; else return error ( f , VORBIS_invalid_first_page ) ; } if ( get8 ( f ) != VORBIS_packet_id ) return error ( f , VORBIS_invalid_first_page ) ; if ( ! getn ( f , header , 6 ) ) return error ( f , VORBIS_unexpected_eof ) ; if ( ! vorbis_validate ( header ) ) return error ( f , VORBIS_invalid_first_page ) ; if ( get32 ( f ) != 0 ) return error ( f , VORBIS_invalid_first_page ) ; f -> channels = get8 ( f ) ; if ( ! f -> channels ) return error ( f , VORBIS_invalid_first_page ) ; if ( f -> channels > STB_VORBIS_MAX_CHANNELS ) return error ( f , VORBIS_too_many_channels ) ; f -> sample_rate = get32 ( f ) ; if ( ! f -> sample_rate ) return error ( f , VORBIS_invalid_first_page ) ; get32 ( f ) ; get32 ( f ) ; get32 ( f ) ; x = get8 ( f ) ; { int log0 , log1 ; log0 = x & 15 ; log1 = x >> 4 ; f -> blocksize_0 = 1 << log0 ; f -> blocksize_1 = 1 << log1 ; if ( log0 < 6 || log0 > 13 ) return error ( f , VORBIS_invalid_setup ) ; if ( log1 < 6 || log1 > 13 ) return error ( f , VORBIS_invalid_setup ) ; if ( log0 > log1 ) return error ( f , VORBIS_invalid_setup ) ; } x = get8 ( f ) ; if ( ! ( x & 1 ) ) return error ( f , VORBIS_invalid_first_page ) ; if ( ! start_page ( f ) ) return FALSE ; if ( ! start_packet ( f ) ) return FALSE ; do { len = next_segment ( f ) ; skip ( f , len ) ; f -> bytes_in_seg = 0 ; } while ( len ) ; if ( ! start_packet ( f ) ) return FALSE ; # ifndef STB_VORBIS_NO_PUSHDATA_API if ( IS_PUSH_MODE ( f ) ) { if ( ! is_whole_packet_present ( f , TRUE ) ) { if ( f -> error == VORBIS_invalid_stream ) f -> error = VORBIS_invalid_setup ; return FALSE ; } } # endif crc32_init ( ) ; if ( get8_packet ( f ) != VORBIS_packet_setup ) return error ( f , VORBIS_invalid_setup ) ; for ( i = 0 ; i < 6 ; ++ i ) header [ i ] = get8_packet ( f ) ; if ( ! vorbis_validate ( header ) ) return error ( f , VORBIS_invalid_setup ) ; f -> codebook_count = get_bits ( f , 8 ) + 1 ; f -> codebooks = ( Codebook * ) setup_malloc ( f , sizeof ( * f -> codebooks ) * f -> codebook_count ) ; if ( f -> codebooks == NULL ) return error ( f , VORBIS_outofmem ) ; memset ( f -> codebooks , 0 , sizeof ( * f -> codebooks ) * f -> codebook_count ) ; for ( i = 0 ; i < f -> codebook_count ; ++ i ) { uint32 * values ; int ordered , sorted_count ; int total = 0 ; uint8 * lengths ; Codebook * c = f -> codebooks + i ; CHECK ( f ) ; x = get_bits ( f , 8 ) ; if ( x != 0x42 ) return error ( f , VORBIS_invalid_setup ) ; x = get_bits ( f , 8 ) ; if ( x != 0x43 ) return error ( f , VORBIS_invalid_setup ) ; x = get_bits ( f , 8 ) ; if ( x != 0x56 ) return error ( f , VORBIS_invalid_setup ) ; x = get_bits ( f , 8 ) ; c -> dimensions = ( get_bits ( f , 8 ) << 8 ) + x ; x = get_bits ( f , 8 ) ; y = get_bits ( f , 8 ) ; c -> entries = ( get_bits ( f , 8 ) << 16 ) + ( y << 8 ) + x ; ordered = get_bits ( f , 1 ) ; c -> sparse = ordered ? 0 : get_bits ( f , 1 ) ; if ( c -> dimensions == 0 && c -> entries != 0 ) return error ( f , VORBIS_invalid_setup ) ; if ( c -> sparse ) lengths = ( uint8 * ) setup_temp_malloc ( f , c -> entries ) ; else lengths = c -> codeword_lengths = ( uint8 * ) setup_malloc ( f , c -> entries ) ; if ( ! lengths ) return error ( f , VORBIS_outofmem ) ; if ( ordered ) { int current_entry = 0 ; int current_length = get_bits ( f , 5 ) + 1 ; while ( current_entry < c -> entries ) { int limit = c -> entries - current_entry ; int n = get_bits ( f , ilog ( limit ) ) ; <S2SV_StartBug> if ( current_entry + n > ( int ) c -> entries ) { return error ( f , VORBIS_invalid_setup ) ; } <S2SV_EndBug> memset ( lengths + current_entry , current_length , n ) ; current_entry += n ; ++ current_length ; } } else { for ( j = 0 ; j < c -> entries ; ++ j ) { int present = c -> sparse ? get_bits ( f , 1 ) : 1 ; if ( present ) { lengths [ j ] = get_bits ( f , 5 ) + 1 ; ++ total ; if ( lengths [ j ] == 32 ) return error ( f , VORBIS_invalid_setup ) ; } else { lengths [ j ] = NO_CODE ; } } } if ( c -> sparse && total >= c -> entries >> 2 ) { if ( c -> entries > ( int ) f -> setup_temp_memory_required ) f -> setup_temp_memory_required = c -> entries ; c -> codeword_lengths = ( uint8 * ) setup_malloc ( f , c -> entries ) ; if ( c -> codeword_lengths == NULL ) return error ( f , VORBIS_outofmem ) ; memcpy ( c -> codeword_lengths , lengths , c -> entries ) ; setup_temp_free ( f , lengths , c -> entries ) ; lengths = c -> codeword_lengths ; c -> sparse = 0 ; } if ( c -> sparse ) { sorted_count = total ; } else { sorted_count = 0 ; # ifndef STB_VORBIS_NO_HUFFMAN_BINARY_SEARCH for ( j = 0 ; j < c -> entries ; ++ j ) if ( lengths [ j ] > STB_VORBIS_FAST_HUFFMAN_LENGTH && lengths [ j ] != NO_CODE ) ++ sorted_count ; # endif } c -> sorted_entries = sorted_count ; values = NULL ; CHECK ( f ) ; if ( ! c -> sparse ) { c -> codewords = ( uint32 * ) setup_malloc ( f , sizeof ( c -> codewords [ 0 ] ) * c -> entries ) ; if ( ! c -> codewords ) return error ( f , VORBIS_outofmem ) ; } else { unsigned int size ; if ( c -> sorted_entries ) { c -> codeword_lengths = ( uint8 * ) setup_malloc ( f , c -> sorted_entries ) ; if ( ! c -> codeword_lengths ) return error ( f , VORBIS_outofmem ) ; c -> codewords = ( uint32 * ) setup_temp_malloc ( f , sizeof ( * c -> codewords ) * c -> sorted_entries ) ; if ( ! c -> codewords ) return error ( f , VORBIS_outofmem ) ; values = ( uint32 * ) setup_temp_malloc ( f , sizeof ( * values ) * c -> sorted_entries ) ; if ( ! values ) return error ( f , VORBIS_outofmem ) ; } size = c -> entries + ( sizeof ( * c -> codewords ) + sizeof ( * values ) ) * c -> sorted_entries ; if ( size > f -> setup_temp_memory_required ) f -> setup_temp_memory_required = size ; } if ( ! compute_codewords ( c , lengths , c -> entries , values ) ) { if ( c -> sparse ) setup_temp_free ( f , values , 0 ) ; return error ( f , VORBIS_invalid_setup ) ; } if ( c -> sorted_entries ) { c -> sorted_codewords = ( uint32 * ) setup_malloc ( f , sizeof ( * c -> sorted_codewords ) * ( c -> sorted_entries + 1 ) ) ; if ( c -> sorted_codewords == NULL ) return error ( f , VORBIS_outofmem ) ; c -> sorted_values = ( int * ) setup_malloc ( f , sizeof ( * c -> sorted_values ) * ( c -> sorted_entries + 1 ) ) ; if ( c -> sorted_values == NULL ) return error ( f , VORBIS_outofmem ) ; ++ c -> sorted_values ; c -> sorted_values [ - 1 ] = - 1 ; compute_sorted_huffman ( c , lengths , values ) ; } if ( c -> sparse ) { setup_temp_free ( f , values , sizeof ( * values ) * c -> sorted_entries ) ; setup_temp_free ( f , c -> codewords , sizeof ( * c -> codewords ) * c -> sorted_entries ) ; setup_temp_free ( f , lengths , c -> entries ) ; c -> codewords = NULL ; } compute_accelerated_huffman ( c ) ; CHECK ( f ) ; c -> lookup_type = get_bits ( f , 4 ) ; if ( c -> lookup_type > 2 ) return error ( f , VORBIS_invalid_setup ) ; if ( c -> lookup_type > 0 ) { uint16 * mults ; c -> minimum_value = float32_unpack ( get_bits ( f , 32 ) ) ; c -> delta_value = float32_unpack ( get_bits ( f , 32 ) ) ; c -> value_bits = get_bits ( f , 4 ) + 1 ; c -> sequence_p = get_bits ( f , 1 ) ; if ( c -> lookup_type == 1 ) { <S2SV_StartBug> c -> lookup_values = lookup1_values ( c -> entries , c -> dimensions ) ; <S2SV_EndBug> } else { c -> lookup_values = c -> entries * c -> dimensions ; } if ( c -> lookup_values == 0 ) return error ( f , VORBIS_invalid_setup ) ; mults = ( uint16 * ) setup_temp_malloc ( f , sizeof ( mults [ 0 ] ) * c -> lookup_values ) ; if ( mults == NULL ) return error ( f , VORBIS_outofmem ) ; for ( j = 0 ; j < ( int ) c -> lookup_values ; ++ j ) { int q = get_bits ( f , c -> value_bits ) ; if ( q == EOP ) { setup_temp_free ( f , mults , sizeof ( mults [ 0 ] ) * c -> lookup_values ) ; return error ( f , VORBIS_invalid_setup ) ; } mults [ j ] = q ; } # ifndef STB_VORBIS_DIVIDES_IN_CODEBOOK if ( c -> lookup_type == 1 ) { int len , sparse = c -> sparse ; float last = 0 ; if ( sparse ) { if ( c -> sorted_entries == 0 ) goto skip ; c -> multiplicands = ( codetype * ) setup_malloc ( f , sizeof ( c -> multiplicands [ 0 ] ) * c -> sorted_entries * c -> dimensions ) ; } else c -> multiplicands = ( codetype * ) setup_malloc ( f , sizeof ( c -> multiplicands [ 0 ] ) * c -> entries * c -> dimensions ) ; if ( c -> multiplicands == NULL ) { setup_temp_free ( f , mults , sizeof ( mults [ 0 ] ) * c -> lookup_values ) ; return error ( f , VORBIS_outofmem ) ; } len = sparse ? c -> sorted_entries : c -> entries ; for ( j = 0 ; j < len ; ++ j ) { unsigned int z = sparse ? c -> sorted_values [ j ] : j ; unsigned int div = 1 ; for ( k = 0 ; k < c -> dimensions ; ++ k ) { int off = ( z / div ) % c -> lookup_values ; float val = mults [ off ] ; val = mults [ off ] * c -> delta_value + c -> minimum_value + last ; c -> multiplicands [ j * c -> dimensions + k ] = val ; if ( c -> sequence_p ) last = val ; if ( k + 1 < c -> dimensions ) { if ( div > UINT_MAX / ( unsigned int ) c -> lookup_values ) { setup_temp_free ( f , mults , sizeof ( mults [ 0 ] ) * c -> lookup_values ) ; return error ( f , VORBIS_invalid_setup ) ; } div *= c -> lookup_values ; } } } c -> lookup_type = 2 ; } else # endif { float last = 0 ; CHECK ( f ) ; c -> multiplicands = ( codetype * ) setup_malloc ( f , sizeof ( c -> multiplicands [ 0 ] ) * c -> lookup_values ) ; if ( c -> multiplicands == NULL ) { setup_temp_free ( f , mults , sizeof ( mults [ 0 ] ) * c -> lookup_values ) ; return error ( f , VORBIS_outofmem ) ; } for ( j = 0 ; j < ( int ) c -> lookup_values ; ++ j ) { float val = mults [ j ] * c -> delta_value + c -> minimum_value + last ; c -> multiplicands [ j ] = val ; if ( c -> sequence_p ) last = val ; } } # ifndef STB_VORBIS_DIVIDES_IN_CODEBOOK skip : ; # endif setup_temp_free ( f , mults , sizeof ( mults [ 0 ] ) * c -> lookup_values ) ; CHECK ( f ) ; } CHECK ( f ) ; } x = get_bits ( f , 6 ) + 1 ; for ( i = 0 ; i < x ; ++ i ) { uint32 z = get_bits ( f , 16 ) ; if ( z != 0 ) return error ( f , VORBIS_invalid_setup ) ; } f -> floor_count = get_bits ( f , 6 ) + 1 ; f -> floor_config = ( Floor * ) setup_malloc ( f , f -> floor_count * sizeof ( * f -> floor_config ) ) ; if ( f -> floor_config == NULL ) return error ( f , VORBIS_outofmem ) ; for ( i = 0 ; i < f -> floor_count ; ++ i ) { f -> floor_types [ i ] = get_bits ( f , 16 ) ; if ( f -> floor_types [ i ] > 1 ) return error ( f , VORBIS_invalid_setup ) ; if ( f -> floor_types [ i ] == 0 ) { Floor0 * g = & f -> floor_config [ i ] . floor0 ; g -> order = get_bits ( f , 8 ) ; g -> rate = get_bits ( f , 16 ) ; g -> bark_map_size = get_bits ( f , 16 ) ; g -> amplitude_bits = get_bits ( f , 6 ) ; g -> amplitude_offset = get_bits ( f , 8 ) ; g -> number_of_books = get_bits ( f , 4 ) + 1 ; for ( j = 0 ; j < g -> number_of_books ; ++ j ) g -> book_list [ j ] = get_bits ( f , 8 ) ; return error ( f , VORBIS_feature_not_supported ) ; } else { stbv__floor_ordering p [ 31 * 8 + 2 ] ; Floor1 * g = & f -> floor_config [ i ] . floor1 ; int max_class = - 1 ; g -> partitions = get_bits ( f , 5 ) ; for ( j = 0 ; j < g -> partitions ; ++ j ) { g -> partition_class_list [ j ] = get_bits ( f , 4 ) ; if ( g -> partition_class_list [ j ] > max_class ) max_class = g -> partition_class_list [ j ] ; } for ( j = 0 ; j <= max_class ; ++ j ) { g -> class_dimensions [ j ] = get_bits ( f , 3 ) + 1 ; g -> class_subclasses [ j ] = get_bits ( f , 2 ) ; if ( g -> class_subclasses [ j ] ) { g -> class_masterbooks [ j ] = get_bits ( f , 8 ) ; if ( g -> class_masterbooks [ j ] >= f -> codebook_count ) return error ( f , VORBIS_invalid_setup ) ; } for ( k = 0 ; k < 1 << g -> class_subclasses [ j ] ; ++ k ) { g -> subclass_books [ j ] [ k ] = get_bits ( f , 8 ) - 1 ; if ( g -> subclass_books [ j ] [ k ] >= f -> codebook_count ) return error ( f , VORBIS_invalid_setup ) ; } } g -> floor1_multiplier = get_bits ( f , 2 ) + 1 ; g -> rangebits = get_bits ( f , 4 ) ; g -> Xlist [ 0 ] = 0 ; g -> Xlist [ 1 ] = 1 << g -> rangebits ; g -> values = 2 ; for ( j = 0 ; j < g -> partitions ; ++ j ) { int c = g -> partition_class_list [ j ] ; for ( k = 0 ; k < g -> class_dimensions [ c ] ; ++ k ) { g -> Xlist [ g -> values ] = get_bits ( f , g -> rangebits ) ; ++ g -> values ; } } for ( j = 0 ; j < g -> values ; ++ j ) { p [ j ] . x = g -> Xlist [ j ] ; p [ j ] . id = j ; } qsort ( p , g -> values , sizeof ( p [ 0 ] ) , point_compare ) ; <S2SV_StartBug> for ( j = 0 ; j < g -> values ; ++ j ) <S2SV_EndBug> g -> sorted_order [ j ] = ( uint8 ) p [ j ] . id ; for ( j = 2 ; j < g -> values ; ++ j ) { int low , hi ; neighbors ( g -> Xlist , j , & low , & hi ) ; g -> neighbors [ j ] [ 0 ] = low ; g -> neighbors [ j ] [ 1 ] = hi ; } if ( g -> values > longest_floorlist ) longest_floorlist = g -> values ; } } f -> residue_count = get_bits ( f , 6 ) + 1 ; f -> residue_config = ( Residue * ) setup_malloc ( f , f -> residue_count * sizeof ( f -> residue_config [ 0 ] ) ) ; if ( f -> residue_config == NULL ) return error ( f , VORBIS_outofmem ) ; memset ( f -> residue_config , 0 , f -> residue_count * sizeof ( f -> residue_config [ 0 ] ) ) ; for ( i = 0 ; i < f -> residue_count ; ++ i ) { uint8 residue_cascade [ 64 ] ; Residue * r = f -> residue_config + i ; f -> residue_types [ i ] = get_bits ( f , 16 ) ; if ( f -> residue_types [ i ] > 2 ) return error ( f , VORBIS_invalid_setup ) ; r -> begin = get_bits ( f , 24 ) ; r -> end = get_bits ( f , 24 ) ; if ( r -> end < r -> begin ) return error ( f , VORBIS_invalid_setup ) ; r -> part_size = get_bits ( f , 24 ) + 1 ; r -> classifications = get_bits ( f , 6 ) + 1 ; r -> classbook = get_bits ( f , 8 ) ; if ( r -> classbook >= f -> codebook_count ) return error ( f , VORBIS_invalid_setup ) ; for ( j = 0 ; j < r -> classifications ; ++ j ) { uint8 high_bits = 0 ; uint8 low_bits = get_bits ( f , 3 ) ; if ( get_bits ( f , 1 ) ) high_bits = get_bits ( f , 5 ) ; residue_cascade [ j ] = high_bits * 8 + low_bits ; } r -> residue_books = ( short ( * ) [ 8 ] ) setup_malloc ( f , sizeof ( r -> residue_books [ 0 ] ) * r -> classifications ) ; if ( r -> residue_books == NULL ) return error ( f , VORBIS_outofmem ) ; for ( j = 0 ; j < r -> classifications ; ++ j ) { for ( k = 0 ; k < 8 ; ++ k ) { if ( residue_cascade [ j ] & ( 1 << k ) ) { r -> residue_books [ j ] [ k ] = get_bits ( f , 8 ) ; if ( r -> residue_books [ j ] [ k ] >= f -> codebook_count ) return error ( f , VORBIS_invalid_setup ) ; } else { r -> residue_books [ j ] [ k ] = - 1 ; } } } r -> classdata = ( uint8 * * ) setup_malloc ( f , sizeof ( * r -> classdata ) * f -> codebooks [ r -> classbook ] . entries ) ; if ( ! r -> classdata ) return error ( f , VORBIS_outofmem ) ; memset ( r -> classdata , 0 , sizeof ( * r -> classdata ) * f -> codebooks [ r -> classbook ] . entries ) ; for ( j = 0 ; j < f -> codebooks [ r -> classbook ] . entries ; ++ j ) { int classwords = f -> codebooks [ r -> classbook ] . dimensions ; int temp = j ; r -> classdata [ j ] = ( uint8 * ) setup_malloc ( f , sizeof ( r -> classdata [ j ] [ 0 ] ) * classwords ) ; if ( r -> classdata [ j ] == NULL ) return error ( f , VORBIS_outofmem ) ; for ( k = classwords - 1 ; k >= 0 ; -- k ) { r -> classdata [ j ] [ k ] = temp % r -> classifications ; temp /= r -> classifications ; } } } f -> mapping_count = get_bits ( f , 6 ) + 1 ; f -> mapping = ( Mapping * ) setup_malloc ( f , f -> mapping_count * sizeof ( * f -> mapping ) ) ; if ( f -> mapping == NULL ) return error ( f , VORBIS_outofmem ) ; memset ( f -> mapping , 0 , f -> mapping_count * sizeof ( * f -> mapping ) ) ; for ( i = 0 ; i < f -> mapping_count ; ++ i ) { Mapping * m = f -> mapping + i ; int mapping_type = get_bits ( f , 16 ) ; if ( mapping_type != 0 ) return error ( f , VORBIS_invalid_setup ) ; m -> chan = ( MappingChannel * ) setup_malloc ( f , f -> channels * sizeof ( * m -> chan ) ) ; if ( m -> chan == NULL ) return error ( f , VORBIS_outofmem ) ; if ( get_bits ( f , 1 ) ) m -> submaps = get_bits ( f , 4 ) + 1 ; else m -> submaps = 1 ; if ( m -> submaps > max_submaps ) max_submaps = m -> submaps ; if ( get_bits ( f , 1 ) ) { <S2SV_StartBug> m -> coupling_steps = get_bits ( f , 8 ) + 1 ; <S2SV_EndBug> for ( k = 0 ; k < m -> coupling_steps ; ++ k ) { m -> chan [ k ] . magnitude = get_bits ( f , ilog ( f -> channels - 1 ) ) ; m -> chan [ k ] . angle = get_bits ( f , ilog ( f -> channels - 1 ) ) ; if ( m -> chan [ k ] . magnitude >= f -> channels ) return error ( f , VORBIS_invalid_setup ) ; if ( m -> chan [ k ] . angle >= f -> channels ) return error ( f , VORBIS_invalid_setup ) ; if ( m -> chan [ k ] . magnitude == m -> chan [ k ] . angle ) return error ( f , VORBIS_invalid_setup ) ; } } else m -> coupling_steps = 0 ; if ( get_bits ( f , 2 ) ) return error ( f , VORBIS_invalid_setup ) ; if ( m -> submaps > 1 ) { for ( j = 0 ; j < f -> channels ; ++ j ) { m -> chan [ j ] . mux = get_bits ( f , 4 ) ; if ( m -> chan [ j ] . mux >= m -> submaps ) return error ( f , VORBIS_invalid_setup ) ; } } else for ( j = 0 ; j < f -> channels ; ++ j ) m -> chan [ j ] . mux = 0 ; for ( j = 0 ; j < m -> submaps ; ++ j ) { get_bits ( f , 8 ) ; m -> submap_floor [ j ] = get_bits ( f , 8 ) ; m -> submap_residue [ j ] = get_bits ( f , 8 ) ; if ( m -> submap_floor [ j ] >= f -> floor_count ) return error ( f , VORBIS_invalid_setup ) ; if ( m -> submap_residue [ j ] >= f -> residue_count ) return error ( f , VORBIS_invalid_setup ) ; } } f -> mode_count = get_bits ( f , 6 ) + 1 ; for ( i = 0 ; i < f -> mode_count ; ++ i ) { Mode * m = f -> mode_config + i ; m -> blockflag = get_bits ( f , 1 ) ; m -> windowtype = get_bits ( f , 16 ) ; m -> transformtype = get_bits ( f , 16 ) ; m -> mapping = get_bits ( f , 8 ) ; if ( m -> windowtype != 0 ) return error ( f , VORBIS_invalid_setup ) ; if ( m -> transformtype != 0 ) return error ( f , VORBIS_invalid_setup ) ; if ( m -> mapping >= f -> mapping_count ) return error ( f , VORBIS_invalid_setup ) ; } flush_packet ( f ) ; f -> previous_length = 0 ; for ( i = 0 ; i < f -> channels ; ++ i ) { f -> channel_buffers [ i ] = ( float * ) setup_malloc ( f , sizeof ( float ) * f -> blocksize_1 ) ; f -> previous_window [ i ] = ( float * ) setup_malloc ( f , sizeof ( float ) * f -> blocksize_1 / 2 ) ; f -> finalY [ i ] = ( int16 * ) setup_malloc ( f , sizeof ( int16 ) * longest_floorlist ) ; if ( f -> channel_buffers [ i ] == NULL || f -> previous_window [ i ] == NULL || f -> finalY [ i ] == NULL ) return error ( f , VORBIS_outofmem ) ; memset ( f -> channel_buffers [ i ] , 0 , sizeof ( float ) * f -> blocksize_1 ) ; # ifdef STB_VORBIS_NO_DEFER_FLOOR f -> floor_buffers [ i ] = ( float * ) setup_malloc ( f , sizeof ( float ) * f -> blocksize_1 / 2 ) ; if ( f -> floor_buffers [ i ] == NULL ) return error ( f , VORBIS_outofmem ) ; # endif } if ( ! init_blocksize ( f , 0 , f -> blocksize_0 ) ) return FALSE ; if ( ! init_blocksize ( f , 1 , f -> blocksize_1 ) ) return FALSE ; f -> blocksize [ 0 ] = f -> blocksize_0 ; f -> blocksize [ 1 ] = f -> blocksize_1 ; # ifdef STB_VORBIS_DIVIDE_TABLE if ( integer_divide_table [ 1 ] [ 1 ] == 0 ) for ( i = 0 ; i < DIVTAB_NUMER ; ++ i ) for ( j = 1 ; j < DIVTAB_DENOM ; ++ j ) integer_divide_table [ i ] [ j ] = i / j ; # endif { uint32 imdct_mem = ( f -> blocksize_1 * sizeof ( float ) >> 1 ) ; uint32 classify_mem ; int i , max_part_read = 0 ; for ( i = 0 ; i < f -> residue_count ; ++ i ) { Residue * r = f -> residue_config + i ; unsigned int actual_size = f -> blocksize_1 / 2 ; unsigned int limit_r_begin = r -> begin < actual_size ? r -> begin : actual_size ; unsigned int limit_r_end = r -> end < actual_size ? r -> end : actual_size ; int n_read = limit_r_end - limit_r_begin ; int part_read = n_read / r -> part_size ; if ( part_read > max_part_read ) max_part_read = part_read ; } # ifndef STB_VORBIS_DIVIDES_IN_RESIDUE classify_mem = f -> channels * ( sizeof ( void * ) + max_part_read * sizeof ( uint8 * ) ) ; # else classify_mem = f -> channels * ( sizeof ( void * ) + max_part_read * sizeof ( int * ) ) ; # endif f -> temp_memory_required = classify_mem ; if ( imdct_mem > f -> temp_memory_required ) f -> temp_memory_required = imdct_mem ; } f -> first_decode = TRUE ; if ( f -> alloc . alloc_buffer ) { assert ( f -> temp_offset == f -> alloc . alloc_buffer_length_in_bytes ) ; if ( f -> setup_offset + sizeof ( * f ) + f -> temp_memory_required > ( unsigned ) f -> temp_offset ) return error ( f , VORBIS_outofmem ) ; } f -> first_audio_page_offset = stb_vorbis_get_file_offset ( f ) ; return TRUE ; }
CWE-119 static int vorbis_finish_frame ( stb_vorbis * f , int len , int left , int right ) { int prev , i , j ; if ( f -> previous_length ) { int i , j , n = f -> previous_length ; <S2SV_StartBug> float * w = get_window ( f , n ) ; <S2SV_EndBug> for ( i = 0 ; i < f -> channels ; ++ i ) { for ( j = 0 ; j < n ; ++ j ) f -> channel_buffers [ i ] [ left + j ] = f -> channel_buffers [ i ] [ left + j ] * w [ j ] + f -> previous_window [ i ] [ j ] * w [ n - 1 - j ] ; } } prev = f -> previous_length ; f -> previous_length = len - right ; for ( i = 0 ; i < f -> channels ; ++ i ) for ( j = 0 ; right + j < len ; ++ j ) f -> previous_window [ i ] [ j ] = f -> channel_buffers [ i ] [ right + j ] ; if ( ! prev ) return 0 ; if ( len < right ) right = len ; f -> samples_output += right - left ; return right - left ; }
CWE-200 static int userauth_hostbased ( struct ssh * ssh ) { Authctxt * authctxt = ssh -> authctxt ; struct sshbuf * b ; struct sshkey * key = NULL ; char * pkalg , * cuser , * chost ; u_char * pkblob , * sig ; size_t alen , blen , slen ; int r , pktype , authenticated = 0 ; <S2SV_StartBug> if ( ! authctxt -> valid ) { <S2SV_EndBug> debug2 ( "%s:<S2SV_blank>disabled<S2SV_blank>because<S2SV_blank>of<S2SV_blank>invalid<S2SV_blank>user" , __func__ ) ; return 0 ; } if ( ( r = sshpkt_get_cstring ( ssh , & pkalg , & alen ) ) != 0 || ( r = sshpkt_get_string ( ssh , & pkblob , & blen ) ) != 0 || ( r = sshpkt_get_cstring ( ssh , & chost , NULL ) ) != 0 || ( r = sshpkt_get_cstring ( ssh , & cuser , NULL ) ) != 0 || ( r = sshpkt_get_string ( ssh , & sig , & slen ) ) != 0 ) fatal ( "%s:<S2SV_blank>packet<S2SV_blank>parsing:<S2SV_blank>%s" , __func__ , ssh_err ( r ) ) ; debug ( "%s:<S2SV_blank>cuser<S2SV_blank>%s<S2SV_blank>chost<S2SV_blank>%s<S2SV_blank>pkalg<S2SV_blank>%s<S2SV_blank>slen<S2SV_blank>%zu" , __func__ , cuser , chost , pkalg , slen ) ; # ifdef DEBUG_PK debug ( "signature:" ) ; sshbuf_dump_data ( sig , siglen , stderr ) ; # endif pktype = sshkey_type_from_name ( pkalg ) ; if ( pktype == KEY_UNSPEC ) { logit ( "%s:<S2SV_blank>unsupported<S2SV_blank>public<S2SV_blank>key<S2SV_blank>algorithm:<S2SV_blank>%s" , __func__ , pkalg ) ; goto done ; } if ( ( r = sshkey_from_blob ( pkblob , blen , & key ) ) != 0 ) { error ( "%s:<S2SV_blank>key_from_blob:<S2SV_blank>%s" , __func__ , ssh_err ( r ) ) ; goto done ; } if ( key == NULL ) { error ( "%s:<S2SV_blank>cannot<S2SV_blank>decode<S2SV_blank>key:<S2SV_blank>%s" , __func__ , pkalg ) ; goto done ; } if ( key -> type != pktype ) { error ( "%s:<S2SV_blank>type<S2SV_blank>mismatch<S2SV_blank>for<S2SV_blank>decoded<S2SV_blank>key<S2SV_blank>" "(received<S2SV_blank>%d,<S2SV_blank>expected<S2SV_blank>%d)" , __func__ , key -> type , pktype ) ; goto done ; } if ( sshkey_type_plain ( key -> type ) == KEY_RSA && ( ssh -> compat & SSH_BUG_RSASIGMD5 ) != 0 ) { error ( "Refusing<S2SV_blank>RSA<S2SV_blank>key<S2SV_blank>because<S2SV_blank>peer<S2SV_blank>uses<S2SV_blank>unsafe<S2SV_blank>" "signature<S2SV_blank>format" ) ; goto done ; } if ( match_pattern_list ( pkalg , options . hostbased_key_types , 0 ) != 1 ) { logit ( "%s:<S2SV_blank>key<S2SV_blank>type<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>in<S2SV_blank>HostbasedAcceptedKeyTypes" , __func__ , sshkey_type ( key ) ) ; goto done ; } <S2SV_StartBug> if ( ( b = sshbuf_new ( ) ) == NULL ) <S2SV_EndBug> fatal ( "%s:<S2SV_blank>sshbuf_new<S2SV_blank>failed" , __func__ ) ; if ( ( r = sshbuf_put_string ( b , session_id2 , session_id2_len ) ) != 0 || ( r = sshbuf_put_u8 ( b , SSH2_MSG_USERAUTH_REQUEST ) ) != 0 || ( r = sshbuf_put_cstring ( b , authctxt -> user ) ) != 0 || ( r = sshbuf_put_cstring ( b , authctxt -> service ) ) != 0 || ( r = sshbuf_put_cstring ( b , "hostbased" ) ) != 0 || ( r = sshbuf_put_string ( b , pkalg , alen ) ) != 0 || ( r = sshbuf_put_string ( b , pkblob , blen ) ) != 0 || ( r = sshbuf_put_cstring ( b , chost ) ) != 0 || ( r = sshbuf_put_cstring ( b , cuser ) ) != 0 ) fatal ( "%s:<S2SV_blank>buffer<S2SV_blank>error:<S2SV_blank>%s" , __func__ , ssh_err ( r ) ) ; # ifdef DEBUG_PK sshbuf_dump ( b , stderr ) ; # endif auth2_record_info ( authctxt , "client<S2SV_blank>user<S2SV_blank>\\"%.100s\\",<S2SV_blank>client<S2SV_blank>host<S2SV_blank>\\"%.100s\\"" , cuser , chost ) ; authenticated = 0 ; if ( PRIVSEP ( hostbased_key_allowed ( authctxt -> pw , cuser , chost , key ) ) && PRIVSEP ( sshkey_verify ( key , sig , slen , sshbuf_ptr ( b ) , sshbuf_len ( b ) , pkalg , ssh -> compat ) ) == 0 ) authenticated = 1 ; auth2_record_key ( authctxt , authenticated , key ) ; sshbuf_free ( b ) ; done : debug2 ( "%s:<S2SV_blank>authenticated<S2SV_blank>%d" , __func__ , authenticated ) ; sshkey_free ( key ) ; free ( pkalg ) ; free ( pkblob ) ; free ( cuser ) ; free ( chost ) ; free ( sig ) ; return authenticated ; }
CWE-200 static int userauth_pubkey ( struct ssh * ssh ) { Authctxt * authctxt = ssh -> authctxt ; struct passwd * pw = authctxt -> pw ; <S2SV_StartBug> struct sshbuf * b ; <S2SV_EndBug> struct sshkey * key = NULL ; <S2SV_StartBug> char * pkalg , * userstyle = NULL , * key_s = NULL , * ca_s = NULL ; <S2SV_EndBug> <S2SV_StartBug> u_char * pkblob , * sig , have_sig ; <S2SV_EndBug> size_t blen , slen ; int r , pktype ; int authenticated = 0 ; struct sshauthopt * authopts = NULL ; <S2SV_StartBug> if ( ! authctxt -> valid ) { <S2SV_EndBug> debug2 ( "%s:<S2SV_blank>disabled<S2SV_blank>because<S2SV_blank>of<S2SV_blank>invalid<S2SV_blank>user" , __func__ ) ; return 0 ; } if ( ( r = sshpkt_get_u8 ( ssh , & have_sig ) ) != 0 || ( r = sshpkt_get_cstring ( ssh , & pkalg , NULL ) ) != 0 || ( r = sshpkt_get_string ( ssh , & pkblob , & blen ) ) != 0 ) fatal ( "%s:<S2SV_blank>parse<S2SV_blank>request<S2SV_blank>failed:<S2SV_blank>%s" , __func__ , ssh_err ( r ) ) ; pktype = sshkey_type_from_name ( pkalg ) ; if ( pktype == KEY_UNSPEC ) { verbose ( "%s:<S2SV_blank>unsupported<S2SV_blank>public<S2SV_blank>key<S2SV_blank>algorithm:<S2SV_blank>%s" , __func__ , pkalg ) ; goto done ; } if ( ( r = sshkey_from_blob ( pkblob , blen , & key ) ) != 0 ) { error ( "%s:<S2SV_blank>could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>key:<S2SV_blank>%s" , __func__ , ssh_err ( r ) ) ; goto done ; } if ( key == NULL ) { error ( "%s:<S2SV_blank>cannot<S2SV_blank>decode<S2SV_blank>key:<S2SV_blank>%s" , __func__ , pkalg ) ; goto done ; } if ( key -> type != pktype ) { error ( "%s:<S2SV_blank>type<S2SV_blank>mismatch<S2SV_blank>for<S2SV_blank>decoded<S2SV_blank>key<S2SV_blank>" "(received<S2SV_blank>%d,<S2SV_blank>expected<S2SV_blank>%d)" , __func__ , key -> type , pktype ) ; goto done ; } if ( sshkey_type_plain ( key -> type ) == KEY_RSA && ( ssh -> compat & SSH_BUG_RSASIGMD5 ) != 0 ) { logit ( "Refusing<S2SV_blank>RSA<S2SV_blank>key<S2SV_blank>because<S2SV_blank>client<S2SV_blank>uses<S2SV_blank>unsafe<S2SV_blank>" "signature<S2SV_blank>scheme" ) ; goto done ; } if ( auth2_key_already_used ( authctxt , key ) ) { logit ( "refusing<S2SV_blank>previously-used<S2SV_blank>%s<S2SV_blank>key" , sshkey_type ( key ) ) ; goto done ; } if ( match_pattern_list ( pkalg , options . pubkey_key_types , 0 ) != 1 ) { logit ( "%s:<S2SV_blank>key<S2SV_blank>type<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>in<S2SV_blank>PubkeyAcceptedKeyTypes" , __func__ , sshkey_ssh_name ( key ) ) ; goto done ; } key_s = format_key ( key ) ; if ( sshkey_is_cert ( key ) ) ca_s = format_key ( key -> cert -> signature_key ) ; if ( have_sig ) { debug3 ( "%s:<S2SV_blank>have<S2SV_blank>%s<S2SV_blank>signature<S2SV_blank>for<S2SV_blank>%s%s%s" , __func__ , pkalg , key_s , ca_s == NULL ? "" : "<S2SV_blank>CA<S2SV_blank>" , ca_s == NULL ? "" : ca_s ) ; if ( ( r = sshpkt_get_string ( ssh , & sig , & slen ) ) != 0 || ( r = sshpkt_get_end ( ssh ) ) != 0 ) fatal ( "%s:<S2SV_blank>%s" , __func__ , ssh_err ( r ) ) ; if ( ( b = sshbuf_new ( ) ) == NULL ) fatal ( "%s:<S2SV_blank>sshbuf_new<S2SV_blank>failed" , __func__ ) ; if ( ssh -> compat & SSH_OLD_SESSIONID ) { if ( ( r = sshbuf_put ( b , session_id2 , session_id2_len ) ) != 0 ) fatal ( "%s:<S2SV_blank>sshbuf_put<S2SV_blank>session<S2SV_blank>id:<S2SV_blank>%s" , __func__ , ssh_err ( r ) ) ; } else { if ( ( r = sshbuf_put_string ( b , session_id2 , session_id2_len ) ) != 0 ) fatal ( "%s:<S2SV_blank>sshbuf_put_string<S2SV_blank>session<S2SV_blank>id:<S2SV_blank>%s" , <S2SV_StartBug> __func__ , ssh_err ( r ) ) ; <S2SV_EndBug> } xasprintf ( & userstyle , "%s%s%s" , authctxt -> user , authctxt -> style ? ":" : "" , authctxt -> style ? authctxt -> style : "" ) ; if ( ( r = sshbuf_put_u8 ( b , SSH2_MSG_USERAUTH_REQUEST ) ) != 0 || ( r = sshbuf_put_cstring ( b , userstyle ) ) != 0 || ( r = sshbuf_put_cstring ( b , authctxt -> service ) ) != 0 || ( r = sshbuf_put_cstring ( b , "publickey" ) ) != 0 || ( r = sshbuf_put_u8 ( b , have_sig ) ) != 0 || ( r = sshbuf_put_cstring ( b , pkalg ) != 0 ) || ( r = sshbuf_put_string ( b , pkblob , blen ) ) != 0 ) fatal ( "%s:<S2SV_blank>build<S2SV_blank>packet<S2SV_blank>failed:<S2SV_blank>%s" , __func__ , ssh_err ( r ) ) ; # ifdef DEBUG_PK sshbuf_dump ( b , stderr ) ; # endif authenticated = 0 ; if ( PRIVSEP ( user_key_allowed ( ssh , pw , key , 1 , & authopts ) ) && PRIVSEP ( sshkey_verify ( key , sig , slen , sshbuf_ptr ( b ) , sshbuf_len ( b ) , ( ssh -> compat & SSH_BUG_SIGTYPE ) == 0 ? pkalg : NULL , ssh -> compat ) ) == 0 ) { authenticated = 1 ; } sshbuf_free ( b ) ; <S2SV_StartBug> free ( sig ) ; <S2SV_EndBug> auth2_record_key ( authctxt , authenticated , key ) ; } else { debug ( "%s:<S2SV_blank>test<S2SV_blank>pkalg<S2SV_blank>%s<S2SV_blank>pkblob<S2SV_blank>%s%s%s" , __func__ , pkalg , key_s , ca_s == NULL ? "" : "<S2SV_blank>CA<S2SV_blank>" , ca_s == NULL ? "" : ca_s ) ; if ( ( r = sshpkt_get_end ( ssh ) ) != 0 ) <S2SV_StartBug> fatal ( "%s:<S2SV_blank>%s" , __func__ , ssh_err ( r ) ) ; <S2SV_EndBug> if ( PRIVSEP ( user_key_allowed ( ssh , pw , key , 0 , NULL ) ) ) { if ( ( r = sshpkt_start ( ssh , SSH2_MSG_USERAUTH_PK_OK ) ) != 0 || ( r = sshpkt_put_cstring ( ssh , pkalg ) ) != 0 || ( r = sshpkt_put_string ( ssh , pkblob , blen ) ) != 0 || ( r = sshpkt_send ( ssh ) ) != 0 || ( r = ssh_packet_write_wait ( ssh ) ) != 0 ) fatal ( "%s:<S2SV_blank>%s" , __func__ , ssh_err ( r ) ) ; authctxt -> postponed = 1 ; } } done : if ( authenticated == 1 && auth_activate_options ( ssh , authopts ) != 0 ) { debug ( "%s:<S2SV_blank>key<S2SV_blank>options<S2SV_blank>inconsistent<S2SV_blank>with<S2SV_blank>existing" , __func__ ) ; authenticated = 0 ; } debug2 ( "%s:<S2SV_blank>authenticated<S2SV_blank>%d<S2SV_blank>pkalg<S2SV_blank>%s" , __func__ , authenticated , pkalg ) ; sshauthopt_free ( authopts ) ; sshkey_free ( key ) ; free ( userstyle ) ; free ( pkalg ) ; free ( pkblob ) ; free ( key_s ) ; free ( ca_s ) ; <S2SV_StartBug> return authenticated ; <S2SV_EndBug> }
CWE-20 void tcp_sack_option ( struct tcpcb * tp , struct tcphdr * th , u_char * cp , int optlen ) { int tmp_olen ; u_char * tmp_cp ; struct sackhole * cur , * p , * temp ; if ( ! tp -> sack_enable ) return ; if ( ( th -> th_flags & TH_ACK ) == 0 ) return ; if ( SEQ_LT ( th -> th_ack , tp -> snd_una ) || SEQ_GT ( th -> th_ack , tp -> snd_max ) ) return ; if ( optlen <= 2 || ( optlen - 2 ) % TCPOLEN_SACK != 0 ) return ; tmp_cp = cp + 2 ; tmp_olen = optlen - 2 ; tcpstat_inc ( tcps_sack_rcv_opts ) ; if ( tp -> snd_numholes < 0 ) tp -> snd_numholes = 0 ; if ( tp -> t_maxseg == 0 ) panic ( "tcp_sack_option" ) ; while ( tmp_olen > 0 ) { struct sackblk sack ; memcpy ( & sack . start , tmp_cp , sizeof ( tcp_seq ) ) ; sack . start = ntohl ( sack . start ) ; memcpy ( & sack . end , tmp_cp + sizeof ( tcp_seq ) , sizeof ( tcp_seq ) ) ; sack . end = ntohl ( sack . end ) ; tmp_olen -= TCPOLEN_SACK ; tmp_cp += TCPOLEN_SACK ; if ( SEQ_LEQ ( sack . end , sack . start ) ) continue ; if ( SEQ_LEQ ( sack . end , tp -> snd_una ) ) continue ; if ( SEQ_GT ( th -> th_ack , tp -> snd_una ) ) { if ( SEQ_LT ( sack . start , th -> th_ack ) ) continue ; } if ( SEQ_GT ( sack . end , tp -> snd_max ) ) continue ; if ( tp -> snd_holes == NULL ) { tp -> snd_holes = ( struct sackhole * ) pool_get ( & sackhl_pool , PR_NOWAIT ) ; if ( tp -> snd_holes == NULL ) { goto done ; } cur = tp -> snd_holes ; cur -> start = th -> th_ack ; cur -> end = sack . start ; cur -> rxmit = cur -> start ; cur -> next = NULL ; tp -> snd_numholes = 1 ; tp -> rcv_lastsack = sack . end ; cur -> dups = min ( tcprexmtthresh , ( ( sack . end - cur -> end ) / tp -> t_maxseg ) ) ; if ( cur -> dups < 1 ) cur -> dups = 1 ; continue ; } p = cur = tp -> snd_holes ; while ( cur ) { if ( SEQ_LEQ ( sack . end , cur -> start ) ) break ; if ( SEQ_GEQ ( sack . start , cur -> end ) ) { cur -> dups ++ ; if ( ( ( sack . end - cur -> end ) / tp -> t_maxseg ) >= tcprexmtthresh ) cur -> dups = tcprexmtthresh ; p = cur ; cur = cur -> next ; continue ; } if ( SEQ_LEQ ( sack . start , cur -> start ) ) { if ( SEQ_GEQ ( sack . end , cur -> end ) ) { if ( p != cur ) { p -> next = cur -> next ; pool_put ( & sackhl_pool , cur ) ; cur = p -> next ; } else { cur = cur -> next ; pool_put ( & sackhl_pool , p ) ; p = cur ; tp -> snd_holes = p ; } tp -> snd_numholes -- ; continue ; } cur -> start = sack . end ; cur -> rxmit = SEQ_MAX ( cur -> rxmit , cur -> start ) ; p = cur ; cur = cur -> next ; continue ; } if ( SEQ_GEQ ( sack . end , cur -> end ) ) { cur -> end = sack . start ; cur -> rxmit = SEQ_MIN ( cur -> rxmit , cur -> end ) ; cur -> dups ++ ; if ( ( ( sack . end - cur -> end ) / tp -> t_maxseg ) >= tcprexmtthresh ) cur -> dups = tcprexmtthresh ; p = cur ; cur = cur -> next ; continue ; } if ( SEQ_LT ( cur -> start , sack . start ) && SEQ_GT ( cur -> end , sack . end ) ) { <S2SV_StartBug> temp = ( struct sackhole * ) <S2SV_EndBug> pool_get ( & sackhl_pool , PR_NOWAIT ) ; if ( temp == NULL ) goto done ; temp -> next = cur -> next ; temp -> start = sack . end ; temp -> end = cur -> end ; temp -> dups = cur -> dups ; temp -> rxmit = SEQ_MAX ( cur -> rxmit , temp -> start ) ; cur -> end = sack . start ; cur -> rxmit = SEQ_MIN ( cur -> rxmit , cur -> end ) ; cur -> dups ++ ; if ( ( ( sack . end - cur -> end ) / tp -> t_maxseg ) >= tcprexmtthresh ) cur -> dups = tcprexmtthresh ; cur -> next = temp ; p = temp ; cur = p -> next ; tp -> snd_numholes ++ ; } } if ( SEQ_LT ( tp -> rcv_lastsack , sack . start ) ) { <S2SV_StartBug> temp = ( struct sackhole * ) <S2SV_EndBug> pool_get ( & sackhl_pool , PR_NOWAIT ) ; if ( temp == NULL ) goto done ; temp -> start = tp -> rcv_lastsack ; temp -> end = sack . start ; temp -> dups = min ( tcprexmtthresh , ( ( sack . end - sack . start ) / tp -> t_maxseg ) ) ; if ( temp -> dups < 1 ) temp -> dups = 1 ; temp -> rxmit = temp -> start ; temp -> next = 0 ; p -> next = temp ; tp -> rcv_lastsack = sack . end ; tp -> snd_numholes ++ ; } } done : return ; }
CWE-706 void sink ( int argc , char * * argv ) { static BUF buffer ; struct stat stb ; enum { YES , NO , DISPLAYED } wrerr ; BUF * bp ; off_t i ; size_t j , count ; int amt , exists , first , ofd ; mode_t mode , omode , mask ; off_t size , statbytes ; unsigned long long ull ; int setimes , targisdir , wrerrno = 0 ; char ch , * cp , * np , * targ , * why , * vect [ 1 ] , buf [ 2048 ] , visbuf [ 2048 ] ; struct timeval tv [ 2 ] ; # define atime tv [ 0 ] # define mtime tv [ 1 ] # define SCREWUP ( str ) { why = str ; goto screwup ; } if ( TYPE_OVERFLOW ( time_t , 0 ) || TYPE_OVERFLOW ( off_t , 0 ) ) SCREWUP ( "Unexpected<S2SV_blank>off_t/time_t<S2SV_blank>size" ) ; setimes = targisdir = 0 ; mask = umask ( 0 ) ; if ( ! pflag ) ( void ) umask ( mask ) ; if ( argc != 1 ) { run_err ( "ambiguous<S2SV_blank>target" ) ; exit ( 1 ) ; } targ = * argv ; if ( targetshouldbedirectory ) verifydir ( targ ) ; ( void ) atomicio ( vwrite , remout , "" , 1 ) ; if ( stat ( targ , & stb ) == 0 && S_ISDIR ( stb . st_mode ) ) targisdir = 1 ; for ( first = 1 ; ; first = 0 ) { cp = buf ; if ( atomicio ( read , remin , cp , 1 ) != 1 ) return ; if ( * cp ++ == '\\n' ) SCREWUP ( "unexpected<S2SV_blank><newline>" ) ; do { if ( atomicio ( read , remin , & ch , sizeof ( ch ) ) != sizeof ( ch ) ) SCREWUP ( "lost<S2SV_blank>connection" ) ; * cp ++ = ch ; } while ( cp < & buf [ sizeof ( buf ) - 1 ] && ch != '\\n' ) ; * cp = 0 ; if ( verbose_mode ) fmprintf ( stderr , "Sink:<S2SV_blank>%s" , buf ) ; if ( buf [ 0 ] == '\\01' || buf [ 0 ] == '\\02' ) { if ( iamremote == 0 ) { ( void ) snmprintf ( visbuf , sizeof ( visbuf ) , NULL , "%s" , buf + 1 ) ; ( void ) atomicio ( vwrite , STDERR_FILENO , visbuf , strlen ( visbuf ) ) ; } if ( buf [ 0 ] == '\\02' ) exit ( 1 ) ; ++ errs ; continue ; } if ( buf [ 0 ] == 'E' ) { ( void ) atomicio ( vwrite , remout , "" , 1 ) ; return ; } if ( ch == '\\n' ) * -- cp = 0 ; cp = buf ; if ( * cp == 'T' ) { setimes ++ ; cp ++ ; if ( ! isdigit ( ( unsigned char ) * cp ) ) SCREWUP ( "mtime.sec<S2SV_blank>not<S2SV_blank>present" ) ; ull = strtoull ( cp , & cp , 10 ) ; if ( ! cp || * cp ++ != '<S2SV_blank>' ) SCREWUP ( "mtime.sec<S2SV_blank>not<S2SV_blank>delimited" ) ; if ( TYPE_OVERFLOW ( time_t , ull ) ) setimes = 0 ; mtime . tv_sec = ull ; mtime . tv_usec = strtol ( cp , & cp , 10 ) ; if ( ! cp || * cp ++ != '<S2SV_blank>' || mtime . tv_usec < 0 || mtime . tv_usec > 999999 ) SCREWUP ( "mtime.usec<S2SV_blank>not<S2SV_blank>delimited" ) ; if ( ! isdigit ( ( unsigned char ) * cp ) ) SCREWUP ( "atime.sec<S2SV_blank>not<S2SV_blank>present" ) ; ull = strtoull ( cp , & cp , 10 ) ; if ( ! cp || * cp ++ != '<S2SV_blank>' ) SCREWUP ( "atime.sec<S2SV_blank>not<S2SV_blank>delimited" ) ; if ( TYPE_OVERFLOW ( time_t , ull ) ) setimes = 0 ; atime . tv_sec = ull ; atime . tv_usec = strtol ( cp , & cp , 10 ) ; if ( ! cp || * cp ++ != '\\0' || atime . tv_usec < 0 || atime . tv_usec > 999999 ) SCREWUP ( "atime.usec<S2SV_blank>not<S2SV_blank>delimited" ) ; ( void ) atomicio ( vwrite , remout , "" , 1 ) ; continue ; } if ( * cp != 'C' && * cp != 'D' ) { if ( first ) { run_err ( "%s" , cp ) ; exit ( 1 ) ; } SCREWUP ( "expected<S2SV_blank>control<S2SV_blank>record" ) ; } mode = 0 ; for ( ++ cp ; cp < buf + 5 ; cp ++ ) { if ( * cp < '0' || * cp > '7' ) SCREWUP ( "bad<S2SV_blank>mode" ) ; mode = ( mode << 3 ) | ( * cp - '0' ) ; } if ( ! pflag ) mode &= ~ mask ; if ( * cp ++ != '<S2SV_blank>' ) SCREWUP ( "mode<S2SV_blank>not<S2SV_blank>delimited" ) ; if ( ! isdigit ( ( unsigned char ) * cp ) ) SCREWUP ( "size<S2SV_blank>not<S2SV_blank>present" ) ; ull = strtoull ( cp , & cp , 10 ) ; if ( ! cp || * cp ++ != '<S2SV_blank>' ) SCREWUP ( "size<S2SV_blank>not<S2SV_blank>delimited" ) ; if ( TYPE_OVERFLOW ( off_t , ull ) ) SCREWUP ( "size<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range" ) ; size = ( off_t ) ull ; <S2SV_StartBug> if ( ( strchr ( cp , '/' ) != NULL ) || ( strcmp ( cp , ".." ) == 0 ) ) { <S2SV_EndBug> run_err ( "error:<S2SV_blank>unexpected<S2SV_blank>filename:<S2SV_blank>%s" , cp ) ; exit ( 1 ) ; } if ( targisdir ) { static char * namebuf ; static size_t cursize ; size_t need ; need = strlen ( targ ) + strlen ( cp ) + 250 ; if ( need > cursize ) { free ( namebuf ) ; namebuf = xmalloc ( need ) ; cursize = need ; } ( void ) snprintf ( namebuf , need , "%s%s%s" , targ , strcmp ( targ , "/" ) ? "/" : "" , cp ) ; np = namebuf ; } else np = targ ; curfile = cp ; exists = stat ( np , & stb ) == 0 ; if ( buf [ 0 ] == 'D' ) { int mod_flag = pflag ; if ( ! iamrecursive ) SCREWUP ( "received<S2SV_blank>directory<S2SV_blank>without<S2SV_blank>-r" ) ; if ( exists ) { if ( ! S_ISDIR ( stb . st_mode ) ) { errno = ENOTDIR ; goto bad ; } if ( pflag ) ( void ) chmod ( np , mode ) ; } else { mod_flag = 1 ; if ( mkdir ( np , mode | S_IRWXU ) < 0 ) goto bad ; } vect [ 0 ] = xstrdup ( np ) ; sink ( 1 , vect ) ; if ( setimes ) { setimes = 0 ; if ( utimes ( vect [ 0 ] , tv ) < 0 ) run_err ( "%s:<S2SV_blank>set<S2SV_blank>times:<S2SV_blank>%s" , vect [ 0 ] , strerror ( errno ) ) ; } if ( mod_flag ) ( void ) chmod ( vect [ 0 ] , mode ) ; free ( vect [ 0 ] ) ; continue ; } omode = mode ; mode |= S_IWUSR ; if ( ( ofd = open ( np , O_WRONLY | O_CREAT , mode ) ) < 0 ) { bad : run_err ( "%s:<S2SV_blank>%s" , np , strerror ( errno ) ) ; continue ; } ( void ) atomicio ( vwrite , remout , "" , 1 ) ; if ( ( bp = allocbuf ( & buffer , ofd , COPY_BUFLEN ) ) == NULL ) { ( void ) close ( ofd ) ; continue ; } cp = bp -> buf ; wrerr = NO ; statbytes = 0 ; if ( showprogress ) start_progress_meter ( curfile , size , & statbytes ) ; set_nonblock ( remin ) ; for ( count = i = 0 ; i < size ; i += bp -> cnt ) { amt = bp -> cnt ; if ( i + amt > size ) amt = size - i ; count += amt ; do { j = atomicio6 ( read , remin , cp , amt , scpio , & statbytes ) ; if ( j == 0 ) { run_err ( "%s" , j != EPIPE ? strerror ( errno ) : "dropped<S2SV_blank>connection" ) ; exit ( 1 ) ; } amt -= j ; cp += j ; } while ( amt > 0 ) ; if ( count == bp -> cnt ) { if ( wrerr == NO ) { if ( atomicio ( vwrite , ofd , bp -> buf , count ) != count ) { wrerr = YES ; wrerrno = errno ; } } count = 0 ; cp = bp -> buf ; } } unset_nonblock ( remin ) ; if ( count != 0 && wrerr == NO && atomicio ( vwrite , ofd , bp -> buf , count ) != count ) { wrerr = YES ; wrerrno = errno ; } if ( wrerr == NO && ( ! exists || S_ISREG ( stb . st_mode ) ) && ftruncate ( ofd , size ) != 0 ) { run_err ( "%s:<S2SV_blank>truncate:<S2SV_blank>%s" , np , strerror ( errno ) ) ; wrerr = DISPLAYED ; } if ( pflag ) { if ( exists || omode != mode ) # ifdef HAVE_FCHMOD if ( fchmod ( ofd , omode ) ) { # else if ( chmod ( np , omode ) ) { # endif run_err ( "%s:<S2SV_blank>set<S2SV_blank>mode:<S2SV_blank>%s" , np , strerror ( errno ) ) ; wrerr = DISPLAYED ; } } else { if ( ! exists && omode != mode ) # ifdef HAVE_FCHMOD if ( fchmod ( ofd , omode & ~ mask ) ) { # else if ( chmod ( np , omode & ~ mask ) ) { # endif run_err ( "%s:<S2SV_blank>set<S2SV_blank>mode:<S2SV_blank>%s" , np , strerror ( errno ) ) ; wrerr = DISPLAYED ; } } if ( close ( ofd ) == - 1 ) { wrerr = YES ; wrerrno = errno ; } ( void ) response ( ) ; if ( showprogress ) stop_progress_meter ( ) ; if ( setimes && wrerr == NO ) { setimes = 0 ; if ( utimes ( np , tv ) < 0 ) { run_err ( "%s:<S2SV_blank>set<S2SV_blank>times:<S2SV_blank>%s" , np , strerror ( errno ) ) ; wrerr = DISPLAYED ; } } switch ( wrerr ) { case YES : run_err ( "%s:<S2SV_blank>%s" , np , strerror ( wrerrno ) ) ; break ; case NO : ( void ) atomicio ( vwrite , remout , "" , 1 ) ; break ; case DISPLAYED : break ; } } screwup : run_err ( "protocol<S2SV_blank>error:<S2SV_blank>%s" , why ) ; exit ( 1 ) ; }
CWE-617 static enum ofperr parse_group_prop_ntr_selection_method ( struct ofpbuf * payload , enum ofp11_group_type group_type , enum ofp15_group_mod_command group_cmd , struct ofputil_group_props * gp ) { struct ntr_group_prop_selection_method * prop = payload -> data ; size_t fields_len , method_len ; enum ofperr error ; switch ( group_type ) { case OFPGT11_SELECT : break ; case OFPGT11_ALL : case OFPGT11_INDIRECT : case OFPGT11_FF : OFPPROP_LOG ( & bad_ofmsg_rl , false , "ntr<S2SV_blank>selection<S2SV_blank>method<S2SV_blank>property<S2SV_blank>is<S2SV_blank>" "only<S2SV_blank>allowed<S2SV_blank>for<S2SV_blank>select<S2SV_blank>groups" ) ; return OFPERR_OFPBPC_BAD_VALUE ; default : <S2SV_StartBug> OVS_NOT_REACHED ( ) ; <S2SV_EndBug> } switch ( group_cmd ) { case OFPGC15_ADD : case OFPGC15_MODIFY : case OFPGC15_ADD_OR_MOD : break ; case OFPGC15_DELETE : case OFPGC15_INSERT_BUCKET : case OFPGC15_REMOVE_BUCKET : OFPPROP_LOG ( & bad_ofmsg_rl , false , "ntr<S2SV_blank>selection<S2SV_blank>method<S2SV_blank>property<S2SV_blank>is<S2SV_blank>" "only<S2SV_blank>allowed<S2SV_blank>for<S2SV_blank>add<S2SV_blank>and<S2SV_blank>delete<S2SV_blank>group<S2SV_blank>modifications" ) ; return OFPERR_OFPBPC_BAD_VALUE ; default : <S2SV_StartBug> OVS_NOT_REACHED ( ) ; <S2SV_EndBug> } if ( payload -> size < sizeof * prop ) { OFPPROP_LOG ( & bad_ofmsg_rl , false , "ntr<S2SV_blank>selection<S2SV_blank>method<S2SV_blank>property<S2SV_blank>" "length<S2SV_blank>%u<S2SV_blank>is<S2SV_blank>not<S2SV_blank>valid" , payload -> size ) ; return OFPERR_OFPBPC_BAD_LEN ; } method_len = strnlen ( prop -> selection_method , NTR_MAX_SELECTION_METHOD_LEN ) ; if ( method_len == NTR_MAX_SELECTION_METHOD_LEN ) { OFPPROP_LOG ( & bad_ofmsg_rl , false , "ntr<S2SV_blank>selection<S2SV_blank>method<S2SV_blank>is<S2SV_blank>not<S2SV_blank>null<S2SV_blank>terminated" ) ; return OFPERR_OFPBPC_BAD_VALUE ; } if ( strcmp ( "hash" , prop -> selection_method ) && strcmp ( "dp_hash" , prop -> selection_method ) ) { OFPPROP_LOG ( & bad_ofmsg_rl , false , "ntr<S2SV_blank>selection<S2SV_blank>method<S2SV_blank>\'%s\'<S2SV_blank>is<S2SV_blank>not<S2SV_blank>supported" , prop -> selection_method ) ; return OFPERR_OFPBPC_BAD_VALUE ; } strcpy ( gp -> selection_method , prop -> selection_method ) ; gp -> selection_method_param = ntohll ( prop -> selection_method_param ) ; ofpbuf_pull ( payload , sizeof * prop ) ; fields_len = ntohs ( prop -> length ) - sizeof * prop ; if ( fields_len && strcmp ( "hash" , gp -> selection_method ) ) { OFPPROP_LOG ( & bad_ofmsg_rl , false , "ntr<S2SV_blank>selection<S2SV_blank>method<S2SV_blank>%s<S2SV_blank>" "does<S2SV_blank>not<S2SV_blank>support<S2SV_blank>fields" , gp -> selection_method ) ; return OFPERR_OFPBPC_BAD_VALUE ; } error = oxm_pull_field_array ( payload -> data , fields_len , & gp -> fields ) ; if ( error ) { OFPPROP_LOG ( & bad_ofmsg_rl , false , "ntr<S2SV_blank>selection<S2SV_blank>method<S2SV_blank>fields<S2SV_blank>are<S2SV_blank>invalid" ) ; return error ; } return 0 ; }
CWE-190 static void Process_ipfix_template_add ( exporter_ipfix_domain_t * exporter , void * DataPtr , uint32_t size_left , FlowSource_t * fs ) { input_translation_t * translation_table ; ipfix_template_record_t * ipfix_template_record ; ipfix_template_elements_std_t * NextElement ; int i ; while ( size_left ) { uint32_t table_id , count , size_required ; uint32_t num_extensions = 0 ; <S2SV_StartBug> if ( size_left && size_left < 4 ) { <S2SV_EndBug> LogError ( "Process_ipfix<S2SV_blank>[%u]<S2SV_blank>Template<S2SV_blank>size<S2SV_blank>error<S2SV_blank>at<S2SV_blank>%s<S2SV_blank>line<S2SV_blank>%u" , exporter -> info . id , __FILE__ , __LINE__ , strerror ( errno ) ) ; size_left = 0 ; continue ; } ipfix_template_record = ( ipfix_template_record_t * ) DataPtr ; size_left -= 4 ; table_id = ntohs ( ipfix_template_record -> TemplateID ) ; count = ntohs ( ipfix_template_record -> FieldCount ) ; dbg_printf ( "\\n[%u]<S2SV_blank>Template<S2SV_blank>ID:<S2SV_blank>%u\\n" , exporter -> info . id , table_id ) ; dbg_printf ( "FieldCount:<S2SV_blank>%u<S2SV_blank>buffersize:<S2SV_blank>%u\\n" , count , size_left ) ; memset ( ( void * ) cache . common_extensions , 0 , ( Max_num_extensions + 1 ) * sizeof ( uint32_t ) ) ; memset ( ( void * ) cache . lookup_info , 0 , 65536 * sizeof ( struct element_param_s ) ) ; for ( i = 1 ; ipfix_element_map [ i ] . id != 0 ; i ++ ) { uint32_t Type = ipfix_element_map [ i ] . id ; if ( ipfix_element_map [ i ] . id == ipfix_element_map [ i - 1 ] . id ) continue ; cache . lookup_info [ Type ] . index = i ; } cache . input_order = calloc ( count , sizeof ( struct order_s ) ) ; if ( ! cache . input_order ) { LogError ( "Process_ipfix:<S2SV_blank>Panic!<S2SV_blank>malloc():<S2SV_blank>%s<S2SV_blank>line<S2SV_blank>%d:<S2SV_blank>%s" , __FILE__ , __LINE__ , strerror ( errno ) ) ; size_left = 0 ; continue ; } cache . input_count = count ; size_required = 4 * count ; if ( size_left < size_required ) { LogError ( "Process_ipfix:<S2SV_blank>[%u]<S2SV_blank>Not<S2SV_blank>enough<S2SV_blank>data<S2SV_blank>for<S2SV_blank>template<S2SV_blank>elements!<S2SV_blank>required:<S2SV_blank>%i,<S2SV_blank>left:<S2SV_blank>%u" , exporter -> info . id , size_required , size_left ) ; dbg_printf ( "ERROR:<S2SV_blank>Not<S2SV_blank>enough<S2SV_blank>data<S2SV_blank>for<S2SV_blank>template<S2SV_blank>elements!<S2SV_blank>required:<S2SV_blank>%i,<S2SV_blank>left:<S2SV_blank>%u" , size_required , size_left ) ; return ; } NextElement = ( ipfix_template_elements_std_t * ) ipfix_template_record -> elements ; for ( i = 0 ; i < count ; i ++ ) { uint16_t Type , Length ; uint32_t ext_id ; int Enterprise ; Type = ntohs ( NextElement -> Type ) ; Length = ntohs ( NextElement -> Length ) ; Enterprise = Type & 0x8000 ? 1 : 0 ; Type = Type & 0x7FFF ; ext_id = MapElement ( Type , Length , i ) ; if ( ext_id && extension_descriptor [ ext_id ] . enabled ) { if ( cache . common_extensions [ ext_id ] == 0 ) { cache . common_extensions [ ext_id ] = 1 ; num_extensions ++ ; } } if ( Enterprise ) { ipfix_template_elements_e_t * e = ( ipfix_template_elements_e_t * ) NextElement ; size_required += 4 ; if ( size_left < size_required ) { LogError ( "Process_ipfix:<S2SV_blank>[%u]<S2SV_blank>Not<S2SV_blank>enough<S2SV_blank>data<S2SV_blank>for<S2SV_blank>template<S2SV_blank>elements!<S2SV_blank>required:<S2SV_blank>%i,<S2SV_blank>left:<S2SV_blank>%u" , exporter -> info . id , size_required , size_left ) ; dbg_printf ( "ERROR:<S2SV_blank>Not<S2SV_blank>enough<S2SV_blank>data<S2SV_blank>for<S2SV_blank>template<S2SV_blank>elements!<S2SV_blank>required:<S2SV_blank>%i,<S2SV_blank>left:<S2SV_blank>%u" , size_required , size_left ) ; return ; } if ( ntohl ( e -> EnterpriseNumber ) == IPFIX_ReverseInformationElement ) { dbg_printf ( "<S2SV_blank>[%i]<S2SV_blank>Enterprise:<S2SV_blank>1,<S2SV_blank>Type:<S2SV_blank>%u,<S2SV_blank>Length<S2SV_blank>%u<S2SV_blank>Reverse<S2SV_blank>Information<S2SV_blank>Element:<S2SV_blank>%u\\n" , i , Type , Length , ntohl ( e -> EnterpriseNumber ) ) ; } else { dbg_printf ( "<S2SV_blank>[%i]<S2SV_blank>Enterprise:<S2SV_blank>1,<S2SV_blank>Type:<S2SV_blank>%u,<S2SV_blank>Length<S2SV_blank>%u<S2SV_blank>EnterpriseNumber:<S2SV_blank>%u\\n" , i , Type , Length , ntohl ( e -> EnterpriseNumber ) ) ; } e ++ ; NextElement = ( ipfix_template_elements_std_t * ) e ; } else { dbg_printf ( "<S2SV_blank>[%i]<S2SV_blank>Enterprise:<S2SV_blank>0,<S2SV_blank>Type:<S2SV_blank>%u,<S2SV_blank>Length<S2SV_blank>%u\\n" , i , Type , Length ) ; NextElement ++ ; } } dbg_printf ( "Processed:<S2SV_blank>%u\\n" , size_required ) ; if ( compact_input_order ( ) ) { if ( extension_descriptor [ EX_ROUTER_IP_v4 ] . enabled ) { if ( cache . common_extensions [ EX_ROUTER_IP_v4 ] == 0 ) { cache . common_extensions [ EX_ROUTER_IP_v4 ] = 1 ; num_extensions ++ ; } dbg_printf ( "Add<S2SV_blank>sending<S2SV_blank>router<S2SV_blank>IP<S2SV_blank>address<S2SV_blank>(%s)<S2SV_blank>=><S2SV_blank>Extension:<S2SV_blank>%u\\n" , fs -> sa_family == PF_INET6 ? "ipv6" : "ipv4" , EX_ROUTER_IP_v4 ) ; } extension_descriptor [ EX_ROUTER_ID ] . enabled = 0 ; if ( extension_descriptor [ EX_RECEIVED ] . enabled ) { if ( cache . common_extensions [ EX_RECEIVED ] == 0 ) { cache . common_extensions [ EX_RECEIVED ] = 1 ; num_extensions ++ ; } dbg_printf ( "Force<S2SV_blank>add<S2SV_blank>packet<S2SV_blank>received<S2SV_blank>time,<S2SV_blank>Extension:<S2SV_blank>%u\\n" , EX_RECEIVED ) ; } # ifdef DEVEL { int i ; for ( i = 4 ; extension_descriptor [ i ] . id ; i ++ ) { if ( cache . common_extensions [ i ] ) { printf ( "Enabled<S2SV_blank>extension:<S2SV_blank>%i\\n" , i ) ; } } } # endif translation_table = setup_translation_table ( exporter , table_id ) ; if ( translation_table -> extension_map_changed ) { dbg_printf ( "Translation<S2SV_blank>Table<S2SV_blank>changed!<S2SV_blank>Add<S2SV_blank>extension<S2SV_blank>map<S2SV_blank>ID:<S2SV_blank>%i\\n" , translation_table -> extension_info . map -> map_id ) ; AddExtensionMap ( fs , translation_table -> extension_info . map ) ; translation_table -> extension_map_changed = 0 ; dbg_printf ( "Translation<S2SV_blank>Table<S2SV_blank>added!<S2SV_blank>map<S2SV_blank>ID:<S2SV_blank>%i\\n" , translation_table -> extension_info . map -> map_id ) ; } if ( ! reorder_sequencer ( translation_table ) ) { LogError ( "Process_ipfix:<S2SV_blank>[%u]<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>reorder<S2SV_blank>sequencer.<S2SV_blank>Remove<S2SV_blank>table<S2SV_blank>id:<S2SV_blank>%u" , exporter -> info . id , table_id ) ; remove_translation_table ( fs , exporter , table_id ) ; } } else { dbg_printf ( "Template<S2SV_blank>does<S2SV_blank>not<S2SV_blank>contain<S2SV_blank>any<S2SV_blank>common<S2SV_blank>fields<S2SV_blank>-<S2SV_blank>skip\\n" ) ; } size_left -= size_required ; DataPtr = DataPtr + size_required + 4 ; if ( size_left < 4 ) { dbg_printf ( "Skip<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>padding\\n" , size_left ) ; size_left = 0 ; } free ( cache . input_order ) ; cache . input_order = NULL ; } }
CWE-190 static void Process_ipfix_template_withdraw ( exporter_ipfix_domain_t * exporter , void * DataPtr , uint32_t size_left , FlowSource_t * fs ) { ipfix_template_record_t * ipfix_template_record ; while ( size_left ) { <S2SV_StartBug> uint32_t id ; <S2SV_EndBug> ipfix_template_record = ( ipfix_template_record_t * ) DataPtr ; size_left -= 4 ; id = ntohs ( ipfix_template_record -> TemplateID ) ; if ( id == IPFIX_TEMPLATE_FLOWSET_ID ) { remove_all_translation_tables ( exporter ) ; ReInitExtensionMapList ( fs ) ; } else { remove_translation_table ( fs , exporter , id ) ; } DataPtr = DataPtr + 4 ; if ( size_left < 4 ) { dbg_printf ( "Skip<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>padding\\n" , size_left ) ; size_left = 0 ; } } }
CWE-415 void gdImageGifCtx ( gdImagePtr im , gdIOCtxPtr out ) { <S2SV_StartBug> gdImagePtr pim = 0 , tim = im ; <S2SV_EndBug> int interlace , BitsPerPixel ; interlace = im -> interlace ; if ( im -> trueColor ) { <S2SV_StartBug> pim = gdImageCreatePaletteFromTrueColor ( im , 1 , 256 ) ; <S2SV_EndBug> if ( ! pim ) { return ; } tim = pim ; } BitsPerPixel = colorstobpp ( tim -> colorsTotal ) ; GIFEncode ( out , tim -> sx , tim -> sy , tim -> interlace , 0 , tim -> transparent , BitsPerPixel , tim -> red , tim -> green , tim -> blue , tim ) ; if ( pim ) { gdImageDestroy ( pim ) ; } <S2SV_StartBug> } <S2SV_EndBug>
CWE-415 void * gdImageGifPtr ( gdImagePtr im , int * size ) { void * rv ; gdIOCtx * out = gdNewDynamicCtx ( 2048 , NULL ) ; <S2SV_StartBug> gdImageGifCtx ( im , out ) ; <S2SV_EndBug> <S2SV_StartBug> rv = gdDPExtractData ( out , size ) ; <S2SV_EndBug> out -> gd_free ( out ) ; return rv ; }
CWE-415 void gdImageWBMPCtx ( gdImagePtr image , int fg , gdIOCtx * out ) { <S2SV_StartBug> int x , y , pos ; <S2SV_EndBug> Wbmp * wbmp ; if ( ( wbmp = createwbmp ( gdImageSX ( image ) , gdImageSY ( image ) , WBMP_WHITE ) ) == NULL ) { gd_error ( "Could<S2SV_blank>not<S2SV_blank>create<S2SV_blank>WBMP" ) ; return ; } pos = 0 ; for ( y = 0 ; y < gdImageSY ( image ) ; y ++ ) { for ( x = 0 ; x < gdImageSX ( image ) ; x ++ ) { <S2SV_StartBug> if ( gdImageGetPixel ( image , x , y ) == fg ) { <S2SV_EndBug> wbmp -> bitmap [ pos ] = WBMP_BLACK ; } pos ++ ; } } if ( writewbmp ( wbmp , & gd_putout , out ) ) { gd_error ( "Could<S2SV_blank>not<S2SV_blank>save<S2SV_blank>WBMP" ) ; } freewbmp ( wbmp ) ; }
CWE-415 void * gdImageWBMPPtr ( gdImagePtr im , int * size , int fg ) { void * rv ; gdIOCtx * out = gdNewDynamicCtx ( 2048 , NULL ) ; <S2SV_StartBug> gdImageWBMPCtx ( im , fg , out ) ; <S2SV_EndBug> <S2SV_StartBug> rv = gdDPExtractData ( out , size ) ; <S2SV_EndBug> out -> gd_free ( out ) ; return rv ; }
CWE-79 static int php_handler ( request_rec * r ) { php_struct * volatile ctx ; void * conf ; apr_bucket_brigade * volatile brigade ; apr_bucket * bucket ; apr_status_t rv ; request_rec * volatile parent_req = NULL ; TSRMLS_FETCH ( ) ; # define PHPAP_INI_OFF php_apache_ini_dtor ( r , parent_req TSRMLS_CC ) ; conf = ap_get_module_config ( r -> per_dir_config , & php5_module ) ; ctx = SG ( server_context ) ; if ( ctx == NULL || ( ctx && ctx -> request_processed && ! strcmp ( r -> protocol , "INCLUDED" ) ) ) { normal : ctx = SG ( server_context ) = apr_pcalloc ( r -> pool , sizeof ( * ctx ) ) ; apr_pool_cleanup_register ( r -> pool , ( void * ) & SG ( server_context ) , php_server_context_cleanup , apr_pool_cleanup_null ) ; ctx -> r = r ; ctx = NULL ; } else { parent_req = ctx -> r ; ctx -> r = r ; } apply_config ( conf ) ; if ( strcmp ( r -> handler , PHP_MAGIC_TYPE ) && strcmp ( r -> handler , PHP_SOURCE_MAGIC_TYPE ) && strcmp ( r -> handler , PHP_SCRIPT ) ) { if ( ! AP2 ( xbithack ) || strcmp ( r -> handler , "text/html" ) || ! ( r -> finfo . protection & APR_UEXECUTE ) ) { PHPAP_INI_OFF ; return DECLINED ; } } if ( r -> used_path_info == AP_REQ_REJECT_PATH_INFO && r -> path_info && r -> path_info [ 0 ] ) { PHPAP_INI_OFF ; return HTTP_NOT_FOUND ; } if ( ! AP2 ( engine ) ) { PHPAP_INI_OFF ; return DECLINED ; } if ( r -> finfo . filetype == 0 ) { php_apache_sapi_log_message_ex ( "script<S2SV_blank>\'%s\'<S2SV_blank>not<S2SV_blank>found<S2SV_blank>or<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>stat" , r TSRMLS_CC ) ; PHPAP_INI_OFF ; return HTTP_NOT_FOUND ; } if ( r -> finfo . filetype == APR_DIR ) { php_apache_sapi_log_message_ex ( "attempt<S2SV_blank>to<S2SV_blank>invoke<S2SV_blank>directory<S2SV_blank>\'%s\'<S2SV_blank>as<S2SV_blank>script" , r TSRMLS_CC ) ; PHPAP_INI_OFF ; return HTTP_FORBIDDEN ; } if ( r -> main == NULL || r -> subprocess_env != r -> main -> subprocess_env ) { ap_add_common_vars ( r ) ; ap_add_cgi_vars ( r ) ; } zend_first_try { if ( ctx == NULL ) { brigade = apr_brigade_create ( r -> pool , r -> connection -> bucket_alloc ) ; ctx = SG ( server_context ) ; ctx -> brigade = brigade ; if ( php_apache_request_ctor ( r , ctx TSRMLS_CC ) != SUCCESS ) { zend_bailout ( ) ; } } else { if ( ! parent_req ) { parent_req = ctx -> r ; } if ( parent_req && parent_req -> handler && strcmp ( parent_req -> handler , PHP_MAGIC_TYPE ) && strcmp ( parent_req -> handler , PHP_SOURCE_MAGIC_TYPE ) && strcmp ( parent_req -> handler , PHP_SCRIPT ) ) { if ( php_apache_request_ctor ( r , ctx TSRMLS_CC ) != SUCCESS ) { zend_bailout ( ) ; } } if ( parent_req && parent_req -> status != HTTP_OK && parent_req -> status != 413 && strcmp ( r -> protocol , "INCLUDED" ) ) { parent_req = NULL ; goto normal ; } ctx -> r = r ; brigade = ctx -> brigade ; } if ( AP2 ( last_modified ) ) { ap_update_mtime ( r , r -> finfo . mtime ) ; ap_set_last_modified ( r ) ; } if ( strncmp ( r -> handler , PHP_SOURCE_MAGIC_TYPE , sizeof ( PHP_SOURCE_MAGIC_TYPE ) - 1 ) == 0 ) { zend_syntax_highlighter_ini syntax_highlighter_ini ; php_get_highlight_struct ( & syntax_highlighter_ini ) ; highlight_file ( ( char * ) r -> filename , & syntax_highlighter_ini TSRMLS_CC ) ; } else { zend_file_handle zfd ; zfd . type = ZEND_HANDLE_FILENAME ; zfd . filename = ( char * ) r -> filename ; zfd . free_filename = 0 ; zfd . opened_path = NULL ; if ( ! parent_req ) { php_execute_script ( & zfd TSRMLS_CC ) ; } else { zend_execute_scripts ( ZEND_INCLUDE TSRMLS_CC , NULL , 1 , & zfd ) ; } apr_table_set ( r -> notes , "mod_php_memory_usage" , apr_psprintf ( ctx -> r -> pool , "%" APR_SIZE_T_FMT , zend_memory_peak_usage ( 1 TSRMLS_CC ) ) ) ; } } zend_end_try ( ) ; if ( ! parent_req ) { php_apache_request_dtor ( r TSRMLS_CC ) ; ctx -> request_processed = 1 ; <S2SV_StartBug> bucket = apr_bucket_eos_create ( r -> connection -> bucket_alloc ) ; <S2SV_EndBug> APR_BRIGADE_INSERT_TAIL ( brigade , bucket ) ; rv = ap_pass_brigade ( r -> output_filters , brigade ) ; if ( rv != APR_SUCCESS || r -> connection -> aborted ) { zend_first_try { php_handle_aborted_connection ( ) ; } zend_end_try ( ) ; } apr_brigade_cleanup ( brigade ) ; apr_pool_cleanup_run ( r -> pool , ( void * ) & SG ( server_context ) , php_server_context_cleanup ) ; } else { ctx -> r = parent_req ; } return OK ; }
CWE-119 php_stream * php_stream_url_wrap_http_ex ( php_stream_wrapper * wrapper , const char * path , const char * mode , int options , char * * opened_path , php_stream_context * context , int redirect_max , int flags STREAMS_DC TSRMLS_DC ) { php_stream * stream = NULL ; php_url * resource = NULL ; int use_ssl ; int use_proxy = 0 ; char * scratch = NULL ; char * tmp = NULL ; char * ua_str = NULL ; zval * * ua_zval = NULL , * * tmpzval = NULL , * ssl_proxy_peer_name = NULL ; int scratch_len = 0 ; int body = 0 ; char location [ HTTP_HEADER_BLOCK_SIZE ] ; zval * response_header = NULL ; int reqok = 0 ; char * http_header_line = NULL ; char tmp_line [ 128 ] ; size_t chunk_size = 0 , file_size = 0 ; int eol_detect = 0 ; char * transport_string , * errstr = NULL ; int transport_len , have_header = 0 , request_fulluri = 0 , ignore_errors = 0 ; char * protocol_version = NULL ; int protocol_version_len = 3 ; struct timeval timeout ; char * user_headers = NULL ; int header_init = ( ( flags & HTTP_WRAPPER_HEADER_INIT ) != 0 ) ; int redirected = ( ( flags & HTTP_WRAPPER_REDIRECTED ) != 0 ) ; int follow_location = 1 ; php_stream_filter * transfer_encoding = NULL ; int response_code ; tmp_line [ 0 ] = '\\0' ; if ( redirect_max < 1 ) { php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , "Redirection<S2SV_blank>limit<S2SV_blank>reached,<S2SV_blank>aborting" ) ; return NULL ; } resource = php_url_parse ( path ) ; if ( resource == NULL ) { return NULL ; } if ( strncasecmp ( resource -> scheme , "http" , sizeof ( "http" ) ) && strncasecmp ( resource -> scheme , "https" , sizeof ( "https" ) ) ) { if ( ! context || php_stream_context_get_option ( context , wrapper -> wops -> label , "proxy" , & tmpzval ) == FAILURE || Z_TYPE_PP ( tmpzval ) != IS_STRING || Z_STRLEN_PP ( tmpzval ) <= 0 ) { php_url_free ( resource ) ; return php_stream_open_wrapper_ex ( path , mode , REPORT_ERRORS , NULL , context ) ; } request_fulluri = 1 ; use_ssl = 0 ; use_proxy = 1 ; transport_len = Z_STRLEN_PP ( tmpzval ) ; transport_string = estrndup ( Z_STRVAL_PP ( tmpzval ) , Z_STRLEN_PP ( tmpzval ) ) ; } else { if ( strpbrk ( mode , "awx+" ) ) { php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , "HTTP<S2SV_blank>wrapper<S2SV_blank>does<S2SV_blank>not<S2SV_blank>support<S2SV_blank>writeable<S2SV_blank>connections" ) ; php_url_free ( resource ) ; return NULL ; } use_ssl = resource -> scheme && ( strlen ( resource -> scheme ) > 4 ) && resource -> scheme [ 4 ] == 's' ; if ( use_ssl && resource -> port == 0 ) resource -> port = 443 ; else if ( resource -> port == 0 ) resource -> port = 80 ; if ( context && php_stream_context_get_option ( context , wrapper -> wops -> label , "proxy" , & tmpzval ) == SUCCESS && Z_TYPE_PP ( tmpzval ) == IS_STRING && Z_STRLEN_PP ( tmpzval ) > 0 ) { use_proxy = 1 ; transport_len = Z_STRLEN_PP ( tmpzval ) ; transport_string = estrndup ( Z_STRVAL_PP ( tmpzval ) , Z_STRLEN_PP ( tmpzval ) ) ; } else { transport_len = spprintf ( & transport_string , 0 , "%s://%s:%d" , use_ssl ? "ssl" : "tcp" , resource -> host , resource -> port ) ; } } if ( context && php_stream_context_get_option ( context , wrapper -> wops -> label , "timeout" , & tmpzval ) == SUCCESS ) { SEPARATE_ZVAL ( tmpzval ) ; convert_to_double_ex ( tmpzval ) ; timeout . tv_sec = ( time_t ) Z_DVAL_PP ( tmpzval ) ; timeout . tv_usec = ( size_t ) ( ( Z_DVAL_PP ( tmpzval ) - timeout . tv_sec ) * 1000000 ) ; } else { timeout . tv_sec = FG ( default_socket_timeout ) ; timeout . tv_usec = 0 ; } stream = php_stream_xport_create ( transport_string , transport_len , options , STREAM_XPORT_CLIENT | STREAM_XPORT_CONNECT , NULL , & timeout , context , & errstr , NULL ) ; if ( stream ) { php_stream_set_option ( stream , PHP_STREAM_OPTION_READ_TIMEOUT , 0 , & timeout ) ; } if ( errstr ) { php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , "%s" , errstr ) ; efree ( errstr ) ; errstr = NULL ; } efree ( transport_string ) ; if ( stream && use_proxy && use_ssl ) { smart_str header = { 0 } ; if ( ! context || php_stream_context_get_option ( context , "ssl" , "peer_name" , & tmpzval ) == FAILURE ) { MAKE_STD_ZVAL ( ssl_proxy_peer_name ) ; ZVAL_STRING ( ssl_proxy_peer_name , resource -> host , 1 ) ; php_stream_context_set_option ( stream -> context , "ssl" , "peer_name" , ssl_proxy_peer_name ) ; } smart_str_appendl ( & header , "CONNECT<S2SV_blank>" , sizeof ( "CONNECT<S2SV_blank>" ) - 1 ) ; smart_str_appends ( & header , resource -> host ) ; smart_str_appendc ( & header , ':' ) ; smart_str_append_unsigned ( & header , resource -> port ) ; smart_str_appendl ( & header , "<S2SV_blank>HTTP/1.0\\r\\n" , sizeof ( "<S2SV_blank>HTTP/1.0\\r\\n" ) - 1 ) ; if ( context && php_stream_context_get_option ( context , "http" , "header" , & tmpzval ) == SUCCESS ) { char * s , * p ; if ( Z_TYPE_PP ( tmpzval ) == IS_ARRAY ) { HashPosition pos ; zval * * tmpheader = NULL ; for ( zend_hash_internal_pointer_reset_ex ( Z_ARRVAL_PP ( tmpzval ) , & pos ) ; SUCCESS == zend_hash_get_current_data_ex ( Z_ARRVAL_PP ( tmpzval ) , ( void * ) & tmpheader , & pos ) ; zend_hash_move_forward_ex ( Z_ARRVAL_PP ( tmpzval ) , & pos ) ) { if ( Z_TYPE_PP ( tmpheader ) == IS_STRING ) { s = Z_STRVAL_PP ( tmpheader ) ; do { while ( * s == '<S2SV_blank>' || * s == '\\t' ) s ++ ; p = s ; while ( * p != 0 && * p != ':' && * p != '\\r' && * p != '\\n' ) p ++ ; if ( * p == ':' ) { p ++ ; if ( p - s == sizeof ( "Proxy-Authorization:" ) - 1 && zend_binary_strcasecmp ( s , sizeof ( "Proxy-Authorization:" ) - 1 , "Proxy-Authorization:" , sizeof ( "Proxy-Authorization:" ) - 1 ) == 0 ) { while ( * p != 0 && * p != '\\r' && * p != '\\n' ) p ++ ; smart_str_appendl ( & header , s , p - s ) ; smart_str_appendl ( & header , "\\r\\n" , sizeof ( "\\r\\n" ) - 1 ) ; goto finish ; } else { while ( * p != 0 && * p != '\\r' && * p != '\\n' ) p ++ ; } } s = p ; while ( * s == '\\r' || * s == '\\n' ) s ++ ; } while ( * s != 0 ) ; } } } else if ( Z_TYPE_PP ( tmpzval ) == IS_STRING && Z_STRLEN_PP ( tmpzval ) ) { s = Z_STRVAL_PP ( tmpzval ) ; do { while ( * s == '<S2SV_blank>' || * s == '\\t' ) s ++ ; p = s ; while ( * p != 0 && * p != ':' && * p != '\\r' && * p != '\\n' ) p ++ ; if ( * p == ':' ) { p ++ ; if ( p - s == sizeof ( "Proxy-Authorization:" ) - 1 && zend_binary_strcasecmp ( s , sizeof ( "Proxy-Authorization:" ) - 1 , "Proxy-Authorization:" , sizeof ( "Proxy-Authorization:" ) - 1 ) == 0 ) { while ( * p != 0 && * p != '\\r' && * p != '\\n' ) p ++ ; smart_str_appendl ( & header , s , p - s ) ; smart_str_appendl ( & header , "\\r\\n" , sizeof ( "\\r\\n" ) - 1 ) ; goto finish ; } else { while ( * p != 0 && * p != '\\r' && * p != '\\n' ) p ++ ; } } s = p ; while ( * s == '\\r' || * s == '\\n' ) s ++ ; } while ( * s != 0 ) ; } } finish : smart_str_appendl ( & header , "\\r\\n" , sizeof ( "\\r\\n" ) - 1 ) ; if ( php_stream_write ( stream , header . c , header . len ) != header . len ) { php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , "Cannot<S2SV_blank>connect<S2SV_blank>to<S2SV_blank>HTTPS<S2SV_blank>server<S2SV_blank>through<S2SV_blank>proxy" ) ; php_stream_close ( stream ) ; stream = NULL ; } smart_str_free ( & header ) ; if ( stream ) { char header_line [ HTTP_HEADER_BLOCK_SIZE ] ; while ( php_stream_gets ( stream , header_line , HTTP_HEADER_BLOCK_SIZE - 1 ) != NULL ) { if ( header_line [ 0 ] == '\\n' || header_line [ 0 ] == '\\r' || header_line [ 0 ] == '\\0' ) { break ; } } } if ( stream ) { if ( php_stream_xport_crypto_setup ( stream , STREAM_CRYPTO_METHOD_SSLv23_CLIENT , NULL TSRMLS_CC ) < 0 || php_stream_xport_crypto_enable ( stream , 1 TSRMLS_CC ) < 0 ) { php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , "Cannot<S2SV_blank>connect<S2SV_blank>to<S2SV_blank>HTTPS<S2SV_blank>server<S2SV_blank>through<S2SV_blank>proxy" ) ; php_stream_close ( stream ) ; stream = NULL ; } } } if ( stream == NULL ) goto out ; if ( options & STREAM_WILL_CAST ) chunk_size = php_stream_set_chunk_size ( stream , 1 ) ; eol_detect = stream -> flags & ( PHP_STREAM_FLAG_DETECT_EOL | PHP_STREAM_FLAG_EOL_MAC ) ; stream -> flags &= ~ ( PHP_STREAM_FLAG_DETECT_EOL | PHP_STREAM_FLAG_EOL_MAC ) ; php_stream_context_set ( stream , context ) ; php_stream_notify_info ( context , PHP_STREAM_NOTIFY_CONNECT , NULL , 0 ) ; if ( header_init && context && php_stream_context_get_option ( context , "http" , "max_redirects" , & tmpzval ) == SUCCESS ) { SEPARATE_ZVAL ( tmpzval ) ; convert_to_long_ex ( tmpzval ) ; redirect_max = Z_LVAL_PP ( tmpzval ) ; } if ( context && php_stream_context_get_option ( context , "http" , "method" , & tmpzval ) == SUCCESS ) { if ( Z_TYPE_PP ( tmpzval ) == IS_STRING && Z_STRLEN_PP ( tmpzval ) > 0 ) { if ( ! redirected || ( Z_STRLEN_PP ( tmpzval ) == 3 && memcmp ( "GET" , Z_STRVAL_PP ( tmpzval ) , 3 ) == 0 ) || ( Z_STRLEN_PP ( tmpzval ) == 4 && memcmp ( "HEAD" , Z_STRVAL_PP ( tmpzval ) , 4 ) == 0 ) ) { scratch_len = strlen ( path ) + 29 + Z_STRLEN_PP ( tmpzval ) ; scratch = emalloc ( scratch_len ) ; strlcpy ( scratch , Z_STRVAL_PP ( tmpzval ) , Z_STRLEN_PP ( tmpzval ) + 1 ) ; strncat ( scratch , "<S2SV_blank>" , 1 ) ; } } } if ( context && php_stream_context_get_option ( context , "http" , "protocol_version" , & tmpzval ) == SUCCESS ) { SEPARATE_ZVAL ( tmpzval ) ; convert_to_double_ex ( tmpzval ) ; protocol_version_len = spprintf ( & protocol_version , 0 , "%.1F" , Z_DVAL_PP ( tmpzval ) ) ; } if ( ! scratch ) { scratch_len = strlen ( path ) + 29 + protocol_version_len ; scratch = emalloc ( scratch_len ) ; strncpy ( scratch , "GET<S2SV_blank>" , scratch_len ) ; } if ( ! request_fulluri && context && php_stream_context_get_option ( context , "http" , "request_fulluri" , & tmpzval ) == SUCCESS ) { zval ztmp = * * tmpzval ; zval_copy_ctor ( & ztmp ) ; convert_to_boolean ( & ztmp ) ; request_fulluri = Z_BVAL ( ztmp ) ? 1 : 0 ; zval_dtor ( & ztmp ) ; } if ( request_fulluri ) { strcat ( scratch , path ) ; } else { if ( resource -> path && * resource -> path ) { strlcat ( scratch , resource -> path , scratch_len ) ; } else { strlcat ( scratch , "/" , scratch_len ) ; } if ( resource -> query ) { strlcat ( scratch , "?" , scratch_len ) ; strlcat ( scratch , resource -> query , scratch_len ) ; } } if ( protocol_version ) { strlcat ( scratch , "<S2SV_blank>HTTP/" , scratch_len ) ; strlcat ( scratch , protocol_version , scratch_len ) ; strlcat ( scratch , "\\r\\n" , scratch_len ) ; } else { strlcat ( scratch , "<S2SV_blank>HTTP/1.0\\r\\n" , scratch_len ) ; } php_stream_write ( stream , scratch , strlen ( scratch ) ) ; if ( context && php_stream_context_get_option ( context , "http" , "header" , & tmpzval ) == SUCCESS ) { tmp = NULL ; if ( Z_TYPE_PP ( tmpzval ) == IS_ARRAY ) { HashPosition pos ; zval * * tmpheader = NULL ; smart_str tmpstr = { 0 } ; for ( zend_hash_internal_pointer_reset_ex ( Z_ARRVAL_PP ( tmpzval ) , & pos ) ; SUCCESS == zend_hash_get_current_data_ex ( Z_ARRVAL_PP ( tmpzval ) , ( void * ) & tmpheader , & pos ) ; zend_hash_move_forward_ex ( Z_ARRVAL_PP ( tmpzval ) , & pos ) ) { if ( Z_TYPE_PP ( tmpheader ) == IS_STRING ) { smart_str_appendl ( & tmpstr , Z_STRVAL_PP ( tmpheader ) , Z_STRLEN_PP ( tmpheader ) ) ; smart_str_appendl ( & tmpstr , "\\r\\n" , sizeof ( "\\r\\n" ) - 1 ) ; } } smart_str_0 ( & tmpstr ) ; if ( tmpstr . c ) { tmp = php_trim ( tmpstr . c , strlen ( tmpstr . c ) , NULL , 0 , NULL , 3 TSRMLS_CC ) ; smart_str_free ( & tmpstr ) ; } } if ( Z_TYPE_PP ( tmpzval ) == IS_STRING && Z_STRLEN_PP ( tmpzval ) ) { tmp = php_trim ( Z_STRVAL_PP ( tmpzval ) , Z_STRLEN_PP ( tmpzval ) , NULL , 0 , NULL , 3 TSRMLS_CC ) ; } if ( tmp && strlen ( tmp ) > 0 ) { char * s ; user_headers = estrdup ( tmp ) ; php_strtolower ( tmp , strlen ( tmp ) ) ; if ( ! header_init ) { strip_header ( user_headers , tmp , "content-length:" ) ; strip_header ( user_headers , tmp , "content-type:" ) ; } if ( ( s = strstr ( tmp , "user-agent:" ) ) && ( s == tmp || * ( s - 1 ) == '\\r' || * ( s - 1 ) == '\\n' || * ( s - 1 ) == '\\t' || * ( s - 1 ) == '<S2SV_blank>' ) ) { have_header |= HTTP_HEADER_USER_AGENT ; } if ( ( s = strstr ( tmp , "host:" ) ) && ( s == tmp || * ( s - 1 ) == '\\r' || * ( s - 1 ) == '\\n' || * ( s - 1 ) == '\\t' || * ( s - 1 ) == '<S2SV_blank>' ) ) { have_header |= HTTP_HEADER_HOST ; } if ( ( s = strstr ( tmp , "from:" ) ) && ( s == tmp || * ( s - 1 ) == '\\r' || * ( s - 1 ) == '\\n' || * ( s - 1 ) == '\\t' || * ( s - 1 ) == '<S2SV_blank>' ) ) { have_header |= HTTP_HEADER_FROM ; } if ( ( s = strstr ( tmp , "authorization:" ) ) && ( s == tmp || * ( s - 1 ) == '\\r' || * ( s - 1 ) == '\\n' || * ( s - 1 ) == '\\t' || * ( s - 1 ) == '<S2SV_blank>' ) ) { have_header |= HTTP_HEADER_AUTH ; } if ( ( s = strstr ( tmp , "content-length:" ) ) && ( s == tmp || * ( s - 1 ) == '\\r' || * ( s - 1 ) == '\\n' || * ( s - 1 ) == '\\t' || * ( s - 1 ) == '<S2SV_blank>' ) ) { have_header |= HTTP_HEADER_CONTENT_LENGTH ; } if ( ( s = strstr ( tmp , "content-type:" ) ) && ( s == tmp || * ( s - 1 ) == '\\r' || * ( s - 1 ) == '\\n' || * ( s - 1 ) == '\\t' || * ( s - 1 ) == '<S2SV_blank>' ) ) { have_header |= HTTP_HEADER_TYPE ; } if ( ( s = strstr ( tmp , "connection:" ) ) && ( s == tmp || * ( s - 1 ) == '\\r' || * ( s - 1 ) == '\\n' || * ( s - 1 ) == '\\t' || * ( s - 1 ) == '<S2SV_blank>' ) ) { have_header |= HTTP_HEADER_CONNECTION ; } if ( use_proxy && use_ssl && ( s = strstr ( tmp , "proxy-authorization:" ) ) && ( s == tmp || * ( s - 1 ) == '\\r' || * ( s - 1 ) == '\\n' || * ( s - 1 ) == '\\t' || * ( s - 1 ) == '<S2SV_blank>' ) ) { char * p = s + sizeof ( "proxy-authorization:" ) - 1 ; while ( s > tmp && ( * ( s - 1 ) == '<S2SV_blank>' || * ( s - 1 ) == '\\t' ) ) s -- ; while ( * p != 0 && * p != '\\r' && * p != '\\n' ) p ++ ; while ( * p == '\\r' || * p == '\\n' ) p ++ ; if ( * p == 0 ) { if ( s == tmp ) { efree ( user_headers ) ; user_headers = NULL ; } else { while ( s > tmp && ( * ( s - 1 ) == '\\r' || * ( s - 1 ) == '\\n' ) ) s -- ; user_headers [ s - tmp ] = 0 ; } } else { memmove ( user_headers + ( s - tmp ) , user_headers + ( p - tmp ) , strlen ( p ) + 1 ) ; } } } if ( tmp ) { efree ( tmp ) ; } } if ( ( ( have_header & HTTP_HEADER_AUTH ) == 0 ) && resource -> user ) { php_url_decode ( resource -> user , strlen ( resource -> user ) ) ; strcpy ( scratch , resource -> user ) ; strcat ( scratch , ":" ) ; if ( resource -> pass ) { php_url_decode ( resource -> pass , strlen ( resource -> pass ) ) ; strcat ( scratch , resource -> pass ) ; } tmp = ( char * ) php_base64_encode ( ( unsigned char * ) scratch , strlen ( scratch ) , NULL ) ; if ( snprintf ( scratch , scratch_len , "Authorization:<S2SV_blank>Basic<S2SV_blank>%s\\r\\n" , tmp ) > 0 ) { php_stream_write ( stream , scratch , strlen ( scratch ) ) ; php_stream_notify_info ( context , PHP_STREAM_NOTIFY_AUTH_REQUIRED , NULL , 0 ) ; } efree ( tmp ) ; tmp = NULL ; } if ( ( ( have_header & HTTP_HEADER_FROM ) == 0 ) && FG ( from_address ) ) { if ( snprintf ( scratch , scratch_len , "From:<S2SV_blank>%s\\r\\n" , FG ( from_address ) ) > 0 ) php_stream_write ( stream , scratch , strlen ( scratch ) ) ; } if ( ( have_header & HTTP_HEADER_HOST ) == 0 ) { if ( ( use_ssl && resource -> port != 443 && resource -> port != 0 ) || ( ! use_ssl && resource -> port != 80 && resource -> port != 0 ) ) { if ( snprintf ( scratch , scratch_len , "Host:<S2SV_blank>%s:%i\\r\\n" , resource -> host , resource -> port ) > 0 ) php_stream_write ( stream , scratch , strlen ( scratch ) ) ; } else { if ( snprintf ( scratch , scratch_len , "Host:<S2SV_blank>%s\\r\\n" , resource -> host ) > 0 ) { php_stream_write ( stream , scratch , strlen ( scratch ) ) ; } } } if ( ( have_header & HTTP_HEADER_CONNECTION ) == 0 ) { php_stream_write_string ( stream , "Connection:<S2SV_blank>close\\r\\n" ) ; } if ( context && php_stream_context_get_option ( context , "http" , "user_agent" , & ua_zval ) == SUCCESS && Z_TYPE_PP ( ua_zval ) == IS_STRING ) { ua_str = Z_STRVAL_PP ( ua_zval ) ; } else if ( FG ( user_agent ) ) { ua_str = FG ( user_agent ) ; } if ( ( ( have_header & HTTP_HEADER_USER_AGENT ) == 0 ) && ua_str ) { # define _UA_HEADER "User-Agent:<S2SV_blank>%s\\r\\n" char * ua ; size_t ua_len ; ua_len = sizeof ( _UA_HEADER ) + strlen ( ua_str ) ; if ( ua_len > sizeof ( _UA_HEADER ) ) { ua = emalloc ( ua_len + 1 ) ; if ( ( ua_len = slprintf ( ua , ua_len , _UA_HEADER , ua_str ) ) > 0 ) { ua [ ua_len ] = 0 ; php_stream_write ( stream , ua , ua_len ) ; } else { php_error_docref ( NULL TSRMLS_CC , E_WARNING , "Cannot<S2SV_blank>construct<S2SV_blank>User-agent<S2SV_blank>header" ) ; } if ( ua ) { efree ( ua ) ; } } } if ( user_headers ) { if ( header_init && context && ! ( have_header & HTTP_HEADER_CONTENT_LENGTH ) && php_stream_context_get_option ( context , "http" , "content" , & tmpzval ) == SUCCESS && Z_TYPE_PP ( tmpzval ) == IS_STRING && Z_STRLEN_PP ( tmpzval ) > 0 ) { scratch_len = slprintf ( scratch , scratch_len , "Content-Length:<S2SV_blank>%d\\r\\n" , Z_STRLEN_PP ( tmpzval ) ) ; php_stream_write ( stream , scratch , scratch_len ) ; have_header |= HTTP_HEADER_CONTENT_LENGTH ; } php_stream_write ( stream , user_headers , strlen ( user_headers ) ) ; php_stream_write ( stream , "\\r\\n" , sizeof ( "\\r\\n" ) - 1 ) ; efree ( user_headers ) ; } if ( header_init && context && php_stream_context_get_option ( context , "http" , "content" , & tmpzval ) == SUCCESS && Z_TYPE_PP ( tmpzval ) == IS_STRING && Z_STRLEN_PP ( tmpzval ) > 0 ) { if ( ! ( have_header & HTTP_HEADER_CONTENT_LENGTH ) ) { scratch_len = slprintf ( scratch , scratch_len , "Content-Length:<S2SV_blank>%d\\r\\n" , Z_STRLEN_PP ( tmpzval ) ) ; php_stream_write ( stream , scratch , scratch_len ) ; } if ( ! ( have_header & HTTP_HEADER_TYPE ) ) { php_stream_write ( stream , "Content-Type:<S2SV_blank>application/x-www-form-urlencoded\\r\\n" , sizeof ( "Content-Type:<S2SV_blank>application/x-www-form-urlencoded\\r\\n" ) - 1 ) ; php_error_docref ( NULL TSRMLS_CC , E_NOTICE , "Content-type<S2SV_blank>not<S2SV_blank>specified<S2SV_blank>assuming<S2SV_blank>application/x-www-form-urlencoded" ) ; } php_stream_write ( stream , "\\r\\n" , sizeof ( "\\r\\n" ) - 1 ) ; php_stream_write ( stream , Z_STRVAL_PP ( tmpzval ) , Z_STRLEN_PP ( tmpzval ) ) ; } else { php_stream_write ( stream , "\\r\\n" , sizeof ( "\\r\\n" ) - 1 ) ; } location [ 0 ] = '\\0' ; if ( ! EG ( active_symbol_table ) ) { zend_rebuild_symbol_table ( TSRMLS_C ) ; } if ( header_init ) { zval * ztmp ; MAKE_STD_ZVAL ( ztmp ) ; array_init ( ztmp ) ; ZEND_SET_SYMBOL ( EG ( active_symbol_table ) , "http_response_header" , ztmp ) ; } { zval * * rh ; if ( zend_hash_find ( EG ( active_symbol_table ) , "http_response_header" , sizeof ( "http_response_header" ) , ( void * * ) & rh ) != SUCCESS || Z_TYPE_PP ( rh ) != IS_ARRAY ) { php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , "HTTP<S2SV_blank>request<S2SV_blank>failed,<S2SV_blank>http_response_header<S2SV_blank>overwritten" ) ; goto out ; } response_header = * rh ; Z_ADDREF_P ( response_header ) ; } if ( ! php_stream_eof ( stream ) ) { size_t tmp_line_len ; if ( php_stream_get_line ( stream , tmp_line , sizeof ( tmp_line ) - 1 , & tmp_line_len ) != NULL ) { zval * http_response ; if ( tmp_line_len > 9 ) { response_code = atoi ( tmp_line + 9 ) ; } else { response_code = 0 ; } if ( context && SUCCESS == php_stream_context_get_option ( context , "http" , "ignore_errors" , & tmpzval ) ) { ignore_errors = zend_is_true ( * tmpzval ) ; } if ( ( options & STREAM_ONLY_GET_HEADERS ) || ignore_errors ) { reqok = 1 ; } if ( response_code >= 100 && response_code < 200 ) { while ( ! php_stream_eof ( stream ) && php_stream_get_line ( stream , tmp_line , sizeof ( tmp_line ) - 1 , & tmp_line_len ) != NULL && ( tmp_line_len < sizeof ( "HTTP/1" ) - 1 || strncasecmp ( tmp_line , "HTTP/1" , sizeof ( "HTTP/1" ) - 1 ) ) ) ; if ( tmp_line_len > 9 ) { response_code = atoi ( tmp_line + 9 ) ; } else { response_code = 0 ; } } if ( response_code >= 200 && response_code < 400 ) { reqok = 1 ; } else { switch ( response_code ) { case 403 : php_stream_notify_error ( context , PHP_STREAM_NOTIFY_AUTH_RESULT , tmp_line , response_code ) ; break ; default : if ( ! tmp_line_len ) { tmp_line [ 0 ] = '\\0' ; } php_stream_notify_error ( context , PHP_STREAM_NOTIFY_FAILURE , tmp_line , response_code ) ; } } <S2SV_StartBug> if ( tmp_line [ tmp_line_len - 1 ] == '\\n' ) { <S2SV_EndBug> -- tmp_line_len ; <S2SV_StartBug> if ( tmp_line [ tmp_line_len - 1 ] == '\\r' ) { <S2SV_EndBug> -- tmp_line_len ; } } MAKE_STD_ZVAL ( http_response ) ; ZVAL_STRINGL ( http_response , tmp_line , tmp_line_len , 1 ) ; zend_hash_next_index_insert ( Z_ARRVAL_P ( response_header ) , & http_response , sizeof ( zval * ) , NULL ) ; } } else { php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , "HTTP<S2SV_blank>request<S2SV_blank>failed,<S2SV_blank>unexpected<S2SV_blank>end<S2SV_blank>of<S2SV_blank>socket!" ) ; goto out ; } http_header_line = emalloc ( HTTP_HEADER_BLOCK_SIZE ) ; while ( ! body && ! php_stream_eof ( stream ) ) { size_t http_header_line_length ; if ( php_stream_get_line ( stream , http_header_line , HTTP_HEADER_BLOCK_SIZE , & http_header_line_length ) && * http_header_line != '\\n' && * http_header_line != '\\r' ) { char * e = http_header_line + http_header_line_length - 1 ; if ( * e != '\\n' ) { do { if ( php_stream_get_line ( stream , http_header_line , HTTP_HEADER_BLOCK_SIZE , & http_header_line_length ) == NULL ) { php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , "Failed<S2SV_blank>to<S2SV_blank>read<S2SV_blank>HTTP<S2SV_blank>headers" ) ; goto out ; } e = http_header_line + http_header_line_length - 1 ; } while ( * e != '\\n' ) ; continue ; } while ( * e == '\\n' || * e == '\\r' ) { e -- ; } http_header_line_length = e - http_header_line + 1 ; http_header_line [ http_header_line_length ] = '\\0' ; if ( ! strncasecmp ( http_header_line , "Location:<S2SV_blank>" , 10 ) ) { if ( context && php_stream_context_get_option ( context , "http" , "follow_location" , & tmpzval ) == SUCCESS ) { SEPARATE_ZVAL ( tmpzval ) ; convert_to_long_ex ( tmpzval ) ; follow_location = Z_LVAL_PP ( tmpzval ) ; } else if ( ! ( response_code >= 300 && response_code < 304 || 307 == response_code || 308 == response_code ) ) { follow_location = 0 ; } strlcpy ( location , http_header_line + 10 , sizeof ( location ) ) ; } else if ( ! strncasecmp ( http_header_line , "Content-Type:<S2SV_blank>" , 14 ) ) { php_stream_notify_info ( context , PHP_STREAM_NOTIFY_MIME_TYPE_IS , http_header_line + 14 , 0 ) ; } else if ( ! strncasecmp ( http_header_line , "Content-Length:<S2SV_blank>" , 16 ) ) { file_size = atoi ( http_header_line + 16 ) ; php_stream_notify_file_size ( context , file_size , http_header_line , 0 ) ; } else if ( ! strncasecmp ( http_header_line , "Transfer-Encoding:<S2SV_blank>chunked" , sizeof ( "Transfer-Encoding:<S2SV_blank>chunked" ) ) ) { if ( ! ( options & STREAM_ONLY_GET_HEADERS ) ) { long decode = 1 ; if ( context && php_stream_context_get_option ( context , "http" , "auto_decode" , & tmpzval ) == SUCCESS ) { SEPARATE_ZVAL ( tmpzval ) ; convert_to_boolean ( * tmpzval ) ; decode = Z_LVAL_PP ( tmpzval ) ; } if ( decode ) { transfer_encoding = php_stream_filter_create ( "dechunk" , NULL , php_stream_is_persistent ( stream ) TSRMLS_CC ) ; if ( transfer_encoding ) { continue ; } } } } if ( http_header_line [ 0 ] == '\\0' ) { body = 1 ; } else { zval * http_header ; MAKE_STD_ZVAL ( http_header ) ; ZVAL_STRINGL ( http_header , http_header_line , http_header_line_length , 1 ) ; zend_hash_next_index_insert ( Z_ARRVAL_P ( response_header ) , & http_header , sizeof ( zval * ) , NULL ) ; } } else { break ; } } if ( ! reqok || ( location [ 0 ] != '\\0' && follow_location ) ) { if ( ! follow_location || ( ( ( options & STREAM_ONLY_GET_HEADERS ) || ignore_errors ) && redirect_max <= 1 ) ) { goto out ; } if ( location [ 0 ] != '\\0' ) php_stream_notify_info ( context , PHP_STREAM_NOTIFY_REDIRECTED , location , 0 ) ; php_stream_close ( stream ) ; stream = NULL ; if ( location [ 0 ] != '\\0' ) { char new_path [ HTTP_HEADER_BLOCK_SIZE ] ; char loc_path [ HTTP_HEADER_BLOCK_SIZE ] ; * new_path = '\\0' ; if ( strlen ( location ) < 8 || ( strncasecmp ( location , "http://" , sizeof ( "http://" ) - 1 ) && strncasecmp ( location , "https://" , sizeof ( "https://" ) - 1 ) && strncasecmp ( location , "ftp://" , sizeof ( "ftp://" ) - 1 ) && strncasecmp ( location , "ftps://" , sizeof ( "ftps://" ) - 1 ) ) ) { if ( * location != '/' ) { if ( * ( location + 1 ) != '\\0' && resource -> path ) { char * s = strrchr ( resource -> path , '/' ) ; if ( ! s ) { s = resource -> path ; if ( ! s [ 0 ] ) { efree ( s ) ; s = resource -> path = estrdup ( "/" ) ; } else { * s = '/' ; } } s [ 1 ] = '\\0' ; if ( resource -> path && * ( resource -> path ) == '/' && * ( resource -> path + 1 ) == '\\0' ) { snprintf ( loc_path , sizeof ( loc_path ) - 1 , "%s%s" , resource -> path , location ) ; } else { snprintf ( loc_path , sizeof ( loc_path ) - 1 , "%s/%s" , resource -> path , location ) ; } } else { snprintf ( loc_path , sizeof ( loc_path ) - 1 , "/%s" , location ) ; } } else { strlcpy ( loc_path , location , sizeof ( loc_path ) ) ; } if ( ( use_ssl && resource -> port != 443 ) || ( ! use_ssl && resource -> port != 80 ) ) { snprintf ( new_path , sizeof ( new_path ) - 1 , "%s://%s:%d%s" , resource -> scheme , resource -> host , resource -> port , loc_path ) ; } else { snprintf ( new_path , sizeof ( new_path ) - 1 , "%s://%s%s" , resource -> scheme , resource -> host , loc_path ) ; } } else { strlcpy ( new_path , location , sizeof ( new_path ) ) ; } php_url_free ( resource ) ; if ( ( resource = php_url_parse ( new_path ) ) == NULL ) { php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , "Invalid<S2SV_blank>redirect<S2SV_blank>URL!<S2SV_blank>%s" , new_path ) ; goto out ; } <S2SV_StartBug> # define CHECK_FOR_CNTRL_CHARS ( val ) { if ( val ) { unsigned char * s , * e ; int l ; l = php_url_decode ( val , strlen ( val ) ) ; s = ( unsigned char * ) val ; e = s + l ; while ( s < e ) { if ( iscntrl ( * s ) ) { php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , "Invalid<S2SV_blank>redirect<S2SV_blank>URL!<S2SV_blank>%s" , new_path ) ; goto out ; } s ++ ; } } } <S2SV_EndBug> if ( strncasecmp ( new_path , "http://" , sizeof ( "http://" ) - 1 ) || strncasecmp ( new_path , "https://" , sizeof ( "https://" ) - 1 ) ) { CHECK_FOR_CNTRL_CHARS ( resource -> user ) CHECK_FOR_CNTRL_CHARS ( resource -> pass ) CHECK_FOR_CNTRL_CHARS ( resource -> path ) } stream = php_stream_url_wrap_http_ex ( wrapper , new_path , mode , options , opened_path , context , -- redirect_max , HTTP_WRAPPER_REDIRECTED STREAMS_CC TSRMLS_CC ) ; } else { php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , "HTTP<S2SV_blank>request<S2SV_blank>failed!<S2SV_blank>%s" , tmp_line ) ; } } out : if ( protocol_version ) { efree ( protocol_version ) ; } if ( http_header_line ) { efree ( http_header_line ) ; } if ( scratch ) { efree ( scratch ) ; } if ( resource ) { php_url_free ( resource ) ; } if ( stream ) { if ( header_init ) { stream -> wrapperdata = response_header ; } else { if ( response_header ) { Z_DELREF_P ( response_header ) ; } } php_stream_notify_progress_init ( context , 0 , file_size ) ; if ( options & STREAM_WILL_CAST ) php_stream_set_chunk_size ( stream , chunk_size ) ; stream -> flags |= eol_detect ; stream -> position = 0 ; strlcpy ( stream -> mode , mode , sizeof ( stream -> mode ) ) ; if ( transfer_encoding ) { php_stream_filter_append ( & stream -> readfilters , transfer_encoding ) ; } } else { if ( response_header ) { Z_DELREF_P ( response_header ) ; } if ( transfer_encoding ) { php_stream_filter_free ( transfer_encoding TSRMLS_CC ) ; } } return stream ; }
CWE-400 static void fpm_child_init ( struct fpm_worker_pool_s * wp ) { <S2SV_StartBug> fpm_globals . max_requests = wp -> config -> pm_max_requests ; <S2SV_EndBug> if ( 0 > fpm_stdio_init_child ( wp ) || 0 > fpm_log_init_child ( wp ) || 0 > fpm_status_init_child ( wp ) || 0 > fpm_unix_init_child ( wp ) || 0 > fpm_signals_init_child ( ) || 0 > fpm_env_init_child ( wp ) || 0 > fpm_php_init_child ( wp ) ) { zlog ( ZLOG_ERROR , "[pool<S2SV_blank>%s]<S2SV_blank>child<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>initialize" , wp -> config -> name ) ; exit ( FPM_EXIT_SOFTWARE ) ; } }
CWE-400 int fpm_stdio_init_child ( struct fpm_worker_pool_s * wp ) { # ifdef HAVE_SYSLOG_H if ( fpm_globals . error_log_fd == ZLOG_SYSLOG ) { closelog ( ) ; } else # endif if ( fpm_globals . error_log_fd > 0 ) { close ( fpm_globals . error_log_fd ) ; } fpm_globals . error_log_fd = - 1 ; zlog_set_fd ( - 1 ) ; <S2SV_StartBug> if ( wp -> listening_socket != STDIN_FILENO ) { <S2SV_EndBug> if ( 0 > dup2 ( wp -> listening_socket , STDIN_FILENO ) ) { zlog ( ZLOG_SYSERROR , "failed<S2SV_blank>to<S2SV_blank>init<S2SV_blank>child<S2SV_blank>stdio:<S2SV_blank>dup2()" ) ; return - 1 ; } } return 0 ; }
CWE-20 int main ( int argc , char * * argv ) { mode_t old_umask ; <S2SV_StartBug> cleanup_free char * base_path = NULL ; <S2SV_EndBug> int clone_flags ; char * old_cwd = NULL ; pid_t pid ; int event_fd = - 1 ; int child_wait_fd = - 1 ; int setup_finished_pipe [ ] = { - 1 , - 1 } ; const char * new_cwd ; uid_t ns_uid ; gid_t ns_gid ; struct stat sbuf ; uint64_t val ; int res UNUSED ; cleanup_free char * seccomp_data = NULL ; size_t seccomp_len ; struct sock_fprog seccomp_prog ; cleanup_free char * args_data = NULL ; if ( argc == 2 && ( strcmp ( argv [ 1 ] , "--version" ) == 0 ) ) print_version_and_exit ( ) ; real_uid = getuid ( ) ; real_gid = getgid ( ) ; acquire_privs ( ) ; if ( prctl ( PR_SET_NO_NEW_PRIVS , 1 , 0 , 0 , 0 ) < 0 ) die_with_error ( "prctl(PR_SET_NO_NEW_CAPS)<S2SV_blank>failed" ) ; read_overflowids ( ) ; argv0 = argv [ 0 ] ; if ( isatty ( 1 ) ) host_tty_dev = ttyname ( 1 ) ; argv ++ ; argc -- ; if ( argc == 0 ) usage ( EXIT_FAILURE , stderr ) ; parse_args ( & argc , ( const char * * * ) & argv ) ; args_data = opt_args_data ; opt_args_data = NULL ; if ( ( requested_caps [ 0 ] || requested_caps [ 1 ] ) && is_privileged ) die ( "--cap-add<S2SV_blank>in<S2SV_blank>setuid<S2SV_blank>mode<S2SV_blank>can<S2SV_blank>be<S2SV_blank>used<S2SV_blank>only<S2SV_blank>by<S2SV_blank>root" ) ; if ( opt_userns_block_fd != - 1 && ! opt_unshare_user ) die ( "--userns-block-fd<S2SV_blank>requires<S2SV_blank>--unshare-user" ) ; if ( opt_userns_block_fd != - 1 && opt_info_fd == - 1 ) die ( "--userns-block-fd<S2SV_blank>requires<S2SV_blank>--info-fd" ) ; if ( ! is_privileged && getuid ( ) != 0 ) opt_unshare_user = TRUE ; # ifdef ENABLE_REQUIRE_USERNS if ( is_privileged && getuid ( ) != 0 ) opt_unshare_user = TRUE ; # endif if ( opt_unshare_user_try && stat ( "/proc/self/ns/user" , & sbuf ) == 0 ) { bool disabled = FALSE ; if ( stat ( "/sys/module/user_namespace/parameters/enable" , & sbuf ) == 0 ) { cleanup_free char * enable = NULL ; enable = load_file_at ( AT_FDCWD , "/sys/module/user_namespace/parameters/enable" ) ; if ( enable != NULL && enable [ 0 ] == 'N' ) disabled = TRUE ; } if ( stat ( "/proc/sys/user/max_user_namespaces" , & sbuf ) == 0 ) { cleanup_free char * max_user_ns = NULL ; max_user_ns = load_file_at ( AT_FDCWD , "/proc/sys/user/max_user_namespaces" ) ; if ( max_user_ns != NULL && strcmp ( max_user_ns , "0\\n" ) == 0 ) disabled = TRUE ; } if ( ! disabled ) opt_unshare_user = TRUE ; } if ( argc == 0 ) usage ( EXIT_FAILURE , stderr ) ; __debug__ ( ( "Creating<S2SV_blank>root<S2SV_blank>mount<S2SV_blank>point\\n" ) ) ; if ( opt_sandbox_uid == - 1 ) opt_sandbox_uid = real_uid ; if ( opt_sandbox_gid == - 1 ) opt_sandbox_gid = real_gid ; if ( ! opt_unshare_user && opt_sandbox_uid != real_uid ) die ( "Specifying<S2SV_blank>--uid<S2SV_blank>requires<S2SV_blank>--unshare-user" ) ; if ( ! opt_unshare_user && opt_sandbox_gid != real_gid ) die ( "Specifying<S2SV_blank>--gid<S2SV_blank>requires<S2SV_blank>--unshare-user" ) ; if ( ! opt_unshare_uts && opt_sandbox_hostname != NULL ) die ( "Specifying<S2SV_blank>--hostname<S2SV_blank>requires<S2SV_blank>--unshare-uts" ) ; if ( opt_as_pid_1 && ! opt_unshare_pid ) die ( "Specifying<S2SV_blank>--as-pid-1<S2SV_blank>requires<S2SV_blank>--unshare-pid" ) ; if ( opt_as_pid_1 && lock_files != NULL ) die ( "Specifying<S2SV_blank>--as-pid-1<S2SV_blank>and<S2SV_blank>--lock-file<S2SV_blank>is<S2SV_blank>not<S2SV_blank>permitted" ) ; proc_fd = open ( "/proc" , O_PATH ) ; if ( proc_fd == - 1 ) die_with_error ( "Can\'t<S2SV_blank>open<S2SV_blank>/proc" ) ; <S2SV_StartBug> base_path = xasprintf ( "/run/user/%d/.bubblewrap" , real_uid ) ; <S2SV_EndBug> if ( ensure_dir ( base_path , 0755 ) ) { free ( base_path ) ; base_path = xasprintf ( "/tmp/.bubblewrap-%d" , real_uid ) ; if ( ensure_dir ( base_path , 0755 ) ) die_with_error ( "Creating<S2SV_blank>root<S2SV_blank>mountpoint<S2SV_blank>failed" ) ; } __debug__ ( ( "creating<S2SV_blank>new<S2SV_blank>namespace\\n" ) ) ; if ( opt_unshare_pid && ! opt_as_pid_1 ) { event_fd = eventfd ( 0 , EFD_CLOEXEC | EFD_NONBLOCK ) ; if ( event_fd == - 1 ) die_with_error ( "eventfd()" ) ; } block_sigchild ( ) ; clone_flags = SIGCHLD | CLONE_NEWNS ; if ( opt_unshare_user ) clone_flags |= CLONE_NEWUSER ; if ( opt_unshare_pid ) clone_flags |= CLONE_NEWPID ; if ( opt_unshare_net ) clone_flags |= CLONE_NEWNET ; if ( opt_unshare_ipc ) clone_flags |= CLONE_NEWIPC ; if ( opt_unshare_uts ) clone_flags |= CLONE_NEWUTS ; if ( opt_unshare_cgroup ) { if ( stat ( "/proc/self/ns/cgroup" , & sbuf ) ) { if ( errno == ENOENT ) die ( "Cannot<S2SV_blank>create<S2SV_blank>new<S2SV_blank>cgroup<S2SV_blank>namespace<S2SV_blank>because<S2SV_blank>the<S2SV_blank>kernel<S2SV_blank>does<S2SV_blank>not<S2SV_blank>support<S2SV_blank>it" ) ; else die_with_error ( "stat<S2SV_blank>on<S2SV_blank>/proc/self/ns/cgroup<S2SV_blank>failed" ) ; } clone_flags |= CLONE_NEWCGROUP ; } if ( opt_unshare_cgroup_try ) if ( ! stat ( "/proc/self/ns/cgroup" , & sbuf ) ) clone_flags |= CLONE_NEWCGROUP ; child_wait_fd = eventfd ( 0 , EFD_CLOEXEC ) ; if ( child_wait_fd == - 1 ) die_with_error ( "eventfd()" ) ; if ( opt_json_status_fd != - 1 ) { int ret ; ret = pipe2 ( setup_finished_pipe , O_CLOEXEC ) ; if ( ret == - 1 ) die_with_error ( "pipe2()" ) ; } pid = raw_clone ( clone_flags , NULL ) ; if ( pid == - 1 ) { if ( opt_unshare_user ) { if ( errno == EINVAL ) die ( "Creating<S2SV_blank>new<S2SV_blank>namespace<S2SV_blank>failed,<S2SV_blank>likely<S2SV_blank>because<S2SV_blank>the<S2SV_blank>kernel<S2SV_blank>does<S2SV_blank>not<S2SV_blank>support<S2SV_blank>user<S2SV_blank>namespaces.<S2SV_blank><S2SV_blank>bwrap<S2SV_blank>must<S2SV_blank>be<S2SV_blank>installed<S2SV_blank>setuid<S2SV_blank>on<S2SV_blank>such<S2SV_blank>systems." ) ; else if ( errno == EPERM && ! is_privileged ) die ( "No<S2SV_blank>permissions<S2SV_blank>to<S2SV_blank>creating<S2SV_blank>new<S2SV_blank>namespace,<S2SV_blank>likely<S2SV_blank>because<S2SV_blank>the<S2SV_blank>kernel<S2SV_blank>does<S2SV_blank>not<S2SV_blank>allow<S2SV_blank>non-privileged<S2SV_blank>user<S2SV_blank>namespaces.<S2SV_blank>On<S2SV_blank>e.g.<S2SV_blank>debian<S2SV_blank>this<S2SV_blank>can<S2SV_blank>be<S2SV_blank>enabled<S2SV_blank>with<S2SV_blank>\'sysctl<S2SV_blank>kernel.unprivileged_userns_clone=1\'." ) ; } die_with_error ( "Creating<S2SV_blank>new<S2SV_blank>namespace<S2SV_blank>failed" ) ; } ns_uid = opt_sandbox_uid ; ns_gid = opt_sandbox_gid ; if ( pid != 0 ) { if ( is_privileged && opt_unshare_user && opt_userns_block_fd == - 1 ) { write_uid_gid_map ( ns_uid , real_uid , ns_gid , real_gid , pid , TRUE , opt_needs_devpts ) ; } drop_privs ( FALSE ) ; handle_die_with_parent ( ) ; if ( opt_info_fd != - 1 ) { cleanup_free char * output = xasprintf ( "{\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>\\"child-pid\\":<S2SV_blank>%i\\n}\\n" , pid ) ; dump_info ( opt_info_fd , output , TRUE ) ; close ( opt_info_fd ) ; } if ( opt_json_status_fd != - 1 ) { cleanup_free char * output = xasprintf ( "{<S2SV_blank>\\"child-pid\\":<S2SV_blank>%i<S2SV_blank>}\\n" , pid ) ; dump_info ( opt_json_status_fd , output , TRUE ) ; } if ( opt_userns_block_fd != - 1 ) { char b [ 1 ] ; ( void ) TEMP_FAILURE_RETRY ( read ( opt_userns_block_fd , b , 1 ) ) ; close ( opt_userns_block_fd ) ; } val = 1 ; res = write ( child_wait_fd , & val , 8 ) ; close ( child_wait_fd ) ; return monitor_child ( event_fd , pid , setup_finished_pipe [ 0 ] ) ; } if ( opt_info_fd != - 1 ) close ( opt_info_fd ) ; if ( opt_json_status_fd != - 1 ) close ( opt_json_status_fd ) ; res = read ( child_wait_fd , & val , 8 ) ; close ( child_wait_fd ) ; switch_to_user_with_privs ( ) ; if ( opt_unshare_net ) loopback_setup ( ) ; ns_uid = opt_sandbox_uid ; ns_gid = opt_sandbox_gid ; if ( ! is_privileged && opt_unshare_user && opt_userns_block_fd == - 1 ) { if ( opt_needs_devpts ) { ns_uid = 0 ; ns_gid = 0 ; } write_uid_gid_map ( ns_uid , real_uid , ns_gid , real_gid , - 1 , TRUE , FALSE ) ; } old_umask = umask ( 0 ) ; resolve_symlinks_in_ops ( ) ; if ( mount ( NULL , "/" , NULL , MS_SLAVE | MS_REC , NULL ) < 0 ) die_with_error ( "Failed<S2SV_blank>to<S2SV_blank>make<S2SV_blank>/<S2SV_blank>slave" ) ; if ( mount ( "tmpfs" , base_path , "tmpfs" , MS_NODEV | MS_NOSUID , NULL ) != 0 ) die_with_error ( "Failed<S2SV_blank>to<S2SV_blank>mount<S2SV_blank>tmpfs" ) ; old_cwd = get_current_dir_name ( ) ; if ( chdir ( base_path ) != 0 ) die_with_error ( "chdir<S2SV_blank>base_path" ) ; if ( mkdir ( "newroot" , 0755 ) ) die_with_error ( "Creating<S2SV_blank>newroot<S2SV_blank>failed" ) ; if ( mount ( "newroot" , "newroot" , NULL , MS_MGC_VAL | MS_BIND | MS_REC , NULL ) < 0 ) die_with_error ( "setting<S2SV_blank>up<S2SV_blank>newroot<S2SV_blank>bind" ) ; if ( mkdir ( "oldroot" , 0755 ) ) die_with_error ( "Creating<S2SV_blank>oldroot<S2SV_blank>failed" ) ; if ( pivot_root ( base_path , "oldroot" ) ) die_with_error ( "pivot_root" ) ; if ( chdir ( "/" ) != 0 ) die_with_error ( "chdir<S2SV_blank>/<S2SV_blank>(base<S2SV_blank>path)" ) ; if ( is_privileged ) { pid_t child ; int privsep_sockets [ 2 ] ; if ( socketpair ( AF_UNIX , SOCK_SEQPACKET | SOCK_CLOEXEC , 0 , privsep_sockets ) != 0 ) die_with_error ( "Can\'t<S2SV_blank>create<S2SV_blank>privsep<S2SV_blank>socket" ) ; child = fork ( ) ; if ( child == - 1 ) die_with_error ( "Can\'t<S2SV_blank>fork<S2SV_blank>unprivileged<S2SV_blank>helper" ) ; if ( child == 0 ) { drop_privs ( FALSE ) ; close ( privsep_sockets [ 0 ] ) ; setup_newroot ( opt_unshare_pid , privsep_sockets [ 1 ] ) ; exit ( 0 ) ; } else { int status ; uint32_t buffer [ 2048 ] ; uint32_t op , flags ; const char * arg1 , * arg2 ; cleanup_fd int unpriv_socket = - 1 ; unpriv_socket = privsep_sockets [ 0 ] ; close ( privsep_sockets [ 1 ] ) ; do { op = read_priv_sec_op ( unpriv_socket , buffer , sizeof ( buffer ) , & flags , & arg1 , & arg2 ) ; privileged_op ( - 1 , op , flags , arg1 , arg2 ) ; if ( write ( unpriv_socket , buffer , 1 ) != 1 ) die ( "Can\'t<S2SV_blank>write<S2SV_blank>to<S2SV_blank>op_socket" ) ; } while ( op != PRIV_SEP_OP_DONE ) ; waitpid ( child , & status , 0 ) ; } } else { setup_newroot ( opt_unshare_pid , - 1 ) ; } close_ops_fd ( ) ; if ( mount ( "oldroot" , "oldroot" , NULL , MS_REC | MS_PRIVATE , NULL ) != 0 ) die_with_error ( "Failed<S2SV_blank>to<S2SV_blank>make<S2SV_blank>old<S2SV_blank>root<S2SV_blank>rprivate" ) ; if ( umount2 ( "oldroot" , MNT_DETACH ) ) die_with_error ( "unmount<S2SV_blank>old<S2SV_blank>root" ) ; { cleanup_fd int oldrootfd = open ( "/" , O_DIRECTORY | O_RDONLY ) ; if ( oldrootfd < 0 ) die_with_error ( "can\'t<S2SV_blank>open<S2SV_blank>/" ) ; if ( chdir ( "/newroot" ) != 0 ) die_with_error ( "chdir<S2SV_blank>/newroot" ) ; if ( pivot_root ( "." , "." ) != 0 ) die_with_error ( "pivot_root(/newroot)" ) ; if ( fchdir ( oldrootfd ) < 0 ) die_with_error ( "fchdir<S2SV_blank>to<S2SV_blank>oldroot" ) ; if ( umount2 ( "." , MNT_DETACH ) < 0 ) die_with_error ( "umount<S2SV_blank>old<S2SV_blank>root" ) ; if ( chdir ( "/" ) != 0 ) die_with_error ( "chdir<S2SV_blank>/" ) ; } if ( opt_unshare_user && ( ns_uid != opt_sandbox_uid || ns_gid != opt_sandbox_gid ) && opt_userns_block_fd == - 1 ) { if ( unshare ( CLONE_NEWUSER ) ) die_with_error ( "unshare<S2SV_blank>user<S2SV_blank>ns" ) ; write_uid_gid_map ( opt_sandbox_uid , ns_uid , opt_sandbox_gid , ns_gid , - 1 , FALSE , FALSE ) ; } drop_privs ( ! is_privileged ) ; if ( opt_block_fd != - 1 ) { char b [ 1 ] ; ( void ) TEMP_FAILURE_RETRY ( read ( opt_block_fd , b , 1 ) ) ; close ( opt_block_fd ) ; } if ( opt_seccomp_fd != - 1 ) { seccomp_data = load_file_data ( opt_seccomp_fd , & seccomp_len ) ; if ( seccomp_data == NULL ) die_with_error ( "Can\'t<S2SV_blank>read<S2SV_blank>seccomp<S2SV_blank>data" ) ; if ( seccomp_len % 8 != 0 ) die ( "Invalid<S2SV_blank>seccomp<S2SV_blank>data,<S2SV_blank>must<S2SV_blank>be<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>8" ) ; seccomp_prog . len = seccomp_len / 8 ; seccomp_prog . filter = ( struct sock_filter * ) seccomp_data ; close ( opt_seccomp_fd ) ; } umask ( old_umask ) ; new_cwd = "/" ; if ( opt_chdir_path ) { if ( chdir ( opt_chdir_path ) ) die_with_error ( "Can\'t<S2SV_blank>chdir<S2SV_blank>to<S2SV_blank>%s" , opt_chdir_path ) ; new_cwd = opt_chdir_path ; } else if ( chdir ( old_cwd ) == 0 ) { new_cwd = old_cwd ; } else { const char * home = getenv ( "HOME" ) ; if ( home != NULL && chdir ( home ) == 0 ) new_cwd = home ; } xsetenv ( "PWD" , new_cwd , 1 ) ; free ( old_cwd ) ; if ( opt_new_session && setsid ( ) == ( pid_t ) - 1 ) die_with_error ( "setsid" ) ; if ( label_exec ( opt_exec_label ) == - 1 ) die_with_error ( "label_exec<S2SV_blank>%s" , argv [ 0 ] ) ; __debug__ ( ( "forking<S2SV_blank>for<S2SV_blank>child\\n" ) ) ; if ( ! opt_as_pid_1 && ( opt_unshare_pid || lock_files != NULL || opt_sync_fd != - 1 ) ) { pid = fork ( ) ; if ( pid == - 1 ) die_with_error ( "Can\'t<S2SV_blank>fork<S2SV_blank>for<S2SV_blank>pid<S2SV_blank>1" ) ; if ( pid != 0 ) { drop_all_caps ( FALSE ) ; { int dont_close [ 3 ] ; int j = 0 ; if ( event_fd != - 1 ) dont_close [ j ++ ] = event_fd ; if ( opt_sync_fd != - 1 ) dont_close [ j ++ ] = opt_sync_fd ; dont_close [ j ++ ] = - 1 ; fdwalk ( proc_fd , close_extra_fds , dont_close ) ; } return do_init ( event_fd , pid , seccomp_data != NULL ? & seccomp_prog : NULL ) ; } } __debug__ ( ( "launch<S2SV_blank>executable<S2SV_blank>%s\\n" , argv [ 0 ] ) ) ; if ( proc_fd != - 1 ) close ( proc_fd ) ; if ( ! opt_as_pid_1 ) { if ( opt_sync_fd != - 1 ) close ( opt_sync_fd ) ; } unblock_sigchild ( ) ; handle_die_with_parent ( ) ; if ( ! is_privileged ) set_ambient_capabilities ( ) ; if ( seccomp_data != NULL && prctl ( PR_SET_SECCOMP , SECCOMP_MODE_FILTER , & seccomp_prog ) != 0 ) die_with_error ( "prctl(PR_SET_SECCOMP)" ) ; if ( setup_finished_pipe [ 1 ] != - 1 ) { char data = 0 ; res = write_to_fd ( setup_finished_pipe [ 1 ] , & data , 1 ) ; } if ( execvp ( argv [ 0 ] , argv ) == - 1 ) { if ( setup_finished_pipe [ 1 ] != - 1 ) { int saved_errno = errno ; char data = 0 ; res = write_to_fd ( setup_finished_pipe [ 1 ] , & data , 1 ) ; errno = saved_errno ; } die_with_error ( "execvp<S2SV_blank>%s" , argv [ 0 ] ) ; } return 0 ; }
CWE-125 <S2SV_StartBug> INST_HANDLER ( lds ) { <S2SV_EndBug> int d = ( ( buf [ 0 ] >> 4 ) & 0xf ) | ( ( buf [ 1 ] & 0x1 ) << 4 ) ; int k = ( buf [ 3 ] << 8 ) | buf [ 2 ] ; op -> ptr = k ; __generic_ld_st ( op , "ram" , 0 , 1 , 0 , k , 0 ) ; ESIL_A ( "r%d,=," , d ) ; }
CWE-125 static void process_constructors ( RBinFile * bf , RList * ret , int bits ) { RList * secs = sections ( bf ) ; RListIter * iter ; RBinSection * sec ; int i , type ; r_list_foreach ( secs , iter , sec ) { type = - 1 ; if ( ! strcmp ( sec -> name , ".fini_array" ) ) { type = R_BIN_ENTRY_TYPE_FINI ; } else if ( ! strcmp ( sec -> name , ".init_array" ) ) { type = R_BIN_ENTRY_TYPE_INIT ; } else if ( ! strcmp ( sec -> name , ".preinit_array" ) ) { type = R_BIN_ENTRY_TYPE_PREINIT ; } if ( type != - 1 ) { ut8 * buf = calloc ( sec -> size , 1 ) ; if ( ! buf ) { continue ; } ( void ) r_buf_read_at ( bf -> buf , sec -> paddr , buf , sec -> size ) ; if ( bits == 32 ) { <S2SV_StartBug> for ( i = 0 ; i < sec -> size ; i += 4 ) { <S2SV_EndBug> ut32 addr32 = r_read_le32 ( buf + i ) ; if ( addr32 ) { RBinAddr * ba = newEntry ( sec -> paddr + i , ( ut64 ) addr32 , type , bits ) ; r_list_append ( ret , ba ) ; } } } else { <S2SV_StartBug> for ( i = 0 ; i < sec -> size ; i += 8 ) { <S2SV_EndBug> ut64 addr64 = r_read_le64 ( buf + i ) ; if ( addr64 ) { RBinAddr * ba = newEntry ( sec -> paddr + i , addr64 , type , bits ) ; r_list_append ( ret , ba ) ; } } } free ( buf ) ; } } r_list_free ( secs ) ; }
CWE-125 static int java_switch_op ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * data , int len ) { ut8 op_byte = data [ 0 ] ; ut64 offset = addr - java_get_method_start ( ) ; ut8 pos = ( offset + 1 ) % 4 ? 1 + 4 - ( offset + 1 ) % 4 : 1 ; if ( op_byte == 0xaa ) { <S2SV_StartBug> if ( pos + 8 > len ) { <S2SV_EndBug> return op -> size ; } <S2SV_StartBug> int min_val = ( ut32 ) ( UINT ( data , pos + 4 ) ) , <S2SV_EndBug> max_val = ( ut32 ) ( UINT ( data , pos + 8 ) ) ; ut32 default_loc = ( ut32 ) ( UINT ( data , pos ) ) , cur_case = 0 ; op -> switch_op = r_anal_switch_op_new ( addr , min_val , default_loc ) ; RAnalCaseOp * caseop = NULL ; pos += 12 ; if ( max_val > min_val && ( ( max_val - min_val ) < ( UT16_MAX / 4 ) ) ) { for ( cur_case = 0 ; cur_case <= max_val - min_val ; pos += 4 , cur_case ++ ) { if ( pos + 4 >= len ) { break ; } int offset = ( int ) ( ut32 ) ( R_BIN_JAVA_UINT ( data , pos ) ) ; caseop = r_anal_switch_op_add_case ( op -> switch_op , addr + pos , cur_case + min_val , addr + offset ) ; if ( caseop ) { caseop -> bb_ref_to = addr + offset ; caseop -> bb_ref_from = addr ; } } } else { eprintf ( "Invalid<S2SV_blank>switch<S2SV_blank>boundaries<S2SV_blank>at<S2SV_blank>0x%" PFMT64x "\\n" , addr ) ; } } op -> size = pos ; return op -> size ; }
CWE-125 INST_HANDLER ( sbrx ) { int b = buf [ 0 ] & 0x7 ; int r = ( ( buf [ 0 ] >> 4 ) & 0xf ) | ( ( buf [ 1 ] & 0x01 ) << 4 ) ; <S2SV_StartBug> RAnalOp next_op ; <S2SV_EndBug> avr_op_analyze ( anal , & next_op , op -> addr + op -> size , buf + op -> size , len - op -> size , cpu ) ; r_strbuf_fini ( & next_op . esil ) ; op -> jump = op -> addr + next_op . size + 2 ; op -> cycles = 1 ; ESIL_A ( "%d,1,<<,r%d,&," , b , r ) ; ESIL_A ( ( buf [ 1 ] & 0xe ) == 0xc ? "!," : "!,!," ) ; ESIL_A ( "?{,%" PFMT64d ",pc,=,}," , op -> jump ) ; }
CWE-125 static int string_scan_range ( RList * list , RBinFile * bf , int min , const ut64 from , const ut64 to , int type ) { ut8 tmp [ R_STRING_SCAN_BUFFER_SIZE ] ; ut64 str_start , needle = from ; int count = 0 , i , rc , runes ; int str_type = R_STRING_TYPE_DETECT ; if ( type == - 1 ) { type = R_STRING_TYPE_DETECT ; } if ( from >= to ) { eprintf ( "Invalid<S2SV_blank>range<S2SV_blank>to<S2SV_blank>find<S2SV_blank>strings<S2SV_blank>0x%llx<S2SV_blank>..<S2SV_blank>0x%llx\\n" , from , to ) ; return - 1 ; } <S2SV_StartBug> ut8 * buf = calloc ( to - from , 1 ) ; <S2SV_EndBug> if ( ! buf || ! min ) { return - 1 ; } <S2SV_StartBug> r_buf_read_at ( bf -> buf , from , buf , to - from ) ; <S2SV_EndBug> while ( needle < to ) { rc = r_utf8_decode ( buf + needle - from , to - needle , NULL ) ; if ( ! rc ) { needle ++ ; continue ; } if ( type == R_STRING_TYPE_DETECT ) { char * w = ( char * ) buf + needle + rc - from ; <S2SV_StartBug> if ( ( to - needle ) > 5 ) { <S2SV_EndBug> <S2SV_StartBug> bool is_wide32 = needle + rc + 2 < to && ! w [ 0 ] && ! w [ 1 ] && ! w [ 2 ] && w [ 3 ] && ! w [ 4 ] ; <S2SV_EndBug> if ( is_wide32 ) { str_type = R_STRING_TYPE_WIDE32 ; } else { bool is_wide = needle + rc + 2 < to && ! w [ 0 ] && w [ 1 ] && ! w [ 2 ] ; str_type = is_wide ? R_STRING_TYPE_WIDE : R_STRING_TYPE_ASCII ; } } else { str_type = R_STRING_TYPE_ASCII ; } } else { str_type = type ; } runes = 0 ; str_start = needle ; for ( rc = i = 0 ; i < sizeof ( tmp ) - 3 && needle < to ; i += rc ) { RRune r = { 0 } ; if ( str_type == R_STRING_TYPE_WIDE32 ) { rc = r_utf32le_decode ( buf + needle - from , to - needle , & r ) ; if ( rc ) { rc = 4 ; } } else if ( str_type == R_STRING_TYPE_WIDE ) { rc = r_utf16le_decode ( buf + needle - from , to - needle , & r ) ; if ( rc == 1 ) { rc = 2 ; } } else { rc = r_utf8_decode ( buf + needle - from , to - needle , & r ) ; if ( rc > 1 ) { str_type = R_STRING_TYPE_UTF8 ; } } if ( ! rc ) { needle ++ ; break ; } needle += rc ; if ( r_isprint ( r ) && r != '\\\\' ) { if ( str_type == R_STRING_TYPE_WIDE32 ) { if ( r == 0xff ) { r = 0 ; } } rc = r_utf8_encode ( & tmp [ i ] , r ) ; runes ++ ; } else if ( r && r < 0x100 && strchr ( "\\b\\v\\f\\n\\r\\t\\a\\033\\\\" , ( char ) r ) ) { if ( ( i + 32 ) < sizeof ( tmp ) && r < 93 ) { tmp [ i + 0 ] = '\\\\' ; tmp [ i + 1 ] = "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>abtnvfr<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>e<S2SV_blank><S2SV_blank>" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" "<S2SV_blank><S2SV_blank>\\\\" [ r ] ; } else { break ; } rc = 2 ; runes ++ ; } else { break ; } } tmp [ i ++ ] = '\\0' ; if ( runes >= min ) { if ( str_type == R_STRING_TYPE_ASCII ) { int j ; for ( j = 0 ; j < i ; j ++ ) { char ch = tmp [ j ] ; if ( ch != '\\n' && ch != '\\r' && ch != '\\t' ) { if ( ! IS_PRINTABLE ( tmp [ j ] ) ) { continue ; } } } } RBinString * bs = R_NEW0 ( RBinString ) ; if ( ! bs ) { break ; } bs -> type = str_type ; bs -> length = runes ; bs -> size = needle - str_start ; bs -> ordinal = count ++ ; switch ( str_type ) { case R_STRING_TYPE_WIDE : if ( str_start - from > 1 ) { const ut8 * p = buf + str_start - 2 - from ; if ( p [ 0 ] == 0xff && p [ 1 ] == 0xfe ) { str_start -= 2 ; } } break ; case R_STRING_TYPE_WIDE32 : if ( str_start - from > 3 ) { const ut8 * p = buf + str_start - 4 - from ; if ( p [ 0 ] == 0xff && p [ 1 ] == 0xfe ) { str_start -= 4 ; } } break ; } bs -> paddr = bs -> vaddr = str_start ; bs -> string = r_str_ndup ( ( const char * ) tmp , i ) ; if ( list ) { r_list_append ( list , bs ) ; } else { print_string ( bs , bf ) ; r_bin_string_free ( bs ) ; } } } free ( buf ) ; return count ; }
CWE-125 static bool r_bin_mdmp_init_directory ( struct r_bin_mdmp_obj * obj ) { int i ; <S2SV_StartBug> ut8 * directory_base ; <S2SV_EndBug> struct minidump_directory * entry ; directory_base = obj -> b -> buf + obj -> hdr -> stream_directory_rva ; sdb_num_set ( obj -> kv , "mdmp_directory.offset" , obj -> hdr -> stream_directory_rva , 0 ) ; sdb_set ( obj -> kv , "mdmp_directory.format" , "[4]E?<S2SV_blank>" "(mdmp_stream_type)StreamType<S2SV_blank>" "(mdmp_location_descriptor)Location" , 0 ) ; <S2SV_StartBug> for ( i = 0 ; i < ( int ) obj -> hdr -> number_of_streams ; i ++ ) { <S2SV_EndBug> <S2SV_StartBug> entry = ( struct minidump_directory * ) ( directory_base + ( i * sizeof ( struct minidump_directory ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> r_bin_mdmp_init_directory_entry ( obj , entry ) ; <S2SV_EndBug> } return true ; }
CWE-125 static int get_debug_info ( struct PE_ ( r_bin_pe_obj_t ) * bin , PE_ ( image_debug_directory_entry ) * dbg_dir_entry , ut8 * dbg_data , int dbg_data_len , SDebugInfo * res ) { # define SIZEOF_FILE_NAME 255 int i = 0 ; const char * basename ; if ( ! dbg_data ) { return 0 ; } switch ( dbg_dir_entry -> Type ) { case IMAGE_DEBUG_TYPE_CODEVIEW : if ( ! strncmp ( ( char * ) dbg_data , "RSDS" , 4 ) ) { SCV_RSDS_HEADER rsds_hdr ; init_rsdr_hdr ( & rsds_hdr ) ; if ( ! get_rsds ( dbg_data , dbg_data_len , & rsds_hdr ) ) { bprintf ( "Warning:<S2SV_blank>Cannot<S2SV_blank>read<S2SV_blank>PE<S2SV_blank>debug<S2SV_blank>info\\n" ) ; return 0 ; } snprintf ( res -> guidstr , GUIDSTR_LEN , "%08x%04x%04x%02x%02x%02x%02x%02x%02x%02x%02x%x" , rsds_hdr . guid . data1 , rsds_hdr . guid . data2 , rsds_hdr . guid . data3 , rsds_hdr . guid . data4 [ 0 ] , rsds_hdr . guid . data4 [ 1 ] , rsds_hdr . guid . data4 [ 2 ] , rsds_hdr . guid . data4 [ 3 ] , rsds_hdr . guid . data4 [ 4 ] , rsds_hdr . guid . data4 [ 5 ] , rsds_hdr . guid . data4 [ 6 ] , rsds_hdr . guid . data4 [ 7 ] , rsds_hdr . age ) ; basename = r_file_basename ( ( char * ) rsds_hdr . file_name ) ; strncpy ( res -> file_name , ( const char * ) basename , sizeof ( res -> file_name ) ) ; res -> file_name [ sizeof ( res -> file_name ) - 1 ] = 0 ; rsds_hdr . free ( ( struct SCV_RSDS_HEADER * ) & rsds_hdr ) ; } else if ( strncmp ( ( const char * ) dbg_data , "NB10" , 4 ) == 0 ) { <S2SV_StartBug> SCV_NB10_HEADER nb10_hdr ; <S2SV_EndBug> init_cv_nb10_header ( & nb10_hdr ) ; get_nb10 ( dbg_data , & nb10_hdr ) ; snprintf ( res -> guidstr , sizeof ( res -> guidstr ) , <S2SV_StartBug> "%x%x" , nb10_hdr . timestamp , nb10_hdr . age ) ; <S2SV_EndBug> strncpy ( res -> file_name , ( const char * ) <S2SV_StartBug> nb10_hdr . file_name , sizeof ( res -> file_name ) - 1 ) ; <S2SV_EndBug> res -> file_name [ sizeof ( res -> file_name ) - 1 ] = 0 ; nb10_hdr . free ( ( struct SCV_NB10_HEADER * ) & nb10_hdr ) ; } else { bprintf ( "CodeView<S2SV_blank>section<S2SV_blank>not<S2SV_blank>NB10<S2SV_blank>or<S2SV_blank>RSDS\\n" ) ; return 0 ; } break ; default : return 0 ; } while ( i < 33 ) { res -> guidstr [ i ] = toupper ( ( int ) res -> guidstr [ i ] ) ; i ++ ; } return 1 ; }
CWE-125 static void get_nb10 ( ut8 * dbg_data , SCV_NB10_HEADER * res ) { const int nb10sz = 16 ; <S2SV_StartBug> memcpy ( res , dbg_data , nb10sz ) ; <S2SV_EndBug> res -> file_name = ( ut8 * ) strdup ( ( const char * ) dbg_data + nb10sz ) ; }
CWE-125 struct r_bin_dyldcache_lib_t * r_bin_dyldcache_extract ( struct r_bin_dyldcache_obj_t * bin , int idx , int * nlib ) { ut64 liboff , linkedit_offset ; ut64 dyld_vmbase ; ut32 addend = 0 ; struct r_bin_dyldcache_lib_t * ret = NULL ; struct dyld_cache_image_info * image_infos = NULL ; struct mach_header * mh ; ut8 * data , * cmdptr ; int cmd , libsz = 0 ; RBuffer * dbuf ; char * libname ; if ( ! bin ) { return NULL ; } if ( bin -> size < 1 ) { eprintf ( "Empty<S2SV_blank>file?<S2SV_blank>(%s)\\n" , bin -> file ? bin -> file : "(null)" ) ; return NULL ; } if ( bin -> nlibs < 0 || idx < 0 || idx >= bin -> nlibs ) { return NULL ; } * nlib = bin -> nlibs ; ret = R_NEW0 ( struct r_bin_dyldcache_lib_t ) ; if ( ! ret ) { <S2SV_StartBug> perror ( "malloc<S2SV_blank>(ret)" ) ; <S2SV_EndBug> return NULL ; } if ( bin -> hdr . startaddr > bin -> size ) { eprintf ( "corrupted<S2SV_blank>dyldcache" ) ; free ( ret ) ; return NULL ; } if ( bin -> hdr . startaddr > bin -> size || bin -> hdr . baseaddroff > bin -> size ) { eprintf ( "corrupted<S2SV_blank>dyldcache" ) ; free ( ret ) ; return NULL ; } <S2SV_StartBug> image_infos = ( struct dyld_cache_image_info * ) ( bin -> b -> buf + bin -> hdr . startaddr ) ; <S2SV_EndBug> <S2SV_StartBug> dyld_vmbase = * ( ut64 * ) ( bin -> b -> buf + bin -> hdr . baseaddroff ) ; <S2SV_EndBug> liboff = image_infos [ idx ] . address - dyld_vmbase ; if ( liboff > bin -> size ) { eprintf ( "Corrupted<S2SV_blank>file\\n" ) ; free ( ret ) ; return NULL ; } ret -> offset = liboff ; <S2SV_StartBug> if ( image_infos [ idx ] . pathFileOffset > bin -> size ) { <S2SV_EndBug> <S2SV_StartBug> eprintf ( "corrupted<S2SV_blank>file\\n" ) ; <S2SV_EndBug> free ( ret ) ; return NULL ; } <S2SV_StartBug> libname = ( char * ) ( bin -> b -> buf + image_infos [ idx ] . pathFileOffset ) ; <S2SV_EndBug> data = bin -> b -> buf + liboff ; mh = ( struct mach_header * ) data ; if ( mh -> magic != MH_MAGIC && mh -> magic != MH_MAGIC_64 ) { if ( mh -> magic == 0xbebafeca ) { eprintf ( "FAT<S2SV_blank>Binary\\n" ) ; } eprintf ( "Not<S2SV_blank>mach-o\\n" ) ; free ( ret ) ; return NULL ; } if ( ! ( dbuf = r_buf_new ( ) ) ) { eprintf ( "new<S2SV_blank>(dbuf)\\n" ) ; free ( ret ) ; return NULL ; } addend = mh -> magic == MH_MAGIC ? sizeof ( struct mach_header ) : sizeof ( struct mach_header_64 ) ; r_buf_set_bytes ( dbuf , data , addend ) ; cmdptr = data + addend ; for ( cmd = 0 ; cmd < mh -> ncmds ; cmd ++ ) { struct load_command * lc = ( struct load_command * ) cmdptr ; r_buf_append_bytes ( dbuf , ( ut8 * ) lc , lc -> cmdsize ) ; cmdptr += lc -> cmdsize ; } cmdptr = data + addend ; for ( cmd = linkedit_offset = 0 ; cmd < mh -> ncmds ; cmd ++ ) { struct load_command * lc = ( struct load_command * ) cmdptr ; cmdptr += lc -> cmdsize ; switch ( lc -> cmd ) { case LC_SEGMENT : { struct segment_command * seg = ( struct segment_command * ) lc ; int t = seg -> filesize ; if ( seg -> fileoff + seg -> filesize > bin -> size || seg -> fileoff > bin -> size ) { eprintf ( "malformed<S2SV_blank>dyldcache\\n" ) ; free ( ret ) ; r_buf_free ( dbuf ) ; return NULL ; } r_buf_append_bytes ( dbuf , bin -> b -> buf + seg -> fileoff , t ) ; r_bin_dyldcache_apply_patch ( dbuf , dbuf -> length , ( ut64 ) ( ( size_t ) & seg -> fileoff - ( size_t ) data ) ) ; int sect_offset = seg -> fileoff - libsz ; libsz = dbuf -> length ; if ( ! strcmp ( seg -> segname , "__LINKEDIT" ) ) { linkedit_offset = sect_offset ; } if ( seg -> nsects > 0 ) { struct section * sects = ( struct section * ) ( ( ut8 * ) seg + sizeof ( struct segment_command ) ) ; int nsect ; for ( nsect = 0 ; nsect < seg -> nsects ; nsect ++ ) { if ( sects [ nsect ] . offset > libsz ) { r_bin_dyldcache_apply_patch ( dbuf , sects [ nsect ] . offset - sect_offset , ( ut64 ) ( ( size_t ) & sects [ nsect ] . offset - ( size_t ) data ) ) ; } } } } break ; case LC_SYMTAB : { struct symtab_command * st = ( struct symtab_command * ) lc ; NZ_OFFSET ( st -> symoff ) ; NZ_OFFSET ( st -> stroff ) ; } break ; case LC_DYSYMTAB : { struct dysymtab_command * st = ( struct dysymtab_command * ) lc ; NZ_OFFSET ( st -> tocoff ) ; NZ_OFFSET ( st -> modtaboff ) ; NZ_OFFSET ( st -> extrefsymoff ) ; NZ_OFFSET ( st -> indirectsymoff ) ; NZ_OFFSET ( st -> extreloff ) ; NZ_OFFSET ( st -> locreloff ) ; } break ; case LC_DYLD_INFO : case LC_DYLD_INFO_ONLY : { struct dyld_info_command * st = ( struct dyld_info_command * ) lc ; NZ_OFFSET ( st -> rebase_off ) ; NZ_OFFSET ( st -> bind_off ) ; NZ_OFFSET ( st -> weak_bind_off ) ; NZ_OFFSET ( st -> lazy_bind_off ) ; NZ_OFFSET ( st -> export_off ) ; } break ; } } ret -> b = dbuf ; strncpy ( ret -> path , libname , sizeof ( ret -> path ) - 1 ) ; ret -> size = libsz ; return ret ; }
CWE-125 struct r_bin_dyldcache_obj_t * r_bin_dyldcache_from_bytes_new ( const ut8 * buf , ut64 size ) { <S2SV_StartBug> struct r_bin_dyldcache_obj_t * bin ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( bin = malloc ( sizeof ( struct r_bin_dyldcache_obj_t ) ) ) ) { <S2SV_EndBug> return NULL ; } <S2SV_StartBug> memset ( bin , 0 , sizeof ( struct r_bin_dyldcache_obj_t ) ) ; <S2SV_EndBug> if ( ! buf ) { return r_bin_dyldcache_free ( bin ) ; } bin -> b = r_buf_new ( ) ; <S2SV_StartBug> if ( ! r_buf_set_bytes ( bin -> b , buf , size ) ) { <S2SV_EndBug> return r_bin_dyldcache_free ( bin ) ; } if ( ! r_bin_dyldcache_init ( bin ) ) { return r_bin_dyldcache_free ( bin ) ; } bin -> size = size ; return bin ; }
CWE-125 static int sh_op ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * data , int len ) { ut8 op_MSB , op_LSB ; int ret ; <S2SV_StartBug> if ( ! data ) <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> memset ( op , '\\0' , sizeof ( RAnalOp ) ) ; op -> addr = addr ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> jump = op -> fail = - 1 ; op -> ptr = op -> val = - 1 ; op -> size = 2 ; op_MSB = anal -> big_endian ? data [ 0 ] : data [ 1 ] ; op_LSB = anal -> big_endian ? data [ 1 ] : data [ 0 ] ; ret = first_nibble_decode [ ( op_MSB >> 4 ) & 0x0F ] ( anal , op , ( ut16 ) ( op_MSB << 8 | op_LSB ) ) ; return ret ; }
CWE-125 static int parseOperand ( RAsm * a , const char * str , Operand * op , bool isrepop ) { size_t pos , nextpos = 0 ; x86newTokenType last_type ; int size_token = 1 ; bool explicit_size = false ; int reg_index = 0 ; op -> type = 0 ; while ( size_token ) { pos = nextpos ; last_type = getToken ( str , & pos , & nextpos ) ; if ( ! r_str_ncasecmp ( str + pos , "ptr" , 3 ) ) { continue ; } else if ( ! r_str_ncasecmp ( str + pos , "byte" , 4 ) ) { op -> type |= OT_MEMORY | OT_BYTE ; op -> dest_size = OT_BYTE ; explicit_size = true ; } else if ( ! r_str_ncasecmp ( str + pos , "word" , 4 ) ) { op -> type |= OT_MEMORY | OT_WORD ; op -> dest_size = OT_WORD ; explicit_size = true ; } else if ( ! r_str_ncasecmp ( str + pos , "dword" , 5 ) ) { op -> type |= OT_MEMORY | OT_DWORD ; op -> dest_size = OT_DWORD ; explicit_size = true ; } else if ( ! r_str_ncasecmp ( str + pos , "qword" , 5 ) ) { op -> type |= OT_MEMORY | OT_QWORD ; op -> dest_size = OT_QWORD ; explicit_size = true ; } else if ( ! r_str_ncasecmp ( str + pos , "oword" , 5 ) ) { op -> type |= OT_MEMORY | OT_OWORD ; op -> dest_size = OT_OWORD ; explicit_size = true ; } else if ( ! r_str_ncasecmp ( str + pos , "tbyte" , 5 ) ) { op -> type |= OT_MEMORY | OT_TBYTE ; op -> dest_size = OT_TBYTE ; explicit_size = true ; } else { size_token = 0 ; } } if ( str [ pos ] == '[' ) { if ( ! op -> type ) { op -> type = OT_MEMORY ; } op -> offset = op -> scale [ 0 ] = op -> scale [ 1 ] = 0 ; ut64 temp = 1 ; Register reg = X86R_UNDEFINED ; bool first_reg = true ; while ( str [ pos ] != ']' ) { if ( pos > nextpos ) { break ; } pos = nextpos ; if ( ! str [ pos ] ) { break ; } last_type = getToken ( str , & pos , & nextpos ) ; if ( last_type == TT_SPECIAL ) { if ( str [ pos ] == '+' || str [ pos ] == '-' || str [ pos ] == ']' ) { if ( reg != X86R_UNDEFINED ) { <S2SV_StartBug> op -> regs [ reg_index ] = reg ; <S2SV_EndBug> op -> scale [ reg_index ] = temp ; <S2SV_StartBug> ++ reg_index ; <S2SV_EndBug> } else { <S2SV_StartBug> op -> offset += temp ; <S2SV_EndBug> <S2SV_StartBug> op -> regs [ reg_index ] = X86R_UNDEFINED ; <S2SV_EndBug> } temp = 1 ; reg = X86R_UNDEFINED ; } else if ( str [ pos ] == '*' ) { } } else if ( last_type == TT_WORD ) { ut32 reg_type = 0 ; if ( reg != X86R_UNDEFINED ) { op -> type = 0 ; } nextpos = pos ; reg = parseReg ( a , str , & nextpos , & reg_type ) ; if ( first_reg ) { op -> extended = false ; if ( reg > 8 ) { op -> extended = true ; op -> reg = reg - 9 ; } first_reg = false ; } else if ( reg > 8 ) { op -> reg = reg - 9 ; } if ( reg_type & OT_REGTYPE & OT_SEGMENTREG ) { op -> reg = reg ; op -> type = reg_type ; parse_segment_offset ( a , str , & nextpos , op , reg_index ) ; return nextpos ; } if ( ! explicit_size ) { op -> type |= reg_type ; } op -> reg_size = reg_type ; op -> explicit_size = explicit_size ; if ( ! ( reg_type & OT_GPREG ) ) { op -> type = 0 ; } } else { char * p = strchr ( str , '+' ) ; op -> offset_sign = 1 ; if ( ! p ) { p = strchr ( str , '-' ) ; if ( p ) { op -> offset_sign = - 1 ; } } char * plus = strchr ( str , '+' ) ; char * minus = strchr ( str , '-' ) ; char * closeB = strchr ( str , ']' ) ; if ( plus && minus && plus < closeB && minus < closeB ) { op -> offset_sign = - 1 ; } char * tmp ; tmp = malloc ( strlen ( str + pos ) + 1 ) ; strcpy ( tmp , str + pos ) ; strtok ( tmp , "+-" ) ; st64 read = getnum ( a , tmp ) ; free ( tmp ) ; temp *= read ; } } } else if ( last_type == TT_WORD ) { nextpos = pos ; RFlagItem * flag ; if ( isrepop ) { op -> is_good_flag = false ; strncpy ( op -> rep_op , str , MAX_REPOP_LENGTH - 1 ) ; op -> rep_op [ MAX_REPOP_LENGTH - 1 ] = '\\0' ; return nextpos ; } op -> reg = parseReg ( a , str , & nextpos , & op -> type ) ; op -> extended = false ; if ( op -> reg > 8 ) { op -> extended = true ; op -> reg -= 9 ; } if ( op -> type & OT_REGTYPE & OT_SEGMENTREG ) { parse_segment_offset ( a , str , & nextpos , op , reg_index ) ; return nextpos ; } if ( op -> reg == X86R_UNDEFINED ) { op -> is_good_flag = false ; if ( a -> num && a -> num -> value == 0 ) { return nextpos ; } op -> type = OT_CONSTANT ; RCore * core = a -> num ? ( RCore * ) ( a -> num -> userptr ) : NULL ; if ( core && ( flag = r_flag_get ( core -> flags , str ) ) ) { op -> is_good_flag = true ; } char * p = strchr ( str , '-' ) ; if ( p ) { op -> sign = - 1 ; str = ++ p ; } op -> immediate = getnum ( a , str ) ; } else if ( op -> reg < X86R_UNDEFINED ) { strncpy ( op -> rep_op , str , MAX_REPOP_LENGTH - 1 ) ; op -> rep_op [ MAX_REPOP_LENGTH - 1 ] = '\\0' ; } } else { op -> type = OT_CONSTANT ; op -> sign = 1 ; char * p = strchr ( str , '-' ) ; if ( p ) { op -> sign = - 1 ; str = ++ p ; } op -> immediate = getnum ( a , str ) ; } return nextpos ; }
CWE-416 INST_HANDLER ( cpse ) { int r = ( buf [ 0 ] & 0xf ) | ( ( buf [ 1 ] & 0x2 ) << 3 ) ; int d = ( ( buf [ 0 ] >> 4 ) & 0xf ) | ( ( buf [ 1 ] & 0x1 ) << 4 ) ; <S2SV_StartBug> RAnalOp next_op ; <S2SV_EndBug> avr_op_analyze ( anal , & next_op , op -> addr + op -> size , buf + op -> size , len - op -> size , cpu ) ; r_strbuf_fini ( & next_op . esil ) ; op -> jump = op -> addr + next_op . size + 2 ; op -> cycles = 1 ; ESIL_A ( "r%d,r%d,^,!," , r , d ) ; ESIL_A ( "?{,%" PFMT64d ",pc,=,}," , op -> jump ) ; }
CWE-416 static void cmd_anal_esil ( RCore * core , const char * input ) { RAnalEsil * esil = core -> anal -> esil ; ut64 addr = core -> offset ; ut64 adr ; char * n , * n1 ; int off ; int stacksize = r_config_get_i ( core -> config , "esil.stack.depth" ) ; int iotrap = r_config_get_i ( core -> config , "esil.iotrap" ) ; int romem = r_config_get_i ( core -> config , "esil.romem" ) ; int stats = r_config_get_i ( core -> config , "esil.stats" ) ; int noNULL = r_config_get_i ( core -> config , "esil.noNULL" ) ; ut64 until_addr = UT64_MAX ; unsigned int addrsize = r_config_get_i ( core -> config , "esil.addr.size" ) ; const char * until_expr = NULL ; RAnalOp * op ; switch ( input [ 0 ] ) { case 'p' : switch ( input [ 1 ] ) { case 'c' : if ( input [ 2 ] == '<S2SV_blank>' ) { r_core_cmdf ( core , "ar<S2SV_blank>PC=%s" , input + 3 ) ; r_core_cmd0 ( core , ".ar*" ) ; } else { eprintf ( "Missing<S2SV_blank>argument\\n" ) ; } break ; case 0 : r_anal_pin_list ( core -> anal ) ; break ; case '-' : if ( input [ 2 ] ) addr = r_num_math ( core -> num , input + 2 ) ; r_anal_pin_unset ( core -> anal , addr ) ; break ; case '<S2SV_blank>' : r_anal_pin ( core -> anal , addr , input + 2 ) ; break ; default : r_core_cmd_help ( core , help_msg_aep ) ; break ; } break ; case 'r' : cmd_anal_reg ( core , input + 1 ) ; break ; case '*' : if ( core -> anal -> esil ) { r_cons_printf ( "trap:<S2SV_blank>%d\\n" , core -> anal -> esil -> trap ) ; r_cons_printf ( "trap-code:<S2SV_blank>%d\\n" , core -> anal -> esil -> trap_code ) ; } else { eprintf ( "esil<S2SV_blank>vm<S2SV_blank>not<S2SV_blank>initialized.<S2SV_blank>run<S2SV_blank>`aei`\\n" ) ; } break ; case '<S2SV_blank>' : if ( ! esil ) { if ( ! ( core -> anal -> esil = esil = r_anal_esil_new ( stacksize , iotrap , addrsize ) ) ) return ; } r_anal_esil_setup ( esil , core -> anal , romem , stats , noNULL ) ; r_anal_esil_set_pc ( esil , core -> offset ) ; r_anal_esil_parse ( esil , input + 1 ) ; r_anal_esil_dumpstack ( esil ) ; r_anal_esil_stack_free ( esil ) ; break ; case 's' : switch ( input [ 1 ] ) { case '?' : eprintf ( "See:<S2SV_blank>ae?~aes\\n" ) ; break ; case 'l' : { ut64 pc = r_debug_reg_get ( core -> dbg , "PC" ) ; RAnalOp * op = r_core_anal_op ( core , pc ) ; if ( ! op ) { break ; } r_core_esil_step ( core , UT64_MAX , NULL , NULL ) ; r_debug_reg_set ( core -> dbg , "PC" , pc + op -> size ) ; r_anal_esil_set_pc ( esil , pc + op -> size ) ; r_core_cmd0 ( core , ".ar*" ) ; } break ; case 'b' : if ( ! r_core_esil_step_back ( core ) ) { eprintf ( "cannnot<S2SV_blank>step<S2SV_blank>back\\n" ) ; } r_core_cmd0 ( core , ".ar*" ) ; break ; case 'u' : if ( input [ 2 ] == 'e' ) { until_expr = input + 3 ; } else { until_addr = r_num_math ( core -> num , input + 2 ) ; } r_core_esil_step ( core , until_addr , until_expr , NULL ) ; r_core_cmd0 ( core , ".ar*" ) ; break ; case 'o' : op = r_core_anal_op ( core , r_reg_getv ( core -> anal -> reg , r_reg_get_name ( core -> anal -> reg , R_REG_NAME_PC ) ) ) ; if ( op && op -> type == R_ANAL_OP_TYPE_CALL ) { until_addr = op -> addr + op -> size ; } r_core_esil_step ( core , until_addr , until_expr , NULL ) ; r_anal_op_free ( op ) ; r_core_cmd0 ( core , ".ar*" ) ; break ; case 'p' : n = strchr ( input , '<S2SV_blank>' ) ; n1 = n ? strchr ( n + 1 , '<S2SV_blank>' ) : NULL ; if ( ( ! n || ! n1 ) || ( ! ( n + 1 ) || ! ( n1 + 1 ) ) ) { eprintf ( "aesp<S2SV_blank>[offset]<S2SV_blank>[num]\\n" ) ; break ; } adr = r_num_math ( core -> num , n + 1 ) ; off = r_num_math ( core -> num , n1 + 1 ) ; cmd_aespc ( core , adr , off ) ; break ; case '<S2SV_blank>' : n = strchr ( input , '<S2SV_blank>' ) ; if ( ! ( n + 1 ) ) { r_core_esil_step ( core , until_addr , until_expr , NULL ) ; break ; } off = r_num_math ( core -> num , n + 1 ) ; cmd_aespc ( core , - 1 , off ) ; break ; default : r_core_esil_step ( core , until_addr , until_expr , NULL ) ; r_core_cmd0 ( core , ".ar*" ) ; break ; } break ; case 'c' : if ( input [ 1 ] == '?' ) { r_core_cmd_help ( core , help_msg_aec ) ; } else if ( input [ 1 ] == 's' ) { const char * pc = r_reg_get_name ( core -> anal -> reg , R_REG_NAME_PC ) ; ut64 newaddr ; int ret ; for ( ; ; ) { op = r_core_anal_op ( core , addr ) ; if ( ! op ) { break ; } if ( op -> type == R_ANAL_OP_TYPE_SWI ) { eprintf ( "syscall<S2SV_blank>at<S2SV_blank>0x%08" PFMT64x "\\n" , addr ) ; break ; } if ( op -> type == R_ANAL_OP_TYPE_TRAP ) { eprintf ( "trap<S2SV_blank>at<S2SV_blank>0x%08" PFMT64x "\\n" , addr ) ; break ; } ret = r_core_esil_step ( core , UT64_MAX , NULL , NULL ) ; r_anal_op_free ( op ) ; op = NULL ; if ( core -> anal -> esil -> trap || core -> anal -> esil -> trap_code ) { break ; } if ( ! ret ) break ; r_core_cmd0 ( core , ".ar*" ) ; newaddr = r_num_get ( core -> num , pc ) ; if ( addr == newaddr ) { addr ++ ; break ; } else { addr = newaddr ; } } if ( op ) { r_anal_op_free ( op ) ; } } else { if ( input [ 1 ] == 'u' && input [ 2 ] == 'e' ) until_expr = input + 3 ; else if ( input [ 1 ] == 'u' ) until_addr = r_num_math ( core -> num , input + 2 ) ; else until_expr = "0" ; r_core_esil_step ( core , until_addr , until_expr , NULL ) ; r_core_cmd0 ( core , ".ar*" ) ; } break ; case 'i' : switch ( input [ 1 ] ) { case 's' : case 'm' : cmd_esil_mem ( core , input + 2 ) ; break ; case 'p' : r_core_cmd0 ( core , "ar<S2SV_blank>PC=$$" ) ; break ; case '?' : cmd_esil_mem ( core , "?" ) ; break ; case '-' : if ( esil ) { sdb_reset ( esil -> stats ) ; } r_anal_esil_free ( esil ) ; core -> anal -> esil = NULL ; break ; case 0 : r_anal_esil_free ( esil ) ; { const char * pc = r_reg_get_name ( core -> anal -> reg , R_REG_NAME_PC ) ; if ( r_reg_getv ( core -> anal -> reg , pc ) == 0LL ) { r_core_cmd0 ( core , "ar<S2SV_blank>PC=$$" ) ; } } if ( ! ( esil = core -> anal -> esil = r_anal_esil_new ( stacksize , iotrap , addrsize ) ) ) { return ; } r_anal_esil_setup ( esil , core -> anal , romem , stats , noNULL ) ; esil -> verbose = ( int ) r_config_get_i ( core -> config , "esil.verbose" ) ; { const char * s = r_config_get ( core -> config , "cmd.esil.intr" ) ; if ( s ) { char * my = strdup ( s ) ; if ( my ) { r_config_set ( core -> config , "cmd.esil.intr" , my ) ; free ( my ) ; } } } break ; } break ; case 'k' : switch ( input [ 1 ] ) { case '\\0' : input = "123*" ; case '<S2SV_blank>' : if ( esil && esil -> stats ) { char * out = sdb_querys ( esil -> stats , NULL , 0 , input + 2 ) ; if ( out ) { r_cons_println ( out ) ; free ( out ) ; } } else { eprintf ( "esil.stats<S2SV_blank>is<S2SV_blank>empty.<S2SV_blank>Run<S2SV_blank>\'aei\'\\n" ) ; } break ; case '-' : if ( esil ) { sdb_reset ( esil -> stats ) ; } break ; } break ; case 'f' : { RListIter * iter ; RAnalBlock * bb ; RAnalFunction * fcn = r_anal_get_fcn_in ( core -> anal , core -> offset , R_ANAL_FCN_TYPE_FCN | R_ANAL_FCN_TYPE_SYM ) ; if ( fcn ) { r_list_foreach ( fcn -> bbs , iter , bb ) { ut64 pc = bb -> addr ; ut64 end = bb -> addr + bb -> size ; RAnalOp op ; ut8 * buf ; int ret , bbs = end - pc ; if ( bbs < 1 || bbs > 0xfffff ) { eprintf ( "Invalid<S2SV_blank>block<S2SV_blank>size\\n" ) ; } buf = calloc ( 1 , bbs + 1 ) ; r_io_read_at ( core -> io , pc , buf , bbs ) ; int left ; while ( pc < end ) { left = R_MIN ( end - pc , 32 ) ; r_asm_set_pc ( core -> assembler , pc ) ; ret = r_anal_op ( core -> anal , & op , addr , buf , left , R_ANAL_OP_MASK_ALL ) ; if ( ret ) { r_reg_set_value_by_role ( core -> anal -> reg , R_REG_NAME_PC , pc ) ; r_anal_esil_parse ( esil , R_STRBUF_SAFEGET ( & op . esil ) ) ; r_anal_esil_dumpstack ( esil ) ; r_anal_esil_stack_free ( esil ) ; pc += op . size ; } else { pc += 4 ; } } } } else { eprintf ( "Cannot<S2SV_blank>find<S2SV_blank>function<S2SV_blank>at<S2SV_blank>0x%08" PFMT64x "\\n" , core -> offset ) ; } } break ; case 't' : switch ( input [ 1 ] ) { case 'r' : { RAnalEsil * esil = r_anal_esil_new ( stacksize , iotrap , addrsize ) ; <S2SV_StartBug> if ( ! esil ) <S2SV_EndBug> return ; r_anal_esil_to_reil_setup ( esil , core -> anal , romem , stats ) ; r_anal_esil_set_pc ( esil , core -> offset ) ; r_anal_esil_parse ( esil , input + 2 ) ; r_anal_esil_dumpstack ( esil ) ; r_anal_esil_free ( esil ) ; break ; } case 's' : switch ( input [ 2 ] ) { case 0 : r_anal_esil_session_list ( esil ) ; break ; case '+' : r_anal_esil_session_add ( esil ) ; break ; default : r_core_cmd_help ( core , help_msg_aets ) ; break ; } break ; default : eprintf ( "Unknown<S2SV_blank>command.<S2SV_blank>Use<S2SV_blank>`aetr`.\\n" ) ; break ; } break ; case 'A' : if ( input [ 1 ] == '?' ) { r_core_cmd_help ( core , help_msg_aea ) ; } else if ( input [ 1 ] == 'r' ) { cmd_aea ( core , 1 + ( 1 << 1 ) , core -> offset , r_num_math ( core -> num , input + 2 ) ) ; } else if ( input [ 1 ] == 'w' ) { cmd_aea ( core , 1 + ( 1 << 2 ) , core -> offset , r_num_math ( core -> num , input + 2 ) ) ; } else if ( input [ 1 ] == 'n' ) { cmd_aea ( core , 1 + ( 1 << 3 ) , core -> offset , r_num_math ( core -> num , input + 2 ) ) ; } else if ( input [ 1 ] == 'j' ) { cmd_aea ( core , 1 + ( 1 << 4 ) , core -> offset , r_num_math ( core -> num , input + 2 ) ) ; } else if ( input [ 1 ] == '*' ) { cmd_aea ( core , 1 + ( 1 << 5 ) , core -> offset , r_num_math ( core -> num , input + 2 ) ) ; } else if ( input [ 1 ] == 'f' ) { RAnalFunction * fcn = r_anal_get_fcn_in ( core -> anal , core -> offset , - 1 ) ; if ( fcn ) { cmd_aea ( core , 1 , fcn -> addr , r_anal_fcn_size ( fcn ) ) ; } } else { cmd_aea ( core , 1 , core -> offset , ( int ) r_num_math ( core -> num , input + 2 ) ) ; } break ; case 'a' : if ( input [ 1 ] == '?' ) { r_core_cmd_help ( core , help_msg_aea ) ; } else if ( input [ 1 ] == 'r' ) { cmd_aea ( core , 1 << 1 , core -> offset , r_num_math ( core -> num , input + 2 ) ) ; } else if ( input [ 1 ] == 'w' ) { cmd_aea ( core , 1 << 2 , core -> offset , r_num_math ( core -> num , input + 2 ) ) ; } else if ( input [ 1 ] == 'n' ) { cmd_aea ( core , 1 << 3 , core -> offset , r_num_math ( core -> num , input + 2 ) ) ; } else if ( input [ 1 ] == 'j' ) { cmd_aea ( core , 1 << 4 , core -> offset , r_num_math ( core -> num , input + 2 ) ) ; } else if ( input [ 1 ] == '*' ) { cmd_aea ( core , 1 << 5 , core -> offset , r_num_math ( core -> num , input + 2 ) ) ; } else if ( input [ 1 ] == 'f' ) { RAnalFunction * fcn = r_anal_get_fcn_in ( core -> anal , core -> offset , - 1 ) ; if ( fcn ) { switch ( input [ 2 ] ) { case 'j' : cmd_aea ( core , 1 << 4 , fcn -> addr , r_anal_fcn_size ( fcn ) ) ; break ; default : cmd_aea ( core , 1 , fcn -> addr , r_anal_fcn_size ( fcn ) ) ; break ; } break ; } } else { const char * arg = input [ 1 ] ? input + 2 : "" ; ut64 len = r_num_math ( core -> num , arg ) ; cmd_aea ( core , 0 , core -> offset , len ) ; } break ; case 'x' : { char * hex ; int ret , bufsz ; input = r_str_trim_ro ( input + 1 ) ; hex = strdup ( input ) ; if ( ! hex ) { break ; } RAnalOp aop = R_EMPTY ; bufsz = r_hex_str2bin ( hex , ( ut8 * ) hex ) ; ret = r_anal_op ( core -> anal , & aop , core -> offset , ( const ut8 * ) hex , bufsz , R_ANAL_OP_MASK_ALL ) ; if ( ret > 0 ) { const char * str = R_STRBUF_SAFEGET ( & aop . esil ) ; char * str2 = r_str_newf ( "<S2SV_blank>%s" , str ) ; cmd_anal_esil ( core , str2 ) ; free ( str2 ) ; } r_anal_op_fini ( & aop ) ; break ; } case '?' : if ( input [ 1 ] == '?' ) { r_core_cmd_help ( core , help_detail_ae ) ; break ; } default : r_core_cmd_help ( core , help_msg_ae ) ; break ; } }
CWE-125 static void core_anal_bytes ( RCore * core , const ut8 * buf , int len , int nops , int fmt ) { int stacksize = r_config_get_i ( core -> config , "esil.stack.depth" ) ; bool iotrap = r_config_get_i ( core -> config , "esil.iotrap" ) ; bool romem = r_config_get_i ( core -> config , "esil.romem" ) ; bool stats = r_config_get_i ( core -> config , "esil.stats" ) ; bool be = core -> print -> big_endian ; bool use_color = core -> print -> flags & R_PRINT_FLAGS_COLOR ; core -> parser -> relsub = r_config_get_i ( core -> config , "asm.relsub" ) ; int ret , i , j , idx , size ; const char * color = "" ; const char * esilstr ; const char * opexstr ; RAnalHint * hint ; RAnalEsil * esil = NULL ; RAsmOp asmop ; RAnalOp op = { 0 } ; ut64 addr ; bool isFirst = true ; unsigned int addrsize = r_config_get_i ( core -> config , "esil.addr.size" ) ; int totalsize = 0 ; if ( use_color ) { color = core -> cons -> pal . label ; } switch ( fmt ) { case 'j' : r_cons_printf ( "[" ) ; break ; case 'r' : esil = r_anal_esil_new ( stacksize , iotrap , addrsize ) ; if ( ! esil ) { return ; } r_anal_esil_to_reil_setup ( esil , core -> anal , romem , stats ) ; r_anal_esil_set_pc ( esil , core -> offset ) ; break ; } for ( i = idx = ret = 0 ; idx < len && ( ! nops || ( nops && i < nops ) ) ; i ++ , idx += ret ) { addr = core -> offset + idx ; hint = r_anal_hint_get ( core -> anal , addr ) ; r_asm_set_pc ( core -> assembler , addr ) ; ( void ) r_asm_disassemble ( core -> assembler , & asmop , buf + idx , len - idx ) ; ret = r_anal_op ( core -> anal , & op , core -> offset + idx , buf + idx , len - idx , R_ANAL_OP_MASK_ESIL ) ; esilstr = R_STRBUF_SAFEGET ( & op . esil ) ; opexstr = R_STRBUF_SAFEGET ( & op . opex ) ; char * mnem = strdup ( r_asm_op_get_asm ( & asmop ) ) ; char * sp = strchr ( mnem , '<S2SV_blank>' ) ; if ( sp ) { * sp = 0 ; if ( op . prefix ) { char * arg = strdup ( sp + 1 ) ; char * sp = strchr ( arg , '<S2SV_blank>' ) ; if ( sp ) { * sp = 0 ; } free ( mnem ) ; mnem = arg ; } } if ( ret < 1 && fmt != 'd' ) { eprintf ( "Oops<S2SV_blank>at<S2SV_blank>0x%08" PFMT64x "<S2SV_blank>(" , core -> offset + idx ) ; for ( i = idx , j = 0 ; i < core -> blocksize && j < 3 ; ++ i , ++ j ) { eprintf ( "%02x<S2SV_blank>" , buf [ i ] ) ; } eprintf ( "...)\\n" ) ; free ( mnem ) ; break ; } size = ( hint && hint -> size ) ? hint -> size : op . size ; if ( fmt == 'd' ) { char * opname = strdup ( r_asm_op_get_asm ( & asmop ) ) ; if ( opname ) { r_str_split ( opname , '<S2SV_blank>' ) ; char * d = r_asm_describe ( core -> assembler , opname ) ; if ( d && * d ) { r_cons_printf ( "%s:<S2SV_blank>%s\\n" , opname , d ) ; free ( d ) ; } else { eprintf ( "Unknown<S2SV_blank>opcode\\n" ) ; } free ( opname ) ; } } else if ( fmt == 'e' ) { if ( * esilstr ) { if ( use_color ) { r_cons_printf ( "%s0x%" PFMT64x Color_RESET "<S2SV_blank>%s\\n" , color , core -> offset + idx , esilstr ) ; } else { r_cons_printf ( "0x%" PFMT64x "<S2SV_blank>%s\\n" , core -> offset + idx , esilstr ) ; } } } else if ( fmt == 's' ) { totalsize += op . size ; } else if ( fmt == 'r' ) { if ( * esilstr ) { if ( use_color ) { r_cons_printf ( "%s0x%" PFMT64x Color_RESET "\\n" , color , core -> offset + idx ) ; } else { r_cons_printf ( "0x%" PFMT64x "\\n" , core -> offset + idx ) ; } r_anal_esil_parse ( esil , esilstr ) ; r_anal_esil_dumpstack ( esil ) ; r_anal_esil_stack_free ( esil ) ; } } else if ( fmt == 'j' ) { if ( isFirst ) { isFirst = false ; } else { r_cons_print ( "," ) ; } r_cons_printf ( "{\\"opcode\\":\\"%s\\"," , r_asm_op_get_asm ( & asmop ) ) ; { char strsub [ 128 ] = { 0 } ; r_parse_varsub ( core -> parser , NULL , core -> offset + idx , asmop . size , r_asm_op_get_asm ( & asmop ) , strsub , sizeof ( strsub ) ) ; { ut64 killme = UT64_MAX ; if ( r_io_read_i ( core -> io , op . ptr , & killme , op . refptr , be ) ) { core -> parser -> relsub_addr = killme ; } } char * p = strdup ( strsub ) ; if ( p ) { r_parse_filter ( core -> parser , addr , core -> flags , p , strsub , sizeof ( strsub ) , be ) ; free ( p ) ; } r_cons_printf ( "\\"disasm\\":\\"%s\\"," , strsub ) ; } r_cons_printf ( "\\"mnemonic\\":\\"%s\\"," , mnem ) ; if ( hint && hint -> opcode ) { r_cons_printf ( "\\"ophint\\":\\"%s\\"," , hint -> opcode ) ; } r_cons_printf ( "\\"sign\\":%s," , r_str_bool ( op . sign ) ) ; r_cons_printf ( "\\"prefix\\":%" PFMT64u "," , op . prefix ) ; r_cons_printf ( "\\"id\\":%d," , op . id ) ; if ( opexstr && * opexstr ) { r_cons_printf ( "\\"opex\\":%s," , opexstr ) ; } r_cons_printf ( "\\"addr\\":%" PFMT64u "," , core -> offset + idx ) ; r_cons_printf ( "\\"bytes\\":\\"" ) ; for ( j = 0 ; j < size ; j ++ ) { r_cons_printf ( "%02x" , buf [ j + idx ] ) ; } r_cons_printf ( "\\"," ) ; if ( op . val != UT64_MAX ) { r_cons_printf ( "\\"val\\":<S2SV_blank>%" PFMT64u "," , op . val ) ; } if ( op . ptr != UT64_MAX ) { r_cons_printf ( "\\"ptr\\":<S2SV_blank>%" PFMT64u "," , op . ptr ) ; } r_cons_printf ( "\\"size\\":<S2SV_blank>%d," , size ) ; r_cons_printf ( "\\"type\\":<S2SV_blank>\\"%s\\"," , r_anal_optype_to_string ( op . type ) ) ; if ( op . reg ) { r_cons_printf ( "\\"reg\\":<S2SV_blank>\\"%s\\"," , op . reg ) ; } if ( op . ireg ) { r_cons_printf ( "\\"ireg\\":<S2SV_blank>\\"%s\\"," , op . ireg ) ; } if ( op . scale ) { r_cons_printf ( "\\"scale\\":%d," , op . scale ) ; } if ( hint && hint -> esil ) { r_cons_printf ( "\\"esil\\":<S2SV_blank>\\"%s\\"," , hint -> esil ) ; } else if ( * esilstr ) { r_cons_printf ( "\\"esil\\":<S2SV_blank>\\"%s\\"," , esilstr ) ; } if ( hint && hint -> jump != UT64_MAX ) { op . jump = hint -> jump ; } if ( op . jump != UT64_MAX ) { r_cons_printf ( "\\"jump\\":%" PFMT64u "," , op . jump ) ; } if ( hint && hint -> fail != UT64_MAX ) { op . fail = hint -> fail ; } if ( op . refptr != - 1 ) { r_cons_printf ( "\\"refptr\\":%d," , op . refptr ) ; } if ( op . fail != UT64_MAX ) { r_cons_printf ( "\\"fail\\":%" PFMT64u "," , op . fail ) ; } r_cons_printf ( "\\"cycles\\":%d," , op . cycles ) ; if ( op . failcycles ) { r_cons_printf ( "\\"failcycles\\":%d," , op . failcycles ) ; } r_cons_printf ( "\\"delay\\":%d," , op . delay ) ; { const char * p = r_anal_stackop_tostring ( op . stackop ) ; if ( p && * p && strcmp ( p , "null" ) ) r_cons_printf ( "\\"stack\\":\\"%s\\"," , p ) ; } if ( op . stackptr ) { r_cons_printf ( "\\"stackptr\\":%d," , op . stackptr ) ; } { const char * arg = ( op . type & R_ANAL_OP_TYPE_COND ) ? r_anal_cond_tostring ( op . cond ) : NULL ; if ( arg ) { r_cons_printf ( "\\"cond\\":\\"%s\\"," , arg ) ; } } r_cons_printf ( "\\"family\\":\\"%s\\"}" , r_anal_op_family_to_string ( op . family ) ) ; } else { # define printline ( k , fmt , arg ) { if ( use_color ) r_cons_printf ( "%s%s:<S2SV_blank>" Color_RESET , color , k ) ; else r_cons_printf ( "%s:<S2SV_blank>" , k ) ; if ( fmt ) r_cons_printf ( fmt , arg ) ; } printline ( "address" , "0x%" PFMT64x "\\n" , core -> offset + idx ) ; printline ( "opcode" , "%s\\n" , r_asm_op_get_asm ( & asmop ) ) ; printline ( "mnemonic" , "%s\\n" , mnem ) ; if ( hint ) { if ( hint -> opcode ) { printline ( "ophint" , "%s\\n" , hint -> opcode ) ; } # if 0 if ( hint -> addr != UT64_MAX ) { printline ( "addr" , "0x%08" PFMT64x "\\n" , ( hint -> addr + idx ) ) ; } # endif } printline ( "prefix" , "%" PFMT64u "\\n" , op . prefix ) ; printline ( "id" , "%d\\n" , op . id ) ; # if 0 if ( opexstr && * opexstr ) { printline ( "opex" , "%s\\n" , opexstr ) ; } # endif printline ( "bytes" , NULL , 0 ) ; <S2SV_StartBug> for ( j = 0 ; j < size ; j ++ ) { <S2SV_EndBug> <S2SV_StartBug> r_cons_printf ( "%02x" , buf [ j + idx ] ) ; <S2SV_EndBug> } r_cons_newline ( ) ; <S2SV_StartBug> if ( op . val != UT64_MAX ) <S2SV_EndBug> printline ( "val" , "0x%08" PFMT64x "\\n" , op . val ) ; <S2SV_StartBug> if ( op . ptr != UT64_MAX ) <S2SV_EndBug> <S2SV_StartBug> printline ( "ptr" , "0x%08" PFMT64x "\\n" , op . ptr ) ; <S2SV_EndBug> <S2SV_StartBug> if ( op . refptr != - 1 ) <S2SV_EndBug> <S2SV_StartBug> printline ( "refptr" , "%d\\n" , op . refptr ) ; <S2SV_EndBug> printline ( "size" , "%d\\n" , size ) ; printline ( "sign" , "%s\\n" , r_str_bool ( op . sign ) ) ; printline ( "type" , "%s\\n" , r_anal_optype_to_string ( op . type ) ) ; printline ( "cycles" , "%d\\n" , op . cycles ) ; if ( op . failcycles ) { printline ( "failcycles" , "%d\\n" , op . failcycles ) ; } { const char * t2 = r_anal_optype_to_string ( op . type2 ) ; if ( t2 && strcmp ( t2 , "null" ) ) { printline ( "type2" , "%s\\n" , t2 ) ; } } if ( op . reg ) { printline ( "reg" , "%s\\n" , op . reg ) ; } if ( op . ireg ) { printline ( "ireg" , "%s\\n" , op . ireg ) ; } if ( op . scale ) { printline ( "scale" , "%d\\n" , op . scale ) ; } if ( hint && hint -> esil ) { printline ( "esil" , "%s\\n" , hint -> esil ) ; } else if ( * esilstr ) { printline ( "esil" , "%s\\n" , esilstr ) ; } if ( hint && hint -> jump != UT64_MAX ) { op . jump = hint -> jump ; } if ( op . jump != UT64_MAX ) { printline ( "jump" , "0x%08" PFMT64x "\\n" , op . jump ) ; } if ( op . direction != 0 ) { const char * dir = op . direction == 1 ? "read" : op . direction == 2 ? "write" : op . direction == 4 ? "exec" : op . direction == 8 ? "ref" : "none" ; printline ( "direction" , "%s\\n" , dir ) ; } if ( hint && hint -> fail != UT64_MAX ) { op . fail = hint -> fail ; } if ( op . fail != UT64_MAX ) { printline ( "fail" , "0x%08" PFMT64x "\\n" , op . fail ) ; } if ( op . delay ) { printline ( "delay" , "%d\\n" , op . delay ) ; } printline ( "stack" , "%s\\n" , r_anal_stackop_tostring ( op . stackop ) ) ; { const char * arg = ( op . type & R_ANAL_OP_TYPE_COND ) ? r_anal_cond_tostring ( op . cond ) : NULL ; if ( arg ) { printline ( "cond" , "%s\\n" , arg ) ; } } printline ( "family" , "%s\\n" , r_anal_op_family_to_string ( op . family ) ) ; printline ( "stackop" , "%s\\n" , r_anal_stackop_tostring ( op . stackop ) ) ; if ( op . stackptr ) { printline ( "stackptr" , "%" PFMT64u "\\n" , op . stackptr ) ; } } free ( mnem ) ; r_anal_hint_free ( hint ) ; r_anal_op_fini ( & op ) ; } r_anal_op_fini ( & op ) ; if ( fmt == 'j' ) { r_cons_printf ( "]" ) ; r_cons_newline ( ) ; } else if ( fmt == 's' ) { r_cons_printf ( "%d\\n" , totalsize ) ; } r_anal_esil_free ( esil ) ; }
CWE-125 static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { <S2SV_StartBug> OPCODE_DESC * opcode_desc ; <S2SV_EndBug> ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; int fail ; char * t ; memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , "" ) ; opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , "1,$" ) ; return NULL ; }
CWE-125 static int _6502_op ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * data , int len ) { char addrbuf [ 64 ] ; const int buffsize = sizeof ( addrbuf ) - 1 ; memset ( op , '\\0' , sizeof ( RAnalOp ) ) ; op -> size = snes_op_get_size ( 1 , 1 , & snes_op [ data [ 0 ] ] ) ; op -> addr = addr ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> id = data [ 0 ] ; r_strbuf_init ( & op -> esil ) ; switch ( data [ 0 ] ) { case 0x02 : case 0x03 : case 0x04 : case 0x07 : case 0x0b : case 0x0c : case 0x0f : case 0x12 : case 0x13 : case 0x14 : case 0x17 : case 0x1a : case 0x1b : case 0x1c : case 0x1f : case 0x22 : case 0x23 : case 0x27 : case 0x2b : case 0x2f : case 0x32 : case 0x33 : case 0x34 : case 0x37 : case 0x3a : case 0x3b : case 0x3c : case 0x3f : case 0x42 : case 0x43 : case 0x44 : case 0x47 : case 0x4b : case 0x4f : case 0x52 : case 0x53 : case 0x54 : case 0x57 : case 0x5a : case 0x5b : case 0x5c : case 0x5f : case 0x62 : case 0x63 : case 0x64 : case 0x67 : case 0x6b : case 0x6f : case 0x72 : case 0x73 : case 0x74 : case 0x77 : case 0x7a : case 0x7b : case 0x7c : case 0x7f : case 0x80 : case 0x82 : case 0x83 : case 0x87 : case 0x89 : case 0x8b : case 0x8f : case 0x92 : case 0x93 : case 0x97 : case 0x9b : case 0x9c : case 0x9e : case 0x9f : case 0xa3 : case 0xa7 : case 0xab : case 0xaf : case 0xb2 : case 0xb3 : case 0xb7 : case 0xbb : case 0xbf : case 0xc2 : case 0xc3 : case 0xc7 : case 0xcb : case 0xcf : case 0xd2 : case 0xd3 : case 0xd4 : case 0xd7 : case 0xda : case 0xdb : case 0xdc : case 0xdf : case 0xe2 : case 0xe3 : case 0xe7 : case 0xeb : case 0xef : case 0xf2 : case 0xf3 : case 0xf4 : case 0xf7 : case 0xfa : case 0xfb : case 0xfc : case 0xff : op -> size = 1 ; op -> type = R_ANAL_OP_TYPE_ILL ; break ; case 0x00 : op -> cycles = 7 ; op -> type = R_ANAL_OP_TYPE_SWI ; op -> size = 1 ; r_strbuf_set ( & op -> esil , ",1,I,=,0,D,=,flags,0x10,|,0x100,sp,+,=[1],pc,1,+,0xfe,sp,+,=[2],3,sp,-=,0xfffe,[2],pc,=" ) ; break ; case 0x78 : case 0x58 : case 0x38 : case 0x18 : case 0xf8 : case 0xd8 : case 0xb8 : op -> cycles = 2 ; op -> type = R_ANAL_OP_TYPE_NOP ; _6502_anal_esil_flags ( op , data [ 0 ] ) ; break ; case 0x24 : case 0x2c : op -> type = R_ANAL_OP_TYPE_MOV ; _6502_anal_esil_get_addr_pattern3 ( op , data , addrbuf , buffsize , 0 ) ; r_strbuf_setf ( & op -> esil , "a,%s,[1],&,0x80,&,!,!,N,=,a,%s,[1],&,0x40,&,!,!,V,=,a,%s,[1],&,0xff,&,!,Z,=" , addrbuf , addrbuf , addrbuf ) ; break ; case 0x69 : case 0x65 : case 0x75 : case 0x6d : case 0x7d : case 0x79 : case 0x61 : case 0x71 : op -> type = R_ANAL_OP_TYPE_ADD ; _6502_anal_esil_get_addr_pattern1 ( op , data , addrbuf , buffsize ) ; if ( data [ 0 ] == 0x69 ) r_strbuf_setf ( & op -> esil , "%s,a,+=,C,NUM,$c7,C,=,a,+=,$c7,C,|=" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , "%s,[1],a,+=,C,NUM,$c7,C,=,a,+=,$c7,C,|=" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; r_strbuf_append ( & op -> esil , ",a,a,=,$z,Z,=" ) ; break ; case 0xe9 : case 0xe5 : case 0xf5 : case 0xed : case 0xfd : case 0xf9 : case 0xe1 : case 0xf1 : op -> type = R_ANAL_OP_TYPE_SUB ; _6502_anal_esil_get_addr_pattern1 ( op , data , addrbuf , buffsize ) ; if ( data [ 0 ] == 0xe9 ) r_strbuf_setf ( & op -> esil , "C,!,%s,+,a,-=" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , "C,!,%s,[1],+,a,-=" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_BNZ ) ; r_strbuf_append ( & op -> esil , ",a,a,=,$z,Z,=,C,!=" ) ; break ; case 0x09 : case 0x05 : case 0x15 : case 0x0d : case 0x1d : case 0x19 : case 0x01 : case 0x11 : op -> type = R_ANAL_OP_TYPE_OR ; _6502_anal_esil_get_addr_pattern1 ( op , data , addrbuf , buffsize ) ; if ( data [ 0 ] == 0x09 ) r_strbuf_setf ( & op -> esil , "%s,a,|=" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , "%s,[1],a,|=" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0x29 : case 0x25 : case 0x35 : case 0x2d : case 0x3d : case 0x39 : case 0x21 : case 0x31 : op -> type = R_ANAL_OP_TYPE_AND ; _6502_anal_esil_get_addr_pattern1 ( op , data , addrbuf , buffsize ) ; if ( data [ 0 ] == 0x29 ) r_strbuf_setf ( & op -> esil , "%s,a,&=" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , "%s,[1],a,&=" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0x49 : case 0x45 : case 0x55 : case 0x4d : case 0x5d : case 0x59 : case 0x41 : case 0x51 : op -> type = R_ANAL_OP_TYPE_XOR ; _6502_anal_esil_get_addr_pattern1 ( op , data , addrbuf , buffsize ) ; if ( data [ 0 ] == 0x49 ) r_strbuf_setf ( & op -> esil , "%s,a,^=" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , "%s,[1],a,^=" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0x0a : case 0x06 : case 0x16 : case 0x0e : case 0x1e : op -> type = R_ANAL_OP_TYPE_SHL ; if ( data [ 0 ] == 0x0a ) { r_strbuf_set ( & op -> esil , "1,a,<<=,$c7,C,=,a,a,=" ) ; } else { _6502_anal_esil_get_addr_pattern2 ( op , data , addrbuf , buffsize , 'x' ) ; r_strbuf_setf ( & op -> esil , "1,%s,[1],<<,%s,=[1],$c7,C,=" , addrbuf , addrbuf ) ; } _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0x4a : case 0x46 : case 0x56 : case 0x4e : case 0x5e : op -> type = R_ANAL_OP_TYPE_SHR ; if ( data [ 0 ] == 0x4a ) { r_strbuf_set ( & op -> esil , "1,a,&,C,=,1,a,>>=" ) ; } else { _6502_anal_esil_get_addr_pattern2 ( op , data , addrbuf , buffsize , 'x' ) ; r_strbuf_setf ( & op -> esil , "1,%s,[1],&,C,=,1,%s,[1],>>,%s,=[1]" , addrbuf , addrbuf , addrbuf ) ; } _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0x2a : case 0x26 : case 0x36 : case 0x2e : case 0x3e : op -> type = R_ANAL_OP_TYPE_ROL ; if ( data [ 0 ] == 0x2a ) { r_strbuf_set ( & op -> esil , "1,a,<<,C,|,a,=,$c7,C,=,a,a,=" ) ; } else { _6502_anal_esil_get_addr_pattern2 ( op , data , addrbuf , buffsize , 'x' ) ; r_strbuf_setf ( & op -> esil , "1,%s,[1],<<,C,|,%s,=[1],$c7,C,=" , addrbuf , addrbuf ) ; } _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0x6a : case 0x66 : case 0x76 : case 0x6e : case 0x7e : op -> type = R_ANAL_OP_TYPE_ROR ; if ( data [ 0 ] == 0x6a ) { r_strbuf_set ( & op -> esil , "C,N,=,1,a,&,C,=,1,a,>>,7,N,<<,|,a,=" ) ; } else { _6502_anal_esil_get_addr_pattern2 ( op , data , addrbuf , buffsize , 'x' ) ; r_strbuf_setf ( & op -> esil , "C,N,=,1,%s,[1],&,C,=,1,%s,[1],>>,7,N,<<,|,%s,=[1]" , addrbuf , addrbuf , addrbuf ) ; } _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0xe6 : case 0xf6 : case 0xee : case 0xfe : op -> type = R_ANAL_OP_TYPE_STORE ; _6502_anal_esil_get_addr_pattern2 ( op , data , addrbuf , buffsize , 'x' ) ; r_strbuf_setf ( & op -> esil , "%s,++=[1]" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0xc6 : case 0xd6 : case 0xce : case 0xde : op -> type = R_ANAL_OP_TYPE_STORE ; _6502_anal_esil_get_addr_pattern2 ( op , data , addrbuf , buffsize , 'x' ) ; r_strbuf_setf ( & op -> esil , "%s,--=[1]" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0xe8 : case 0xc8 : op -> cycles = 2 ; op -> type = R_ANAL_OP_TYPE_STORE ; _6502_anal_esil_inc_reg ( op , data [ 0 ] , "+" ) ; break ; case 0xca : case 0x88 : op -> cycles = 2 ; op -> type = R_ANAL_OP_TYPE_STORE ; _6502_anal_esil_inc_reg ( op , data [ 0 ] , "-" ) ; break ; case 0xc9 : case 0xc5 : case 0xd5 : case 0xcd : case 0xdd : case 0xd9 : case 0xc1 : case 0xd1 : op -> type = R_ANAL_OP_TYPE_CMP ; _6502_anal_esil_get_addr_pattern1 ( op , data , addrbuf , buffsize ) ; if ( data [ 0 ] == 0xc9 ) r_strbuf_setf ( & op -> esil , "%s,a,==" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , "%s,[1],a,==" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_BNZ ) ; r_strbuf_append ( & op -> esil , ",C,!,C,=" ) ; break ; case 0xe0 : case 0xe4 : case 0xec : op -> type = R_ANAL_OP_TYPE_CMP ; _6502_anal_esil_get_addr_pattern3 ( op , data , addrbuf , buffsize , 0 ) ; if ( data [ 0 ] == 0xe0 ) r_strbuf_setf ( & op -> esil , "%s,x,==" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , "%s,[1],x,==" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_BNZ ) ; r_strbuf_append ( & op -> esil , ",C,!,C,=" ) ; break ; case 0xc0 : case 0xc4 : case 0xcc : op -> type = R_ANAL_OP_TYPE_CMP ; _6502_anal_esil_get_addr_pattern3 ( op , data , addrbuf , buffsize , 0 ) ; if ( data [ 0 ] == 0xc0 ) r_strbuf_setf ( & op -> esil , "%s,y,==" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , "%s,[1],y,==" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_BNZ ) ; r_strbuf_append ( & op -> esil , ",C,!,C,=" ) ; break ; case 0x10 : case 0x30 : case 0x50 : case 0x70 : case 0x90 : case 0xb0 : case 0xd0 : case 0xf0 : op -> cycles = 2 ; op -> failcycles = 3 ; op -> type = R_ANAL_OP_TYPE_CJMP ; <S2SV_StartBug> if ( data [ 1 ] <= 127 ) <S2SV_EndBug> op -> jump = addr + data [ 1 ] + op -> size ; <S2SV_StartBug> else op -> jump = addr - ( 256 - data [ 1 ] ) + op -> size ; <S2SV_EndBug> <S2SV_StartBug> op -> fail = addr + op -> size ; <S2SV_EndBug> _6502_anal_esil_ccall ( op , data [ 0 ] ) ; break ; case 0x20 : op -> cycles = 6 ; op -> type = R_ANAL_OP_TYPE_CALL ; op -> jump = data [ 1 ] | data [ 2 ] << 8 ; op -> stackop = R_ANAL_STACK_INC ; op -> stackptr = 2 ; r_strbuf_setf ( & op -> esil , "1,pc,-,0xff,sp,+,=[2],0x%04x,pc,=,2,sp,-=" , op -> jump ) ; break ; case 0x4c : op -> cycles = 3 ; op -> type = R_ANAL_OP_TYPE_JMP ; op -> jump = data [ 1 ] | data [ 2 ] << 8 ; r_strbuf_setf ( & op -> esil , "0x%04x,pc,=" , op -> jump ) ; break ; case 0x6c : op -> cycles = 5 ; op -> type = R_ANAL_OP_TYPE_UJMP ; r_strbuf_setf ( & op -> esil , "0x%04x,[2],pc,=" , data [ 1 ] | data [ 2 ] << 8 ) ; break ; case 0x60 : op -> eob = true ; op -> type = R_ANAL_OP_TYPE_RET ; op -> cycles = 6 ; op -> stackop = R_ANAL_STACK_INC ; op -> stackptr = - 2 ; r_strbuf_set ( & op -> esil , "0x101,sp,+,[2],pc,=,pc,++=,2,sp,+=" ) ; break ; case 0x40 : op -> eob = true ; op -> type = R_ANAL_OP_TYPE_RET ; op -> cycles = 6 ; op -> stackop = R_ANAL_STACK_INC ; op -> stackptr = - 3 ; r_strbuf_set ( & op -> esil , "0x101,sp,+,[1],flags,=,0x102,sp,+,[2],pc,=,3,sp,+=" ) ; break ; case 0xea : op -> type = R_ANAL_OP_TYPE_NOP ; op -> cycles = 2 ; break ; case 0xa9 : case 0xa5 : case 0xb5 : case 0xad : case 0xbd : case 0xb9 : case 0xa1 : case 0xb1 : op -> type = R_ANAL_OP_TYPE_LOAD ; _6502_anal_esil_get_addr_pattern1 ( op , data , addrbuf , buffsize ) ; if ( data [ 0 ] == 0xa9 ) r_strbuf_setf ( & op -> esil , "%s,a,=" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , "%s,[1],a,=" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0xa2 : case 0xa6 : case 0xb6 : case 0xae : case 0xbe : op -> type = R_ANAL_OP_TYPE_LOAD ; _6502_anal_esil_get_addr_pattern2 ( op , data , addrbuf , buffsize , 'y' ) ; if ( data [ 0 ] == 0xa2 ) r_strbuf_setf ( & op -> esil , "%s,x,=" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , "%s,[1],x,=" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0xa0 : case 0xa4 : case 0xb4 : case 0xac : case 0xbc : op -> type = R_ANAL_OP_TYPE_LOAD ; _6502_anal_esil_get_addr_pattern3 ( op , data , addrbuf , buffsize , 'x' ) ; if ( data [ 0 ] == 0xa0 ) r_strbuf_setf ( & op -> esil , "%s,y,=" , addrbuf ) ; else r_strbuf_setf ( & op -> esil , "%s,[1],y,=" , addrbuf ) ; _6502_anal_update_flags ( op , _6502_FLAGS_NZ ) ; break ; case 0x85 : case 0x95 : case 0x8d : case 0x9d : case 0x99 : case 0x81 : case 0x91 : op -> type = R_ANAL_OP_TYPE_STORE ; _6502_anal_esil_get_addr_pattern1 ( op , data , addrbuf , buffsize ) ; r_strbuf_setf ( & op -> esil , "a,%s,=[1]" , addrbuf ) ; break ; case 0x86 : case 0x96 : case 0x8e : op -> type = R_ANAL_OP_TYPE_STORE ; _6502_anal_esil_get_addr_pattern2 ( op , data , addrbuf , buffsize , 'y' ) ; r_strbuf_setf ( & op -> esil , "x,%s,=[1]" , addrbuf ) ; break ; case 0x84 : case 0x94 : case 0x8c : op -> type = R_ANAL_OP_TYPE_STORE ; _6502_anal_esil_get_addr_pattern3 ( op , data , addrbuf , buffsize , 'x' ) ; r_strbuf_setf ( & op -> esil , "y,%s,=[1]" , addrbuf ) ; break ; case 0x08 : case 0x48 : op -> type = R_ANAL_OP_TYPE_PUSH ; op -> cycles = 3 ; op -> stackop = R_ANAL_STACK_INC ; op -> stackptr = 1 ; _6502_anal_esil_push ( op , data [ 0 ] ) ; break ; case 0x28 : case 0x68 : op -> type = R_ANAL_OP_TYPE_POP ; op -> cycles = 4 ; op -> stackop = R_ANAL_STACK_INC ; op -> stackptr = - 1 ; _6502_anal_esil_pop ( op , data [ 0 ] ) ; break ; case 0xaa : case 0x8a : case 0xa8 : case 0x98 : op -> type = R_ANAL_OP_TYPE_MOV ; op -> cycles = 2 ; _6502_anal_esil_mov ( op , data [ 0 ] ) ; break ; case 0x9a : op -> type = R_ANAL_OP_TYPE_MOV ; op -> cycles = 2 ; op -> stackop = R_ANAL_STACK_SET ; _6502_anal_esil_mov ( op , data [ 0 ] ) ; break ; case 0xba : op -> type = R_ANAL_OP_TYPE_MOV ; op -> cycles = 2 ; op -> stackop = R_ANAL_STACK_GET ; _6502_anal_esil_mov ( op , data [ 0 ] ) ; break ; } return op -> size ; }
CWE-119 static const ut8 * r_bin_dwarf_parse_comp_unit ( Sdb * s , const ut8 * obuf , RBinDwarfCompUnit * cu , const RBinDwarfDebugAbbrev * da , size_t offset , const ut8 * debug_str , size_t debug_str_len ) { const ut8 * buf = obuf , * buf_end = obuf + ( cu -> hdr . length - 7 ) ; ut64 abbr_code ; size_t i ; if ( cu -> hdr . length > debug_str_len ) { return NULL ; } while ( buf && buf < buf_end && buf >= obuf ) { if ( cu -> length && cu -> capacity == cu -> length ) { r_bin_dwarf_expand_cu ( cu ) ; } buf = r_uleb128 ( buf , buf_end - buf , & abbr_code ) ; if ( abbr_code > da -> length || ! buf ) { return NULL ; } r_bin_dwarf_init_die ( & cu -> dies [ cu -> length ] ) ; if ( ! abbr_code ) { cu -> dies [ cu -> length ] . abbrev_code = 0 ; cu -> length ++ ; buf ++ ; continue ; } cu -> dies [ cu -> length ] . abbrev_code = abbr_code ; cu -> dies [ cu -> length ] . tag = da -> decls [ abbr_code - 1 ] . tag ; abbr_code += offset ; if ( da -> capacity < abbr_code ) { return NULL ; } for ( i = 0 ; i < da -> decls [ abbr_code - 1 ] . length ; i ++ ) { if ( cu -> dies [ cu -> length ] . length == cu -> dies [ cu -> length ] . capacity ) { r_bin_dwarf_expand_die ( & cu -> dies [ cu -> length ] ) ; } if ( i >= cu -> dies [ cu -> length ] . capacity || i >= da -> decls [ abbr_code - 1 ] . capacity ) { eprintf ( "Warning:<S2SV_blank>malformed<S2SV_blank>dwarf<S2SV_blank>attribute<S2SV_blank>capacity<S2SV_blank>doesn\'t<S2SV_blank>match<S2SV_blank>length\\n" ) ; break ; } memset ( & cu -> dies [ cu -> length ] . attr_values [ i ] , 0 , sizeof ( cu -> dies [ cu -> length ] . attr_values [ i ] ) ) ; buf = r_bin_dwarf_parse_attr_value ( buf , buf_end - buf , & da -> decls [ abbr_code - 1 ] . specs [ i ] , & cu -> dies [ cu -> length ] . attr_values [ i ] , & cu -> hdr , debug_str , debug_str_len ) ; if ( cu -> dies [ cu -> length ] . attr_values [ i ] . name == DW_AT_comp_dir ) { const char * name = cu -> dies [ cu -> length ] . attr_values [ i ] . encoding . str_struct . string ; <S2SV_StartBug> sdb_set ( s , "DW_AT_comp_dir" , name , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> cu -> dies [ cu -> length ] . length ++ ; } cu -> length ++ ; } return buf ; }
CWE-119 int wasm_dis ( WasmOp * op , const unsigned char * buf , int buf_len ) { op -> len = 1 ; op -> op = buf [ 0 ] ; if ( op -> op > 0xbf ) { return 1 ; } WasmOpDef * opdef = & opcodes [ op -> op ] ; switch ( op -> op ) { case WASM_OP_TRAP : case WASM_OP_NOP : case WASM_OP_ELSE : case WASM_OP_RETURN : case WASM_OP_DROP : case WASM_OP_SELECT : case WASM_OP_I32EQZ : case WASM_OP_I32EQ : case WASM_OP_I32NE : case WASM_OP_I32LTS : case WASM_OP_I32LTU : case WASM_OP_I32GTS : case WASM_OP_I32GTU : case WASM_OP_I32LES : case WASM_OP_I32LEU : case WASM_OP_I32GES : case WASM_OP_I32GEU : case WASM_OP_I64EQZ : case WASM_OP_I64EQ : case WASM_OP_I64NE : case WASM_OP_I64LTS : case WASM_OP_I64LTU : case WASM_OP_I64GTS : case WASM_OP_I64GTU : case WASM_OP_I64LES : case WASM_OP_I64LEU : case WASM_OP_I64GES : case WASM_OP_I64GEU : case WASM_OP_F32EQ : case WASM_OP_F32NE : case WASM_OP_F32LT : case WASM_OP_F32GT : case WASM_OP_F32LE : case WASM_OP_F32GE : case WASM_OP_F64EQ : case WASM_OP_F64NE : case WASM_OP_F64LT : case WASM_OP_F64GT : case WASM_OP_F64LE : case WASM_OP_F64GE : case WASM_OP_I32CLZ : case WASM_OP_I32CTZ : case WASM_OP_I32POPCNT : case WASM_OP_I32ADD : case WASM_OP_I32SUB : case WASM_OP_I32MUL : case WASM_OP_I32DIVS : case WASM_OP_I32DIVU : case WASM_OP_I32REMS : case WASM_OP_I32REMU : case WASM_OP_I32AND : case WASM_OP_I32OR : case WASM_OP_I32XOR : case WASM_OP_I32SHL : case WASM_OP_I32SHRS : case WASM_OP_I32SHRU : case WASM_OP_I32ROTL : case WASM_OP_I32ROTR : case WASM_OP_I64CLZ : case WASM_OP_I64CTZ : case WASM_OP_I64POPCNT : case WASM_OP_I64ADD : case WASM_OP_I64SUB : case WASM_OP_I64MUL : case WASM_OP_I64DIVS : case WASM_OP_I64DIVU : case WASM_OP_I64REMS : case WASM_OP_I64REMU : case WASM_OP_I64AND : case WASM_OP_I64OR : case WASM_OP_I64XOR : case WASM_OP_I64SHL : case WASM_OP_I64SHRS : case WASM_OP_I64SHRU : case WASM_OP_I64ROTL : case WASM_OP_I64ROTR : case WASM_OP_F32ABS : case WASM_OP_F32NEG : case WASM_OP_F32CEIL : case WASM_OP_F32FLOOR : case WASM_OP_F32TRUNC : case WASM_OP_F32NEAREST : case WASM_OP_F32SQRT : case WASM_OP_F32ADD : case WASM_OP_F32SUB : case WASM_OP_F32MUL : case WASM_OP_F32DIV : case WASM_OP_F32MIN : case WASM_OP_F32MAX : case WASM_OP_F32COPYSIGN : case WASM_OP_F64ABS : case WASM_OP_F64NEG : case WASM_OP_F64CEIL : case WASM_OP_F64FLOOR : case WASM_OP_F64TRUNC : case WASM_OP_F64NEAREST : case WASM_OP_F64SQRT : case WASM_OP_F64ADD : case WASM_OP_F64SUB : case WASM_OP_F64MUL : case WASM_OP_F64DIV : case WASM_OP_F64MIN : case WASM_OP_F64MAX : case WASM_OP_F64COPYSIGN : case WASM_OP_I32WRAPI64 : case WASM_OP_I32TRUNCSF32 : case WASM_OP_I32TRUNCUF32 : case WASM_OP_I32TRUNCSF64 : case WASM_OP_I32TRUNCUF64 : case WASM_OP_I64EXTENDSI32 : case WASM_OP_I64EXTENDUI32 : case WASM_OP_I64TRUNCSF32 : case WASM_OP_I64TRUNCUF32 : case WASM_OP_I64TRUNCSF64 : case WASM_OP_I64TRUNCUF64 : case WASM_OP_F32CONVERTSI32 : case WASM_OP_F32CONVERTUI32 : case WASM_OP_F32CONVERTSI64 : case WASM_OP_F32CONVERTUI64 : case WASM_OP_F32DEMOTEF64 : case WASM_OP_F64CONVERTSI32 : case WASM_OP_F64CONVERTUI32 : case WASM_OP_F64CONVERTSI64 : case WASM_OP_F64CONVERTUI64 : case WASM_OP_F64PROMOTEF32 : case WASM_OP_I32REINTERPRETF32 : case WASM_OP_I64REINTERPRETF64 : case WASM_OP_F32REINTERPRETI32 : case WASM_OP_F64REINTERPRETI64 : case WASM_OP_END : { snprintf ( op -> txt , R_ASM_BUFSIZE , "%s" , opdef -> txt ) ; } break ; case WASM_OP_BLOCK : case WASM_OP_LOOP : case WASM_OP_IF : { st32 val = 0 ; size_t n = read_i32_leb128 ( buf + 1 , buf + buf_len , & val ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; switch ( 0x80 - val ) { case R_BIN_WASM_VALUETYPE_EMPTY : snprintf ( op -> txt , R_ASM_BUFSIZE , "%s" , opdef -> txt ) ; break ; case R_BIN_WASM_VALUETYPE_i32 : snprintf ( op -> txt , R_ASM_BUFSIZE , "%s<S2SV_blank>(result<S2SV_blank>i32)" , opdef -> txt ) ; break ; case R_BIN_WASM_VALUETYPE_i64 : snprintf ( op -> txt , R_ASM_BUFSIZE , "%s<S2SV_blank>(result<S2SV_blank>i64)" , opdef -> txt ) ; break ; case R_BIN_WASM_VALUETYPE_f32 : snprintf ( op -> txt , R_ASM_BUFSIZE , "%s<S2SV_blank>(result<S2SV_blank>f32)" , opdef -> txt ) ; break ; case R_BIN_WASM_VALUETYPE_f64 : snprintf ( op -> txt , R_ASM_BUFSIZE , "%s<S2SV_blank>(result<S2SV_blank>f64)" , opdef -> txt ) ; break ; default : snprintf ( op -> txt , R_ASM_BUFSIZE , "%s<S2SV_blank>(result<S2SV_blank>?)" , opdef -> txt ) ; break ; } op -> len += n ; } break ; case WASM_OP_BR : case WASM_OP_BRIF : case WASM_OP_CALL : { ut32 val = 0 ; size_t n = read_u32_leb128 ( buf + 1 , buf + buf_len , & val ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; snprintf ( op -> txt , R_ASM_BUFSIZE , "%s<S2SV_blank>%d" , opdef -> txt , val ) ; op -> len += n ; } break ; case WASM_OP_BRTABLE : { ut32 count = 0 , * table = NULL , def = 0 ; size_t n = read_u32_leb128 ( buf + 1 , buf + buf_len , & count ) ; if ( ! ( n > 0 && n < buf_len ) ) { goto err ; } if ( ! ( table = calloc ( count , sizeof ( ut32 ) ) ) ) { goto err ; } int i = 0 ; op -> len += n ; for ( i = 0 ; i < count ; i ++ ) { n = read_u32_leb128 ( buf + op -> len , buf + buf_len , & table [ i ] ) ; if ( ! ( op -> len + n <= buf_len ) ) { goto beach ; } op -> len += n ; } n = read_u32_leb128 ( buf + op -> len , buf + buf_len , & def ) ; if ( ! ( n > 0 && n + op -> len < buf_len ) ) { goto beach ; } op -> len += n ; snprintf ( op -> txt , R_ASM_BUFSIZE , "%s<S2SV_blank>%d<S2SV_blank>" , opdef -> txt , count ) ; <S2SV_StartBug> for ( i = 0 ; i < count && strlen ( op -> txt ) + 10 < R_ASM_BUFSIZE ; i ++ ) { <S2SV_EndBug> <S2SV_StartBug> int optxtlen = strlen ( op -> txt ) ; <S2SV_EndBug> snprintf ( op -> txt + optxtlen , R_ASM_BUFSIZE - optxtlen , "%d<S2SV_blank>" , table [ i ] ) ; <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> snprintf ( op -> txt + strlen ( op -> txt ) , R_ASM_BUFSIZE , "%d" , def ) ; <S2SV_EndBug> free ( table ) ; break ; beach : free ( table ) ; goto err ; } break ; case WASM_OP_CALLINDIRECT : { ut32 val = 0 , reserved = 0 ; size_t n = read_u32_leb128 ( buf + 1 , buf + buf_len , & val ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; op -> len += n ; n = read_u32_leb128 ( buf + op -> len , buf + buf_len , & reserved ) ; if ( ! ( n == 1 && op -> len + n <= buf_len ) ) goto err ; reserved &= 0x1 ; snprintf ( op -> txt , R_ASM_BUFSIZE , "%s<S2SV_blank>%d<S2SV_blank>%d" , opdef -> txt , val , reserved ) ; op -> len += n ; } break ; case WASM_OP_GETLOCAL : case WASM_OP_SETLOCAL : case WASM_OP_TEELOCAL : case WASM_OP_GETGLOBAL : case WASM_OP_SETGLOBAL : { ut32 val = 0 ; size_t n = read_u32_leb128 ( buf + 1 , buf + buf_len , & val ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; snprintf ( op -> txt , R_ASM_BUFSIZE , "%s<S2SV_blank>%d" , opdef -> txt , val ) ; op -> len += n ; } break ; case WASM_OP_I32LOAD : case WASM_OP_I64LOAD : case WASM_OP_F32LOAD : case WASM_OP_F64LOAD : case WASM_OP_I32LOAD8S : case WASM_OP_I32LOAD8U : case WASM_OP_I32LOAD16S : case WASM_OP_I32LOAD16U : case WASM_OP_I64LOAD8S : case WASM_OP_I64LOAD8U : case WASM_OP_I64LOAD16S : case WASM_OP_I64LOAD16U : case WASM_OP_I64LOAD32S : case WASM_OP_I64LOAD32U : case WASM_OP_I32STORE : case WASM_OP_I64STORE : case WASM_OP_F32STORE : case WASM_OP_F64STORE : case WASM_OP_I32STORE8 : case WASM_OP_I32STORE16 : case WASM_OP_I64STORE8 : case WASM_OP_I64STORE16 : case WASM_OP_I64STORE32 : { ut32 flag = 0 , offset = 0 ; size_t n = read_u32_leb128 ( buf + 1 , buf + buf_len , & flag ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; op -> len += n ; n = read_u32_leb128 ( buf + op -> len , buf + buf_len , & offset ) ; if ( ! ( n > 0 && op -> len + n <= buf_len ) ) goto err ; snprintf ( op -> txt , R_ASM_BUFSIZE , "%s<S2SV_blank>%d<S2SV_blank>%d" , opdef -> txt , flag , offset ) ; op -> len += n ; } break ; case WASM_OP_CURRENTMEMORY : case WASM_OP_GROWMEMORY : { ut32 reserved = 0 ; size_t n = read_u32_leb128 ( buf + 1 , buf + buf_len , & reserved ) ; if ( ! ( n == 1 && n < buf_len ) ) goto err ; reserved &= 0x1 ; snprintf ( op -> txt , R_ASM_BUFSIZE , "%s<S2SV_blank>%d" , opdef -> txt , reserved ) ; op -> len += n ; } break ; case WASM_OP_I32CONST : { st32 val = 0 ; size_t n = read_i32_leb128 ( buf + 1 , buf + buf_len , & val ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; snprintf ( op -> txt , R_ASM_BUFSIZE , "%s<S2SV_blank>%" PFMT32d , opdef -> txt , val ) ; op -> len += n ; } break ; case WASM_OP_I64CONST : { st64 val = 0 ; size_t n = read_i64_leb128 ( buf + 1 , buf + buf_len , & val ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; snprintf ( op -> txt , R_ASM_BUFSIZE , "%s<S2SV_blank>%" PFMT64d , opdef -> txt , val ) ; op -> len += n ; } break ; case WASM_OP_F32CONST : { ut32 val = 0 ; size_t n = read_u32_leb128 ( buf + 1 , buf + buf_len , & val ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; long double d = ( long double ) val ; snprintf ( op -> txt , R_ASM_BUFSIZE , "%s<S2SV_blank>%" LDBLFMT , opdef -> txt , d ) ; op -> len += n ; } break ; case WASM_OP_F64CONST : { ut64 val = 0 ; size_t n = read_u64_leb128 ( buf + 1 , buf + buf_len , & val ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; long double d = ( long double ) val ; snprintf ( op -> txt , R_ASM_BUFSIZE , "%s<S2SV_blank>%" LDBLFMT , opdef -> txt , d ) ; op -> len += n ; } break ; default : goto err ; } return op -> len ; err : op -> len = 1 ; snprintf ( op -> txt , R_ASM_BUFSIZE , "invalid" ) ; return op -> len ; }
CWE-125 <S2SV_StartBug> INST_HANDLER ( sts ) { <S2SV_EndBug> int r = ( ( buf [ 0 ] >> 4 ) & 0xf ) | ( ( buf [ 1 ] & 0x1 ) << 4 ) ; int k = ( buf [ 3 ] << 8 ) | buf [ 2 ] ; op -> ptr = k ; ESIL_A ( "r%d," , r ) ; __generic_ld_st ( op , "ram" , 0 , 1 , 0 , k , 1 ) ; op -> cycles = 2 ; }
CWE-119 static bool parseOperands ( char * str , ArmOp * op ) { char * t = strdup ( str ) ; int operand = 0 ; char * token = t ; char * x ; int imm_count = 0 ; int mem_opt = 0 ; if ( ! token ) { return false ; } while ( token ) { char * next = strchr ( token , ',' ) ; if ( next ) { * next ++ = 0 ; } while ( token [ 0 ] == '<S2SV_blank>' ) { <S2SV_StartBug> token ++ ; <S2SV_EndBug> } op -> operands [ operand ] . type = ARM_NOTYPE ; op -> operands [ operand ] . reg_type = ARM_UNDEFINED ; op -> operands [ operand ] . shift = ARM_NO_SHIFT ; while ( token [ 0 ] == '<S2SV_blank>' || token [ 0 ] == '[' || token [ 0 ] == ']' ) { token ++ ; } if ( ! strncmp ( token , "lsl" , 3 ) ) { op -> operands [ operand ] . shift = ARM_LSL ; } else if ( ! strncmp ( token , "lsr" , 3 ) ) { op -> operands [ operand ] . shift = ARM_LSR ; } else if ( ! strncmp ( token , "asr" , 3 ) ) { op -> operands [ operand ] . shift = ARM_ASR ; } if ( op -> operands [ operand ] . shift != ARM_NO_SHIFT ) { op -> operands_count ++ ; op -> operands [ operand ] . shift_amount = r_num_math ( NULL , token + 4 ) ; if ( op -> operands [ operand ] . shift_amount > 63 ) { return false ; } operand ++ ; token = next ; continue ; } switch ( token [ 0 ] ) { case 'x' : x = strchr ( token , ',' ) ; if ( x ) { x [ 0 ] = '\\0' ; } op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_GPR ; op -> operands [ operand ] . reg_type = ARM_REG64 ; op -> operands [ operand ] . reg = r_num_math ( NULL , token + 1 ) ; if ( op -> operands [ operand ] . reg > 31 ) { return false ; } break ; case 'w' : op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_GPR ; op -> operands [ operand ] . reg_type = ARM_REG32 ; op -> operands [ operand ] . reg = r_num_math ( NULL , token + 1 ) ; if ( op -> operands [ operand ] . reg > 31 ) { return false ; } break ; case 'v' : op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_FP ; op -> operands [ operand ] . reg = r_num_math ( NULL , token + 1 ) ; break ; case 's' : case 'S' : if ( token [ 1 ] == 'P' || token [ 1 ] == 'p' ) { int i ; for ( i = 0 ; msr_const [ i ] . name ; i ++ ) { if ( ! r_str_ncasecmp ( token , msr_const [ i ] . name , strlen ( msr_const [ i ] . name ) ) ) { op -> operands [ operand ] . sp_val = msr_const [ i ] . val ; break ; } } op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_GPR ; op -> operands [ operand ] . reg_type = ARM_SP | ARM_REG64 ; op -> operands [ operand ] . reg = 31 ; break ; } mem_opt = get_mem_option ( token ) ; if ( mem_opt != - 1 ) { op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_MEM_OPT ; op -> operands [ operand ] . mem_option = mem_opt ; } break ; case 'L' : case 'l' : case 'I' : case 'i' : case 'N' : case 'n' : case 'O' : case 'o' : case 'p' : case 'P' : mem_opt = get_mem_option ( token ) ; if ( mem_opt != - 1 ) { op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_MEM_OPT ; op -> operands [ operand ] . mem_option = mem_opt ; } break ; case '-' : op -> operands [ operand ] . sign = - 1 ; default : op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_CONSTANT ; op -> operands [ operand ] . immediate = r_num_math ( NULL , token ) ; imm_count ++ ; break ; } token = next ; operand ++ ; if ( operand > MAX_OPERANDS ) { free ( t ) ; return false ; } } free ( t ) ; return true ; }
CWE-125 static int opmov ( RAsm * a , ut8 * data , const Opcode * op ) { int l = 0 ; st64 offset = 0 ; int mod = 0 ; int base = 0 ; int rex = 0 ; ut64 immediate = 0 ; if ( op -> operands [ 1 ] . type & OT_CONSTANT ) { if ( ! op -> operands [ 1 ] . is_good_flag ) { return - 1 ; } if ( op -> operands [ 1 ] . immediate == - 1 ) { return - 1 ; } immediate = op -> operands [ 1 ] . immediate * op -> operands [ 1 ] . sign ; if ( op -> operands [ 0 ] . type & OT_GPREG && ! ( op -> operands [ 0 ] . type & OT_MEMORY ) ) { if ( a -> bits == 64 && ( ( op -> operands [ 0 ] . type & OT_QWORD ) | ( op -> operands [ 1 ] . type & OT_QWORD ) ) ) { if ( ! ( op -> operands [ 1 ] . type & OT_CONSTANT ) && op -> operands [ 1 ] . extended ) { data [ l ++ ] = 0x49 ; } else { data [ l ++ ] = 0x48 ; } } else if ( op -> operands [ 0 ] . extended ) { data [ l ++ ] = 0x41 ; } if ( op -> operands [ 0 ] . type & OT_WORD ) { if ( a -> bits > 16 ) { data [ l ++ ] = 0x66 ; } } if ( op -> operands [ 0 ] . type & OT_BYTE ) { data [ l ++ ] = 0xb0 | op -> operands [ 0 ] . reg ; data [ l ++ ] = immediate ; } else { if ( a -> bits == 64 && ( ( op -> operands [ 0 ] . type & OT_QWORD ) | ( op -> operands [ 1 ] . type & OT_QWORD ) ) && immediate < UT32_MAX ) { data [ l ++ ] = 0xc7 ; data [ l ++ ] = 0xc0 | op -> operands [ 0 ] . reg ; } else { data [ l ++ ] = 0xb8 | op -> operands [ 0 ] . reg ; } data [ l ++ ] = immediate ; data [ l ++ ] = immediate >> 8 ; if ( ! ( op -> operands [ 0 ] . type & OT_WORD ) ) { data [ l ++ ] = immediate >> 16 ; data [ l ++ ] = immediate >> 24 ; } if ( a -> bits == 64 && immediate > UT32_MAX ) { data [ l ++ ] = immediate >> 32 ; data [ l ++ ] = immediate >> 40 ; data [ l ++ ] = immediate >> 48 ; data [ l ++ ] = immediate >> 56 ; } } } else if ( op -> operands [ 0 ] . type & OT_MEMORY ) { if ( ! op -> operands [ 0 ] . explicit_size ) { if ( op -> operands [ 0 ] . type & OT_GPREG ) { ( ( Opcode * ) op ) -> operands [ 0 ] . dest_size = op -> operands [ 0 ] . reg_size ; } else { return - 1 ; } } int dest_bits = 8 * ( ( op -> operands [ 0 ] . dest_size & ALL_SIZE ) >> OPSIZE_SHIFT ) ; int reg_bits = 8 * ( ( op -> operands [ 0 ] . reg_size & ALL_SIZE ) >> OPSIZE_SHIFT ) ; int offset = op -> operands [ 0 ] . offset * op -> operands [ 0 ] . offset_sign ; bool use_aso = false ; if ( reg_bits < a -> bits ) { use_aso = true ; } bool use_oso = false ; if ( dest_bits == 16 ) { use_oso = true ; } bool rip_rel = op -> operands [ 0 ] . regs [ 0 ] == X86R_RIP ; int rex = 1 << 6 ; bool use_rex = false ; if ( dest_bits == 64 ) { use_rex = true ; rex |= 1 << 3 ; } if ( op -> operands [ 0 ] . extended ) { use_rex = true ; rex |= 1 ; } int opcode ; if ( dest_bits == 8 ) { opcode = 0xc6 ; } else { opcode = 0xc7 ; } int modrm = 0 ; int mod ; int reg = 0 ; int rm ; bool use_sib = false ; int sib ; if ( offset == 0 ) { mod = 0 ; } else if ( offset < 128 && offset > - 129 ) { mod = 1 ; } else { mod = 2 ; } if ( reg_bits == 16 ) { if ( op -> operands [ 0 ] . regs [ 0 ] == X86R_BX && op -> operands [ 0 ] . regs [ 1 ] == X86R_SI ) { rm = B0000 ; } else if ( op -> operands [ 0 ] . regs [ 0 ] == X86R_BX && op -> operands [ 0 ] . regs [ 1 ] == X86R_DI ) { rm = B0001 ; } else if ( op -> operands [ 0 ] . regs [ 0 ] == X86R_BP && op -> operands [ 0 ] . regs [ 1 ] == X86R_SI ) { rm = B0010 ; } else if ( op -> operands [ 0 ] . regs [ 0 ] == X86R_BP && op -> operands [ 0 ] . regs [ 1 ] == X86R_DI ) { rm = B0011 ; } else if ( op -> operands [ 0 ] . regs [ 0 ] == X86R_SI && op -> operands [ 0 ] . regs [ 1 ] == - 1 ) { rm = B0100 ; } else if ( op -> operands [ 0 ] . regs [ 0 ] == X86R_DI && op -> operands [ 0 ] . regs [ 1 ] == - 1 ) { rm = B0101 ; } else if ( op -> operands [ 0 ] . regs [ 0 ] == X86R_BX && op -> operands [ 0 ] . regs [ 1 ] == - 1 ) { rm = B0111 ; } else { return - 1 ; } modrm = ( mod << 6 ) | ( reg << 3 ) | rm ; } else { if ( op -> operands [ 0 ] . extended ) { rm = op -> operands [ 0 ] . reg ; } else { rm = op -> operands [ 0 ] . regs [ 0 ] ; } if ( rm == 5 && mod == 0 ) { mod = 1 ; } int index = op -> operands [ 0 ] . regs [ 1 ] ; int scale = getsib ( op -> operands [ 0 ] . scale [ 1 ] ) ; if ( index != - 1 ) { use_sib = true ; sib = ( scale << 6 ) | ( index << 3 ) | rm ; } else if ( rm == 4 ) { use_sib = true ; sib = 0x24 ; } if ( use_sib ) { rm = B0100 ; } if ( rip_rel ) { modrm = ( B0000 << 6 ) | ( reg << 3 ) | B0101 ; sib = ( scale << 6 ) | ( B0100 << 3 ) | B0101 ; } else { modrm = ( mod << 6 ) | ( reg << 3 ) | rm ; } } if ( use_aso ) { data [ l ++ ] = 0x67 ; } if ( use_oso ) { data [ l ++ ] = 0x66 ; } if ( use_rex ) { data [ l ++ ] = rex ; } data [ l ++ ] = opcode ; data [ l ++ ] = modrm ; if ( use_sib ) { data [ l ++ ] = sib ; } if ( mod == 1 ) { data [ l ++ ] = offset ; } else if ( reg_bits == 16 && mod == 2 ) { data [ l ++ ] = offset ; data [ l ++ ] = offset >> 8 ; } else if ( mod == 2 || rip_rel ) { data [ l ++ ] = offset ; data [ l ++ ] = offset >> 8 ; data [ l ++ ] = offset >> 16 ; data [ l ++ ] = offset >> 24 ; } int byte ; for ( byte = 0 ; byte < dest_bits && byte < 32 ; byte += 8 ) { data [ l ++ ] = ( immediate >> byte ) ; } } } else if ( op -> operands [ 1 ] . type & OT_REGALL && ! ( op -> operands [ 1 ] . type & OT_MEMORY ) ) { if ( op -> operands [ 0 ] . type & OT_CONSTANT ) { return - 1 ; } if ( op -> operands [ 0 ] . type & OT_REGTYPE & OT_SEGMENTREG && op -> operands [ 1 ] . type & OT_REGTYPE & OT_SEGMENTREG ) { return - 1 ; } if ( op -> operands [ 0 ] . type & OT_REGTYPE && op -> operands [ 1 ] . type & OT_REGTYPE ) { if ( ! ( ( op -> operands [ 0 ] . type & ALL_SIZE ) & ( op -> operands [ 1 ] . type & ALL_SIZE ) ) ) { return - 1 ; } } if ( a -> bits == 64 ) { if ( op -> operands [ 0 ] . extended ) { rex = 1 ; } if ( op -> operands [ 1 ] . extended ) { rex += 4 ; } if ( op -> operands [ 1 ] . type & OT_QWORD ) { if ( ! ( op -> operands [ 0 ] . type & OT_QWORD ) ) { data [ l ++ ] = 0x67 ; data [ l ++ ] = 0x48 ; } } if ( op -> operands [ 1 ] . type & OT_QWORD && op -> operands [ 0 ] . type & OT_QWORD ) { data [ l ++ ] = 0x48 | rex ; } if ( op -> operands [ 1 ] . type & OT_DWORD && op -> operands [ 0 ] . type & OT_DWORD ) { data [ l ++ ] = 0x40 | rex ; } } else if ( op -> operands [ 0 ] . extended && op -> operands [ 1 ] . extended ) { data [ l ++ ] = 0x45 ; } offset = op -> operands [ 0 ] . offset * op -> operands [ 0 ] . offset_sign ; if ( op -> operands [ 1 ] . type & OT_REGTYPE & OT_SEGMENTREG ) { data [ l ++ ] = 0x8c ; } else { if ( op -> operands [ 0 ] . type & OT_WORD ) { data [ l ++ ] = 0x66 ; } data [ l ++ ] = ( op -> operands [ 0 ] . type & OT_BYTE ) ? 0x88 : 0x89 ; } if ( op -> operands [ 0 ] . scale [ 0 ] > 1 ) { data [ l ++ ] = op -> operands [ 1 ] . reg << 3 | 4 ; data [ l ++ ] = getsib ( op -> operands [ 0 ] . scale [ 0 ] ) << 6 | op -> operands [ 0 ] . regs [ 0 ] << 3 | 5 ; data [ l ++ ] = offset ; data [ l ++ ] = offset >> 8 ; data [ l ++ ] = offset >> 16 ; data [ l ++ ] = offset >> 24 ; return l ; } if ( ! ( op -> operands [ 0 ] . type & OT_MEMORY ) ) { if ( op -> operands [ 0 ] . reg == X86R_UNDEFINED || op -> operands [ 1 ] . reg == X86R_UNDEFINED ) { return - 1 ; } mod = 0x3 ; data [ l ++ ] = mod << 6 | op -> operands [ 1 ] . reg << 3 | op -> operands [ 0 ] . reg ; } else if ( op -> operands [ 0 ] . regs [ 0 ] == X86R_UNDEFINED ) { data [ l ++ ] = op -> operands [ 1 ] . reg << 3 | 0x5 ; data [ l ++ ] = offset ; data [ l ++ ] = offset >> 8 ; data [ l ++ ] = offset >> 16 ; data [ l ++ ] = offset >> 24 ; } else { if ( op -> operands [ 0 ] . type & OT_MEMORY ) { if ( op -> operands [ 0 ] . regs [ 1 ] != X86R_UNDEFINED ) { data [ l ++ ] = op -> operands [ 1 ] . reg << 3 | 0x4 ; data [ l ++ ] = op -> operands [ 0 ] . regs [ 1 ] << 3 | op -> operands [ 0 ] . regs [ 0 ] ; return l ; } if ( offset ) { mod = ( offset > 128 || offset < - 129 ) ? 0x2 : 0x1 ; } if ( op -> operands [ 0 ] . regs [ 0 ] == X86R_EBP ) { mod = 0x2 ; } data [ l ++ ] = mod << 6 | op -> operands [ 1 ] . reg << 3 | op -> operands [ 0 ] . regs [ 0 ] ; if ( op -> operands [ 0 ] . regs [ 0 ] == X86R_ESP ) { data [ l ++ ] = 0x24 ; } if ( offset ) { data [ l ++ ] = offset ; } if ( mod == 2 ) { data [ l ++ ] = offset >> 8 ; data [ l ++ ] = offset >> 16 ; data [ l ++ ] = offset >> 24 ; } } } } else if ( op -> operands [ 1 ] . type & OT_MEMORY ) { if ( op -> operands [ 0 ] . type & OT_MEMORY ) { return - 1 ; } offset = op -> operands [ 1 ] . offset * op -> operands [ 1 ] . offset_sign ; if ( op -> operands [ 0 ] . reg == X86R_EAX && op -> operands [ 1 ] . regs [ 0 ] == X86R_UNDEFINED ) { if ( a -> bits == 64 ) { data [ l ++ ] = 0x48 ; } if ( op -> operands [ 0 ] . type & OT_BYTE ) { data [ l ++ ] = 0xa0 ; } else { data [ l ++ ] = 0xa1 ; } data [ l ++ ] = offset ; data [ l ++ ] = offset >> 8 ; data [ l ++ ] = offset >> 16 ; data [ l ++ ] = offset >> 24 ; if ( a -> bits == 64 ) { data [ l ++ ] = offset >> 32 ; data [ l ++ ] = offset >> 40 ; data [ l ++ ] = offset >> 48 ; data [ l ++ ] = offset >> 54 ; } return l ; } if ( op -> operands [ 0 ] . type & OT_BYTE && a -> bits == 64 && op -> operands [ 1 ] . regs [ 0 ] ) { if ( op -> operands [ 1 ] . regs [ 0 ] >= X86R_R8 && op -> operands [ 0 ] . reg < 4 ) { data [ l ++ ] = 0x41 ; data [ l ++ ] = 0x8a ; data [ l ++ ] = op -> operands [ 0 ] . reg << 3 | ( op -> operands [ 1 ] . regs [ 0 ] - 8 ) ; return l ; } return - 1 ; } if ( op -> operands [ 1 ] . type & OT_REGTYPE & OT_SEGMENTREG ) { if ( op -> operands [ 1 ] . scale [ 0 ] == 0 ) { return - 1 ; } <S2SV_StartBug> data [ l ++ ] = SEG_REG_PREFIXES [ op -> operands [ 1 ] . regs [ 0 ] ] ; <S2SV_EndBug> <S2SV_StartBug> data [ l ++ ] = 0x8b ; <S2SV_EndBug> data [ l ++ ] = op -> operands [ 0 ] . reg << 3 | 0x5 ; <S2SV_StartBug> data [ l ++ ] = offset ; <S2SV_EndBug> data [ l ++ ] = offset >> 8 ; data [ l ++ ] = offset >> 16 ; data [ l ++ ] = offset >> 24 ; <S2SV_StartBug> return l ; <S2SV_EndBug> } <S2SV_StartBug> if ( a -> bits == 64 ) { <S2SV_EndBug> if ( op -> operands [ 0 ] . type & OT_QWORD ) { if ( ! ( op -> operands [ 1 ] . type & OT_QWORD ) ) { if ( op -> operands [ 1 ] . regs [ 0 ] != - 1 ) { data [ l ++ ] = 0x67 ; } data [ l ++ ] = 0x48 ; } } else if ( op -> operands [ 1 ] . type & OT_DWORD ) { data [ l ++ ] = 0x44 ; } else if ( ! ( op -> operands [ 1 ] . type & OT_QWORD ) ) { data [ l ++ ] = 0x67 ; } if ( op -> operands [ 1 ] . type & OT_QWORD && op -> operands [ 0 ] . type & OT_QWORD ) { data [ l ++ ] = 0x48 ; } } if ( op -> operands [ 0 ] . type & OT_WORD ) { data [ l ++ ] = 0x66 ; data [ l ++ ] = op -> operands [ 1 ] . type & OT_BYTE ? 0x8a : 0x8b ; } else { data [ l ++ ] = ( op -> operands [ 1 ] . type & OT_BYTE || op -> operands [ 0 ] . type & OT_BYTE ) ? 0x8a : 0x8b ; } if ( op -> operands [ 1 ] . regs [ 0 ] == X86R_UNDEFINED ) { if ( a -> bits == 64 ) { data [ l ++ ] = op -> operands [ 0 ] . reg << 3 | 0x4 ; <S2SV_StartBug> data [ l ++ ] = 0x25 ; <S2SV_EndBug> } else { <S2SV_StartBug> data [ l ++ ] = op -> operands [ 0 ] . reg << 3 | 0x5 ; <S2SV_EndBug> } data [ l ++ ] = offset ; data [ l ++ ] = offset >> 8 ; data [ l ++ ] = offset >> 16 ; data [ l ++ ] = offset >> 24 ; } else { <S2SV_StartBug> if ( op -> operands [ 1 ] . scale [ 0 ] > 1 ) { <S2SV_EndBug> <S2SV_StartBug> data [ l ++ ] = op -> operands [ 0 ] . reg << 3 | 4 ; <S2SV_EndBug> if ( op -> operands [ 1 ] . scale [ 0 ] >= 2 ) { base = 5 ; } if ( base ) { data [ l ++ ] = getsib ( op -> operands [ 1 ] . scale [ 0 ] ) << 6 | op -> operands [ 1 ] . regs [ 0 ] << 3 | base ; } else { data [ l ++ ] = getsib ( op -> operands [ 1 ] . scale [ 0 ] ) << 3 | op -> operands [ 1 ] . regs [ 0 ] ; } if ( offset || base ) { data [ l ++ ] = offset ; data [ l ++ ] = offset >> 8 ; data [ l ++ ] = offset >> 16 ; data [ l ++ ] = offset >> 24 ; } return l ; } if ( op -> operands [ 1 ] . regs [ 1 ] != X86R_UNDEFINED ) { data [ l ++ ] = op -> operands [ 0 ] . reg << 3 | 0x4 ; data [ l ++ ] = op -> operands [ 1 ] . regs [ 1 ] << 3 | op -> operands [ 1 ] . regs [ 0 ] ; return l ; } if ( offset || op -> operands [ 1 ] . regs [ 0 ] == X86R_EBP ) { mod = 0x2 ; if ( op -> operands [ 1 ] . offset > 127 ) { mod = 0x4 ; } } if ( a -> bits == 64 && offset && op -> operands [ 0 ] . type & OT_QWORD ) { if ( op -> operands [ 1 ] . regs [ 0 ] == X86R_RIP ) { data [ l ++ ] = 0x5 ; } else { if ( op -> operands [ 1 ] . offset > 127 ) { data [ l ++ ] = 0x80 | op -> operands [ 0 ] . reg << 3 | op -> operands [ 1 ] . regs [ 0 ] ; } else { data [ l ++ ] = 0x40 | op -> operands [ 1 ] . regs [ 0 ] ; } } if ( op -> operands [ 1 ] . offset > 127 ) { mod = 0x1 ; } } else { if ( op -> operands [ 1 ] . regs [ 0 ] == X86R_EIP && ( op -> operands [ 0 ] . type & OT_DWORD ) ) { data [ l ++ ] = 0x0d ; } else if ( op -> operands [ 1 ] . regs [ 0 ] == X86R_RIP && ( op -> operands [ 0 ] . type & OT_QWORD ) ) { data [ l ++ ] = 0x05 ; } else { data [ l ++ ] = mod << 5 | op -> operands [ 0 ] . reg << 3 | op -> operands [ 1 ] . regs [ 0 ] ; } } if ( op -> operands [ 1 ] . regs [ 0 ] == X86R_ESP ) { data [ l ++ ] = 0x24 ; } if ( mod >= 0x2 ) { data [ l ++ ] = offset ; if ( op -> operands [ 1 ] . offset > 128 || op -> operands [ 1 ] . regs [ 0 ] == X86R_EIP ) { data [ l ++ ] = offset >> 8 ; data [ l ++ ] = offset >> 16 ; data [ l ++ ] = offset >> 24 ; } } else if ( a -> bits == 64 && ( offset || op -> operands [ 1 ] . regs [ 0 ] == X86R_RIP ) ) { data [ l ++ ] = offset ; if ( op -> operands [ 1 ] . offset > 127 || op -> operands [ 1 ] . regs [ 0 ] == X86R_RIP ) { data [ l ++ ] = offset >> 8 ; data [ l ++ ] = offset >> 16 ; data [ l ++ ] = offset >> 24 ; } } } } return l ; }
CWE-78 static char * __filterQuotedShell ( const char * arg ) { r_return_val_if_fail ( arg , NULL ) ; char * a = malloc ( strlen ( arg ) + 1 ) ; if ( ! a ) { return NULL ; } char * b = a ; while ( * arg ) { switch ( * arg ) { case '<S2SV_blank>' : case '=' : <S2SV_StartBug> case '\\r' : <S2SV_EndBug> case '\\n' : break ; default : * b ++ = * arg ; break ; } arg ++ ; } * b = 0 ; return a ; }
CWE-78 static char * __filterShell ( const char * arg ) { r_return_val_if_fail ( arg , NULL ) ; char * a = malloc ( strlen ( arg ) + 1 ) ; if ( ! a ) { return NULL ; } char * b = a ; while ( * arg ) { <S2SV_StartBug> switch ( * arg ) { <S2SV_EndBug> case '@' : case '`' : case '|' : case ';' : <S2SV_StartBug> case '\\n' : <S2SV_EndBug> break ; default : <S2SV_StartBug> * b ++ = * arg ; <S2SV_EndBug> break ; } arg ++ ; } * b = 0 ; return a ; }
CWE-78 static int bin_symbols ( RCore * r , int mode , ut64 laddr , int va , ut64 at , const char * name , bool exponly , const char * args ) { RBinInfo * info = r_bin_get_info ( r -> bin ) ; RList * entries = r_bin_get_entries ( r -> bin ) ; RBinSymbol * symbol ; RBinAddr * entry ; RListIter * iter ; bool firstexp = true ; bool printHere = false ; int i = 0 , lastfs = 's' ; bool bin_demangle = r_config_get_i ( r -> config , "bin.demangle" ) ; if ( ! info ) { return 0 ; } if ( args && * args == '.' ) { printHere = true ; } bool is_arm = info && info -> arch && ! strncmp ( info -> arch , "arm" , 3 ) ; const char * lang = bin_demangle ? r_config_get ( r -> config , "bin.lang" ) : NULL ; RList * symbols = r_bin_get_symbols ( r -> bin ) ; r_spaces_push ( & r -> anal -> meta_spaces , "bin" ) ; if ( IS_MODE_JSON ( mode ) && ! printHere ) { r_cons_printf ( "[" ) ; } else if ( IS_MODE_SET ( mode ) ) { r_flag_space_set ( r -> flags , R_FLAGS_FS_SYMBOLS ) ; } else if ( ! at && exponly ) { if ( IS_MODE_RAD ( mode ) ) { r_cons_printf ( "fs<S2SV_blank>exports\\n" ) ; } else if ( IS_MODE_NORMAL ( mode ) ) { r_cons_printf ( printHere ? "" : "[Exports]\\n" ) ; } } else if ( ! at && ! exponly ) { if ( IS_MODE_RAD ( mode ) ) { r_cons_printf ( "fs<S2SV_blank>symbols\\n" ) ; } else if ( IS_MODE_NORMAL ( mode ) ) { r_cons_printf ( printHere ? "" : "[Symbols]\\n" ) ; } } if ( IS_MODE_NORMAL ( mode ) ) { r_cons_printf ( "Num<S2SV_blank>Paddr<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Vaddr<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Bind<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Type<S2SV_blank>Size<S2SV_blank>Name\\n" ) ; } size_t count = 0 ; r_list_foreach ( symbols , iter , symbol ) { if ( ! symbol -> name ) { continue ; } char * r_symbol_name = r_str_escape_utf8 ( symbol -> name , false , true ) ; ut64 addr = compute_addr ( r -> bin , symbol -> paddr , symbol -> vaddr , va ) ; int len = symbol -> size ? symbol -> size : 32 ; SymName sn = { 0 } ; if ( exponly && ! isAnExport ( symbol ) ) { free ( r_symbol_name ) ; continue ; } if ( name && strcmp ( r_symbol_name , name ) ) { free ( r_symbol_name ) ; continue ; } if ( at && ( ! symbol -> size || ! is_in_range ( at , addr , symbol -> size ) ) ) { free ( r_symbol_name ) ; continue ; } if ( ( printHere && ! is_in_range ( r -> offset , symbol -> paddr , len ) ) && ( printHere && ! is_in_range ( r -> offset , addr , len ) ) ) { free ( r_symbol_name ) ; continue ; } count ++ ; snInit ( r , & sn , symbol , lang ) ; if ( IS_MODE_SET ( mode ) && ( is_section_symbol ( symbol ) || is_file_symbol ( symbol ) ) ) { } else if ( IS_MODE_SET ( mode ) && is_special_symbol ( symbol ) ) { if ( is_arm ) { handle_arm_special_symbol ( r , symbol , va ) ; } } else if ( IS_MODE_SET ( mode ) ) { if ( is_arm ) { handle_arm_symbol ( r , symbol , info , va ) ; } select_flag_space ( r , symbol ) ; if ( sn . classname ) { RFlagItem * fi = r_flag_get ( r -> flags , sn . methflag ) ; if ( r -> bin -> prefix ) { char * prname = r_str_newf ( "%s.%s" , r -> bin -> prefix , sn . methflag ) ; r_name_filter ( sn . methflag , - 1 ) ; free ( sn . methflag ) ; sn . methflag = prname ; } if ( fi ) { r_flag_item_set_realname ( fi , sn . methname ) ; if ( ( fi -> offset - r -> flags -> base ) == addr ) { r_flag_unset ( r -> flags , fi ) ; } } else { fi = r_flag_set ( r -> flags , sn . methflag , addr , symbol -> size ) ; char * comment = fi -> comment ? strdup ( fi -> comment ) : NULL ; if ( comment ) { r_flag_item_set_comment ( fi , comment ) ; R_FREE ( comment ) ; } } } else { const char * n = sn . demname ? sn . demname : sn . name ; const char * fn = sn . demflag ? sn . demflag : sn . nameflag ; char * fnp = ( r -> bin -> prefix ) ? r_str_newf ( "%s.%s" , r -> bin -> prefix , fn ) : strdup ( fn ) ; RFlagItem * fi = r_flag_set ( r -> flags , fnp , addr , symbol -> size ) ; if ( fi ) { r_flag_item_set_realname ( fi , n ) ; fi -> demangled = ( bool ) ( size_t ) sn . demname ; } else { if ( fn ) { eprintf ( "[Warning]<S2SV_blank>Can\'t<S2SV_blank>find<S2SV_blank>flag<S2SV_blank>(%s)\\n" , fn ) ; } } free ( fnp ) ; } if ( sn . demname ) { r_meta_add ( r -> anal , R_META_TYPE_COMMENT , addr , symbol -> size , sn . demname ) ; } r_flag_space_pop ( r -> flags ) ; } else if ( IS_MODE_JSON ( mode ) ) { char * str = r_str_escape_utf8_for_json ( r_symbol_name , - 1 ) ; r_cons_printf ( "%s{\\"name\\":\\"%s\\"," "\\"demname\\":\\"%s\\"," "\\"flagname\\":\\"%s\\"," "\\"ordinal\\":%d," "\\"bind\\":\\"%s\\"," "\\"size\\":%d," "\\"type\\":\\"%s\\"," "\\"vaddr\\":%" PFMT64d "," "\\"paddr\\":%" PFMT64d "}" , ( ( exponly && firstexp ) || printHere ) ? "" : ( iter -> p ? "," : "" ) , str , sn . demname ? sn . demname : "" , sn . nameflag , symbol -> ordinal , symbol -> bind , ( int ) symbol -> size , symbol -> type , ( ut64 ) addr , ( ut64 ) symbol -> paddr ) ; free ( str ) ; } else if ( IS_MODE_SIMPLE ( mode ) ) { const char * name = sn . demname ? sn . demname : r_symbol_name ; r_cons_printf ( "0x%08" PFMT64x "<S2SV_blank>%d<S2SV_blank>%s\\n" , addr , ( int ) symbol -> size , name ) ; } else if ( IS_MODE_SIMPLEST ( mode ) ) { const char * name = sn . demname ? sn . demname : r_symbol_name ; r_cons_printf ( "%s\\n" , name ) ; } else if ( IS_MODE_RAD ( mode ) ) { if ( is_special_symbol ( symbol ) ) { goto next ; } RBinFile * binfile ; RBinPlugin * plugin ; const char * name = sn . demname ? sn . demname : r_symbol_name ; if ( ! name ) { goto next ; } if ( ! strncmp ( name , "imp." , 4 ) ) { if ( lastfs != 'i' ) { r_cons_printf ( "fs<S2SV_blank>imports\\n" ) ; } lastfs = 'i' ; } else { if ( lastfs != 's' ) { const char * fs = exponly ? "exports" : "symbols" ; r_cons_printf ( "fs<S2SV_blank>%s\\n" , fs ) ; } lastfs = 's' ; } if ( r -> bin -> prefix || * name ) { char * flagname = construct_symbol_flagname ( "sym" , name , MAXFLAG_LEN_DEFAULT ) ; if ( ! flagname ) { goto next ; } r_cons_printf ( "\\"f<S2SV_blank>%s%s%s<S2SV_blank>%u<S2SV_blank>0x%08" PFMT64x "\\"\\n" , r -> bin -> prefix ? r -> bin -> prefix : "" , r -> bin -> prefix ? "." : "" , flagname , symbol -> size , addr ) ; free ( flagname ) ; } binfile = r_bin_cur ( r -> bin ) ; plugin = r_bin_file_cur_plugin ( binfile ) ; if ( plugin && plugin -> name ) { if ( r_str_startswith ( plugin -> name , "pe" ) ) { char * module = strdup ( r_symbol_name ) ; char * p = strstr ( module , ".dll_" ) ; if ( p && strstr ( module , "imp." ) ) { char * symname = __filterShell ( p + 5 ) ; char * m = __filterShell ( module ) ; * p = 0 ; if ( r -> bin -> prefix ) { <S2SV_StartBug> r_cons_printf ( "k<S2SV_blank>bin/pe/%s/%d=%s.%s\\n" , <S2SV_EndBug> module , symbol -> ordinal , r -> bin -> prefix , symname ) ; } else { <S2SV_StartBug> r_cons_printf ( "k<S2SV_blank>bin/pe/%s/%d=%s\\n" , <S2SV_EndBug> module , symbol -> ordinal , symname ) ; } free ( symname ) ; free ( m ) ; } free ( module ) ; } } } else { const char * bind = symbol -> bind ? symbol -> bind : "NONE" ; const char * type = symbol -> type ? symbol -> type : "NONE" ; const char * name = r_str_get ( sn . demname ? sn . demname : r_symbol_name ) ; r_cons_printf ( "%03u" , symbol -> ordinal ) ; if ( symbol -> paddr == UT64_MAX ) { r_cons_printf ( "<S2SV_blank>----------" ) ; } else { r_cons_printf ( "<S2SV_blank>0x%08" PFMT64x , symbol -> paddr ) ; } r_cons_printf ( "<S2SV_blank>0x%08" PFMT64x "<S2SV_blank>%6s<S2SV_blank>%6s<S2SV_blank>%4d%s%s\\n" , addr , bind , type , symbol -> size , * name ? "<S2SV_blank>" : "" , name ) ; } next : snFini ( & sn ) ; i ++ ; free ( r_symbol_name ) ; if ( exponly && firstexp ) { firstexp = false ; } if ( printHere ) { break ; } } if ( count == 0 && IS_MODE_JSON ( mode ) ) { r_cons_printf ( "{}" ) ; } if ( is_arm ) { r_list_foreach ( entries , iter , entry ) { if ( IS_MODE_SET ( mode ) ) { handle_arm_entry ( r , entry , info , va ) ; } } } if ( IS_MODE_JSON ( mode ) && ! printHere ) { r_cons_printf ( "]" ) ; } r_spaces_pop ( & r -> anal -> meta_spaces ) ; return true ; }
CWE-78 static int r_core_cmd_subst_i ( RCore * core , char * cmd , char * colon , bool * tmpseek ) { RList * tmpenvs = r_list_newf ( tmpenvs_free ) ; const char * quotestr = "`" ; const char * tick = NULL ; char * ptr , * ptr2 , * str ; char * arroba = NULL ; char * grep = NULL ; RIODesc * tmpdesc = NULL ; int pamode = ! core -> io -> va ; int i , ret = 0 , pipefd ; bool usemyblock = false ; int scr_html = - 1 ; int scr_color = - 1 ; bool eos = false ; bool haveQuote = false ; bool oldfixedarch = core -> fixedarch ; bool oldfixedbits = core -> fixedbits ; bool cmd_tmpseek = false ; ut64 tmpbsz = core -> blocksize ; int cmd_ignbithints = - 1 ; if ( ! cmd ) { r_list_free ( tmpenvs ) ; return 0 ; } cmd = r_str_trim_head_tail ( cmd ) ; char * $0 = strstr ( cmd , "$(" ) ; if ( $0 ) { char * $1 = strchr ( $0 + 2 , ')' ) ; if ( $1 ) { * $0 = '`' ; * $1 = '`' ; memmove ( $0 + 1 , $0 + 2 , strlen ( $0 + 2 ) + 1 ) ; } else { eprintf ( "Unterminated<S2SV_blank>$()<S2SV_blank>block\\n" ) ; } } switch ( * cmd ) { case '.' : if ( cmd [ 1 ] == \'"\' ) { r_list_free ( tmpenvs ) ; return r_cmd_call ( core -> rcmd , cmd ) ; } break ; case \'"\' : for ( ; * cmd ; ) { int pipefd = - 1 ; ut64 oseek = UT64_MAX ; char * line , * p ; haveQuote = * cmd == \'"\' ; if ( haveQuote ) { cmd ++ ; p = * cmd ? find_eoq ( cmd ) : NULL ; if ( ! p || ! * p ) { eprintf ( "Missing<S2SV_blank>\\"<S2SV_blank>in<S2SV_blank>(%s)." , cmd ) ; r_list_free ( tmpenvs ) ; return false ; } * p ++ = 0 ; if ( ! * p ) { eos = true ; } } else { char * sc = strchr ( cmd , ';' ) ; if ( sc ) { * sc = 0 ; } r_core_cmd0 ( core , cmd ) ; if ( ! sc ) { break ; } cmd = sc + 1 ; continue ; } <S2SV_StartBug> if ( * p ) { <S2SV_EndBug> if ( p [ 0 ] == '@' ) { p -- ; } while ( p [ 1 ] == ';' || IS_WHITESPACE ( p [ 1 ] ) ) { p ++ ; } if ( p [ 1 ] == '@' || ( p [ 1 ] && p [ 2 ] == '@' ) ) { char * q = strchr ( p + 1 , \'"\' ) ; if ( q ) { <S2SV_StartBug> * q = 0 ; <S2SV_EndBug> } haveQuote = q != NULL ; oseek = core -> offset ; r_core_seek ( core , r_num_math ( core -> num , p + 2 ) , 1 ) ; if ( q ) { * p = \'"\' ; p = q ; } else { p = strchr ( p + 1 , ';' ) ; } } if ( p && * p && p [ 1 ] == '>' ) { str = p + 2 ; while ( * str == '>' ) { str ++ ; } str = ( char * ) r_str_trim_ro ( str ) ; r_cons_flush ( ) ; const bool append = p [ 2 ] == '>' ; pipefd = r_cons_pipe_open ( str , 1 , append ) ; } } line = strdup ( cmd ) ; line = r_str_replace ( line , "\\\\\\"" , "\\"" , true ) ; if ( p && * p && p [ 1 ] == '|' ) { str = p + 2 ; while ( IS_WHITESPACE ( * str ) ) { str ++ ; } r_core_cmd_pipe ( core , cmd , str ) ; } else { r_cmd_call ( core -> rcmd , line ) ; } free ( line ) ; if ( oseek != UT64_MAX ) { r_core_seek ( core , oseek , 1 ) ; } if ( pipefd != - 1 ) { r_cons_flush ( ) ; r_cons_pipe_close ( pipefd ) ; } if ( ! p ) { break ; } if ( eos ) { break ; } if ( haveQuote ) { if ( * p == ';' ) { cmd = p + 1 ; } else { if ( * p == \'"\' ) { <S2SV_StartBug> cmd = p + 1 ; <S2SV_EndBug> } else { <S2SV_StartBug> * p = \'"\' ; <S2SV_EndBug> cmd = p ; } } } else { cmd = p + 1 ; } } r_list_free ( tmpenvs ) ; return true ; case '(' : if ( cmd [ 1 ] != '*' && ! strstr ( cmd , ")()" ) ) { r_list_free ( tmpenvs ) ; return r_cmd_call ( core -> rcmd , cmd ) ; } break ; case '?' : if ( cmd [ 1 ] == '>' ) { r_core_cmd_help ( core , help_msg_greater_sign ) ; r_list_free ( tmpenvs ) ; return true ; } } if ( * cmd != '#' ) { ptr = ( char * ) r_str_firstbut ( cmd , '#' , "`\\"" ) ; if ( ptr && ( ptr [ 1 ] == '<S2SV_blank>' || ptr [ 1 ] == '\\t' ) ) { * ptr = '\\0' ; } } if ( * cmd != '#' ) { ptr = ( char * ) r_str_lastbut ( cmd , ';' , quotestr ) ; if ( colon && ptr ) { int ret ; * ptr = '\\0' ; if ( r_core_cmd_subst ( core , cmd ) == - 1 ) { r_list_free ( tmpenvs ) ; return - 1 ; } cmd = ptr + 1 ; ret = r_core_cmd_subst ( core , cmd ) ; * ptr = ';' ; r_list_free ( tmpenvs ) ; return ret ; } } ptr = ( char * ) r_str_lastbut ( cmd , '|' , quotestr ) ; if ( ptr ) { if ( ptr > cmd ) { char * ch = ptr - 1 ; if ( * ch == '\\\\' ) { memmove ( ch , ptr , strlen ( ptr ) + 1 ) ; goto escape_pipe ; } } char * ptr2 = strchr ( cmd , '`' ) ; if ( ! ptr2 || ( ptr2 && ptr2 > ptr ) ) { if ( ! tick || ( tick && tick > ptr ) ) { * ptr = '\\0' ; cmd = r_str_trim_nc ( cmd ) ; if ( ! strcmp ( ptr + 1 , "?" ) ) { r_core_cmd_help ( core , help_msg_vertical_bar ) ; r_list_free ( tmpenvs ) ; return ret ; } else if ( ! strncmp ( ptr + 1 , "H" , 1 ) ) { scr_html = r_config_get_i ( core -> config , "scr.html" ) ; r_config_set_i ( core -> config , "scr.html" , true ) ; } else if ( ! strcmp ( ptr + 1 , "T" ) ) { scr_color = r_config_get_i ( core -> config , "scr.color" ) ; r_config_set_i ( core -> config , "scr.color" , COLOR_MODE_DISABLED ) ; core -> cons -> use_tts = true ; } else if ( ! strcmp ( ptr + 1 , "." ) ) { ret = * cmd ? r_core_cmdf ( core , ".%s" , cmd ) : 0 ; r_list_free ( tmpenvs ) ; return ret ; } else if ( ptr [ 1 ] ) { int value = core -> num -> value ; if ( * cmd ) { r_core_cmd_pipe ( core , cmd , ptr + 1 ) ; } else { char * res = r_io_system ( core -> io , ptr + 1 ) ; if ( res ) { r_cons_printf ( "%s\\n" , res ) ; free ( res ) ; } } core -> num -> value = value ; r_list_free ( tmpenvs ) ; return 0 ; } else { scr_html = r_config_get_i ( core -> config , "scr.html" ) ; r_config_set_i ( core -> config , "scr.html" , 0 ) ; scr_color = r_config_get_i ( core -> config , "scr.color" ) ; r_config_set_i ( core -> config , "scr.color" , COLOR_MODE_DISABLED ) ; } } } } escape_pipe : ptr = ( char * ) r_str_lastbut ( cmd , '&' , quotestr ) ; while ( ptr && * ptr && ptr [ 1 ] == '&' ) { * ptr = '\\0' ; ret = r_cmd_call ( core -> rcmd , cmd ) ; if ( ret == - 1 ) { eprintf ( "command<S2SV_blank>error(%s)\\n" , cmd ) ; if ( scr_html != - 1 ) { r_config_set_i ( core -> config , "scr.html" , scr_html ) ; } if ( scr_color != - 1 ) { r_config_set_i ( core -> config , "scr.color" , scr_color ) ; } r_list_free ( tmpenvs ) ; return ret ; } for ( cmd = ptr + 2 ; cmd && * cmd == '<S2SV_blank>' ; cmd ++ ) { ; } ptr = strchr ( cmd , '&' ) ; } R_FREE ( core -> oobi ) ; ptr = strstr ( cmd , "?*" ) ; if ( ptr && ( ptr == cmd || ptr [ - 1 ] != '~' ) ) { ptr [ 0 ] = 0 ; if ( * cmd != '#' ) { int detail = 0 ; if ( cmd < ptr && ptr [ - 1 ] == '?' ) { detail ++ ; if ( cmd < ptr - 1 && ptr [ - 2 ] == '?' ) { detail ++ ; } } r_cons_break_push ( NULL , NULL ) ; recursive_help ( core , detail , cmd ) ; r_cons_break_pop ( ) ; r_cons_grep_parsecmd ( ptr + 2 , "`" ) ; if ( scr_html != - 1 ) { r_config_set_i ( core -> config , "scr.html" , scr_html ) ; } if ( scr_color != - 1 ) { r_config_set_i ( core -> config , "scr.color" , scr_color ) ; } r_list_free ( tmpenvs ) ; return 0 ; } } # if 0 ptr = strchr ( cmd , '<' ) ; if ( ptr ) { ptr [ 0 ] = '\\0' ; if ( r_cons_singleton ( ) -> is_interactive ) { if ( ptr [ 1 ] == '<' ) { for ( str = ptr + 2 ; str [ 0 ] == '<S2SV_blank>' ; str ++ ) { } eprintf ( "==><S2SV_blank>Reading<S2SV_blank>from<S2SV_blank>stdin<S2SV_blank>until<S2SV_blank>\'%s\'\\n" , str ) ; free ( core -> oobi ) ; core -> oobi = malloc ( 1 ) ; if ( core -> oobi ) { core -> oobi [ 0 ] = '\\0' ; } core -> oobi_len = 0 ; for ( ; ; ) { char buf [ 1024 ] ; int ret ; write ( 1 , "><S2SV_blank>" , 2 ) ; fgets ( buf , sizeof ( buf ) - 1 , stdin ) ; if ( feof ( stdin ) ) { break ; } if ( * buf ) buf [ strlen ( buf ) - 1 ] = '\\0' ; ret = strlen ( buf ) ; core -> oobi_len += ret ; core -> oobi = realloc ( core -> oobi , core -> oobi_len + 1 ) ; if ( core -> oobi ) { if ( ! strcmp ( buf , str ) ) { break ; } strcat ( ( char * ) core -> oobi , buf ) ; } } } else { for ( str = ptr + 1 ; * str == '<S2SV_blank>' ; str ++ ) { } if ( ! * str ) { goto next ; } eprintf ( "Slurping<S2SV_blank>file<S2SV_blank>\'%s\'\\n" , str ) ; free ( core -> oobi ) ; core -> oobi = ( ut8 * ) r_file_slurp ( str , & core -> oobi_len ) ; if ( ! core -> oobi ) { eprintf ( "cannot<S2SV_blank>open<S2SV_blank>file\\n" ) ; } else if ( ptr == cmd ) { return r_core_cmd_buffer ( core , ( const char * ) core -> oobi ) ; } } } else { eprintf ( "Cannot<S2SV_blank>slurp<S2SV_blank>with<S2SV_blank><<<S2SV_blank>in<S2SV_blank>non-interactive<S2SV_blank>mode\\n" ) ; r_list_free ( tmpenvs ) ; return 0 ; } } next : # endif ptr = ( char * ) r_str_firstbut ( cmd , '>' , "\\"" ) ; if ( ptr ) { if ( ptr > cmd ) { char * ch = ptr - 1 ; if ( * ch == '\\\\' ) { memmove ( ch , ptr , strlen ( ptr ) + 1 ) ; goto escape_redir ; } } if ( ptr [ 0 ] && ptr [ 1 ] == '?' ) { r_core_cmd_help ( core , help_msg_greater_sign ) ; r_list_free ( tmpenvs ) ; return true ; } int fdn = 1 ; int pipecolor = r_config_get_i ( core -> config , "scr.color.pipe" ) ; int use_editor = false ; int ocolor = r_config_get_i ( core -> config , "scr.color" ) ; * ptr = '\\0' ; str = r_str_trim_head_tail ( ptr + 1 + ( ptr [ 1 ] == '>' ) ) ; if ( ! * str ) { eprintf ( "No<S2SV_blank>output?\\n" ) ; goto next2 ; } if ( ptr > ( cmd + 1 ) && IS_WHITECHAR ( ptr [ - 2 ] ) ) { char * fdnum = ptr - 1 ; if ( * fdnum == 'H' ) { scr_html = r_config_get_i ( core -> config , "scr.html" ) ; r_config_set_i ( core -> config , "scr.html" , true ) ; pipecolor = true ; * fdnum = 0 ; } else { if ( IS_DIGIT ( * fdnum ) ) { fdn = * fdnum - '0' ; } * fdnum = 0 ; } } r_cons_set_interactive ( false ) ; if ( ! strcmp ( str , "-" ) ) { use_editor = true ; str = r_file_temp ( "dumpedit" ) ; r_config_set_i ( core -> config , "scr.color" , COLOR_MODE_DISABLED ) ; } const bool appendResult = ( ptr [ 1 ] == '>' ) ; if ( * str == '$' ) { char * o = r_core_cmd_str ( core , cmd ) ; if ( appendResult ) { char * oldText = r_cmd_alias_get ( core -> rcmd , str , 1 ) ; if ( oldText ) { char * two = r_str_newf ( "%s%s" , oldText , o ) ; if ( two ) { r_cmd_alias_set ( core -> rcmd , str , two , 1 ) ; free ( two ) ; } } else { char * n = r_str_newf ( "$%s" , o ) ; r_cmd_alias_set ( core -> rcmd , str , n , 1 ) ; free ( n ) ; } } else { char * n = r_str_newf ( "$%s" , o ) ; r_cmd_alias_set ( core -> rcmd , str , n , 1 ) ; free ( n ) ; } ret = 0 ; free ( o ) ; } else if ( fdn > 0 ) { pipefd = r_cons_pipe_open ( str , fdn , appendResult ) ; if ( pipefd != - 1 ) { if ( ! pipecolor ) { r_config_set_i ( core -> config , "scr.color" , COLOR_MODE_DISABLED ) ; } ret = r_core_cmd_subst ( core , cmd ) ; r_cons_flush ( ) ; r_cons_pipe_close ( pipefd ) ; } } r_cons_set_last_interactive ( ) ; if ( ! pipecolor ) { r_config_set_i ( core -> config , "scr.color" , ocolor ) ; } if ( use_editor ) { const char * editor = r_config_get ( core -> config , "cfg.editor" ) ; if ( editor && * editor ) { r_sys_cmdf ( "%s<S2SV_blank>\'%s\'" , editor , str ) ; r_file_rm ( str ) ; } else { eprintf ( "No<S2SV_blank>cfg.editor<S2SV_blank>configured\\n" ) ; } r_config_set_i ( core -> config , "scr.color" , ocolor ) ; free ( str ) ; } if ( scr_html != - 1 ) { r_config_set_i ( core -> config , "scr.html" , scr_html ) ; } if ( scr_color != - 1 ) { r_config_set_i ( core -> config , "scr.color" , scr_color ) ; } core -> cons -> use_tts = false ; r_list_free ( tmpenvs ) ; return ret ; } escape_redir : next2 : ptr = strchr ( cmd , '`' ) ; if ( ptr ) { if ( ptr > cmd ) { char * ch = ptr - 1 ; if ( * ch == '\\\\' ) { memmove ( ch , ptr , strlen ( ptr ) + 1 ) ; goto escape_backtick ; } } bool empty = false ; int oneline = 1 ; if ( ptr [ 1 ] == '`' ) { memmove ( ptr , ptr + 1 , strlen ( ptr ) ) ; oneline = 0 ; empty = true ; } ptr2 = strchr ( ptr + 1 , '`' ) ; if ( empty ) { } else if ( ! ptr2 ) { eprintf ( "parse:<S2SV_blank>Missing<S2SV_blank>backtick<S2SV_blank>in<S2SV_blank>expression.\\n" ) ; goto fail ; } else { int value = core -> num -> value ; * ptr = '\\0' ; * ptr2 = '\\0' ; if ( ptr [ 1 ] == '!' ) { str = r_core_cmd_str_pipe ( core , ptr + 1 ) ; } else { int ocolor = r_config_get_i ( core -> config , "scr.color" ) ; r_config_set_i ( core -> config , "scr.color" , 0 ) ; core -> cmd_in_backticks = true ; str = r_core_cmd_str ( core , ptr + 1 ) ; core -> cmd_in_backticks = false ; r_config_set_i ( core -> config , "scr.color" , ocolor ) ; } if ( ! str ) { goto fail ; } if ( * str == '|' || * str == '*' ) { eprintf ( "r_core_cmd_subst_i:<S2SV_blank>invalid<S2SV_blank>backticked<S2SV_blank>command\\n" ) ; free ( str ) ; goto fail ; } if ( oneline && str ) { for ( i = 0 ; str [ i ] ; i ++ ) { if ( str [ i ] == '\\n' ) { str [ i ] = '<S2SV_blank>' ; } } } str = r_str_append ( str , ptr2 + 1 ) ; cmd = r_str_append ( strdup ( cmd ) , str ) ; core -> num -> value = value ; ret = r_core_cmd_subst ( core , cmd ) ; free ( cmd ) ; if ( scr_html != - 1 ) { r_config_set_i ( core -> config , "scr.html" , scr_html ) ; } free ( str ) ; r_list_free ( tmpenvs ) ; return ret ; } } escape_backtick : if ( * cmd != \'"\' && * cmd ) { const char * s = strstr ( cmd , "~?" ) ; if ( s ) { bool showHelp = false ; if ( cmd == s ) { showHelp = true ; } else { if ( ! strcmp ( s , "~??" ) ) { showHelp = true ; } } if ( showHelp ) { r_cons_grep_help ( ) ; r_list_free ( tmpenvs ) ; return true ; } } } if ( * cmd != '.' ) { grep = r_cons_grep_strip ( cmd , quotestr ) ; } if ( * cmd != \'"\' ) { ptr = strchr ( cmd , '@' ) ; if ( ptr == cmd + 1 && * cmd == '?' ) { ptr = NULL ; } } else { ptr = NULL ; } cmd_tmpseek = core -> tmpseek = ptr ? true : false ; int rc = 0 ; if ( ptr ) { char * f , * ptr2 = strchr ( ptr + 1 , '!' ) ; ut64 addr = core -> offset ; bool addr_is_set = false ; char * tmpbits = NULL ; const char * offstr = NULL ; bool is_bits_set = false ; bool is_arch_set = false ; char * tmpeval = NULL ; char * tmpasm = NULL ; bool flgspc_changed = false ; int tmpfd = - 1 ; int sz , len ; ut8 * buf ; * ptr ++ = '\\0' ; repeat_arroba : arroba = ( ptr [ 0 ] && ptr [ 1 ] && ptr [ 2 ] ) ? strchr ( ptr + 2 , '@' ) : NULL ; if ( arroba ) { * arroba = 0 ; } for ( ; * ptr == '<S2SV_blank>' ; ptr ++ ) { } if ( * ptr && ptr [ 1 ] == ':' ) { } else { ptr -- ; } ptr = r_str_trim_tail ( ptr ) ; if ( ptr [ 1 ] == '?' ) { r_core_cmd_help ( core , help_msg_at ) ; } else if ( ptr [ 1 ] == '%' ) { char * k = strdup ( ptr + 2 ) ; char * v = strchr ( k , '=' ) ; if ( v ) { * v ++ = 0 ; r_sys_setenv ( k , v ) ; r_list_append ( tmpenvs , k ) ; } else { free ( k ) ; } } else if ( ptr [ 1 ] == '.' ) { if ( ptr [ 2 ] == '.' ) { if ( ptr [ 3 ] == '.' ) { ut64 addr = r_num_tail ( core -> num , core -> offset , ptr + 4 ) ; r_core_block_size ( core , R_ABS ( ( st64 ) addr - ( st64 ) core -> offset ) ) ; goto fuji ; } else { addr = r_num_tail ( core -> num , core -> offset , ptr + 3 ) ; r_core_seek ( core , addr , 1 ) ; cmd_tmpseek = core -> tmpseek = true ; goto fuji ; } } else { eprintf ( "TODO:<S2SV_blank>what<S2SV_blank>do<S2SV_blank>you<S2SV_blank>expect<S2SV_blank>for<S2SV_blank>@.<S2SV_blank>import<S2SV_blank>offset<S2SV_blank>from<S2SV_blank>file<S2SV_blank>maybe?\\n" ) ; } } else if ( ptr [ 0 ] && ptr [ 1 ] == ':' && ptr [ 2 ] ) { switch ( ptr [ 0 ] ) { case 'F' : flgspc_changed = r_flag_space_push ( core -> flags , ptr + 2 ) ; break ; case 'B' : { int index = ( int ) r_num_math ( core -> num , ptr + 2 ) ; RAnalBlock * bb = r_anal_bb_from_offset ( core -> anal , core -> offset ) ; if ( bb ) { if ( index < 0 ) { index = bb -> ninstr + index ; } if ( index >= 0 && index < bb -> ninstr ) { ut16 inst_off = r_anal_bb_offset_inst ( bb , index ) ; r_core_seek ( core , bb -> addr + inst_off , 1 ) ; cmd_tmpseek = core -> tmpseek = true ; } else { eprintf ( "The<S2SV_blank>current<S2SV_blank>basic<S2SV_blank>block<S2SV_blank>has<S2SV_blank>%d<S2SV_blank>instructions\\n" , bb -> ninstr ) ; } } else { eprintf ( "Can\'t<S2SV_blank>find<S2SV_blank>a<S2SV_blank>basic<S2SV_blank>block<S2SV_blank>for<S2SV_blank>0x%08" PFMT64x "\\n" , core -> offset ) ; } break ; } break ; case 'f' : f = r_file_slurp ( ptr + 2 , & sz ) ; if ( f ) { { RBuffer * b = r_buf_new_with_bytes ( ( const ut8 * ) f , sz ) ; RIODesc * d = r_io_open_buffer ( core -> io , b , R_PERM_RWX , 0 ) ; if ( d ) { if ( tmpdesc ) { r_io_desc_close ( tmpdesc ) ; } tmpdesc = d ; if ( pamode ) { r_config_set_i ( core -> config , "io.va" , 1 ) ; } r_io_map_new ( core -> io , d -> fd , d -> perm , 0 , core -> offset , r_buf_size ( b ) ) ; } } # if 0 buf = malloc ( sz ) ; if ( buf ) { free ( core -> block ) ; core -> block = buf ; core -> blocksize = sz ; memcpy ( core -> block , f , sz ) ; usemyblock = true ; } else { eprintf ( "cannot<S2SV_blank>alloc<S2SV_blank>%d" , sz ) ; } free ( f ) ; # endif } else { eprintf ( "cannot<S2SV_blank>open<S2SV_blank>\'%s\'\\n" , ptr + 3 ) ; } break ; case 'r' : if ( ptr [ 1 ] == ':' ) { ut64 regval ; char * mander = strdup ( ptr + 2 ) ; char * sep = findSeparator ( mander ) ; if ( sep ) { char ch = * sep ; * sep = 0 ; regval = r_debug_reg_get ( core -> dbg , mander ) ; * sep = ch ; char * numexpr = r_str_newf ( "0x%" PFMT64x "%s" , regval , sep ) ; regval = r_num_math ( core -> num , numexpr ) ; free ( numexpr ) ; } else { regval = r_debug_reg_get ( core -> dbg , ptr + 2 ) ; } r_core_seek ( core , regval , 1 ) ; cmd_tmpseek = core -> tmpseek = true ; free ( mander ) ; } break ; case 'b' : is_bits_set = set_tmp_bits ( core , r_num_math ( core -> num , ptr + 2 ) , & tmpbits ) ; cmd_ignbithints = r_config_get_i ( core -> config , "anal.ignbithints" ) ; r_config_set_i ( core -> config , "anal.ignbithints" , 1 ) ; break ; case 'i' : { ut64 addr = r_num_math ( core -> num , ptr + 2 ) ; if ( addr ) { r_core_cmdf ( core , "so<S2SV_blank>%s" , ptr + 2 ) ; cmd_tmpseek = core -> tmpseek = true ; } } break ; case 'e' : { char * cmd = parse_tmp_evals ( core , ptr + 2 ) ; if ( ! tmpeval ) { tmpeval = cmd ; } else { tmpeval = r_str_prepend ( tmpeval , cmd ) ; free ( cmd ) ; } } break ; case 'x' : if ( ptr [ 1 ] == ':' ) { buf = malloc ( strlen ( ptr + 2 ) + 1 ) ; if ( buf ) { len = r_hex_str2bin ( ptr + 2 , buf ) ; r_core_block_size ( core , R_ABS ( len ) ) ; if ( len > 0 ) { RBuffer * b = r_buf_new_with_bytes ( buf , len ) ; RIODesc * d = r_io_open_buffer ( core -> io , b , R_PERM_RWX , 0 ) ; if ( d ) { if ( tmpdesc ) { r_io_desc_close ( tmpdesc ) ; } tmpdesc = d ; if ( pamode ) { r_config_set_i ( core -> config , "io.va" , 1 ) ; } r_io_map_new ( core -> io , d -> fd , d -> perm , 0 , core -> offset , r_buf_size ( b ) ) ; r_core_block_size ( core , len ) ; r_core_block_read ( core ) ; } } else { eprintf ( "Error:<S2SV_blank>Invalid<S2SV_blank>hexpairs<S2SV_blank>for<S2SV_blank>@x:\\n" ) ; } free ( buf ) ; } else { eprintf ( "cannot<S2SV_blank>allocate\\n" ) ; } } else { eprintf ( "Invalid<S2SV_blank>@x:<S2SV_blank>syntax\\n" ) ; } break ; case 'k' : { char * out = sdb_querys ( core -> sdb , NULL , 0 , ptr + ( ( ptr [ 1 ] ) ? 2 : 1 ) ) ; if ( out ) { r_core_seek ( core , r_num_math ( core -> num , out ) , 1 ) ; free ( out ) ; usemyblock = true ; } } break ; case 'o' : if ( ptr [ 1 ] == ':' ) { tmpfd = core -> io -> desc ? core -> io -> desc -> fd : - 1 ; r_io_use_fd ( core -> io , atoi ( ptr + 2 ) ) ; } break ; case 'a' : if ( ptr [ 1 ] == ':' ) { char * q = strchr ( ptr + 2 , ':' ) ; if ( q ) { * q ++ = 0 ; int bits = r_num_math ( core -> num , q ) ; is_bits_set = set_tmp_bits ( core , bits , & tmpbits ) ; } is_arch_set = set_tmp_arch ( core , ptr + 2 , & tmpasm ) ; } else { eprintf ( "Usage:<S2SV_blank>pd<S2SV_blank>10<S2SV_blank>@a:arm:32\\n" ) ; } break ; case 's' : { len = strlen ( ptr + 2 ) ; r_core_block_size ( core , len ) ; const ut8 * buf = ( const ut8 * ) r_str_trim_ro ( ptr + 2 ) ; if ( len > 0 ) { RBuffer * b = r_buf_new_with_bytes ( buf , len ) ; RIODesc * d = r_io_open_buffer ( core -> io , b , R_PERM_RWX , 0 ) ; if ( ! core -> io -> va ) { r_config_set_i ( core -> config , "io.va" , 1 ) ; } if ( d ) { if ( tmpdesc ) { r_io_desc_close ( tmpdesc ) ; } tmpdesc = d ; if ( pamode ) { r_config_set_i ( core -> config , "io.va" , 1 ) ; } r_io_map_new ( core -> io , d -> fd , d -> perm , 0 , core -> offset , r_buf_size ( b ) ) ; r_core_block_size ( core , len ) ; } } } break ; default : goto ignore ; } * ptr = '@' ; char * trim = ptr - 2 ; while ( trim > cmd ) { if ( ! IS_WHITESPACE ( * trim ) ) { break ; } * trim = 0 ; trim -- ; } goto next_arroba ; } ignore : ptr = r_str_trim_head ( ptr + 1 ) - 1 ; cmd = r_str_trim_nc ( cmd ) ; if ( ptr2 ) { if ( strlen ( ptr + 1 ) == 13 && strlen ( ptr2 + 1 ) == 6 && ! memcmp ( ptr + 1 , "0x" , 2 ) && ! memcmp ( ptr2 + 1 , "0x" , 2 ) ) { } else if ( strlen ( ptr + 1 ) == 9 && strlen ( ptr2 + 1 ) == 4 ) { } else { * ptr2 = '\\0' ; if ( ! ptr2 [ 1 ] ) { goto fail ; } r_core_block_size ( core , r_num_math ( core -> num , ptr2 + 1 ) ) ; } } offstr = r_str_trim_head ( ptr + 1 ) ; addr = r_num_math ( core -> num , offstr ) ; addr_is_set = true ; if ( isalpha ( ( ut8 ) ptr [ 1 ] ) && ! addr ) { if ( ! r_flag_get ( core -> flags , ptr + 1 ) ) { eprintf ( "Invalid<S2SV_blank>address<S2SV_blank>(%s)\\n" , ptr + 1 ) ; goto fail ; } } else { char ch = * offstr ; if ( ch == '-' || ch == '+' ) { addr = core -> offset + addr ; } } if ( addr ) { RIODesc * d = tmpdesc ; if ( d ) { r_io_map_new ( core -> io , d -> fd , d -> perm , 0 , addr , r_io_desc_size ( d ) ) ; } } next_arroba : if ( arroba ) { ptr = arroba + 1 ; * arroba = '@' ; arroba = NULL ; goto repeat_arroba ; } core -> fixedblock = ! ! tmpdesc ; if ( core -> fixedblock ) { r_core_block_read ( core ) ; } if ( ptr [ 1 ] == '@' ) { if ( ptr [ 2 ] == '@' ) { char * rule = ptr + 3 ; while ( * rule && * rule == '<S2SV_blank>' ) { rule ++ ; } ret = r_core_cmd_foreach3 ( core , cmd , rule ) ; } else { ret = r_core_cmd_foreach ( core , cmd , ptr + 2 ) ; } } else { bool tmpseek = false ; const char * fromvars [ ] = { "anal.from" , "diff.from" , "graph.from" , "io.buffer.from" , "lines.from" , "search.from" , "zoom.from" , NULL } ; const char * tovars [ ] = { "anal.to" , "diff.to" , "graph.to" , "io.buffer.to" , "lines.to" , "search.to" , "zoom.to" , NULL } ; ut64 curfrom [ R_ARRAY_SIZE ( fromvars ) - 1 ] , curto [ R_ARRAY_SIZE ( tovars ) - 1 ] ; if ( ptr [ 1 ] == '(' ) { char * range = ptr + 3 ; char * p = strchr ( range , '<S2SV_blank>' ) ; if ( ! p ) { eprintf ( "Usage:<S2SV_blank>/<S2SV_blank>ABCD<S2SV_blank>@..0x1000<S2SV_blank>0x3000\\n" ) ; free ( tmpeval ) ; free ( tmpasm ) ; free ( tmpbits ) ; goto fail ; } * p = '\\x00' ; ut64 from = r_num_math ( core -> num , range ) ; ut64 to = r_num_math ( core -> num , p + 1 ) ; for ( i = 0 ; fromvars [ i ] ; i ++ ) { curfrom [ i ] = r_config_get_i ( core -> config , fromvars [ i ] ) ; } for ( i = 0 ; tovars [ i ] ; i ++ ) { curto [ i ] = r_config_get_i ( core -> config , tovars [ i ] ) ; } for ( i = 0 ; fromvars [ i ] ; i ++ ) { r_config_set_i ( core -> config , fromvars [ i ] , from ) ; } for ( i = 0 ; tovars [ i ] ; i ++ ) { r_config_set_i ( core -> config , tovars [ i ] , to ) ; } tmpseek = true ; } if ( usemyblock ) { if ( addr_is_set ) { core -> offset = addr ; } ret = r_cmd_call ( core -> rcmd , r_str_trim_head ( cmd ) ) ; } else { if ( addr_is_set ) { if ( ptr [ 1 ] ) { r_core_seek ( core , addr , 1 ) ; r_core_block_read ( core ) ; } } ret = r_cmd_call ( core -> rcmd , r_str_trim_head ( cmd ) ) ; } if ( tmpseek ) { for ( i = 0 ; fromvars [ i ] ; i ++ ) { r_config_set_i ( core -> config , fromvars [ i ] , curfrom [ i ] ) ; } for ( i = 0 ; tovars [ i ] ; i ++ ) { r_config_set_i ( core -> config , tovars [ i ] , curto [ i ] ) ; } } } if ( ptr2 ) { * ptr2 = '!' ; r_core_block_size ( core , tmpbsz ) ; } if ( is_arch_set ) { core -> fixedarch = oldfixedarch ; r_config_set ( core -> config , "asm.arch" , tmpasm ) ; R_FREE ( tmpasm ) ; } if ( tmpfd != - 1 ) { r_io_use_fd ( core -> io , tmpfd ) ; } if ( tmpdesc ) { if ( pamode ) { r_config_set_i ( core -> config , "io.va" , 0 ) ; } r_io_desc_close ( tmpdesc ) ; tmpdesc = NULL ; } if ( is_bits_set ) { r_config_set ( core -> config , "asm.bits" , tmpbits ) ; core -> fixedbits = oldfixedbits ; } if ( tmpbsz != core -> blocksize ) { r_core_block_size ( core , tmpbsz ) ; } if ( tmpeval ) { r_core_cmd0 ( core , tmpeval ) ; R_FREE ( tmpeval ) ; } if ( flgspc_changed ) { r_flag_space_pop ( core -> flags ) ; } * ptr = '@' ; rc = ret ; goto beach ; } fuji : rc = cmd ? r_cmd_call ( core -> rcmd , r_str_trim_head ( cmd ) ) : false ; beach : r_cons_grep_process ( grep ) ; if ( scr_html != - 1 ) { r_cons_flush ( ) ; r_config_set_i ( core -> config , "scr.html" , scr_html ) ; } if ( scr_color != - 1 ) { r_config_set_i ( core -> config , "scr.color" , scr_color ) ; } r_list_free ( tmpenvs ) ; if ( tmpdesc ) { r_io_desc_close ( tmpdesc ) ; tmpdesc = NULL ; } core -> fixedarch = oldfixedarch ; core -> fixedbits = oldfixedbits ; if ( tmpseek ) { * tmpseek = cmd_tmpseek ; } if ( cmd_ignbithints != - 1 ) { r_config_set_i ( core -> config , "anal.ignbithints" , cmd_ignbithints ) ; } return rc ; fail : rc = - 1 ; goto beach ; }
CWE-119 RD_BOOL <S2SV_StartBug> ber_parse_header ( STREAM s , int tagval , int * length ) <S2SV_EndBug> { int tag , len ; if ( tagval > 0xff ) { in_uint16_be ( s , tag ) ; } else { in_uint8 ( s , tag ) ; } if ( tag != tagval ) { logger ( Core , Error , "ber_parse_header(),<S2SV_blank>expected<S2SV_blank>tag<S2SV_blank>%d,<S2SV_blank>got<S2SV_blank>%d" , tagval , tag ) ; return False ; } in_uint8 ( s , len ) ; if ( len & 0x80 ) { len &= ~ 0x80 ; * length = 0 ; while ( len -- ) next_be ( s , * length ) ; } else * length = len ; return s_check ( s ) ; }
CWE-119 static int process_plane ( uint8 * in , int width , int height , uint8 * out , int size ) { UNUSED ( size ) ; int indexw ; int indexh ; int code ; int collen ; int replen ; int color ; int x ; int revcode ; uint8 * last_line ; uint8 * this_line ; uint8 * org_in ; uint8 * org_out ; org_in = in ; org_out = out ; last_line = 0 ; indexh = 0 ; while ( indexh < height ) { out = ( org_out + width * height * 4 ) - ( ( indexh + 1 ) * width * 4 ) ; color = 0 ; this_line = out ; indexw = 0 ; if ( last_line == 0 ) { while ( indexw < width ) { code = CVAL ( in ) ; replen = code & 0xf ; collen = ( code >> 4 ) & 0xf ; revcode = ( replen << 4 ) | collen ; if ( ( revcode <= 47 ) && ( revcode >= 16 ) ) { replen = revcode ; collen = 0 ; } <S2SV_StartBug> while ( collen > 0 ) <S2SV_EndBug> { color = CVAL ( in ) ; * out = color ; out += 4 ; indexw ++ ; collen -- ; } <S2SV_StartBug> while ( replen > 0 ) <S2SV_EndBug> { * out = color ; out += 4 ; indexw ++ ; replen -- ; } } } else { while ( indexw < width ) { code = CVAL ( in ) ; replen = code & 0xf ; collen = ( code >> 4 ) & 0xf ; revcode = ( replen << 4 ) | collen ; if ( ( revcode <= 47 ) && ( revcode >= 16 ) ) { replen = revcode ; collen = 0 ; } <S2SV_StartBug> while ( collen > 0 ) <S2SV_EndBug> { x = CVAL ( in ) ; if ( x & 1 ) { x = x >> 1 ; x = x + 1 ; color = - x ; } else { x = x >> 1 ; color = x ; } x = last_line [ indexw * 4 ] + color ; * out = x ; out += 4 ; indexw ++ ; collen -- ; } <S2SV_StartBug> while ( replen > 0 ) <S2SV_EndBug> { x = last_line [ indexw * 4 ] + color ; * out = x ; out += 4 ; indexw ++ ; replen -- ; } } } indexh ++ ; last_line = this_line ; } return ( int ) ( in - org_in ) ; }
CWE-119 static void cliprdr_process ( STREAM s ) { uint16 type , status ; uint32 length , format ; uint8 * data ; <S2SV_StartBug> in_uint16_le ( s , type ) ; <S2SV_EndBug> in_uint16_le ( s , status ) ; in_uint32_le ( s , length ) ; data = s -> p ; logger ( Clipboard , Debug , "cliprdr_process(),<S2SV_blank>type=%d,<S2SV_blank>status=%d,<S2SV_blank>length=%d" , type , status , length ) ; <S2SV_StartBug> if ( status == CLIPRDR_ERROR ) <S2SV_EndBug> { switch ( type ) { case CLIPRDR_FORMAT_ACK : cliprdr_send_native_format_announce ( last_formats , last_formats_length ) ; break ; case CLIPRDR_DATA_RESPONSE : ui_clip_request_failed ( ) ; break ; default : logger ( Clipboard , Warning , "cliprdr_process(),<S2SV_blank>unhandled<S2SV_blank>error<S2SV_blank>(type=%d)" , type ) ; } return ; } switch ( type ) { case CLIPRDR_CONNECT : ui_clip_sync ( ) ; break ; case CLIPRDR_FORMAT_ANNOUNCE : ui_clip_format_announce ( data , length ) ; cliprdr_send_packet ( CLIPRDR_FORMAT_ACK , CLIPRDR_RESPONSE , NULL , 0 ) ; return ; case CLIPRDR_FORMAT_ACK : break ; case CLIPRDR_DATA_REQUEST : in_uint32_le ( s , format ) ; ui_clip_request_data ( format ) ; break ; case CLIPRDR_DATA_RESPONSE : ui_clip_handle_data ( data , length ) ; break ; case 7 : break ; default : logger ( Clipboard , Warning , "cliprdr_process(),<S2SV_blank>unhandled<S2SV_blank>packet<S2SV_blank>type<S2SV_blank>%d" , type ) ; } }
CWE-119 RD_BOOL cssp_read_tsrequest ( STREAM token , STREAM pubkey ) { STREAM s ; int length ; int tagval ; <S2SV_StartBug> s = tcp_recv ( NULL , 4 ) ; <S2SV_EndBug> if ( s == NULL ) return False ; if ( s -> p [ 0 ] != ( BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED ) ) { logger ( Protocol , Error , "cssp_read_tsrequest(),<S2SV_blank>expected<S2SV_blank>BER_TAG_SEQUENCE|BER_TAG_CONSTRUCTED,<S2SV_blank>got<S2SV_blank>%x" , s -> p [ 0 ] ) ; return False ; } if ( s -> p [ 1 ] < 0x80 ) length = s -> p [ 1 ] - 2 ; else if ( s -> p [ 1 ] == 0x81 ) length = s -> p [ 2 ] - 1 ; else if ( s -> p [ 1 ] == 0x82 ) length = ( s -> p [ 2 ] << 8 ) | s -> p [ 3 ] ; else return False ; s = tcp_recv ( s , length ) ; <S2SV_StartBug> if ( ! ber_in_header ( s , & tagval , & length ) || <S2SV_EndBug> tagval != ( BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED ) ) return False ; if ( ! ber_in_header ( s , & tagval , & length ) || tagval != ( BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 0 ) ) return False ; <S2SV_StartBug> in_uint8s ( s , length ) ; <S2SV_EndBug> if ( token ) { if ( ! ber_in_header ( s , & tagval , & length ) || tagval != ( BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 1 ) ) return False ; if ( ! ber_in_header ( s , & tagval , & length ) || tagval != ( BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED ) ) return False ; if ( ! ber_in_header ( s , & tagval , & length ) || tagval != ( BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED ) ) return False ; if ( ! ber_in_header ( s , & tagval , & length ) || tagval != ( BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 0 ) ) return False ; if ( ! ber_in_header ( s , & tagval , & length ) || tagval != BER_TAG_OCTET_STRING ) return False ; <S2SV_StartBug> token -> end = token -> p = token -> data ; <S2SV_EndBug> out_uint8p ( token , s -> p , length ) ; s_mark_end ( token ) ; } if ( pubkey ) { if ( ! ber_in_header ( s , & tagval , & length ) || tagval != ( BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 3 ) ) return False ; if ( ! ber_in_header ( s , & tagval , & length ) || tagval != BER_TAG_OCTET_STRING ) return False ; pubkey -> data = pubkey -> p = s -> p ; pubkey -> end = pubkey -> data + length ; pubkey -> size = length ; } return True ; }
CWE-119 static void lspci_process ( STREAM s ) { unsigned int pkglen ; static char * rest = NULL ; <S2SV_StartBug> char * buf ; <S2SV_EndBug> pkglen = s -> end - s -> p ; buf = xmalloc ( pkglen + 1 ) ; STRNCPY ( buf , ( char * ) s -> p , pkglen + 1 ) ; str_handle_lines ( buf , & rest , lspci_process_line , NULL ) ; xfree ( buf ) ; }
CWE-119 static RD_BOOL mcs_parse_domain_params ( STREAM s ) { <S2SV_StartBug> int length ; <S2SV_EndBug> <S2SV_StartBug> ber_parse_header ( s , MCS_TAG_DOMAIN_PARAMS , & length ) ; <S2SV_EndBug> in_uint8s ( s , length ) ; return s_check ( s ) ; }
CWE-119 static RD_BOOL mcs_recv_connect_response ( STREAM mcs_data ) { UNUSED ( mcs_data ) ; uint8 result ; <S2SV_StartBug> int length ; <S2SV_EndBug> <S2SV_StartBug> STREAM s ; <S2SV_EndBug> RD_BOOL is_fastpath ; uint8 fastpath_hdr ; logger ( Protocol , Debug , "%s()" , __func__ ) ; s = iso_recv ( & is_fastpath , & fastpath_hdr ) ; if ( s == NULL ) return False ; <S2SV_StartBug> ber_parse_header ( s , MCS_CONNECT_RESPONSE , & length ) ; <S2SV_EndBug> ber_parse_header ( s , BER_TAG_RESULT , & length ) ; in_uint8 ( s , result ) ; if ( result != 0 ) { logger ( Protocol , Error , "mcs_recv_connect_response(),<S2SV_blank>result=%d" , result ) ; return False ; } ber_parse_header ( s , BER_TAG_INTEGER , & length ) ; in_uint8s ( s , length ) ; <S2SV_StartBug> mcs_parse_domain_params ( s ) ; <S2SV_EndBug> ber_parse_header ( s , BER_TAG_OCTET_STRING , & length ) ; sec_process_mcs_data ( s ) ; return s_check_end ( s ) ; }
CWE-119 static void process_secondary_order ( STREAM s ) { uint16 length ; uint16 flags ; uint8 type ; uint8 * next_order ; <S2SV_StartBug> in_uint16_le ( s , length ) ; <S2SV_EndBug> in_uint16_le ( s , flags ) ; <S2SV_StartBug> in_uint8 ( s , type ) ; <S2SV_EndBug> next_order = s -> p + ( sint16 ) length + 7 ; switch ( type ) { case RDP_ORDER_RAW_BMPCACHE : process_raw_bmpcache ( s ) ; break ; case RDP_ORDER_COLCACHE : process_colcache ( s ) ; break ; case RDP_ORDER_BMPCACHE : process_bmpcache ( s ) ; break ; case RDP_ORDER_FONTCACHE : process_fontcache ( s ) ; break ; case RDP_ORDER_RAW_BMPCACHE2 : process_bmpcache2 ( s , flags , False ) ; break ; case RDP_ORDER_BMPCACHE2 : process_bmpcache2 ( s , flags , True ) ; break ; case RDP_ORDER_BRUSHCACHE : process_brushcache ( s , flags ) ; break ; default : logger ( Graphics , Warning , "process_secondary_order(),<S2SV_blank>unhandled<S2SV_blank>secondary<S2SV_blank>order<S2SV_blank>%d" , type ) ; } s -> p = next_order ; }
CWE-416 void comps_mrtree_unite ( COMPS_MRTree * rt1 , COMPS_MRTree * rt2 ) { COMPS_HSList * tmplist , * tmp_subnodes ; COMPS_HSListItem * it , * it2 ; struct Pair { COMPS_HSList * subnodes ; char * key ; <S2SV_StartBug> char added ; <S2SV_EndBug> } * pair , * parent_pair ; pair = malloc ( sizeof ( struct Pair ) ) ; pair -> subnodes = rt2 -> subnodes ; pair -> key = NULL ; tmplist = comps_hslist_create ( ) ; comps_hslist_init ( tmplist , NULL , NULL , & free ) ; comps_hslist_append ( tmplist , pair , 0 ) ; while ( tmplist -> first != NULL ) { it = tmplist -> first ; comps_hslist_remove ( tmplist , tmplist -> first ) ; tmp_subnodes = ( ( struct Pair * ) it -> data ) -> subnodes ; parent_pair = ( struct Pair * ) it -> data ; free ( it ) ; <S2SV_StartBug> pair -> added = 0 ; <S2SV_EndBug> for ( it = tmp_subnodes -> first ; it != NULL ; it = it -> next ) { pair = malloc ( sizeof ( struct Pair ) ) ; pair -> subnodes = ( ( COMPS_MRTreeData * ) it -> data ) -> subnodes ; if ( parent_pair -> key != NULL ) { pair -> key = malloc ( sizeof ( char ) * ( strlen ( ( ( COMPS_MRTreeData * ) it -> data ) -> key ) + strlen ( parent_pair -> key ) + 1 ) ) ; memcpy ( pair -> key , parent_pair -> key , sizeof ( char ) * strlen ( parent_pair -> key ) ) ; memcpy ( pair -> key + strlen ( parent_pair -> key ) , ( ( COMPS_MRTreeData * ) it -> data ) -> key , sizeof ( char ) * ( strlen ( ( ( COMPS_MRTreeData * ) it -> data ) -> key ) + 1 ) ) ; } else { pair -> key = malloc ( sizeof ( char ) * ( strlen ( ( ( COMPS_MRTreeData * ) it -> data ) -> key ) + 1 ) ) ; memcpy ( pair -> key , ( ( COMPS_MRTreeData * ) it -> data ) -> key , sizeof ( char ) * ( strlen ( ( ( COMPS_MRTreeData * ) it -> data ) -> key ) + 1 ) ) ; } if ( ( ( COMPS_MRTreeData * ) it -> data ) -> data -> first != NULL ) { for ( it2 = ( ( COMPS_MRTreeData * ) it -> data ) -> data -> first ; it2 != NULL ; it2 = it2 -> next ) { comps_mrtree_set ( rt1 , pair -> key , it2 -> data ) ; } if ( ( ( COMPS_MRTreeData * ) it -> data ) -> subnodes -> first ) { comps_hslist_append ( tmplist , pair , 0 ) ; } else { free ( pair -> key ) ; free ( pair ) ; } } else { if ( ( ( COMPS_MRTreeData * ) it -> data ) -> subnodes -> first ) { comps_hslist_append ( tmplist , pair , 0 ) ; } else { free ( pair -> key ) ; free ( pair ) ; } } } free ( parent_pair -> key ) ; free ( parent_pair ) ; } comps_hslist_destroy ( & tmplist ) ; }
CWE-416 void comps_objmrtree_unite ( COMPS_ObjMRTree * rt1 , COMPS_ObjMRTree * rt2 ) { COMPS_HSList * tmplist , * tmp_subnodes ; COMPS_HSListItem * it ; COMPS_ObjListIt * it2 ; struct Pair { COMPS_HSList * subnodes ; char * key ; <S2SV_StartBug> char added ; <S2SV_EndBug> } * pair , * parent_pair ; pair = malloc ( sizeof ( struct Pair ) ) ; pair -> subnodes = rt2 -> subnodes ; pair -> key = NULL ; tmplist = comps_hslist_create ( ) ; comps_hslist_init ( tmplist , NULL , NULL , & free ) ; comps_hslist_append ( tmplist , pair , 0 ) ; while ( tmplist -> first != NULL ) { it = tmplist -> first ; comps_hslist_remove ( tmplist , tmplist -> first ) ; tmp_subnodes = ( ( struct Pair * ) it -> data ) -> subnodes ; parent_pair = ( struct Pair * ) it -> data ; free ( it ) ; <S2SV_StartBug> pair -> added = 0 ; <S2SV_EndBug> for ( it = tmp_subnodes -> first ; it != NULL ; it = it -> next ) { pair = malloc ( sizeof ( struct Pair ) ) ; pair -> subnodes = ( ( COMPS_ObjMRTreeData * ) it -> data ) -> subnodes ; if ( parent_pair -> key != NULL ) { pair -> key = malloc ( sizeof ( char ) * ( strlen ( ( ( COMPS_ObjMRTreeData * ) it -> data ) -> key ) + strlen ( parent_pair -> key ) + 1 ) ) ; memcpy ( pair -> key , parent_pair -> key , sizeof ( char ) * strlen ( parent_pair -> key ) ) ; memcpy ( pair -> key + strlen ( parent_pair -> key ) , ( ( COMPS_ObjMRTreeData * ) it -> data ) -> key , sizeof ( char ) * ( strlen ( ( ( COMPS_ObjMRTreeData * ) it -> data ) -> key ) + 1 ) ) ; } else { pair -> key = malloc ( sizeof ( char ) * ( strlen ( ( ( COMPS_ObjMRTreeData * ) it -> data ) -> key ) + 1 ) ) ; memcpy ( pair -> key , ( ( COMPS_ObjMRTreeData * ) it -> data ) -> key , sizeof ( char ) * ( strlen ( ( ( COMPS_ObjMRTreeData * ) it -> data ) -> key ) + 1 ) ) ; } if ( ( ( COMPS_ObjMRTreeData * ) it -> data ) -> data -> first != NULL ) { for ( it2 = ( ( COMPS_ObjMRTreeData * ) it -> data ) -> data -> first ; it2 != NULL ; it2 = it2 -> next ) { comps_objmrtree_set ( rt1 , pair -> key , it2 -> comps_obj ) ; } if ( ( ( COMPS_ObjMRTreeData * ) it -> data ) -> subnodes -> first ) { comps_hslist_append ( tmplist , pair , 0 ) ; } else { free ( pair -> key ) ; free ( pair ) ; } } else { if ( ( ( COMPS_ObjMRTreeData * ) it -> data ) -> subnodes -> first ) { comps_hslist_append ( tmplist , pair , 0 ) ; } else { free ( pair -> key ) ; free ( pair ) ; } } } free ( parent_pair -> key ) ; free ( parent_pair ) ; } comps_hslist_destroy ( & tmplist ) ; }
CWE-416 void comps_objrtree_unite ( COMPS_ObjRTree * rt1 , COMPS_ObjRTree * rt2 ) { COMPS_HSList * tmplist , * tmp_subnodes ; COMPS_HSListItem * it ; struct Pair { COMPS_HSList * subnodes ; char * key ; <S2SV_StartBug> char added ; <S2SV_EndBug> } * pair , * parent_pair ; pair = malloc ( sizeof ( struct Pair ) ) ; pair -> subnodes = rt2 -> subnodes ; pair -> key = NULL ; tmplist = comps_hslist_create ( ) ; comps_hslist_init ( tmplist , NULL , NULL , & free ) ; comps_hslist_append ( tmplist , pair , 0 ) ; while ( tmplist -> first != NULL ) { it = tmplist -> first ; comps_hslist_remove ( tmplist , tmplist -> first ) ; tmp_subnodes = ( ( struct Pair * ) it -> data ) -> subnodes ; parent_pair = ( struct Pair * ) it -> data ; free ( it ) ; for ( it = tmp_subnodes -> first ; it != NULL ; it = it -> next ) { pair = malloc ( sizeof ( struct Pair ) ) ; pair -> subnodes = ( ( COMPS_ObjRTreeData * ) it -> data ) -> subnodes ; if ( parent_pair -> key != NULL ) { pair -> key = malloc ( sizeof ( char ) * ( strlen ( ( ( COMPS_ObjRTreeData * ) it -> data ) -> key ) + strlen ( parent_pair -> key ) + 1 ) ) ; memcpy ( pair -> key , parent_pair -> key , sizeof ( char ) * strlen ( parent_pair -> key ) ) ; memcpy ( pair -> key + strlen ( parent_pair -> key ) , ( ( COMPS_ObjRTreeData * ) it -> data ) -> key , sizeof ( char ) * ( strlen ( ( ( COMPS_ObjRTreeData * ) it -> data ) -> key ) + 1 ) ) ; } else { pair -> key = malloc ( sizeof ( char ) * ( strlen ( ( ( COMPS_ObjRTreeData * ) it -> data ) -> key ) + 1 ) ) ; memcpy ( pair -> key , ( ( COMPS_ObjRTreeData * ) it -> data ) -> key , sizeof ( char ) * ( strlen ( ( ( COMPS_ObjRTreeData * ) it -> data ) -> key ) + 1 ) ) ; } if ( ( ( COMPS_ObjRTreeData * ) it -> data ) -> data != NULL ) { comps_objrtree_set ( rt1 , pair -> key , ( ( ( COMPS_ObjRTreeData * ) it -> data ) -> data ) ) ; } if ( ( ( COMPS_ObjRTreeData * ) it -> data ) -> subnodes -> first ) { comps_hslist_append ( tmplist , pair , 0 ) ; } else { free ( pair -> key ) ; free ( pair ) ; } } free ( parent_pair -> key ) ; free ( parent_pair ) ; } comps_hslist_destroy ( & tmplist ) ; }
CWE-416 void comps_rtree_unite ( COMPS_RTree * rt1 , COMPS_RTree * rt2 ) { COMPS_HSList * tmplist , * tmp_subnodes ; COMPS_HSListItem * it ; struct Pair { COMPS_HSList * subnodes ; char * key ; <S2SV_StartBug> char added ; <S2SV_EndBug> } * pair , * parent_pair ; pair = malloc ( sizeof ( struct Pair ) ) ; pair -> subnodes = rt2 -> subnodes ; pair -> key = NULL ; tmplist = comps_hslist_create ( ) ; comps_hslist_init ( tmplist , NULL , NULL , & free ) ; comps_hslist_append ( tmplist , pair , 0 ) ; while ( tmplist -> first != NULL ) { it = tmplist -> first ; comps_hslist_remove ( tmplist , tmplist -> first ) ; tmp_subnodes = ( ( struct Pair * ) it -> data ) -> subnodes ; parent_pair = ( struct Pair * ) it -> data ; free ( it ) ; for ( it = tmp_subnodes -> first ; it != NULL ; it = it -> next ) { pair = malloc ( sizeof ( struct Pair ) ) ; pair -> subnodes = ( ( COMPS_RTreeData * ) it -> data ) -> subnodes ; if ( parent_pair -> key != NULL ) { pair -> key = malloc ( sizeof ( char ) * ( strlen ( ( ( COMPS_RTreeData * ) it -> data ) -> key ) + strlen ( parent_pair -> key ) + 1 ) ) ; memcpy ( pair -> key , parent_pair -> key , sizeof ( char ) * strlen ( parent_pair -> key ) ) ; memcpy ( pair -> key + strlen ( parent_pair -> key ) , ( ( COMPS_RTreeData * ) it -> data ) -> key , sizeof ( char ) * ( strlen ( ( ( COMPS_RTreeData * ) it -> data ) -> key ) + 1 ) ) ; } else { pair -> key = malloc ( sizeof ( char ) * ( strlen ( ( ( COMPS_RTreeData * ) it -> data ) -> key ) + 1 ) ) ; memcpy ( pair -> key , ( ( COMPS_RTreeData * ) it -> data ) -> key , sizeof ( char ) * ( strlen ( ( ( COMPS_RTreeData * ) it -> data ) -> key ) + 1 ) ) ; } if ( ( ( COMPS_RTreeData * ) it -> data ) -> data != NULL ) { comps_rtree_set ( rt1 , pair -> key , rt2 -> data_cloner ( ( ( COMPS_RTreeData * ) it -> data ) -> data ) ) ; } if ( ( ( COMPS_RTreeData * ) it -> data ) -> subnodes -> first ) { comps_hslist_append ( tmplist , pair , 0 ) ; } else { free ( pair -> key ) ; free ( pair ) ; } } free ( parent_pair -> key ) ; free ( parent_pair ) ; } comps_hslist_destroy ( & tmplist ) ; }
CWE-59 rpmVerifyAttrs rpmfilesVerify ( rpmfiles fi , int ix , rpmVerifyAttrs omitMask ) { rpm_mode_t fmode = rpmfilesFMode ( fi , ix ) ; rpmfileAttrs fileAttrs = rpmfilesFFlags ( fi , ix ) ; rpmVerifyAttrs flags = rpmfilesVFlags ( fi , ix ) ; const char * fn = rpmfilesFN ( fi , ix ) ; struct stat sb ; rpmVerifyAttrs vfy = RPMVERIFY_NONE ; switch ( rpmfilesFState ( fi , ix ) ) { case RPMFILE_STATE_NETSHARED : case RPMFILE_STATE_NOTINSTALLED : goto exit ; break ; case RPMFILE_STATE_REPLACED : flags = RPMVERIFY_LSTATFAIL ; break ; case RPMFILE_STATE_WRONGCOLOR : flags &= ~ ( RPMVERIFY_FILEDIGEST | RPMVERIFY_FILESIZE | RPMVERIFY_MTIME | RPMVERIFY_RDEV ) ; break ; case RPMFILE_STATE_NORMAL : case RPMFILE_STATE_MISSING : break ; } if ( fn == NULL || lstat ( fn , & sb ) != 0 ) { vfy |= RPMVERIFY_LSTATFAIL ; goto exit ; } <S2SV_StartBug> if ( S_ISDIR ( fmode ) && S_ISLNK ( sb . st_mode ) && stat ( fn , & sb ) != 0 ) { <S2SV_EndBug> vfy |= RPMVERIFY_LSTATFAIL ; goto exit ; } if ( S_ISLNK ( sb . st_mode ) ) flags &= ~ ( RPMVERIFY_MODE ) ; else flags &= ~ ( RPMVERIFY_LINKTO ) ; if ( ! S_ISREG ( sb . st_mode ) ) flags &= ~ ( RPMVERIFY_FILEDIGEST | RPMVERIFY_FILESIZE | RPMVERIFY_MTIME | RPMVERIFY_CAPS ) ; if ( fileAttrs & RPMFILE_GHOST ) flags &= ~ ( RPMVERIFY_FILEDIGEST | RPMVERIFY_FILESIZE | RPMVERIFY_MTIME | RPMVERIFY_LINKTO ) ; flags &= ~ ( omitMask | RPMVERIFY_FAILURES ) ; if ( flags & RPMVERIFY_FILEDIGEST ) { const unsigned char * digest ; int algo ; size_t diglen ; if ( ( digest = rpmfilesFDigest ( fi , ix , & algo , & diglen ) ) ) { unsigned char fdigest [ diglen ] ; rpm_loff_t fsize ; if ( rpmDoDigest ( algo , fn , 0 , fdigest , & fsize ) ) { vfy |= ( RPMVERIFY_READFAIL | RPMVERIFY_FILEDIGEST ) ; } else { sb . st_size = fsize ; if ( memcmp ( fdigest , digest , diglen ) ) vfy |= RPMVERIFY_FILEDIGEST ; } } else { vfy |= RPMVERIFY_FILEDIGEST ; } } if ( flags & RPMVERIFY_LINKTO ) { char linkto [ 1024 + 1 ] ; int size = 0 ; if ( ( size = readlink ( fn , linkto , sizeof ( linkto ) - 1 ) ) == - 1 ) vfy |= ( RPMVERIFY_READLINKFAIL | RPMVERIFY_LINKTO ) ; else { const char * flink = rpmfilesFLink ( fi , ix ) ; linkto [ size ] = '\\0' ; if ( flink == NULL || ! rstreq ( linkto , flink ) ) vfy |= RPMVERIFY_LINKTO ; } } if ( flags & RPMVERIFY_FILESIZE ) { if ( sb . st_size != rpmfilesFSize ( fi , ix ) ) vfy |= RPMVERIFY_FILESIZE ; } if ( flags & RPMVERIFY_MODE ) { rpm_mode_t metamode = fmode ; rpm_mode_t filemode ; filemode = ( rpm_mode_t ) sb . st_mode ; if ( fileAttrs & RPMFILE_GHOST ) { metamode &= ~ 0xf000 ; filemode &= ~ 0xf000 ; } if ( metamode != filemode ) vfy |= RPMVERIFY_MODE ; # if WITH_ACL acl_t facl = acl_get_file ( fn , ACL_TYPE_ACCESS ) ; if ( facl ) { if ( acl_equiv_mode ( facl , NULL ) == 1 ) { vfy |= RPMVERIFY_MODE ; } acl_free ( facl ) ; } # endif } if ( flags & RPMVERIFY_RDEV ) { if ( S_ISCHR ( fmode ) != S_ISCHR ( sb . st_mode ) || S_ISBLK ( fmode ) != S_ISBLK ( sb . st_mode ) ) { vfy |= RPMVERIFY_RDEV ; } else if ( S_ISDEV ( fmode ) && S_ISDEV ( sb . st_mode ) ) { rpm_rdev_t st_rdev = ( sb . st_rdev & 0xffff ) ; rpm_rdev_t frdev = ( rpmfilesFRdev ( fi , ix ) & 0xffff ) ; if ( st_rdev != frdev ) vfy |= RPMVERIFY_RDEV ; } } # if WITH_CAP if ( flags & RPMVERIFY_CAPS ) { cap_t cap , fcap ; cap = cap_from_text ( rpmfilesFCaps ( fi , ix ) ) ; if ( ! cap ) { cap = cap_from_text ( "=" ) ; } fcap = cap_get_file ( fn ) ; if ( ! fcap ) { fcap = cap_from_text ( "=" ) ; } if ( cap_compare ( cap , fcap ) != 0 ) vfy |= RPMVERIFY_CAPS ; cap_free ( fcap ) ; cap_free ( cap ) ; } # endif if ( ( flags & RPMVERIFY_MTIME ) && ( sb . st_mtime != rpmfilesFMtime ( fi , ix ) ) ) { vfy |= RPMVERIFY_MTIME ; } if ( flags & RPMVERIFY_USER ) { const char * name = rpmugUname ( sb . st_uid ) ; const char * fuser = rpmfilesFUser ( fi , ix ) ; uid_t uid ; int namematch = 0 ; int idmatch = 0 ; if ( name && fuser ) namematch = rstreq ( name , fuser ) ; if ( fuser && rpmugUid ( fuser , & uid ) == 0 ) idmatch = ( uid == sb . st_uid ) ; if ( namematch != idmatch ) { rpmlog ( RPMLOG_WARNING , _ ( "Duplicate<S2SV_blank>username<S2SV_blank>or<S2SV_blank>UID<S2SV_blank>for<S2SV_blank>user<S2SV_blank>%s\\n" ) , fuser ) ; } if ( ! ( namematch || idmatch ) ) vfy |= RPMVERIFY_USER ; } if ( flags & RPMVERIFY_GROUP ) { const char * name = rpmugGname ( sb . st_gid ) ; const char * fgroup = rpmfilesFGroup ( fi , ix ) ; gid_t gid ; int namematch = 0 ; int idmatch = 0 ; if ( name && fgroup ) namematch = rstreq ( name , fgroup ) ; if ( fgroup && rpmugGid ( fgroup , & gid ) == 0 ) idmatch = ( gid == sb . st_gid ) ; if ( namematch != idmatch ) { rpmlog ( RPMLOG_WARNING , _ ( "Duplicate<S2SV_blank>groupname<S2SV_blank>or<S2SV_blank>GID<S2SV_blank>for<S2SV_blank>group<S2SV_blank>%s\\n" ) , fgroup ) ; } if ( ! ( namematch || idmatch ) ) vfy |= RPMVERIFY_GROUP ; } exit : return vfy ; }
CWE-59 <S2SV_StartBug> static int fsmVerify ( const char * path , rpmfi fi ) <S2SV_EndBug> { int rc ; int saveerrno = errno ; struct stat dsb ; mode_t mode = rpmfiFMode ( fi ) ; rc = fsmStat ( path , 1 , & dsb ) ; if ( rc ) return rc ; if ( S_ISREG ( mode ) ) { char * rmpath = rstrscat ( NULL , path , "-RPMDELETE" , NULL ) ; rc = fsmRename ( path , rmpath ) ; if ( ! rc ) ( void ) fsmUnlink ( rmpath ) ; else rc = RPMERR_UNLINK_FAILED ; free ( rmpath ) ; return ( rc ? rc : RPMERR_ENOENT ) ; } else if ( S_ISDIR ( mode ) ) { if ( S_ISDIR ( dsb . st_mode ) ) return 0 ; if ( S_ISLNK ( dsb . st_mode ) ) { <S2SV_StartBug> rc = fsmStat ( path , 0 , & dsb ) ; <S2SV_EndBug> if ( rc == RPMERR_ENOENT ) rc = 0 ; if ( rc ) return rc ; errno = saveerrno ; <S2SV_StartBug> if ( S_ISDIR ( dsb . st_mode ) ) return 0 ; <S2SV_EndBug> } } else if ( S_ISLNK ( mode ) ) { if ( S_ISLNK ( dsb . st_mode ) ) { char buf [ 8 * BUFSIZ ] ; size_t len ; rc = fsmReadLink ( path , buf , 8 * BUFSIZ , & len ) ; errno = saveerrno ; if ( rc ) return rc ; if ( rstreq ( rpmfiFLink ( fi ) , buf ) ) return 0 ; } } else if ( S_ISFIFO ( mode ) ) { if ( S_ISFIFO ( dsb . st_mode ) ) return 0 ; } else if ( S_ISCHR ( mode ) || S_ISBLK ( mode ) ) { if ( ( S_ISCHR ( dsb . st_mode ) || S_ISBLK ( dsb . st_mode ) ) && ( dsb . st_rdev == rpmfiFRdev ( fi ) ) ) return 0 ; } else if ( S_ISSOCK ( mode ) ) { if ( S_ISSOCK ( dsb . st_mode ) ) return 0 ; } rc = fsmUnlink ( path ) ; if ( rc == 0 ) rc = RPMERR_ENOENT ; return ( rc ? rc : RPMERR_ENOENT ) ; }
CWE-59 int rpmPackageFilesInstall ( rpmts ts , rpmte te , rpmfiles files , rpmpsm psm , char * * failedFile ) { FD_t payload = rpmtePayload ( te ) ; rpmfi fi = rpmfiNewArchiveReader ( payload , files , RPMFI_ITER_READ_ARCHIVE ) ; rpmfs fs = rpmteGetFileStates ( te ) ; rpmPlugins plugins = rpmtsPlugins ( ts ) ; struct stat sb ; int saveerrno = errno ; int rc = 0 ; int nodigest = ( rpmtsFlags ( ts ) & RPMTRANS_FLAG_NOFILEDIGEST ) ? 1 : 0 ; int nofcaps = ( rpmtsFlags ( ts ) & RPMTRANS_FLAG_NOCAPS ) ? 1 : 0 ; int firsthardlink = - 1 ; int skip ; rpmFileAction action ; char * tid = NULL ; const char * suffix ; char * fpath = NULL ; if ( fi == NULL ) { rc = RPMERR_BAD_MAGIC ; goto exit ; } rasprintf ( & tid , ";%08x" , ( unsigned ) rpmtsGetTid ( ts ) ) ; rc = fsmMkdirs ( files , fs , plugins ) ; while ( ! rc ) { rc = rpmfiNext ( fi ) ; if ( rc < 0 ) { if ( rc == RPMERR_ITER_END ) rc = 0 ; break ; } action = rpmfsGetAction ( fs , rpmfiFX ( fi ) ) ; skip = XFA_SKIPPING ( action ) ; suffix = S_ISDIR ( rpmfiFMode ( fi ) ) ? NULL : tid ; if ( action != FA_TOUCH ) { fpath = fsmFsPath ( fi , suffix ) ; } else { fpath = fsmFsPath ( fi , "" ) ; } rc = rpmfiStat ( fi , 1 , & sb ) ; fsmDebug ( fpath , action , & sb ) ; if ( rc ) break ; rc = rpmpluginsCallFsmFilePre ( plugins , fi , fpath , sb . st_mode , action ) ; if ( rc ) { skip = 1 ; } else { setFileState ( fs , rpmfiFX ( fi ) ) ; } if ( ! skip ) { int setmeta = 1 ; if ( ! suffix ) { rc = fsmBackup ( fi , action ) ; } if ( ! suffix ) { <S2SV_StartBug> rc = fsmVerify ( fpath , fi ) ; <S2SV_EndBug> } else { rc = ( action == FA_TOUCH ) ? 0 : RPMERR_ENOENT ; } if ( S_ISREG ( sb . st_mode ) ) { if ( rc == RPMERR_ENOENT ) { rc = fsmMkfile ( fi , fpath , files , psm , nodigest , & setmeta , & firsthardlink ) ; } } else if ( S_ISDIR ( sb . st_mode ) ) { if ( rc == RPMERR_ENOENT ) { mode_t mode = sb . st_mode ; mode &= ~ 07777 ; mode |= 00700 ; rc = fsmMkdir ( fpath , mode ) ; } } else if ( S_ISLNK ( sb . st_mode ) ) { if ( rc == RPMERR_ENOENT ) { rc = fsmSymlink ( rpmfiFLink ( fi ) , fpath ) ; } } else if ( S_ISFIFO ( sb . st_mode ) ) { if ( rc == RPMERR_ENOENT ) { rc = fsmMkfifo ( fpath , 0000 ) ; } } else if ( S_ISCHR ( sb . st_mode ) || S_ISBLK ( sb . st_mode ) || S_ISSOCK ( sb . st_mode ) ) { if ( rc == RPMERR_ENOENT ) { rc = fsmMknod ( fpath , sb . st_mode , sb . st_rdev ) ; } } else { if ( ! IS_DEV_LOG ( fpath ) ) rc = RPMERR_UNKNOWN_FILETYPE ; } if ( ! rc && setmeta ) { rc = fsmSetmeta ( fpath , fi , plugins , action , & sb , nofcaps ) ; } } else if ( firsthardlink >= 0 && rpmfiArchiveHasContent ( fi ) ) { char * fn = rpmfilesFN ( files , firsthardlink ) ; rc = expandRegular ( fi , fn , psm , 0 , nodigest , 0 ) ; firsthardlink = - 1 ; free ( fn ) ; } if ( rc ) { if ( ! skip ) { if ( suffix && ( action != FA_TOUCH ) ) { ( void ) fsmRemove ( fpath , sb . st_mode ) ; } errno = saveerrno ; } } else { rpmpsmNotify ( psm , RPMCALLBACK_INST_PROGRESS , rpmfiArchiveTell ( fi ) ) ; if ( ! skip ) { if ( suffix ) rc = fsmBackup ( fi , action ) ; if ( ! rc ) rc = fsmCommit ( & fpath , fi , action , suffix ) ; } } if ( rc ) * failedFile = xstrdup ( fpath ) ; rpmpluginsCallFsmFilePost ( plugins , fi , fpath , sb . st_mode , action , rc ) ; fpath = _free ( fpath ) ; } rpmswAdd ( rpmtsOp ( ts , RPMTS_OP_UNCOMPRESS ) , fdOp ( payload , FDSTAT_READ ) ) ; rpmswAdd ( rpmtsOp ( ts , RPMTS_OP_DIGEST ) , fdOp ( payload , FDSTAT_DIGEST ) ) ; exit : rpmfiArchiveClose ( fi ) ; rpmfiFree ( fi ) ; Fclose ( payload ) ; free ( tid ) ; free ( fpath ) ; return rc ; }
CWE-190 uint8_t hfs_cat_traverse ( HFS_INFO * hfs , TSK_HFS_BTREE_CB a_cb , void * ptr ) { TSK_FS_INFO * fs = & ( hfs -> fs_info ) ; uint32_t cur_node ; char * node ; uint16_t nodesize ; uint8_t is_done = 0 ; tsk_error_reset ( ) ; nodesize = tsk_getu16 ( fs -> endian , hfs -> catalog_header . nodesize ) ; if ( ( node = ( char * ) tsk_malloc ( nodesize ) ) == NULL ) return 1 ; cur_node = tsk_getu32 ( fs -> endian , hfs -> catalog_header . rootNode ) ; if ( cur_node == 0 ) { if ( tsk_verbose ) tsk_fprintf ( stderr , "hfs_cat_traverse:<S2SV_blank>" "empty<S2SV_blank>extents<S2SV_blank>btree\\n" ) ; free ( node ) ; return 1 ; } if ( tsk_verbose ) tsk_fprintf ( stderr , "hfs_cat_traverse:<S2SV_blank>starting<S2SV_blank>at<S2SV_blank>" "root<S2SV_blank>node<S2SV_blank>%" PRIu32 ";<S2SV_blank>nodesize<S2SV_blank>=<S2SV_blank>%" PRIu16 "\\n" , cur_node , nodesize ) ; is_done = 0 ; while ( is_done == 0 ) { TSK_OFF_T cur_off ; uint16_t num_rec ; ssize_t cnt ; hfs_btree_node * node_desc ; if ( cur_node > tsk_getu32 ( fs -> endian , hfs -> catalog_header . totalNodes ) ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( "hfs_cat_traverse:<S2SV_blank>Node<S2SV_blank>%d<S2SV_blank>too<S2SV_blank>large<S2SV_blank>for<S2SV_blank>file" , cur_node ) ; free ( node ) ; return 1 ; } cur_off = cur_node * nodesize ; cnt = tsk_fs_attr_read ( hfs -> catalog_attr , cur_off , node , nodesize , 0 ) ; if ( cnt != nodesize ) { if ( cnt >= 0 ) { tsk_error_reset ( ) ; tsk_error_set_errno ( TSK_ERR_FS_READ ) ; } tsk_error_set_errstr2 ( "hfs_cat_traverse:<S2SV_blank>Error<S2SV_blank>reading<S2SV_blank>node<S2SV_blank>%d<S2SV_blank>at<S2SV_blank>offset<S2SV_blank>%" PRIuOFF , cur_node , cur_off ) ; free ( node ) ; return 1 ; } if ( nodesize < sizeof ( hfs_btree_node ) ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( "hfs_cat_traverse:<S2SV_blank>Node<S2SV_blank>size<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small<S2SV_blank>to<S2SV_blank>be<S2SV_blank>valid" , nodesize ) ; free ( node ) ; return 1 ; } node_desc = ( hfs_btree_node * ) node ; num_rec = tsk_getu16 ( fs -> endian , node_desc -> num_rec ) ; if ( tsk_verbose ) tsk_fprintf ( stderr , "hfs_cat_traverse:<S2SV_blank>node<S2SV_blank>%" PRIu32 "<S2SV_blank>@<S2SV_blank>%" PRIu64 "<S2SV_blank>has<S2SV_blank>%" PRIu16 "<S2SV_blank>records\\n" , cur_node , cur_off , num_rec ) ; if ( num_rec == 0 ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( "hfs_cat_traverse:<S2SV_blank>zero<S2SV_blank>records<S2SV_blank>in<S2SV_blank>node<S2SV_blank>%" PRIu32 , cur_node ) ; free ( node ) ; return 1 ; } if ( node_desc -> type == HFS_BT_NODE_TYPE_IDX ) { uint32_t next_node = 0 ; int rec ; for ( rec = 0 ; rec < num_rec ; ++ rec ) { size_t rec_off ; hfs_btree_key_cat * key ; uint8_t retval ; <S2SV_StartBug> uint16_t keylen ; <S2SV_EndBug> rec_off = tsk_getu16 ( fs -> endian , & node [ nodesize - ( rec + 1 ) * 2 ] ) ; if ( rec_off > nodesize ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( "hfs_cat_traverse:<S2SV_blank>offset<S2SV_blank>of<S2SV_blank>record<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>index<S2SV_blank>node<S2SV_blank>%d<S2SV_blank>too<S2SV_blank>large<S2SV_blank>(%d<S2SV_blank>vs<S2SV_blank>%" PRIu16 ")" , rec , cur_node , ( int ) rec_off , nodesize ) ; free ( node ) ; return 1 ; } key = ( hfs_btree_key_cat * ) & node [ rec_off ] ; keylen = 2 + tsk_getu16 ( hfs -> fs_info . endian , key -> key_len ) ; if ( ( keylen ) > nodesize ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( "hfs_cat_traverse:<S2SV_blank>length<S2SV_blank>of<S2SV_blank>key<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>index<S2SV_blank>node<S2SV_blank>%d<S2SV_blank>too<S2SV_blank>large<S2SV_blank>(%d<S2SV_blank>vs<S2SV_blank>%" PRIu16 ")" , rec , cur_node , keylen , nodesize ) ; free ( node ) ; return 1 ; } retval = a_cb ( hfs , HFS_BT_NODE_TYPE_IDX , key , cur_off + rec_off , ptr ) ; if ( retval == HFS_BTREE_CB_ERR ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr2 ( "hfs_cat_traverse:<S2SV_blank>Callback<S2SV_blank>returned<S2SV_blank>error" ) ; free ( node ) ; return 1 ; } else if ( ( retval == HFS_BTREE_CB_IDX_LT ) || ( next_node == 0 ) ) { hfs_btree_index_record * idx_rec ; int keylen = 2 + hfs_get_idxkeylen ( hfs , tsk_getu16 ( fs -> endian , key -> key_len ) , & ( hfs -> catalog_header ) ) ; if ( rec_off + keylen > nodesize ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( "hfs_cat_traverse:<S2SV_blank>offset<S2SV_blank>of<S2SV_blank>record<S2SV_blank>and<S2SV_blank>keylength<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>index<S2SV_blank>node<S2SV_blank>%d<S2SV_blank>too<S2SV_blank>large<S2SV_blank>(%d<S2SV_blank>vs<S2SV_blank>%" PRIu16 ")" , rec , cur_node , ( int ) rec_off + keylen , nodesize ) ; free ( node ) ; return 1 ; } idx_rec = ( hfs_btree_index_record * ) & node [ rec_off + keylen ] ; next_node = tsk_getu32 ( fs -> endian , idx_rec -> childNode ) ; } if ( retval == HFS_BTREE_CB_IDX_EQGT ) { break ; } } if ( next_node == 0 ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( "hfs_cat_traverse:<S2SV_blank>did<S2SV_blank>not<S2SV_blank>find<S2SV_blank>any<S2SV_blank>keys<S2SV_blank>in<S2SV_blank>index<S2SV_blank>node<S2SV_blank>%d" , cur_node ) ; is_done = 1 ; break ; } if ( next_node == cur_node ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( "hfs_cat_traverse:<S2SV_blank>node<S2SV_blank>%d<S2SV_blank>references<S2SV_blank>itself<S2SV_blank>as<S2SV_blank>next<S2SV_blank>node" , cur_node ) ; is_done = 1 ; break ; } cur_node = next_node ; } else if ( node_desc -> type == HFS_BT_NODE_TYPE_LEAF ) { int rec ; for ( rec = 0 ; rec < num_rec ; ++ rec ) { size_t rec_off ; hfs_btree_key_cat * key ; uint8_t retval ; <S2SV_StartBug> uint16_t keylen ; <S2SV_EndBug> rec_off = tsk_getu16 ( fs -> endian , & node [ nodesize - ( rec + 1 ) * 2 ] ) ; if ( rec_off > nodesize ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( "hfs_cat_traverse:<S2SV_blank>offset<S2SV_blank>of<S2SV_blank>record<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>leaf<S2SV_blank>node<S2SV_blank>%d<S2SV_blank>too<S2SV_blank>large<S2SV_blank>(%d<S2SV_blank>vs<S2SV_blank>%" PRIu16 ")" , rec , cur_node , ( int ) rec_off , nodesize ) ; free ( node ) ; return 1 ; } key = ( hfs_btree_key_cat * ) & node [ rec_off ] ; keylen = 2 + tsk_getu16 ( hfs -> fs_info . endian , key -> key_len ) ; if ( ( keylen ) > nodesize ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( "hfs_cat_traverse:<S2SV_blank>length<S2SV_blank>of<S2SV_blank>key<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>leaf<S2SV_blank>node<S2SV_blank>%d<S2SV_blank>too<S2SV_blank>large<S2SV_blank>(%d<S2SV_blank>vs<S2SV_blank>%" PRIu16 ")" , rec , cur_node , keylen , nodesize ) ; free ( node ) ; return 1 ; } retval = a_cb ( hfs , HFS_BT_NODE_TYPE_LEAF , key , cur_off + rec_off , ptr ) ; if ( retval == HFS_BTREE_CB_LEAF_STOP ) { is_done = 1 ; break ; } else if ( retval == HFS_BTREE_CB_ERR ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr2 ( "hfs_cat_traverse:<S2SV_blank>Callback<S2SV_blank>returned<S2SV_blank>error" ) ; free ( node ) ; return 1 ; } } if ( is_done == 0 ) { cur_node = tsk_getu32 ( fs -> endian , node_desc -> flink ) ; if ( cur_node == 0 ) { is_done = 1 ; } if ( tsk_verbose ) tsk_fprintf ( stderr , "hfs_cat_traverse:<S2SV_blank>moving<S2SV_blank>forward<S2SV_blank>to<S2SV_blank>next<S2SV_blank>leaf" ) ; } } else { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( "hfs_cat_traverse:<S2SV_blank>btree<S2SV_blank>node<S2SV_blank>%" PRIu32 "<S2SV_blank>(%" PRIu64 ")<S2SV_blank>is<S2SV_blank>neither<S2SV_blank>index<S2SV_blank>nor<S2SV_blank>leaf<S2SV_blank>(%" PRIu8 ")" , cur_node , cur_off , node_desc -> type ) ; free ( node ) ; return 1 ; } } free ( node ) ; return 0 ; }
CWE-125 uint8_t hfs_cat_traverse ( HFS_INFO * hfs , TSK_HFS_BTREE_CB a_cb , void * ptr ) { TSK_FS_INFO * fs = & ( hfs -> fs_info ) ; uint32_t cur_node ; char * node ; uint16_t nodesize ; uint8_t is_done = 0 ; tsk_error_reset ( ) ; nodesize = tsk_getu16 ( fs -> endian , hfs -> catalog_header . nodesize ) ; if ( ( node = ( char * ) tsk_malloc ( nodesize ) ) == NULL ) return 1 ; cur_node = tsk_getu32 ( fs -> endian , hfs -> catalog_header . rootNode ) ; if ( cur_node == 0 ) { if ( tsk_verbose ) tsk_fprintf ( stderr , "hfs_cat_traverse:<S2SV_blank>" "empty<S2SV_blank>extents<S2SV_blank>btree\\n" ) ; free ( node ) ; return 1 ; } if ( tsk_verbose ) tsk_fprintf ( stderr , "hfs_cat_traverse:<S2SV_blank>starting<S2SV_blank>at<S2SV_blank>" "root<S2SV_blank>node<S2SV_blank>%" PRIu32 ";<S2SV_blank>nodesize<S2SV_blank>=<S2SV_blank>%" PRIu16 "\\n" , cur_node , nodesize ) ; is_done = 0 ; while ( is_done == 0 ) { TSK_OFF_T cur_off ; uint16_t num_rec ; ssize_t cnt ; hfs_btree_node * node_desc ; if ( cur_node > tsk_getu32 ( fs -> endian , hfs -> catalog_header . totalNodes ) ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( "hfs_cat_traverse:<S2SV_blank>Node<S2SV_blank>%d<S2SV_blank>too<S2SV_blank>large<S2SV_blank>for<S2SV_blank>file" , cur_node ) ; free ( node ) ; return 1 ; } cur_off = cur_node * nodesize ; cnt = tsk_fs_attr_read ( hfs -> catalog_attr , cur_off , node , nodesize , 0 ) ; if ( cnt != nodesize ) { if ( cnt >= 0 ) { tsk_error_reset ( ) ; tsk_error_set_errno ( TSK_ERR_FS_READ ) ; } tsk_error_set_errstr2 ( "hfs_cat_traverse:<S2SV_blank>Error<S2SV_blank>reading<S2SV_blank>node<S2SV_blank>%d<S2SV_blank>at<S2SV_blank>offset<S2SV_blank>%" PRIuOFF , cur_node , cur_off ) ; free ( node ) ; return 1 ; } if ( nodesize < sizeof ( hfs_btree_node ) ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( "hfs_cat_traverse:<S2SV_blank>Node<S2SV_blank>size<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small<S2SV_blank>to<S2SV_blank>be<S2SV_blank>valid" , nodesize ) ; free ( node ) ; return 1 ; } node_desc = ( hfs_btree_node * ) node ; num_rec = tsk_getu16 ( fs -> endian , node_desc -> num_rec ) ; if ( tsk_verbose ) tsk_fprintf ( stderr , "hfs_cat_traverse:<S2SV_blank>node<S2SV_blank>%" PRIu32 "<S2SV_blank>@<S2SV_blank>%" PRIu64 "<S2SV_blank>has<S2SV_blank>%" PRIu16 "<S2SV_blank>records\\n" , cur_node , cur_off , num_rec ) ; if ( num_rec == 0 ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( "hfs_cat_traverse:<S2SV_blank>zero<S2SV_blank>records<S2SV_blank>in<S2SV_blank>node<S2SV_blank>%" PRIu32 , cur_node ) ; free ( node ) ; return 1 ; } if ( node_desc -> type == HFS_BT_NODE_TYPE_IDX ) { uint32_t next_node = 0 ; int rec ; for ( rec = 0 ; rec < num_rec ; ++ rec ) { size_t rec_off ; hfs_btree_key_cat * key ; uint8_t retval ; int keylen ; rec_off = tsk_getu16 ( fs -> endian , & node [ nodesize - ( rec + 1 ) * 2 ] ) ; if ( rec_off > nodesize ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( "hfs_cat_traverse:<S2SV_blank>offset<S2SV_blank>of<S2SV_blank>record<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>index<S2SV_blank>node<S2SV_blank>%d<S2SV_blank>too<S2SV_blank>large<S2SV_blank>(%d<S2SV_blank>vs<S2SV_blank>%" PRIu16 ")" , rec , cur_node , ( int ) rec_off , nodesize ) ; free ( node ) ; return 1 ; } key = ( hfs_btree_key_cat * ) & node [ rec_off ] ; keylen = 2 + tsk_getu16 ( hfs -> fs_info . endian , key -> key_len ) ; <S2SV_StartBug> if ( ( keylen ) > nodesize ) { <S2SV_EndBug> tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( "hfs_cat_traverse:<S2SV_blank>length<S2SV_blank>of<S2SV_blank>key<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>index<S2SV_blank>node<S2SV_blank>%d<S2SV_blank>too<S2SV_blank>large<S2SV_blank>(%d<S2SV_blank>vs<S2SV_blank>%" <S2SV_StartBug> PRIu16 ")" , rec , cur_node , keylen , nodesize ) ; <S2SV_EndBug> free ( node ) ; return 1 ; } retval = a_cb ( hfs , HFS_BT_NODE_TYPE_IDX , key , cur_off + rec_off , ptr ) ; if ( retval == HFS_BTREE_CB_ERR ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr2 ( "hfs_cat_traverse:<S2SV_blank>Callback<S2SV_blank>returned<S2SV_blank>error" ) ; free ( node ) ; return 1 ; } else if ( ( retval == HFS_BTREE_CB_IDX_LT ) || ( next_node == 0 ) ) { hfs_btree_index_record * idx_rec ; int keylen = 2 + hfs_get_idxkeylen ( hfs , tsk_getu16 ( fs -> endian , key -> key_len ) , & ( hfs -> catalog_header ) ) ; if ( rec_off + keylen > nodesize ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( "hfs_cat_traverse:<S2SV_blank>offset<S2SV_blank>of<S2SV_blank>record<S2SV_blank>and<S2SV_blank>keylength<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>index<S2SV_blank>node<S2SV_blank>%d<S2SV_blank>too<S2SV_blank>large<S2SV_blank>(%d<S2SV_blank>vs<S2SV_blank>%" PRIu16 ")" , rec , cur_node , ( int ) rec_off + keylen , nodesize ) ; free ( node ) ; return 1 ; } idx_rec = ( hfs_btree_index_record * ) & node [ rec_off + keylen ] ; next_node = tsk_getu32 ( fs -> endian , idx_rec -> childNode ) ; } if ( retval == HFS_BTREE_CB_IDX_EQGT ) { break ; } } if ( next_node == 0 ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( "hfs_cat_traverse:<S2SV_blank>did<S2SV_blank>not<S2SV_blank>find<S2SV_blank>any<S2SV_blank>keys<S2SV_blank>in<S2SV_blank>index<S2SV_blank>node<S2SV_blank>%d" , cur_node ) ; is_done = 1 ; break ; } if ( next_node == cur_node ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( "hfs_cat_traverse:<S2SV_blank>node<S2SV_blank>%d<S2SV_blank>references<S2SV_blank>itself<S2SV_blank>as<S2SV_blank>next<S2SV_blank>node" , cur_node ) ; is_done = 1 ; break ; } cur_node = next_node ; } else if ( node_desc -> type == HFS_BT_NODE_TYPE_LEAF ) { int rec ; for ( rec = 0 ; rec < num_rec ; ++ rec ) { size_t rec_off ; hfs_btree_key_cat * key ; uint8_t retval ; int keylen ; rec_off = tsk_getu16 ( fs -> endian , & node [ nodesize - ( rec + 1 ) * 2 ] ) ; if ( rec_off > nodesize ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( "hfs_cat_traverse:<S2SV_blank>offset<S2SV_blank>of<S2SV_blank>record<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>leaf<S2SV_blank>node<S2SV_blank>%d<S2SV_blank>too<S2SV_blank>large<S2SV_blank>(%d<S2SV_blank>vs<S2SV_blank>%" PRIu16 ")" , rec , cur_node , ( int ) rec_off , nodesize ) ; free ( node ) ; return 1 ; } key = ( hfs_btree_key_cat * ) & node [ rec_off ] ; keylen = 2 + tsk_getu16 ( hfs -> fs_info . endian , key -> key_len ) ; if ( ( keylen ) > nodesize ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( "hfs_cat_traverse:<S2SV_blank>length<S2SV_blank>of<S2SV_blank>key<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>leaf<S2SV_blank>node<S2SV_blank>%d<S2SV_blank>too<S2SV_blank>large<S2SV_blank>(%d<S2SV_blank>vs<S2SV_blank>%" PRIu16 ")" , rec , cur_node , keylen , nodesize ) ; free ( node ) ; return 1 ; } retval = a_cb ( hfs , HFS_BT_NODE_TYPE_LEAF , key , cur_off + rec_off , ptr ) ; if ( retval == HFS_BTREE_CB_LEAF_STOP ) { is_done = 1 ; break ; } else if ( retval == HFS_BTREE_CB_ERR ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr2 ( "hfs_cat_traverse:<S2SV_blank>Callback<S2SV_blank>returned<S2SV_blank>error" ) ; free ( node ) ; return 1 ; } } if ( is_done == 0 ) { cur_node = tsk_getu32 ( fs -> endian , node_desc -> flink ) ; if ( cur_node == 0 ) { is_done = 1 ; } if ( tsk_verbose ) tsk_fprintf ( stderr , "hfs_cat_traverse:<S2SV_blank>moving<S2SV_blank>forward<S2SV_blank>to<S2SV_blank>next<S2SV_blank>leaf" ) ; } } else { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( "hfs_cat_traverse:<S2SV_blank>btree<S2SV_blank>node<S2SV_blank>%" PRIu32 "<S2SV_blank>(%" PRIu64 ")<S2SV_blank>is<S2SV_blank>neither<S2SV_blank>index<S2SV_blank>nor<S2SV_blank>leaf<S2SV_blank>(%" PRIu8 ")" , cur_node , cur_off , node_desc -> type ) ; free ( node ) ; return 1 ; } } free ( node ) ; return 0 ; }
CWE-125 int modbus_reply ( modbus_t * ctx , const uint8_t * req , int req_length , modbus_mapping_t * mb_mapping ) { int offset ; int slave ; int function ; uint16_t address ; uint8_t rsp [ MAX_MESSAGE_LENGTH ] ; int rsp_length = 0 ; sft_t sft ; if ( ctx == NULL ) { errno = EINVAL ; return - 1 ; } offset = ctx -> backend -> header_length ; slave = req [ offset - 1 ] ; function = req [ offset ] ; address = ( req [ offset + 1 ] << 8 ) + req [ offset + 2 ] ; sft . slave = slave ; sft . function = function ; sft . t_id = ctx -> backend -> prepare_response_tid ( req , & req_length ) ; switch ( function ) { case MODBUS_FC_READ_COILS : case MODBUS_FC_READ_DISCRETE_INPUTS : { unsigned int is_input = ( function == MODBUS_FC_READ_DISCRETE_INPUTS ) ; int start_bits = is_input ? mb_mapping -> start_input_bits : mb_mapping -> start_bits ; int nb_bits = is_input ? mb_mapping -> nb_input_bits : mb_mapping -> nb_bits ; uint8_t * tab_bits = is_input ? mb_mapping -> tab_input_bits : mb_mapping -> tab_bits ; const char * const name = is_input ? "read_input_bits" : "read_bits" ; int nb = ( req [ offset + 3 ] << 8 ) + req [ offset + 4 ] ; int mapping_address = address - start_bits ; if ( nb < 1 || MODBUS_MAX_READ_BITS < nb ) { rsp_length = response_exception ( ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE , rsp , TRUE , "Illegal<S2SV_blank>nb<S2SV_blank>of<S2SV_blank>values<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>%s<S2SV_blank>(max<S2SV_blank>%d)\\n" , nb , name , MODBUS_MAX_READ_BITS ) ; } else if ( mapping_address < 0 || ( mapping_address + nb ) > nb_bits ) { rsp_length = response_exception ( ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS , rsp , FALSE , "Illegal<S2SV_blank>data<S2SV_blank>address<S2SV_blank>0x%0X<S2SV_blank>in<S2SV_blank>%s\\n" , mapping_address < 0 ? address : address + nb , name ) ; } else { rsp_length = ctx -> backend -> build_response_basis ( & sft , rsp ) ; rsp [ rsp_length ++ ] = ( nb / 8 ) + ( ( nb % 8 ) ? 1 : 0 ) ; rsp_length = response_io_status ( tab_bits , mapping_address , nb , rsp , rsp_length ) ; } } break ; case MODBUS_FC_READ_HOLDING_REGISTERS : case MODBUS_FC_READ_INPUT_REGISTERS : { unsigned int is_input = ( function == MODBUS_FC_READ_INPUT_REGISTERS ) ; int start_registers = is_input ? mb_mapping -> start_input_registers : mb_mapping -> start_registers ; int nb_registers = is_input ? mb_mapping -> nb_input_registers : mb_mapping -> nb_registers ; uint16_t * tab_registers = is_input ? mb_mapping -> tab_input_registers : mb_mapping -> tab_registers ; const char * const name = is_input ? "read_input_registers" : "read_registers" ; int nb = ( req [ offset + 3 ] << 8 ) + req [ offset + 4 ] ; int mapping_address = address - start_registers ; if ( nb < 1 || MODBUS_MAX_READ_REGISTERS < nb ) { rsp_length = response_exception ( ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE , rsp , TRUE , "Illegal<S2SV_blank>nb<S2SV_blank>of<S2SV_blank>values<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>%s<S2SV_blank>(max<S2SV_blank>%d)\\n" , nb , name , MODBUS_MAX_READ_REGISTERS ) ; } else if ( mapping_address < 0 || ( mapping_address + nb ) > nb_registers ) { rsp_length = response_exception ( ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS , rsp , FALSE , "Illegal<S2SV_blank>data<S2SV_blank>address<S2SV_blank>0x%0X<S2SV_blank>in<S2SV_blank>%s\\n" , mapping_address < 0 ? address : address + nb , name ) ; } else { int i ; rsp_length = ctx -> backend -> build_response_basis ( & sft , rsp ) ; rsp [ rsp_length ++ ] = nb << 1 ; for ( i = mapping_address ; i < mapping_address + nb ; i ++ ) { rsp [ rsp_length ++ ] = tab_registers [ i ] >> 8 ; rsp [ rsp_length ++ ] = tab_registers [ i ] & 0xFF ; } } } break ; case MODBUS_FC_WRITE_SINGLE_COIL : { int mapping_address = address - mb_mapping -> start_bits ; if ( mapping_address < 0 || mapping_address >= mb_mapping -> nb_bits ) { rsp_length = response_exception ( ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS , rsp , FALSE , "Illegal<S2SV_blank>data<S2SV_blank>address<S2SV_blank>0x%0X<S2SV_blank>in<S2SV_blank>write_bit\\n" , address ) ; } else { int data = ( req [ offset + 3 ] << 8 ) + req [ offset + 4 ] ; if ( data == 0xFF00 || data == 0x0 ) { mb_mapping -> tab_bits [ mapping_address ] = data ? ON : OFF ; memcpy ( rsp , req , req_length ) ; rsp_length = req_length ; } else { rsp_length = response_exception ( ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE , rsp , FALSE , "Illegal<S2SV_blank>data<S2SV_blank>value<S2SV_blank>0x%0X<S2SV_blank>in<S2SV_blank>write_bit<S2SV_blank>request<S2SV_blank>at<S2SV_blank>address<S2SV_blank>%0X\\n" , data , address ) ; } } } break ; case MODBUS_FC_WRITE_SINGLE_REGISTER : { int mapping_address = address - mb_mapping -> start_registers ; if ( mapping_address < 0 || mapping_address >= mb_mapping -> nb_registers ) { rsp_length = response_exception ( ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS , rsp , FALSE , "Illegal<S2SV_blank>data<S2SV_blank>address<S2SV_blank>0x%0X<S2SV_blank>in<S2SV_blank>write_register\\n" , address ) ; } else { int data = ( req [ offset + 3 ] << 8 ) + req [ offset + 4 ] ; mb_mapping -> tab_registers [ mapping_address ] = data ; memcpy ( rsp , req , req_length ) ; rsp_length = req_length ; } } break ; case MODBUS_FC_WRITE_MULTIPLE_COILS : { int nb = ( req [ offset + 3 ] << 8 ) + req [ offset + 4 ] ; <S2SV_StartBug> int mapping_address = address - mb_mapping -> start_bits ; <S2SV_EndBug> <S2SV_StartBug> if ( nb < 1 || MODBUS_MAX_WRITE_BITS < nb ) { <S2SV_EndBug> rsp_length = response_exception ( ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE , rsp , TRUE , "Illegal<S2SV_blank>number<S2SV_blank>of<S2SV_blank>values<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>write_bits<S2SV_blank>(max<S2SV_blank>%d)\\n" , nb , MODBUS_MAX_WRITE_BITS ) ; } else if ( mapping_address < 0 || ( mapping_address + nb ) > mb_mapping -> nb_bits ) { rsp_length = response_exception ( ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS , rsp , FALSE , "Illegal<S2SV_blank>data<S2SV_blank>address<S2SV_blank>0x%0X<S2SV_blank>in<S2SV_blank>write_bits\\n" , mapping_address < 0 ? address : address + nb ) ; } else { modbus_set_bits_from_bytes ( mb_mapping -> tab_bits , mapping_address , nb , & req [ offset + 6 ] ) ; rsp_length = ctx -> backend -> build_response_basis ( & sft , rsp ) ; memcpy ( rsp + rsp_length , req + rsp_length , 4 ) ; rsp_length += 4 ; } } break ; case MODBUS_FC_WRITE_MULTIPLE_REGISTERS : { <S2SV_StartBug> int nb = ( req [ offset + 3 ] << 8 ) + req [ offset + 4 ] ; <S2SV_EndBug> int mapping_address = address - mb_mapping -> start_registers ; <S2SV_StartBug> if ( nb < 1 || MODBUS_MAX_WRITE_REGISTERS < nb ) { <S2SV_EndBug> rsp_length = response_exception ( ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE , rsp , TRUE , "Illegal<S2SV_blank>number<S2SV_blank>of<S2SV_blank>values<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>write_registers<S2SV_blank>(max<S2SV_blank>%d)\\n" , nb , MODBUS_MAX_WRITE_REGISTERS ) ; } else if ( mapping_address < 0 || ( mapping_address + nb ) > mb_mapping -> nb_registers ) { rsp_length = response_exception ( ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS , rsp , FALSE , "Illegal<S2SV_blank>data<S2SV_blank>address<S2SV_blank>0x%0X<S2SV_blank>in<S2SV_blank>write_registers\\n" , mapping_address < 0 ? address : address + nb ) ; } else { int i , j ; for ( i = mapping_address , j = 6 ; i < mapping_address + nb ; i ++ , j += 2 ) { mb_mapping -> tab_registers [ i ] = ( req [ offset + j ] << 8 ) + req [ offset + j + 1 ] ; } rsp_length = ctx -> backend -> build_response_basis ( & sft , rsp ) ; memcpy ( rsp + rsp_length , req + rsp_length , 4 ) ; rsp_length += 4 ; } } break ; case MODBUS_FC_REPORT_SLAVE_ID : { int str_len ; int byte_count_pos ; rsp_length = ctx -> backend -> build_response_basis ( & sft , rsp ) ; byte_count_pos = rsp_length ++ ; rsp [ rsp_length ++ ] = _REPORT_SLAVE_ID ; rsp [ rsp_length ++ ] = 0xFF ; str_len = 3 + strlen ( LIBMODBUS_VERSION_STRING ) ; memcpy ( rsp + rsp_length , "LMB" LIBMODBUS_VERSION_STRING , str_len ) ; rsp_length += str_len ; rsp [ byte_count_pos ] = rsp_length - byte_count_pos - 1 ; } break ; case MODBUS_FC_READ_EXCEPTION_STATUS : if ( ctx -> debug ) { fprintf ( stderr , "FIXME<S2SV_blank>Not<S2SV_blank>implemented\\n" ) ; } errno = ENOPROTOOPT ; return - 1 ; break ; case MODBUS_FC_MASK_WRITE_REGISTER : { int mapping_address = address - mb_mapping -> start_registers ; if ( mapping_address < 0 || mapping_address >= mb_mapping -> nb_registers ) { rsp_length = response_exception ( ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS , rsp , FALSE , "Illegal<S2SV_blank>data<S2SV_blank>address<S2SV_blank>0x%0X<S2SV_blank>in<S2SV_blank>write_register\\n" , address ) ; } else { uint16_t data = mb_mapping -> tab_registers [ mapping_address ] ; uint16_t and = ( req [ offset + 3 ] << 8 ) + req [ offset + 4 ] ; uint16_t or = ( req [ offset + 5 ] << 8 ) + req [ offset + 6 ] ; data = ( data & and ) | ( or & ( ~ and ) ) ; mb_mapping -> tab_registers [ mapping_address ] = data ; memcpy ( rsp , req , req_length ) ; rsp_length = req_length ; } } break ; case MODBUS_FC_WRITE_AND_READ_REGISTERS : { int nb = ( req [ offset + 3 ] << 8 ) + req [ offset + 4 ] ; uint16_t address_write = ( req [ offset + 5 ] << 8 ) + req [ offset + 6 ] ; int nb_write = ( req [ offset + 7 ] << 8 ) + req [ offset + 8 ] ; int nb_write_bytes = req [ offset + 9 ] ; int mapping_address = address - mb_mapping -> start_registers ; int mapping_address_write = address_write - mb_mapping -> start_registers ; if ( nb_write < 1 || MODBUS_MAX_WR_WRITE_REGISTERS < nb_write || nb < 1 || MODBUS_MAX_WR_READ_REGISTERS < nb || nb_write_bytes != nb_write * 2 ) { rsp_length = response_exception ( ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE , rsp , TRUE , "Illegal<S2SV_blank>nb<S2SV_blank>of<S2SV_blank>values<S2SV_blank>(W%d,<S2SV_blank>R%d)<S2SV_blank>in<S2SV_blank>write_and_read_registers<S2SV_blank>(max<S2SV_blank>W%d,<S2SV_blank>R%d)\\n" , nb_write , nb , MODBUS_MAX_WR_WRITE_REGISTERS , MODBUS_MAX_WR_READ_REGISTERS ) ; } else if ( mapping_address < 0 || ( mapping_address + nb ) > mb_mapping -> nb_registers || mapping_address < 0 || ( mapping_address_write + nb_write ) > mb_mapping -> nb_registers ) { rsp_length = response_exception ( ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS , rsp , FALSE , "Illegal<S2SV_blank>data<S2SV_blank>read<S2SV_blank>address<S2SV_blank>0x%0X<S2SV_blank>or<S2SV_blank>write<S2SV_blank>address<S2SV_blank>0x%0X<S2SV_blank>write_and_read_registers\\n" , mapping_address < 0 ? address : address + nb , mapping_address_write < 0 ? address_write : address_write + nb_write ) ; } else { int i , j ; rsp_length = ctx -> backend -> build_response_basis ( & sft , rsp ) ; rsp [ rsp_length ++ ] = nb << 1 ; for ( i = mapping_address_write , j = 10 ; i < mapping_address_write + nb_write ; i ++ , j += 2 ) { mb_mapping -> tab_registers [ i ] = ( req [ offset + j ] << 8 ) + req [ offset + j + 1 ] ; } for ( i = mapping_address ; i < mapping_address + nb ; i ++ ) { rsp [ rsp_length ++ ] = mb_mapping -> tab_registers [ i ] >> 8 ; rsp [ rsp_length ++ ] = mb_mapping -> tab_registers [ i ] & 0xFF ; } } } break ; default : rsp_length = response_exception ( ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_FUNCTION , rsp , TRUE , "Unknown<S2SV_blank>Modbus<S2SV_blank>function<S2SV_blank>code:<S2SV_blank>0x%0X\\n" , function ) ; break ; } return ( ctx -> backend -> backend_type == _MODBUS_BACKEND_TYPE_RTU && slave == MODBUS_BROADCAST_ADDRESS ) ? 0 : send_msg ( ctx , rsp , rsp_length ) ; }
CWE-255 int vt_reset_keyboard ( int fd ) { <S2SV_StartBug> int kb ; <S2SV_EndBug> <S2SV_StartBug> kb = vt_default_utf8 ( ) != 0 ? K_UNICODE : K_XLATE ; <S2SV_EndBug> if ( ioctl ( fd , KDSKBMODE , kb ) < 0 ) return - errno ; return 0 ; }
CWE-255 static int find_source_vc ( char * * ret_path , unsigned * ret_idx ) { _cleanup_free_ char * path = NULL ; int r , err = 0 ; unsigned i ; path = new ( char , sizeof ( "/dev/tty63" ) ) ; if ( ! path ) return log_oom ( ) ; for ( i = 1 ; i <= 63 ; i ++ ) { _cleanup_close_ int fd = - 1 ; r = verify_vc_allocation ( i ) ; if ( r < 0 ) { if ( ! err ) err = - r ; continue ; } sprintf ( path , "/dev/tty%u" , i ) ; fd = open_terminal ( path , O_RDWR | O_CLOEXEC | O_NOCTTY ) ; if ( fd < 0 ) { if ( ! err ) err = - fd ; continue ; } <S2SV_StartBug> r = verify_vc_kbmode ( fd ) ; <S2SV_EndBug> if ( r < 0 ) { if ( ! err ) err = - r ; continue ; } * ret_idx = i ; * ret_path = TAKE_PTR ( path ) ; return TAKE_FD ( fd ) ; } return log_error_errno ( err , "No<S2SV_blank>usable<S2SV_blank>source<S2SV_blank>console<S2SV_blank>found:<S2SV_blank>%m" ) ; }
CWE-255 static void setup_remaining_vcs ( int src_fd , unsigned src_idx , bool utf8 ) { struct console_font_op cfo = { . op = KD_FONT_OP_GET , . width = UINT_MAX , . height = UINT_MAX , . charcount = UINT_MAX , } ; struct unimapinit adv = { } ; struct unimapdesc unimapd ; _cleanup_free_ struct unipair * unipairs = NULL ; _cleanup_free_ void * fontbuf = NULL ; unsigned i ; int r ; unipairs = new ( struct unipair , USHRT_MAX ) ; if ( ! unipairs ) { log_oom ( ) ; return ; } r = ioctl ( src_fd , KDFONTOP , & cfo ) ; if ( r < 0 ) log_warning_errno ( errno , "KD_FONT_OP_GET<S2SV_blank>failed<S2SV_blank>while<S2SV_blank>trying<S2SV_blank>to<S2SV_blank>get<S2SV_blank>the<S2SV_blank>font<S2SV_blank>metadata:<S2SV_blank>%m" ) ; else { if ( cfo . width > 32 || cfo . height > 32 || cfo . charcount > 512 ) log_warning ( "Invalid<S2SV_blank>font<S2SV_blank>metadata<S2SV_blank>-<S2SV_blank>width:<S2SV_blank>%u<S2SV_blank>(max<S2SV_blank>32),<S2SV_blank>height:<S2SV_blank>%u<S2SV_blank>(max<S2SV_blank>32),<S2SV_blank>count:<S2SV_blank>%u<S2SV_blank>(max<S2SV_blank>512)" , cfo . width , cfo . height , cfo . charcount ) ; else { fontbuf = malloc_multiply ( ( cfo . width + 7 ) / 8 * 32 , cfo . charcount ) ; if ( ! fontbuf ) { log_oom ( ) ; return ; } cfo . data = fontbuf ; r = ioctl ( src_fd , KDFONTOP , & cfo ) ; if ( r < 0 ) log_warning_errno ( errno , "KD_FONT_OP_GET<S2SV_blank>failed<S2SV_blank>while<S2SV_blank>trying<S2SV_blank>to<S2SV_blank>read<S2SV_blank>the<S2SV_blank>font<S2SV_blank>data:<S2SV_blank>%m" ) ; else { unimapd . entries = unipairs ; unimapd . entry_ct = USHRT_MAX ; r = ioctl ( src_fd , GIO_UNIMAP , & unimapd ) ; if ( r < 0 ) log_warning_errno ( errno , "GIO_UNIMAP<S2SV_blank>failed<S2SV_blank>while<S2SV_blank>trying<S2SV_blank>to<S2SV_blank>read<S2SV_blank>unicode<S2SV_blank>mappings:<S2SV_blank>%m" ) ; else cfo . op = KD_FONT_OP_SET ; } } } if ( cfo . op != KD_FONT_OP_SET ) log_warning ( "Fonts<S2SV_blank>will<S2SV_blank>not<S2SV_blank>be<S2SV_blank>copied<S2SV_blank>to<S2SV_blank>remaining<S2SV_blank>consoles" ) ; for ( i = 1 ; i <= 63 ; i ++ ) { char ttyname [ sizeof ( "/dev/tty63" ) ] ; _cleanup_close_ int fd_d = - 1 ; if ( i == src_idx || verify_vc_allocation ( i ) < 0 ) continue ; xsprintf ( ttyname , "/dev/tty%u" , i ) ; fd_d = open_terminal ( ttyname , O_RDWR | O_CLOEXEC | O_NOCTTY ) ; if ( fd_d < 0 ) { log_warning_errno ( fd_d , "Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>tty%u,<S2SV_blank>fonts<S2SV_blank>will<S2SV_blank>not<S2SV_blank>be<S2SV_blank>copied:<S2SV_blank>%m" , i ) ; continue ; } <S2SV_StartBug> if ( verify_vc_kbmode ( fd_d ) < 0 ) <S2SV_EndBug> continue ; toggle_utf8 ( ttyname , fd_d , utf8 ) ; if ( cfo . op != KD_FONT_OP_SET ) continue ; r = ioctl ( fd_d , KDFONTOP , & cfo ) ; if ( r < 0 ) { int last_errno , mode ; last_errno = errno ; if ( ioctl ( fd_d , KDGETMODE , & mode ) >= 0 && mode != KD_TEXT ) log_debug ( "KD_FONT_OP_SET<S2SV_blank>skipped:<S2SV_blank>tty%u<S2SV_blank>is<S2SV_blank>not<S2SV_blank>in<S2SV_blank>text<S2SV_blank>mode" , i ) ; else log_warning_errno ( last_errno , "KD_FONT_OP_SET<S2SV_blank>failed,<S2SV_blank>fonts<S2SV_blank>will<S2SV_blank>not<S2SV_blank>be<S2SV_blank>copied<S2SV_blank>to<S2SV_blank>tty%u:<S2SV_blank>%m" , i ) ; continue ; } r = ioctl ( fd_d , PIO_UNIMAPCLR , & adv ) ; if ( r < 0 ) { log_warning_errno ( errno , "PIO_UNIMAPCLR<S2SV_blank>failed,<S2SV_blank>unimaps<S2SV_blank>might<S2SV_blank>be<S2SV_blank>incorrect<S2SV_blank>for<S2SV_blank>tty%u:<S2SV_blank>%m" , i ) ; continue ; } r = ioctl ( fd_d , PIO_UNIMAP , & unimapd ) ; if ( r < 0 ) { log_warning_errno ( errno , "PIO_UNIMAP<S2SV_blank>failed,<S2SV_blank>unimaps<S2SV_blank>might<S2SV_blank>be<S2SV_blank>incorrect<S2SV_blank>for<S2SV_blank>tty%u:<S2SV_blank>%m" , i ) ; continue ; } log_debug ( "Font<S2SV_blank>and<S2SV_blank>unimap<S2SV_blank>successfully<S2SV_blank>copied<S2SV_blank>to<S2SV_blank>%s" , ttyname ) ; } }
CWE-255 static int toggle_utf8 ( const char * name , int fd , bool utf8 ) { int r ; struct termios tc = { } ; <S2SV_StartBug> assert ( name ) ; <S2SV_EndBug> r = ioctl ( fd , KDSKBMODE , utf8 ? K_UNICODE : K_XLATE ) ; if ( r < 0 ) return log_warning_errno ( errno , "Failed<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>UTF-8<S2SV_blank>kbdmode<S2SV_blank>on<S2SV_blank>%s:<S2SV_blank>%m" , enable_disable ( utf8 ) , name ) ; r = loop_write ( fd , utf8 ? "\\033%G" : "\\033%@" , 3 , false ) ; if ( r < 0 ) return log_warning_errno ( r , "Failed<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>UTF-8<S2SV_blank>term<S2SV_blank>processing<S2SV_blank>on<S2SV_blank>%s:<S2SV_blank>%m" , enable_disable ( utf8 ) , name ) ; r = tcgetattr ( fd , & tc ) ; if ( r >= 0 ) { SET_FLAG ( tc . c_iflag , IUTF8 , utf8 ) ; r = tcsetattr ( fd , TCSANOW , & tc ) ; } if ( r < 0 ) return log_warning_errno ( errno , "Failed<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>iutf8<S2SV_blank>flag<S2SV_blank>on<S2SV_blank>%s:<S2SV_blank>%m" , enable_disable ( utf8 ) , name ) ; log_debug ( "UTF-8<S2SV_blank>kbdmode<S2SV_blank>%sd<S2SV_blank>on<S2SV_blank>%s" , enable_disable ( utf8 ) , name ) ; return 0 ; }
CWE-255 static int verify_source_vc ( char * * ret_path , const char * src_vc ) { _cleanup_close_ int fd = - 1 ; char * path ; int r ; fd = open_terminal ( src_vc , O_RDWR | O_CLOEXEC | O_NOCTTY ) ; if ( fd < 0 ) return log_error_errno ( fd , "Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s:<S2SV_blank>%m" , src_vc ) ; r = verify_vc_device ( fd ) ; if ( r < 0 ) return log_error_errno ( r , "Device<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>virtual<S2SV_blank>console:<S2SV_blank>%m" , src_vc ) ; r = verify_vc_allocation_byfd ( fd ) ; if ( r < 0 ) return log_error_errno ( r , "Virtual<S2SV_blank>console<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>allocated:<S2SV_blank>%m" , src_vc ) ; <S2SV_StartBug> r = verify_vc_kbmode ( fd ) ; <S2SV_EndBug> if ( r < 0 ) return log_error_errno ( r , "Virtual<S2SV_blank>console<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>in<S2SV_blank>K_XLATE<S2SV_blank>or<S2SV_blank>K_UNICODE:<S2SV_blank>%m" , src_vc ) ; path = strdup ( src_vc ) ; if ( ! path ) return log_oom ( ) ; * ret_path = path ; return TAKE_FD ( fd ) ; }
CWE-59 void w3m_exit ( int i ) { # ifdef USE_MIGEMO init_migemo ( ) ; # endif stopDownload ( ) ; deleteFiles ( ) ; # ifdef USE_SSL free_ssl_ctx ( ) ; # endif disconnectFTP ( ) ; # ifdef USE_NNTP disconnectNews ( ) ; # endif # ifdef __MINGW32_VERSION WSACleanup ( ) ; # endif <S2SV_StartBug> exit ( i ) ; <S2SV_EndBug> }
CWE-59 void init_rc ( void ) { int i ; struct stat st ; FILE * f ; if ( rc_dir != NULL ) goto open_rc ; rc_dir = expandPath ( RC_DIR ) ; i = strlen ( rc_dir ) ; if ( i > 1 && rc_dir [ i - 1 ] == '/' ) rc_dir [ i - 1 ] = '\\0' ; # ifdef USE_M17N display_charset_str = wc_get_ces_list ( ) ; document_charset_str = display_charset_str ; system_charset_str = display_charset_str ; # endif if ( stat ( rc_dir , & st ) < 0 ) { if ( errno == ENOENT ) { if ( do_mkdir ( rc_dir , 0700 ) < 0 ) { goto rc_dir_err ; } else { stat ( rc_dir , & st ) ; } } else { goto rc_dir_err ; } } if ( ! S_ISDIR ( st . st_mode ) ) { goto rc_dir_err ; } if ( ! ( st . st_mode & S_IWUSR ) ) { goto rc_dir_err ; } no_rc_dir = FALSE ; tmp_dir = rc_dir ; if ( config_file == NULL ) config_file = rcFile ( CONFIG_FILE ) ; create_option_search_table ( ) ; open_rc : if ( ( f = fopen ( etcFile ( W3MCONFIG ) , "rt" ) ) != NULL ) { interpret_rc ( f ) ; fclose ( f ) ; } if ( ( f = fopen ( confFile ( CONFIG_FILE ) , "rt" ) ) != NULL ) { interpret_rc ( f ) ; fclose ( f ) ; } if ( config_file && ( f = fopen ( config_file , "rt" ) ) != NULL ) { interpret_rc ( f ) ; fclose ( f ) ; } return ; rc_dir_err : no_rc_dir = TRUE ; if ( ( ( tmp_dir = getenv ( "TMPDIR" ) ) == NULL || * tmp_dir == '\\0' ) && ( ( tmp_dir = getenv ( "TMP" ) ) == NULL || * tmp_dir == '\\0' ) && ( ( tmp_dir = getenv ( "TEMP" ) ) == NULL || * tmp_dir == '\\0' ) ) tmp_dir = "/tmp" ; <S2SV_StartBug> create_option_search_table ( ) ; <S2SV_EndBug> goto open_rc ; }
CWE-476 void formUpdateBuffer ( Anchor * a , Buffer * buf , FormItemList * form ) { Buffer save ; char * p ; int spos , epos , rows , c_rows , pos , col = 0 ; Line * l ; copyBuffer ( & save , buf ) ; gotoLine ( buf , a -> start . line ) ; switch ( form -> type ) { case FORM_TEXTAREA : case FORM_INPUT_TEXT : case FORM_INPUT_FILE : case FORM_INPUT_PASSWORD : case FORM_INPUT_CHECKBOX : case FORM_INPUT_RADIO : # ifdef MENU_SELECT case FORM_SELECT : # endif spos = a -> start . pos ; epos = a -> end . pos ; break ; default : spos = a -> start . pos + 1 ; epos = a -> end . pos - 1 ; } switch ( form -> type ) { case FORM_INPUT_CHECKBOX : case FORM_INPUT_RADIO : if ( buf -> currentLine == NULL || spos >= buf -> currentLine -> len || spos < 0 ) break ; if ( form -> checked ) buf -> currentLine -> lineBuf [ spos ] = '*' ; else buf -> currentLine -> lineBuf [ spos ] = '<S2SV_blank>' ; break ; case FORM_INPUT_TEXT : case FORM_INPUT_FILE : case FORM_INPUT_PASSWORD : case FORM_TEXTAREA : # ifdef MENU_SELECT case FORM_SELECT : if ( form -> type == FORM_SELECT ) { p = form -> label -> ptr ; updateSelectOption ( form , form -> select_option ) ; } else # endif { if ( ! form -> value ) break ; p = form -> value -> ptr ; } l = buf -> currentLine ; if ( ! l ) break ; if ( form -> type == FORM_TEXTAREA ) { int n = a -> y - buf -> currentLine -> linenumber ; if ( n > 0 ) for ( ; l && n ; l = l -> prev , n -- ) ; else if ( n < 0 ) for ( ; l && n ; l = l -> prev , n ++ ) ; if ( ! l ) break ; } rows = form -> rows ? form -> rows : 1 ; col = COLPOS ( l , a -> start . pos ) ; for ( c_rows = 0 ; c_rows < rows ; c_rows ++ , l = l -> next ) { <S2SV_StartBug> if ( rows > 1 ) { <S2SV_EndBug> pos = columnPos ( l , col ) ; a = retrieveAnchor ( buf -> formitem , l -> linenumber , pos ) ; if ( a == NULL ) break ; spos = a -> start . pos ; epos = a -> end . pos ; } if ( a -> start . line != a -> end . line || spos > epos || epos >= l -> len || spos < 0 || epos < 0 || COLPOS ( l , epos ) < col ) break ; pos = form_update_line ( l , & p , spos , epos , COLPOS ( l , epos ) - col , rows > 1 , form -> type == FORM_INPUT_PASSWORD ) ; if ( pos != epos ) { shiftAnchorPosition ( buf -> href , buf -> hmarklist , a -> start . line , spos , pos - epos ) ; shiftAnchorPosition ( buf -> name , buf -> hmarklist , a -> start . line , spos , pos - epos ) ; shiftAnchorPosition ( buf -> img , buf -> hmarklist , a -> start . line , spos , pos - epos ) ; shiftAnchorPosition ( buf -> formitem , buf -> hmarklist , a -> start . line , spos , pos - epos ) ; } } break ; } copyBuffer ( buf , & save ) ; arrangeLine ( buf ) ; }
CWE-835 static void feed_table_block_tag ( struct table * tbl , char * line , struct table_mode * mode , int indent , int cmd ) { int offset ; if ( mode -> indent_level <= 0 && indent == - 1 ) return ; if ( mode -> indent_level >= CHAR_MAX && indent == 1 ) return ; setwidth ( tbl , mode ) ; feed_table_inline_tag ( tbl , line , mode , - 1 ) ; clearcontentssize ( tbl , mode ) ; if ( indent == 1 ) { mode -> indent_level ++ ; if ( mode -> indent_level <= MAX_INDENT_LEVEL ) tbl -> indent += INDENT_INCR ; } else if ( indent == - 1 ) { mode -> indent_level -- ; if ( mode -> indent_level < MAX_INDENT_LEVEL ) tbl -> indent -= INDENT_INCR ; } <S2SV_StartBug> offset = tbl -> indent ; <S2SV_EndBug> if ( cmd == HTML_DT ) { if ( mode -> indent_level > 0 && mode -> indent_level <= MAX_INDENT_LEVEL ) offset -= INDENT_INCR ; <S2SV_StartBug> } <S2SV_EndBug> if ( tbl -> indent > 0 ) { check_minimum0 ( tbl , 0 ) ; addcontentssize ( tbl , offset ) ; } }
CWE-918 static int daemon_msg_open_req ( uint8 ver , struct daemon_slpars * pars , uint32 plen , char * source , size_t sourcelen ) { char errbuf [ PCAP_ERRBUF_SIZE ] ; char errmsgbuf [ PCAP_ERRBUF_SIZE ] ; pcap_t * fp ; int nread ; char sendbuf [ RPCAP_NETBUF_SIZE ] ; int sendbufidx = 0 ; struct rpcap_openreply * openreply ; if ( plen > sourcelen - 1 ) { pcap_snprintf ( errmsgbuf , PCAP_ERRBUF_SIZE , "Source<S2SV_blank>string<S2SV_blank>too<S2SV_blank>long" ) ; goto error ; } nread = sock_recv ( pars -> sockctrl , source , plen , SOCK_RECEIVEALL_YES | SOCK_EOF_IS_ERROR , errbuf , PCAP_ERRBUF_SIZE ) ; if ( nread == - 1 ) { rpcapd_log ( LOGPRIO_ERROR , "Read<S2SV_blank>from<S2SV_blank>client<S2SV_blank>failed:<S2SV_blank>%s" , errbuf ) ; return - 1 ; } source [ nread ] = '\\0' ; plen -= nread ; <S2SV_StartBug> if ( ( fp = pcap_open_live ( source , <S2SV_EndBug> 1500 , 0 , 1000 , errmsgbuf ) ) == NULL ) goto error ; if ( sock_bufferize ( NULL , sizeof ( struct rpcap_header ) , NULL , & sendbufidx , RPCAP_NETBUF_SIZE , SOCKBUF_CHECKONLY , errmsgbuf , PCAP_ERRBUF_SIZE ) == - 1 ) goto error ; rpcap_createhdr ( ( struct rpcap_header * ) sendbuf , ver , RPCAP_MSG_OPEN_REPLY , 0 , sizeof ( struct rpcap_openreply ) ) ; openreply = ( struct rpcap_openreply * ) & sendbuf [ sendbufidx ] ; if ( sock_bufferize ( NULL , sizeof ( struct rpcap_openreply ) , NULL , & sendbufidx , RPCAP_NETBUF_SIZE , SOCKBUF_CHECKONLY , errmsgbuf , PCAP_ERRBUF_SIZE ) == - 1 ) goto error ; memset ( openreply , 0 , sizeof ( struct rpcap_openreply ) ) ; openreply -> linktype = htonl ( pcap_datalink ( fp ) ) ; openreply -> tzoff = 0 ; pcap_close ( fp ) ; if ( sock_send ( pars -> sockctrl , sendbuf , sendbufidx , errbuf , PCAP_ERRBUF_SIZE ) == - 1 ) { rpcapd_log ( LOGPRIO_ERROR , "Send<S2SV_blank>to<S2SV_blank>client<S2SV_blank>failed:<S2SV_blank>%s" , errbuf ) ; return - 1 ; } return 0 ; error : if ( rpcap_senderror ( pars -> sockctrl , ver , PCAP_ERR_OPEN , errmsgbuf , errbuf ) == - 1 ) { rpcapd_log ( LOGPRIO_ERROR , "Send<S2SV_blank>to<S2SV_blank>client<S2SV_blank>failed:<S2SV_blank>%s" , errbuf ) ; return - 1 ; } if ( rpcapd_discard ( pars -> sockctrl , plen ) == - 1 ) { return - 1 ; } return 0 ; }
CWE-476 static int daemon_AuthUserPwd ( char * username , char * password , char * errbuf ) { # ifdef _WIN32 HANDLE Token ; if ( LogonUser ( username , "." , password , LOGON32_LOGON_NETWORK , LOGON32_PROVIDER_DEFAULT , & Token ) == 0 ) { pcap_fmt_errmsg_for_win32_err ( errbuf , PCAP_ERRBUF_SIZE , GetLastError ( ) , "LogonUser()<S2SV_blank>failed" ) ; return - 1 ; } if ( ImpersonateLoggedOnUser ( Token ) == 0 ) { pcap_fmt_errmsg_for_win32_err ( errbuf , PCAP_ERRBUF_SIZE , GetLastError ( ) , "ImpersonateLoggedOnUser()<S2SV_blank>failed" ) ; CloseHandle ( Token ) ; return - 1 ; } CloseHandle ( Token ) ; return 0 ; # else struct passwd * user ; char * user_password ; # ifdef HAVE_GETSPNAM struct spwd * usersp ; <S2SV_StartBug> # endif <S2SV_EndBug> if ( ( user = getpwnam ( username ) ) == NULL ) { pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , "Authentication<S2SV_blank>failed:<S2SV_blank>user<S2SV_blank>name<S2SV_blank>or<S2SV_blank>password<S2SV_blank>incorrect" ) ; return - 1 ; } # ifdef HAVE_GETSPNAM if ( ( usersp = getspnam ( username ) ) == NULL ) { pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , "Authentication<S2SV_blank>failed:<S2SV_blank>user<S2SV_blank>name<S2SV_blank>or<S2SV_blank>password<S2SV_blank>incorrect" ) ; return - 1 ; } user_password = usersp -> sp_pwdp ; # else user_password = user -> pw_passwd ; # endif <S2SV_StartBug> if ( strcmp ( user_password , ( char * ) crypt ( password , user_password ) ) != 0 ) <S2SV_EndBug> { pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , "Authentication<S2SV_blank>failed:<S2SV_blank>user<S2SV_blank>name<S2SV_blank>or<S2SV_blank>password<S2SV_blank>incorrect" ) ; return - 1 ; } if ( setuid ( user -> pw_uid ) ) { pcap_fmt_errmsg_for_errno ( errbuf , PCAP_ERRBUF_SIZE , errno , "setuid" ) ; return - 1 ; } return 0 ; # endif }
CWE-345 static int daemon_AuthUserPwd ( char * username , char * password , char * errbuf ) { # ifdef _WIN32 <S2SV_StartBug> HANDLE Token ; <S2SV_EndBug> <S2SV_StartBug> if ( LogonUser ( username , "." , password , LOGON32_LOGON_NETWORK , LOGON32_PROVIDER_DEFAULT , & Token ) == 0 ) <S2SV_EndBug> { <S2SV_StartBug> pcap_fmt_errmsg_for_win32_err ( errbuf , PCAP_ERRBUF_SIZE , <S2SV_EndBug> <S2SV_StartBug> GetLastError ( ) , "LogonUser()<S2SV_blank>failed" ) ; <S2SV_EndBug> return - 1 ; } <S2SV_StartBug> if ( ImpersonateLoggedOnUser ( Token ) == 0 ) <S2SV_EndBug> { pcap_fmt_errmsg_for_win32_err ( errbuf , PCAP_ERRBUF_SIZE , GetLastError ( ) , "ImpersonateLoggedOnUser()<S2SV_blank>failed" ) ; CloseHandle ( Token ) ; <S2SV_StartBug> return - 1 ; <S2SV_EndBug> } CloseHandle ( Token ) ; return 0 ; <S2SV_StartBug> # else <S2SV_EndBug> struct passwd * user ; char * user_password ; # ifdef HAVE_GETSPNAM struct spwd * usersp ; # endif char * crypt_password ; if ( ( user = getpwnam ( username ) ) == NULL ) { <S2SV_StartBug> pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , "Authentication<S2SV_blank>failed:<S2SV_blank>user<S2SV_blank>name<S2SV_blank>or<S2SV_blank>password<S2SV_blank>incorrect" ) ; <S2SV_EndBug> return - 1 ; } # ifdef HAVE_GETSPNAM if ( ( usersp = getspnam ( username ) ) == NULL ) { <S2SV_StartBug> pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , "Authentication<S2SV_blank>failed:<S2SV_blank>user<S2SV_blank>name<S2SV_blank>or<S2SV_blank>password<S2SV_blank>incorrect" ) ; <S2SV_EndBug> return - 1 ; } user_password = usersp -> sp_pwdp ; # else user_password = user -> pw_passwd ; # endif <S2SV_StartBug> crypt_password = crypt ( password , user_password ) ; <S2SV_EndBug> if ( crypt_password == NULL ) { <S2SV_StartBug> pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , "Authentication<S2SV_blank>failed" ) ; <S2SV_EndBug> return - 1 ; } if ( strcmp ( user_password , crypt_password ) != 0 ) { <S2SV_StartBug> pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , "Authentication<S2SV_blank>failed:<S2SV_blank>user<S2SV_blank>name<S2SV_blank>or<S2SV_blank>password<S2SV_blank>incorrect" ) ; <S2SV_EndBug> return - 1 ; } if ( setuid ( user -> pw_uid ) ) { <S2SV_StartBug> pcap_fmt_errmsg_for_errno ( errbuf , PCAP_ERRBUF_SIZE , <S2SV_EndBug> <S2SV_StartBug> errno , "setuid" ) ; <S2SV_EndBug> <S2SV_StartBug> return - 1 ; <S2SV_EndBug> } return 0 ; # endif }
CWE-20 static int daemon_msg_findallif_req ( uint8 ver , struct daemon_slpars * pars , uint32 plen ) { char errbuf [ PCAP_ERRBUF_SIZE ] ; char errmsgbuf [ PCAP_ERRBUF_SIZE ] ; char sendbuf [ RPCAP_NETBUF_SIZE ] ; int sendbufidx = 0 ; pcap_if_t * alldevs = NULL ; pcap_if_t * d ; struct pcap_addr * address ; struct rpcap_findalldevs_if * findalldevs_if ; <S2SV_StartBug> uint16 nif = 0 ; <S2SV_EndBug> if ( rpcapd_discard ( pars -> sockctrl , plen ) == - 1 ) { return - 1 ; } if ( pcap_findalldevs ( & alldevs , errmsgbuf ) == - 1 ) goto error ; if ( alldevs == NULL ) { if ( rpcap_senderror ( pars -> sockctrl , ver , PCAP_ERR_NOREMOTEIF , "No<S2SV_blank>interfaces<S2SV_blank>found!<S2SV_blank>Make<S2SV_blank>sure<S2SV_blank>libpcap/WinPcap<S2SV_blank>is<S2SV_blank>properly<S2SV_blank>installed" "<S2SV_blank>and<S2SV_blank>you<S2SV_blank>have<S2SV_blank>the<S2SV_blank>right<S2SV_blank>to<S2SV_blank>access<S2SV_blank>to<S2SV_blank>the<S2SV_blank>remote<S2SV_blank>device." , errbuf ) == - 1 ) { rpcapd_log ( LOGPRIO_ERROR , "Send<S2SV_blank>to<S2SV_blank>client<S2SV_blank>failed:<S2SV_blank>%s" , errbuf ) ; return - 1 ; } return 0 ; } <S2SV_StartBug> for ( d = alldevs ; d != NULL ; d = d -> next ) <S2SV_EndBug> { nif ++ ; if ( d -> description ) <S2SV_StartBug> plen += strlen ( d -> description ) ; <S2SV_EndBug> if ( d -> name ) <S2SV_StartBug> plen += strlen ( d -> name ) ; <S2SV_EndBug> <S2SV_StartBug> plen += sizeof ( struct rpcap_findalldevs_if ) ; <S2SV_EndBug> for ( address = d -> addresses ; address != NULL ; address = address -> next ) { switch ( address -> addr -> sa_family ) { case AF_INET : # ifdef AF_INET6 case AF_INET6 : # endif <S2SV_StartBug> plen += ( sizeof ( struct rpcap_sockaddr ) * 4 ) ; <S2SV_EndBug> break ; default : break ; } } } if ( sock_bufferize ( NULL , sizeof ( struct rpcap_header ) , NULL , & sendbufidx , RPCAP_NETBUF_SIZE , SOCKBUF_CHECKONLY , errmsgbuf , PCAP_ERRBUF_SIZE ) == - 1 ) goto error ; rpcap_createhdr ( ( struct rpcap_header * ) sendbuf , ver , <S2SV_StartBug> RPCAP_MSG_FINDALLIF_REPLY , nif , plen ) ; <S2SV_EndBug> for ( d = alldevs ; d != NULL ; d = d -> next ) { uint16 lname , ldescr ; findalldevs_if = ( struct rpcap_findalldevs_if * ) & sendbuf [ sendbufidx ] ; if ( sock_bufferize ( NULL , sizeof ( struct rpcap_findalldevs_if ) , NULL , & sendbufidx , RPCAP_NETBUF_SIZE , SOCKBUF_CHECKONLY , errmsgbuf , PCAP_ERRBUF_SIZE ) == - 1 ) goto error ; memset ( findalldevs_if , 0 , sizeof ( struct rpcap_findalldevs_if ) ) ; if ( d -> description ) ldescr = ( short ) strlen ( d -> description ) ; else ldescr = 0 ; if ( d -> name ) lname = ( short ) strlen ( d -> name ) ; else lname = 0 ; findalldevs_if -> desclen = htons ( ldescr ) ; findalldevs_if -> namelen = htons ( lname ) ; findalldevs_if -> flags = htonl ( d -> flags ) ; for ( address = d -> addresses ; address != NULL ; address = address -> next ) { switch ( address -> addr -> sa_family ) { case AF_INET : # ifdef AF_INET6 case AF_INET6 : # endif findalldevs_if -> naddr ++ ; break ; default : break ; } } findalldevs_if -> naddr = htons ( findalldevs_if -> naddr ) ; if ( sock_bufferize ( d -> name , lname , sendbuf , & sendbufidx , RPCAP_NETBUF_SIZE , SOCKBUF_BUFFERIZE , errmsgbuf , PCAP_ERRBUF_SIZE ) == - 1 ) goto error ; if ( sock_bufferize ( d -> description , ldescr , sendbuf , & sendbufidx , RPCAP_NETBUF_SIZE , SOCKBUF_BUFFERIZE , errmsgbuf , PCAP_ERRBUF_SIZE ) == - 1 ) goto error ; for ( address = d -> addresses ; address != NULL ; address = address -> next ) { struct rpcap_sockaddr * sockaddr ; switch ( address -> addr -> sa_family ) { case AF_INET : # ifdef AF_INET6 case AF_INET6 : # endif sockaddr = ( struct rpcap_sockaddr * ) & sendbuf [ sendbufidx ] ; if ( sock_bufferize ( NULL , sizeof ( struct rpcap_sockaddr ) , NULL , & sendbufidx , RPCAP_NETBUF_SIZE , SOCKBUF_CHECKONLY , errmsgbuf , PCAP_ERRBUF_SIZE ) == - 1 ) goto error ; daemon_seraddr ( ( struct sockaddr_storage * ) address -> addr , sockaddr ) ; sockaddr = ( struct rpcap_sockaddr * ) & sendbuf [ sendbufidx ] ; if ( sock_bufferize ( NULL , sizeof ( struct rpcap_sockaddr ) , NULL , & sendbufidx , RPCAP_NETBUF_SIZE , SOCKBUF_CHECKONLY , errmsgbuf , PCAP_ERRBUF_SIZE ) == - 1 ) goto error ; daemon_seraddr ( ( struct sockaddr_storage * ) address -> netmask , sockaddr ) ; sockaddr = ( struct rpcap_sockaddr * ) & sendbuf [ sendbufidx ] ; if ( sock_bufferize ( NULL , sizeof ( struct rpcap_sockaddr ) , NULL , & sendbufidx , RPCAP_NETBUF_SIZE , SOCKBUF_CHECKONLY , errmsgbuf , PCAP_ERRBUF_SIZE ) == - 1 ) goto error ; daemon_seraddr ( ( struct sockaddr_storage * ) address -> broadaddr , sockaddr ) ; sockaddr = ( struct rpcap_sockaddr * ) & sendbuf [ sendbufidx ] ; if ( sock_bufferize ( NULL , sizeof ( struct rpcap_sockaddr ) , NULL , & sendbufidx , RPCAP_NETBUF_SIZE , SOCKBUF_CHECKONLY , errmsgbuf , PCAP_ERRBUF_SIZE ) == - 1 ) goto error ; daemon_seraddr ( ( struct sockaddr_storage * ) address -> dstaddr , sockaddr ) ; break ; default : break ; } } } pcap_freealldevs ( alldevs ) ; if ( sock_send ( pars -> sockctrl , sendbuf , sendbufidx , errbuf , PCAP_ERRBUF_SIZE ) == - 1 ) { rpcapd_log ( LOGPRIO_ERROR , "Send<S2SV_blank>to<S2SV_blank>client<S2SV_blank>failed:<S2SV_blank>%s" , errbuf ) ; return - 1 ; } return 0 ; error : if ( alldevs ) pcap_freealldevs ( alldevs ) ; if ( rpcap_senderror ( pars -> sockctrl , ver , PCAP_ERR_FINDALLIF , errmsgbuf , errbuf ) == - 1 ) { rpcapd_log ( LOGPRIO_ERROR , "Send<S2SV_blank>to<S2SV_blank>client<S2SV_blank>failed:<S2SV_blank>%s" , errbuf ) ; return - 1 ; } return 0 ; }
CWE-20 pcap_t * pcap_ng_check_header ( const uint8_t * magic , FILE * fp , u_int precision , char * errbuf , int * err ) { bpf_u_int32 magic_int ; size_t amt_read ; bpf_u_int32 total_length ; bpf_u_int32 byte_order_magic ; struct block_header * bhdrp ; struct section_header_block * shbp ; pcap_t * p ; int swapped = 0 ; struct pcap_ng_sf * ps ; int status ; struct block_cursor cursor ; struct interface_description_block * idbp ; * err = 0 ; memcpy ( & magic_int , magic , sizeof ( magic_int ) ) ; if ( magic_int != BT_SHB ) { return ( NULL ) ; } amt_read = fread ( & total_length , 1 , sizeof ( total_length ) , fp ) ; if ( amt_read < sizeof ( total_length ) ) { if ( ferror ( fp ) ) { pcap_fmt_errmsg_for_errno ( errbuf , PCAP_ERRBUF_SIZE , errno , "error<S2SV_blank>reading<S2SV_blank>dump<S2SV_blank>file" ) ; * err = 1 ; return ( NULL ) ; } return ( NULL ) ; } amt_read = fread ( & byte_order_magic , 1 , sizeof ( byte_order_magic ) , fp ) ; if ( amt_read < sizeof ( byte_order_magic ) ) { if ( ferror ( fp ) ) { pcap_fmt_errmsg_for_errno ( errbuf , PCAP_ERRBUF_SIZE , errno , "error<S2SV_blank>reading<S2SV_blank>dump<S2SV_blank>file" ) ; * err = 1 ; return ( NULL ) ; } return ( NULL ) ; } if ( byte_order_magic != BYTE_ORDER_MAGIC ) { byte_order_magic = SWAPLONG ( byte_order_magic ) ; if ( byte_order_magic != BYTE_ORDER_MAGIC ) { return ( NULL ) ; } swapped = 1 ; total_length = SWAPLONG ( total_length ) ; } <S2SV_StartBug> if ( total_length < sizeof ( * bhdrp ) + sizeof ( * shbp ) + sizeof ( struct block_trailer ) ) { <S2SV_EndBug> pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , <S2SV_StartBug> "Section<S2SV_blank>Header<S2SV_blank>Block<S2SV_blank>in<S2SV_blank>pcapng<S2SV_blank>dump<S2SV_blank>file<S2SV_blank>has<S2SV_blank>a<S2SV_blank>length<S2SV_blank>of<S2SV_blank>%u<S2SV_blank><<S2SV_blank>%" PRIsize , <S2SV_EndBug> total_length , <S2SV_StartBug> sizeof ( * bhdrp ) + sizeof ( * shbp ) + sizeof ( struct block_trailer ) ) ; <S2SV_EndBug> * err = 1 ; return ( NULL ) ; } if ( total_length > INITIAL_MAX_BLOCKSIZE ) { pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , "pcapng<S2SV_blank>block<S2SV_blank>size<S2SV_blank>%u<S2SV_blank>><S2SV_blank>maximum<S2SV_blank>%u" , total_length , INITIAL_MAX_BLOCKSIZE ) ; * err = 1 ; return ( NULL ) ; } p = pcap_open_offline_common ( errbuf , sizeof ( struct pcap_ng_sf ) ) ; if ( p == NULL ) { * err = 1 ; return ( NULL ) ; } p -> swapped = swapped ; ps = p -> priv ; switch ( precision ) { case PCAP_TSTAMP_PRECISION_MICRO : ps -> user_tsresol = 1000000 ; break ; case PCAP_TSTAMP_PRECISION_NANO : ps -> user_tsresol = 1000000000 ; break ; default : pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , "unknown<S2SV_blank>time<S2SV_blank>stamp<S2SV_blank>resolution<S2SV_blank>%u" , precision ) ; free ( p ) ; * err = 1 ; return ( NULL ) ; } p -> opt . tstamp_precision = precision ; p -> bufsize = 2048 ; if ( p -> bufsize < total_length ) p -> bufsize = total_length ; p -> buffer = malloc ( p -> bufsize ) ; if ( p -> buffer == NULL ) { pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , "out<S2SV_blank>of<S2SV_blank>memory" ) ; free ( p ) ; * err = 1 ; return ( NULL ) ; } ps -> max_blocksize = INITIAL_MAX_BLOCKSIZE ; bhdrp = ( struct block_header * ) p -> buffer ; shbp = ( struct section_header_block * ) ( ( u_char * ) p -> buffer + sizeof ( struct block_header ) ) ; bhdrp -> block_type = magic_int ; bhdrp -> total_length = total_length ; shbp -> byte_order_magic = byte_order_magic ; if ( read_bytes ( fp , ( u_char * ) p -> buffer + ( sizeof ( magic_int ) + sizeof ( total_length ) + sizeof ( byte_order_magic ) ) , total_length - ( sizeof ( magic_int ) + sizeof ( total_length ) + sizeof ( byte_order_magic ) ) , 1 , errbuf ) == - 1 ) goto fail ; if ( p -> swapped ) { shbp -> major_version = SWAPSHORT ( shbp -> major_version ) ; shbp -> minor_version = SWAPSHORT ( shbp -> minor_version ) ; } if ( ! ( shbp -> major_version == PCAP_NG_VERSION_MAJOR && shbp -> minor_version == PCAP_NG_VERSION_MINOR ) ) { pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , "unsupported<S2SV_blank>pcapng<S2SV_blank>savefile<S2SV_blank>version<S2SV_blank>%u.%u" , shbp -> major_version , shbp -> minor_version ) ; goto fail ; } p -> version_major = shbp -> major_version ; p -> version_minor = shbp -> minor_version ; p -> opt . tstamp_precision = precision ; for ( ; ; ) { status = read_block ( fp , p , & cursor , errbuf ) ; if ( status == 0 ) { pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , "the<S2SV_blank>capture<S2SV_blank>file<S2SV_blank>has<S2SV_blank>no<S2SV_blank>Interface<S2SV_blank>Description<S2SV_blank>Blocks" ) ; goto fail ; } if ( status == - 1 ) goto fail ; switch ( cursor . block_type ) { case BT_IDB : idbp = get_from_block_data ( & cursor , sizeof ( * idbp ) , errbuf ) ; if ( idbp == NULL ) goto fail ; if ( p -> swapped ) { idbp -> linktype = SWAPSHORT ( idbp -> linktype ) ; idbp -> snaplen = SWAPLONG ( idbp -> snaplen ) ; } if ( ! add_interface ( p , & cursor , errbuf ) ) goto fail ; goto done ; case BT_EPB : case BT_SPB : case BT_PB : pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , "the<S2SV_blank>capture<S2SV_blank>file<S2SV_blank>has<S2SV_blank>a<S2SV_blank>packet<S2SV_blank>block<S2SV_blank>before<S2SV_blank>any<S2SV_blank>Interface<S2SV_blank>Description<S2SV_blank>Blocks" ) ; goto fail ; default : break ; } } done : p -> tzoff = 0 ; p -> linktype = linktype_to_dlt ( idbp -> linktype ) ; p -> snapshot = pcap_adjust_snapshot ( p -> linktype , idbp -> snaplen ) ; p -> linktype_ext = 0 ; if ( MAX_BLOCKSIZE_FOR_SNAPLEN ( max_snaplen_for_dlt ( p -> linktype ) ) > ps -> max_blocksize ) ps -> max_blocksize = MAX_BLOCKSIZE_FOR_SNAPLEN ( max_snaplen_for_dlt ( p -> linktype ) ) ; p -> next_packet_op = pcap_ng_next_packet ; p -> cleanup_op = pcap_ng_cleanup ; return ( p ) ; fail : free ( ps -> ifaces ) ; free ( p -> buffer ) ; free ( p ) ; * err = 1 ; return ( NULL ) ; }
CWE-20 static int read_bytes ( FILE * fp , void * buf , size_t bytes_to_read , int fail_on_eof , char * errbuf ) { size_t amt_read ; amt_read = fread ( buf , 1 , bytes_to_read , fp ) ; if ( amt_read != bytes_to_read ) { if ( ferror ( fp ) ) { pcap_fmt_errmsg_for_errno ( errbuf , PCAP_ERRBUF_SIZE , errno , "error<S2SV_blank>reading<S2SV_blank>dump<S2SV_blank>file" ) ; } else { if ( amt_read == 0 && ! fail_on_eof ) return ( 0 ) ; pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , <S2SV_StartBug> "truncated<S2SV_blank>dump<S2SV_blank>file;<S2SV_blank>tried<S2SV_blank>to<S2SV_blank>read<S2SV_blank>%" PRIsize "<S2SV_blank>bytes,<S2SV_blank>only<S2SV_blank>got<S2SV_blank>%" PRIsize , <S2SV_EndBug> bytes_to_read , amt_read ) ; } return ( - 1 ) ; } return ( 1 ) ; }
CWE-20 pcap_t * pcap_ng_check_header ( const uint8_t * magic , FILE * fp , u_int precision , char * errbuf , int * err ) { bpf_u_int32 magic_int ; size_t amt_read ; bpf_u_int32 total_length ; bpf_u_int32 byte_order_magic ; struct block_header * bhdrp ; struct section_header_block * shbp ; pcap_t * p ; int swapped = 0 ; struct pcap_ng_sf * ps ; int status ; struct block_cursor cursor ; struct interface_description_block * idbp ; * err = 0 ; memcpy ( & magic_int , magic , sizeof ( magic_int ) ) ; if ( magic_int != BT_SHB ) { return ( NULL ) ; } amt_read = fread ( & total_length , 1 , sizeof ( total_length ) , fp ) ; if ( amt_read < sizeof ( total_length ) ) { if ( ferror ( fp ) ) { pcap_fmt_errmsg_for_errno ( errbuf , PCAP_ERRBUF_SIZE , errno , "error<S2SV_blank>reading<S2SV_blank>dump<S2SV_blank>file" ) ; * err = 1 ; return ( NULL ) ; } return ( NULL ) ; } amt_read = fread ( & byte_order_magic , 1 , sizeof ( byte_order_magic ) , fp ) ; if ( amt_read < sizeof ( byte_order_magic ) ) { if ( ferror ( fp ) ) { pcap_fmt_errmsg_for_errno ( errbuf , PCAP_ERRBUF_SIZE , errno , "error<S2SV_blank>reading<S2SV_blank>dump<S2SV_blank>file" ) ; * err = 1 ; return ( NULL ) ; } return ( NULL ) ; } if ( byte_order_magic != BYTE_ORDER_MAGIC ) { byte_order_magic = SWAPLONG ( byte_order_magic ) ; if ( byte_order_magic != BYTE_ORDER_MAGIC ) { return ( NULL ) ; } swapped = 1 ; total_length = SWAPLONG ( total_length ) ; } if ( total_length < sizeof ( * bhdrp ) + sizeof ( * shbp ) + sizeof ( struct block_trailer ) || ( total_length > BT_SHB_INSANE_MAX ) ) { pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , <S2SV_StartBug> "Section<S2SV_blank>Header<S2SV_blank>Block<S2SV_blank>in<S2SV_blank>pcapng<S2SV_blank>dump<S2SV_blank>file<S2SV_blank>has<S2SV_blank>invalid<S2SV_blank>length<S2SV_blank>%" PRIsize "<S2SV_blank><<S2SV_blank>_%lu_<S2SV_blank><<S2SV_blank>%lu<S2SV_blank>(BT_SHB_INSANE_MAX)" , <S2SV_EndBug> sizeof ( * bhdrp ) + sizeof ( * shbp ) + sizeof ( struct block_trailer ) , total_length , BT_SHB_INSANE_MAX ) ; * err = 1 ; return ( NULL ) ; } p = pcap_open_offline_common ( errbuf , sizeof ( struct pcap_ng_sf ) ) ; if ( p == NULL ) { * err = 1 ; return ( NULL ) ; } p -> swapped = swapped ; ps = p -> priv ; switch ( precision ) { case PCAP_TSTAMP_PRECISION_MICRO : ps -> user_tsresol = 1000000 ; break ; case PCAP_TSTAMP_PRECISION_NANO : ps -> user_tsresol = 1000000000 ; break ; default : pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , "unknown<S2SV_blank>time<S2SV_blank>stamp<S2SV_blank>resolution<S2SV_blank>%u" , precision ) ; free ( p ) ; * err = 1 ; return ( NULL ) ; } p -> opt . tstamp_precision = precision ; p -> bufsize = 2048 ; if ( p -> bufsize < total_length ) p -> bufsize = total_length ; p -> buffer = malloc ( p -> bufsize ) ; if ( p -> buffer == NULL ) { pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , "out<S2SV_blank>of<S2SV_blank>memory" ) ; free ( p ) ; * err = 1 ; return ( NULL ) ; } ps -> max_blocksize = INITIAL_MAX_BLOCKSIZE ; bhdrp = ( struct block_header * ) p -> buffer ; shbp = ( struct section_header_block * ) ( ( u_char * ) p -> buffer + sizeof ( struct block_header ) ) ; bhdrp -> block_type = magic_int ; bhdrp -> total_length = total_length ; shbp -> byte_order_magic = byte_order_magic ; if ( read_bytes ( fp , ( u_char * ) p -> buffer + ( sizeof ( magic_int ) + sizeof ( total_length ) + sizeof ( byte_order_magic ) ) , total_length - ( sizeof ( magic_int ) + sizeof ( total_length ) + sizeof ( byte_order_magic ) ) , 1 , errbuf ) == - 1 ) goto fail ; if ( p -> swapped ) { shbp -> major_version = SWAPSHORT ( shbp -> major_version ) ; shbp -> minor_version = SWAPSHORT ( shbp -> minor_version ) ; } if ( ! ( shbp -> major_version == PCAP_NG_VERSION_MAJOR && shbp -> minor_version == PCAP_NG_VERSION_MINOR ) ) { pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , "unsupported<S2SV_blank>pcapng<S2SV_blank>savefile<S2SV_blank>version<S2SV_blank>%u.%u" , shbp -> major_version , shbp -> minor_version ) ; goto fail ; } p -> version_major = shbp -> major_version ; p -> version_minor = shbp -> minor_version ; p -> opt . tstamp_precision = precision ; for ( ; ; ) { status = read_block ( fp , p , & cursor , errbuf ) ; if ( status == 0 ) { pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , "the<S2SV_blank>capture<S2SV_blank>file<S2SV_blank>has<S2SV_blank>no<S2SV_blank>Interface<S2SV_blank>Description<S2SV_blank>Blocks" ) ; goto fail ; } if ( status == - 1 ) goto fail ; switch ( cursor . block_type ) { case BT_IDB : idbp = get_from_block_data ( & cursor , sizeof ( * idbp ) , errbuf ) ; if ( idbp == NULL ) goto fail ; if ( p -> swapped ) { idbp -> linktype = SWAPSHORT ( idbp -> linktype ) ; idbp -> snaplen = SWAPLONG ( idbp -> snaplen ) ; } if ( ! add_interface ( p , & cursor , errbuf ) ) goto fail ; goto done ; case BT_EPB : case BT_SPB : case BT_PB : pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , "the<S2SV_blank>capture<S2SV_blank>file<S2SV_blank>has<S2SV_blank>a<S2SV_blank>packet<S2SV_blank>block<S2SV_blank>before<S2SV_blank>any<S2SV_blank>Interface<S2SV_blank>Description<S2SV_blank>Blocks" ) ; goto fail ; default : break ; } } done : p -> tzoff = 0 ; p -> linktype = linktype_to_dlt ( idbp -> linktype ) ; p -> snapshot = pcap_adjust_snapshot ( p -> linktype , idbp -> snaplen ) ; p -> linktype_ext = 0 ; if ( MAX_BLOCKSIZE_FOR_SNAPLEN ( max_snaplen_for_dlt ( p -> linktype ) ) > ps -> max_blocksize ) ps -> max_blocksize = MAX_BLOCKSIZE_FOR_SNAPLEN ( max_snaplen_for_dlt ( p -> linktype ) ) ; p -> next_packet_op = pcap_ng_next_packet ; p -> cleanup_op = pcap_ng_cleanup ; return ( p ) ; fail : free ( ps -> ifaces ) ; free ( p -> buffer ) ; free ( p ) ; * err = 1 ; return ( NULL ) ; }
CWE-20 void lmp_print ( netdissect_options * ndo , register const u_char * pptr , register u_int len ) { const struct lmp_common_header * lmp_com_header ; const struct lmp_object_header * lmp_obj_header ; const u_char * tptr , * obj_tptr ; u_int tlen , lmp_obj_len , lmp_obj_ctype , obj_tlen ; int hexdump , ret ; u_int offset ; u_int link_type ; union { float f ; uint32_t i ; } bw ; tptr = pptr ; lmp_com_header = ( const struct lmp_common_header * ) pptr ; ND_TCHECK ( * lmp_com_header ) ; if ( LMP_EXTRACT_VERSION ( lmp_com_header -> version_res [ 0 ] ) != LMP_VERSION ) { ND_PRINT ( ( ndo , "LMP<S2SV_blank>version<S2SV_blank>%u<S2SV_blank>packet<S2SV_blank>not<S2SV_blank>supported" , LMP_EXTRACT_VERSION ( lmp_com_header -> version_res [ 0 ] ) ) ) ; return ; } if ( ndo -> ndo_vflag < 1 ) { ND_PRINT ( ( ndo , "LMPv%u<S2SV_blank>%s<S2SV_blank>Message,<S2SV_blank>length:<S2SV_blank>%u" , LMP_EXTRACT_VERSION ( lmp_com_header -> version_res [ 0 ] ) , tok2str ( lmp_msg_type_values , "unknown<S2SV_blank>(%u)" , lmp_com_header -> msg_type ) , len ) ) ; return ; } tlen = EXTRACT_16BITS ( lmp_com_header -> length ) ; ND_PRINT ( ( ndo , "\\n\\tLMPv%u,<S2SV_blank>msg-type:<S2SV_blank>%s,<S2SV_blank>Flags:<S2SV_blank>[%s],<S2SV_blank>length:<S2SV_blank>%u" , LMP_EXTRACT_VERSION ( lmp_com_header -> version_res [ 0 ] ) , tok2str ( lmp_msg_type_values , "unknown,<S2SV_blank>type:<S2SV_blank>%u" , lmp_com_header -> msg_type ) , bittok2str ( lmp_header_flag_values , "none" , lmp_com_header -> flags ) , tlen ) ) ; if ( tlen < sizeof ( const struct lmp_common_header ) ) { ND_PRINT ( ( ndo , "<S2SV_blank>(too<S2SV_blank>short)" ) ) ; return ; } if ( tlen > len ) { ND_PRINT ( ( ndo , "<S2SV_blank>(too<S2SV_blank>long)" ) ) ; tlen = len ; } tptr += sizeof ( const struct lmp_common_header ) ; tlen -= sizeof ( const struct lmp_common_header ) ; while ( tlen > 0 ) { ND_TCHECK2 ( * tptr , sizeof ( struct lmp_object_header ) ) ; lmp_obj_header = ( const struct lmp_object_header * ) tptr ; lmp_obj_len = EXTRACT_16BITS ( lmp_obj_header -> length ) ; lmp_obj_ctype = ( lmp_obj_header -> ctype ) & 0x7f ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Object<S2SV_blank>(%u),<S2SV_blank>Class-Type:<S2SV_blank>%s<S2SV_blank>(%u)<S2SV_blank>Flags:<S2SV_blank>[%snegotiable],<S2SV_blank>length:<S2SV_blank>%u" , tok2str ( lmp_obj_values , "Unknown" , lmp_obj_header -> class_num ) , lmp_obj_header -> class_num , tok2str ( lmp_ctype_values , "Unknown" , ( ( lmp_obj_header -> class_num ) << 8 ) + lmp_obj_ctype ) , lmp_obj_ctype , ( lmp_obj_header -> ctype ) & 0x80 ? "" : "non-" , lmp_obj_len ) ) ; if ( lmp_obj_len < 4 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(too<S2SV_blank>short)" ) ) ; return ; } if ( ( lmp_obj_len % 4 ) != 0 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>a<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>4)" ) ) ; return ; } obj_tptr = tptr + sizeof ( struct lmp_object_header ) ; obj_tlen = lmp_obj_len - sizeof ( struct lmp_object_header ) ; ND_TCHECK2 ( * tptr , lmp_obj_len ) ; hexdump = FALSE ; switch ( lmp_obj_header -> class_num ) { case LMP_OBJ_CC_ID : switch ( lmp_obj_ctype ) { case LMP_CTYPE_LOC : case LMP_CTYPE_RMT : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Control<S2SV_blank>Channel<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)" , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_LINK_ID : case LMP_OBJ_INTERFACE_ID : switch ( lmp_obj_ctype ) { case LMP_CTYPE_IPV4_LOC : case LMP_CTYPE_IPV4_RMT : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>IPv4<S2SV_blank>Link<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)" , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; case LMP_CTYPE_IPV6_LOC : case LMP_CTYPE_IPV6_RMT : if ( obj_tlen != 16 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>IPv6<S2SV_blank>Link<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)" , ip6addr_string ( ndo , obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; case LMP_CTYPE_UNMD_LOC : case LMP_CTYPE_UNMD_RMT : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Link<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)" , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_MESSAGE_ID : switch ( lmp_obj_ctype ) { case LMP_CTYPE_1 : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Message<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)" , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; case LMP_CTYPE_2 : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Message<S2SV_blank>ID<S2SV_blank>Ack:<S2SV_blank>%u<S2SV_blank>(0x%08x)" , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_NODE_ID : switch ( lmp_obj_ctype ) { case LMP_CTYPE_LOC : case LMP_CTYPE_RMT : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Node<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)" , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_CONFIG : switch ( lmp_obj_ctype ) { case LMP_CTYPE_HELLO_CONFIG : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Hello<S2SV_blank>Interval:<S2SV_blank>%u\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Hello<S2SV_blank>Dead<S2SV_blank>Interval:<S2SV_blank>%u" , EXTRACT_16BITS ( obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_HELLO : switch ( lmp_obj_ctype ) { case LMP_CTYPE_HELLO : if ( obj_tlen != 8 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Tx<S2SV_blank>Seq:<S2SV_blank>%u,<S2SV_blank>Rx<S2SV_blank>Seq:<S2SV_blank>%u" , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr + 4 ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_TE_LINK : switch ( lmp_obj_ctype ) { case LMP_CTYPE_IPV4 : if ( obj_tlen != 12 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[%s]" , bittok2str ( lmp_obj_te_link_flag_values , "none" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Link-ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)" "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Remote<S2SV_blank>Link-ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)" , ipaddr_string ( ndo , obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , ipaddr_string ( ndo , obj_tptr + 8 ) , EXTRACT_32BITS ( obj_tptr + 8 ) ) ) ; break ; case LMP_CTYPE_IPV6 : if ( obj_tlen != 36 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[%s]" , bittok2str ( lmp_obj_te_link_flag_values , "none" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Link-ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)" "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Remote<S2SV_blank>Link-ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)" , ip6addr_string ( ndo , obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , ip6addr_string ( ndo , obj_tptr + 20 ) , EXTRACT_32BITS ( obj_tptr + 20 ) ) ) ; break ; case LMP_CTYPE_UNMD : if ( obj_tlen != 12 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[%s]" , bittok2str ( lmp_obj_te_link_flag_values , "none" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Link-ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)" "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Remote<S2SV_blank>Link-ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)" , EXTRACT_32BITS ( obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 8 ) , EXTRACT_32BITS ( obj_tptr + 8 ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_DATA_LINK : switch ( lmp_obj_ctype ) { case LMP_CTYPE_IPV4 : if ( obj_tlen < 12 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[%s]" , bittok2str ( lmp_obj_data_link_flag_values , "none" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)" "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Remote<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)" , ipaddr_string ( ndo , obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , ipaddr_string ( ndo , obj_tptr + 8 ) , EXTRACT_32BITS ( obj_tptr + 8 ) ) ) ; ret = lmp_print_data_link_subobjs ( ndo , obj_tptr , obj_tlen - 12 , 12 ) ; if ( ret == - 1 ) goto trunc ; if ( ret == TRUE ) hexdump = TRUE ; break ; case LMP_CTYPE_IPV6 : if ( obj_tlen < 36 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[%s]" , bittok2str ( lmp_obj_data_link_flag_values , "none" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)" "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Remote<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)" , ip6addr_string ( ndo , obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , ip6addr_string ( ndo , obj_tptr + 20 ) , EXTRACT_32BITS ( obj_tptr + 20 ) ) ) ; ret = lmp_print_data_link_subobjs ( ndo , obj_tptr , obj_tlen - 36 , 36 ) ; if ( ret == - 1 ) goto trunc ; if ( ret == TRUE ) hexdump = TRUE ; break ; case LMP_CTYPE_UNMD : if ( obj_tlen < 12 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[%s]" , bittok2str ( lmp_obj_data_link_flag_values , "none" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)" "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Remote<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)" , EXTRACT_32BITS ( obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 8 ) , EXTRACT_32BITS ( obj_tptr + 8 ) ) ) ; ret = lmp_print_data_link_subobjs ( ndo , obj_tptr , obj_tlen - 12 , 12 ) ; if ( ret == - 1 ) goto trunc ; if ( ret == TRUE ) hexdump = TRUE ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_VERIFY_BEGIN : switch ( lmp_obj_ctype ) { case LMP_CTYPE_1 : if ( obj_tlen != 20 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>%s" , bittok2str ( lmp_obj_begin_verify_flag_values , "none" , EXTRACT_16BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Verify<S2SV_blank>Interval:<S2SV_blank>%u" , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Data<S2SV_blank>links:<S2SV_blank>%u" , EXTRACT_32BITS ( obj_tptr + 4 ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Encoding<S2SV_blank>type:<S2SV_blank>%s" , tok2str ( gmpls_encoding_values , "Unknown" , * ( obj_tptr + 8 ) ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Verify<S2SV_blank>Transport<S2SV_blank>Mechanism:<S2SV_blank>%u<S2SV_blank>(0x%x)%s" , EXTRACT_16BITS ( obj_tptr + 10 ) , EXTRACT_16BITS ( obj_tptr + 10 ) , EXTRACT_16BITS ( obj_tptr + 10 ) & 8000 ? "<S2SV_blank>(Payload<S2SV_blank>test<S2SV_blank>messages<S2SV_blank>capable)" : "" ) ) ; bw . i = EXTRACT_32BITS ( obj_tptr + 12 ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Transmission<S2SV_blank>Rate:<S2SV_blank>%.3f<S2SV_blank>Mbps" , bw . f * 8 / 1000000 ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Wavelength:<S2SV_blank>%u" , EXTRACT_32BITS ( obj_tptr + 16 ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_VERIFY_BEGIN_ACK : switch ( lmp_obj_ctype ) { case LMP_CTYPE_1 : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Verify<S2SV_blank>Dead<S2SV_blank>Interval:<S2SV_blank>%u" "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Verify<S2SV_blank>Transport<S2SV_blank>Response:<S2SV_blank>%u" , EXTRACT_16BITS ( obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_VERIFY_ID : switch ( lmp_obj_ctype ) { case LMP_CTYPE_1 : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Verify<S2SV_blank>ID:<S2SV_blank>%u" , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_CHANNEL_STATUS : switch ( lmp_obj_ctype ) { case LMP_CTYPE_IPV4 : offset = 0 ; while ( offset + 8 <= obj_tlen ) { ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)" , ipaddr_string ( ndo , obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Active:<S2SV_blank>%s<S2SV_blank>(%u)" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 31 ) ? "Allocated" : "Non-allocated" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 31 ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Direction:<S2SV_blank>%s<S2SV_blank>(%u)" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 30 ) & 0x1 ? "Transmit" : "Receive" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 30 ) & 0x1 ) ) ; ND_PRINT ( ( ndo , "\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Channel<S2SV_blank>Status:<S2SV_blank>%s<S2SV_blank>(%u)" , tok2str ( lmp_obj_channel_status_values , "Unknown" , EXTRACT_32BITS ( obj_tptr + offset + 4 ) & 0x3FFFFFF ) , EXTRACT_32BITS ( obj_tptr + offset + 4 ) & 0x3FFFFFF ) ) ; offset += 8 ; } break ; case LMP_CTYPE_IPV6 : offset = 0 ; while ( offset + 20 <= obj_tlen ) { ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)" , ip6addr_string ( ndo , obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Active:<S2SV_blank>%s<S2SV_blank>(%u)" , ( EXTRACT_32BITS ( obj_tptr + offset + 16 ) >> 31 ) ? "Allocated" : "Non-allocated" , ( EXTRACT_32BITS ( obj_tptr + offset + 16 ) >> 31 ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Direction:<S2SV_blank>%s<S2SV_blank>(%u)" , ( EXTRACT_32BITS ( obj_tptr + offset + 16 ) >> 30 ) & 0x1 ? "Transmit" : "Receive" , ( EXTRACT_32BITS ( obj_tptr + offset + 16 ) >> 30 ) & 0x1 ) ) ; ND_PRINT ( ( ndo , "\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Channel<S2SV_blank>Status:<S2SV_blank>%s<S2SV_blank>(%u)" , tok2str ( lmp_obj_channel_status_values , "Unknown" , EXTRACT_32BITS ( obj_tptr + offset + 16 ) & 0x3FFFFFF ) , EXTRACT_32BITS ( obj_tptr + offset + 16 ) & 0x3FFFFFF ) ) ; offset += 20 ; } break ; case LMP_CTYPE_UNMD : offset = 0 ; while ( offset + 8 <= obj_tlen ) { ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)" , EXTRACT_32BITS ( obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Active:<S2SV_blank>%s<S2SV_blank>(%u)" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 31 ) ? "Allocated" : "Non-allocated" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 31 ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Direction:<S2SV_blank>%s<S2SV_blank>(%u)" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 30 ) & 0x1 ? "Transmit" : "Receive" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 30 ) & 0x1 ) ) ; ND_PRINT ( ( ndo , "\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Channel<S2SV_blank>Status:<S2SV_blank>%s<S2SV_blank>(%u)" , tok2str ( lmp_obj_channel_status_values , "Unknown" , EXTRACT_32BITS ( obj_tptr + offset + 4 ) & 0x3FFFFFF ) , EXTRACT_32BITS ( obj_tptr + offset + 4 ) & 0x3FFFFFF ) ) ; offset += 8 ; } break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_CHANNEL_STATUS_REQ : switch ( lmp_obj_ctype ) { case LMP_CTYPE_IPV4 : offset = 0 ; while ( offset + 4 <= obj_tlen ) { ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)" , ipaddr_string ( ndo , obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; offset += 4 ; } break ; case LMP_CTYPE_IPV6 : offset = 0 ; while ( offset + 16 <= obj_tlen ) { ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)" , ip6addr_string ( ndo , obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; offset += 16 ; } break ; case LMP_CTYPE_UNMD : offset = 0 ; while ( offset + 4 <= obj_tlen ) { ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)" , EXTRACT_32BITS ( obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; offset += 4 ; } break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_ERROR_CODE : switch ( lmp_obj_ctype ) { case LMP_CTYPE_BEGIN_VERIFY_ERROR : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Error<S2SV_blank>Code:<S2SV_blank>%s" , bittok2str ( lmp_obj_begin_verify_error_values , "none" , EXTRACT_32BITS ( obj_tptr ) ) ) ) ; break ; case LMP_CTYPE_LINK_SUMMARY_ERROR : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Error<S2SV_blank>Code:<S2SV_blank>%s" , bittok2str ( lmp_obj_link_summary_error_values , "none" , EXTRACT_32BITS ( obj_tptr ) ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_SERVICE_CONFIG : switch ( lmp_obj_ctype ) { case LMP_CTYPE_SERVICE_CONFIG_SP : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank>Flags:<S2SV_blank>%s" , bittok2str ( lmp_obj_service_config_sp_flag_values , "none" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>UNI<S2SV_blank>Version:<S2SV_blank>%u" , EXTRACT_8BITS ( obj_tptr + 1 ) ) ) ; break ; case LMP_CTYPE_SERVICE_CONFIG_CPSA : if ( obj_tlen != 16 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } link_type = EXTRACT_8BITS ( obj_tptr ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank>Link<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u)" , tok2str ( lmp_sd_service_config_cpsa_link_type_values , "Unknown" , link_type ) , link_type ) ) ; switch ( link_type ) { case LMP_SD_SERVICE_CONFIG_CPSA_LINK_TYPE_SDH : ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank>Signal<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u)" , tok2str ( lmp_sd_service_config_cpsa_signal_type_sdh_values , "Unknown" , EXTRACT_8BITS ( obj_tptr + 1 ) ) , EXTRACT_8BITS ( obj_tptr + 1 ) ) ) ; break ; case LMP_SD_SERVICE_CONFIG_CPSA_LINK_TYPE_SONET : ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank>Signal<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u)" , tok2str ( lmp_sd_service_config_cpsa_signal_type_sonet_values , "Unknown" , EXTRACT_8BITS ( obj_tptr + 1 ) ) , EXTRACT_8BITS ( obj_tptr + 1 ) ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank>Transparency:<S2SV_blank>%s" , bittok2str ( lmp_obj_service_config_cpsa_tp_flag_values , "none" , EXTRACT_8BITS ( obj_tptr + 2 ) ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank>Contiguous<S2SV_blank>Concatenation<S2SV_blank>Types:<S2SV_blank>%s" , bittok2str ( lmp_obj_service_config_cpsa_cct_flag_values , "none" , EXTRACT_8BITS ( obj_tptr + 3 ) ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank>Minimum<S2SV_blank>NCC:<S2SV_blank>%u" , EXTRACT_16BITS ( obj_tptr + 4 ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank>Maximum<S2SV_blank>NCC:<S2SV_blank>%u" , EXTRACT_16BITS ( obj_tptr + 6 ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank>Minimum<S2SV_blank>NVC:%u" , EXTRACT_16BITS ( obj_tptr + 8 ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank>Maximum<S2SV_blank>NVC:%u" , EXTRACT_16BITS ( obj_tptr + 10 ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)" , ipaddr_string ( ndo , obj_tptr + 12 ) , EXTRACT_32BITS ( obj_tptr + 12 ) ) ) ; break ; case LMP_CTYPE_SERVICE_CONFIG_TRANSPARENCY_TCM : if ( obj_tlen != 8 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank>Transparency<S2SV_blank>Flags:<S2SV_blank>%s" , bittok2str ( lmp_obj_service_config_nsa_transparency_flag_values , "none" , EXTRACT_32BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank>TCM<S2SV_blank>Monitoring<S2SV_blank>Flags:<S2SV_blank>%s" , bittok2str ( lmp_obj_service_config_nsa_tcm_flag_values , "none" , EXTRACT_8BITS ( obj_tptr + 7 ) ) ) ) ; break ; case LMP_CTYPE_SERVICE_CONFIG_NETWORK_DIVERSITY : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank>Diversity:<S2SV_blank>Flags:<S2SV_blank>%s" , bittok2str ( lmp_obj_service_config_nsa_network_diversity_flag_values , "none" , EXTRACT_8BITS ( obj_tptr + 3 ) ) ) ) ; break ; default : hexdump = TRUE ; } break ; default : if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , obj_tptr , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , obj_tlen ) ; break ; } if ( ndo -> ndo_vflag > 1 || hexdump == TRUE ) print_unknown_data ( ndo , tptr + sizeof ( struct lmp_object_header ) , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , lmp_obj_len - sizeof ( struct lmp_object_header ) ) ; tptr += lmp_obj_len ; tlen -= lmp_obj_len ; } return ; trunc : <S2SV_StartBug> ND_PRINT ( ( ndo , "\\n\\t\\t<S2SV_blank>packet<S2SV_blank>exceeded<S2SV_blank>snapshot" ) ) ; <S2SV_EndBug> }
CWE-20 static int lmp_print_data_link_subobjs ( netdissect_options * ndo , const u_char * obj_tptr , int total_subobj_len , int offset ) { int hexdump = FALSE ; int subobj_type , subobj_len ; union { float f ; uint32_t i ; } bw ; while ( total_subobj_len > 0 && hexdump == FALSE ) { <S2SV_StartBug> subobj_type = EXTRACT_8BITS ( obj_tptr + offset ) ; <S2SV_EndBug> subobj_len = EXTRACT_8BITS ( obj_tptr + offset + 1 ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Subobject,<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>Length:<S2SV_blank>%u" , tok2str ( lmp_data_link_subobj , "Unknown" , subobj_type ) , subobj_type , subobj_len ) ) ; if ( subobj_len < 4 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(too<S2SV_blank>short)" ) ) ; break ; } if ( ( subobj_len % 4 ) != 0 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>a<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>4)" ) ) ; break ; } if ( total_subobj_len < subobj_len ) { ND_PRINT ( ( ndo , "<S2SV_blank>(goes<S2SV_blank>past<S2SV_blank>the<S2SV_blank>end<S2SV_blank>of<S2SV_blank>the<S2SV_blank>object)" ) ) ; break ; } switch ( subobj_type ) { case INT_SWITCHING_TYPE_SUBOBJ : <S2SV_StartBug> ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Switching<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u)" , <S2SV_EndBug> tok2str ( gmpls_switch_cap_values , "Unknown" , EXTRACT_8BITS ( obj_tptr + offset + 2 ) ) , <S2SV_StartBug> EXTRACT_8BITS ( obj_tptr + offset + 2 ) ) ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Encoding<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u)" , tok2str ( gmpls_encoding_values , "Unknown" , EXTRACT_8BITS ( obj_tptr + offset + 3 ) ) , EXTRACT_8BITS ( obj_tptr + offset + 3 ) ) ) ; ND_TCHECK_32BITS ( obj_tptr + offset + 4 ) ; bw . i = EXTRACT_32BITS ( obj_tptr + offset + 4 ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Min<S2SV_blank>Reservable<S2SV_blank>Bandwidth:<S2SV_blank>%.3f<S2SV_blank>Mbps" , bw . f * 8 / 1000000 ) ) ; <S2SV_StartBug> bw . i = EXTRACT_32BITS ( obj_tptr + offset + 8 ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Max<S2SV_blank>Reservable<S2SV_blank>Bandwidth:<S2SV_blank>%.3f<S2SV_blank>Mbps" , bw . f * 8 / 1000000 ) ) ; break ; case WAVELENGTH_SUBOBJ : <S2SV_StartBug> ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Wavelength:<S2SV_blank>%u" , <S2SV_EndBug> EXTRACT_32BITS ( obj_tptr + offset + 4 ) ) ) ; break ; default : hexdump = TRUE ; break ; } total_subobj_len -= subobj_len ; offset += subobj_len ; } return ( hexdump ) ; trunc : return - 1 ; }
CWE-125 static void babel_print_v2 ( netdissect_options * ndo , const u_char * cp , u_int length ) { u_int i ; u_short bodylen ; u_char v4_prefix [ 16 ] = { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0xFF , 0xFF , 0 , 0 , 0 , 0 } ; u_char v6_prefix [ 16 ] = { 0 } ; ND_TCHECK2 ( * cp , 4 ) ; if ( length < 4 ) goto invalid ; bodylen = EXTRACT_16BITS ( cp + 2 ) ; ND_PRINT ( ( ndo , "<S2SV_blank>(%u)" , bodylen ) ) ; i = 0 ; while ( i < bodylen ) { const u_char * message ; u_int type , len ; message = cp + 4 + i ; ND_TCHECK2 ( * message , 1 ) ; if ( ( type = message [ 0 ] ) == MESSAGE_PAD1 ) { ND_PRINT ( ( ndo , ndo -> ndo_vflag ? "\\n\\tPad<S2SV_blank>1" : "<S2SV_blank>pad1" ) ) ; i += 1 ; continue ; } ND_TCHECK2 ( * message , 2 ) ; ICHECK ( i , 2 ) ; len = message [ 1 ] ; ND_TCHECK2 ( * message , 2 + len ) ; ICHECK ( i , 2 + len ) ; switch ( type ) { case MESSAGE_PADN : { if ( ! ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "<S2SV_blank>padN" ) ) ; else ND_PRINT ( ( ndo , "\\n\\tPad<S2SV_blank>%d" , len + 2 ) ) ; } break ; case MESSAGE_ACK_REQ : { u_short nonce , interval ; if ( ! ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "<S2SV_blank>ack-req" ) ) ; else { ND_PRINT ( ( ndo , "\\n\\tAcknowledgment<S2SV_blank>Request<S2SV_blank>" ) ) ; if ( len < 6 ) goto invalid ; nonce = EXTRACT_16BITS ( message + 4 ) ; interval = EXTRACT_16BITS ( message + 6 ) ; ND_PRINT ( ( ndo , "%04x<S2SV_blank>%s" , nonce , format_interval ( interval ) ) ) ; } } break ; case MESSAGE_ACK : { u_short nonce ; if ( ! ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "<S2SV_blank>ack" ) ) ; else { ND_PRINT ( ( ndo , "\\n\\tAcknowledgment<S2SV_blank>" ) ) ; if ( len < 2 ) goto invalid ; nonce = EXTRACT_16BITS ( message + 2 ) ; ND_PRINT ( ( ndo , "%04x" , nonce ) ) ; } } break ; case MESSAGE_HELLO : { u_short seqno , interval ; if ( ! ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "<S2SV_blank>hello" ) ) ; else { ND_PRINT ( ( ndo , "\\n\\tHello<S2SV_blank>" ) ) ; if ( len < 6 ) goto invalid ; seqno = EXTRACT_16BITS ( message + 4 ) ; interval = EXTRACT_16BITS ( message + 6 ) ; ND_PRINT ( ( ndo , "seqno<S2SV_blank>%u<S2SV_blank>interval<S2SV_blank>%s" , seqno , format_interval ( interval ) ) ) ; if ( len > 6 ) subtlvs_print ( ndo , message + 8 , message + 2 + len , type ) ; } } break ; case MESSAGE_IHU : { unsigned short txcost , interval ; if ( ! ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "<S2SV_blank>ihu" ) ) ; else { u_char address [ 16 ] ; int rc ; ND_PRINT ( ( ndo , "\\n\\tIHU<S2SV_blank>" ) ) ; if ( len < 6 ) goto invalid ; txcost = EXTRACT_16BITS ( message + 4 ) ; interval = EXTRACT_16BITS ( message + 6 ) ; rc = network_address ( message [ 2 ] , message + 8 , len - 6 , address ) ; if ( rc < 0 ) { ND_PRINT ( ( ndo , "%s" , tstr ) ) ; break ; } ND_PRINT ( ( ndo , "%s<S2SV_blank>txcost<S2SV_blank>%u<S2SV_blank>interval<S2SV_blank>%s" , format_address ( ndo , address ) , txcost , format_interval ( interval ) ) ) ; if ( ( u_int ) rc < len - 6 ) subtlvs_print ( ndo , message + 8 + rc , message + 2 + len , type ) ; } } break ; case MESSAGE_ROUTER_ID : { if ( ! ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "<S2SV_blank>router-id" ) ) ; else { ND_PRINT ( ( ndo , "\\n\\tRouter<S2SV_blank>Id" ) ) ; if ( len < 10 ) goto invalid ; ND_PRINT ( ( ndo , "<S2SV_blank>%s" , format_id ( message + 4 ) ) ) ; } } break ; case MESSAGE_NH : { if ( ! ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "<S2SV_blank>nh" ) ) ; else { int rc ; u_char nh [ 16 ] ; ND_PRINT ( ( ndo , "\\n\\tNext<S2SV_blank>Hop" ) ) ; if ( len < 2 ) goto invalid ; rc = network_address ( message [ 2 ] , message + 4 , len - 2 , nh ) ; if ( rc < 0 ) goto invalid ; ND_PRINT ( ( ndo , "<S2SV_blank>%s" , format_address ( ndo , nh ) ) ) ; } } break ; case MESSAGE_UPDATE : { if ( ! ndo -> ndo_vflag ) { ND_PRINT ( ( ndo , "<S2SV_blank>update" ) ) ; <S2SV_StartBug> if ( len < 1 ) <S2SV_EndBug> ND_PRINT ( ( ndo , "/truncated" ) ) ; else ND_PRINT ( ( ndo , "%s%s%s" , ( message [ 3 ] & 0x80 ) ? "/prefix" : "" , ( message [ 3 ] & 0x40 ) ? "/id" : "" , ( message [ 3 ] & 0x3f ) ? "/unknown" : "" ) ) ; } else { u_short interval , seqno , metric ; u_char plen ; int rc ; u_char prefix [ 16 ] ; ND_PRINT ( ( ndo , "\\n\\tUpdate" ) ) ; if ( len < 10 ) goto invalid ; plen = message [ 4 ] + ( message [ 2 ] == 1 ? 96 : 0 ) ; rc = network_prefix ( message [ 2 ] , message [ 4 ] , message [ 5 ] , message + 12 , message [ 2 ] == 1 ? v4_prefix : v6_prefix , len - 10 , prefix ) ; if ( rc < 0 ) goto invalid ; interval = EXTRACT_16BITS ( message + 6 ) ; seqno = EXTRACT_16BITS ( message + 8 ) ; metric = EXTRACT_16BITS ( message + 10 ) ; ND_PRINT ( ( ndo , "%s%s%s<S2SV_blank>%s<S2SV_blank>metric<S2SV_blank>%u<S2SV_blank>seqno<S2SV_blank>%u<S2SV_blank>interval<S2SV_blank>%s" , ( message [ 3 ] & 0x80 ) ? "/prefix" : "" , ( message [ 3 ] & 0x40 ) ? "/id" : "" , ( message [ 3 ] & 0x3f ) ? "/unknown" : "" , format_prefix ( ndo , prefix , plen ) , metric , seqno , format_interval_update ( interval ) ) ) ; if ( message [ 3 ] & 0x80 ) { if ( message [ 2 ] == 1 ) memcpy ( v4_prefix , prefix , 16 ) ; else memcpy ( v6_prefix , prefix , 16 ) ; } if ( ( u_int ) rc < len - 10 ) subtlvs_print ( ndo , message + 12 + rc , message + 2 + len , type ) ; } } break ; case MESSAGE_REQUEST : { if ( ! ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "<S2SV_blank>request" ) ) ; else { int rc ; u_char prefix [ 16 ] , plen ; ND_PRINT ( ( ndo , "\\n\\tRequest<S2SV_blank>" ) ) ; if ( len < 2 ) goto invalid ; plen = message [ 3 ] + ( message [ 2 ] == 1 ? 96 : 0 ) ; rc = network_prefix ( message [ 2 ] , message [ 3 ] , 0 , message + 4 , NULL , len - 2 , prefix ) ; if ( rc < 0 ) goto invalid ; ND_PRINT ( ( ndo , "for<S2SV_blank>%s" , message [ 2 ] == 0 ? "any" : format_prefix ( ndo , prefix , plen ) ) ) ; } } break ; case MESSAGE_MH_REQUEST : { if ( ! ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "<S2SV_blank>mh-request" ) ) ; else { int rc ; u_short seqno ; u_char prefix [ 16 ] , plen ; ND_PRINT ( ( ndo , "\\n\\tMH-Request<S2SV_blank>" ) ) ; if ( len < 14 ) goto invalid ; seqno = EXTRACT_16BITS ( message + 4 ) ; rc = network_prefix ( message [ 2 ] , message [ 3 ] , 0 , message + 16 , NULL , len - 14 , prefix ) ; if ( rc < 0 ) goto invalid ; plen = message [ 3 ] + ( message [ 2 ] == 1 ? 96 : 0 ) ; ND_PRINT ( ( ndo , "(%u<S2SV_blank>hops)<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>seqno<S2SV_blank>%u<S2SV_blank>id<S2SV_blank>%s" , message [ 6 ] , format_prefix ( ndo , prefix , plen ) , seqno , format_id ( message + 8 ) ) ) ; } } break ; case MESSAGE_TSPC : if ( ! ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "<S2SV_blank>tspc" ) ) ; else { ND_PRINT ( ( ndo , "\\n\\tTS/PC<S2SV_blank>" ) ) ; if ( len < 6 ) goto invalid ; ND_PRINT ( ( ndo , "timestamp<S2SV_blank>%u<S2SV_blank>packetcounter<S2SV_blank>%u" , EXTRACT_32BITS ( message + 4 ) , EXTRACT_16BITS ( message + 2 ) ) ) ; } break ; case MESSAGE_HMAC : { if ( ! ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "<S2SV_blank>hmac" ) ) ; else { unsigned j ; ND_PRINT ( ( ndo , "\\n\\tHMAC<S2SV_blank>" ) ) ; if ( len < 18 ) goto invalid ; ND_PRINT ( ( ndo , "key-id<S2SV_blank>%u<S2SV_blank>digest-%u<S2SV_blank>" , EXTRACT_16BITS ( message + 2 ) , len - 2 ) ) ; for ( j = 0 ; j < len - 2 ; j ++ ) ND_PRINT ( ( ndo , "%02X" , message [ 4 + j ] ) ) ; } } break ; case MESSAGE_UPDATE_SRC_SPECIFIC : { if ( ! ndo -> ndo_vflag ) { ND_PRINT ( ( ndo , "<S2SV_blank>ss-update" ) ) ; } else { u_char prefix [ 16 ] , src_prefix [ 16 ] ; u_short interval , seqno , metric ; u_char ae , plen , src_plen , omitted ; int rc ; int parsed_len = 10 ; ND_PRINT ( ( ndo , "\\n\\tSS-Update" ) ) ; if ( len < 10 ) goto invalid ; ae = message [ 2 ] ; src_plen = message [ 3 ] ; plen = message [ 4 ] ; omitted = message [ 5 ] ; interval = EXTRACT_16BITS ( message + 6 ) ; seqno = EXTRACT_16BITS ( message + 8 ) ; metric = EXTRACT_16BITS ( message + 10 ) ; rc = network_prefix ( ae , plen , omitted , message + 2 + parsed_len , ae == 1 ? v4_prefix : v6_prefix , len - parsed_len , prefix ) ; if ( rc < 0 ) goto invalid ; if ( ae == 1 ) plen += 96 ; parsed_len += rc ; rc = network_prefix ( ae , src_plen , 0 , message + 2 + parsed_len , NULL , len - parsed_len , src_prefix ) ; if ( rc < 0 ) goto invalid ; if ( ae == 1 ) src_plen += 96 ; parsed_len += rc ; ND_PRINT ( ( ndo , "<S2SV_blank>%s<S2SV_blank>from" , format_prefix ( ndo , prefix , plen ) ) ) ; ND_PRINT ( ( ndo , "<S2SV_blank>%s<S2SV_blank>metric<S2SV_blank>%u<S2SV_blank>seqno<S2SV_blank>%u<S2SV_blank>interval<S2SV_blank>%s" , format_prefix ( ndo , src_prefix , src_plen ) , metric , seqno , format_interval_update ( interval ) ) ) ; if ( ( u_int ) parsed_len < len ) subtlvs_print ( ndo , message + 2 + parsed_len , message + 2 + len , type ) ; } } break ; case MESSAGE_REQUEST_SRC_SPECIFIC : { if ( ! ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "<S2SV_blank>ss-request" ) ) ; else { int rc , parsed_len = 3 ; u_char ae , plen , src_plen , prefix [ 16 ] , src_prefix [ 16 ] ; ND_PRINT ( ( ndo , "\\n\\tSS-Request<S2SV_blank>" ) ) ; if ( len < 3 ) goto invalid ; ae = message [ 2 ] ; plen = message [ 3 ] ; src_plen = message [ 4 ] ; rc = network_prefix ( ae , plen , 0 , message + 2 + parsed_len , NULL , len - parsed_len , prefix ) ; if ( rc < 0 ) goto invalid ; if ( ae == 1 ) plen += 96 ; parsed_len += rc ; rc = network_prefix ( ae , src_plen , 0 , message + 2 + parsed_len , NULL , len - parsed_len , src_prefix ) ; if ( rc < 0 ) goto invalid ; if ( ae == 1 ) src_plen += 96 ; parsed_len += rc ; if ( ae == 0 ) { ND_PRINT ( ( ndo , "for<S2SV_blank>any" ) ) ; } else { ND_PRINT ( ( ndo , "for<S2SV_blank>(%s,<S2SV_blank>" , format_prefix ( ndo , prefix , plen ) ) ) ; ND_PRINT ( ( ndo , "%s)" , format_prefix ( ndo , src_prefix , src_plen ) ) ) ; } } } break ; case MESSAGE_MH_REQUEST_SRC_SPECIFIC : { if ( ! ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "<S2SV_blank>ss-mh-request" ) ) ; else { int rc , parsed_len = 14 ; u_short seqno ; u_char ae , plen , src_plen , prefix [ 16 ] , src_prefix [ 16 ] , hopc ; const u_char * router_id = NULL ; ND_PRINT ( ( ndo , "\\n\\tSS-MH-Request<S2SV_blank>" ) ) ; if ( len < 14 ) goto invalid ; ae = message [ 2 ] ; plen = message [ 3 ] ; seqno = EXTRACT_16BITS ( message + 4 ) ; hopc = message [ 6 ] ; src_plen = message [ 7 ] ; router_id = message + 8 ; rc = network_prefix ( ae , plen , 0 , message + 2 + parsed_len , NULL , len - parsed_len , prefix ) ; if ( rc < 0 ) goto invalid ; if ( ae == 1 ) plen += 96 ; parsed_len += rc ; rc = network_prefix ( ae , src_plen , 0 , message + 2 + parsed_len , NULL , len - parsed_len , src_prefix ) ; if ( rc < 0 ) goto invalid ; if ( ae == 1 ) src_plen += 96 ; ND_PRINT ( ( ndo , "(%u<S2SV_blank>hops)<S2SV_blank>for<S2SV_blank>(%s,<S2SV_blank>" , hopc , format_prefix ( ndo , prefix , plen ) ) ) ; ND_PRINT ( ( ndo , "%s)<S2SV_blank>seqno<S2SV_blank>%u<S2SV_blank>id<S2SV_blank>%s" , format_prefix ( ndo , src_prefix , src_plen ) , seqno , format_id ( router_id ) ) ) ; } } break ; default : if ( ! ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "<S2SV_blank>unknown" ) ) ; else ND_PRINT ( ( ndo , "\\n\\tUnknown<S2SV_blank>message<S2SV_blank>type<S2SV_blank>%d" , type ) ) ; } i += len + 2 ; } return ; trunc : ND_PRINT ( ( ndo , "<S2SV_blank>%s" , tstr ) ) ; return ; invalid : ND_PRINT ( ( ndo , "%s" , istr ) ) ; return ; }
CWE-125 static int bgp_attr_print ( netdissect_options * ndo , u_int atype , const u_char * pptr , u_int len ) { int i ; uint16_t af ; uint8_t safi , snpa , nhlen ; union { float f ; uint32_t i ; } bw ; int advance ; u_int tlen ; const u_char * tptr ; char buf [ MAXHOSTNAMELEN + 100 ] ; int as_size ; tptr = pptr ; tlen = len ; switch ( atype ) { case BGPTYPE_ORIGIN : if ( len != 1 ) ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; else { ND_TCHECK ( * tptr ) ; ND_PRINT ( ( ndo , "%s" , tok2str ( bgp_origin_values , "Unknown<S2SV_blank>Origin<S2SV_blank>Typecode" , tptr [ 0 ] ) ) ) ; } break ; case BGPTYPE_AS4_PATH : case BGPTYPE_AS_PATH : if ( len % 2 ) { ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; break ; } if ( ! len ) { ND_PRINT ( ( ndo , "empty" ) ) ; break ; } as_size = bgp_attr_get_as_size ( ndo , atype , pptr , len ) ; while ( tptr < pptr + len ) { ND_TCHECK ( tptr [ 0 ] ) ; ND_PRINT ( ( ndo , "%s" , tok2str ( bgp_as_path_segment_open_values , "?" , tptr [ 0 ] ) ) ) ; ND_TCHECK ( tptr [ 1 ] ) ; for ( i = 0 ; i < tptr [ 1 ] * as_size ; i += as_size ) { ND_TCHECK2 ( tptr [ 2 + i ] , as_size ) ; ND_PRINT ( ( ndo , "%s<S2SV_blank>" , as_printf ( ndo , astostr , sizeof ( astostr ) , as_size == 2 ? EXTRACT_16BITS ( & tptr [ 2 + i ] ) : EXTRACT_32BITS ( & tptr [ 2 + i ] ) ) ) ) ; } ND_TCHECK ( tptr [ 0 ] ) ; ND_PRINT ( ( ndo , "%s" , tok2str ( bgp_as_path_segment_close_values , "?" , tptr [ 0 ] ) ) ) ; ND_TCHECK ( tptr [ 1 ] ) ; tptr += 2 + tptr [ 1 ] * as_size ; } break ; case BGPTYPE_NEXT_HOP : if ( len != 4 ) ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; else { ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , "%s" , ipaddr_string ( ndo , tptr ) ) ) ; } break ; case BGPTYPE_MULTI_EXIT_DISC : case BGPTYPE_LOCAL_PREF : if ( len != 4 ) ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; else { ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , "%u" , EXTRACT_32BITS ( tptr ) ) ) ; } break ; case BGPTYPE_ATOMIC_AGGREGATE : if ( len != 0 ) ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; break ; case BGPTYPE_AGGREGATOR : if ( len != 6 && len != 8 ) { ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; break ; } ND_TCHECK2 ( tptr [ 0 ] , len ) ; if ( len == 6 ) { ND_PRINT ( ( ndo , "<S2SV_blank>AS<S2SV_blank>#%s,<S2SV_blank>origin<S2SV_blank>%s" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_16BITS ( tptr ) ) , ipaddr_string ( ndo , tptr + 2 ) ) ) ; } else { ND_PRINT ( ( ndo , "<S2SV_blank>AS<S2SV_blank>#%s,<S2SV_blank>origin<S2SV_blank>%s" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr ) ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; } break ; case BGPTYPE_AGGREGATOR4 : if ( len != 8 ) { ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; break ; } ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , "<S2SV_blank>AS<S2SV_blank>#%s,<S2SV_blank>origin<S2SV_blank>%s" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr ) ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; break ; case BGPTYPE_COMMUNITIES : if ( len % 4 ) { ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; break ; } while ( tlen > 0 ) { uint32_t comm ; ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; comm = EXTRACT_32BITS ( tptr ) ; switch ( comm ) { case BGP_COMMUNITY_NO_EXPORT : ND_PRINT ( ( ndo , "<S2SV_blank>NO_EXPORT" ) ) ; break ; case BGP_COMMUNITY_NO_ADVERT : ND_PRINT ( ( ndo , "<S2SV_blank>NO_ADVERTISE" ) ) ; break ; case BGP_COMMUNITY_NO_EXPORT_SUBCONFED : ND_PRINT ( ( ndo , "<S2SV_blank>NO_EXPORT_SUBCONFED" ) ) ; break ; default : ND_PRINT ( ( ndo , "%u:%u%s" , ( comm >> 16 ) & 0xffff , comm & 0xffff , ( tlen > 4 ) ? ",<S2SV_blank>" : "" ) ) ; break ; } tlen -= 4 ; tptr += 4 ; } break ; case BGPTYPE_ORIGINATOR_ID : if ( len != 4 ) { ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; break ; } ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , "%s" , ipaddr_string ( ndo , tptr ) ) ) ; break ; case BGPTYPE_CLUSTER_LIST : if ( len % 4 ) { ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; break ; } while ( tlen > 0 ) { ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , "%s%s" , ipaddr_string ( ndo , tptr ) , ( tlen > 4 ) ? ",<S2SV_blank>" : "" ) ) ; tlen -= 4 ; tptr += 4 ; } break ; case BGPTYPE_MP_REACH_NLRI : ND_TCHECK2 ( tptr [ 0 ] , 3 ) ; af = EXTRACT_16BITS ( tptr ) ; safi = tptr [ 2 ] ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>AFI:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>%sSAFI:<S2SV_blank>%s<S2SV_blank>(%u)" , tok2str ( af_values , "Unknown<S2SV_blank>AFI" , af ) , af , ( safi > 128 ) ? "vendor<S2SV_blank>specific<S2SV_blank>" : "" , tok2str ( bgp_safi_values , "Unknown<S2SV_blank>SAFI" , safi ) , safi ) ) ; switch ( af << 8 | safi ) { case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_RT_ROUTING_INFO ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET << 8 | SAFNUM_MDT ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : break ; default : ND_TCHECK2 ( tptr [ 0 ] , tlen ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>no<S2SV_blank>AFI<S2SV_blank>%u<S2SV_blank>/<S2SV_blank>SAFI<S2SV_blank>%u<S2SV_blank>decoder" , af , safi ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , tlen ) ; goto done ; break ; } tptr += 3 ; ND_TCHECK ( tptr [ 0 ] ) ; nhlen = tptr [ 0 ] ; tlen = nhlen ; tptr ++ ; if ( tlen ) { int nnh = 0 ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>nexthop:<S2SV_blank>" ) ) ; while ( tlen > 0 ) { if ( nnh ++ > 0 ) { ND_PRINT ( ( ndo , ",<S2SV_blank>" ) ) ; } switch ( af << 8 | safi ) { case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_RT_ROUTING_INFO ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET << 8 | SAFNUM_MDT ) : if ( tlen < ( int ) sizeof ( struct in_addr ) ) { ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in_addr ) ) ; ND_PRINT ( ( ndo , "%s" , ipaddr_string ( ndo , tptr ) ) ) ; tlen -= sizeof ( struct in_addr ) ; tptr += sizeof ( struct in_addr ) ; } break ; case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < ( int ) ( sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ) { ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ; ND_PRINT ( ( ndo , "RD:<S2SV_blank>%s,<S2SV_blank>%s" , bgp_vpn_rd_print ( ndo , tptr ) , ipaddr_string ( ndo , tptr + BGP_VPN_RD_LEN ) ) ) ; tlen -= ( sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ; tptr += ( sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ; } break ; case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : if ( tlen < ( int ) sizeof ( struct in6_addr ) ) { ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in6_addr ) ) ; ND_PRINT ( ( ndo , "%s" , ip6addr_string ( ndo , tptr ) ) ) ; tlen -= sizeof ( struct in6_addr ) ; tptr += sizeof ( struct in6_addr ) ; } break ; case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < ( int ) ( sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ) { ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ; ND_PRINT ( ( ndo , "RD:<S2SV_blank>%s,<S2SV_blank>%s" , bgp_vpn_rd_print ( ndo , tptr ) , ip6addr_string ( ndo , tptr + BGP_VPN_RD_LEN ) ) ) ; tlen -= ( sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ; tptr += ( sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ; } break ; case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < ( int ) sizeof ( struct in_addr ) ) { ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in_addr ) ) ; ND_PRINT ( ( ndo , "%s" , ipaddr_string ( ndo , tptr ) ) ) ; tlen -= ( sizeof ( struct in_addr ) ) ; tptr += ( sizeof ( struct in_addr ) ) ; } break ; case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : ND_TCHECK2 ( tptr [ 0 ] , tlen ) ; ND_PRINT ( ( ndo , "%s" , isonsap_string ( ndo , tptr , tlen ) ) ) ; tptr += tlen ; tlen = 0 ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < BGP_VPN_RD_LEN + 1 ) { ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , tlen ) ; ND_PRINT ( ( ndo , "RD:<S2SV_blank>%s,<S2SV_blank>%s" , bgp_vpn_rd_print ( ndo , tptr ) , isonsap_string ( ndo , tptr + BGP_VPN_RD_LEN , tlen - BGP_VPN_RD_LEN ) ) ) ; <S2SV_StartBug> if ( EXTRACT_32BITS ( tptr + BGP_VPN_RD_LEN ) == 0x47000601 ) <S2SV_EndBug> ND_PRINT ( ( ndo , "<S2SV_blank>=<S2SV_blank>%s" , ipaddr_string ( ndo , tptr + BGP_VPN_RD_LEN + 4 ) ) ) ; <S2SV_StartBug> else if ( EXTRACT_24BITS ( tptr + BGP_VPN_RD_LEN ) == 0x350000 ) <S2SV_EndBug> ND_PRINT ( ( ndo , "<S2SV_blank>=<S2SV_blank>%s" , ip6addr_string ( ndo , tptr + BGP_VPN_RD_LEN + 3 ) ) ) ; tptr += tlen ; tlen = 0 ; } break ; default : ND_TCHECK2 ( tptr [ 0 ] , tlen ) ; ND_PRINT ( ( ndo , "no<S2SV_blank>AFI<S2SV_blank>%u/SAFI<S2SV_blank>%u<S2SV_blank>decoder" , af , safi ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , tlen ) ; tptr += tlen ; tlen = 0 ; goto done ; break ; } } } ND_PRINT ( ( ndo , ",<S2SV_blank>nh-length:<S2SV_blank>%u" , nhlen ) ) ; tptr += tlen ; ND_TCHECK ( tptr [ 0 ] ) ; snpa = tptr [ 0 ] ; tptr ++ ; if ( snpa ) { ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%u<S2SV_blank>SNPA" , snpa ) ) ; for ( ; snpa > 0 ; snpa -- ) { ND_TCHECK ( tptr [ 0 ] ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%d<S2SV_blank>bytes" , tptr [ 0 ] ) ) ; tptr += tptr [ 0 ] + 1 ; } } else { ND_PRINT ( ( ndo , ",<S2SV_blank>no<S2SV_blank>SNPA" ) ) ; } while ( tptr < pptr + len ) { switch ( af << 8 | safi ) { case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix4 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_RT_ROUTING_INFO ) : advance = decode_rt_routing_info ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST_VPN ) : advance = decode_multicast_vpn ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_MDT ) : advance = decode_mdt_vpn_nlri ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix6 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_l2 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; default : ND_TCHECK2 ( * tptr , tlen ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>no<S2SV_blank>AFI<S2SV_blank>%u<S2SV_blank>/<S2SV_blank>SAFI<S2SV_blank>%u<S2SV_blank>decoder" , af , safi ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , tlen ) ; advance = 0 ; tptr = pptr + len ; break ; } if ( advance < 0 ) break ; tptr += advance ; } done : break ; case BGPTYPE_MP_UNREACH_NLRI : ND_TCHECK2 ( tptr [ 0 ] , BGP_MP_NLRI_MINSIZE ) ; af = EXTRACT_16BITS ( tptr ) ; safi = tptr [ 2 ] ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>AFI:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>%sSAFI:<S2SV_blank>%s<S2SV_blank>(%u)" , tok2str ( af_values , "Unknown<S2SV_blank>AFI" , af ) , af , ( safi > 128 ) ? "vendor<S2SV_blank>specific<S2SV_blank>" : "" , tok2str ( bgp_safi_values , "Unknown<S2SV_blank>SAFI" , safi ) , safi ) ) ; if ( len == BGP_MP_NLRI_MINSIZE ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>End-of-Rib<S2SV_blank>Marker<S2SV_blank>(empty<S2SV_blank>NLRI)" ) ) ; tptr += 3 ; while ( tptr < pptr + len ) { switch ( af << 8 | safi ) { case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix4 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix6 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_l2 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_MDT ) : advance = decode_mdt_vpn_nlri ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST_VPN ) : advance = decode_multicast_vpn ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; default : ND_TCHECK2 ( * ( tptr - 3 ) , tlen ) ; ND_PRINT ( ( ndo , "no<S2SV_blank>AFI<S2SV_blank>%u<S2SV_blank>/<S2SV_blank>SAFI<S2SV_blank>%u<S2SV_blank>decoder" , af , safi ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr - 3 , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , tlen ) ; advance = 0 ; tptr = pptr + len ; break ; } if ( advance < 0 ) break ; tptr += advance ; } break ; case BGPTYPE_EXTD_COMMUNITIES : if ( len % 8 ) { ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; break ; } while ( tlen > 0 ) { uint16_t extd_comm ; ND_TCHECK2 ( tptr [ 0 ] , 2 ) ; extd_comm = EXTRACT_16BITS ( tptr ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>(0x%04x),<S2SV_blank>Flags<S2SV_blank>[%s]" , tok2str ( bgp_extd_comm_subtype_values , "unknown<S2SV_blank>extd<S2SV_blank>community<S2SV_blank>typecode" , extd_comm ) , extd_comm , bittok2str ( bgp_extd_comm_flag_values , "none" , extd_comm ) ) ) ; ND_TCHECK2 ( * ( tptr + 2 ) , 6 ) ; switch ( extd_comm ) { case BGP_EXT_COM_RT_0 : case BGP_EXT_COM_RO_0 : case BGP_EXT_COM_L2VPN_RT_0 : ND_PRINT ( ( ndo , ":<S2SV_blank>%u:%u<S2SV_blank>(=<S2SV_blank>%s)" , EXTRACT_16BITS ( tptr + 2 ) , EXTRACT_32BITS ( tptr + 4 ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; break ; case BGP_EXT_COM_RT_1 : case BGP_EXT_COM_RO_1 : case BGP_EXT_COM_L2VPN_RT_1 : case BGP_EXT_COM_VRF_RT_IMP : ND_PRINT ( ( ndo , ":<S2SV_blank>%s:%u" , ipaddr_string ( ndo , tptr + 2 ) , EXTRACT_16BITS ( tptr + 6 ) ) ) ; break ; case BGP_EXT_COM_RT_2 : case BGP_EXT_COM_RO_2 : ND_PRINT ( ( ndo , ":<S2SV_blank>%s:%u" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr + 2 ) ) , EXTRACT_16BITS ( tptr + 6 ) ) ) ; break ; case BGP_EXT_COM_LINKBAND : bw . i = EXTRACT_32BITS ( tptr + 2 ) ; ND_PRINT ( ( ndo , ":<S2SV_blank>bandwidth:<S2SV_blank>%.3f<S2SV_blank>Mbps" , bw . f * 8 / 1000000 ) ) ; break ; case BGP_EXT_COM_VPN_ORIGIN : case BGP_EXT_COM_VPN_ORIGIN2 : case BGP_EXT_COM_VPN_ORIGIN3 : case BGP_EXT_COM_VPN_ORIGIN4 : case BGP_EXT_COM_OSPF_RID : case BGP_EXT_COM_OSPF_RID2 : ND_PRINT ( ( ndo , "%s" , ipaddr_string ( ndo , tptr + 2 ) ) ) ; break ; case BGP_EXT_COM_OSPF_RTYPE : case BGP_EXT_COM_OSPF_RTYPE2 : ND_PRINT ( ( ndo , ":<S2SV_blank>area:%s,<S2SV_blank>router-type:%s,<S2SV_blank>metric-type:%s%s" , ipaddr_string ( ndo , tptr + 2 ) , tok2str ( bgp_extd_comm_ospf_rtype_values , "unknown<S2SV_blank>(0x%02x)" , * ( tptr + 6 ) ) , ( * ( tptr + 7 ) & BGP_OSPF_RTYPE_METRIC_TYPE ) ? "E2" : "" , ( ( * ( tptr + 6 ) == BGP_OSPF_RTYPE_EXT ) || ( * ( tptr + 6 ) == BGP_OSPF_RTYPE_NSSA ) ) ? "E1" : "" ) ) ; break ; case BGP_EXT_COM_L2INFO : ND_PRINT ( ( ndo , ":<S2SV_blank>%s<S2SV_blank>Control<S2SV_blank>Flags<S2SV_blank>[0x%02x]:MTU<S2SV_blank>%u" , tok2str ( l2vpn_encaps_values , "unknown<S2SV_blank>encaps" , * ( tptr + 2 ) ) , * ( tptr + 3 ) , EXTRACT_16BITS ( tptr + 4 ) ) ) ; break ; case BGP_EXT_COM_SOURCE_AS : ND_PRINT ( ( ndo , ":<S2SV_blank>AS<S2SV_blank>%u" , EXTRACT_16BITS ( tptr + 2 ) ) ) ; break ; default : ND_TCHECK2 ( * tptr , 8 ) ; print_unknown_data ( ndo , tptr , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , 8 ) ; break ; } tlen -= 8 ; tptr += 8 ; } break ; case BGPTYPE_PMSI_TUNNEL : { uint8_t tunnel_type , flags ; ND_TCHECK2 ( tptr [ 0 ] , 5 ) ; tunnel_type = * ( tptr + 1 ) ; flags = * tptr ; tlen = len ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Tunnel-type<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>Flags<S2SV_blank>[%s],<S2SV_blank>MPLS<S2SV_blank>Label<S2SV_blank>%u" , tok2str ( bgp_pmsi_tunnel_values , "Unknown" , tunnel_type ) , tunnel_type , bittok2str ( bgp_pmsi_flag_values , "none" , flags ) , EXTRACT_24BITS ( tptr + 2 ) >> 4 ) ) ; tptr += 5 ; tlen -= 5 ; switch ( tunnel_type ) { case BGP_PMSI_TUNNEL_PIM_SM : case BGP_PMSI_TUNNEL_PIM_BIDIR : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Sender<S2SV_blank>%s,<S2SV_blank>P-Group<S2SV_blank>%s" , ipaddr_string ( ndo , tptr ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; break ; case BGP_PMSI_TUNNEL_PIM_SSM : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Root-Node<S2SV_blank>%s,<S2SV_blank>P-Group<S2SV_blank>%s" , ipaddr_string ( ndo , tptr ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; break ; case BGP_PMSI_TUNNEL_INGRESS : ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Tunnel-Endpoint<S2SV_blank>%s" , ipaddr_string ( ndo , tptr ) ) ) ; break ; case BGP_PMSI_TUNNEL_LDP_P2MP : case BGP_PMSI_TUNNEL_LDP_MP2MP : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Root-Node<S2SV_blank>%s,<S2SV_blank>LSP-ID<S2SV_blank>0x%08x" , ipaddr_string ( ndo , tptr ) , EXTRACT_32BITS ( tptr + 4 ) ) ) ; break ; case BGP_PMSI_TUNNEL_RSVP_P2MP : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Extended-Tunnel-ID<S2SV_blank>%s,<S2SV_blank>P2MP-ID<S2SV_blank>0x%08x" , ipaddr_string ( ndo , tptr ) , EXTRACT_32BITS ( tptr + 4 ) ) ) ; break ; default : if ( ndo -> ndo_vflag <= 1 ) { print_unknown_data ( ndo , tptr , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , tlen ) ; } } break ; } case BGPTYPE_AIGP : { uint8_t type ; uint16_t length ; tlen = len ; while ( tlen >= 3 ) { ND_TCHECK2 ( tptr [ 0 ] , 3 ) ; type = * tptr ; length = EXTRACT_16BITS ( tptr + 1 ) ; tptr += 3 ; tlen -= 3 ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>TLV<S2SV_blank>(%u),<S2SV_blank>length<S2SV_blank>%u" , tok2str ( bgp_aigp_values , "Unknown" , type ) , type , length ) ) ; if ( length < 3 ) goto trunc ; length -= 3 ; ND_TCHECK2 ( tptr [ 3 ] , length ) ; switch ( type ) { case BGP_AIGP_TLV : if ( length < 8 ) goto trunc ; ND_PRINT ( ( ndo , ",<S2SV_blank>metric<S2SV_blank>%" PRIu64 , EXTRACT_64BITS ( tptr ) ) ) ; break ; default : if ( ndo -> ndo_vflag <= 1 ) { print_unknown_data ( ndo , tptr , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , length ) ; } } tptr += length ; tlen -= length ; } break ; } case BGPTYPE_ATTR_SET : ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; if ( len < 4 ) goto trunc ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Origin<S2SV_blank>AS:<S2SV_blank>%s" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr ) ) ) ) ; tptr += 4 ; len -= 4 ; while ( len ) { u_int aflags , alenlen , alen ; ND_TCHECK2 ( tptr [ 0 ] , 2 ) ; if ( len < 2 ) goto trunc ; aflags = * tptr ; atype = * ( tptr + 1 ) ; tptr += 2 ; len -= 2 ; alenlen = bgp_attr_lenlen ( aflags , tptr ) ; ND_TCHECK2 ( tptr [ 0 ] , alenlen ) ; if ( len < alenlen ) goto trunc ; alen = bgp_attr_len ( aflags , tptr ) ; tptr += alenlen ; len -= alenlen ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>length:<S2SV_blank>%u" , tok2str ( bgp_attr_values , "Unknown<S2SV_blank>Attribute" , atype ) , atype , alen ) ) ; if ( aflags ) { ND_PRINT ( ( ndo , ",<S2SV_blank>Flags<S2SV_blank>[%s%s%s%s" , aflags & 0x80 ? "O" : "" , aflags & 0x40 ? "T" : "" , aflags & 0x20 ? "P" : "" , aflags & 0x10 ? "E" : "" ) ) ; if ( aflags & 0xf ) ND_PRINT ( ( ndo , "+%x" , aflags & 0xf ) ) ; ND_PRINT ( ( ndo , "]:<S2SV_blank>" ) ) ; } if ( ! bgp_attr_print ( ndo , atype , tptr , alen ) ) return 0 ; tptr += alen ; len -= alen ; } break ; case BGPTYPE_LARGE_COMMUNITY : if ( len == 0 || len % 12 ) { ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" ) ) ; while ( len > 0 ) { ND_TCHECK2 ( * tptr , 12 ) ; ND_PRINT ( ( ndo , "%u:%u:%u%s" , EXTRACT_32BITS ( tptr ) , EXTRACT_32BITS ( tptr + 4 ) , EXTRACT_32BITS ( tptr + 8 ) , ( len > 12 ) ? ",<S2SV_blank>" : "" ) ) ; tptr += 12 ; len -= 12 ; } break ; default : ND_TCHECK2 ( * pptr , len ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>no<S2SV_blank>Attribute<S2SV_blank>%u<S2SV_blank>decoder" , atype ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , pptr , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , len ) ; break ; } if ( ndo -> ndo_vflag > 1 && len ) { ND_TCHECK2 ( * pptr , len ) ; print_unknown_data ( ndo , pptr , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , len ) ; } return 1 ; trunc : return 0 ; }
CWE-125 void icmp_print ( netdissect_options * ndo , const u_char * bp , u_int plen , const u_char * bp2 , int fragmented ) { char * cp ; const struct icmp * dp ; const struct icmp_ext_t * ext_dp ; const struct ip * ip ; const char * str , * fmt ; const struct ip * oip ; const struct udphdr * ouh ; const uint8_t * obj_tptr ; uint32_t raw_label ; const u_char * snapend_save ; const struct icmp_mpls_ext_object_header_t * icmp_mpls_ext_object_header ; u_int hlen , dport , mtu , obj_tlen , obj_class_num , obj_ctype ; char buf [ MAXHOSTNAMELEN + 100 ] ; struct cksum_vec vec [ 1 ] ; dp = ( const struct icmp * ) bp ; ext_dp = ( const struct icmp_ext_t * ) bp ; ip = ( const struct ip * ) bp2 ; str = buf ; ND_TCHECK ( dp -> icmp_code ) ; switch ( dp -> icmp_type ) { case ICMP_ECHO : case ICMP_ECHOREPLY : ND_TCHECK ( dp -> icmp_seq ) ; ( void ) snprintf ( buf , sizeof ( buf ) , "echo<S2SV_blank>%s,<S2SV_blank>id<S2SV_blank>%u,<S2SV_blank>seq<S2SV_blank>%u" , dp -> icmp_type == ICMP_ECHO ? "request" : "reply" , EXTRACT_16BITS ( & dp -> icmp_id ) , EXTRACT_16BITS ( & dp -> icmp_seq ) ) ; break ; case ICMP_UNREACH : ND_TCHECK ( dp -> icmp_ip . ip_dst ) ; switch ( dp -> icmp_code ) { case ICMP_UNREACH_PROTOCOL : ND_TCHECK ( dp -> icmp_ip . ip_p ) ; ( void ) snprintf ( buf , sizeof ( buf ) , "%s<S2SV_blank>protocol<S2SV_blank>%d<S2SV_blank>unreachable" , ipaddr_string ( ndo , & dp -> icmp_ip . ip_dst ) , dp -> icmp_ip . ip_p ) ; break ; case ICMP_UNREACH_PORT : ND_TCHECK ( dp -> icmp_ip . ip_p ) ; oip = & dp -> icmp_ip ; hlen = IP_HL ( oip ) * 4 ; ouh = ( const struct udphdr * ) ( ( ( const u_char * ) oip ) + hlen ) ; ND_TCHECK ( ouh -> uh_dport ) ; dport = EXTRACT_16BITS ( & ouh -> uh_dport ) ; switch ( oip -> ip_p ) { case IPPROTO_TCP : ( void ) snprintf ( buf , sizeof ( buf ) , "%s<S2SV_blank>tcp<S2SV_blank>port<S2SV_blank>%s<S2SV_blank>unreachable" , ipaddr_string ( ndo , & oip -> ip_dst ) , tcpport_string ( ndo , dport ) ) ; break ; case IPPROTO_UDP : ( void ) snprintf ( buf , sizeof ( buf ) , "%s<S2SV_blank>udp<S2SV_blank>port<S2SV_blank>%s<S2SV_blank>unreachable" , ipaddr_string ( ndo , & oip -> ip_dst ) , udpport_string ( ndo , dport ) ) ; break ; default : ( void ) snprintf ( buf , sizeof ( buf ) , "%s<S2SV_blank>protocol<S2SV_blank>%u<S2SV_blank>port<S2SV_blank>%u<S2SV_blank>unreachable" , ipaddr_string ( ndo , & oip -> ip_dst ) , oip -> ip_p , dport ) ; break ; } break ; case ICMP_UNREACH_NEEDFRAG : { register const struct mtu_discovery * mp ; mp = ( const struct mtu_discovery * ) ( const u_char * ) & dp -> icmp_void ; mtu = EXTRACT_16BITS ( & mp -> nexthopmtu ) ; if ( mtu ) { ( void ) snprintf ( buf , sizeof ( buf ) , "%s<S2SV_blank>unreachable<S2SV_blank>-<S2SV_blank>need<S2SV_blank>to<S2SV_blank>frag<S2SV_blank>(mtu<S2SV_blank>%d)" , ipaddr_string ( ndo , & dp -> icmp_ip . ip_dst ) , mtu ) ; } else { ( void ) snprintf ( buf , sizeof ( buf ) , "%s<S2SV_blank>unreachable<S2SV_blank>-<S2SV_blank>need<S2SV_blank>to<S2SV_blank>frag" , ipaddr_string ( ndo , & dp -> icmp_ip . ip_dst ) ) ; } } break ; default : fmt = tok2str ( unreach2str , "#%d<S2SV_blank>%%s<S2SV_blank>unreachable" , dp -> icmp_code ) ; ( void ) snprintf ( buf , sizeof ( buf ) , fmt , ipaddr_string ( ndo , & dp -> icmp_ip . ip_dst ) ) ; break ; } break ; case ICMP_REDIRECT : ND_TCHECK ( dp -> icmp_ip . ip_dst ) ; fmt = tok2str ( type2str , "redirect-#%d<S2SV_blank>%%s<S2SV_blank>to<S2SV_blank>net<S2SV_blank>%%s" , dp -> icmp_code ) ; ( void ) snprintf ( buf , sizeof ( buf ) , fmt , ipaddr_string ( ndo , & dp -> icmp_ip . ip_dst ) , ipaddr_string ( ndo , & dp -> icmp_gwaddr ) ) ; break ; case ICMP_ROUTERADVERT : { register const struct ih_rdiscovery * ihp ; register const struct id_rdiscovery * idp ; u_int lifetime , num , size ; ( void ) snprintf ( buf , sizeof ( buf ) , "router<S2SV_blank>advertisement" ) ; cp = buf + strlen ( buf ) ; ihp = ( const struct ih_rdiscovery * ) & dp -> icmp_void ; ND_TCHECK ( * ihp ) ; ( void ) strncpy ( cp , "<S2SV_blank>lifetime<S2SV_blank>" , sizeof ( buf ) - ( cp - buf ) ) ; cp = buf + strlen ( buf ) ; lifetime = EXTRACT_16BITS ( & ihp -> ird_lifetime ) ; if ( lifetime < 60 ) { ( void ) snprintf ( cp , sizeof ( buf ) - ( cp - buf ) , "%u" , lifetime ) ; } else if ( lifetime < 60 * 60 ) { ( void ) snprintf ( cp , sizeof ( buf ) - ( cp - buf ) , "%u:%02u" , lifetime / 60 , lifetime % 60 ) ; } else { ( void ) snprintf ( cp , sizeof ( buf ) - ( cp - buf ) , "%u:%02u:%02u" , lifetime / 3600 , ( lifetime % 3600 ) / 60 , lifetime % 60 ) ; } cp = buf + strlen ( buf ) ; num = ihp -> ird_addrnum ; ( void ) snprintf ( cp , sizeof ( buf ) - ( cp - buf ) , "<S2SV_blank>%d:" , num ) ; cp = buf + strlen ( buf ) ; size = ihp -> ird_addrsiz ; if ( size != 2 ) { ( void ) snprintf ( cp , sizeof ( buf ) - ( cp - buf ) , "<S2SV_blank>[size<S2SV_blank>%d]" , size ) ; break ; } idp = ( const struct id_rdiscovery * ) & dp -> icmp_data ; while ( num -- > 0 ) { ND_TCHECK ( * idp ) ; ( void ) snprintf ( cp , sizeof ( buf ) - ( cp - buf ) , "<S2SV_blank>{%s<S2SV_blank>%u}" , ipaddr_string ( ndo , & idp -> ird_addr ) , EXTRACT_32BITS ( & idp -> ird_pref ) ) ; cp = buf + strlen ( buf ) ; ++ idp ; } } break ; case ICMP_TIMXCEED : ND_TCHECK ( dp -> icmp_ip . ip_dst ) ; switch ( dp -> icmp_code ) { case ICMP_TIMXCEED_INTRANS : str = "time<S2SV_blank>exceeded<S2SV_blank>in-transit" ; break ; case ICMP_TIMXCEED_REASS : str = "ip<S2SV_blank>reassembly<S2SV_blank>time<S2SV_blank>exceeded" ; break ; default : ( void ) snprintf ( buf , sizeof ( buf ) , "time<S2SV_blank>exceeded-#%u" , dp -> icmp_code ) ; break ; } break ; case ICMP_PARAMPROB : if ( dp -> icmp_code ) ( void ) snprintf ( buf , sizeof ( buf ) , "parameter<S2SV_blank>problem<S2SV_blank>-<S2SV_blank>code<S2SV_blank>%u" , dp -> icmp_code ) ; else { ND_TCHECK ( dp -> icmp_pptr ) ; ( void ) snprintf ( buf , sizeof ( buf ) , "parameter<S2SV_blank>problem<S2SV_blank>-<S2SV_blank>octet<S2SV_blank>%u" , dp -> icmp_pptr ) ; } break ; case ICMP_MASKREPLY : ND_TCHECK ( dp -> icmp_mask ) ; ( void ) snprintf ( buf , sizeof ( buf ) , "address<S2SV_blank>mask<S2SV_blank>is<S2SV_blank>0x%08x" , EXTRACT_32BITS ( & dp -> icmp_mask ) ) ; break ; case ICMP_TSTAMP : ND_TCHECK ( dp -> icmp_seq ) ; ( void ) snprintf ( buf , sizeof ( buf ) , "time<S2SV_blank>stamp<S2SV_blank>query<S2SV_blank>id<S2SV_blank>%u<S2SV_blank>seq<S2SV_blank>%u" , EXTRACT_16BITS ( & dp -> icmp_id ) , EXTRACT_16BITS ( & dp -> icmp_seq ) ) ; break ; case ICMP_TSTAMPREPLY : ND_TCHECK ( dp -> icmp_ttime ) ; ( void ) snprintf ( buf , sizeof ( buf ) , "time<S2SV_blank>stamp<S2SV_blank>reply<S2SV_blank>id<S2SV_blank>%u<S2SV_blank>seq<S2SV_blank>%u:<S2SV_blank>org<S2SV_blank>%s" , EXTRACT_16BITS ( & dp -> icmp_id ) , EXTRACT_16BITS ( & dp -> icmp_seq ) , icmp_tstamp_print ( EXTRACT_32BITS ( & dp -> icmp_otime ) ) ) ; ( void ) snprintf ( buf + strlen ( buf ) , sizeof ( buf ) - strlen ( buf ) , ",<S2SV_blank>recv<S2SV_blank>%s" , icmp_tstamp_print ( EXTRACT_32BITS ( & dp -> icmp_rtime ) ) ) ; ( void ) snprintf ( buf + strlen ( buf ) , sizeof ( buf ) - strlen ( buf ) , ",<S2SV_blank>xmit<S2SV_blank>%s" , icmp_tstamp_print ( EXTRACT_32BITS ( & dp -> icmp_ttime ) ) ) ; break ; default : str = tok2str ( icmp2str , "type-#%d" , dp -> icmp_type ) ; break ; } ND_PRINT ( ( ndo , "ICMP<S2SV_blank>%s,<S2SV_blank>length<S2SV_blank>%u" , str , plen ) ) ; if ( ndo -> ndo_vflag && ! fragmented ) { if ( ND_TTEST2 ( * bp , plen ) ) { uint16_t sum ; vec [ 0 ] . ptr = ( const uint8_t * ) ( const void * ) dp ; vec [ 0 ] . len = plen ; sum = in_cksum ( vec , 1 ) ; <S2SV_StartBug> if ( sum != 0 ) { <S2SV_EndBug> uint16_t icmp_sum = EXTRACT_16BITS ( & dp -> icmp_cksum ) ; ND_PRINT ( ( ndo , "<S2SV_blank>(wrong<S2SV_blank>icmp<S2SV_blank>cksum<S2SV_blank>%x<S2SV_blank>(->%x)!)" , icmp_sum , in_cksum_shouldbe ( icmp_sum , sum ) ) ) ; } } } if ( ndo -> ndo_vflag >= 1 && ICMP_ERRTYPE ( dp -> icmp_type ) ) { bp += 8 ; ND_PRINT ( ( ndo , "\\n\\t" ) ) ; ip = ( const struct ip * ) bp ; ndo -> ndo_snaplen = ndo -> ndo_snapend - bp ; snapend_save = ndo -> ndo_snapend ; ND_TCHECK_16BITS ( & ip -> ip_len ) ; ip_print ( ndo , bp , EXTRACT_16BITS ( & ip -> ip_len ) ) ; ndo -> ndo_snapend = snapend_save ; } if ( ndo -> ndo_vflag >= 1 && plen > ICMP_EXTD_MINLEN && ICMP_MPLS_EXT_TYPE ( dp -> icmp_type ) ) { ND_TCHECK ( * ext_dp ) ; if ( ! ext_dp -> icmp_length && ND_TTEST2 ( ext_dp -> icmp_ext_version_res , plen - ICMP_EXTD_MINLEN ) ) { vec [ 0 ] . ptr = ( const uint8_t * ) ( const void * ) & ext_dp -> icmp_ext_version_res ; vec [ 0 ] . len = plen - ICMP_EXTD_MINLEN ; if ( in_cksum ( vec , 1 ) ) { return ; } } ND_PRINT ( ( ndo , "\\n\\tMPLS<S2SV_blank>extension<S2SV_blank>v%u" , ICMP_MPLS_EXT_EXTRACT_VERSION ( * ( ext_dp -> icmp_ext_version_res ) ) ) ) ; if ( ICMP_MPLS_EXT_EXTRACT_VERSION ( * ( ext_dp -> icmp_ext_version_res ) ) != ICMP_MPLS_EXT_VERSION ) { ND_PRINT ( ( ndo , "<S2SV_blank>packet<S2SV_blank>not<S2SV_blank>supported" ) ) ; return ; } hlen = plen - ICMP_EXTD_MINLEN ; if ( ND_TTEST2 ( ext_dp -> icmp_ext_version_res , hlen ) ) { vec [ 0 ] . ptr = ( const uint8_t * ) ( const void * ) & ext_dp -> icmp_ext_version_res ; vec [ 0 ] . len = hlen ; ND_PRINT ( ( ndo , ",<S2SV_blank>checksum<S2SV_blank>0x%04x<S2SV_blank>(%scorrect),<S2SV_blank>length<S2SV_blank>%u" , EXTRACT_16BITS ( ext_dp -> icmp_ext_checksum ) , in_cksum ( vec , 1 ) ? "in" : "" , hlen ) ) ; } hlen -= 4 ; obj_tptr = ( const uint8_t * ) ext_dp -> icmp_ext_data ; while ( hlen > sizeof ( struct icmp_mpls_ext_object_header_t ) ) { icmp_mpls_ext_object_header = ( const struct icmp_mpls_ext_object_header_t * ) obj_tptr ; ND_TCHECK ( * icmp_mpls_ext_object_header ) ; obj_tlen = EXTRACT_16BITS ( icmp_mpls_ext_object_header -> length ) ; obj_class_num = icmp_mpls_ext_object_header -> class_num ; obj_ctype = icmp_mpls_ext_object_header -> ctype ; obj_tptr += sizeof ( struct icmp_mpls_ext_object_header_t ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Object<S2SV_blank>(%u),<S2SV_blank>Class-Type:<S2SV_blank>%u,<S2SV_blank>length<S2SV_blank>%u" , tok2str ( icmp_mpls_ext_obj_values , "unknown" , obj_class_num ) , obj_class_num , obj_ctype , obj_tlen ) ) ; hlen -= sizeof ( struct icmp_mpls_ext_object_header_t ) ; if ( ( obj_class_num == 0 ) || ( obj_tlen < sizeof ( struct icmp_mpls_ext_object_header_t ) ) ) { return ; } obj_tlen -= sizeof ( struct icmp_mpls_ext_object_header_t ) ; switch ( obj_class_num ) { case 1 : switch ( obj_ctype ) { case 1 : ND_TCHECK2 ( * obj_tptr , 4 ) ; raw_label = EXTRACT_32BITS ( obj_tptr ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>label<S2SV_blank>%u,<S2SV_blank>exp<S2SV_blank>%u" , MPLS_LABEL ( raw_label ) , MPLS_EXP ( raw_label ) ) ) ; if ( MPLS_STACK ( raw_label ) ) ND_PRINT ( ( ndo , ",<S2SV_blank>[S]" ) ) ; ND_PRINT ( ( ndo , ",<S2SV_blank>ttl<S2SV_blank>%u" , MPLS_TTL ( raw_label ) ) ) ; break ; default : print_unknown_data ( ndo , obj_tptr , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , obj_tlen ) ; } break ; case 2 : default : print_unknown_data ( ndo , obj_tptr , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , obj_tlen ) ; break ; } if ( hlen < obj_tlen ) break ; hlen -= obj_tlen ; obj_tptr += obj_tlen ; } } return ; trunc : ND_PRINT ( ( ndo , "[|icmp]" ) ) ; }
CWE-125 static int dccp_print_option ( netdissect_options * ndo , const u_char * option , u_int hlen ) { uint8_t optlen , i ; ND_TCHECK ( * option ) ; if ( * option >= 32 ) { ND_TCHECK ( * ( option + 1 ) ) ; optlen = * ( option + 1 ) ; if ( optlen < 2 ) { if ( * option >= 128 ) ND_PRINT ( ( ndo , "CCID<S2SV_blank>option<S2SV_blank>%u<S2SV_blank>optlen<S2SV_blank>too<S2SV_blank>short" , * option ) ) ; else ND_PRINT ( ( ndo , "%s<S2SV_blank>optlen<S2SV_blank>too<S2SV_blank>short" , tok2str ( dccp_option_values , "Option<S2SV_blank>%u" , * option ) ) ) ; return 0 ; } } else optlen = 1 ; if ( hlen < optlen ) { if ( * option >= 128 ) ND_PRINT ( ( ndo , "CCID<S2SV_blank>option<S2SV_blank>%u<S2SV_blank>optlen<S2SV_blank>goes<S2SV_blank>past<S2SV_blank>header<S2SV_blank>length" , * option ) ) ; else ND_PRINT ( ( ndo , "%s<S2SV_blank>optlen<S2SV_blank>goes<S2SV_blank>past<S2SV_blank>header<S2SV_blank>length" , tok2str ( dccp_option_values , "Option<S2SV_blank>%u" , * option ) ) ) ; return 0 ; } ND_TCHECK2 ( * option , optlen ) ; if ( * option >= 128 ) { ND_PRINT ( ( ndo , "CCID<S2SV_blank>option<S2SV_blank>%d" , * option ) ) ; switch ( optlen ) { case 4 : ND_PRINT ( ( ndo , "<S2SV_blank>%u" , EXTRACT_16BITS ( option + 2 ) ) ) ; break ; case 6 : ND_PRINT ( ( ndo , "<S2SV_blank>%u" , EXTRACT_32BITS ( option + 2 ) ) ) ; break ; default : break ; } } else { ND_PRINT ( ( ndo , "%s" , tok2str ( dccp_option_values , "Option<S2SV_blank>%u" , * option ) ) ) ; switch ( * option ) { case 32 : case 33 : case 34 : case 35 : if ( optlen < 3 ) { ND_PRINT ( ( ndo , "<S2SV_blank>optlen<S2SV_blank>too<S2SV_blank>short" ) ) ; return optlen ; } if ( * ( option + 2 ) < 10 ) { ND_PRINT ( ( ndo , "<S2SV_blank>%s" , dccp_feature_nums [ * ( option + 2 ) ] ) ) ; for ( i = 0 ; i < optlen - 3 ; i ++ ) ND_PRINT ( ( ndo , "<S2SV_blank>%d" , * ( option + 3 + i ) ) ) ; } break ; case 36 : if ( optlen > 2 ) { ND_PRINT ( ( ndo , "<S2SV_blank>0x" ) ) ; for ( i = 0 ; i < optlen - 2 ; i ++ ) ND_PRINT ( ( ndo , "%02x" , * ( option + 2 + i ) ) ) ; } break ; case 37 : for ( i = 0 ; i < optlen - 2 ; i ++ ) ND_PRINT ( ( ndo , "<S2SV_blank>%d" , * ( option + 2 + i ) ) ) ; break ; case 38 : if ( optlen > 2 ) { ND_PRINT ( ( ndo , "<S2SV_blank>0x" ) ) ; for ( i = 0 ; i < optlen - 2 ; i ++ ) ND_PRINT ( ( ndo , "%02x" , * ( option + 2 + i ) ) ) ; } break ; case 39 : if ( optlen > 2 ) { ND_PRINT ( ( ndo , "<S2SV_blank>0x" ) ) ; for ( i = 0 ; i < optlen - 2 ; i ++ ) ND_PRINT ( ( ndo , "%02x" , * ( option + 2 + i ) ) ) ; } break ; case 40 : if ( optlen > 2 ) { ND_PRINT ( ( ndo , "<S2SV_blank>0x" ) ) ; for ( i = 0 ; i < optlen - 2 ; i ++ ) ND_PRINT ( ( ndo , "%02x" , * ( option + 2 + i ) ) ) ; } break ; case 41 : <S2SV_StartBug> if ( optlen == 4 ) <S2SV_EndBug> ND_PRINT ( ( ndo , "<S2SV_blank>%u" , EXTRACT_32BITS ( option + 2 ) ) ) ; else <S2SV_StartBug> ND_PRINT ( ( ndo , "<S2SV_blank>optlen<S2SV_blank>!=<S2SV_blank>4" ) ) ; <S2SV_EndBug> break ; case 42 : <S2SV_StartBug> if ( optlen == 4 ) <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , "<S2SV_blank>%u" , EXTRACT_32BITS ( option + 2 ) ) ) ; <S2SV_EndBug> else <S2SV_StartBug> ND_PRINT ( ( ndo , "<S2SV_blank>optlen<S2SV_blank>!=<S2SV_blank>4" ) ) ; <S2SV_EndBug> break ; case 43 : if ( optlen == 6 ) ND_PRINT ( ( ndo , "<S2SV_blank>%u" , EXTRACT_32BITS ( option + 2 ) ) ) ; else if ( optlen == 4 ) ND_PRINT ( ( ndo , "<S2SV_blank>%u" , EXTRACT_16BITS ( option + 2 ) ) ) ; else ND_PRINT ( ( ndo , "<S2SV_blank>optlen<S2SV_blank>!=<S2SV_blank>4<S2SV_blank>or<S2SV_blank>6" ) ) ; break ; case 44 : if ( optlen > 2 ) { ND_PRINT ( ( ndo , "<S2SV_blank>" ) ) ; for ( i = 0 ; i < optlen - 2 ; i ++ ) ND_PRINT ( ( ndo , "%02x" , * ( option + 2 + i ) ) ) ; } break ; } } return optlen ; trunc : ND_PRINT ( ( ndo , "%s" , tstr ) ) ; return 0 ; }
CWE-674 const u_char * smb_fdata ( netdissect_options * ndo , const u_char * buf , const char * fmt , const u_char * maxbuf , int unicodestr ) { static int depth = 0 ; char s [ 128 ] ; char * p ; while ( * fmt ) { switch ( * fmt ) { case '*' : fmt ++ ; while ( buf < maxbuf ) { const u_char * buf2 ; depth ++ ; <S2SV_StartBug> buf2 = smb_fdata ( ndo , buf , fmt , maxbuf , unicodestr ) ; <S2SV_EndBug> depth -- ; if ( buf2 == NULL ) return ( NULL ) ; if ( buf2 == buf ) return ( buf ) ; buf = buf2 ; } return ( buf ) ; case '|' : fmt ++ ; if ( buf >= maxbuf ) return ( buf ) ; break ; case '%' : fmt ++ ; buf = maxbuf ; break ; case '#' : fmt ++ ; return ( buf ) ; break ; case '[' : fmt ++ ; if ( buf >= maxbuf ) return ( buf ) ; memset ( s , 0 , sizeof ( s ) ) ; p = strchr ( fmt , ']' ) ; if ( ( size_t ) ( p - fmt + 1 ) > sizeof ( s ) ) { return ( buf ) ; } strncpy ( s , fmt , p - fmt ) ; s [ p - fmt ] = '\\0' ; fmt = p + 1 ; buf = smb_fdata1 ( ndo , buf , s , maxbuf , unicodestr ) ; if ( buf == NULL ) return ( NULL ) ; break ; default : ND_PRINT ( ( ndo , "%c" , * fmt ) ) ; fmt ++ ; break ; } } if ( ! depth && buf < maxbuf ) { size_t len = PTR_DIFF ( maxbuf , buf ) ; ND_PRINT ( ( ndo , "Data:<S2SV_blank>(%lu<S2SV_blank>bytes)\\n" , ( unsigned long ) len ) ) ; smb_print_data ( ndo , buf , len ) ; return ( buf + len ) ; } return ( buf ) ; }
CWE-125 static const u_char * ikev1_n_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi0 _U_ , uint32_t proto0 _U_ , int depth _U_ ) { const struct ikev1_pl_n * p ; struct ikev1_pl_n n ; const u_char * cp ; const u_char * ep2 ; uint32_t doi ; uint32_t proto ; static const char * notify_error_str [ ] = { NULL , "INVALID-PAYLOAD-TYPE" , "DOI-NOT-SUPPORTED" , "SITUATION-NOT-SUPPORTED" , "INVALID-COOKIE" , "INVALID-MAJOR-VERSION" , "INVALID-MINOR-VERSION" , "INVALID-EXCHANGE-TYPE" , "INVALID-FLAGS" , "INVALID-MESSAGE-ID" , "INVALID-PROTOCOL-ID" , "INVALID-SPI" , "INVALID-TRANSFORM-ID" , "ATTRIBUTES-NOT-SUPPORTED" , "NO-PROPOSAL-CHOSEN" , "BAD-PROPOSAL-SYNTAX" , "PAYLOAD-MALFORMED" , "INVALID-KEY-INFORMATION" , "INVALID-ID-INFORMATION" , "INVALID-CERT-ENCODING" , "INVALID-CERTIFICATE" , "CERT-TYPE-UNSUPPORTED" , "INVALID-CERT-AUTHORITY" , "INVALID-HASH-INFORMATION" , "AUTHENTICATION-FAILED" , "INVALID-SIGNATURE" , "ADDRESS-NOTIFICATION" , "NOTIFY-SA-LIFETIME" , "CERTIFICATE-UNAVAILABLE" , "UNSUPPORTED-EXCHANGE-TYPE" , "UNEQUAL-PAYLOAD-LENGTHS" , } ; static const char * ipsec_notify_error_str [ ] = { "RESERVED" , } ; static const char * notify_status_str [ ] = { "CONNECTED" , } ; static const char * ipsec_notify_status_str [ ] = { "RESPONDER-LIFETIME" , "REPLAY-STATUS" , "INITIAL-CONTACT" , } ; # define NOTIFY_ERROR_STR ( x ) STR_OR_ID ( ( x ) , notify_error_str ) # define IPSEC_NOTIFY_ERROR_STR ( x ) STR_OR_ID ( ( u_int ) ( ( x ) - 8192 ) , ipsec_notify_error_str ) # define NOTIFY_STATUS_STR ( x ) STR_OR_ID ( ( u_int ) ( ( x ) - 16384 ) , notify_status_str ) # define IPSEC_NOTIFY_STATUS_STR ( x ) STR_OR_ID ( ( u_int ) ( ( x ) - 24576 ) , ipsec_notify_status_str ) ND_PRINT ( ( ndo , "%s:" , NPSTR ( ISAKMP_NPTYPE_N ) ) ) ; p = ( const struct ikev1_pl_n * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & n , ext , sizeof ( n ) ) ; doi = ntohl ( n . doi ) ; proto = n . prot_id ; if ( doi != 1 ) { ND_PRINT ( ( ndo , "<S2SV_blank>doi=%d" , doi ) ) ; ND_PRINT ( ( ndo , "<S2SV_blank>proto=%d" , proto ) ) ; if ( ntohs ( n . type ) < 8192 ) ND_PRINT ( ( ndo , "<S2SV_blank>type=%s" , NOTIFY_ERROR_STR ( ntohs ( n . type ) ) ) ) ; else if ( ntohs ( n . type ) < 16384 ) ND_PRINT ( ( ndo , "<S2SV_blank>type=%s" , numstr ( ntohs ( n . type ) ) ) ) ; else if ( ntohs ( n . type ) < 24576 ) ND_PRINT ( ( ndo , "<S2SV_blank>type=%s" , NOTIFY_STATUS_STR ( ntohs ( n . type ) ) ) ) ; else ND_PRINT ( ( ndo , "<S2SV_blank>type=%s" , numstr ( ntohs ( n . type ) ) ) ) ; if ( n . spi_size ) { ND_PRINT ( ( ndo , "<S2SV_blank>spi=" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( p + 1 ) , n . spi_size ) ) goto trunc ; } return ( const u_char * ) ( p + 1 ) + n . spi_size ; } ND_PRINT ( ( ndo , "<S2SV_blank>doi=ipsec" ) ) ; ND_PRINT ( ( ndo , "<S2SV_blank>proto=%s" , PROTOIDSTR ( proto ) ) ) ; if ( ntohs ( n . type ) < 8192 ) ND_PRINT ( ( ndo , "<S2SV_blank>type=%s" , NOTIFY_ERROR_STR ( ntohs ( n . type ) ) ) ) ; else if ( ntohs ( n . type ) < 16384 ) ND_PRINT ( ( ndo , "<S2SV_blank>type=%s" , IPSEC_NOTIFY_ERROR_STR ( ntohs ( n . type ) ) ) ) ; else if ( ntohs ( n . type ) < 24576 ) ND_PRINT ( ( ndo , "<S2SV_blank>type=%s" , NOTIFY_STATUS_STR ( ntohs ( n . type ) ) ) ) ; else if ( ntohs ( n . type ) < 32768 ) ND_PRINT ( ( ndo , "<S2SV_blank>type=%s" , IPSEC_NOTIFY_STATUS_STR ( ntohs ( n . type ) ) ) ) ; else ND_PRINT ( ( ndo , "<S2SV_blank>type=%s" , numstr ( ntohs ( n . type ) ) ) ) ; if ( n . spi_size ) { ND_PRINT ( ( ndo , "<S2SV_blank>spi=" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( p + 1 ) , n . spi_size ) ) goto trunc ; } cp = ( const u_char * ) ( p + 1 ) + n . spi_size ; ep2 = ( const u_char * ) p + item_len ; if ( cp < ep ) { switch ( ntohs ( n . type ) ) { case IPSECDOI_NTYPE_RESPONDER_LIFETIME : { const struct attrmap * map = oakley_t_map ; size_t nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; ND_PRINT ( ( ndo , "<S2SV_blank>attrs=(" ) ) ; while ( cp < ep && cp < ep2 ) { cp = ikev1_attrmap_print ( ndo , cp , ep2 , map , nmap ) ; if ( cp == NULL ) { ND_PRINT ( ( ndo , ")" ) ) ; goto trunc ; } } ND_PRINT ( ( ndo , ")" ) ) ; break ; } case IPSECDOI_NTYPE_REPLAY_STATUS : ND_PRINT ( ( ndo , "<S2SV_blank>status=(" ) ) ; <S2SV_StartBug> ND_PRINT ( ( ndo , "replay<S2SV_blank>detection<S2SV_blank>%sabled" , <S2SV_EndBug> EXTRACT_32BITS ( cp ) ? "en" : "dis" ) ) ; ND_PRINT ( ( ndo , ")" ) ) ; break ; default : if ( ndo -> ndo_vflag > 3 ) { ND_PRINT ( ( ndo , "<S2SV_blank>data=(" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( cp ) , ep - cp ) ) goto trunc ; ND_PRINT ( ( ndo , ")" ) ) ; } else { if ( ! ike_show_somedata ( ndo , cp , ep ) ) goto trunc ; } break ; } } return ( const u_char * ) ext + item_len ; trunc : ND_PRINT ( ( ndo , "<S2SV_blank>[|%s]" , NPSTR ( ISAKMP_NPTYPE_N ) ) ) ; return NULL ; }
CWE-125 void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , "unknown<S2SV_blank>type<S2SV_blank>(%u)" , type ) ; ND_PRINT ( ( ndo , "VRRPv%u,<S2SV_blank>%s" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , ",<S2SV_blank>(ttl<S2SV_blank>%u)" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , ",<S2SV_blank>vrid<S2SV_blank>%u,<S2SV_blank>prio<S2SV_blank>%u" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , ",<S2SV_blank>authtype<S2SV_blank>%s" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , ",<S2SV_blank>intvl<S2SV_blank>%us,<S2SV_blank>length<S2SV_blank>%u" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , ",<S2SV_blank>intvl<S2SV_blank>%ucs,<S2SV_blank>length<S2SV_blank>%u" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 && ND_TTEST2 ( bp [ 0 ] , len ) ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; <S2SV_StartBug> if ( in_cksum ( vec , 1 ) ) <S2SV_EndBug> ND_PRINT ( ( ndo , ",<S2SV_blank>(bad<S2SV_blank>vrrp<S2SV_blank>cksum<S2SV_blank>%x)" , <S2SV_StartBug> EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; <S2SV_EndBug> } if ( version == 3 && ND_TTEST2 ( bp [ 0 ] , len ) ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , ",<S2SV_blank>(bad<S2SV_blank>vrrp<S2SV_blank>cksum<S2SV_blank>%x)" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } ND_PRINT ( ( ndo , ",<S2SV_blank>addrs" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , "(%d)" , naddrs ) ) ; ND_PRINT ( ( ndo , ":" ) ) ; c = '<S2SV_blank>' ; bp += 8 ; for ( i = 0 ; i < naddrs ; i ++ ) { ND_TCHECK ( bp [ 3 ] ) ; ND_PRINT ( ( ndo , "%c%s" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { ND_TCHECK ( bp [ 7 ] ) ; ND_PRINT ( ( ndo , "<S2SV_blank>auth<S2SV_blank>\\"" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , "\\"" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , "\\"" ) ) ; } } return ; trunc : ND_PRINT ( ( ndo , "[|vrrp]" ) ) ; }
CWE-125 static u_int ieee802_11_print ( netdissect_options * ndo , const u_char * p , u_int length , u_int orig_caplen , int pad , u_int fcslen ) { uint16_t fc ; u_int caplen , hdrlen , meshdrlen ; struct lladdr_info src , dst ; int llc_hdrlen ; caplen = orig_caplen ; if ( length < fcslen ) { ND_PRINT ( ( ndo , "%s" , tstr ) ) ; return caplen ; } length -= fcslen ; if ( caplen > length ) { fcslen = caplen - length ; caplen -= fcslen ; ndo -> ndo_snapend -= fcslen ; } if ( caplen < IEEE802_11_FC_LEN ) { ND_PRINT ( ( ndo , "%s" , tstr ) ) ; return orig_caplen ; } fc = EXTRACT_LE_16BITS ( p ) ; hdrlen = extract_header_length ( ndo , fc ) ; if ( hdrlen == 0 ) { return ( 0 ) ; } if ( pad ) hdrlen = roundup2 ( hdrlen , 4 ) ; if ( ndo -> ndo_Hflag && FC_TYPE ( fc ) == T_DATA && DATA_FRAME_IS_QOS ( FC_SUBTYPE ( fc ) ) ) { <S2SV_StartBug> meshdrlen = extract_mesh_header_length ( p + hdrlen ) ; <S2SV_EndBug> hdrlen += meshdrlen ; } else meshdrlen = 0 ; if ( caplen < hdrlen ) { ND_PRINT ( ( ndo , "%s" , tstr ) ) ; return hdrlen ; } if ( ndo -> ndo_eflag ) ieee_802_11_hdr_print ( ndo , fc , p , hdrlen , meshdrlen ) ; length -= hdrlen ; caplen -= hdrlen ; p += hdrlen ; src . addr_string = etheraddr_string ; dst . addr_string = etheraddr_string ; switch ( FC_TYPE ( fc ) ) { case T_MGMT : get_mgmt_src_dst_mac ( p - hdrlen , & src . addr , & dst . addr ) ; if ( ! mgmt_body_print ( ndo , fc , src . addr , p , length ) ) { ND_PRINT ( ( ndo , "%s" , tstr ) ) ; return hdrlen ; } break ; case T_CTRL : if ( ! ctrl_body_print ( ndo , fc , p - hdrlen ) ) { ND_PRINT ( ( ndo , "%s" , tstr ) ) ; return hdrlen ; } break ; case T_DATA : if ( DATA_FRAME_IS_NULL ( FC_SUBTYPE ( fc ) ) ) return hdrlen ; if ( FC_PROTECTED ( fc ) ) { ND_PRINT ( ( ndo , "Data" ) ) ; if ( ! wep_print ( ndo , p ) ) { ND_PRINT ( ( ndo , "%s" , tstr ) ) ; return hdrlen ; } } else { get_data_src_dst_mac ( fc , p - hdrlen , & src . addr , & dst . addr ) ; llc_hdrlen = llc_print ( ndo , p , length , caplen , & src , & dst ) ; if ( llc_hdrlen < 0 ) { if ( ! ndo -> ndo_suppress_default_print ) ND_DEFAULTPRINT ( p , caplen ) ; llc_hdrlen = - llc_hdrlen ; } hdrlen += llc_hdrlen ; } break ; default : break ; } return hdrlen ; }
CWE-125 static int print_prefix ( netdissect_options * ndo , const u_char * prefix , u_int max_length ) { int plenbytes ; char buf [ sizeof ( "xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx::/128" ) ] ; if ( prefix [ 0 ] >= 96 && max_length >= IPV4_MAPPED_HEADING_LEN + 1 && is_ipv4_mapped_address ( & prefix [ 1 ] ) ) { struct in_addr addr ; u_int plen ; plen = prefix [ 0 ] - 96 ; if ( 32 < plen ) return - 1 ; max_length -= 1 ; memset ( & addr , 0 , sizeof ( addr ) ) ; plenbytes = ( plen + 7 ) / 8 ; if ( max_length < ( u_int ) plenbytes + IPV4_MAPPED_HEADING_LEN ) return - 3 ; memcpy ( & addr , & prefix [ 1 + IPV4_MAPPED_HEADING_LEN ] , plenbytes ) ; if ( plen % 8 ) { ( ( u_char * ) & addr ) [ plenbytes - 1 ] &= ( ( 0xff00 >> ( plen % 8 ) ) & 0xff ) ; } snprintf ( buf , sizeof ( buf ) , "%s/%d" , ipaddr_string ( ndo , & addr ) , plen ) ; plenbytes += 1 + IPV4_MAPPED_HEADING_LEN ; } else { plenbytes = decode_prefix6 ( ndo , prefix , max_length , buf , sizeof ( buf ) ) ; <S2SV_StartBug> } <S2SV_EndBug> ND_PRINT ( ( ndo , "%s" , buf ) ) ; return plenbytes ; }
CWE-125 static void bgp_capabilities_print ( netdissect_options * ndo , const u_char * opt , int caps_len ) { int cap_type , cap_len , tcap_len , cap_offset ; int i = 0 ; while ( i < caps_len ) { ND_TCHECK2 ( opt [ i ] , BGP_CAP_HEADER_SIZE ) ; cap_type = opt [ i ] ; cap_len = opt [ i + 1 ] ; tcap_len = cap_len ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>length:<S2SV_blank>%u" , tok2str ( bgp_capcode_values , "Unknown" , cap_type ) , cap_type , cap_len ) ) ; ND_TCHECK2 ( opt [ i + 2 ] , cap_len ) ; switch ( cap_type ) { case BGP_CAPCODE_MP : ND_PRINT ( ( ndo , "\\n\\t\\tAFI<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>SAFI<S2SV_blank>%s<S2SV_blank>(%u)" , tok2str ( af_values , "Unknown" , EXTRACT_16BITS ( opt + i + 2 ) ) , EXTRACT_16BITS ( opt + i + 2 ) , tok2str ( bgp_safi_values , "Unknown" , opt [ i + 5 ] ) , opt [ i + 5 ] ) ) ; break ; <S2SV_StartBug> case BGP_CAPCODE_RESTART : <S2SV_EndBug> ND_PRINT ( ( ndo , "\\n\\t\\tRestart<S2SV_blank>Flags:<S2SV_blank>[%s],<S2SV_blank>Restart<S2SV_blank>Time<S2SV_blank>%us" , ( ( opt [ i + 2 ] ) & 0x80 ) ? "R" : "none" , EXTRACT_16BITS ( opt + i + 2 ) & 0xfff ) ) ; tcap_len -= 2 ; cap_offset = 4 ; while ( tcap_len >= 4 ) { ND_PRINT ( ( ndo , "\\n\\t\\t<S2SV_blank><S2SV_blank>AFI<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>SAFI<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>Forwarding<S2SV_blank>state<S2SV_blank>preserved:<S2SV_blank>%s" , tok2str ( af_values , "Unknown" , EXTRACT_16BITS ( opt + i + cap_offset ) ) , EXTRACT_16BITS ( opt + i + cap_offset ) , tok2str ( bgp_safi_values , "Unknown" , opt [ i + cap_offset + 2 ] ) , opt [ i + cap_offset + 2 ] , ( ( opt [ i + cap_offset + 3 ] ) & 0x80 ) ? "yes" : "no" ) ) ; tcap_len -= 4 ; cap_offset += 4 ; } break ; case BGP_CAPCODE_RR : case BGP_CAPCODE_RR_CISCO : break ; case BGP_CAPCODE_AS_NEW : if ( cap_len == 4 ) { ND_PRINT ( ( ndo , "\\n\\t\\t<S2SV_blank>4<S2SV_blank>Byte<S2SV_blank>AS<S2SV_blank>%s" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( opt + i + 2 ) ) ) ) ; } break ; case BGP_CAPCODE_ADD_PATH : cap_offset = 2 ; if ( tcap_len == 0 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(bogus)" ) ) ; break ; } while ( tcap_len > 0 ) { if ( tcap_len < 4 ) { ND_PRINT ( ( ndo , "\\n\\t\\t(invalid)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t\\tAFI<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>SAFI<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>Send/Receive:<S2SV_blank>%s" , tok2str ( af_values , "Unknown" , EXTRACT_16BITS ( opt + i + cap_offset ) ) , EXTRACT_16BITS ( opt + i + cap_offset ) , tok2str ( bgp_safi_values , "Unknown" , opt [ i + cap_offset + 2 ] ) , opt [ i + cap_offset + 2 ] , tok2str ( bgp_add_path_recvsend , "Bogus<S2SV_blank>(0x%02x)" , opt [ i + cap_offset + 3 ] ) ) ) ; tcap_len -= 4 ; cap_offset += 4 ; } break ; default : ND_PRINT ( ( ndo , "\\n\\t\\tno<S2SV_blank>decoder<S2SV_blank>for<S2SV_blank>Capability<S2SV_blank>%u" , cap_type ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , & opt [ i + 2 ] , "\\n\\t\\t" , cap_len ) ; break ; } if ( ndo -> ndo_vflag > 1 && cap_len > 0 ) { print_unknown_data ( ndo , & opt [ i + 2 ] , "\\n\\t\\t" , cap_len ) ; } i += BGP_CAP_HEADER_SIZE + cap_len ; } return ; trunc : ND_PRINT ( ( ndo , "[|BGP]" ) ) ; }
CWE-125 static void print_trans ( netdissect_options * ndo , const u_char * words , const u_char * data1 , const u_char * buf , const u_char * maxbuf ) { u_int bcc ; const char * f1 , * f2 , * f3 , * f4 ; const u_char * data , * param ; const u_char * w = words + 1 ; int datalen , paramlen ; if ( request ) { ND_TCHECK2 ( w [ 12 * 2 ] , 2 ) ; paramlen = EXTRACT_LE_16BITS ( w + 9 * 2 ) ; param = buf + EXTRACT_LE_16BITS ( w + 10 * 2 ) ; datalen = EXTRACT_LE_16BITS ( w + 11 * 2 ) ; data = buf + EXTRACT_LE_16BITS ( w + 12 * 2 ) ; f1 = "TotParamCnt=[d]<S2SV_blank>\\nTotDataCnt=[d]<S2SV_blank>\\nMaxParmCnt=[d]<S2SV_blank>\\nMaxDataCnt=[d]\\nMaxSCnt=[d]<S2SV_blank>\\nTransFlags=[w]<S2SV_blank>\\nRes1=[w]<S2SV_blank>\\nRes2=[w]<S2SV_blank>\\nRes3=[w]\\nParamCnt=[d]<S2SV_blank>\\nParamOff=[d]<S2SV_blank>\\nDataCnt=[d]<S2SV_blank>\\nDataOff=[d]<S2SV_blank>\\nSUCnt=[d]\\n" ; f2 = "|Name=[S]\\n" ; f3 = "|Param<S2SV_blank>" ; f4 = "|Data<S2SV_blank>" ; } else { ND_TCHECK2 ( w [ 7 * 2 ] , 2 ) ; paramlen = EXTRACT_LE_16BITS ( w + 3 * 2 ) ; param = buf + EXTRACT_LE_16BITS ( w + 4 * 2 ) ; datalen = EXTRACT_LE_16BITS ( w + 6 * 2 ) ; data = buf + EXTRACT_LE_16BITS ( w + 7 * 2 ) ; f1 = "TotParamCnt=[d]<S2SV_blank>\\nTotDataCnt=[d]<S2SV_blank>\\nRes1=[d]\\nParamCnt=[d]<S2SV_blank>\\nParamOff=[d]<S2SV_blank>\\nRes2=[d]<S2SV_blank>\\nDataCnt=[d]<S2SV_blank>\\nDataOff=[d]<S2SV_blank>\\nRes3=[d]\\nLsetup=[d]\\n" ; f2 = "|Unknown<S2SV_blank>" ; f3 = "|Param<S2SV_blank>" ; f4 = "|Data<S2SV_blank>" ; } smb_fdata ( ndo , words + 1 , f1 , min ( words + 1 + 2 * words [ 0 ] , maxbuf ) , unicodestr ) ; ND_TCHECK2 ( * data1 , 2 ) ; bcc = EXTRACT_LE_16BITS ( data1 ) ; ND_PRINT ( ( ndo , "smb_bcc=%u\\n" , bcc ) ) ; if ( bcc > 0 ) { smb_fdata ( ndo , data1 + 2 , f2 , maxbuf - ( paramlen + datalen ) , unicodestr ) ; <S2SV_StartBug> if ( strcmp ( ( const char * ) ( data1 + 2 ) , "\\\\MAILSLOT\\\\BROWSE" ) == 0 ) { <S2SV_EndBug> print_browse ( ndo , param , paramlen , data , datalen ) ; return ; } <S2SV_StartBug> if ( strcmp ( ( const char * ) ( data1 + 2 ) , "\\\\PIPE\\\\LANMAN" ) == 0 ) { <S2SV_EndBug> print_ipc ( ndo , param , paramlen , data , datalen ) ; return ; } <S2SV_StartBug> if ( paramlen ) <S2SV_EndBug> smb_fdata ( ndo , param , f3 , min ( param + paramlen , maxbuf ) , unicodestr ) ; if ( datalen ) smb_fdata ( ndo , data , f4 , min ( data + datalen , maxbuf ) , unicodestr ) ; } return ; trunc : ND_PRINT ( ( ndo , "%s" , tstr ) ) ; }
CWE-120 static char * get_next_file ( FILE * VFile , char * ptr ) { <S2SV_StartBug> char * ret ; <S2SV_EndBug> ret = fgets ( ptr , PATH_MAX , VFile ) ; if ( ! ret ) return NULL ; <S2SV_StartBug> if ( ptr [ strlen ( ptr ) - 1 ] == '\\n' ) <S2SV_EndBug> <S2SV_StartBug> ptr [ strlen ( ptr ) - 1 ] = '\\0' ; <S2SV_EndBug> return ret ; }
CWE-125 u_int mfr_print ( netdissect_options * ndo , register const u_char * p , u_int length ) { u_int tlen , idx , hdr_len = 0 ; uint16_t sequence_num ; uint8_t ie_type , ie_len ; const uint8_t * tptr ; ND_TCHECK2 ( * p , 4 ) ; if ( ( p [ 0 ] & MFR_BEC_MASK ) == MFR_CTRL_FRAME && p [ 1 ] == 0 ) { ND_PRINT ( ( ndo , "FRF.16<S2SV_blank>Control,<S2SV_blank>Flags<S2SV_blank>[%s],<S2SV_blank>%s,<S2SV_blank>length<S2SV_blank>%u" , bittok2str ( frf_flag_values , "none" , ( p [ 0 ] & MFR_BEC_MASK ) ) , tok2str ( mfr_ctrl_msg_values , "Unknown<S2SV_blank>Message<S2SV_blank>(0x%02x)" , p [ 2 ] ) , length ) ) ; tptr = p + 3 ; tlen = length - 3 ; hdr_len = 3 ; if ( ! ndo -> ndo_vflag ) return hdr_len ; while ( tlen > sizeof ( struct ie_tlv_header_t ) ) { ND_TCHECK2 ( * tptr , sizeof ( struct ie_tlv_header_t ) ) ; ie_type = tptr [ 0 ] ; ie_len = tptr [ 1 ] ; ND_PRINT ( ( ndo , "\\n\\tIE<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>length<S2SV_blank>%u:<S2SV_blank>" , tok2str ( mfr_ctrl_ie_values , "Unknown" , ie_type ) , ie_type , ie_len ) ) ; if ( ie_type == 0 || ie_len <= sizeof ( struct ie_tlv_header_t ) ) return hdr_len ; ND_TCHECK2 ( * tptr , ie_len ) ; tptr += sizeof ( struct ie_tlv_header_t ) ; ie_len -= sizeof ( struct ie_tlv_header_t ) ; tlen -= sizeof ( struct ie_tlv_header_t ) ; switch ( ie_type ) { <S2SV_StartBug> case MFR_CTRL_IE_MAGIC_NUM : <S2SV_EndBug> ND_PRINT ( ( ndo , "0x%08x" , EXTRACT_32BITS ( tptr ) ) ) ; break ; case MFR_CTRL_IE_BUNDLE_ID : case MFR_CTRL_IE_LINK_ID : for ( idx = 0 ; idx < ie_len && idx < MFR_ID_STRING_MAXLEN ; idx ++ ) { if ( * ( tptr + idx ) != 0 ) safeputchar ( ndo , * ( tptr + idx ) ) ; else break ; } break ; case MFR_CTRL_IE_TIMESTAMP : if ( ie_len == sizeof ( struct timeval ) ) { ts_print ( ndo , ( const struct timeval * ) tptr ) ; break ; } case MFR_CTRL_IE_VENDOR_EXT : case MFR_CTRL_IE_CAUSE : default : if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr , "\\n\\t<S2SV_blank><S2SV_blank>" , ie_len ) ; break ; } if ( ndo -> ndo_vflag > 1 ) print_unknown_data ( ndo , tptr , "\\n\\t<S2SV_blank><S2SV_blank>" , ie_len ) ; tlen -= ie_len ; tptr += ie_len ; } return hdr_len ; } sequence_num = ( p [ 0 ] & 0x1e ) << 7 | p [ 1 ] ; if ( ( p [ 0 ] & MFR_BEC_MASK ) == MFR_FRAG_FRAME || ( p [ 0 ] & MFR_BEC_MASK ) == MFR_B_BIT ) { ND_PRINT ( ( ndo , "FRF.16<S2SV_blank>Frag,<S2SV_blank>seq<S2SV_blank>%u,<S2SV_blank>Flags<S2SV_blank>[%s],<S2SV_blank>" , sequence_num , bittok2str ( frf_flag_values , "none" , ( p [ 0 ] & MFR_BEC_MASK ) ) ) ) ; hdr_len = 2 ; fr_print ( ndo , p + hdr_len , length - hdr_len ) ; return hdr_len ; } ND_PRINT ( ( ndo , "FRF.16<S2SV_blank>Frag,<S2SV_blank>seq<S2SV_blank>%u,<S2SV_blank>Flags<S2SV_blank>[%s]" , sequence_num , bittok2str ( frf_flag_values , "none" , ( p [ 0 ] & MFR_BEC_MASK ) ) ) ) ; print_unknown_data ( ndo , p , "\\n\\t" , length ) ; return hdr_len ; trunc : ND_PRINT ( ( ndo , "[|mfr]" ) ) ; return length ; }
CWE-125 static u_int ldp_pdu_print ( netdissect_options * ndo , register const u_char * pptr ) { const struct ldp_common_header * ldp_com_header ; const struct ldp_msg_header * ldp_msg_header ; const u_char * tptr , * msg_tptr ; u_short tlen ; u_short pdu_len , msg_len , msg_type , msg_tlen ; int hexdump , processed ; ldp_com_header = ( const struct ldp_common_header * ) pptr ; ND_TCHECK ( * ldp_com_header ) ; if ( EXTRACT_16BITS ( & ldp_com_header -> version ) != LDP_VERSION ) { ND_PRINT ( ( ndo , "%sLDP<S2SV_blank>version<S2SV_blank>%u<S2SV_blank>packet<S2SV_blank>not<S2SV_blank>supported" , ( ndo -> ndo_vflag < 1 ) ? "" : "\\n\\t" , EXTRACT_16BITS ( & ldp_com_header -> version ) ) ) ; return 0 ; } pdu_len = EXTRACT_16BITS ( & ldp_com_header -> pdu_length ) ; if ( pdu_len < sizeof ( const struct ldp_common_header ) - 4 ) { ND_PRINT ( ( ndo , "%sLDP,<S2SV_blank>pdu-length:<S2SV_blank>%u<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)" , ( ndo -> ndo_vflag < 1 ) ? "" : "\\n\\t" , pdu_len , ( u_int ) ( sizeof ( const struct ldp_common_header ) - 4 ) ) ) ; return 0 ; } ND_PRINT ( ( ndo , "%sLDP,<S2SV_blank>Label-Space-ID:<S2SV_blank>%s:%u,<S2SV_blank>pdu-length:<S2SV_blank>%u" , ( ndo -> ndo_vflag < 1 ) ? "" : "\\n\\t" , ipaddr_string ( ndo , & ldp_com_header -> lsr_id ) , EXTRACT_16BITS ( & ldp_com_header -> label_space ) , pdu_len ) ) ; if ( ndo -> ndo_vflag < 1 ) return 0 ; tptr = pptr + sizeof ( const struct ldp_common_header ) ; tlen = pdu_len - ( sizeof ( const struct ldp_common_header ) - 4 ) ; while ( tlen > 0 ) { ND_TCHECK2 ( * tptr , sizeof ( struct ldp_msg_header ) ) ; ldp_msg_header = ( const struct ldp_msg_header * ) tptr ; msg_len = EXTRACT_16BITS ( ldp_msg_header -> length ) ; msg_type = LDP_MASK_MSG_TYPE ( EXTRACT_16BITS ( ldp_msg_header -> type ) ) ; if ( msg_len < sizeof ( struct ldp_msg_header ) - 4 ) { ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Message<S2SV_blank>(0x%04x),<S2SV_blank>length:<S2SV_blank>%u<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)" , tok2str ( ldp_msg_values , "Unknown" , msg_type ) , msg_type , msg_len , ( u_int ) ( sizeof ( struct ldp_msg_header ) - 4 ) ) ) ; return 0 ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Message<S2SV_blank>(0x%04x),<S2SV_blank>length:<S2SV_blank>%u,<S2SV_blank>Message<S2SV_blank>ID:<S2SV_blank>0x%08x,<S2SV_blank>Flags:<S2SV_blank>[%s<S2SV_blank>if<S2SV_blank>unknown]" , tok2str ( ldp_msg_values , "Unknown" , msg_type ) , msg_type , msg_len , EXTRACT_32BITS ( & ldp_msg_header -> id ) , LDP_MASK_U_BIT ( EXTRACT_16BITS ( & ldp_msg_header -> type ) ) ? "continue<S2SV_blank>processing" : "ignore" ) ) ; msg_tptr = tptr + sizeof ( struct ldp_msg_header ) ; msg_tlen = msg_len - ( sizeof ( struct ldp_msg_header ) - 4 ) ; ND_TCHECK2 ( * tptr , msg_len ) ; hexdump = FALSE ; switch ( msg_type ) { case LDP_MSG_NOTIF : case LDP_MSG_HELLO : case LDP_MSG_INIT : case LDP_MSG_KEEPALIVE : case LDP_MSG_ADDRESS : case LDP_MSG_LABEL_MAPPING : case LDP_MSG_ADDRESS_WITHDRAW : case LDP_MSG_LABEL_WITHDRAW : while ( msg_tlen >= 4 ) { processed = ldp_tlv_print ( ndo , msg_tptr , msg_tlen ) ; if ( processed == 0 ) break ; msg_tlen -= processed ; msg_tptr += processed ; } break ; case LDP_MSG_LABEL_REQUEST : case LDP_MSG_LABEL_RELEASE : case LDP_MSG_LABEL_ABORT_REQUEST : default : if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , msg_tptr , "\\n\\t<S2SV_blank><S2SV_blank>" , msg_tlen ) ; break ; } if ( ndo -> ndo_vflag > 1 || hexdump == TRUE ) print_unknown_data ( ndo , tptr + sizeof ( struct ldp_msg_header ) , "\\n\\t<S2SV_blank><S2SV_blank>" , msg_len ) ; tptr += msg_len + 4 ; tlen -= msg_len + 4 ; } return pdu_len + 4 ; trunc : <S2SV_StartBug> ND_PRINT ( ( ndo , "\\n\\t\\t<S2SV_blank>packet<S2SV_blank>exceeded<S2SV_blank>snapshot" ) ) ; <S2SV_EndBug> return 0 ; }
CWE-125 static int ldp_tlv_print ( netdissect_options * ndo , register const u_char * tptr , u_short msg_tlen ) { struct ldp_tlv_header { uint8_t type [ 2 ] ; uint8_t length [ 2 ] ; } ; const struct ldp_tlv_header * ldp_tlv_header ; u_short tlv_type , tlv_len , tlv_tlen , af , ft_flags ; u_char fec_type ; u_int ui , vc_info_len , vc_info_tlv_type , vc_info_tlv_len , idx ; char buf [ 100 ] ; int i ; ldp_tlv_header = ( const struct ldp_tlv_header * ) tptr ; ND_TCHECK ( * ldp_tlv_header ) ; tlv_len = EXTRACT_16BITS ( ldp_tlv_header -> length ) ; if ( tlv_len + 4 > msg_tlen ) { ND_PRINT ( ( ndo , "\\n\\t\\t<S2SV_blank>TLV<S2SV_blank>contents<S2SV_blank>go<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>message" ) ) ; return 0 ; } tlv_tlen = tlv_len ; tlv_type = LDP_MASK_TLV_TYPE ( EXTRACT_16BITS ( ldp_tlv_header -> type ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>TLV<S2SV_blank>(0x%04x),<S2SV_blank>length:<S2SV_blank>%u,<S2SV_blank>Flags:<S2SV_blank>[%s<S2SV_blank>and<S2SV_blank>%s<S2SV_blank>forward<S2SV_blank>if<S2SV_blank>unknown]" , tok2str ( ldp_tlv_values , "Unknown" , tlv_type ) , tlv_type , tlv_len , LDP_MASK_U_BIT ( EXTRACT_16BITS ( & ldp_tlv_header -> type ) ) ? "continue<S2SV_blank>processing" : "ignore" , LDP_MASK_F_BIT ( EXTRACT_16BITS ( & ldp_tlv_header -> type ) ) ? "do" : "don\'t" ) ) ; tptr += sizeof ( struct ldp_tlv_header ) ; switch ( tlv_type ) { case LDP_TLV_COMMON_HELLO : TLV_TCHECK ( 4 ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Hold<S2SV_blank>Time:<S2SV_blank>%us,<S2SV_blank>Flags:<S2SV_blank>[%s<S2SV_blank>Hello%s]" , EXTRACT_16BITS ( tptr ) , ( EXTRACT_16BITS ( tptr + 2 ) & 0x8000 ) ? "Targeted" : "Link" , ( EXTRACT_16BITS ( tptr + 2 ) & 0x4000 ) ? ",<S2SV_blank>Request<S2SV_blank>for<S2SV_blank>targeted<S2SV_blank>Hellos" : "" ) ) ; break ; case LDP_TLV_IPV4_TRANSPORT_ADDR : TLV_TCHECK ( 4 ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>IPv4<S2SV_blank>Transport<S2SV_blank>Address:<S2SV_blank>%s" , ipaddr_string ( ndo , tptr ) ) ) ; break ; case LDP_TLV_IPV6_TRANSPORT_ADDR : TLV_TCHECK ( 16 ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>IPv6<S2SV_blank>Transport<S2SV_blank>Address:<S2SV_blank>%s" , ip6addr_string ( ndo , tptr ) ) ) ; break ; case LDP_TLV_CONFIG_SEQ_NUMBER : TLV_TCHECK ( 4 ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Sequence<S2SV_blank>Number:<S2SV_blank>%u" , EXTRACT_32BITS ( tptr ) ) ) ; break ; case LDP_TLV_ADDRESS_LIST : TLV_TCHECK ( LDP_TLV_ADDRESS_LIST_AFNUM_LEN ) ; af = EXTRACT_16BITS ( tptr ) ; tptr += LDP_TLV_ADDRESS_LIST_AFNUM_LEN ; tlv_tlen -= LDP_TLV_ADDRESS_LIST_AFNUM_LEN ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Address<S2SV_blank>Family:<S2SV_blank>%s,<S2SV_blank>addresses" , tok2str ( af_values , "Unknown<S2SV_blank>(%u)" , af ) ) ) ; switch ( af ) { case AFNUM_INET : while ( tlv_tlen >= sizeof ( struct in_addr ) ) { ND_TCHECK2 ( * tptr , sizeof ( struct in_addr ) ) ; ND_PRINT ( ( ndo , "<S2SV_blank>%s" , ipaddr_string ( ndo , tptr ) ) ) ; tlv_tlen -= sizeof ( struct in_addr ) ; tptr += sizeof ( struct in_addr ) ; } break ; case AFNUM_INET6 : while ( tlv_tlen >= sizeof ( struct in6_addr ) ) { ND_TCHECK2 ( * tptr , sizeof ( struct in6_addr ) ) ; ND_PRINT ( ( ndo , "<S2SV_blank>%s" , ip6addr_string ( ndo , tptr ) ) ) ; tlv_tlen -= sizeof ( struct in6_addr ) ; tptr += sizeof ( struct in6_addr ) ; } break ; default : break ; } break ; case LDP_TLV_COMMON_SESSION : TLV_TCHECK ( 8 ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Version:<S2SV_blank>%u,<S2SV_blank>Keepalive:<S2SV_blank>%us,<S2SV_blank>Flags:<S2SV_blank>[Downstream<S2SV_blank>%s,<S2SV_blank>Loop<S2SV_blank>Detection<S2SV_blank>%s]" , EXTRACT_16BITS ( tptr ) , EXTRACT_16BITS ( tptr + 2 ) , ( EXTRACT_16BITS ( tptr + 6 ) & 0x8000 ) ? "On<S2SV_blank>Demand" : "Unsolicited" , ( EXTRACT_16BITS ( tptr + 6 ) & 0x4000 ) ? "Enabled" : "Disabled" ) ) ; break ; case LDP_TLV_FEC : TLV_TCHECK ( 1 ) ; fec_type = * tptr ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>FEC<S2SV_blank>(0x%02x)" , tok2str ( ldp_fec_values , "Unknown" , fec_type ) , fec_type ) ) ; tptr += 1 ; tlv_tlen -= 1 ; switch ( fec_type ) { case LDP_FEC_WILDCARD : break ; case LDP_FEC_PREFIX : TLV_TCHECK ( 2 ) ; af = EXTRACT_16BITS ( tptr ) ; tptr += LDP_TLV_ADDRESS_LIST_AFNUM_LEN ; tlv_tlen -= LDP_TLV_ADDRESS_LIST_AFNUM_LEN ; if ( af == AFNUM_INET ) { i = decode_prefix4 ( ndo , tptr , tlv_tlen , buf , sizeof ( buf ) ) ; if ( i == - 2 ) goto trunc ; if ( i == - 3 ) ND_PRINT ( ( ndo , ":<S2SV_blank>IPv4<S2SV_blank>prefix<S2SV_blank>(goes<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>TLV)" ) ) ; else if ( i == - 1 ) ND_PRINT ( ( ndo , ":<S2SV_blank>IPv4<S2SV_blank>prefix<S2SV_blank>(invalid<S2SV_blank>length)" ) ) ; else ND_PRINT ( ( ndo , ":<S2SV_blank>IPv4<S2SV_blank>prefix<S2SV_blank>%s" , buf ) ) ; } else if ( af == AFNUM_INET6 ) { i = decode_prefix6 ( ndo , tptr , tlv_tlen , buf , sizeof ( buf ) ) ; if ( i == - 2 ) goto trunc ; if ( i == - 3 ) ND_PRINT ( ( ndo , ":<S2SV_blank>IPv4<S2SV_blank>prefix<S2SV_blank>(goes<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>TLV)" ) ) ; else if ( i == - 1 ) ND_PRINT ( ( ndo , ":<S2SV_blank>IPv6<S2SV_blank>prefix<S2SV_blank>(invalid<S2SV_blank>length)" ) ) ; else ND_PRINT ( ( ndo , ":<S2SV_blank>IPv6<S2SV_blank>prefix<S2SV_blank>%s" , buf ) ) ; } else ND_PRINT ( ( ndo , ":<S2SV_blank>Address<S2SV_blank>family<S2SV_blank>%u<S2SV_blank>prefix" , af ) ) ; break ; case LDP_FEC_HOSTADDRESS : break ; case LDP_FEC_MARTINI_VC : TLV_TCHECK ( 7 ) ; vc_info_len = * ( tptr + 2 ) ; if ( vc_info_len == 0 ) { ND_PRINT ( ( ndo , ":<S2SV_blank>%s,<S2SV_blank>%scontrol<S2SV_blank>word,<S2SV_blank>group-ID<S2SV_blank>%u,<S2SV_blank>VC-info-length:<S2SV_blank>%u" , tok2str ( mpls_pw_types_values , "Unknown" , EXTRACT_16BITS ( tptr ) & 0x7fff ) , EXTRACT_16BITS ( tptr ) & 0x8000 ? "" : "no<S2SV_blank>" , EXTRACT_32BITS ( tptr + 3 ) , vc_info_len ) ) ; break ; } TLV_TCHECK ( 11 ) ; ND_PRINT ( ( ndo , ":<S2SV_blank>%s,<S2SV_blank>%scontrol<S2SV_blank>word,<S2SV_blank>group-ID<S2SV_blank>%u,<S2SV_blank>VC-ID<S2SV_blank>%u,<S2SV_blank>VC-info-length:<S2SV_blank>%u" , tok2str ( mpls_pw_types_values , "Unknown" , EXTRACT_16BITS ( tptr ) & 0x7fff ) , EXTRACT_16BITS ( tptr ) & 0x8000 ? "" : "no<S2SV_blank>" , EXTRACT_32BITS ( tptr + 3 ) , EXTRACT_32BITS ( tptr + 7 ) , vc_info_len ) ) ; if ( vc_info_len < 4 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(invalid,<S2SV_blank><<S2SV_blank>4" ) ) ; return ( tlv_len + 4 ) ; } vc_info_len -= 4 ; tptr += 11 ; tlv_tlen -= 11 ; TLV_TCHECK ( vc_info_len ) ; while ( vc_info_len > 2 ) { vc_info_tlv_type = * tptr ; vc_info_tlv_len = * ( tptr + 1 ) ; if ( vc_info_tlv_len < 2 ) break ; if ( vc_info_len < vc_info_tlv_len ) break ; ND_PRINT ( ( ndo , "\\n\\t\\tInterface<S2SV_blank>Parameter:<S2SV_blank>%s<S2SV_blank>(0x%02x),<S2SV_blank>len<S2SV_blank>%u" , tok2str ( ldp_fec_martini_ifparm_values , "Unknown" , vc_info_tlv_type ) , vc_info_tlv_type , vc_info_tlv_len ) ) ; switch ( vc_info_tlv_type ) { case LDP_FEC_MARTINI_IFPARM_MTU : ND_PRINT ( ( ndo , ":<S2SV_blank>%u" , EXTRACT_16BITS ( tptr + 2 ) ) ) ; break ; case LDP_FEC_MARTINI_IFPARM_DESC : ND_PRINT ( ( ndo , ":<S2SV_blank>" ) ) ; for ( idx = 2 ; idx < vc_info_tlv_len ; idx ++ ) safeputchar ( ndo , * ( tptr + idx ) ) ; break ; case LDP_FEC_MARTINI_IFPARM_VCCV : ND_PRINT ( ( ndo , "\\n\\t\\t<S2SV_blank><S2SV_blank>Control<S2SV_blank>Channels<S2SV_blank>(0x%02x)<S2SV_blank>=<S2SV_blank>[%s]" , * ( tptr + 2 ) , bittok2str ( ldp_fec_martini_ifparm_vccv_cc_values , "none" , * ( tptr + 2 ) ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t\\t<S2SV_blank><S2SV_blank>CV<S2SV_blank>Types<S2SV_blank>(0x%02x)<S2SV_blank>=<S2SV_blank>[%s]" , * ( tptr + 3 ) , bittok2str ( ldp_fec_martini_ifparm_vccv_cv_values , "none" , * ( tptr + 3 ) ) ) ) ; break ; default : print_unknown_data ( ndo , tptr + 2 , "\\n\\t\\t<S2SV_blank><S2SV_blank>" , vc_info_tlv_len - 2 ) ; break ; } vc_info_len -= vc_info_tlv_len ; tptr += vc_info_tlv_len ; } break ; } break ; case LDP_TLV_GENERIC_LABEL : TLV_TCHECK ( 4 ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Label:<S2SV_blank>%u" , EXTRACT_32BITS ( tptr ) & 0xfffff ) ) ; break ; case LDP_TLV_STATUS : TLV_TCHECK ( 8 ) ; ui = EXTRACT_32BITS ( tptr ) ; tptr += 4 ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Status:<S2SV_blank>0x%02x,<S2SV_blank>Flags:<S2SV_blank>[%s<S2SV_blank>and<S2SV_blank>%s<S2SV_blank>forward]" , ui & 0x3fffffff , ui & 0x80000000 ? "Fatal<S2SV_blank>error" : "Advisory<S2SV_blank>Notification" , ui & 0x40000000 ? "do" : "don\'t" ) ) ; ui = EXTRACT_32BITS ( tptr ) ; tptr += 4 ; if ( ui ) ND_PRINT ( ( ndo , ",<S2SV_blank>causing<S2SV_blank>Message<S2SV_blank>ID:<S2SV_blank>0x%08x" , ui ) ) ; break ; case LDP_TLV_FT_SESSION : <S2SV_StartBug> TLV_TCHECK ( 8 ) ; <S2SV_EndBug> ft_flags = EXTRACT_16BITS ( tptr ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[%sReconnect,<S2SV_blank>%sSave<S2SV_blank>State,<S2SV_blank>%sAll-Label<S2SV_blank>Protection,<S2SV_blank>%s<S2SV_blank>Checkpoint,<S2SV_blank>%sRe-Learn<S2SV_blank>State]" , ft_flags & 0x8000 ? "" : "No<S2SV_blank>" , ft_flags & 0x8 ? "" : "Don\'t<S2SV_blank>" , ft_flags & 0x4 ? "" : "No<S2SV_blank>" , ft_flags & 0x2 ? "Sequence<S2SV_blank>Numbered<S2SV_blank>Label" : "All<S2SV_blank>Labels" , ft_flags & 0x1 ? "" : "Don\'t<S2SV_blank>" ) ) ; tptr += 4 ; ui = EXTRACT_32BITS ( tptr ) ; if ( ui ) ND_PRINT ( ( ndo , ",<S2SV_blank>Reconnect<S2SV_blank>Timeout:<S2SV_blank>%ums" , ui ) ) ; tptr += 4 ; ui = EXTRACT_32BITS ( tptr ) ; if ( ui ) ND_PRINT ( ( ndo , ",<S2SV_blank>Recovery<S2SV_blank>Time:<S2SV_blank>%ums" , ui ) ) ; break ; case LDP_TLV_MTU : TLV_TCHECK ( 2 ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>MTU:<S2SV_blank>%u" , EXTRACT_16BITS ( tptr ) ) ) ; break ; case LDP_TLV_HOP_COUNT : case LDP_TLV_PATH_VECTOR : case LDP_TLV_ATM_LABEL : case LDP_TLV_FR_LABEL : case LDP_TLV_EXTD_STATUS : case LDP_TLV_RETURNED_PDU : case LDP_TLV_RETURNED_MSG : case LDP_TLV_ATM_SESSION_PARM : case LDP_TLV_FR_SESSION_PARM : case LDP_TLV_LABEL_REQUEST_MSG_ID : default : if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , tlv_tlen ) ; break ; } return ( tlv_len + 4 ) ; trunc : <S2SV_StartBug> ND_PRINT ( ( ndo , "\\n\\t\\t<S2SV_blank>packet<S2SV_blank>exceeded<S2SV_blank>snapshot" ) ) ; <S2SV_EndBug> return 0 ; badtlv : ND_PRINT ( ( ndo , "\\n\\t\\t<S2SV_blank>TLV<S2SV_blank>contents<S2SV_blank>go<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>TLV" ) ) ; return ( tlv_len + 4 ) ; }
CWE-674 static int bgp_attr_print ( netdissect_options * ndo , <S2SV_StartBug> u_int atype , const u_char * pptr , u_int len ) <S2SV_EndBug> { int i ; uint16_t af ; uint8_t safi , snpa , nhlen ; union { float f ; uint32_t i ; } bw ; int advance ; u_int tlen ; const u_char * tptr ; char buf [ MAXHOSTNAMELEN + 100 ] ; int as_size ; tptr = pptr ; tlen = len ; switch ( atype ) { case BGPTYPE_ORIGIN : if ( len != 1 ) ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; else { ND_TCHECK ( * tptr ) ; ND_PRINT ( ( ndo , "%s" , tok2str ( bgp_origin_values , "Unknown<S2SV_blank>Origin<S2SV_blank>Typecode" , tptr [ 0 ] ) ) ) ; } break ; case BGPTYPE_AS4_PATH : case BGPTYPE_AS_PATH : if ( len % 2 ) { ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; break ; } if ( ! len ) { ND_PRINT ( ( ndo , "empty" ) ) ; break ; } as_size = bgp_attr_get_as_size ( ndo , atype , pptr , len ) ; while ( tptr < pptr + len ) { ND_TCHECK ( tptr [ 0 ] ) ; ND_PRINT ( ( ndo , "%s" , tok2str ( bgp_as_path_segment_open_values , "?" , tptr [ 0 ] ) ) ) ; ND_TCHECK ( tptr [ 1 ] ) ; for ( i = 0 ; i < tptr [ 1 ] * as_size ; i += as_size ) { ND_TCHECK2 ( tptr [ 2 + i ] , as_size ) ; ND_PRINT ( ( ndo , "%s<S2SV_blank>" , as_printf ( ndo , astostr , sizeof ( astostr ) , as_size == 2 ? EXTRACT_16BITS ( & tptr [ 2 + i ] ) : EXTRACT_32BITS ( & tptr [ 2 + i ] ) ) ) ) ; } ND_TCHECK ( tptr [ 0 ] ) ; ND_PRINT ( ( ndo , "%s" , tok2str ( bgp_as_path_segment_close_values , "?" , tptr [ 0 ] ) ) ) ; ND_TCHECK ( tptr [ 1 ] ) ; tptr += 2 + tptr [ 1 ] * as_size ; } break ; case BGPTYPE_NEXT_HOP : if ( len != 4 ) ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; else { ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , "%s" , ipaddr_string ( ndo , tptr ) ) ) ; } break ; case BGPTYPE_MULTI_EXIT_DISC : case BGPTYPE_LOCAL_PREF : if ( len != 4 ) ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; else { ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , "%u" , EXTRACT_32BITS ( tptr ) ) ) ; } break ; case BGPTYPE_ATOMIC_AGGREGATE : if ( len != 0 ) ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; break ; case BGPTYPE_AGGREGATOR : if ( len != 6 && len != 8 ) { ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; break ; } ND_TCHECK2 ( tptr [ 0 ] , len ) ; if ( len == 6 ) { ND_PRINT ( ( ndo , "<S2SV_blank>AS<S2SV_blank>#%s,<S2SV_blank>origin<S2SV_blank>%s" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_16BITS ( tptr ) ) , ipaddr_string ( ndo , tptr + 2 ) ) ) ; } else { ND_PRINT ( ( ndo , "<S2SV_blank>AS<S2SV_blank>#%s,<S2SV_blank>origin<S2SV_blank>%s" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr ) ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; } break ; case BGPTYPE_AGGREGATOR4 : if ( len != 8 ) { ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; break ; } ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , "<S2SV_blank>AS<S2SV_blank>#%s,<S2SV_blank>origin<S2SV_blank>%s" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr ) ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; break ; case BGPTYPE_COMMUNITIES : if ( len % 4 ) { ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; break ; } while ( tlen > 0 ) { uint32_t comm ; ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; comm = EXTRACT_32BITS ( tptr ) ; switch ( comm ) { case BGP_COMMUNITY_NO_EXPORT : ND_PRINT ( ( ndo , "<S2SV_blank>NO_EXPORT" ) ) ; break ; case BGP_COMMUNITY_NO_ADVERT : ND_PRINT ( ( ndo , "<S2SV_blank>NO_ADVERTISE" ) ) ; break ; case BGP_COMMUNITY_NO_EXPORT_SUBCONFED : ND_PRINT ( ( ndo , "<S2SV_blank>NO_EXPORT_SUBCONFED" ) ) ; break ; default : ND_PRINT ( ( ndo , "%u:%u%s" , ( comm >> 16 ) & 0xffff , comm & 0xffff , ( tlen > 4 ) ? ",<S2SV_blank>" : "" ) ) ; break ; } tlen -= 4 ; tptr += 4 ; } break ; case BGPTYPE_ORIGINATOR_ID : if ( len != 4 ) { ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; break ; } ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , "%s" , ipaddr_string ( ndo , tptr ) ) ) ; break ; case BGPTYPE_CLUSTER_LIST : if ( len % 4 ) { ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; break ; } while ( tlen > 0 ) { ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , "%s%s" , ipaddr_string ( ndo , tptr ) , ( tlen > 4 ) ? ",<S2SV_blank>" : "" ) ) ; tlen -= 4 ; tptr += 4 ; } break ; case BGPTYPE_MP_REACH_NLRI : ND_TCHECK2 ( tptr [ 0 ] , 3 ) ; af = EXTRACT_16BITS ( tptr ) ; safi = tptr [ 2 ] ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>AFI:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>%sSAFI:<S2SV_blank>%s<S2SV_blank>(%u)" , tok2str ( af_values , "Unknown<S2SV_blank>AFI" , af ) , af , ( safi > 128 ) ? "vendor<S2SV_blank>specific<S2SV_blank>" : "" , tok2str ( bgp_safi_values , "Unknown<S2SV_blank>SAFI" , safi ) , safi ) ) ; switch ( af << 8 | safi ) { case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_RT_ROUTING_INFO ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET << 8 | SAFNUM_MDT ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : break ; default : ND_TCHECK2 ( tptr [ 0 ] , tlen ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>no<S2SV_blank>AFI<S2SV_blank>%u<S2SV_blank>/<S2SV_blank>SAFI<S2SV_blank>%u<S2SV_blank>decoder" , af , safi ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , tlen ) ; goto done ; break ; } tptr += 3 ; ND_TCHECK ( tptr [ 0 ] ) ; nhlen = tptr [ 0 ] ; tlen = nhlen ; tptr ++ ; if ( tlen ) { int nnh = 0 ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>nexthop:<S2SV_blank>" ) ) ; while ( tlen > 0 ) { if ( nnh ++ > 0 ) { ND_PRINT ( ( ndo , ",<S2SV_blank>" ) ) ; } switch ( af << 8 | safi ) { case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_RT_ROUTING_INFO ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET << 8 | SAFNUM_MDT ) : if ( tlen < ( int ) sizeof ( struct in_addr ) ) { ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in_addr ) ) ; ND_PRINT ( ( ndo , "%s" , ipaddr_string ( ndo , tptr ) ) ) ; tlen -= sizeof ( struct in_addr ) ; tptr += sizeof ( struct in_addr ) ; } break ; case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < ( int ) ( sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ) { ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ; ND_PRINT ( ( ndo , "RD:<S2SV_blank>%s,<S2SV_blank>%s" , bgp_vpn_rd_print ( ndo , tptr ) , ipaddr_string ( ndo , tptr + BGP_VPN_RD_LEN ) ) ) ; tlen -= ( sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ; tptr += ( sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ; } break ; case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : if ( tlen < ( int ) sizeof ( struct in6_addr ) ) { ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in6_addr ) ) ; ND_PRINT ( ( ndo , "%s" , ip6addr_string ( ndo , tptr ) ) ) ; tlen -= sizeof ( struct in6_addr ) ; tptr += sizeof ( struct in6_addr ) ; } break ; case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < ( int ) ( sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ) { ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ; ND_PRINT ( ( ndo , "RD:<S2SV_blank>%s,<S2SV_blank>%s" , bgp_vpn_rd_print ( ndo , tptr ) , ip6addr_string ( ndo , tptr + BGP_VPN_RD_LEN ) ) ) ; tlen -= ( sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ; tptr += ( sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ; } break ; case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < ( int ) sizeof ( struct in_addr ) ) { ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in_addr ) ) ; ND_PRINT ( ( ndo , "%s" , ipaddr_string ( ndo , tptr ) ) ) ; tlen -= ( sizeof ( struct in_addr ) ) ; tptr += ( sizeof ( struct in_addr ) ) ; } break ; case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : ND_TCHECK2 ( tptr [ 0 ] , tlen ) ; ND_PRINT ( ( ndo , "%s" , isonsap_string ( ndo , tptr , tlen ) ) ) ; tptr += tlen ; tlen = 0 ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < BGP_VPN_RD_LEN + 1 ) { ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , tlen ) ; ND_PRINT ( ( ndo , "RD:<S2SV_blank>%s,<S2SV_blank>%s" , bgp_vpn_rd_print ( ndo , tptr ) , isonsap_string ( ndo , tptr + BGP_VPN_RD_LEN , tlen - BGP_VPN_RD_LEN ) ) ) ; if ( tlen == BGP_VPN_RD_LEN + 4 + sizeof ( struct in_addr ) && EXTRACT_32BITS ( tptr + BGP_VPN_RD_LEN ) == 0x47000601 ) ND_PRINT ( ( ndo , "<S2SV_blank>=<S2SV_blank>%s" , ipaddr_string ( ndo , tptr + BGP_VPN_RD_LEN + 4 ) ) ) ; else if ( tlen == BGP_VPN_RD_LEN + 3 + sizeof ( struct in6_addr ) && EXTRACT_24BITS ( tptr + BGP_VPN_RD_LEN ) == 0x350000 ) ND_PRINT ( ( ndo , "<S2SV_blank>=<S2SV_blank>%s" , ip6addr_string ( ndo , tptr + BGP_VPN_RD_LEN + 3 ) ) ) ; tptr += tlen ; tlen = 0 ; } break ; default : ND_TCHECK2 ( tptr [ 0 ] , tlen ) ; ND_PRINT ( ( ndo , "no<S2SV_blank>AFI<S2SV_blank>%u/SAFI<S2SV_blank>%u<S2SV_blank>decoder" , af , safi ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , tlen ) ; tptr += tlen ; tlen = 0 ; goto done ; break ; } } } ND_PRINT ( ( ndo , ",<S2SV_blank>nh-length:<S2SV_blank>%u" , nhlen ) ) ; tptr += tlen ; ND_TCHECK ( tptr [ 0 ] ) ; snpa = tptr [ 0 ] ; tptr ++ ; if ( snpa ) { ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%u<S2SV_blank>SNPA" , snpa ) ) ; for ( ; snpa > 0 ; snpa -- ) { ND_TCHECK ( tptr [ 0 ] ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%d<S2SV_blank>bytes" , tptr [ 0 ] ) ) ; tptr += tptr [ 0 ] + 1 ; } } else { ND_PRINT ( ( ndo , ",<S2SV_blank>no<S2SV_blank>SNPA" ) ) ; } while ( tptr < pptr + len ) { switch ( af << 8 | safi ) { case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix4 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_RT_ROUTING_INFO ) : advance = decode_rt_routing_info ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST_VPN ) : advance = decode_multicast_vpn ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_MDT ) : advance = decode_mdt_vpn_nlri ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix6 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_l2 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; default : ND_TCHECK2 ( * tptr , tlen ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>no<S2SV_blank>AFI<S2SV_blank>%u<S2SV_blank>/<S2SV_blank>SAFI<S2SV_blank>%u<S2SV_blank>decoder" , af , safi ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , tlen ) ; advance = 0 ; tptr = pptr + len ; break ; } if ( advance < 0 ) break ; tptr += advance ; } done : break ; case BGPTYPE_MP_UNREACH_NLRI : ND_TCHECK2 ( tptr [ 0 ] , BGP_MP_NLRI_MINSIZE ) ; af = EXTRACT_16BITS ( tptr ) ; safi = tptr [ 2 ] ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>AFI:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>%sSAFI:<S2SV_blank>%s<S2SV_blank>(%u)" , tok2str ( af_values , "Unknown<S2SV_blank>AFI" , af ) , af , ( safi > 128 ) ? "vendor<S2SV_blank>specific<S2SV_blank>" : "" , tok2str ( bgp_safi_values , "Unknown<S2SV_blank>SAFI" , safi ) , safi ) ) ; if ( len == BGP_MP_NLRI_MINSIZE ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>End-of-Rib<S2SV_blank>Marker<S2SV_blank>(empty<S2SV_blank>NLRI)" ) ) ; tptr += 3 ; while ( tptr < pptr + len ) { switch ( af << 8 | safi ) { case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix4 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix6 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_l2 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_MDT ) : advance = decode_mdt_vpn_nlri ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST_VPN ) : advance = decode_multicast_vpn ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; default : ND_TCHECK2 ( * ( tptr - 3 ) , tlen ) ; ND_PRINT ( ( ndo , "no<S2SV_blank>AFI<S2SV_blank>%u<S2SV_blank>/<S2SV_blank>SAFI<S2SV_blank>%u<S2SV_blank>decoder" , af , safi ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr - 3 , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , tlen ) ; advance = 0 ; tptr = pptr + len ; break ; } if ( advance < 0 ) break ; tptr += advance ; } break ; case BGPTYPE_EXTD_COMMUNITIES : if ( len % 8 ) { ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; break ; } while ( tlen > 0 ) { uint16_t extd_comm ; ND_TCHECK2 ( tptr [ 0 ] , 2 ) ; extd_comm = EXTRACT_16BITS ( tptr ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>(0x%04x),<S2SV_blank>Flags<S2SV_blank>[%s]" , tok2str ( bgp_extd_comm_subtype_values , "unknown<S2SV_blank>extd<S2SV_blank>community<S2SV_blank>typecode" , extd_comm ) , extd_comm , bittok2str ( bgp_extd_comm_flag_values , "none" , extd_comm ) ) ) ; ND_TCHECK2 ( * ( tptr + 2 ) , 6 ) ; switch ( extd_comm ) { case BGP_EXT_COM_RT_0 : case BGP_EXT_COM_RO_0 : case BGP_EXT_COM_L2VPN_RT_0 : ND_PRINT ( ( ndo , ":<S2SV_blank>%u:%u<S2SV_blank>(=<S2SV_blank>%s)" , EXTRACT_16BITS ( tptr + 2 ) , EXTRACT_32BITS ( tptr + 4 ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; break ; case BGP_EXT_COM_RT_1 : case BGP_EXT_COM_RO_1 : case BGP_EXT_COM_L2VPN_RT_1 : case BGP_EXT_COM_VRF_RT_IMP : ND_PRINT ( ( ndo , ":<S2SV_blank>%s:%u" , ipaddr_string ( ndo , tptr + 2 ) , EXTRACT_16BITS ( tptr + 6 ) ) ) ; break ; case BGP_EXT_COM_RT_2 : case BGP_EXT_COM_RO_2 : ND_PRINT ( ( ndo , ":<S2SV_blank>%s:%u" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr + 2 ) ) , EXTRACT_16BITS ( tptr + 6 ) ) ) ; break ; case BGP_EXT_COM_LINKBAND : bw . i = EXTRACT_32BITS ( tptr + 2 ) ; ND_PRINT ( ( ndo , ":<S2SV_blank>bandwidth:<S2SV_blank>%.3f<S2SV_blank>Mbps" , bw . f * 8 / 1000000 ) ) ; break ; case BGP_EXT_COM_VPN_ORIGIN : case BGP_EXT_COM_VPN_ORIGIN2 : case BGP_EXT_COM_VPN_ORIGIN3 : case BGP_EXT_COM_VPN_ORIGIN4 : case BGP_EXT_COM_OSPF_RID : case BGP_EXT_COM_OSPF_RID2 : ND_PRINT ( ( ndo , "%s" , ipaddr_string ( ndo , tptr + 2 ) ) ) ; break ; case BGP_EXT_COM_OSPF_RTYPE : case BGP_EXT_COM_OSPF_RTYPE2 : ND_PRINT ( ( ndo , ":<S2SV_blank>area:%s,<S2SV_blank>router-type:%s,<S2SV_blank>metric-type:%s%s" , ipaddr_string ( ndo , tptr + 2 ) , tok2str ( bgp_extd_comm_ospf_rtype_values , "unknown<S2SV_blank>(0x%02x)" , * ( tptr + 6 ) ) , ( * ( tptr + 7 ) & BGP_OSPF_RTYPE_METRIC_TYPE ) ? "E2" : "" , ( ( * ( tptr + 6 ) == BGP_OSPF_RTYPE_EXT ) || ( * ( tptr + 6 ) == BGP_OSPF_RTYPE_NSSA ) ) ? "E1" : "" ) ) ; break ; case BGP_EXT_COM_L2INFO : ND_PRINT ( ( ndo , ":<S2SV_blank>%s<S2SV_blank>Control<S2SV_blank>Flags<S2SV_blank>[0x%02x]:MTU<S2SV_blank>%u" , tok2str ( l2vpn_encaps_values , "unknown<S2SV_blank>encaps" , * ( tptr + 2 ) ) , * ( tptr + 3 ) , EXTRACT_16BITS ( tptr + 4 ) ) ) ; break ; case BGP_EXT_COM_SOURCE_AS : ND_PRINT ( ( ndo , ":<S2SV_blank>AS<S2SV_blank>%u" , EXTRACT_16BITS ( tptr + 2 ) ) ) ; break ; default : ND_TCHECK2 ( * tptr , 8 ) ; print_unknown_data ( ndo , tptr , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , 8 ) ; break ; } tlen -= 8 ; tptr += 8 ; } break ; case BGPTYPE_PMSI_TUNNEL : { uint8_t tunnel_type , flags ; ND_TCHECK2 ( tptr [ 0 ] , 5 ) ; tunnel_type = * ( tptr + 1 ) ; flags = * tptr ; tlen = len ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Tunnel-type<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>Flags<S2SV_blank>[%s],<S2SV_blank>MPLS<S2SV_blank>Label<S2SV_blank>%u" , tok2str ( bgp_pmsi_tunnel_values , "Unknown" , tunnel_type ) , tunnel_type , bittok2str ( bgp_pmsi_flag_values , "none" , flags ) , EXTRACT_24BITS ( tptr + 2 ) >> 4 ) ) ; tptr += 5 ; tlen -= 5 ; switch ( tunnel_type ) { case BGP_PMSI_TUNNEL_PIM_SM : case BGP_PMSI_TUNNEL_PIM_BIDIR : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Sender<S2SV_blank>%s,<S2SV_blank>P-Group<S2SV_blank>%s" , ipaddr_string ( ndo , tptr ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; break ; case BGP_PMSI_TUNNEL_PIM_SSM : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Root-Node<S2SV_blank>%s,<S2SV_blank>P-Group<S2SV_blank>%s" , ipaddr_string ( ndo , tptr ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; break ; case BGP_PMSI_TUNNEL_INGRESS : ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Tunnel-Endpoint<S2SV_blank>%s" , ipaddr_string ( ndo , tptr ) ) ) ; break ; case BGP_PMSI_TUNNEL_LDP_P2MP : case BGP_PMSI_TUNNEL_LDP_MP2MP : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Root-Node<S2SV_blank>%s,<S2SV_blank>LSP-ID<S2SV_blank>0x%08x" , ipaddr_string ( ndo , tptr ) , EXTRACT_32BITS ( tptr + 4 ) ) ) ; break ; case BGP_PMSI_TUNNEL_RSVP_P2MP : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Extended-Tunnel-ID<S2SV_blank>%s,<S2SV_blank>P2MP-ID<S2SV_blank>0x%08x" , ipaddr_string ( ndo , tptr ) , EXTRACT_32BITS ( tptr + 4 ) ) ) ; break ; default : if ( ndo -> ndo_vflag <= 1 ) { print_unknown_data ( ndo , tptr , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , tlen ) ; } } break ; } case BGPTYPE_AIGP : { uint8_t type ; uint16_t length ; tlen = len ; while ( tlen >= 3 ) { ND_TCHECK2 ( tptr [ 0 ] , 3 ) ; type = * tptr ; length = EXTRACT_16BITS ( tptr + 1 ) ; tptr += 3 ; tlen -= 3 ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>TLV<S2SV_blank>(%u),<S2SV_blank>length<S2SV_blank>%u" , tok2str ( bgp_aigp_values , "Unknown" , type ) , type , length ) ) ; if ( length < 3 ) goto trunc ; length -= 3 ; ND_TCHECK2 ( tptr [ 3 ] , length ) ; switch ( type ) { case BGP_AIGP_TLV : if ( length < 8 ) goto trunc ; ND_PRINT ( ( ndo , ",<S2SV_blank>metric<S2SV_blank>%" PRIu64 , EXTRACT_64BITS ( tptr ) ) ) ; break ; default : if ( ndo -> ndo_vflag <= 1 ) { print_unknown_data ( ndo , tptr , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , length ) ; } } tptr += length ; tlen -= length ; } break ; } case BGPTYPE_ATTR_SET : ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; if ( len < 4 ) goto trunc ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Origin<S2SV_blank>AS:<S2SV_blank>%s" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr ) ) ) ) ; tptr += 4 ; len -= 4 ; while ( len ) { u_int aflags , alenlen , alen ; ND_TCHECK2 ( tptr [ 0 ] , 2 ) ; if ( len < 2 ) goto trunc ; aflags = * tptr ; atype = * ( tptr + 1 ) ; tptr += 2 ; len -= 2 ; alenlen = bgp_attr_lenlen ( aflags , tptr ) ; ND_TCHECK2 ( tptr [ 0 ] , alenlen ) ; if ( len < alenlen ) goto trunc ; alen = bgp_attr_len ( aflags , tptr ) ; tptr += alenlen ; len -= alenlen ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>length:<S2SV_blank>%u" , tok2str ( bgp_attr_values , "Unknown<S2SV_blank>Attribute" , atype ) , atype , alen ) ) ; if ( aflags ) { ND_PRINT ( ( ndo , ",<S2SV_blank>Flags<S2SV_blank>[%s%s%s%s" , aflags & 0x80 ? "O" : "" , aflags & 0x40 ? "T" : "" , aflags & 0x20 ? "P" : "" , aflags & 0x10 ? "E" : "" ) ) ; if ( aflags & 0xf ) ND_PRINT ( ( ndo , "+%x" , aflags & 0xf ) ) ; ND_PRINT ( ( ndo , "]:<S2SV_blank>" ) ) ; } <S2SV_StartBug> if ( ! bgp_attr_print ( ndo , atype , tptr , alen ) ) <S2SV_EndBug> return 0 ; tptr += alen ; len -= alen ; } break ; case BGPTYPE_LARGE_COMMUNITY : if ( len == 0 || len % 12 ) { ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" ) ) ; while ( len > 0 ) { ND_TCHECK2 ( * tptr , 12 ) ; ND_PRINT ( ( ndo , "%u:%u:%u%s" , EXTRACT_32BITS ( tptr ) , EXTRACT_32BITS ( tptr + 4 ) , EXTRACT_32BITS ( tptr + 8 ) , ( len > 12 ) ? ",<S2SV_blank>" : "" ) ) ; tptr += 12 ; len -= 12 ; } break ; default : ND_TCHECK2 ( * pptr , len ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>no<S2SV_blank>Attribute<S2SV_blank>%u<S2SV_blank>decoder" , atype ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , pptr , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , len ) ; break ; } if ( ndo -> ndo_vflag > 1 && len ) { ND_TCHECK2 ( * pptr , len ) ; print_unknown_data ( ndo , pptr , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , len ) ; } return 1 ; trunc : return 0 ; }
CWE-674 static void bgp_update_print ( netdissect_options * ndo , const u_char * dat , int length ) { struct bgp bgp ; const u_char * p ; int withdrawn_routes_len ; int len ; int i ; ND_TCHECK2 ( dat [ 0 ] , BGP_SIZE ) ; if ( length < BGP_SIZE ) goto trunc ; memcpy ( & bgp , dat , BGP_SIZE ) ; p = dat + BGP_SIZE ; length -= BGP_SIZE ; ND_TCHECK2 ( p [ 0 ] , 2 ) ; if ( length < 2 ) goto trunc ; withdrawn_routes_len = EXTRACT_16BITS ( p ) ; p += 2 ; length -= 2 ; if ( withdrawn_routes_len ) { ND_TCHECK2 ( p [ 0 ] , withdrawn_routes_len ) ; if ( length < withdrawn_routes_len ) goto trunc ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>Withdrawn<S2SV_blank>routes:<S2SV_blank>%d<S2SV_blank>bytes" , withdrawn_routes_len ) ) ; p += withdrawn_routes_len ; length -= withdrawn_routes_len ; } ND_TCHECK2 ( p [ 0 ] , 2 ) ; if ( length < 2 ) goto trunc ; len = EXTRACT_16BITS ( p ) ; p += 2 ; length -= 2 ; if ( withdrawn_routes_len == 0 && len == 0 && length == 0 ) { ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>End-of-Rib<S2SV_blank>Marker<S2SV_blank>(empty<S2SV_blank>NLRI)" ) ) ; return ; } if ( len ) { while ( len ) { int aflags , atype , alenlen , alen ; ND_TCHECK2 ( p [ 0 ] , 2 ) ; if ( len < 2 ) goto trunc ; if ( length < 2 ) goto trunc ; aflags = * p ; atype = * ( p + 1 ) ; p += 2 ; len -= 2 ; length -= 2 ; alenlen = bgp_attr_lenlen ( aflags , p ) ; ND_TCHECK2 ( p [ 0 ] , alenlen ) ; if ( len < alenlen ) goto trunc ; if ( length < alenlen ) goto trunc ; alen = bgp_attr_len ( aflags , p ) ; p += alenlen ; len -= alenlen ; length -= alenlen ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>length:<S2SV_blank>%u" , tok2str ( bgp_attr_values , "Unknown<S2SV_blank>Attribute" , atype ) , atype , alen ) ) ; if ( aflags ) { ND_PRINT ( ( ndo , ",<S2SV_blank>Flags<S2SV_blank>[%s%s%s%s" , aflags & 0x80 ? "O" : "" , aflags & 0x40 ? "T" : "" , aflags & 0x20 ? "P" : "" , aflags & 0x10 ? "E" : "" ) ) ; if ( aflags & 0xf ) ND_PRINT ( ( ndo , "+%x" , aflags & 0xf ) ) ; ND_PRINT ( ( ndo , "]:<S2SV_blank>" ) ) ; } if ( len < alen ) goto trunc ; if ( length < alen ) goto trunc ; <S2SV_StartBug> if ( ! bgp_attr_print ( ndo , atype , p , alen ) ) <S2SV_EndBug> goto trunc ; p += alen ; len -= alen ; length -= alen ; } } if ( length ) { ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>Updated<S2SV_blank>routes:" ) ) ; while ( length ) { char buf [ MAXHOSTNAMELEN + 100 ] ; i = decode_prefix4 ( ndo , p , length , buf , sizeof ( buf ) ) ; if ( i == - 1 ) { ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; break ; } else if ( i == - 2 ) goto trunc ; else if ( i == - 3 ) goto trunc ; else { ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; p += i ; length -= i ; } } } return ; trunc : ND_PRINT ( ( ndo , "%s" , tstr ) ) ; }
CWE-125 static int rsvp_obj_print ( netdissect_options * ndo , const u_char * pptr , u_int plen , const u_char * tptr , const char * ident , u_int tlen , const struct rsvp_common_header * rsvp_com_header ) { const struct rsvp_object_header * rsvp_obj_header ; const u_char * obj_tptr ; union { const struct rsvp_obj_integrity_t * rsvp_obj_integrity ; const struct rsvp_obj_frr_t * rsvp_obj_frr ; } obj_ptr ; u_short rsvp_obj_len , rsvp_obj_ctype , obj_tlen , intserv_serv_tlen ; int hexdump , processed , padbytes , error_code , error_value , i , sigcheck ; union { float f ; uint32_t i ; } bw ; uint8_t namelen ; u_int action , subchannel ; while ( tlen >= sizeof ( struct rsvp_object_header ) ) { ND_TCHECK2 ( * tptr , sizeof ( struct rsvp_object_header ) ) ; rsvp_obj_header = ( const struct rsvp_object_header * ) tptr ; rsvp_obj_len = EXTRACT_16BITS ( rsvp_obj_header -> length ) ; rsvp_obj_ctype = rsvp_obj_header -> ctype ; if ( rsvp_obj_len % 4 ) { ND_PRINT ( ( ndo , "%sERROR:<S2SV_blank>object<S2SV_blank>header<S2SV_blank>size<S2SV_blank>%u<S2SV_blank>not<S2SV_blank>a<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>4" , ident , rsvp_obj_len ) ) ; return - 1 ; } if ( rsvp_obj_len < sizeof ( struct rsvp_object_header ) ) { ND_PRINT ( ( ndo , "%sERROR:<S2SV_blank>object<S2SV_blank>header<S2SV_blank>too<S2SV_blank>short<S2SV_blank>%u<S2SV_blank><<S2SV_blank>%lu" , ident , rsvp_obj_len , ( unsigned long ) sizeof ( const struct rsvp_object_header ) ) ) ; return - 1 ; } ND_PRINT ( ( ndo , "%s%s<S2SV_blank>Object<S2SV_blank>(%u)<S2SV_blank>Flags:<S2SV_blank>[%s" , ident , tok2str ( rsvp_obj_values , "Unknown" , rsvp_obj_header -> class_num ) , rsvp_obj_header -> class_num , ( ( rsvp_obj_header -> class_num ) & 0x80 ) ? "ignore" : "reject" ) ) ; if ( rsvp_obj_header -> class_num > 128 ) ND_PRINT ( ( ndo , "<S2SV_blank>%s" , ( ( rsvp_obj_header -> class_num ) & 0x40 ) ? "and<S2SV_blank>forward" : "silently" ) ) ; ND_PRINT ( ( ndo , "<S2SV_blank>if<S2SV_blank>unknown],<S2SV_blank>Class-Type:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>length:<S2SV_blank>%u" , tok2str ( rsvp_ctype_values , "Unknown" , ( ( rsvp_obj_header -> class_num ) << 8 ) + rsvp_obj_ctype ) , rsvp_obj_ctype , rsvp_obj_len ) ) ; if ( tlen < rsvp_obj_len ) { ND_PRINT ( ( ndo , "%sERROR:<S2SV_blank>object<S2SV_blank>goes<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>objects<S2SV_blank>TLV" , ident ) ) ; return - 1 ; } obj_tptr = tptr + sizeof ( struct rsvp_object_header ) ; obj_tlen = rsvp_obj_len - sizeof ( struct rsvp_object_header ) ; if ( ! ND_TTEST2 ( * tptr , rsvp_obj_len ) ) return - 1 ; hexdump = FALSE ; switch ( rsvp_obj_header -> class_num ) { case RSVP_OBJ_SESSION : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_IPV4 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>IPv4<S2SV_blank>DestAddress:<S2SV_blank>%s,<S2SV_blank>Protocol<S2SV_blank>ID:<S2SV_blank>0x%02x" , ident , ipaddr_string ( ndo , obj_tptr ) , * ( obj_tptr + sizeof ( struct in_addr ) ) ) ) ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[0x%02x],<S2SV_blank>DestPort<S2SV_blank>%u" , ident , * ( obj_tptr + 5 ) , EXTRACT_16BITS ( obj_tptr + 6 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; break ; case RSVP_CTYPE_IPV6 : if ( obj_tlen < 20 ) return - 1 ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>IPv6<S2SV_blank>DestAddress:<S2SV_blank>%s,<S2SV_blank>Protocol<S2SV_blank>ID:<S2SV_blank>0x%02x" , ident , ip6addr_string ( ndo , obj_tptr ) , * ( obj_tptr + sizeof ( struct in6_addr ) ) ) ) ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[0x%02x],<S2SV_blank>DestPort<S2SV_blank>%u" , ident , * ( obj_tptr + sizeof ( struct in6_addr ) + 1 ) , EXTRACT_16BITS ( obj_tptr + sizeof ( struct in6_addr ) + 2 ) ) ) ; obj_tlen -= 20 ; obj_tptr += 20 ; break ; case RSVP_CTYPE_TUNNEL_IPV6 : if ( obj_tlen < 36 ) return - 1 ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>IPv6<S2SV_blank>Tunnel<S2SV_blank>EndPoint:<S2SV_blank>%s,<S2SV_blank>Tunnel<S2SV_blank>ID:<S2SV_blank>0x%04x,<S2SV_blank>Extended<S2SV_blank>Tunnel<S2SV_blank>ID:<S2SV_blank>%s" , ident , ip6addr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 18 ) , ip6addr_string ( ndo , obj_tptr + 20 ) ) ) ; obj_tlen -= 36 ; obj_tptr += 36 ; break ; case RSVP_CTYPE_14 : if ( obj_tlen < 26 ) return - 1 ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>IPv6<S2SV_blank>P2MP<S2SV_blank>LSP<S2SV_blank>ID:<S2SV_blank>0x%08x,<S2SV_blank>Tunnel<S2SV_blank>ID:<S2SV_blank>0x%04x,<S2SV_blank>Extended<S2SV_blank>Tunnel<S2SV_blank>ID:<S2SV_blank>%s" , ident , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) , ip6addr_string ( ndo , obj_tptr + 8 ) ) ) ; obj_tlen -= 26 ; obj_tptr += 26 ; break ; case RSVP_CTYPE_13 : if ( obj_tlen < 12 ) return - 1 ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>IPv4<S2SV_blank>P2MP<S2SV_blank>LSP<S2SV_blank>ID:<S2SV_blank>%s,<S2SV_blank>Tunnel<S2SV_blank>ID:<S2SV_blank>0x%04x,<S2SV_blank>Extended<S2SV_blank>Tunnel<S2SV_blank>ID:<S2SV_blank>%s" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) , ipaddr_string ( ndo , obj_tptr + 8 ) ) ) ; obj_tlen -= 12 ; obj_tptr += 12 ; break ; case RSVP_CTYPE_TUNNEL_IPV4 : case RSVP_CTYPE_UNI_IPV4 : if ( obj_tlen < 12 ) return - 1 ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>IPv4<S2SV_blank>Tunnel<S2SV_blank>EndPoint:<S2SV_blank>%s,<S2SV_blank>Tunnel<S2SV_blank>ID:<S2SV_blank>0x%04x,<S2SV_blank>Extended<S2SV_blank>Tunnel<S2SV_blank>ID:<S2SV_blank>%s" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) , ipaddr_string ( ndo , obj_tptr + 8 ) ) ) ; obj_tlen -= 12 ; obj_tptr += 12 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_CONFIRM : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_IPV4 : if ( obj_tlen < sizeof ( struct in_addr ) ) return - 1 ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>IPv4<S2SV_blank>Receiver<S2SV_blank>Address:<S2SV_blank>%s" , ident , ipaddr_string ( ndo , obj_tptr ) ) ) ; obj_tlen -= sizeof ( struct in_addr ) ; obj_tptr += sizeof ( struct in_addr ) ; break ; case RSVP_CTYPE_IPV6 : if ( obj_tlen < sizeof ( struct in6_addr ) ) return - 1 ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>IPv6<S2SV_blank>Receiver<S2SV_blank>Address:<S2SV_blank>%s" , ident , ip6addr_string ( ndo , obj_tptr ) ) ) ; obj_tlen -= sizeof ( struct in6_addr ) ; obj_tptr += sizeof ( struct in6_addr ) ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_NOTIFY_REQ : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_IPV4 : if ( obj_tlen < sizeof ( struct in_addr ) ) return - 1 ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>IPv4<S2SV_blank>Notify<S2SV_blank>Node<S2SV_blank>Address:<S2SV_blank>%s" , ident , ipaddr_string ( ndo , obj_tptr ) ) ) ; obj_tlen -= sizeof ( struct in_addr ) ; obj_tptr += sizeof ( struct in_addr ) ; break ; case RSVP_CTYPE_IPV6 : if ( obj_tlen < sizeof ( struct in6_addr ) ) return - 1 ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>IPv6<S2SV_blank>Notify<S2SV_blank>Node<S2SV_blank>Address:<S2SV_blank>%s" , ident , ip6addr_string ( ndo , obj_tptr ) ) ) ; obj_tlen -= sizeof ( struct in6_addr ) ; obj_tptr += sizeof ( struct in6_addr ) ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_SUGGESTED_LABEL : case RSVP_OBJ_UPSTREAM_LABEL : case RSVP_OBJ_RECOVERY_LABEL : case RSVP_OBJ_LABEL : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : while ( obj_tlen >= 4 ) { ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>Label:<S2SV_blank>%u" , ident , EXTRACT_32BITS ( obj_tptr ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; } break ; case RSVP_CTYPE_2 : if ( obj_tlen < 4 ) return - 1 ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>Generalized<S2SV_blank>Label:<S2SV_blank>%u" , ident , EXTRACT_32BITS ( obj_tptr ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; break ; case RSVP_CTYPE_3 : if ( obj_tlen < 12 ) return - 1 ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>Waveband<S2SV_blank>ID:<S2SV_blank>%u%s<S2SV_blank><S2SV_blank>Start<S2SV_blank>Label:<S2SV_blank>%u,<S2SV_blank>Stop<S2SV_blank>Label:<S2SV_blank>%u" , ident , EXTRACT_32BITS ( obj_tptr ) , ident , EXTRACT_32BITS ( obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 8 ) ) ) ; obj_tlen -= 12 ; obj_tptr += 12 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_STYLE : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < 4 ) return - 1 ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>Reservation<S2SV_blank>Style:<S2SV_blank>%s,<S2SV_blank>Flags:<S2SV_blank>[0x%02x]" , ident , tok2str ( rsvp_resstyle_values , "Unknown" , EXTRACT_24BITS ( obj_tptr + 1 ) ) , * ( obj_tptr ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_SENDER_TEMPLATE : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_IPV4 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>Source<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>Source<S2SV_blank>Port:<S2SV_blank>%u" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; break ; case RSVP_CTYPE_IPV6 : if ( obj_tlen < 20 ) return - 1 ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>Source<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>Source<S2SV_blank>Port:<S2SV_blank>%u" , ident , ip6addr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 18 ) ) ) ; obj_tlen -= 20 ; obj_tptr += 20 ; break ; case RSVP_CTYPE_13 : if ( obj_tlen < 40 ) return - 1 ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>IPv6<S2SV_blank>Tunnel<S2SV_blank>Sender<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>LSP<S2SV_blank>ID:<S2SV_blank>0x%04x" "%s<S2SV_blank><S2SV_blank>Sub-Group<S2SV_blank>Originator<S2SV_blank>ID:<S2SV_blank>%s,<S2SV_blank>Sub-Group<S2SV_blank>ID:<S2SV_blank>0x%04x" , ident , ip6addr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 18 ) , ident , ip6addr_string ( ndo , obj_tptr + 20 ) , EXTRACT_16BITS ( obj_tptr + 38 ) ) ) ; obj_tlen -= 40 ; obj_tptr += 40 ; break ; case RSVP_CTYPE_TUNNEL_IPV4 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>IPv4<S2SV_blank>Tunnel<S2SV_blank>Sender<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>LSP-ID:<S2SV_blank>0x%04x" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; break ; case RSVP_CTYPE_12 : if ( obj_tlen < 16 ) return - 1 ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>IPv4<S2SV_blank>Tunnel<S2SV_blank>Sender<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>LSP<S2SV_blank>ID:<S2SV_blank>0x%04x" "%s<S2SV_blank><S2SV_blank>Sub-Group<S2SV_blank>Originator<S2SV_blank>ID:<S2SV_blank>%s,<S2SV_blank>Sub-Group<S2SV_blank>ID:<S2SV_blank>0x%04x" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) , ident , ipaddr_string ( ndo , obj_tptr + 8 ) , EXTRACT_16BITS ( obj_tptr + 12 ) ) ) ; obj_tlen -= 16 ; obj_tptr += 16 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_LABEL_REQ : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : while ( obj_tlen >= 4 ) { ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>L3<S2SV_blank>Protocol<S2SV_blank>ID:<S2SV_blank>%s" , ident , tok2str ( ethertype_values , "Unknown<S2SV_blank>Protocol<S2SV_blank>(0x%04x)" , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; } break ; case RSVP_CTYPE_2 : if ( obj_tlen < 12 ) return - 1 ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>L3<S2SV_blank>Protocol<S2SV_blank>ID:<S2SV_blank>%s" , ident , tok2str ( ethertype_values , "Unknown<S2SV_blank>Protocol<S2SV_blank>(0x%04x)" , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ) ; ND_PRINT ( ( ndo , ",%s<S2SV_blank>merge<S2SV_blank>capability" , ( ( * ( obj_tptr + 4 ) ) & 0x80 ) ? "no" : "" ) ) ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>Minimum<S2SV_blank>VPI/VCI:<S2SV_blank>%u/%u" , ident , ( EXTRACT_16BITS ( obj_tptr + 4 ) ) & 0xfff , ( EXTRACT_16BITS ( obj_tptr + 6 ) ) & 0xfff ) ) ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>Maximum<S2SV_blank>VPI/VCI:<S2SV_blank>%u/%u" , ident , ( EXTRACT_16BITS ( obj_tptr + 8 ) ) & 0xfff , ( EXTRACT_16BITS ( obj_tptr + 10 ) ) & 0xfff ) ) ; obj_tlen -= 12 ; obj_tptr += 12 ; break ; case RSVP_CTYPE_3 : if ( obj_tlen < 12 ) return - 1 ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>L3<S2SV_blank>Protocol<S2SV_blank>ID:<S2SV_blank>%s" , ident , tok2str ( ethertype_values , "Unknown<S2SV_blank>Protocol<S2SV_blank>(0x%04x)" , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ) ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>Minimum/Maximum<S2SV_blank>DLCI:<S2SV_blank>%u/%u,<S2SV_blank>%s%s<S2SV_blank>bit<S2SV_blank>DLCI" , ident , ( EXTRACT_32BITS ( obj_tptr + 4 ) ) & 0x7fffff , ( EXTRACT_32BITS ( obj_tptr + 8 ) ) & 0x7fffff , ( ( ( EXTRACT_16BITS ( obj_tptr + 4 ) >> 7 ) & 3 ) == 0 ) ? "10" : "" , ( ( ( EXTRACT_16BITS ( obj_tptr + 4 ) >> 7 ) & 3 ) == 2 ) ? "23" : "" ) ) ; obj_tlen -= 12 ; obj_tptr += 12 ; break ; case RSVP_CTYPE_4 : if ( obj_tlen < 4 ) return - 1 ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>LSP<S2SV_blank>Encoding<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u)" , ident , tok2str ( gmpls_encoding_values , "Unknown" , * obj_tptr ) , * obj_tptr ) ) ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>Switching<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>Payload<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%04x)" , ident , tok2str ( gmpls_switch_cap_values , "Unknown" , * ( obj_tptr + 1 ) ) , * ( obj_tptr + 1 ) , tok2str ( gmpls_payload_values , "Unknown" , EXTRACT_16BITS ( obj_tptr + 2 ) ) , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_RRO : case RSVP_OBJ_ERO : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_IPV4 : while ( obj_tlen >= 4 ) { u_char length ; ND_TCHECK2 ( * obj_tptr , 4 ) ; length = * ( obj_tptr + 1 ) ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>Subobject<S2SV_blank>Type:<S2SV_blank>%s,<S2SV_blank>length<S2SV_blank>%u" , ident , tok2str ( rsvp_obj_xro_values , "Unknown<S2SV_blank>%u" , RSVP_OBJ_XRO_MASK_SUBOBJ ( * obj_tptr ) ) , length ) ) ; if ( length == 0 ) { ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>ERROR:<S2SV_blank>zero<S2SV_blank>length<S2SV_blank>ERO<S2SV_blank>subtype" , ident ) ) ; break ; } switch ( RSVP_OBJ_XRO_MASK_SUBOBJ ( * obj_tptr ) ) { u_char prefix_length ; case RSVP_OBJ_XRO_IPV4 : if ( length != 8 ) { ND_PRINT ( ( ndo , "<S2SV_blank>ERROR:<S2SV_blank>length<S2SV_blank>!=<S2SV_blank>8" ) ) ; goto invalid ; } ND_TCHECK2 ( * obj_tptr , 8 ) ; prefix_length = * ( obj_tptr + 6 ) ; if ( prefix_length != 32 ) { ND_PRINT ( ( ndo , "<S2SV_blank>ERROR:<S2SV_blank>Prefix<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>32" , prefix_length ) ) ; goto invalid ; } ND_PRINT ( ( ndo , ",<S2SV_blank>%s,<S2SV_blank>%s/%u,<S2SV_blank>Flags:<S2SV_blank>[%s]" , RSVP_OBJ_XRO_MASK_LOOSE ( * obj_tptr ) ? "Loose" : "Strict" , ipaddr_string ( ndo , obj_tptr + 2 ) , * ( obj_tptr + 6 ) , bittok2str ( rsvp_obj_rro_flag_values , "none" , * ( obj_tptr + 7 ) ) ) ) ; break ; case RSVP_OBJ_XRO_LABEL : if ( length != 8 ) { ND_PRINT ( ( ndo , "<S2SV_blank>ERROR:<S2SV_blank>length<S2SV_blank>!=<S2SV_blank>8" ) ) ; goto invalid ; } ND_TCHECK2 ( * obj_tptr , 8 ) ; ND_PRINT ( ( ndo , ",<S2SV_blank>Flags:<S2SV_blank>[%s]<S2SV_blank>(%#x),<S2SV_blank>Class-Type:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>%u" , bittok2str ( rsvp_obj_rro_label_flag_values , "none" , * ( obj_tptr + 2 ) ) , * ( obj_tptr + 2 ) , tok2str ( rsvp_ctype_values , "Unknown" , * ( obj_tptr + 3 ) + 256 * RSVP_OBJ_RRO ) , * ( obj_tptr + 3 ) , EXTRACT_32BITS ( obj_tptr + 4 ) ) ) ; } obj_tlen -= * ( obj_tptr + 1 ) ; obj_tptr += * ( obj_tptr + 1 ) ; } break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_HELLO : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : case RSVP_CTYPE_2 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>Source<S2SV_blank>Instance:<S2SV_blank>0x%08x,<S2SV_blank>Destination<S2SV_blank>Instance:<S2SV_blank>0x%08x" , ident , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr + 4 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_RESTART_CAPABILITY : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>Restart<S2SV_blank><S2SV_blank>Time:<S2SV_blank>%ums,<S2SV_blank>Recovery<S2SV_blank>Time:<S2SV_blank>%ums" , ident , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr + 4 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_SESSION_ATTRIBUTE : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_TUNNEL_IPV4 : if ( obj_tlen < 4 ) return - 1 ; namelen = * ( obj_tptr + 3 ) ; if ( obj_tlen < 4 + namelen ) return - 1 ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>Session<S2SV_blank>Name:<S2SV_blank>" , ident ) ) ; for ( i = 0 ; i < namelen ; i ++ ) safeputchar ( ndo , * ( obj_tptr + 4 + i ) ) ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>Setup<S2SV_blank>Priority:<S2SV_blank>%u,<S2SV_blank>Holding<S2SV_blank>Priority:<S2SV_blank>%u,<S2SV_blank>Flags:<S2SV_blank>[%s]<S2SV_blank>(%#x)" , ident , ( int ) * obj_tptr , ( int ) * ( obj_tptr + 1 ) , bittok2str ( rsvp_session_attribute_flag_values , "none" , * ( obj_tptr + 2 ) ) , * ( obj_tptr + 2 ) ) ) ; obj_tlen -= 4 + * ( obj_tptr + 3 ) ; obj_tptr += 4 + * ( obj_tptr + 3 ) ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_GENERALIZED_UNI : switch ( rsvp_obj_ctype ) { int subobj_type , af , subobj_len , total_subobj_len ; case RSVP_CTYPE_1 : if ( obj_tlen < 4 ) return - 1 ; total_subobj_len = obj_tlen ; while ( total_subobj_len > 0 ) { if ( total_subobj_len < 4 ) goto invalid ; subobj_len = EXTRACT_16BITS ( obj_tptr ) ; subobj_type = ( EXTRACT_16BITS ( obj_tptr + 2 ) ) >> 8 ; af = ( EXTRACT_16BITS ( obj_tptr + 2 ) ) & 0x00FF ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>Subobject<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>AF:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>length:<S2SV_blank>%u" , ident , tok2str ( rsvp_obj_generalized_uni_values , "Unknown" , subobj_type ) , subobj_type , tok2str ( af_values , "Unknown" , af ) , af , subobj_len ) ) ; if ( subobj_len < 4 || subobj_len > total_subobj_len ) goto invalid ; switch ( subobj_type ) { case RSVP_GEN_UNI_SUBOBJ_SOURCE_TNA_ADDRESS : case RSVP_GEN_UNI_SUBOBJ_DESTINATION_TNA_ADDRESS : switch ( af ) { case AFNUM_INET : if ( subobj_len < 8 ) return - 1 ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>UNI<S2SV_blank>IPv4<S2SV_blank>TNA<S2SV_blank>address:<S2SV_blank>%s" , ident , ipaddr_string ( ndo , obj_tptr + 4 ) ) ) ; break ; case AFNUM_INET6 : if ( subobj_len < 20 ) return - 1 ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>UNI<S2SV_blank>IPv6<S2SV_blank>TNA<S2SV_blank>address:<S2SV_blank>%s" , ident , ip6addr_string ( ndo , obj_tptr + 4 ) ) ) ; break ; case AFNUM_NSAP : if ( subobj_len ) { hexdump = TRUE ; } break ; } break ; case RSVP_GEN_UNI_SUBOBJ_DIVERSITY : if ( subobj_len ) { hexdump = TRUE ; } break ; case RSVP_GEN_UNI_SUBOBJ_EGRESS_LABEL : if ( subobj_len < 16 ) { return - 1 ; } ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>U-bit:<S2SV_blank>%x,<S2SV_blank>Label<S2SV_blank>type:<S2SV_blank>%u,<S2SV_blank>Logical<S2SV_blank>port<S2SV_blank>id:<S2SV_blank>%u,<S2SV_blank>Label:<S2SV_blank>%u" , ident , ( ( EXTRACT_32BITS ( obj_tptr + 4 ) ) >> 31 ) , ( ( EXTRACT_32BITS ( obj_tptr + 4 ) ) & 0xFF ) , EXTRACT_32BITS ( obj_tptr + 8 ) , EXTRACT_32BITS ( obj_tptr + 12 ) ) ) ; break ; case RSVP_GEN_UNI_SUBOBJ_SERVICE_LEVEL : if ( subobj_len < 8 ) { return - 1 ; } ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Service<S2SV_blank>level:<S2SV_blank>%u" , ident , ( EXTRACT_32BITS ( obj_tptr + 4 ) ) >> 24 ) ) ; break ; default : hexdump = TRUE ; break ; } total_subobj_len -= subobj_len ; obj_tptr += subobj_len ; obj_tlen += subobj_len ; } if ( total_subobj_len ) { hexdump = TRUE ; } break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_RSVP_HOP : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_3 : case RSVP_CTYPE_IPV4 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>Previous/Next<S2SV_blank>Interface:<S2SV_blank>%s,<S2SV_blank>Logical<S2SV_blank>Interface<S2SV_blank>Handle:<S2SV_blank>0x%08x" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_32BITS ( obj_tptr + 4 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; if ( obj_tlen ) hexdump = TRUE ; break ; case RSVP_CTYPE_4 : case RSVP_CTYPE_IPV6 : if ( obj_tlen < 20 ) return - 1 ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>Previous/Next<S2SV_blank>Interface:<S2SV_blank>%s,<S2SV_blank>Logical<S2SV_blank>Interface<S2SV_blank>Handle:<S2SV_blank>0x%08x" , ident , ip6addr_string ( ndo , obj_tptr ) , EXTRACT_32BITS ( obj_tptr + 16 ) ) ) ; obj_tlen -= 20 ; obj_tptr += 20 ; hexdump = TRUE ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_TIME_VALUES : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < 4 ) return - 1 ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>Refresh<S2SV_blank>Period:<S2SV_blank>%ums" , ident , EXTRACT_32BITS ( obj_tptr ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_SENDER_TSPEC : case RSVP_OBJ_ADSPEC : case RSVP_OBJ_FLOWSPEC : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_2 : if ( obj_tlen < 4 ) return - 1 ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>Msg-Version:<S2SV_blank>%u,<S2SV_blank>length:<S2SV_blank>%u" , ident , ( * obj_tptr & 0xf0 ) >> 4 , EXTRACT_16BITS ( obj_tptr + 2 ) << 2 ) ) ; obj_tptr += 4 ; obj_tlen -= 4 ; while ( obj_tlen >= 4 ) { intserv_serv_tlen = EXTRACT_16BITS ( obj_tptr + 2 ) << 2 ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>Service<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>break<S2SV_blank>bit<S2SV_blank>%s<S2SV_blank>set,<S2SV_blank>Service<S2SV_blank>length:<S2SV_blank>%u" , ident , tok2str ( rsvp_intserv_service_type_values , "unknown" , * ( obj_tptr ) ) , * ( obj_tptr ) , ( * ( obj_tptr + 1 ) & 0x80 ) ? "" : "not" , intserv_serv_tlen ) ) ; obj_tptr += 4 ; obj_tlen -= 4 ; while ( intserv_serv_tlen >= 4 ) { processed = rsvp_intserv_print ( ndo , obj_tptr , obj_tlen ) ; if ( processed == 0 ) break ; obj_tlen -= processed ; intserv_serv_tlen -= processed ; obj_tptr += processed ; } } break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_FILTERSPEC : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_IPV4 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>Source<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>Source<S2SV_blank>Port:<S2SV_blank>%u" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; break ; case RSVP_CTYPE_IPV6 : if ( obj_tlen < 20 ) return - 1 ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>Source<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>Source<S2SV_blank>Port:<S2SV_blank>%u" , ident , ip6addr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 18 ) ) ) ; obj_tlen -= 20 ; obj_tptr += 20 ; break ; case RSVP_CTYPE_3 : if ( obj_tlen < 20 ) return - 1 ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>Source<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>Flow<S2SV_blank>Label:<S2SV_blank>%u" , ident , ip6addr_string ( ndo , obj_tptr ) , EXTRACT_24BITS ( obj_tptr + 17 ) ) ) ; obj_tlen -= 20 ; obj_tptr += 20 ; break ; case RSVP_CTYPE_TUNNEL_IPV6 : if ( obj_tlen < 20 ) return - 1 ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>Source<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>LSP-ID:<S2SV_blank>0x%04x" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 18 ) ) ) ; obj_tlen -= 20 ; obj_tptr += 20 ; break ; case RSVP_CTYPE_13 : if ( obj_tlen < 40 ) return - 1 ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>IPv6<S2SV_blank>Tunnel<S2SV_blank>Sender<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>LSP<S2SV_blank>ID:<S2SV_blank>0x%04x" "%s<S2SV_blank><S2SV_blank>Sub-Group<S2SV_blank>Originator<S2SV_blank>ID:<S2SV_blank>%s,<S2SV_blank>Sub-Group<S2SV_blank>ID:<S2SV_blank>0x%04x" , ident , ip6addr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 18 ) , ident , ip6addr_string ( ndo , obj_tptr + 20 ) , EXTRACT_16BITS ( obj_tptr + 38 ) ) ) ; obj_tlen -= 40 ; obj_tptr += 40 ; break ; case RSVP_CTYPE_TUNNEL_IPV4 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>Source<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>LSP-ID:<S2SV_blank>0x%04x" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; break ; case RSVP_CTYPE_12 : if ( obj_tlen < 16 ) return - 1 ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>IPv4<S2SV_blank>Tunnel<S2SV_blank>Sender<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>LSP<S2SV_blank>ID:<S2SV_blank>0x%04x" "%s<S2SV_blank><S2SV_blank>Sub-Group<S2SV_blank>Originator<S2SV_blank>ID:<S2SV_blank>%s,<S2SV_blank>Sub-Group<S2SV_blank>ID:<S2SV_blank>0x%04x" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) , ident , ipaddr_string ( ndo , obj_tptr + 8 ) , EXTRACT_16BITS ( obj_tptr + 12 ) ) ) ; obj_tlen -= 16 ; obj_tptr += 16 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_FASTREROUTE : obj_ptr . rsvp_obj_frr = ( const struct rsvp_obj_frr_t * ) obj_tptr ; switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < sizeof ( struct rsvp_obj_frr_t ) ) return - 1 ; bw . i = EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> bandwidth ) ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>Setup<S2SV_blank>Priority:<S2SV_blank>%u,<S2SV_blank>Holding<S2SV_blank>Priority:<S2SV_blank>%u,<S2SV_blank>Hop-limit:<S2SV_blank>%u,<S2SV_blank>Bandwidth:<S2SV_blank>%.10g<S2SV_blank>Mbps" , ident , ( int ) obj_ptr . rsvp_obj_frr -> setup_prio , ( int ) obj_ptr . rsvp_obj_frr -> hold_prio , ( int ) obj_ptr . rsvp_obj_frr -> hop_limit , bw . f * 8 / 1000000 ) ) ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>Include-any:<S2SV_blank>0x%08x,<S2SV_blank>Exclude-any:<S2SV_blank>0x%08x,<S2SV_blank>Include-all:<S2SV_blank>0x%08x" , ident , EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> include_any ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> exclude_any ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> include_all ) ) ) ; obj_tlen -= sizeof ( struct rsvp_obj_frr_t ) ; obj_tptr += sizeof ( struct rsvp_obj_frr_t ) ; break ; case RSVP_CTYPE_TUNNEL_IPV4 : if ( obj_tlen < 16 ) return - 1 ; bw . i = EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> bandwidth ) ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>Setup<S2SV_blank>Priority:<S2SV_blank>%u,<S2SV_blank>Holding<S2SV_blank>Priority:<S2SV_blank>%u,<S2SV_blank>Hop-limit:<S2SV_blank>%u,<S2SV_blank>Bandwidth:<S2SV_blank>%.10g<S2SV_blank>Mbps" , ident , ( int ) obj_ptr . rsvp_obj_frr -> setup_prio , ( int ) obj_ptr . rsvp_obj_frr -> hold_prio , ( int ) obj_ptr . rsvp_obj_frr -> hop_limit , bw . f * 8 / 1000000 ) ) ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>Include<S2SV_blank>Colors:<S2SV_blank>0x%08x,<S2SV_blank>Exclude<S2SV_blank>Colors:<S2SV_blank>0x%08x" , ident , EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> include_any ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> exclude_any ) ) ) ; obj_tlen -= 16 ; obj_tptr += 16 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_DETOUR : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_TUNNEL_IPV4 : while ( obj_tlen >= 8 ) { ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>PLR-ID:<S2SV_blank>%s,<S2SV_blank>Avoid-Node-ID:<S2SV_blank>%s" , ident , ipaddr_string ( ndo , obj_tptr ) , ipaddr_string ( ndo , obj_tptr + 4 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; } break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_CLASSTYPE : case RSVP_OBJ_CLASSTYPE_OLD : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : <S2SV_StartBug> ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>CT:<S2SV_blank>%u" , <S2SV_EndBug> ident , EXTRACT_32BITS ( obj_tptr ) & 0x7 ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_ERROR_SPEC : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_3 : case RSVP_CTYPE_IPV4 : if ( obj_tlen < 8 ) return - 1 ; error_code = * ( obj_tptr + 5 ) ; error_value = EXTRACT_16BITS ( obj_tptr + 6 ) ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>Error<S2SV_blank>Node<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>Flags:<S2SV_blank>[0x%02x]%s<S2SV_blank><S2SV_blank>Error<S2SV_blank>Code:<S2SV_blank>%s<S2SV_blank>(%u)" , ident , ipaddr_string ( ndo , obj_tptr ) , * ( obj_tptr + 4 ) , ident , tok2str ( rsvp_obj_error_code_values , "unknown" , error_code ) , error_code ) ) ; switch ( error_code ) { case RSVP_OBJ_ERROR_SPEC_CODE_ROUTING : ND_PRINT ( ( ndo , ",<S2SV_blank>Error<S2SV_blank>Value:<S2SV_blank>%s<S2SV_blank>(%u)" , tok2str ( rsvp_obj_error_code_routing_values , "unknown" , error_value ) , error_value ) ) ; break ; case RSVP_OBJ_ERROR_SPEC_CODE_DIFFSERV_TE : case RSVP_OBJ_ERROR_SPEC_CODE_DIFFSERV_TE_OLD : ND_PRINT ( ( ndo , ",<S2SV_blank>Error<S2SV_blank>Value:<S2SV_blank>%s<S2SV_blank>(%u)" , tok2str ( rsvp_obj_error_code_diffserv_te_values , "unknown" , error_value ) , error_value ) ) ; break ; default : ND_PRINT ( ( ndo , ",<S2SV_blank>Unknown<S2SV_blank>Error<S2SV_blank>Value<S2SV_blank>(%u)" , error_value ) ) ; break ; } obj_tlen -= 8 ; obj_tptr += 8 ; break ; case RSVP_CTYPE_4 : case RSVP_CTYPE_IPV6 : if ( obj_tlen < 20 ) return - 1 ; error_code = * ( obj_tptr + 17 ) ; error_value = EXTRACT_16BITS ( obj_tptr + 18 ) ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>Error<S2SV_blank>Node<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>Flags:<S2SV_blank>[0x%02x]%s<S2SV_blank><S2SV_blank>Error<S2SV_blank>Code:<S2SV_blank>%s<S2SV_blank>(%u)" , ident , ip6addr_string ( ndo , obj_tptr ) , * ( obj_tptr + 16 ) , ident , tok2str ( rsvp_obj_error_code_values , "unknown" , error_code ) , error_code ) ) ; switch ( error_code ) { case RSVP_OBJ_ERROR_SPEC_CODE_ROUTING : ND_PRINT ( ( ndo , ",<S2SV_blank>Error<S2SV_blank>Value:<S2SV_blank>%s<S2SV_blank>(%u)" , tok2str ( rsvp_obj_error_code_routing_values , "unknown" , error_value ) , error_value ) ) ; break ; default : break ; } obj_tlen -= 20 ; obj_tptr += 20 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_PROPERTIES : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < 4 ) return - 1 ; padbytes = EXTRACT_16BITS ( obj_tptr + 2 ) ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>TLV<S2SV_blank>count:<S2SV_blank>%u,<S2SV_blank>padding<S2SV_blank>bytes:<S2SV_blank>%u" , ident , EXTRACT_16BITS ( obj_tptr ) , padbytes ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; while ( obj_tlen >= 2 + padbytes ) { ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>TLV<S2SV_blank>(0x%02x),<S2SV_blank>length:<S2SV_blank>%u" , ident , tok2str ( rsvp_obj_prop_tlv_values , "unknown" , * obj_tptr ) , * obj_tptr , * ( obj_tptr + 1 ) ) ) ; if ( obj_tlen < * ( obj_tptr + 1 ) ) return - 1 ; if ( * ( obj_tptr + 1 ) < 2 ) return - 1 ; print_unknown_data ( ndo , obj_tptr + 2 , "\\n\\t\\t" , * ( obj_tptr + 1 ) - 2 ) ; obj_tlen -= * ( obj_tptr + 1 ) ; obj_tptr += * ( obj_tptr + 1 ) ; } break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_MESSAGE_ID : case RSVP_OBJ_MESSAGE_ID_ACK : case RSVP_OBJ_MESSAGE_ID_LIST : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : case RSVP_CTYPE_2 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>Flags<S2SV_blank>[0x%02x],<S2SV_blank>epoch:<S2SV_blank>%u" , ident , * obj_tptr , EXTRACT_24BITS ( obj_tptr + 1 ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; while ( obj_tlen >= 4 ) { ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Message-ID<S2SV_blank>0x%08x<S2SV_blank>(%u)" , ident , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; } break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_INTEGRITY : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < sizeof ( struct rsvp_obj_integrity_t ) ) return - 1 ; obj_ptr . rsvp_obj_integrity = ( const struct rsvp_obj_integrity_t * ) obj_tptr ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>Key-ID<S2SV_blank>0x%04x%08x,<S2SV_blank>Sequence<S2SV_blank>0x%08x%08x,<S2SV_blank>Flags<S2SV_blank>[%s]" , ident , EXTRACT_16BITS ( obj_ptr . rsvp_obj_integrity -> key_id ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_integrity -> key_id + 2 ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_integrity -> sequence ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_integrity -> sequence + 4 ) , bittok2str ( rsvp_obj_integrity_flag_values , "none" , obj_ptr . rsvp_obj_integrity -> flags ) ) ) ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>MD5-sum<S2SV_blank>0x%08x%08x%08x%08x<S2SV_blank>" , ident , EXTRACT_32BITS ( obj_ptr . rsvp_obj_integrity -> digest ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_integrity -> digest + 4 ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_integrity -> digest + 8 ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_integrity -> digest + 12 ) ) ) ; sigcheck = signature_verify ( ndo , pptr , plen , obj_ptr . rsvp_obj_integrity -> digest , rsvp_clear_checksum , rsvp_com_header ) ; ND_PRINT ( ( ndo , "<S2SV_blank>(%s)" , tok2str ( signature_check_values , "Unknown" , sigcheck ) ) ) ; obj_tlen += sizeof ( struct rsvp_obj_integrity_t ) ; obj_tptr += sizeof ( struct rsvp_obj_integrity_t ) ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_ADMIN_STATUS : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < 4 ) return - 1 ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>Flags<S2SV_blank>[%s]" , ident , bittok2str ( rsvp_obj_admin_status_flag_values , "none" , EXTRACT_32BITS ( obj_tptr ) ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_LABEL_SET : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < 4 ) return - 1 ; action = ( EXTRACT_16BITS ( obj_tptr ) >> 8 ) ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>Action:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>Label<S2SV_blank>type:<S2SV_blank>%u" , ident , tok2str ( rsvp_obj_label_set_action_values , "Unknown" , action ) , action , ( ( EXTRACT_32BITS ( obj_tptr ) & 0x7F ) ) ) ) ; switch ( action ) { case LABEL_SET_INCLUSIVE_RANGE : case LABEL_SET_EXCLUSIVE_RANGE : if ( obj_tlen < 12 ) return - 1 ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>Start<S2SV_blank>range:<S2SV_blank>%u,<S2SV_blank>End<S2SV_blank>range:<S2SV_blank>%u" , ident , EXTRACT_32BITS ( obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 8 ) ) ) ; obj_tlen -= 12 ; obj_tptr += 12 ; break ; default : obj_tlen -= 4 ; obj_tptr += 4 ; subchannel = 1 ; while ( obj_tlen >= 4 ) { ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>Subchannel<S2SV_blank>#%u:<S2SV_blank>%u" , ident , subchannel , EXTRACT_32BITS ( obj_tptr ) ) ) ; obj_tptr += 4 ; obj_tlen -= 4 ; subchannel ++ ; } break ; } break ; default : hexdump = TRUE ; } case RSVP_OBJ_S2L : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_IPV4 : if ( obj_tlen < 4 ) return - 1 ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>Sub-LSP<S2SV_blank>destination<S2SV_blank>address:<S2SV_blank>%s" , ident , ipaddr_string ( ndo , obj_tptr ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; break ; case RSVP_CTYPE_IPV6 : if ( obj_tlen < 16 ) return - 1 ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>Sub-LSP<S2SV_blank>destination<S2SV_blank>address:<S2SV_blank>%s" , ident , ip6addr_string ( ndo , obj_tptr ) ) ) ; obj_tlen -= 16 ; obj_tptr += 16 ; break ; default : hexdump = TRUE ; } case RSVP_OBJ_SCOPE : case RSVP_OBJ_POLICY_DATA : case RSVP_OBJ_ACCEPT_LABEL_SET : case RSVP_OBJ_PROTECTION : default : if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , obj_tptr , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , obj_tlen ) ; break ; } if ( ndo -> ndo_vflag > 1 || hexdump == TRUE ) print_unknown_data ( ndo , tptr + sizeof ( struct rsvp_object_header ) , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , rsvp_obj_len - sizeof ( struct rsvp_object_header ) ) ; tptr += rsvp_obj_len ; tlen -= rsvp_obj_len ; } return 0 ; invalid : ND_PRINT ( ( ndo , "%s" , istr ) ) ; return - 1 ; trunc : ND_PRINT ( ( ndo , "\\n\\t\\t" ) ) ; ND_PRINT ( ( ndo , "%s" , tstr ) ) ; return - 1 ; }
CWE-125 static int rx_cache_find ( const struct rx_header * rxh , const struct ip * ip , int sport , int32_t * opcode ) { int i ; struct rx_cache_entry * rxent ; uint32_t clip ; uint32_t sip ; UNALIGNED_MEMCPY ( & clip , & ip -> ip_dst , sizeof ( uint32_t ) ) ; UNALIGNED_MEMCPY ( & sip , & ip -> ip_src , sizeof ( uint32_t ) ) ; i = rx_cache_hint ; do { rxent = & rx_cache [ i ] ; if ( rxent -> callnum == EXTRACT_32BITS ( & rxh -> callNumber ) && rxent -> client . s_addr == clip && rxent -> server . s_addr == sip && <S2SV_StartBug> rxent -> serviceId == EXTRACT_32BITS ( & rxh -> serviceId ) && <S2SV_EndBug> rxent -> dport == sport ) { rx_cache_hint = i ; * opcode = rxent -> opcode ; return ( 1 ) ; } if ( ++ i >= RX_CACHE_SIZE ) i = 0 ; } while ( i != rx_cache_hint ) ; return ( 0 ) ; }
CWE-125 static void rx_cache_insert ( netdissect_options * ndo , const u_char * bp , const struct ip * ip , int dport ) { struct rx_cache_entry * rxent ; const struct rx_header * rxh = ( const struct rx_header * ) bp ; if ( ndo -> ndo_snapend - bp + 1 <= ( int ) ( sizeof ( struct rx_header ) + sizeof ( int32_t ) ) ) return ; rxent = & rx_cache [ rx_cache_next ] ; if ( ++ rx_cache_next >= RX_CACHE_SIZE ) rx_cache_next = 0 ; rxent -> callnum = EXTRACT_32BITS ( & rxh -> callNumber ) ; UNALIGNED_MEMCPY ( & rxent -> client , & ip -> ip_src , sizeof ( uint32_t ) ) ; UNALIGNED_MEMCPY ( & rxent -> server , & ip -> ip_dst , sizeof ( uint32_t ) ) ; rxent -> dport = dport ; <S2SV_StartBug> rxent -> serviceId = EXTRACT_32BITS ( & rxh -> serviceId ) ; <S2SV_EndBug> rxent -> opcode = EXTRACT_32BITS ( bp + sizeof ( struct rx_header ) ) ; }
CWE-125 static void icmp6_nodeinfo_print ( netdissect_options * ndo , u_int icmp6len , const u_char * bp , const u_char * ep ) { const struct icmp6_nodeinfo * ni6 ; const struct icmp6_hdr * dp ; const u_char * cp ; size_t siz , i ; int needcomma ; if ( ep < bp ) return ; dp = ( const struct icmp6_hdr * ) bp ; ni6 = ( const struct icmp6_nodeinfo * ) bp ; siz = ep - bp ; switch ( ni6 -> ni_type ) { case ICMP6_NI_QUERY : if ( siz == sizeof ( * dp ) + 4 ) { ND_PRINT ( ( ndo , "<S2SV_blank>who-are-you<S2SV_blank>request" ) ) ; break ; } ND_PRINT ( ( ndo , "<S2SV_blank>node<S2SV_blank>information<S2SV_blank>query" ) ) ; ND_TCHECK2 ( * dp , sizeof ( * ni6 ) ) ; ni6 = ( const struct icmp6_nodeinfo * ) dp ; ND_PRINT ( ( ndo , "<S2SV_blank>(" ) ) ; switch ( EXTRACT_16BITS ( & ni6 -> ni_qtype ) ) { case NI_QTYPE_NOOP : ND_PRINT ( ( ndo , "noop" ) ) ; break ; case NI_QTYPE_SUPTYPES : ND_PRINT ( ( ndo , "supported<S2SV_blank>qtypes" ) ) ; i = EXTRACT_16BITS ( & ni6 -> ni_flags ) ; if ( i ) ND_PRINT ( ( ndo , "<S2SV_blank>[%s]" , ( i & 0x01 ) ? "C" : "" ) ) ; break ; case NI_QTYPE_FQDN : ND_PRINT ( ( ndo , "DNS<S2SV_blank>name" ) ) ; break ; case NI_QTYPE_NODEADDR : ND_PRINT ( ( ndo , "node<S2SV_blank>addresses" ) ) ; i = ni6 -> ni_flags ; if ( ! i ) break ; ND_PRINT ( ( ndo , "<S2SV_blank>[%s%s%s%s%s%s]" , ( i & NI_NODEADDR_FLAG_ANYCAST ) ? "a" : "" , ( i & NI_NODEADDR_FLAG_GLOBAL ) ? "G" : "" , ( i & NI_NODEADDR_FLAG_SITELOCAL ) ? "S" : "" , ( i & NI_NODEADDR_FLAG_LINKLOCAL ) ? "L" : "" , ( i & NI_NODEADDR_FLAG_COMPAT ) ? "C" : "" , ( i & NI_NODEADDR_FLAG_ALL ) ? "A" : "" ) ) ; break ; default : ND_PRINT ( ( ndo , "unknown" ) ) ; break ; } if ( ni6 -> ni_qtype == NI_QTYPE_NOOP || ni6 -> ni_qtype == NI_QTYPE_SUPTYPES ) { if ( siz != sizeof ( * ni6 ) ) if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ",<S2SV_blank>invalid<S2SV_blank>len" ) ) ; ND_PRINT ( ( ndo , ")" ) ) ; break ; } if ( siz == sizeof ( * ni6 ) ) { ND_PRINT ( ( ndo , ",<S2SV_blank>03<S2SV_blank>draft" ) ) ; ND_PRINT ( ( ndo , ")" ) ) ; break ; } switch ( ni6 -> ni_code ) { case ICMP6_NI_SUBJ_IPV6 : if ( ! ND_TTEST2 ( * dp , sizeof ( * ni6 ) + sizeof ( struct in6_addr ) ) ) break ; if ( siz != sizeof ( * ni6 ) + sizeof ( struct in6_addr ) ) { if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ",<S2SV_blank>invalid<S2SV_blank>subject<S2SV_blank>len" ) ) ; break ; } ND_PRINT ( ( ndo , ",<S2SV_blank>subject=%s" , ip6addr_string ( ndo , ni6 + 1 ) ) ) ; break ; case ICMP6_NI_SUBJ_FQDN : ND_PRINT ( ( ndo , ",<S2SV_blank>subject=DNS<S2SV_blank>name" ) ) ; cp = ( const u_char * ) ( ni6 + 1 ) ; if ( cp [ 0 ] == ep - cp - 1 ) { if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ",<S2SV_blank>03<S2SV_blank>draft" ) ) ; cp ++ ; ND_PRINT ( ( ndo , ",<S2SV_blank>\\"" ) ) ; while ( cp < ep ) { safeputchar ( ndo , * cp ) ; cp ++ ; } ND_PRINT ( ( ndo , "\\"" ) ) ; } else dnsname_print ( ndo , cp , ep ) ; break ; case ICMP6_NI_SUBJ_IPV4 : if ( ! ND_TTEST2 ( * dp , sizeof ( * ni6 ) + sizeof ( struct in_addr ) ) ) break ; if ( siz != sizeof ( * ni6 ) + sizeof ( struct in_addr ) ) { if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ",<S2SV_blank>invalid<S2SV_blank>subject<S2SV_blank>len" ) ) ; break ; } ND_PRINT ( ( ndo , ",<S2SV_blank>subject=%s" , ipaddr_string ( ndo , ni6 + 1 ) ) ) ; break ; default : ND_PRINT ( ( ndo , ",<S2SV_blank>unknown<S2SV_blank>subject" ) ) ; break ; } ND_PRINT ( ( ndo , ")" ) ) ; break ; case ICMP6_NI_REPLY : if ( icmp6len > siz ) { ND_PRINT ( ( ndo , "[|icmp6:<S2SV_blank>node<S2SV_blank>information<S2SV_blank>reply]" ) ) ; break ; } needcomma = 0 ; ND_TCHECK2 ( * dp , sizeof ( * ni6 ) ) ; ni6 = ( const struct icmp6_nodeinfo * ) dp ; ND_PRINT ( ( ndo , "<S2SV_blank>node<S2SV_blank>information<S2SV_blank>reply" ) ) ; ND_PRINT ( ( ndo , "<S2SV_blank>(" ) ) ; switch ( ni6 -> ni_code ) { case ICMP6_NI_SUCCESS : if ( ndo -> ndo_vflag ) { ND_PRINT ( ( ndo , "success" ) ) ; needcomma ++ ; } break ; case ICMP6_NI_REFUSED : ND_PRINT ( ( ndo , "refused" ) ) ; needcomma ++ ; if ( siz != sizeof ( * ni6 ) ) if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ",<S2SV_blank>invalid<S2SV_blank>length" ) ) ; break ; case ICMP6_NI_UNKNOWN : ND_PRINT ( ( ndo , "unknown" ) ) ; needcomma ++ ; if ( siz != sizeof ( * ni6 ) ) if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ",<S2SV_blank>invalid<S2SV_blank>length" ) ) ; break ; } if ( ni6 -> ni_code != ICMP6_NI_SUCCESS ) { ND_PRINT ( ( ndo , ")" ) ) ; break ; } switch ( EXTRACT_16BITS ( & ni6 -> ni_qtype ) ) { case NI_QTYPE_NOOP : if ( needcomma ) ND_PRINT ( ( ndo , ",<S2SV_blank>" ) ) ; ND_PRINT ( ( ndo , "noop" ) ) ; if ( siz != sizeof ( * ni6 ) ) if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ",<S2SV_blank>invalid<S2SV_blank>length" ) ) ; break ; case NI_QTYPE_SUPTYPES : if ( needcomma ) ND_PRINT ( ( ndo , ",<S2SV_blank>" ) ) ; ND_PRINT ( ( ndo , "supported<S2SV_blank>qtypes" ) ) ; i = EXTRACT_16BITS ( & ni6 -> ni_flags ) ; if ( i ) ND_PRINT ( ( ndo , "<S2SV_blank>[%s]" , ( i & 0x01 ) ? "C" : "" ) ) ; break ; case NI_QTYPE_FQDN : if ( needcomma ) ND_PRINT ( ( ndo , ",<S2SV_blank>" ) ) ; ND_PRINT ( ( ndo , "DNS<S2SV_blank>name" ) ) ; cp = ( const u_char * ) ( ni6 + 1 ) + 4 ; ND_TCHECK ( cp [ 0 ] ) ; if ( cp [ 0 ] == ep - cp - 1 ) { if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ",<S2SV_blank>03<S2SV_blank>draft" ) ) ; cp ++ ; ND_PRINT ( ( ndo , ",<S2SV_blank>\\"" ) ) ; while ( cp < ep ) { safeputchar ( ndo , * cp ) ; cp ++ ; } ND_PRINT ( ( ndo , "\\"" ) ) ; } else dnsname_print ( ndo , cp , ep ) ; if ( ( EXTRACT_16BITS ( & ni6 -> ni_flags ) & 0x01 ) != 0 ) ND_PRINT ( ( ndo , "<S2SV_blank>[TTL=%u]" , EXTRACT_32BITS ( ni6 + 1 ) ) ) ; break ; case NI_QTYPE_NODEADDR : if ( needcomma ) ND_PRINT ( ( ndo , ",<S2SV_blank>" ) ) ; ND_PRINT ( ( ndo , "node<S2SV_blank>addresses" ) ) ; i = sizeof ( * ni6 ) ; while ( i < siz ) { if ( i + sizeof ( struct in6_addr ) + sizeof ( int32_t ) > siz ) break ; ND_PRINT ( ( ndo , "<S2SV_blank>%s" , ip6addr_string ( ndo , bp + i ) ) ) ; i += sizeof ( struct in6_addr ) ; ND_PRINT ( ( ndo , "(%d)" , ( int32_t ) EXTRACT_32BITS ( bp + i ) ) ) ; i += sizeof ( int32_t ) ; } i = ni6 -> ni_flags ; if ( ! i ) break ; ND_PRINT ( ( ndo , "<S2SV_blank>[%s%s%s%s%s%s%s]" , ( i & NI_NODEADDR_FLAG_ANYCAST ) ? "a" : "" , ( i & NI_NODEADDR_FLAG_GLOBAL ) ? "G" : "" , ( i & NI_NODEADDR_FLAG_SITELOCAL ) ? "S" : "" , ( i & NI_NODEADDR_FLAG_LINKLOCAL ) ? "L" : "" , ( i & NI_NODEADDR_FLAG_COMPAT ) ? "C" : "" , ( i & NI_NODEADDR_FLAG_ALL ) ? "A" : "" , ( i & NI_NODEADDR_FLAG_TRUNCATE ) ? "T" : "" ) ) ; break ; default : if ( needcomma ) ND_PRINT ( ( ndo , ",<S2SV_blank>" ) ) ; ND_PRINT ( ( ndo , "unknown" ) ) ; break ; } ND_PRINT ( ( ndo , ")" ) ) ; break ; } return ; trunc : <S2SV_StartBug> ND_PRINT ( ( ndo , "[|icmp6]" ) ) ; <S2SV_EndBug> }
CWE-125 static void icmp6_opt_print ( netdissect_options * ndo , const u_char * bp , int resid ) { const struct nd_opt_hdr * op ; const struct nd_opt_prefix_info * opp ; const struct nd_opt_mtu * opm ; const struct nd_opt_rdnss * oprd ; const struct nd_opt_dnssl * opds ; const struct nd_opt_advinterval * opa ; const struct nd_opt_homeagent_info * oph ; const struct nd_opt_route_info * opri ; const u_char * cp , * ep , * domp ; struct in6_addr in6 ; const struct in6_addr * in6p ; size_t l ; u_int i ; # define ECHECK ( var ) if ( ( const u_char * ) & ( var ) > ep - sizeof ( var ) ) return cp = bp ; ep = ndo -> ndo_snapend ; while ( cp < ep ) { op = ( const struct nd_opt_hdr * ) cp ; ECHECK ( op -> nd_opt_len ) ; if ( resid <= 0 ) return ; if ( op -> nd_opt_len == 0 ) goto trunc ; if ( cp + ( op -> nd_opt_len << 3 ) > ep ) goto trunc ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>option<S2SV_blank>(%u),<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>(%u):<S2SV_blank>" , tok2str ( icmp6_opt_values , "unknown" , op -> nd_opt_type ) , op -> nd_opt_type , op -> nd_opt_len << 3 , op -> nd_opt_len ) ) ; switch ( op -> nd_opt_type ) { case ND_OPT_SOURCE_LINKADDR : l = ( op -> nd_opt_len << 3 ) - 2 ; print_lladdr ( ndo , cp + 2 , l ) ; break ; case ND_OPT_TARGET_LINKADDR : l = ( op -> nd_opt_len << 3 ) - 2 ; print_lladdr ( ndo , cp + 2 , l ) ; break ; case ND_OPT_PREFIX_INFORMATION : opp = ( const struct nd_opt_prefix_info * ) op ; ND_TCHECK ( opp -> nd_opt_pi_prefix ) ; ND_PRINT ( ( ndo , "%s/%u%s,<S2SV_blank>Flags<S2SV_blank>[%s],<S2SV_blank>valid<S2SV_blank>time<S2SV_blank>%s" , ip6addr_string ( ndo , & opp -> nd_opt_pi_prefix ) , opp -> nd_opt_pi_prefix_len , ( op -> nd_opt_len != 4 ) ? "badlen" : "" , bittok2str ( icmp6_opt_pi_flag_values , "none" , opp -> nd_opt_pi_flags_reserved ) , get_lifetime ( EXTRACT_32BITS ( & opp -> nd_opt_pi_valid_time ) ) ) ) ; ND_PRINT ( ( ndo , ",<S2SV_blank>pref.<S2SV_blank>time<S2SV_blank>%s" , get_lifetime ( EXTRACT_32BITS ( & opp -> nd_opt_pi_preferred_time ) ) ) ) ; break ; case ND_OPT_REDIRECTED_HEADER : print_unknown_data ( ndo , bp , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , op -> nd_opt_len << 3 ) ; break ; case ND_OPT_MTU : opm = ( const struct nd_opt_mtu * ) op ; ND_TCHECK ( opm -> nd_opt_mtu_mtu ) ; ND_PRINT ( ( ndo , "<S2SV_blank>%u%s" , EXTRACT_32BITS ( & opm -> nd_opt_mtu_mtu ) , ( op -> nd_opt_len != 1 ) ? "bad<S2SV_blank>option<S2SV_blank>length" : "" ) ) ; break ; case ND_OPT_RDNSS : oprd = ( const struct nd_opt_rdnss * ) op ; l = ( op -> nd_opt_len - 1 ) / 2 ; ND_PRINT ( ( ndo , "<S2SV_blank>lifetime<S2SV_blank>%us," , EXTRACT_32BITS ( & oprd -> nd_opt_rdnss_lifetime ) ) ) ; for ( i = 0 ; i < l ; i ++ ) { ND_TCHECK ( oprd -> nd_opt_rdnss_addr [ i ] ) ; ND_PRINT ( ( ndo , "<S2SV_blank>addr:<S2SV_blank>%s" , ip6addr_string ( ndo , & oprd -> nd_opt_rdnss_addr [ i ] ) ) ) ; } break ; case ND_OPT_DNSSL : opds = ( const struct nd_opt_dnssl * ) op ; ND_PRINT ( ( ndo , "<S2SV_blank>lifetime<S2SV_blank>%us,<S2SV_blank>domain(s):" , EXTRACT_32BITS ( & opds -> nd_opt_dnssl_lifetime ) ) ) ; domp = cp + 8 ; while ( domp < cp + ( op -> nd_opt_len << 3 ) && * domp != '\\0' ) { ND_PRINT ( ( ndo , "<S2SV_blank>" ) ) ; if ( ( domp = ns_nprint ( ndo , domp , bp ) ) == NULL ) goto trunc ; } break ; case ND_OPT_ADVINTERVAL : opa = ( const struct nd_opt_advinterval * ) op ; ND_TCHECK ( opa -> nd_opt_adv_interval ) ; ND_PRINT ( ( ndo , "<S2SV_blank>%ums" , EXTRACT_32BITS ( & opa -> nd_opt_adv_interval ) ) ) ; break ; case ND_OPT_HOMEAGENT_INFO : oph = ( const struct nd_opt_homeagent_info * ) op ; ND_TCHECK ( oph -> nd_opt_hai_lifetime ) ; ND_PRINT ( ( ndo , "<S2SV_blank>preference<S2SV_blank>%u,<S2SV_blank>lifetime<S2SV_blank>%u" , EXTRACT_16BITS ( & oph -> nd_opt_hai_preference ) , EXTRACT_16BITS ( & oph -> nd_opt_hai_lifetime ) ) ) ; break ; case ND_OPT_ROUTE_INFO : opri = ( const struct nd_opt_route_info * ) op ; ND_TCHECK ( opri -> nd_opt_rti_lifetime ) ; memset ( & in6 , 0 , sizeof ( in6 ) ) ; in6p = ( const struct in6_addr * ) ( opri + 1 ) ; switch ( op -> nd_opt_len ) { case 1 : break ; case 2 : ND_TCHECK2 ( * in6p , 8 ) ; memcpy ( & in6 , opri + 1 , 8 ) ; break ; case 3 : ND_TCHECK ( * in6p ) ; memcpy ( & in6 , opri + 1 , sizeof ( in6 ) ) ; break ; default : goto trunc ; } ND_PRINT ( ( ndo , "<S2SV_blank>%s/%u" , ip6addr_string ( ndo , & in6 ) , opri -> nd_opt_rti_prefixlen ) ) ; ND_PRINT ( ( ndo , ",<S2SV_blank>pref=%s" , get_rtpref ( opri -> nd_opt_rti_flags ) ) ) ; ND_PRINT ( ( ndo , ",<S2SV_blank>lifetime=%s" , get_lifetime ( EXTRACT_32BITS ( & opri -> nd_opt_rti_lifetime ) ) ) ) ; break ; default : if ( ndo -> ndo_vflag <= 1 ) { print_unknown_data ( ndo , cp + 2 , "\\n\\t<S2SV_blank><S2SV_blank>" , ( op -> nd_opt_len << 3 ) - 2 ) ; return ; } break ; } if ( ndo -> ndo_vflag > 1 ) print_unknown_data ( ndo , cp + 2 , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , ( op -> nd_opt_len << 3 ) - 2 ) ; cp += op -> nd_opt_len << 3 ; resid -= op -> nd_opt_len << 3 ; } return ; trunc : <S2SV_StartBug> ND_PRINT ( ( ndo , "[ndp<S2SV_blank>opt]" ) ) ; <S2SV_EndBug> return ; # undef ECHECK }
CWE-125 void icmp6_print ( netdissect_options * ndo , const u_char * bp , u_int length , const u_char * bp2 , int fragmented ) { const struct icmp6_hdr * dp ; const struct ip6_hdr * ip ; const struct ip6_hdr * oip ; const struct udphdr * ouh ; int dport ; const u_char * ep ; u_int prot ; dp = ( const struct icmp6_hdr * ) bp ; ip = ( const struct ip6_hdr * ) bp2 ; oip = ( const struct ip6_hdr * ) ( dp + 1 ) ; ep = ndo -> ndo_snapend ; ND_TCHECK ( dp -> icmp6_cksum ) ; if ( ndo -> ndo_vflag && ! fragmented ) { uint16_t sum , udp_sum ; if ( ND_TTEST2 ( bp [ 0 ] , length ) ) { udp_sum = EXTRACT_16BITS ( & dp -> icmp6_cksum ) ; sum = icmp6_cksum ( ndo , ip , dp , length ) ; if ( sum != 0 ) ND_PRINT ( ( ndo , "[bad<S2SV_blank>icmp6<S2SV_blank>cksum<S2SV_blank>0x%04x<S2SV_blank>-><S2SV_blank>0x%04x!]<S2SV_blank>" , udp_sum , in_cksum_shouldbe ( udp_sum , sum ) ) ) ; else ND_PRINT ( ( ndo , "[icmp6<S2SV_blank>sum<S2SV_blank>ok]<S2SV_blank>" ) ) ; } } ND_PRINT ( ( ndo , "ICMP6,<S2SV_blank>%s" , tok2str ( icmp6_type_values , "unknown<S2SV_blank>icmp6<S2SV_blank>type<S2SV_blank>(%u)" , dp -> icmp6_type ) ) ) ; if ( ndo -> ndo_vflag && ( dp -> icmp6_type == ND_ROUTER_SOLICIT || dp -> icmp6_type == ND_ROUTER_ADVERT || dp -> icmp6_type == ND_NEIGHBOR_ADVERT || dp -> icmp6_type == ND_NEIGHBOR_SOLICIT || dp -> icmp6_type == ND_REDIRECT || dp -> icmp6_type == ICMP6_HADISCOV_REPLY || dp -> icmp6_type == ICMP6_MOBILEPREFIX_ADVERT ) ) ND_PRINT ( ( ndo , ",<S2SV_blank>length<S2SV_blank>%u" , length ) ) ; switch ( dp -> icmp6_type ) { case ICMP6_DST_UNREACH : ND_TCHECK ( oip -> ip6_dst ) ; ND_PRINT ( ( ndo , ",<S2SV_blank>%s" , tok2str ( icmp6_dst_unreach_code_values , "unknown<S2SV_blank>unreach<S2SV_blank>code<S2SV_blank>(%u)" , dp -> icmp6_code ) ) ) ; switch ( dp -> icmp6_code ) { case ICMP6_DST_UNREACH_NOROUTE : case ICMP6_DST_UNREACH_ADMIN : case ICMP6_DST_UNREACH_ADDR : ND_PRINT ( ( ndo , "<S2SV_blank>%s" , ip6addr_string ( ndo , & oip -> ip6_dst ) ) ) ; break ; case ICMP6_DST_UNREACH_BEYONDSCOPE : ND_PRINT ( ( ndo , "<S2SV_blank>%s,<S2SV_blank>source<S2SV_blank>address<S2SV_blank>%s" , ip6addr_string ( ndo , & oip -> ip6_dst ) , ip6addr_string ( ndo , & oip -> ip6_src ) ) ) ; break ; case ICMP6_DST_UNREACH_NOPORT : if ( ( ouh = get_upperlayer ( ndo , ( const u_char * ) oip , & prot ) ) == NULL ) goto trunc ; dport = EXTRACT_16BITS ( & ouh -> uh_dport ) ; switch ( prot ) { case IPPROTO_TCP : ND_PRINT ( ( ndo , ",<S2SV_blank>%s<S2SV_blank>tcp<S2SV_blank>port<S2SV_blank>%s" , ip6addr_string ( ndo , & oip -> ip6_dst ) , tcpport_string ( ndo , dport ) ) ) ; break ; case IPPROTO_UDP : ND_PRINT ( ( ndo , ",<S2SV_blank>%s<S2SV_blank>udp<S2SV_blank>port<S2SV_blank>%s" , ip6addr_string ( ndo , & oip -> ip6_dst ) , udpport_string ( ndo , dport ) ) ) ; break ; default : ND_PRINT ( ( ndo , ",<S2SV_blank>%s<S2SV_blank>protocol<S2SV_blank>%d<S2SV_blank>port<S2SV_blank>%d<S2SV_blank>unreachable" , ip6addr_string ( ndo , & oip -> ip6_dst ) , oip -> ip6_nxt , dport ) ) ; break ; } break ; default : if ( ndo -> ndo_vflag <= 1 ) { print_unknown_data ( ndo , bp , "\\n\\t" , length ) ; return ; } break ; } break ; case ICMP6_PACKET_TOO_BIG : ND_TCHECK ( dp -> icmp6_mtu ) ; ND_PRINT ( ( ndo , ",<S2SV_blank>mtu<S2SV_blank>%u" , EXTRACT_32BITS ( & dp -> icmp6_mtu ) ) ) ; break ; case ICMP6_TIME_EXCEEDED : ND_TCHECK ( oip -> ip6_dst ) ; switch ( dp -> icmp6_code ) { case ICMP6_TIME_EXCEED_TRANSIT : ND_PRINT ( ( ndo , "<S2SV_blank>for<S2SV_blank>%s" , ip6addr_string ( ndo , & oip -> ip6_dst ) ) ) ; break ; case ICMP6_TIME_EXCEED_REASSEMBLY : ND_PRINT ( ( ndo , "<S2SV_blank>(reassembly)" ) ) ; break ; default : ND_PRINT ( ( ndo , ",<S2SV_blank>unknown<S2SV_blank>code<S2SV_blank>(%u)" , dp -> icmp6_code ) ) ; break ; } break ; case ICMP6_PARAM_PROB : ND_TCHECK ( oip -> ip6_dst ) ; switch ( dp -> icmp6_code ) { case ICMP6_PARAMPROB_HEADER : ND_PRINT ( ( ndo , ",<S2SV_blank>erroneous<S2SV_blank>-<S2SV_blank>octet<S2SV_blank>%u" , EXTRACT_32BITS ( & dp -> icmp6_pptr ) ) ) ; break ; case ICMP6_PARAMPROB_NEXTHEADER : ND_PRINT ( ( ndo , ",<S2SV_blank>next<S2SV_blank>header<S2SV_blank>-<S2SV_blank>octet<S2SV_blank>%u" , EXTRACT_32BITS ( & dp -> icmp6_pptr ) ) ) ; break ; case ICMP6_PARAMPROB_OPTION : ND_PRINT ( ( ndo , ",<S2SV_blank>option<S2SV_blank>-<S2SV_blank>octet<S2SV_blank>%u" , EXTRACT_32BITS ( & dp -> icmp6_pptr ) ) ) ; break ; default : ND_PRINT ( ( ndo , ",<S2SV_blank>code-#%d" , dp -> icmp6_code ) ) ; break ; } break ; case ICMP6_ECHO_REQUEST : case ICMP6_ECHO_REPLY : ND_TCHECK ( dp -> icmp6_seq ) ; ND_PRINT ( ( ndo , ",<S2SV_blank>seq<S2SV_blank>%u" , EXTRACT_16BITS ( & dp -> icmp6_seq ) ) ) ; break ; case ICMP6_MEMBERSHIP_QUERY : if ( length == MLD_MINLEN ) { mld6_print ( ndo , ( const u_char * ) dp ) ; } else if ( length >= MLDV2_MINLEN ) { ND_PRINT ( ( ndo , "<S2SV_blank>v2" ) ) ; mldv2_query_print ( ndo , ( const u_char * ) dp , length ) ; } else { ND_PRINT ( ( ndo , "<S2SV_blank>unknown-version<S2SV_blank>(len<S2SV_blank>%u)<S2SV_blank>" , length ) ) ; } break ; case ICMP6_MEMBERSHIP_REPORT : mld6_print ( ndo , ( const u_char * ) dp ) ; break ; case ICMP6_MEMBERSHIP_REDUCTION : mld6_print ( ndo , ( const u_char * ) dp ) ; break ; case ND_ROUTER_SOLICIT : # define RTSOLLEN 8 if ( ndo -> ndo_vflag ) { icmp6_opt_print ( ndo , ( const u_char * ) dp + RTSOLLEN , length - RTSOLLEN ) ; } break ; case ND_ROUTER_ADVERT : # define RTADVLEN 16 if ( ndo -> ndo_vflag ) { const struct nd_router_advert * p ; p = ( const struct nd_router_advert * ) dp ; ND_TCHECK ( p -> nd_ra_retransmit ) ; ND_PRINT ( ( ndo , "\\n\\thop<S2SV_blank>limit<S2SV_blank>%u,<S2SV_blank>Flags<S2SV_blank>[%s]" ",<S2SV_blank>pref<S2SV_blank>%s,<S2SV_blank>router<S2SV_blank>lifetime<S2SV_blank>%us,<S2SV_blank>reachable<S2SV_blank>time<S2SV_blank>%ums,<S2SV_blank>retrans<S2SV_blank>timer<S2SV_blank>%ums" , ( u_int ) p -> nd_ra_curhoplimit , bittok2str ( icmp6_opt_ra_flag_values , "none" , ( p -> nd_ra_flags_reserved ) ) , get_rtpref ( p -> nd_ra_flags_reserved ) , EXTRACT_16BITS ( & p -> nd_ra_router_lifetime ) , EXTRACT_32BITS ( & p -> nd_ra_reachable ) , EXTRACT_32BITS ( & p -> nd_ra_retransmit ) ) ) ; icmp6_opt_print ( ndo , ( const u_char * ) dp + RTADVLEN , length - RTADVLEN ) ; } break ; case ND_NEIGHBOR_SOLICIT : { const struct nd_neighbor_solicit * p ; p = ( const struct nd_neighbor_solicit * ) dp ; ND_TCHECK ( p -> nd_ns_target ) ; ND_PRINT ( ( ndo , ",<S2SV_blank>who<S2SV_blank>has<S2SV_blank>%s" , ip6addr_string ( ndo , & p -> nd_ns_target ) ) ) ; if ( ndo -> ndo_vflag ) { # define NDSOLLEN 24 icmp6_opt_print ( ndo , ( const u_char * ) dp + NDSOLLEN , length - NDSOLLEN ) ; } } break ; case ND_NEIGHBOR_ADVERT : { const struct nd_neighbor_advert * p ; p = ( const struct nd_neighbor_advert * ) dp ; ND_TCHECK ( p -> nd_na_target ) ; ND_PRINT ( ( ndo , ",<S2SV_blank>tgt<S2SV_blank>is<S2SV_blank>%s" , ip6addr_string ( ndo , & p -> nd_na_target ) ) ) ; if ( ndo -> ndo_vflag ) { ND_PRINT ( ( ndo , ",<S2SV_blank>Flags<S2SV_blank>[%s]" , bittok2str ( icmp6_nd_na_flag_values , "none" , EXTRACT_32BITS ( & p -> nd_na_flags_reserved ) ) ) ) ; # define NDADVLEN 24 icmp6_opt_print ( ndo , ( const u_char * ) dp + NDADVLEN , length - NDADVLEN ) ; # undef NDADVLEN } } break ; case ND_REDIRECT : # define RDR ( i ) ( ( const struct nd_redirect * ) ( i ) ) ND_TCHECK ( RDR ( dp ) -> nd_rd_dst ) ; ND_PRINT ( ( ndo , ",<S2SV_blank>%s" , ip6addr_string ( ndo , & RDR ( dp ) -> nd_rd_dst ) ) ) ; ND_TCHECK ( RDR ( dp ) -> nd_rd_target ) ; ND_PRINT ( ( ndo , "<S2SV_blank>to<S2SV_blank>%s" , ip6addr_string ( ndo , & RDR ( dp ) -> nd_rd_target ) ) ) ; # define REDIRECTLEN 40 if ( ndo -> ndo_vflag ) { icmp6_opt_print ( ndo , ( const u_char * ) dp + REDIRECTLEN , length - REDIRECTLEN ) ; } break ; # undef REDIRECTLEN # undef RDR case ICMP6_ROUTER_RENUMBERING : icmp6_rrenum_print ( ndo , bp , ep ) ; break ; case ICMP6_NI_QUERY : case ICMP6_NI_REPLY : icmp6_nodeinfo_print ( ndo , length , bp , ep ) ; break ; case IND_SOLICIT : case IND_ADVERT : break ; case ICMP6_V2_MEMBERSHIP_REPORT : mldv2_report_print ( ndo , ( const u_char * ) dp , length ) ; break ; case ICMP6_MOBILEPREFIX_SOLICIT : case ICMP6_HADISCOV_REQUEST : ND_TCHECK ( dp -> icmp6_data16 [ 0 ] ) ; ND_PRINT ( ( ndo , ",<S2SV_blank>id<S2SV_blank>0x%04x" , EXTRACT_16BITS ( & dp -> icmp6_data16 [ 0 ] ) ) ) ; break ; case ICMP6_HADISCOV_REPLY : if ( ndo -> ndo_vflag ) { const struct in6_addr * in6 ; const u_char * cp ; ND_TCHECK ( dp -> icmp6_data16 [ 0 ] ) ; ND_PRINT ( ( ndo , ",<S2SV_blank>id<S2SV_blank>0x%04x" , EXTRACT_16BITS ( & dp -> icmp6_data16 [ 0 ] ) ) ) ; cp = ( const u_char * ) dp + length ; in6 = ( const struct in6_addr * ) ( dp + 1 ) ; for ( ; ( const u_char * ) in6 < cp ; in6 ++ ) { ND_TCHECK ( * in6 ) ; ND_PRINT ( ( ndo , ",<S2SV_blank>%s" , ip6addr_string ( ndo , in6 ) ) ) ; } } break ; case ICMP6_MOBILEPREFIX_ADVERT : if ( ndo -> ndo_vflag ) { ND_TCHECK ( dp -> icmp6_data16 [ 0 ] ) ; ND_PRINT ( ( ndo , ",<S2SV_blank>id<S2SV_blank>0x%04x" , EXTRACT_16BITS ( & dp -> icmp6_data16 [ 0 ] ) ) ) ; ND_TCHECK ( dp -> icmp6_data16 [ 1 ] ) ; if ( dp -> icmp6_data16 [ 1 ] & 0xc0 ) ND_PRINT ( ( ndo , "<S2SV_blank>" ) ) ; if ( dp -> icmp6_data16 [ 1 ] & 0x80 ) ND_PRINT ( ( ndo , "M" ) ) ; if ( dp -> icmp6_data16 [ 1 ] & 0x40 ) ND_PRINT ( ( ndo , "O" ) ) ; # define MPADVLEN 8 icmp6_opt_print ( ndo , ( const u_char * ) dp + MPADVLEN , length - MPADVLEN ) ; } break ; case ND_RPL_MESSAGE : rpl_print ( ndo , dp , & dp -> icmp6_data8 [ 0 ] , length - sizeof ( struct icmp6_hdr ) + 4 ) ; break ; default : ND_PRINT ( ( ndo , ",<S2SV_blank>length<S2SV_blank>%u" , length ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , bp , "\\n\\t" , length ) ; return ; } if ( ! ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ",<S2SV_blank>length<S2SV_blank>%u" , length ) ) ; return ; trunc : <S2SV_StartBug> ND_PRINT ( ( ndo , "[|icmp6]" ) ) ; <S2SV_EndBug> }
CWE-125 static void icmp6_rrenum_print ( netdissect_options * ndo , const u_char * bp , const u_char * ep ) { const struct icmp6_router_renum * rr6 ; const char * cp ; const struct rr_pco_match * match ; const struct rr_pco_use * use ; char hbuf [ NI_MAXHOST ] ; int n ; if ( ep < bp ) return ; rr6 = ( const struct icmp6_router_renum * ) bp ; cp = ( const char * ) ( rr6 + 1 ) ; ND_TCHECK ( rr6 -> rr_reserved ) ; switch ( rr6 -> rr_code ) { case ICMP6_ROUTER_RENUMBERING_COMMAND : ND_PRINT ( ( ndo , "router<S2SV_blank>renum:<S2SV_blank>command" ) ) ; break ; case ICMP6_ROUTER_RENUMBERING_RESULT : ND_PRINT ( ( ndo , "router<S2SV_blank>renum:<S2SV_blank>result" ) ) ; break ; case ICMP6_ROUTER_RENUMBERING_SEQNUM_RESET : ND_PRINT ( ( ndo , "router<S2SV_blank>renum:<S2SV_blank>sequence<S2SV_blank>number<S2SV_blank>reset" ) ) ; break ; default : ND_PRINT ( ( ndo , "router<S2SV_blank>renum:<S2SV_blank>code-#%d" , rr6 -> rr_code ) ) ; break ; } ND_PRINT ( ( ndo , ",<S2SV_blank>seq=%u" , EXTRACT_32BITS ( & rr6 -> rr_seqnum ) ) ) ; if ( ndo -> ndo_vflag ) { # define F ( x , y ) ( ( rr6 -> rr_flags ) & ( x ) ? ( y ) : "" ) ND_PRINT ( ( ndo , "[" ) ) ; if ( rr6 -> rr_flags ) { ND_PRINT ( ( ndo , "%s%s%s%s%s," , F ( ICMP6_RR_FLAGS_TEST , "T" ) , F ( ICMP6_RR_FLAGS_REQRESULT , "R" ) , F ( ICMP6_RR_FLAGS_FORCEAPPLY , "A" ) , F ( ICMP6_RR_FLAGS_SPECSITE , "S" ) , F ( ICMP6_RR_FLAGS_PREVDONE , "P" ) ) ) ; } ND_PRINT ( ( ndo , "seg=%u," , rr6 -> rr_segnum ) ) ; ND_PRINT ( ( ndo , "maxdelay=%u" , EXTRACT_16BITS ( & rr6 -> rr_maxdelay ) ) ) ; if ( rr6 -> rr_reserved ) ND_PRINT ( ( ndo , "rsvd=0x%x" , EXTRACT_32BITS ( & rr6 -> rr_reserved ) ) ) ; ND_PRINT ( ( ndo , "]" ) ) ; # undef F } if ( rr6 -> rr_code == ICMP6_ROUTER_RENUMBERING_COMMAND ) { match = ( const struct rr_pco_match * ) cp ; cp = ( const char * ) ( match + 1 ) ; ND_TCHECK ( match -> rpm_prefix ) ; if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , "\\n\\t" ) ) ; else ND_PRINT ( ( ndo , "<S2SV_blank>" ) ) ; ND_PRINT ( ( ndo , "match(" ) ) ; switch ( match -> rpm_code ) { case RPM_PCO_ADD : ND_PRINT ( ( ndo , "add" ) ) ; break ; case RPM_PCO_CHANGE : ND_PRINT ( ( ndo , "change" ) ) ; break ; case RPM_PCO_SETGLOBAL : ND_PRINT ( ( ndo , "setglobal" ) ) ; break ; default : ND_PRINT ( ( ndo , "#%u" , match -> rpm_code ) ) ; break ; } if ( ndo -> ndo_vflag ) { ND_PRINT ( ( ndo , ",ord=%u" , match -> rpm_ordinal ) ) ; ND_PRINT ( ( ndo , ",min=%u" , match -> rpm_minlen ) ) ; ND_PRINT ( ( ndo , ",max=%u" , match -> rpm_maxlen ) ) ; } if ( addrtostr6 ( & match -> rpm_prefix , hbuf , sizeof ( hbuf ) ) ) ND_PRINT ( ( ndo , ",%s/%u" , hbuf , match -> rpm_matchlen ) ) ; else ND_PRINT ( ( ndo , ",?/%u" , match -> rpm_matchlen ) ) ; ND_PRINT ( ( ndo , ")" ) ) ; n = match -> rpm_len - 3 ; if ( n % 4 ) goto trunc ; n /= 4 ; while ( n -- > 0 ) { use = ( const struct rr_pco_use * ) cp ; cp = ( const char * ) ( use + 1 ) ; ND_TCHECK ( use -> rpu_prefix ) ; if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , "\\n\\t" ) ) ; else ND_PRINT ( ( ndo , "<S2SV_blank>" ) ) ; ND_PRINT ( ( ndo , "use(" ) ) ; if ( use -> rpu_flags ) { # define F ( x , y ) ( ( use -> rpu_flags ) & ( x ) ? ( y ) : "" ) ND_PRINT ( ( ndo , "%s%s," , F ( ICMP6_RR_PCOUSE_FLAGS_DECRVLTIME , "V" ) , F ( ICMP6_RR_PCOUSE_FLAGS_DECRPLTIME , "P" ) ) ) ; # undef F } if ( ndo -> ndo_vflag ) { ND_PRINT ( ( ndo , "mask=0x%x," , use -> rpu_ramask ) ) ; ND_PRINT ( ( ndo , "raflags=0x%x," , use -> rpu_raflags ) ) ; if ( ~ use -> rpu_vltime == 0 ) ND_PRINT ( ( ndo , "vltime=infty," ) ) ; else ND_PRINT ( ( ndo , "vltime=%u," , EXTRACT_32BITS ( & use -> rpu_vltime ) ) ) ; if ( ~ use -> rpu_pltime == 0 ) ND_PRINT ( ( ndo , "pltime=infty," ) ) ; else ND_PRINT ( ( ndo , "pltime=%u," , EXTRACT_32BITS ( & use -> rpu_pltime ) ) ) ; } if ( addrtostr6 ( & use -> rpu_prefix , hbuf , sizeof ( hbuf ) ) ) ND_PRINT ( ( ndo , "%s/%u/%u" , hbuf , use -> rpu_uselen , use -> rpu_keeplen ) ) ; else ND_PRINT ( ( ndo , "?/%u/%u" , use -> rpu_uselen , use -> rpu_keeplen ) ) ; ND_PRINT ( ( ndo , ")" ) ) ; } } return ; trunc : <S2SV_StartBug> ND_PRINT ( ( ndo , "[|icmp6]" ) ) ; <S2SV_EndBug> }
CWE-125 static void mldv2_query_print ( netdissect_options * ndo , const u_char * bp , u_int len ) { const struct icmp6_hdr * icp = ( const struct icmp6_hdr * ) bp ; u_int mrc ; int mrt , qqi ; u_int nsrcs ; register u_int i ; if ( len < 28 ) { ND_PRINT ( ( ndo , "<S2SV_blank>[invalid<S2SV_blank>len<S2SV_blank>%d]" , len ) ) ; return ; } ND_TCHECK ( icp -> icmp6_data16 [ 0 ] ) ; mrc = EXTRACT_16BITS ( & icp -> icmp6_data16 [ 0 ] ) ; if ( mrc < 32768 ) { mrt = mrc ; } else { mrt = ( ( mrc & 0x0fff ) | 0x1000 ) << ( ( ( mrc & 0x7000 ) >> 12 ) + 3 ) ; } if ( ndo -> ndo_vflag ) { ND_PRINT ( ( ndo , "<S2SV_blank>[max<S2SV_blank>resp<S2SV_blank>delay=%d]" , mrt ) ) ; } ND_TCHECK2 ( bp [ 8 ] , sizeof ( struct in6_addr ) ) ; ND_PRINT ( ( ndo , "<S2SV_blank>[gaddr<S2SV_blank>%s" , ip6addr_string ( ndo , & bp [ 8 ] ) ) ) ; if ( ndo -> ndo_vflag ) { ND_TCHECK ( bp [ 25 ] ) ; if ( bp [ 24 ] & 0x08 ) { ND_PRINT ( ( ndo , "<S2SV_blank>sflag" ) ) ; } if ( bp [ 24 ] & 0x07 ) { ND_PRINT ( ( ndo , "<S2SV_blank>robustness=%d" , bp [ 24 ] & 0x07 ) ) ; } if ( bp [ 25 ] < 128 ) { qqi = bp [ 25 ] ; } else { qqi = ( ( bp [ 25 ] & 0x0f ) | 0x10 ) << ( ( ( bp [ 25 ] & 0x70 ) >> 4 ) + 3 ) ; } ND_PRINT ( ( ndo , "<S2SV_blank>qqi=%d" , qqi ) ) ; } ND_TCHECK2 ( bp [ 26 ] , 2 ) ; nsrcs = EXTRACT_16BITS ( & bp [ 26 ] ) ; if ( nsrcs > 0 ) { if ( len < 28 + nsrcs * sizeof ( struct in6_addr ) ) ND_PRINT ( ( ndo , "<S2SV_blank>[invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>sources]" ) ) ; else if ( ndo -> ndo_vflag > 1 ) { ND_PRINT ( ( ndo , "<S2SV_blank>{" ) ) ; for ( i = 0 ; i < nsrcs ; i ++ ) { ND_TCHECK2 ( bp [ 28 + i * sizeof ( struct in6_addr ) ] , sizeof ( struct in6_addr ) ) ; ND_PRINT ( ( ndo , "<S2SV_blank>%s" , ip6addr_string ( ndo , & bp [ 28 + i * sizeof ( struct in6_addr ) ] ) ) ) ; } ND_PRINT ( ( ndo , "<S2SV_blank>}" ) ) ; } else ND_PRINT ( ( ndo , ",<S2SV_blank>%d<S2SV_blank>source(s)" , nsrcs ) ) ; } ND_PRINT ( ( ndo , "]" ) ) ; return ; trunc : <S2SV_StartBug> ND_PRINT ( ( ndo , "[|icmp6]" ) ) ; <S2SV_EndBug> return ; }
CWE-125 static void mldv2_report_print ( netdissect_options * ndo , const u_char * bp , u_int len ) { const struct icmp6_hdr * icp = ( const struct icmp6_hdr * ) bp ; u_int group , nsrcs , ngroups ; u_int i , j ; if ( len < 8 ) { ND_PRINT ( ( ndo , "<S2SV_blank>[invalid<S2SV_blank>len<S2SV_blank>%d]" , len ) ) ; return ; } ND_TCHECK ( icp -> icmp6_data16 [ 1 ] ) ; ngroups = EXTRACT_16BITS ( & icp -> icmp6_data16 [ 1 ] ) ; ND_PRINT ( ( ndo , ",<S2SV_blank>%d<S2SV_blank>group<S2SV_blank>record(s)" , ngroups ) ) ; if ( ndo -> ndo_vflag > 0 ) { group = 8 ; for ( i = 0 ; i < ngroups ; i ++ ) { if ( len < group + 20 ) { ND_PRINT ( ( ndo , "<S2SV_blank>[invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>groups]" ) ) ; return ; } ND_TCHECK2 ( bp [ group + 4 ] , sizeof ( struct in6_addr ) ) ; ND_PRINT ( ( ndo , "<S2SV_blank>[gaddr<S2SV_blank>%s" , ip6addr_string ( ndo , & bp [ group + 4 ] ) ) ) ; ND_PRINT ( ( ndo , "<S2SV_blank>%s" , tok2str ( mldv2report2str , "<S2SV_blank>[v2-report-#%d]" , bp [ group ] ) ) ) ; nsrcs = ( bp [ group + 2 ] << 8 ) + bp [ group + 3 ] ; if ( len < group + 20 + ( nsrcs * sizeof ( struct in6_addr ) ) ) { ND_PRINT ( ( ndo , "<S2SV_blank>[invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>sources<S2SV_blank>%d]" , nsrcs ) ) ; return ; } if ( ndo -> ndo_vflag == 1 ) ND_PRINT ( ( ndo , ",<S2SV_blank>%d<S2SV_blank>source(s)" , nsrcs ) ) ; else { ND_PRINT ( ( ndo , "<S2SV_blank>{" ) ) ; for ( j = 0 ; j < nsrcs ; j ++ ) { ND_TCHECK2 ( bp [ group + 20 + j * sizeof ( struct in6_addr ) ] , sizeof ( struct in6_addr ) ) ; ND_PRINT ( ( ndo , "<S2SV_blank>%s" , ip6addr_string ( ndo , & bp [ group + 20 + j * sizeof ( struct in6_addr ) ] ) ) ) ; } ND_PRINT ( ( ndo , "<S2SV_blank>}" ) ) ; } group += 20 + nsrcs * sizeof ( struct in6_addr ) ; ND_PRINT ( ( ndo , "]" ) ) ; } } return ; trunc : <S2SV_StartBug> ND_PRINT ( ( ndo , "[|icmp6]" ) ) ; <S2SV_EndBug> return ; }
CWE-125 static void rpl_dao_print ( netdissect_options * ndo , const u_char * bp , u_int length ) { const struct nd_rpl_dao * dao = ( const struct nd_rpl_dao * ) bp ; const char * dagid_str = "<elided>" ; ND_TCHECK ( * dao ) ; if ( length < ND_RPL_DAO_MIN_LEN ) goto tooshort ; bp += ND_RPL_DAO_MIN_LEN ; length -= ND_RPL_DAO_MIN_LEN ; if ( RPL_DAO_D ( dao -> rpl_flags ) ) { ND_TCHECK2 ( dao -> rpl_dagid , DAGID_LEN ) ; if ( length < DAGID_LEN ) goto tooshort ; dagid_str = ip6addr_string ( ndo , dao -> rpl_dagid ) ; bp += DAGID_LEN ; length -= DAGID_LEN ; } ND_PRINT ( ( ndo , "<S2SV_blank>[dagid:%s,seq:%u,instance:%u%s%s,%02x]" , dagid_str , dao -> rpl_daoseq , dao -> rpl_instanceid , RPL_DAO_K ( dao -> rpl_flags ) ? ",acK" : "" , RPL_DAO_D ( dao -> rpl_flags ) ? ",Dagid" : "" , dao -> rpl_flags ) ) ; if ( ndo -> ndo_vflag > 1 ) { const struct rpl_dio_genoption * opt = ( const struct rpl_dio_genoption * ) bp ; rpl_dio_printopt ( ndo , opt , length ) ; } return ; trunc : <S2SV_StartBug> ND_PRINT ( ( ndo , "<S2SV_blank>[|truncated]" ) ) ; <S2SV_EndBug> return ; tooshort : ND_PRINT ( ( ndo , "<S2SV_blank>[|length<S2SV_blank>too<S2SV_blank>short]" ) ) ; return ; }
CWE-125 static void rpl_daoack_print ( netdissect_options * ndo , const u_char * bp , u_int length ) { const struct nd_rpl_daoack * daoack = ( const struct nd_rpl_daoack * ) bp ; const char * dagid_str = "<elided>" ; ND_TCHECK2 ( * daoack , ND_RPL_DAOACK_MIN_LEN ) ; if ( length < ND_RPL_DAOACK_MIN_LEN ) goto tooshort ; bp += ND_RPL_DAOACK_MIN_LEN ; length -= ND_RPL_DAOACK_MIN_LEN ; if ( RPL_DAOACK_D ( daoack -> rpl_flags ) ) { ND_TCHECK2 ( daoack -> rpl_dagid , DAGID_LEN ) ; if ( length < DAGID_LEN ) goto tooshort ; dagid_str = ip6addr_string ( ndo , daoack -> rpl_dagid ) ; bp += DAGID_LEN ; length -= DAGID_LEN ; } ND_PRINT ( ( ndo , "<S2SV_blank>[dagid:%s,seq:%u,instance:%u,status:%u]" , dagid_str , daoack -> rpl_daoseq , daoack -> rpl_instanceid , daoack -> rpl_status ) ) ; if ( ndo -> ndo_vflag > 1 ) { const struct rpl_dio_genoption * opt = ( const struct rpl_dio_genoption * ) bp ; rpl_dio_printopt ( ndo , opt , length ) ; } return ; trunc : <S2SV_StartBug> ND_PRINT ( ( ndo , "<S2SV_blank>[|dao-truncated]" ) ) ; <S2SV_EndBug> return ; tooshort : ND_PRINT ( ( ndo , "<S2SV_blank>[|dao-length<S2SV_blank>too<S2SV_blank>short]" ) ) ; return ; }
CWE-125 static void rpl_dio_print ( netdissect_options * ndo , const u_char * bp , u_int length ) { const struct nd_rpl_dio * dio = ( const struct nd_rpl_dio * ) bp ; const char * dagid_str ; ND_TCHECK ( * dio ) ; dagid_str = ip6addr_string ( ndo , dio -> rpl_dagid ) ; ND_PRINT ( ( ndo , "<S2SV_blank>[dagid:%s,seq:%u,instance:%u,rank:%u,%smop:%s,prf:%u]" , dagid_str , dio -> rpl_dtsn , dio -> rpl_instanceid , EXTRACT_16BITS ( & dio -> rpl_dagrank ) , RPL_DIO_GROUNDED ( dio -> rpl_mopprf ) ? "grounded," : "" , tok2str ( rpl_mop_values , "mop%u" , RPL_DIO_MOP ( dio -> rpl_mopprf ) ) , RPL_DIO_PRF ( dio -> rpl_mopprf ) ) ) ; if ( ndo -> ndo_vflag > 1 ) { const struct rpl_dio_genoption * opt = ( const struct rpl_dio_genoption * ) & dio [ 1 ] ; rpl_dio_printopt ( ndo , opt , length ) ; } return ; trunc : <S2SV_StartBug> ND_PRINT ( ( ndo , "<S2SV_blank>[|truncated]" ) ) ; <S2SV_EndBug> return ; }
CWE-125 static void rpl_dio_printopt ( netdissect_options * ndo , const struct rpl_dio_genoption * opt , u_int length ) { if ( length < RPL_DIO_GENOPTION_LEN ) return ; length -= RPL_DIO_GENOPTION_LEN ; ND_TCHECK ( opt -> rpl_dio_len ) ; while ( ( opt -> rpl_dio_type == RPL_OPT_PAD0 && ( const u_char * ) opt < ndo -> ndo_snapend ) || ND_TTEST2 ( * opt , ( opt -> rpl_dio_len + 2 ) ) ) { unsigned int optlen = opt -> rpl_dio_len + 2 ; if ( opt -> rpl_dio_type == RPL_OPT_PAD0 ) { optlen = 1 ; ND_PRINT ( ( ndo , "<S2SV_blank>opt:pad0" ) ) ; } else { ND_PRINT ( ( ndo , "<S2SV_blank>opt:%s<S2SV_blank>len:%u<S2SV_blank>" , tok2str ( rpl_subopt_values , "subopt:%u" , opt -> rpl_dio_type ) , optlen ) ) ; if ( ndo -> ndo_vflag > 2 ) { unsigned int paylen = opt -> rpl_dio_len ; if ( paylen > length ) paylen = length ; hex_print ( ndo , "<S2SV_blank>" , ( ( const uint8_t * ) opt ) + RPL_DIO_GENOPTION_LEN , paylen ) ; } } opt = ( const struct rpl_dio_genoption * ) ( ( ( const char * ) opt ) + optlen ) ; length -= optlen ; <S2SV_StartBug> } <S2SV_EndBug> return ; trunc : <S2SV_StartBug> ND_PRINT ( ( ndo , "<S2SV_blank>[|truncated]" ) ) ; <S2SV_EndBug> return ; }
CWE-125 static void rpl_print ( netdissect_options * ndo , const struct icmp6_hdr * hdr , const u_char * bp , u_int length ) { int secured = hdr -> icmp6_code & 0x80 ; int basecode = hdr -> icmp6_code & 0x7f ; if ( secured ) { ND_PRINT ( ( ndo , ",<S2SV_blank>(SEC)<S2SV_blank>[worktodo]" ) ) ; return ; } else { ND_PRINT ( ( ndo , ",<S2SV_blank>(CLR)" ) ) ; } switch ( basecode ) { case ND_RPL_DAG_IS : ND_PRINT ( ( ndo , "DODAG<S2SV_blank>Information<S2SV_blank>Solicitation" ) ) ; if ( ndo -> ndo_vflag ) { } break ; case ND_RPL_DAG_IO : ND_PRINT ( ( ndo , "DODAG<S2SV_blank>Information<S2SV_blank>Object" ) ) ; if ( ndo -> ndo_vflag ) { rpl_dio_print ( ndo , bp , length ) ; } break ; case ND_RPL_DAO : ND_PRINT ( ( ndo , "Destination<S2SV_blank>Advertisement<S2SV_blank>Object" ) ) ; if ( ndo -> ndo_vflag ) { rpl_dao_print ( ndo , bp , length ) ; } break ; case ND_RPL_DAO_ACK : ND_PRINT ( ( ndo , "Destination<S2SV_blank>Advertisement<S2SV_blank>Object<S2SV_blank>Ack" ) ) ; if ( ndo -> ndo_vflag ) { rpl_daoack_print ( ndo , bp , length ) ; } break ; default : ND_PRINT ( ( ndo , "RPL<S2SV_blank>message,<S2SV_blank>unknown<S2SV_blank>code<S2SV_blank>%u" , hdr -> icmp6_code ) ) ; break ; } return ; # if 0 trunc : <S2SV_StartBug> ND_PRINT ( ( ndo , "<S2SV_blank>[|truncated]" ) ) ; <S2SV_EndBug> return ; # endif }
CWE-125 void lmp_print ( netdissect_options * ndo , register const u_char * pptr , register u_int len ) { const struct lmp_common_header * lmp_com_header ; const struct lmp_object_header * lmp_obj_header ; const u_char * tptr , * obj_tptr ; u_int tlen , lmp_obj_len , lmp_obj_ctype , obj_tlen ; <S2SV_StartBug> int hexdump ; <S2SV_EndBug> u_int offset ; u_int link_type ; union { float f ; uint32_t i ; } bw ; tptr = pptr ; lmp_com_header = ( const struct lmp_common_header * ) pptr ; ND_TCHECK ( * lmp_com_header ) ; if ( LMP_EXTRACT_VERSION ( lmp_com_header -> version_res [ 0 ] ) != LMP_VERSION ) { ND_PRINT ( ( ndo , "LMP<S2SV_blank>version<S2SV_blank>%u<S2SV_blank>packet<S2SV_blank>not<S2SV_blank>supported" , LMP_EXTRACT_VERSION ( lmp_com_header -> version_res [ 0 ] ) ) ) ; return ; } if ( ndo -> ndo_vflag < 1 ) { ND_PRINT ( ( ndo , "LMPv%u<S2SV_blank>%s<S2SV_blank>Message,<S2SV_blank>length:<S2SV_blank>%u" , LMP_EXTRACT_VERSION ( lmp_com_header -> version_res [ 0 ] ) , tok2str ( lmp_msg_type_values , "unknown<S2SV_blank>(%u)" , lmp_com_header -> msg_type ) , len ) ) ; return ; } tlen = EXTRACT_16BITS ( lmp_com_header -> length ) ; ND_PRINT ( ( ndo , "\\n\\tLMPv%u,<S2SV_blank>msg-type:<S2SV_blank>%s,<S2SV_blank>Flags:<S2SV_blank>[%s],<S2SV_blank>length:<S2SV_blank>%u" , LMP_EXTRACT_VERSION ( lmp_com_header -> version_res [ 0 ] ) , tok2str ( lmp_msg_type_values , "unknown,<S2SV_blank>type:<S2SV_blank>%u" , lmp_com_header -> msg_type ) , bittok2str ( lmp_header_flag_values , "none" , lmp_com_header -> flags ) , tlen ) ) ; if ( tlen < sizeof ( const struct lmp_common_header ) ) { ND_PRINT ( ( ndo , "<S2SV_blank>(too<S2SV_blank>short)" ) ) ; return ; } if ( tlen > len ) { ND_PRINT ( ( ndo , "<S2SV_blank>(too<S2SV_blank>long)" ) ) ; tlen = len ; } tptr += sizeof ( const struct lmp_common_header ) ; tlen -= sizeof ( const struct lmp_common_header ) ; while ( tlen > 0 ) { ND_TCHECK2 ( * tptr , sizeof ( struct lmp_object_header ) ) ; lmp_obj_header = ( const struct lmp_object_header * ) tptr ; lmp_obj_len = EXTRACT_16BITS ( lmp_obj_header -> length ) ; lmp_obj_ctype = ( lmp_obj_header -> ctype ) & 0x7f ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Object<S2SV_blank>(%u),<S2SV_blank>Class-Type:<S2SV_blank>%s<S2SV_blank>(%u)<S2SV_blank>Flags:<S2SV_blank>[%snegotiable],<S2SV_blank>length:<S2SV_blank>%u" , tok2str ( lmp_obj_values , "Unknown" , lmp_obj_header -> class_num ) , lmp_obj_header -> class_num , tok2str ( lmp_ctype_values , "Unknown" , ( ( lmp_obj_header -> class_num ) << 8 ) + lmp_obj_ctype ) , lmp_obj_ctype , ( lmp_obj_header -> ctype ) & 0x80 ? "" : "non-" , lmp_obj_len ) ) ; if ( lmp_obj_len < 4 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(too<S2SV_blank>short)" ) ) ; return ; } if ( ( lmp_obj_len % 4 ) != 0 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>a<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>4)" ) ) ; return ; } obj_tptr = tptr + sizeof ( struct lmp_object_header ) ; obj_tlen = lmp_obj_len - sizeof ( struct lmp_object_header ) ; ND_TCHECK2 ( * tptr , lmp_obj_len ) ; hexdump = FALSE ; switch ( lmp_obj_header -> class_num ) { case LMP_OBJ_CC_ID : switch ( lmp_obj_ctype ) { case LMP_CTYPE_LOC : case LMP_CTYPE_RMT : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Control<S2SV_blank>Channel<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)" , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_LINK_ID : case LMP_OBJ_INTERFACE_ID : switch ( lmp_obj_ctype ) { case LMP_CTYPE_IPV4_LOC : case LMP_CTYPE_IPV4_RMT : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>IPv4<S2SV_blank>Link<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)" , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; case LMP_CTYPE_IPV6_LOC : case LMP_CTYPE_IPV6_RMT : if ( obj_tlen != 16 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>IPv6<S2SV_blank>Link<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)" , ip6addr_string ( ndo , obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; case LMP_CTYPE_UNMD_LOC : case LMP_CTYPE_UNMD_RMT : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Link<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)" , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_MESSAGE_ID : switch ( lmp_obj_ctype ) { case LMP_CTYPE_1 : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Message<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)" , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; case LMP_CTYPE_2 : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Message<S2SV_blank>ID<S2SV_blank>Ack:<S2SV_blank>%u<S2SV_blank>(0x%08x)" , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_NODE_ID : switch ( lmp_obj_ctype ) { case LMP_CTYPE_LOC : case LMP_CTYPE_RMT : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Node<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)" , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_CONFIG : switch ( lmp_obj_ctype ) { case LMP_CTYPE_HELLO_CONFIG : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Hello<S2SV_blank>Interval:<S2SV_blank>%u\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Hello<S2SV_blank>Dead<S2SV_blank>Interval:<S2SV_blank>%u" , EXTRACT_16BITS ( obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_HELLO : switch ( lmp_obj_ctype ) { case LMP_CTYPE_HELLO : if ( obj_tlen != 8 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Tx<S2SV_blank>Seq:<S2SV_blank>%u,<S2SV_blank>Rx<S2SV_blank>Seq:<S2SV_blank>%u" , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr + 4 ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_TE_LINK : switch ( lmp_obj_ctype ) { case LMP_CTYPE_IPV4 : if ( obj_tlen != 12 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[%s]" , bittok2str ( lmp_obj_te_link_flag_values , "none" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Link-ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)" "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Remote<S2SV_blank>Link-ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)" , ipaddr_string ( ndo , obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , ipaddr_string ( ndo , obj_tptr + 8 ) , EXTRACT_32BITS ( obj_tptr + 8 ) ) ) ; break ; case LMP_CTYPE_IPV6 : if ( obj_tlen != 36 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[%s]" , bittok2str ( lmp_obj_te_link_flag_values , "none" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Link-ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)" "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Remote<S2SV_blank>Link-ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)" , ip6addr_string ( ndo , obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , ip6addr_string ( ndo , obj_tptr + 20 ) , EXTRACT_32BITS ( obj_tptr + 20 ) ) ) ; break ; case LMP_CTYPE_UNMD : if ( obj_tlen != 12 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[%s]" , bittok2str ( lmp_obj_te_link_flag_values , "none" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Link-ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)" "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Remote<S2SV_blank>Link-ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)" , EXTRACT_32BITS ( obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 8 ) , EXTRACT_32BITS ( obj_tptr + 8 ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_DATA_LINK : switch ( lmp_obj_ctype ) { case LMP_CTYPE_IPV4 : if ( obj_tlen < 12 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[%s]" , bittok2str ( lmp_obj_data_link_flag_values , "none" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)" "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Remote<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)" , ipaddr_string ( ndo , obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , ipaddr_string ( ndo , obj_tptr + 8 ) , EXTRACT_32BITS ( obj_tptr + 8 ) ) ) ; <S2SV_StartBug> if ( lmp_print_data_link_subobjs ( ndo , obj_tptr , obj_tlen - 12 , 12 ) ) <S2SV_EndBug> hexdump = TRUE ; break ; case LMP_CTYPE_IPV6 : if ( obj_tlen < 36 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[%s]" , bittok2str ( lmp_obj_data_link_flag_values , "none" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)" "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Remote<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)" , ip6addr_string ( ndo , obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , ip6addr_string ( ndo , obj_tptr + 20 ) , EXTRACT_32BITS ( obj_tptr + 20 ) ) ) ; <S2SV_StartBug> if ( lmp_print_data_link_subobjs ( ndo , obj_tptr , obj_tlen - 36 , 36 ) ) <S2SV_EndBug> hexdump = TRUE ; break ; case LMP_CTYPE_UNMD : if ( obj_tlen < 12 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[%s]" , bittok2str ( lmp_obj_data_link_flag_values , "none" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)" "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Remote<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)" , EXTRACT_32BITS ( obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 8 ) , EXTRACT_32BITS ( obj_tptr + 8 ) ) ) ; <S2SV_StartBug> if ( lmp_print_data_link_subobjs ( ndo , obj_tptr , obj_tlen - 12 , 12 ) ) <S2SV_EndBug> hexdump = TRUE ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_VERIFY_BEGIN : switch ( lmp_obj_ctype ) { case LMP_CTYPE_1 : if ( obj_tlen != 20 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>%s" , bittok2str ( lmp_obj_begin_verify_flag_values , "none" , EXTRACT_16BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Verify<S2SV_blank>Interval:<S2SV_blank>%u" , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Data<S2SV_blank>links:<S2SV_blank>%u" , EXTRACT_32BITS ( obj_tptr + 4 ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Encoding<S2SV_blank>type:<S2SV_blank>%s" , tok2str ( gmpls_encoding_values , "Unknown" , * ( obj_tptr + 8 ) ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Verify<S2SV_blank>Transport<S2SV_blank>Mechanism:<S2SV_blank>%u<S2SV_blank>(0x%x)%s" , EXTRACT_16BITS ( obj_tptr + 10 ) , EXTRACT_16BITS ( obj_tptr + 10 ) , EXTRACT_16BITS ( obj_tptr + 10 ) & 8000 ? "<S2SV_blank>(Payload<S2SV_blank>test<S2SV_blank>messages<S2SV_blank>capable)" : "" ) ) ; bw . i = EXTRACT_32BITS ( obj_tptr + 12 ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Transmission<S2SV_blank>Rate:<S2SV_blank>%.3f<S2SV_blank>Mbps" , bw . f * 8 / 1000000 ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Wavelength:<S2SV_blank>%u" , EXTRACT_32BITS ( obj_tptr + 16 ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_VERIFY_BEGIN_ACK : switch ( lmp_obj_ctype ) { case LMP_CTYPE_1 : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Verify<S2SV_blank>Dead<S2SV_blank>Interval:<S2SV_blank>%u" "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Verify<S2SV_blank>Transport<S2SV_blank>Response:<S2SV_blank>%u" , EXTRACT_16BITS ( obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_VERIFY_ID : switch ( lmp_obj_ctype ) { case LMP_CTYPE_1 : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Verify<S2SV_blank>ID:<S2SV_blank>%u" , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_CHANNEL_STATUS : switch ( lmp_obj_ctype ) { case LMP_CTYPE_IPV4 : offset = 0 ; while ( offset + 8 <= obj_tlen ) { ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)" , ipaddr_string ( ndo , obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Active:<S2SV_blank>%s<S2SV_blank>(%u)" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 31 ) ? "Allocated" : "Non-allocated" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 31 ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Direction:<S2SV_blank>%s<S2SV_blank>(%u)" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 30 ) & 0x1 ? "Transmit" : "Receive" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 30 ) & 0x1 ) ) ; ND_PRINT ( ( ndo , "\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Channel<S2SV_blank>Status:<S2SV_blank>%s<S2SV_blank>(%u)" , tok2str ( lmp_obj_channel_status_values , "Unknown" , EXTRACT_32BITS ( obj_tptr + offset + 4 ) & 0x3FFFFFF ) , EXTRACT_32BITS ( obj_tptr + offset + 4 ) & 0x3FFFFFF ) ) ; offset += 8 ; } break ; case LMP_CTYPE_IPV6 : offset = 0 ; while ( offset + 20 <= obj_tlen ) { ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)" , ip6addr_string ( ndo , obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Active:<S2SV_blank>%s<S2SV_blank>(%u)" , ( EXTRACT_32BITS ( obj_tptr + offset + 16 ) >> 31 ) ? "Allocated" : "Non-allocated" , ( EXTRACT_32BITS ( obj_tptr + offset + 16 ) >> 31 ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Direction:<S2SV_blank>%s<S2SV_blank>(%u)" , ( EXTRACT_32BITS ( obj_tptr + offset + 16 ) >> 30 ) & 0x1 ? "Transmit" : "Receive" , ( EXTRACT_32BITS ( obj_tptr + offset + 16 ) >> 30 ) & 0x1 ) ) ; ND_PRINT ( ( ndo , "\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Channel<S2SV_blank>Status:<S2SV_blank>%s<S2SV_blank>(%u)" , tok2str ( lmp_obj_channel_status_values , "Unknown" , EXTRACT_32BITS ( obj_tptr + offset + 16 ) & 0x3FFFFFF ) , EXTRACT_32BITS ( obj_tptr + offset + 16 ) & 0x3FFFFFF ) ) ; offset += 20 ; } break ; case LMP_CTYPE_UNMD : offset = 0 ; while ( offset + 8 <= obj_tlen ) { ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)" , EXTRACT_32BITS ( obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Active:<S2SV_blank>%s<S2SV_blank>(%u)" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 31 ) ? "Allocated" : "Non-allocated" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 31 ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Direction:<S2SV_blank>%s<S2SV_blank>(%u)" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 30 ) & 0x1 ? "Transmit" : "Receive" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 30 ) & 0x1 ) ) ; ND_PRINT ( ( ndo , "\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Channel<S2SV_blank>Status:<S2SV_blank>%s<S2SV_blank>(%u)" , tok2str ( lmp_obj_channel_status_values , "Unknown" , EXTRACT_32BITS ( obj_tptr + offset + 4 ) & 0x3FFFFFF ) , EXTRACT_32BITS ( obj_tptr + offset + 4 ) & 0x3FFFFFF ) ) ; offset += 8 ; } break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_CHANNEL_STATUS_REQ : switch ( lmp_obj_ctype ) { case LMP_CTYPE_IPV4 : offset = 0 ; while ( offset + 4 <= obj_tlen ) { ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)" , ipaddr_string ( ndo , obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; offset += 4 ; } break ; case LMP_CTYPE_IPV6 : offset = 0 ; while ( offset + 16 <= obj_tlen ) { ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)" , ip6addr_string ( ndo , obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; offset += 16 ; } break ; case LMP_CTYPE_UNMD : offset = 0 ; while ( offset + 4 <= obj_tlen ) { ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)" , EXTRACT_32BITS ( obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; offset += 4 ; } break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_ERROR_CODE : switch ( lmp_obj_ctype ) { case LMP_CTYPE_BEGIN_VERIFY_ERROR : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Error<S2SV_blank>Code:<S2SV_blank>%s" , bittok2str ( lmp_obj_begin_verify_error_values , "none" , EXTRACT_32BITS ( obj_tptr ) ) ) ) ; break ; case LMP_CTYPE_LINK_SUMMARY_ERROR : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Error<S2SV_blank>Code:<S2SV_blank>%s" , bittok2str ( lmp_obj_link_summary_error_values , "none" , EXTRACT_32BITS ( obj_tptr ) ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_SERVICE_CONFIG : switch ( lmp_obj_ctype ) { case LMP_CTYPE_SERVICE_CONFIG_SP : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank>Flags:<S2SV_blank>%s" , bittok2str ( lmp_obj_service_config_sp_flag_values , "none" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>UNI<S2SV_blank>Version:<S2SV_blank>%u" , EXTRACT_8BITS ( obj_tptr + 1 ) ) ) ; break ; case LMP_CTYPE_SERVICE_CONFIG_CPSA : if ( obj_tlen != 16 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } link_type = EXTRACT_8BITS ( obj_tptr ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank>Link<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u)" , tok2str ( lmp_sd_service_config_cpsa_link_type_values , "Unknown" , link_type ) , link_type ) ) ; switch ( link_type ) { case LMP_SD_SERVICE_CONFIG_CPSA_LINK_TYPE_SDH : ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank>Signal<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u)" , tok2str ( lmp_sd_service_config_cpsa_signal_type_sdh_values , "Unknown" , EXTRACT_8BITS ( obj_tptr + 1 ) ) , EXTRACT_8BITS ( obj_tptr + 1 ) ) ) ; break ; case LMP_SD_SERVICE_CONFIG_CPSA_LINK_TYPE_SONET : ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank>Signal<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u)" , tok2str ( lmp_sd_service_config_cpsa_signal_type_sonet_values , "Unknown" , EXTRACT_8BITS ( obj_tptr + 1 ) ) , EXTRACT_8BITS ( obj_tptr + 1 ) ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank>Transparency:<S2SV_blank>%s" , bittok2str ( lmp_obj_service_config_cpsa_tp_flag_values , "none" , EXTRACT_8BITS ( obj_tptr + 2 ) ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank>Contiguous<S2SV_blank>Concatenation<S2SV_blank>Types:<S2SV_blank>%s" , bittok2str ( lmp_obj_service_config_cpsa_cct_flag_values , "none" , EXTRACT_8BITS ( obj_tptr + 3 ) ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank>Minimum<S2SV_blank>NCC:<S2SV_blank>%u" , EXTRACT_16BITS ( obj_tptr + 4 ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank>Maximum<S2SV_blank>NCC:<S2SV_blank>%u" , EXTRACT_16BITS ( obj_tptr + 6 ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank>Minimum<S2SV_blank>NVC:%u" , EXTRACT_16BITS ( obj_tptr + 8 ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank>Maximum<S2SV_blank>NVC:%u" , EXTRACT_16BITS ( obj_tptr + 10 ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)" , ipaddr_string ( ndo , obj_tptr + 12 ) , EXTRACT_32BITS ( obj_tptr + 12 ) ) ) ; break ; case LMP_CTYPE_SERVICE_CONFIG_TRANSPARENCY_TCM : if ( obj_tlen != 8 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank>Transparency<S2SV_blank>Flags:<S2SV_blank>%s" , bittok2str ( lmp_obj_service_config_nsa_transparency_flag_values , "none" , EXTRACT_32BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank>TCM<S2SV_blank>Monitoring<S2SV_blank>Flags:<S2SV_blank>%s" , bittok2str ( lmp_obj_service_config_nsa_tcm_flag_values , "none" , EXTRACT_8BITS ( obj_tptr + 7 ) ) ) ) ; break ; case LMP_CTYPE_SERVICE_CONFIG_NETWORK_DIVERSITY : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank>Diversity:<S2SV_blank>Flags:<S2SV_blank>%s" , bittok2str ( lmp_obj_service_config_nsa_network_diversity_flag_values , "none" , EXTRACT_8BITS ( obj_tptr + 3 ) ) ) ) ; break ; default : hexdump = TRUE ; } break ; default : if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , obj_tptr , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , obj_tlen ) ; break ; } if ( ndo -> ndo_vflag > 1 || hexdump == TRUE ) print_unknown_data ( ndo , tptr + sizeof ( struct lmp_object_header ) , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , lmp_obj_len - sizeof ( struct lmp_object_header ) ) ; tptr += lmp_obj_len ; tlen -= lmp_obj_len ; } return ; trunc : ND_PRINT ( ( ndo , "\\n\\t\\t<S2SV_blank>packet<S2SV_blank>exceeded<S2SV_blank>snapshot" ) ) ; }
CWE-125 static int lmp_print_data_link_subobjs ( netdissect_options * ndo , const u_char * obj_tptr , int total_subobj_len , int offset ) { int hexdump = FALSE ; int subobj_type , subobj_len ; union { float f ; uint32_t i ; } bw ; while ( total_subobj_len > 0 && hexdump == FALSE ) { subobj_type = EXTRACT_8BITS ( obj_tptr + offset ) ; subobj_len = EXTRACT_8BITS ( obj_tptr + offset + 1 ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Subobject,<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>Length:<S2SV_blank>%u" , tok2str ( lmp_data_link_subobj , "Unknown" , subobj_type ) , subobj_type , subobj_len ) ) ; if ( subobj_len < 4 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(too<S2SV_blank>short)" ) ) ; break ; } if ( ( subobj_len % 4 ) != 0 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>a<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>4)" ) ) ; break ; } if ( total_subobj_len < subobj_len ) { ND_PRINT ( ( ndo , "<S2SV_blank>(goes<S2SV_blank>past<S2SV_blank>the<S2SV_blank>end<S2SV_blank>of<S2SV_blank>the<S2SV_blank>object)" ) ) ; break ; } switch ( subobj_type ) { case INT_SWITCHING_TYPE_SUBOBJ : ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Switching<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u)" , tok2str ( gmpls_switch_cap_values , "Unknown" , EXTRACT_8BITS ( obj_tptr + offset + 2 ) ) , EXTRACT_8BITS ( obj_tptr + offset + 2 ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Encoding<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u)" , tok2str ( gmpls_encoding_values , "Unknown" , EXTRACT_8BITS ( obj_tptr + offset + 3 ) ) , EXTRACT_8BITS ( obj_tptr + offset + 3 ) ) ) ; <S2SV_StartBug> bw . i = EXTRACT_32BITS ( obj_tptr + offset + 4 ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Min<S2SV_blank>Reservable<S2SV_blank>Bandwidth:<S2SV_blank>%.3f<S2SV_blank>Mbps" , bw . f * 8 / 1000000 ) ) ; bw . i = EXTRACT_32BITS ( obj_tptr + offset + 8 ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Max<S2SV_blank>Reservable<S2SV_blank>Bandwidth:<S2SV_blank>%.3f<S2SV_blank>Mbps" , bw . f * 8 / 1000000 ) ) ; break ; case WAVELENGTH_SUBOBJ : ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Wavelength:<S2SV_blank>%u" , EXTRACT_32BITS ( obj_tptr + offset + 4 ) ) ) ; break ; default : hexdump = TRUE ; break ; } total_subobj_len -= subobj_len ; offset += subobj_len ; } return ( hexdump ) ; <S2SV_StartBug> } <S2SV_EndBug>
CWE-125 static int ospf6_print_lshdr ( netdissect_options * ndo , register const struct lsa6_hdr * lshp , const u_char * dataend ) { if ( ( const u_char * ) ( lshp + 1 ) > dataend ) goto trunc ; <S2SV_StartBug> ND_TCHECK ( lshp -> ls_type ) ; <S2SV_EndBug> ND_TCHECK ( lshp -> ls_seq ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>Advertising<S2SV_blank>Router<S2SV_blank>%s,<S2SV_blank>seq<S2SV_blank>0x%08x,<S2SV_blank>age<S2SV_blank>%us,<S2SV_blank>length<S2SV_blank>%u" , ipaddr_string ( ndo , & lshp -> ls_router ) , EXTRACT_32BITS ( & lshp -> ls_seq ) , EXTRACT_16BITS ( & lshp -> ls_age ) , EXTRACT_16BITS ( & lshp -> ls_length ) - ( u_int ) sizeof ( struct lsa6_hdr ) ) ) ; ospf6_print_ls_type ( ndo , EXTRACT_16BITS ( & lshp -> ls_type ) , & lshp -> ls_stateid ) ; return ( 0 ) ; trunc : return ( 1 ) ; }
CWE-125 static void bgp_capabilities_print ( netdissect_options * ndo , const u_char * opt , int caps_len ) { int cap_type , cap_len , tcap_len , cap_offset ; int i = 0 ; while ( i < caps_len ) { ND_TCHECK2 ( opt [ i ] , BGP_CAP_HEADER_SIZE ) ; cap_type = opt [ i ] ; cap_len = opt [ i + 1 ] ; tcap_len = cap_len ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>length:<S2SV_blank>%u" , tok2str ( bgp_capcode_values , "Unknown" , cap_type ) , cap_type , cap_len ) ) ; ND_TCHECK2 ( opt [ i + 2 ] , cap_len ) ; switch ( cap_type ) { <S2SV_StartBug> case BGP_CAPCODE_MP : <S2SV_EndBug> ND_PRINT ( ( ndo , "\\n\\t\\tAFI<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>SAFI<S2SV_blank>%s<S2SV_blank>(%u)" , tok2str ( af_values , "Unknown" , EXTRACT_16BITS ( opt + i + 2 ) ) , EXTRACT_16BITS ( opt + i + 2 ) , tok2str ( bgp_safi_values , "Unknown" , opt [ i + 5 ] ) , opt [ i + 5 ] ) ) ; break ; case BGP_CAPCODE_RESTART : ND_TCHECK_16BITS ( opt + i + 2 ) ; ND_PRINT ( ( ndo , "\\n\\t\\tRestart<S2SV_blank>Flags:<S2SV_blank>[%s],<S2SV_blank>Restart<S2SV_blank>Time<S2SV_blank>%us" , ( ( opt [ i + 2 ] ) & 0x80 ) ? "R" : "none" , EXTRACT_16BITS ( opt + i + 2 ) & 0xfff ) ) ; tcap_len -= 2 ; cap_offset = 4 ; while ( tcap_len >= 4 ) { ND_PRINT ( ( ndo , "\\n\\t\\t<S2SV_blank><S2SV_blank>AFI<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>SAFI<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>Forwarding<S2SV_blank>state<S2SV_blank>preserved:<S2SV_blank>%s" , tok2str ( af_values , "Unknown" , EXTRACT_16BITS ( opt + i + cap_offset ) ) , EXTRACT_16BITS ( opt + i + cap_offset ) , tok2str ( bgp_safi_values , "Unknown" , opt [ i + cap_offset + 2 ] ) , opt [ i + cap_offset + 2 ] , ( ( opt [ i + cap_offset + 3 ] ) & 0x80 ) ? "yes" : "no" ) ) ; tcap_len -= 4 ; cap_offset += 4 ; } break ; case BGP_CAPCODE_RR : case BGP_CAPCODE_RR_CISCO : break ; case BGP_CAPCODE_AS_NEW : if ( cap_len == 4 ) { ND_PRINT ( ( ndo , "\\n\\t\\t<S2SV_blank>4<S2SV_blank>Byte<S2SV_blank>AS<S2SV_blank>%s" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( opt + i + 2 ) ) ) ) ; } break ; case BGP_CAPCODE_ADD_PATH : cap_offset = 2 ; if ( tcap_len == 0 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(bogus)" ) ) ; break ; } while ( tcap_len > 0 ) { if ( tcap_len < 4 ) { ND_PRINT ( ( ndo , "\\n\\t\\t(invalid)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t\\tAFI<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>SAFI<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>Send/Receive:<S2SV_blank>%s" , tok2str ( af_values , "Unknown" , EXTRACT_16BITS ( opt + i + cap_offset ) ) , EXTRACT_16BITS ( opt + i + cap_offset ) , tok2str ( bgp_safi_values , "Unknown" , opt [ i + cap_offset + 2 ] ) , opt [ i + cap_offset + 2 ] , tok2str ( bgp_add_path_recvsend , "Bogus<S2SV_blank>(0x%02x)" , opt [ i + cap_offset + 3 ] ) ) ) ; tcap_len -= 4 ; cap_offset += 4 ; } break ; default : ND_PRINT ( ( ndo , "\\n\\t\\tno<S2SV_blank>decoder<S2SV_blank>for<S2SV_blank>Capability<S2SV_blank>%u" , cap_type ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , & opt [ i + 2 ] , "\\n\\t\\t" , cap_len ) ; break ; } if ( ndo -> ndo_vflag > 1 && cap_len > 0 ) { print_unknown_data ( ndo , & opt [ i + 2 ] , "\\n\\t\\t" , cap_len ) ; } i += BGP_CAP_HEADER_SIZE + cap_len ; } return ; trunc : ND_PRINT ( ( ndo , "[|BGP]" ) ) ; }
CWE-119 bool radeon_atom_get_tv_timings ( struct radeon_device * rdev , int index , struct drm_display_mode * mode ) { struct radeon_mode_info * mode_info = & rdev -> mode_info ; ATOM_ANALOG_TV_INFO * tv_info ; ATOM_ANALOG_TV_INFO_V1_2 * tv_info_v1_2 ; ATOM_DTD_FORMAT * dtd_timings ; int data_index = GetIndexIntoMasterTable ( DATA , AnalogTV_Info ) ; u8 frev , crev ; u16 data_offset , misc ; if ( ! atom_parse_data_header ( mode_info -> atom_context , data_index , NULL , & frev , & crev , & data_offset ) ) return false ; switch ( crev ) { case 1 : tv_info = ( ATOM_ANALOG_TV_INFO * ) ( mode_info -> atom_context -> bios + data_offset ) ; <S2SV_StartBug> if ( index > MAX_SUPPORTED_TV_TIMING ) <S2SV_EndBug> return false ; mode -> crtc_htotal = le16_to_cpu ( tv_info -> aModeTimings [ index ] . usCRTC_H_Total ) ; mode -> crtc_hdisplay = le16_to_cpu ( tv_info -> aModeTimings [ index ] . usCRTC_H_Disp ) ; mode -> crtc_hsync_start = le16_to_cpu ( tv_info -> aModeTimings [ index ] . usCRTC_H_SyncStart ) ; mode -> crtc_hsync_end = le16_to_cpu ( tv_info -> aModeTimings [ index ] . usCRTC_H_SyncStart ) + le16_to_cpu ( tv_info -> aModeTimings [ index ] . usCRTC_H_SyncWidth ) ; mode -> crtc_vtotal = le16_to_cpu ( tv_info -> aModeTimings [ index ] . usCRTC_V_Total ) ; mode -> crtc_vdisplay = le16_to_cpu ( tv_info -> aModeTimings [ index ] . usCRTC_V_Disp ) ; mode -> crtc_vsync_start = le16_to_cpu ( tv_info -> aModeTimings [ index ] . usCRTC_V_SyncStart ) ; mode -> crtc_vsync_end = le16_to_cpu ( tv_info -> aModeTimings [ index ] . usCRTC_V_SyncStart ) + le16_to_cpu ( tv_info -> aModeTimings [ index ] . usCRTC_V_SyncWidth ) ; mode -> flags = 0 ; misc = le16_to_cpu ( tv_info -> aModeTimings [ index ] . susModeMiscInfo . usAccess ) ; if ( misc & ATOM_VSYNC_POLARITY ) mode -> flags |= DRM_MODE_FLAG_NVSYNC ; if ( misc & ATOM_HSYNC_POLARITY ) mode -> flags |= DRM_MODE_FLAG_NHSYNC ; if ( misc & ATOM_COMPOSITESYNC ) mode -> flags |= DRM_MODE_FLAG_CSYNC ; if ( misc & ATOM_INTERLACE ) mode -> flags |= DRM_MODE_FLAG_INTERLACE ; if ( misc & ATOM_DOUBLE_CLOCK_MODE ) mode -> flags |= DRM_MODE_FLAG_DBLSCAN ; mode -> clock = le16_to_cpu ( tv_info -> aModeTimings [ index ] . usPixelClock ) * 10 ; if ( index == 1 ) { mode -> crtc_htotal -= 1 ; mode -> crtc_vtotal -= 1 ; } break ; case 2 : tv_info_v1_2 = ( ATOM_ANALOG_TV_INFO_V1_2 * ) ( mode_info -> atom_context -> bios + data_offset ) ; <S2SV_StartBug> if ( index > MAX_SUPPORTED_TV_TIMING_V1_2 ) <S2SV_EndBug> return false ; dtd_timings = & tv_info_v1_2 -> aModeTimings [ index ] ; mode -> crtc_htotal = le16_to_cpu ( dtd_timings -> usHActive ) + le16_to_cpu ( dtd_timings -> usHBlanking_Time ) ; mode -> crtc_hdisplay = le16_to_cpu ( dtd_timings -> usHActive ) ; mode -> crtc_hsync_start = le16_to_cpu ( dtd_timings -> usHActive ) + le16_to_cpu ( dtd_timings -> usHSyncOffset ) ; mode -> crtc_hsync_end = mode -> crtc_hsync_start + le16_to_cpu ( dtd_timings -> usHSyncWidth ) ; mode -> crtc_vtotal = le16_to_cpu ( dtd_timings -> usVActive ) + le16_to_cpu ( dtd_timings -> usVBlanking_Time ) ; mode -> crtc_vdisplay = le16_to_cpu ( dtd_timings -> usVActive ) ; mode -> crtc_vsync_start = le16_to_cpu ( dtd_timings -> usVActive ) + le16_to_cpu ( dtd_timings -> usVSyncOffset ) ; mode -> crtc_vsync_end = mode -> crtc_vsync_start + le16_to_cpu ( dtd_timings -> usVSyncWidth ) ; mode -> flags = 0 ; misc = le16_to_cpu ( dtd_timings -> susModeMiscInfo . usAccess ) ; if ( misc & ATOM_VSYNC_POLARITY ) mode -> flags |= DRM_MODE_FLAG_NVSYNC ; if ( misc & ATOM_HSYNC_POLARITY ) mode -> flags |= DRM_MODE_FLAG_NHSYNC ; if ( misc & ATOM_COMPOSITESYNC ) mode -> flags |= DRM_MODE_FLAG_CSYNC ; if ( misc & ATOM_INTERLACE ) mode -> flags |= DRM_MODE_FLAG_INTERLACE ; if ( misc & ATOM_DOUBLE_CLOCK_MODE ) mode -> flags |= DRM_MODE_FLAG_DBLSCAN ; mode -> clock = le16_to_cpu ( dtd_timings -> usPixClk ) * 10 ; break ; } return true ; }
CWE-362 static bool blk_kick_flush ( struct request_queue * q , struct blk_flush_queue * fq ) { struct list_head * pending = & fq -> flush_queue [ fq -> flush_pending_idx ] ; struct request * first_rq = list_first_entry ( pending , struct request , flush . list ) ; struct request * flush_rq = fq -> flush_rq ; if ( fq -> flush_pending_idx != fq -> flush_running_idx || list_empty ( pending ) ) return false ; if ( ! list_empty ( & fq -> flush_data_in_flight ) && time_before ( jiffies , fq -> flush_pending_since + FLUSH_PENDING_TIMEOUT ) ) return false ; fq -> flush_pending_idx ^= 1 ; blk_rq_init ( q , flush_rq ) ; if ( q -> mq_ops ) { <S2SV_StartBug> flush_rq -> mq_ctx = first_rq -> mq_ctx ; <S2SV_EndBug> <S2SV_StartBug> flush_rq -> tag = first_rq -> tag ; <S2SV_EndBug> } flush_rq -> cmd_type = REQ_TYPE_FS ; flush_rq -> cmd_flags = WRITE_FLUSH | REQ_FLUSH_SEQ ; flush_rq -> rq_disk = first_rq -> rq_disk ; flush_rq -> end_io = flush_end_io ; return blk_flush_queue_rq ( flush_rq , false ) ; }
CWE-362 static void flush_end_io ( struct request * flush_rq , int error ) { struct request_queue * q = flush_rq -> q ; struct list_head * running ; bool queued = false ; struct request * rq , * n ; unsigned long flags = 0 ; struct blk_flush_queue * fq = blk_get_flush_queue ( q , flush_rq -> mq_ctx ) ; if ( q -> mq_ops ) { <S2SV_StartBug> spin_lock_irqsave ( & fq -> mq_flush_lock , flags ) ; <S2SV_EndBug> flush_rq -> tag = - 1 ; } running = & fq -> flush_queue [ fq -> flush_running_idx ] ; BUG_ON ( fq -> flush_pending_idx == fq -> flush_running_idx ) ; fq -> flush_running_idx ^= 1 ; if ( ! q -> mq_ops ) elv_completed_request ( q , flush_rq ) ; list_for_each_entry_safe ( rq , n , running , flush . list ) { unsigned int seq = blk_flush_cur_seq ( rq ) ; BUG_ON ( seq != REQ_FSEQ_PREFLUSH && seq != REQ_FSEQ_POSTFLUSH ) ; queued |= blk_flush_complete_seq ( rq , fq , seq , error ) ; } if ( queued || fq -> flush_queue_delayed ) { WARN_ON ( q -> mq_ops ) ; blk_run_queue_async ( q ) ; } fq -> flush_queue_delayed = 0 ; if ( q -> mq_ops ) spin_unlock_irqrestore ( & fq -> mq_flush_lock , flags ) ; }
CWE-362 static void bt_for_each ( struct blk_mq_hw_ctx * hctx , struct blk_mq_bitmap_tags * bt , unsigned int off , busy_iter_fn * fn , void * data , bool reserved ) { struct request * rq ; int bit , i ; for ( i = 0 ; i < bt -> map_nr ; i ++ ) { struct blk_align_bitmap * bm = & bt -> map [ i ] ; for ( bit = find_first_bit ( & bm -> word , bm -> depth ) ; bit < bm -> depth ; bit = find_next_bit ( & bm -> word , bm -> depth , bit + 1 ) ) { <S2SV_StartBug> rq = blk_mq_tag_to_rq ( hctx -> tags , off + bit ) ; <S2SV_EndBug> if ( rq -> q == hctx -> queue ) fn ( hctx , rq , data , reserved ) ; } off += ( 1 << bt -> bits_per_word ) ; } }
CWE-362 static void bt_tags_for_each ( struct blk_mq_tags * tags , struct blk_mq_bitmap_tags * bt , unsigned int off , busy_tag_iter_fn * fn , void * data , bool reserved ) { struct request * rq ; int bit , i ; if ( ! tags -> rqs ) return ; for ( i = 0 ; i < bt -> map_nr ; i ++ ) { struct blk_align_bitmap * bm = & bt -> map [ i ] ; for ( bit = find_first_bit ( & bm -> word , bm -> depth ) ; bit < bm -> depth ; bit = find_next_bit ( & bm -> word , bm -> depth , bit + 1 ) ) { <S2SV_StartBug> rq = blk_mq_tag_to_rq ( tags , off + bit ) ; <S2SV_EndBug> fn ( rq , data , reserved ) ; } off += ( 1 << bt -> bits_per_word ) ; } }
CWE-362 struct request * blk_mq_tag_to_rq ( struct blk_mq_tags * tags , unsigned int tag ) { <S2SV_StartBug> struct request * rq = tags -> rqs [ tag ] ; <S2SV_EndBug> <S2SV_StartBug> struct blk_flush_queue * fq = blk_get_flush_queue ( rq -> q , rq -> mq_ctx ) ; <S2SV_EndBug> if ( ! is_flush_request ( rq , fq , tag ) ) return rq ; return fq -> flush_rq ; }
CWE-362 void uverbs_user_mmap_disassociate ( struct ib_uverbs_file * ufile ) { struct rdma_umap_priv * priv , * next_priv ; lockdep_assert_held ( & ufile -> hw_destroy_rwsem ) ; while ( 1 ) { struct mm_struct * mm = NULL ; mutex_lock ( & ufile -> umap_lock ) ; while ( ! list_empty ( & ufile -> umaps ) ) { int ret ; priv = list_first_entry ( & ufile -> umaps , struct rdma_umap_priv , list ) ; mm = priv -> vma -> vm_mm ; ret = mmget_not_zero ( mm ) ; if ( ! ret ) { list_del_init ( & priv -> list ) ; mm = NULL ; continue ; } break ; } mutex_unlock ( & ufile -> umap_lock ) ; if ( ! mm ) return ; <S2SV_StartBug> down_write ( & mm -> mmap_sem ) ; <S2SV_EndBug> mutex_lock ( & ufile -> umap_lock ) ; list_for_each_entry_safe ( priv , next_priv , & ufile -> umaps , list ) { struct vm_area_struct * vma = priv -> vma ; if ( vma -> vm_mm != mm ) continue ; list_del_init ( & priv -> list ) ; zap_vma_ptes ( vma , vma -> vm_start , vma -> vm_end - vma -> vm_start ) ; vma -> vm_flags &= ~ ( VM_SHARED | VM_MAYSHARE ) ; } mutex_unlock ( & ufile -> umap_lock ) ; <S2SV_StartBug> up_write ( & mm -> mmap_sem ) ; <S2SV_EndBug> mmput ( mm ) ; } }
CWE-362 static void userfaultfd_event_wait_completion ( struct userfaultfd_ctx * ctx , struct userfaultfd_wait_queue * ewq ) { struct userfaultfd_ctx * release_new_ctx ; if ( WARN_ON_ONCE ( current -> flags & PF_EXITING ) ) goto out ; ewq -> ctx = ctx ; init_waitqueue_entry ( & ewq -> wq , current ) ; release_new_ctx = NULL ; spin_lock ( & ctx -> event_wqh . lock ) ; __add_wait_queue ( & ctx -> event_wqh , & ewq -> wq ) ; for ( ; ; ) { set_current_state ( TASK_KILLABLE ) ; if ( ewq -> msg . event == 0 ) break ; if ( READ_ONCE ( ctx -> released ) || fatal_signal_pending ( current ) ) { __remove_wait_queue ( & ctx -> event_wqh , & ewq -> wq ) ; if ( ewq -> msg . event == UFFD_EVENT_FORK ) { struct userfaultfd_ctx * new ; new = ( struct userfaultfd_ctx * ) ( unsigned long ) ewq -> msg . arg . reserved . reserved1 ; release_new_ctx = new ; } break ; } spin_unlock ( & ctx -> event_wqh . lock ) ; wake_up_poll ( & ctx -> fd_wqh , EPOLLIN ) ; schedule ( ) ; spin_lock ( & ctx -> event_wqh . lock ) ; } __set_current_state ( TASK_RUNNING ) ; spin_unlock ( & ctx -> event_wqh . lock ) ; if ( release_new_ctx ) { struct vm_area_struct * vma ; struct mm_struct * mm = release_new_ctx -> mm ; down_write ( & mm -> mmap_sem ) ; <S2SV_StartBug> for ( vma = mm -> mmap ; vma ; vma = vma -> vm_next ) <S2SV_EndBug> if ( vma -> vm_userfaultfd_ctx . ctx == release_new_ctx ) { vma -> vm_userfaultfd_ctx = NULL_VM_UFFD_CTX ; vma -> vm_flags &= ~ ( VM_UFFD_WP | VM_UFFD_MISSING ) ; } up_write ( & mm -> mmap_sem ) ; userfaultfd_ctx_put ( release_new_ctx ) ; } out : WRITE_ONCE ( ctx -> mmap_changing , false ) ; userfaultfd_ctx_put ( ctx ) ; }
CWE-362 static int userfaultfd_register ( struct userfaultfd_ctx * ctx , unsigned long arg ) { struct mm_struct * mm = ctx -> mm ; struct vm_area_struct * vma , * prev , * cur ; int ret ; struct uffdio_register uffdio_register ; struct uffdio_register __user * user_uffdio_register ; unsigned long vm_flags , new_flags ; bool found ; bool basic_ioctls ; unsigned long start , end , vma_end ; user_uffdio_register = ( struct uffdio_register __user * ) arg ; ret = - EFAULT ; if ( copy_from_user ( & uffdio_register , user_uffdio_register , sizeof ( uffdio_register ) - sizeof ( __u64 ) ) ) goto out ; ret = - EINVAL ; if ( ! uffdio_register . mode ) goto out ; if ( uffdio_register . mode & ~ ( UFFDIO_REGISTER_MODE_MISSING | UFFDIO_REGISTER_MODE_WP ) ) goto out ; vm_flags = 0 ; if ( uffdio_register . mode & UFFDIO_REGISTER_MODE_MISSING ) vm_flags |= VM_UFFD_MISSING ; if ( uffdio_register . mode & UFFDIO_REGISTER_MODE_WP ) { vm_flags |= VM_UFFD_WP ; ret = - EINVAL ; goto out ; } ret = validate_range ( mm , uffdio_register . range . start , uffdio_register . range . len ) ; if ( ret ) goto out ; start = uffdio_register . range . start ; end = start + uffdio_register . range . len ; ret = - ENOMEM ; if ( ! mmget_not_zero ( mm ) ) goto out ; <S2SV_StartBug> down_write ( & mm -> mmap_sem ) ; <S2SV_EndBug> vma = find_vma_prev ( mm , start , & prev ) ; if ( ! vma ) goto out_unlock ; ret = - EINVAL ; if ( vma -> vm_start >= end ) goto out_unlock ; if ( is_vm_hugetlb_page ( vma ) ) { unsigned long vma_hpagesize = vma_kernel_pagesize ( vma ) ; if ( start & ( vma_hpagesize - 1 ) ) goto out_unlock ; } found = false ; basic_ioctls = false ; for ( cur = vma ; cur && cur -> vm_start < end ; cur = cur -> vm_next ) { cond_resched ( ) ; BUG_ON ( ! ! cur -> vm_userfaultfd_ctx . ctx ^ ! ! ( cur -> vm_flags & ( VM_UFFD_MISSING | VM_UFFD_WP ) ) ) ; ret = - EINVAL ; if ( ! vma_can_userfault ( cur ) ) goto out_unlock ; ret = - EPERM ; if ( unlikely ( ! ( cur -> vm_flags & VM_MAYWRITE ) ) ) goto out_unlock ; if ( is_vm_hugetlb_page ( cur ) && end <= cur -> vm_end && end > cur -> vm_start ) { unsigned long vma_hpagesize = vma_kernel_pagesize ( cur ) ; ret = - EINVAL ; if ( end & ( vma_hpagesize - 1 ) ) goto out_unlock ; } ret = - EBUSY ; if ( cur -> vm_userfaultfd_ctx . ctx && cur -> vm_userfaultfd_ctx . ctx != ctx ) goto out_unlock ; if ( is_vm_hugetlb_page ( cur ) ) basic_ioctls = true ; found = true ; } BUG_ON ( ! found ) ; if ( vma -> vm_start < start ) prev = vma ; ret = 0 ; do { cond_resched ( ) ; BUG_ON ( ! vma_can_userfault ( vma ) ) ; BUG_ON ( vma -> vm_userfaultfd_ctx . ctx && vma -> vm_userfaultfd_ctx . ctx != ctx ) ; WARN_ON ( ! ( vma -> vm_flags & VM_MAYWRITE ) ) ; if ( vma -> vm_userfaultfd_ctx . ctx == ctx && ( vma -> vm_flags & vm_flags ) == vm_flags ) goto skip ; if ( vma -> vm_start > start ) start = vma -> vm_start ; vma_end = min ( end , vma -> vm_end ) ; new_flags = ( vma -> vm_flags & ~ vm_flags ) | vm_flags ; prev = vma_merge ( mm , prev , start , vma_end , new_flags , vma -> anon_vma , vma -> vm_file , vma -> vm_pgoff , vma_policy ( vma ) , ( ( struct vm_userfaultfd_ctx ) { ctx } ) ) ; if ( prev ) { vma = prev ; goto next ; } if ( vma -> vm_start < start ) { ret = split_vma ( mm , vma , start , 1 ) ; if ( ret ) break ; } if ( vma -> vm_end > end ) { ret = split_vma ( mm , vma , end , 0 ) ; if ( ret ) break ; } next : vma -> vm_flags = new_flags ; vma -> vm_userfaultfd_ctx . ctx = ctx ; skip : prev = vma ; start = vma -> vm_end ; vma = vma -> vm_next ; } while ( vma && vma -> vm_start < end ) ; out_unlock : up_write ( & mm -> mmap_sem ) ; mmput ( mm ) ; if ( ! ret ) { if ( put_user ( basic_ioctls ? UFFD_API_RANGE_IOCTLS_BASIC : UFFD_API_RANGE_IOCTLS , & user_uffdio_register -> ioctls ) ) ret = - EFAULT ; } out : return ret ; }
CWE-362 static int userfaultfd_release ( struct inode * inode , struct file * file ) { struct userfaultfd_ctx * ctx = file -> private_data ; struct mm_struct * mm = ctx -> mm ; struct vm_area_struct * vma , * prev ; struct userfaultfd_wake_range range = { . len = 0 , } ; unsigned long new_flags ; WRITE_ONCE ( ctx -> released , true ) ; if ( ! mmget_not_zero ( mm ) ) goto wakeup ; down_write ( & mm -> mmap_sem ) ; <S2SV_StartBug> prev = NULL ; <S2SV_EndBug> for ( vma = mm -> mmap ; vma ; vma = vma -> vm_next ) { cond_resched ( ) ; BUG_ON ( ! ! vma -> vm_userfaultfd_ctx . ctx ^ ! ! ( vma -> vm_flags & ( VM_UFFD_MISSING | VM_UFFD_WP ) ) ) ; if ( vma -> vm_userfaultfd_ctx . ctx != ctx ) { prev = vma ; continue ; } new_flags = vma -> vm_flags & ~ ( VM_UFFD_MISSING | VM_UFFD_WP ) ; prev = vma_merge ( mm , prev , vma -> vm_start , vma -> vm_end , new_flags , vma -> anon_vma , vma -> vm_file , vma -> vm_pgoff , vma_policy ( vma ) , NULL_VM_UFFD_CTX ) ; if ( prev ) vma = prev ; else prev = vma ; vma -> vm_flags = new_flags ; vma -> vm_userfaultfd_ctx = NULL_VM_UFFD_CTX ; } <S2SV_StartBug> up_write ( & mm -> mmap_sem ) ; <S2SV_EndBug> mmput ( mm ) ; wakeup : spin_lock ( & ctx -> fault_pending_wqh . lock ) ; __wake_up_locked_key ( & ctx -> fault_pending_wqh , TASK_NORMAL , & range ) ; __wake_up ( & ctx -> fault_wqh , TASK_NORMAL , 1 , & range ) ; spin_unlock ( & ctx -> fault_pending_wqh . lock ) ; wake_up_all ( & ctx -> event_wqh ) ; wake_up_poll ( & ctx -> fd_wqh , EPOLLHUP ) ; userfaultfd_ctx_put ( ctx ) ; return 0 ; }
CWE-362 static int userfaultfd_unregister ( struct userfaultfd_ctx * ctx , unsigned long arg ) { struct mm_struct * mm = ctx -> mm ; struct vm_area_struct * vma , * prev , * cur ; int ret ; struct uffdio_range uffdio_unregister ; unsigned long new_flags ; bool found ; unsigned long start , end , vma_end ; const void __user * buf = ( void __user * ) arg ; ret = - EFAULT ; if ( copy_from_user ( & uffdio_unregister , buf , sizeof ( uffdio_unregister ) ) ) goto out ; ret = validate_range ( mm , uffdio_unregister . start , uffdio_unregister . len ) ; if ( ret ) goto out ; start = uffdio_unregister . start ; end = start + uffdio_unregister . len ; ret = - ENOMEM ; if ( ! mmget_not_zero ( mm ) ) goto out ; down_write ( & mm -> mmap_sem ) ; <S2SV_StartBug> vma = find_vma_prev ( mm , start , & prev ) ; <S2SV_EndBug> if ( ! vma ) goto out_unlock ; ret = - EINVAL ; if ( vma -> vm_start >= end ) goto out_unlock ; if ( is_vm_hugetlb_page ( vma ) ) { unsigned long vma_hpagesize = vma_kernel_pagesize ( vma ) ; if ( start & ( vma_hpagesize - 1 ) ) goto out_unlock ; } found = false ; ret = - EINVAL ; for ( cur = vma ; cur && cur -> vm_start < end ; cur = cur -> vm_next ) { cond_resched ( ) ; BUG_ON ( ! ! cur -> vm_userfaultfd_ctx . ctx ^ ! ! ( cur -> vm_flags & ( VM_UFFD_MISSING | VM_UFFD_WP ) ) ) ; if ( ! vma_can_userfault ( cur ) ) goto out_unlock ; found = true ; } BUG_ON ( ! found ) ; if ( vma -> vm_start < start ) prev = vma ; ret = 0 ; do { cond_resched ( ) ; BUG_ON ( ! vma_can_userfault ( vma ) ) ; if ( ! vma -> vm_userfaultfd_ctx . ctx ) goto skip ; WARN_ON ( ! ( vma -> vm_flags & VM_MAYWRITE ) ) ; if ( vma -> vm_start > start ) start = vma -> vm_start ; vma_end = min ( end , vma -> vm_end ) ; if ( userfaultfd_missing ( vma ) ) { struct userfaultfd_wake_range range ; range . start = start ; range . len = vma_end - start ; wake_userfault ( vma -> vm_userfaultfd_ctx . ctx , & range ) ; } new_flags = vma -> vm_flags & ~ ( VM_UFFD_MISSING | VM_UFFD_WP ) ; prev = vma_merge ( mm , prev , start , vma_end , new_flags , vma -> anon_vma , vma -> vm_file , vma -> vm_pgoff , vma_policy ( vma ) , NULL_VM_UFFD_CTX ) ; if ( prev ) { vma = prev ; goto next ; } if ( vma -> vm_start < start ) { ret = split_vma ( mm , vma , start , 1 ) ; if ( ret ) break ; } if ( vma -> vm_end > end ) { ret = split_vma ( mm , vma , end , 0 ) ; if ( ret ) break ; } next : vma -> vm_flags = new_flags ; vma -> vm_userfaultfd_ctx = NULL_VM_UFFD_CTX ; skip : prev = vma ; start = vma -> vm_end ; vma = vma -> vm_next ; } while ( vma && vma -> vm_start < end ) ; out_unlock : up_write ( & mm -> mmap_sem ) ; mmput ( mm ) ; out : return ret ; }
CWE-362 struct vm_area_struct * find_extend_vma ( struct mm_struct * mm , unsigned long addr ) { struct vm_area_struct * vma ; unsigned long start ; addr &= PAGE_MASK ; vma = find_vma ( mm , addr ) ; if ( ! vma ) return NULL ; if ( vma -> vm_start <= addr ) return vma ; if ( ! ( vma -> vm_flags & VM_GROWSDOWN ) ) return NULL ; <S2SV_StartBug> start = vma -> vm_start ; <S2SV_EndBug> if ( expand_stack ( vma , addr ) ) return NULL ; if ( vma -> vm_flags & VM_LOCKED ) populate_vma_page_range ( vma , addr , start , NULL ) ; return vma ; }
CWE-119 static int create_qp_common ( struct mlx5_ib_dev * dev , struct ib_pd * pd , struct ib_qp_init_attr * init_attr , struct ib_udata * udata , struct mlx5_ib_qp * qp ) { struct mlx5_ib_resources * devr = & dev -> devr ; int inlen = MLX5_ST_SZ_BYTES ( create_qp_in ) ; struct mlx5_core_dev * mdev = dev -> mdev ; <S2SV_StartBug> struct mlx5_ib_create_qp_resp resp ; <S2SV_EndBug> struct mlx5_ib_cq * send_cq ; struct mlx5_ib_cq * recv_cq ; unsigned long flags ; u32 uidx = MLX5_IB_DEFAULT_UIDX ; struct mlx5_ib_create_qp ucmd ; struct mlx5_ib_qp_base * base ; int mlx5_st ; void * qpc ; u32 * in ; int err ; mutex_init ( & qp -> mutex ) ; spin_lock_init ( & qp -> sq . lock ) ; spin_lock_init ( & qp -> rq . lock ) ; mlx5_st = to_mlx5_st ( init_attr -> qp_type ) ; if ( mlx5_st < 0 ) return - EINVAL ; if ( init_attr -> rwq_ind_tbl ) { if ( ! udata ) return - ENOSYS ; err = create_rss_raw_qp_tir ( dev , qp , pd , init_attr , udata ) ; return err ; } if ( init_attr -> create_flags & IB_QP_CREATE_BLOCK_MULTICAST_LOOPBACK ) { if ( ! MLX5_CAP_GEN ( mdev , block_lb_mc ) ) { mlx5_ib_dbg ( dev , "block<S2SV_blank>multicast<S2SV_blank>loopback<S2SV_blank>isn\'t<S2SV_blank>supported\\n" ) ; return - EINVAL ; } else { qp -> flags |= MLX5_IB_QP_BLOCK_MULTICAST_LOOPBACK ; } } if ( init_attr -> create_flags & ( IB_QP_CREATE_CROSS_CHANNEL | IB_QP_CREATE_MANAGED_SEND | IB_QP_CREATE_MANAGED_RECV ) ) { if ( ! MLX5_CAP_GEN ( mdev , cd ) ) { mlx5_ib_dbg ( dev , "cross-channel<S2SV_blank>isn\'t<S2SV_blank>supported\\n" ) ; return - EINVAL ; } if ( init_attr -> create_flags & IB_QP_CREATE_CROSS_CHANNEL ) qp -> flags |= MLX5_IB_QP_CROSS_CHANNEL ; if ( init_attr -> create_flags & IB_QP_CREATE_MANAGED_SEND ) qp -> flags |= MLX5_IB_QP_MANAGED_SEND ; if ( init_attr -> create_flags & IB_QP_CREATE_MANAGED_RECV ) qp -> flags |= MLX5_IB_QP_MANAGED_RECV ; } if ( init_attr -> qp_type == IB_QPT_UD && ( init_attr -> create_flags & IB_QP_CREATE_IPOIB_UD_LSO ) ) if ( ! MLX5_CAP_GEN ( mdev , ipoib_basic_offloads ) ) { mlx5_ib_dbg ( dev , "ipoib<S2SV_blank>UD<S2SV_blank>lso<S2SV_blank>qp<S2SV_blank>isn\'t<S2SV_blank>supported\\n" ) ; return - EOPNOTSUPP ; } if ( init_attr -> create_flags & IB_QP_CREATE_SCATTER_FCS ) { if ( init_attr -> qp_type != IB_QPT_RAW_PACKET ) { mlx5_ib_dbg ( dev , "Scatter<S2SV_blank>FCS<S2SV_blank>is<S2SV_blank>supported<S2SV_blank>only<S2SV_blank>for<S2SV_blank>Raw<S2SV_blank>Packet<S2SV_blank>QPs" ) ; return - EOPNOTSUPP ; } if ( ! MLX5_CAP_GEN ( dev -> mdev , eth_net_offloads ) || ! MLX5_CAP_ETH ( dev -> mdev , scatter_fcs ) ) { mlx5_ib_dbg ( dev , "Scatter<S2SV_blank>FCS<S2SV_blank>isn\'t<S2SV_blank>supported\\n" ) ; return - EOPNOTSUPP ; } qp -> flags |= MLX5_IB_QP_CAP_SCATTER_FCS ; } if ( init_attr -> sq_sig_type == IB_SIGNAL_ALL_WR ) qp -> sq_signal_bits = MLX5_WQE_CTRL_CQ_UPDATE ; if ( init_attr -> create_flags & IB_QP_CREATE_CVLAN_STRIPPING ) { if ( ! ( MLX5_CAP_GEN ( dev -> mdev , eth_net_offloads ) && MLX5_CAP_ETH ( dev -> mdev , vlan_cap ) ) || ( init_attr -> qp_type != IB_QPT_RAW_PACKET ) ) return - EOPNOTSUPP ; qp -> flags |= MLX5_IB_QP_CVLAN_STRIPPING ; } if ( pd && pd -> uobject ) { if ( ib_copy_from_udata ( & ucmd , udata , sizeof ( ucmd ) ) ) { mlx5_ib_dbg ( dev , "copy<S2SV_blank>failed\\n" ) ; return - EFAULT ; } err = get_qp_user_index ( to_mucontext ( pd -> uobject -> context ) , & ucmd , udata -> inlen , & uidx ) ; if ( err ) return err ; qp -> wq_sig = ! ! ( ucmd . flags & MLX5_QP_FLAG_SIGNATURE ) ; qp -> scat_cqe = ! ! ( ucmd . flags & MLX5_QP_FLAG_SCATTER_CQE ) ; if ( ucmd . flags & MLX5_QP_FLAG_TUNNEL_OFFLOADS ) { if ( init_attr -> qp_type != IB_QPT_RAW_PACKET || ! tunnel_offload_supported ( mdev ) ) { mlx5_ib_dbg ( dev , "Tunnel<S2SV_blank>offload<S2SV_blank>isn\'t<S2SV_blank>supported\\n" ) ; return - EOPNOTSUPP ; } qp -> tunnel_offload_en = true ; } if ( init_attr -> create_flags & IB_QP_CREATE_SOURCE_QPN ) { if ( init_attr -> qp_type != IB_QPT_UD || ( MLX5_CAP_GEN ( dev -> mdev , port_type ) != MLX5_CAP_PORT_TYPE_IB ) || ! mlx5_get_flow_namespace ( dev -> mdev , MLX5_FLOW_NAMESPACE_BYPASS ) ) { mlx5_ib_dbg ( dev , "Source<S2SV_blank>QP<S2SV_blank>option<S2SV_blank>isn\'t<S2SV_blank>supported\\n" ) ; return - EOPNOTSUPP ; } qp -> flags |= MLX5_IB_QP_UNDERLAY ; qp -> underlay_qpn = init_attr -> source_qpn ; } } else { qp -> wq_sig = ! ! wq_signature ; } base = ( init_attr -> qp_type == IB_QPT_RAW_PACKET || qp -> flags & MLX5_IB_QP_UNDERLAY ) ? & qp -> raw_packet_qp . rq . base : & qp -> trans_qp . base ; qp -> has_rq = qp_has_rq ( init_attr ) ; err = set_rq_size ( dev , & init_attr -> cap , qp -> has_rq , qp , ( pd && pd -> uobject ) ? & ucmd : NULL ) ; if ( err ) { mlx5_ib_dbg ( dev , "err<S2SV_blank>%d\\n" , err ) ; return err ; } if ( pd ) { if ( pd -> uobject ) { __u32 max_wqes = 1 << MLX5_CAP_GEN ( mdev , log_max_qp_sz ) ; mlx5_ib_dbg ( dev , "requested<S2SV_blank>sq_wqe_count<S2SV_blank>(%d)\\n" , ucmd . sq_wqe_count ) ; if ( ucmd . rq_wqe_shift != qp -> rq . wqe_shift || ucmd . rq_wqe_count != qp -> rq . wqe_cnt ) { mlx5_ib_dbg ( dev , "invalid<S2SV_blank>rq<S2SV_blank>params\\n" ) ; return - EINVAL ; } if ( ucmd . sq_wqe_count > max_wqes ) { mlx5_ib_dbg ( dev , "requested<S2SV_blank>sq_wqe_count<S2SV_blank>(%d)<S2SV_blank>><S2SV_blank>max<S2SV_blank>allowed<S2SV_blank>(%d)\\n" , ucmd . sq_wqe_count , max_wqes ) ; return - EINVAL ; } if ( init_attr -> create_flags & mlx5_ib_create_qp_sqpn_qp1 ( ) ) { mlx5_ib_dbg ( dev , "user-space<S2SV_blank>is<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>UD<S2SV_blank>QPs<S2SV_blank>spoofing<S2SV_blank>as<S2SV_blank>QP1\\n" ) ; return - EINVAL ; } err = create_user_qp ( dev , pd , qp , udata , init_attr , & in , & resp , & inlen , base ) ; if ( err ) mlx5_ib_dbg ( dev , "err<S2SV_blank>%d\\n" , err ) ; } else { err = create_kernel_qp ( dev , init_attr , qp , & in , & inlen , base ) ; if ( err ) mlx5_ib_dbg ( dev , "err<S2SV_blank>%d\\n" , err ) ; } if ( err ) return err ; } else { in = kvzalloc ( inlen , GFP_KERNEL ) ; if ( ! in ) return - ENOMEM ; qp -> create_type = MLX5_QP_EMPTY ; } if ( is_sqp ( init_attr -> qp_type ) ) qp -> port = init_attr -> port_num ; qpc = MLX5_ADDR_OF ( create_qp_in , in , qpc ) ; MLX5_SET ( qpc , qpc , st , mlx5_st ) ; MLX5_SET ( qpc , qpc , pm_state , MLX5_QP_PM_MIGRATED ) ; if ( init_attr -> qp_type != MLX5_IB_QPT_REG_UMR ) MLX5_SET ( qpc , qpc , pd , to_mpd ( pd ? pd : devr -> p0 ) -> pdn ) ; else MLX5_SET ( qpc , qpc , latency_sensitive , 1 ) ; if ( qp -> wq_sig ) MLX5_SET ( qpc , qpc , wq_signature , 1 ) ; if ( qp -> flags & MLX5_IB_QP_BLOCK_MULTICAST_LOOPBACK ) MLX5_SET ( qpc , qpc , block_lb_mc , 1 ) ; if ( qp -> flags & MLX5_IB_QP_CROSS_CHANNEL ) MLX5_SET ( qpc , qpc , cd_master , 1 ) ; if ( qp -> flags & MLX5_IB_QP_MANAGED_SEND ) MLX5_SET ( qpc , qpc , cd_slave_send , 1 ) ; if ( qp -> flags & MLX5_IB_QP_MANAGED_RECV ) MLX5_SET ( qpc , qpc , cd_slave_receive , 1 ) ; if ( qp -> scat_cqe && is_connected ( init_attr -> qp_type ) ) { int rcqe_sz ; int scqe_sz ; rcqe_sz = mlx5_ib_get_cqe_size ( dev , init_attr -> recv_cq ) ; scqe_sz = mlx5_ib_get_cqe_size ( dev , init_attr -> send_cq ) ; if ( rcqe_sz == 128 ) MLX5_SET ( qpc , qpc , cs_res , MLX5_RES_SCAT_DATA64_CQE ) ; else MLX5_SET ( qpc , qpc , cs_res , MLX5_RES_SCAT_DATA32_CQE ) ; if ( init_attr -> sq_sig_type == IB_SIGNAL_ALL_WR ) { if ( scqe_sz == 128 ) MLX5_SET ( qpc , qpc , cs_req , MLX5_REQ_SCAT_DATA64_CQE ) ; else MLX5_SET ( qpc , qpc , cs_req , MLX5_REQ_SCAT_DATA32_CQE ) ; } } if ( qp -> rq . wqe_cnt ) { MLX5_SET ( qpc , qpc , log_rq_stride , qp -> rq . wqe_shift - 4 ) ; MLX5_SET ( qpc , qpc , log_rq_size , ilog2 ( qp -> rq . wqe_cnt ) ) ; } MLX5_SET ( qpc , qpc , rq_type , get_rx_type ( qp , init_attr ) ) ; if ( qp -> sq . wqe_cnt ) { MLX5_SET ( qpc , qpc , log_sq_size , ilog2 ( qp -> sq . wqe_cnt ) ) ; } else { MLX5_SET ( qpc , qpc , no_sq , 1 ) ; if ( init_attr -> srq && init_attr -> srq -> srq_type == IB_SRQT_TM ) MLX5_SET ( qpc , qpc , offload_type , MLX5_QPC_OFFLOAD_TYPE_RNDV ) ; } switch ( init_attr -> qp_type ) { case IB_QPT_XRC_TGT : MLX5_SET ( qpc , qpc , cqn_rcv , to_mcq ( devr -> c0 ) -> mcq . cqn ) ; MLX5_SET ( qpc , qpc , cqn_snd , to_mcq ( devr -> c0 ) -> mcq . cqn ) ; MLX5_SET ( qpc , qpc , srqn_rmpn_xrqn , to_msrq ( devr -> s0 ) -> msrq . srqn ) ; MLX5_SET ( qpc , qpc , xrcd , to_mxrcd ( init_attr -> xrcd ) -> xrcdn ) ; break ; case IB_QPT_XRC_INI : MLX5_SET ( qpc , qpc , cqn_rcv , to_mcq ( devr -> c0 ) -> mcq . cqn ) ; MLX5_SET ( qpc , qpc , xrcd , to_mxrcd ( devr -> x1 ) -> xrcdn ) ; MLX5_SET ( qpc , qpc , srqn_rmpn_xrqn , to_msrq ( devr -> s0 ) -> msrq . srqn ) ; break ; default : if ( init_attr -> srq ) { MLX5_SET ( qpc , qpc , xrcd , to_mxrcd ( devr -> x0 ) -> xrcdn ) ; MLX5_SET ( qpc , qpc , srqn_rmpn_xrqn , to_msrq ( init_attr -> srq ) -> msrq . srqn ) ; } else { MLX5_SET ( qpc , qpc , xrcd , to_mxrcd ( devr -> x1 ) -> xrcdn ) ; MLX5_SET ( qpc , qpc , srqn_rmpn_xrqn , to_msrq ( devr -> s1 ) -> msrq . srqn ) ; } } if ( init_attr -> send_cq ) MLX5_SET ( qpc , qpc , cqn_snd , to_mcq ( init_attr -> send_cq ) -> mcq . cqn ) ; if ( init_attr -> recv_cq ) MLX5_SET ( qpc , qpc , cqn_rcv , to_mcq ( init_attr -> recv_cq ) -> mcq . cqn ) ; MLX5_SET64 ( qpc , qpc , dbr_addr , qp -> db . dma ) ; if ( MLX5_CAP_GEN ( mdev , cqe_version ) == MLX5_CQE_VERSION_V1 ) MLX5_SET ( qpc , qpc , user_index , uidx ) ; if ( init_attr -> qp_type == IB_QPT_UD && ( init_attr -> create_flags & IB_QP_CREATE_IPOIB_UD_LSO ) ) { MLX5_SET ( qpc , qpc , ulp_stateless_offload_mode , 1 ) ; qp -> flags |= MLX5_IB_QP_LSO ; } if ( init_attr -> create_flags & IB_QP_CREATE_PCI_WRITE_END_PADDING ) { if ( ! MLX5_CAP_GEN ( dev -> mdev , end_pad ) ) { mlx5_ib_dbg ( dev , "scatter<S2SV_blank>end<S2SV_blank>padding<S2SV_blank>is<S2SV_blank>not<S2SV_blank>supported\\n" ) ; err = - EOPNOTSUPP ; goto err ; } else if ( init_attr -> qp_type != IB_QPT_RAW_PACKET ) { MLX5_SET ( qpc , qpc , end_padding_mode , MLX5_WQ_END_PAD_MODE_ALIGN ) ; } else { qp -> flags |= MLX5_IB_QP_PCI_WRITE_END_PADDING ; } } if ( inlen < 0 ) { err = - EINVAL ; goto err ; } if ( init_attr -> qp_type == IB_QPT_RAW_PACKET || qp -> flags & MLX5_IB_QP_UNDERLAY ) { qp -> raw_packet_qp . sq . ubuffer . buf_addr = ucmd . sq_buf_addr ; raw_packet_qp_copy_info ( qp , & qp -> raw_packet_qp ) ; err = create_raw_packet_qp ( dev , qp , in , inlen , pd ) ; } else { err = mlx5_core_create_qp ( dev -> mdev , & base -> mqp , in , inlen ) ; } if ( err ) { mlx5_ib_dbg ( dev , "create<S2SV_blank>qp<S2SV_blank>failed\\n" ) ; goto err_create ; } kvfree ( in ) ; base -> container_mibqp = qp ; base -> mqp . event = mlx5_ib_qp_event ; get_cqs ( init_attr -> qp_type , init_attr -> send_cq , init_attr -> recv_cq , & send_cq , & recv_cq ) ; spin_lock_irqsave ( & dev -> reset_flow_resource_lock , flags ) ; mlx5_ib_lock_cqs ( send_cq , recv_cq ) ; list_add_tail ( & qp -> qps_list , & dev -> qp_list ) ; if ( send_cq ) list_add_tail ( & qp -> cq_send_list , & send_cq -> list_send_qp ) ; if ( recv_cq ) list_add_tail ( & qp -> cq_recv_list , & recv_cq -> list_recv_qp ) ; mlx5_ib_unlock_cqs ( send_cq , recv_cq ) ; spin_unlock_irqrestore ( & dev -> reset_flow_resource_lock , flags ) ; return 0 ; err_create : if ( qp -> create_type == MLX5_QP_USER ) destroy_qp_user ( dev , pd , qp , base ) ; else if ( qp -> create_type == MLX5_QP_KERNEL ) destroy_qp_kernel ( dev , qp ) ; err : kvfree ( in ) ; return err ; }
CWE-189 static ssize_t f_hidg_write ( struct file * file , const char __user * buffer , size_t count , loff_t * offp ) { struct f_hidg * hidg = file -> private_data ; struct usb_request * req ; unsigned long flags ; ssize_t status = - ENOMEM ; if ( ! access_ok ( buffer , count ) ) return - EFAULT ; spin_lock_irqsave ( & hidg -> write_spinlock , flags ) ; # define WRITE_COND ( ! hidg -> write_pending ) try_again : while ( ! WRITE_COND ) { spin_unlock_irqrestore ( & hidg -> write_spinlock , flags ) ; if ( file -> f_flags & O_NONBLOCK ) return - EAGAIN ; if ( wait_event_interruptible_exclusive ( hidg -> write_queue , WRITE_COND ) ) return - ERESTARTSYS ; spin_lock_irqsave ( & hidg -> write_spinlock , flags ) ; } hidg -> write_pending = 1 ; req = hidg -> req ; count = min_t ( unsigned , count , hidg -> report_length ) ; spin_unlock_irqrestore ( & hidg -> write_spinlock , flags ) ; status = copy_from_user ( req -> buf , buffer , count ) ; if ( status != 0 ) { ERROR ( hidg -> func . config -> cdev , "copy_from_user<S2SV_blank>error\\n" ) ; status = - EINVAL ; goto release_write_pending ; } spin_lock_irqsave ( & hidg -> write_spinlock , flags ) ; if ( ! hidg -> req ) { free_ep_req ( hidg -> in_ep , req ) ; goto try_again ; } req -> status = 0 ; req -> zero = 0 ; req -> length = count ; req -> complete = f_hidg_req_complete ; req -> context = hidg ; <S2SV_StartBug> status = usb_ep_queue ( hidg -> in_ep , req , GFP_ATOMIC ) ; <S2SV_EndBug> if ( status < 0 ) { ERROR ( hidg -> func . config -> cdev , "usb_ep_queue<S2SV_blank>error<S2SV_blank>on<S2SV_blank>int<S2SV_blank>endpoint<S2SV_blank>%zd\\n" , status ) ; <S2SV_StartBug> goto release_write_pending_unlocked ; <S2SV_EndBug> } else { status = count ; } <S2SV_StartBug> spin_unlock_irqrestore ( & hidg -> write_spinlock , flags ) ; <S2SV_EndBug> return status ; release_write_pending : spin_lock_irqsave ( & hidg -> write_spinlock , flags ) ; <S2SV_StartBug> release_write_pending_unlocked : <S2SV_EndBug> hidg -> write_pending = 0 ; spin_unlock_irqrestore ( & hidg -> write_spinlock , flags ) ; wake_up ( & hidg -> write_queue ) ; return status ; }
CWE-416 static void * __ns_get_path ( struct path * path , struct ns_common * ns ) { struct vfsmount * mnt = nsfs_mnt ; struct qstr qname = { . name = "" , } ; struct dentry * dentry ; struct inode * inode ; unsigned long d ; rcu_read_lock ( ) ; d = atomic_long_read ( & ns -> stashed ) ; if ( ! d ) goto slow ; dentry = ( struct dentry * ) d ; if ( ! lockref_get_not_dead ( & dentry -> d_lockref ) ) goto slow ; rcu_read_unlock ( ) ; ns -> ops -> put ( ns ) ; got_it : path -> mnt = mntget ( mnt ) ; path -> dentry = dentry ; return NULL ; slow : rcu_read_unlock ( ) ; inode = new_inode_pseudo ( mnt -> mnt_sb ) ; if ( ! inode ) { ns -> ops -> put ( ns ) ; return ERR_PTR ( - ENOMEM ) ; } inode -> i_ino = ns -> inum ; inode -> i_mtime = inode -> i_atime = inode -> i_ctime = current_time ( inode ) ; inode -> i_flags |= S_IMMUTABLE ; inode -> i_mode = S_IFREG | S_IRUGO ; inode -> i_fop = & ns_file_operations ; inode -> i_private = ns ; dentry = d_alloc_pseudo ( mnt -> mnt_sb , & qname ) ; if ( ! dentry ) { iput ( inode ) ; return ERR_PTR ( - ENOMEM ) ; } d_instantiate ( dentry , inode ) ; <S2SV_StartBug> dentry -> d_fsdata = ( void * ) ns -> ops ; <S2SV_EndBug> d = atomic_long_cmpxchg ( & ns -> stashed , 0 , ( unsigned long ) dentry ) ; if ( d ) { d_delete ( dentry ) ; dput ( dentry ) ; cpu_relax ( ) ; return ERR_PTR ( - EAGAIN ) ; } goto got_it ; }
CWE-416 int SMB2_read ( const unsigned int xid , struct cifs_io_parms * io_parms , unsigned int * nbytes , char * * buf , int * buf_type ) { struct smb_rqst rqst ; int resp_buftype , rc = - EACCES ; struct smb2_read_plain_req * req = NULL ; struct smb2_read_rsp * rsp = NULL ; struct kvec iov [ 1 ] ; struct kvec rsp_iov ; unsigned int total_len ; int flags = CIFS_LOG_ERROR ; struct cifs_ses * ses = io_parms -> tcon -> ses ; * nbytes = 0 ; rc = smb2_new_read_req ( ( void * * ) & req , & total_len , io_parms , NULL , 0 , 0 ) ; if ( rc ) return rc ; if ( smb3_encryption_required ( io_parms -> tcon ) ) flags |= CIFS_TRANSFORM_REQ ; iov [ 0 ] . iov_base = ( char * ) req ; iov [ 0 ] . iov_len = total_len ; memset ( & rqst , 0 , sizeof ( struct smb_rqst ) ) ; rqst . rq_iov = iov ; rqst . rq_nvec = 1 ; rc = cifs_send_recv ( xid , ses , & rqst , & resp_buftype , flags , & rsp_iov ) ; <S2SV_StartBug> cifs_small_buf_release ( req ) ; <S2SV_EndBug> rsp = ( struct smb2_read_rsp * ) rsp_iov . iov_base ; if ( rc ) { if ( rc != - ENODATA ) { cifs_stats_fail_inc ( io_parms -> tcon , SMB2_READ_HE ) ; cifs_dbg ( VFS , "Send<S2SV_blank>error<S2SV_blank>in<S2SV_blank>read<S2SV_blank>=<S2SV_blank>%d\\n" , rc ) ; trace_smb3_read_err ( xid , req -> PersistentFileId , io_parms -> tcon -> tid , ses -> Suid , io_parms -> offset , io_parms -> length , rc ) ; } else trace_smb3_read_done ( xid , req -> PersistentFileId , io_parms -> tcon -> tid , ses -> Suid , io_parms -> offset , 0 ) ; free_rsp_buf ( resp_buftype , rsp_iov . iov_base ) ; return rc == - ENODATA ? 0 : rc ; } else trace_smb3_read_done ( xid , req -> PersistentFileId , io_parms -> tcon -> tid , ses -> Suid , io_parms -> offset , io_parms -> length ) ; <S2SV_StartBug> * nbytes = le32_to_cpu ( rsp -> DataLength ) ; <S2SV_EndBug> if ( ( * nbytes > CIFS_MAX_MSGSIZE ) || ( * nbytes > io_parms -> length ) ) { cifs_dbg ( FYI , "bad<S2SV_blank>length<S2SV_blank>%d<S2SV_blank>for<S2SV_blank>count<S2SV_blank>%d\\n" , * nbytes , io_parms -> length ) ; rc = - EIO ; * nbytes = 0 ; } if ( * buf ) { memcpy ( * buf , ( char * ) rsp + rsp -> DataOffset , * nbytes ) ; free_rsp_buf ( resp_buftype , rsp_iov . iov_base ) ; } else if ( resp_buftype != CIFS_NO_BUFFER ) { * buf = rsp_iov . iov_base ; if ( resp_buftype == CIFS_SMALL_BUFFER ) * buf_type = CIFS_SMALL_BUFFER ; else if ( resp_buftype == CIFS_LARGE_BUFFER ) * buf_type = CIFS_LARGE_BUFFER ; } return rc ; }
CWE-119 int mlx4_register_mac ( struct mlx4_dev * dev , u8 port , u64 mac , int * index ) { struct mlx4_mac_table * table = & mlx4_priv ( dev ) -> port [ port ] . mac_table ; int i , err = 0 ; int free = - 1 ; mlx4_dbg ( dev , "Registering<S2SV_blank>MAC:<S2SV_blank>0x%llx\\n" , ( unsigned long long ) mac ) ; mutex_lock ( & table -> mutex ) ; for ( i = 0 ; i < MLX4_MAX_MAC_NUM - 1 ; i ++ ) { if ( free < 0 && ! table -> refs [ i ] ) { free = i ; continue ; } if ( mac == ( MLX4_MAC_MASK & be64_to_cpu ( table -> entries [ i ] ) ) ) { * index = i ; ++ table -> refs [ i ] ; goto out ; } } <S2SV_StartBug> mlx4_dbg ( dev , "Free<S2SV_blank>MAC<S2SV_blank>index<S2SV_blank>is<S2SV_blank>%d\\n" , free ) ; <S2SV_EndBug> if ( table -> total == table -> max ) { err = - ENOSPC ; goto out ; } table -> refs [ free ] = 1 ; table -> entries [ free ] = cpu_to_be64 ( mac | MLX4_MAC_VALID ) ; err = mlx4_set_port_mac_table ( dev , port , table -> entries ) ; if ( unlikely ( err ) ) { mlx4_err ( dev , "Failed<S2SV_blank>adding<S2SV_blank>MAC:<S2SV_blank>0x%llx\\n" , ( unsigned long long ) mac ) ; table -> refs [ free ] = 0 ; table -> entries [ free ] = 0 ; goto out ; } * index = free ; ++ table -> total ; out : mutex_unlock ( & table -> mutex ) ; return err ; }
CWE-119 int mlx4_register_vlan ( struct mlx4_dev * dev , u8 port , u16 vlan , int * index ) { struct mlx4_vlan_table * table = & mlx4_priv ( dev ) -> port [ port ] . vlan_table ; int i , err = 0 ; int free = - 1 ; mutex_lock ( & table -> mutex ) ; for ( i = MLX4_VLAN_REGULAR ; i < MLX4_MAX_VLAN_NUM ; i ++ ) { if ( free < 0 && ( table -> refs [ i ] == 0 ) ) { free = i ; continue ; } if ( table -> refs [ i ] && ( vlan == ( MLX4_VLAN_MASK & be32_to_cpu ( table -> entries [ i ] ) ) ) ) { * index = i ; ++ table -> refs [ i ] ; goto out ; <S2SV_StartBug> } <S2SV_EndBug> } if ( table -> total == table -> max ) { err = - ENOSPC ; goto out ; } table -> refs [ free ] = 1 ; table -> entries [ free ] = cpu_to_be32 ( vlan | MLX4_VLAN_VALID ) ; err = mlx4_set_port_vlan_table ( dev , port , table -> entries ) ; if ( unlikely ( err ) ) { mlx4_warn ( dev , "Failed<S2SV_blank>adding<S2SV_blank>vlan:<S2SV_blank>%u\\n" , vlan ) ; table -> refs [ free ] = 0 ; table -> entries [ free ] = 0 ; goto out ; } * index = free ; ++ table -> total ; out : mutex_unlock ( & table -> mutex ) ; return err ; }
CWE-200 int compat_get_timex ( struct timex * txc , const struct compat_timex __user * utp ) { struct compat_timex tx32 ; <S2SV_StartBug> if ( copy_from_user ( & tx32 , utp , sizeof ( struct compat_timex ) ) ) <S2SV_EndBug> return - EFAULT ; txc -> modes = tx32 . modes ; txc -> offset = tx32 . offset ; txc -> freq = tx32 . freq ; txc -> maxerror = tx32 . maxerror ; txc -> esterror = tx32 . esterror ; txc -> status = tx32 . status ; txc -> constant = tx32 . constant ; txc -> precision = tx32 . precision ; txc -> tolerance = tx32 . tolerance ; txc -> time . tv_sec = tx32 . time . tv_sec ; txc -> time . tv_usec = tx32 . time . tv_usec ; txc -> tick = tx32 . tick ; txc -> ppsfreq = tx32 . ppsfreq ; txc -> jitter = tx32 . jitter ; txc -> shift = tx32 . shift ; txc -> stabil = tx32 . stabil ; txc -> jitcnt = tx32 . jitcnt ; txc -> calcnt = tx32 . calcnt ; txc -> errcnt = tx32 . errcnt ; txc -> stbcnt = tx32 . stbcnt ; return 0 ; }
CWE-476 int expand_downwards ( struct vm_area_struct * vma , unsigned long address ) { struct mm_struct * mm = vma -> vm_mm ; struct vm_area_struct * prev ; <S2SV_StartBug> int error ; <S2SV_EndBug> address &= PAGE_MASK ; <S2SV_StartBug> error = security_mmap_addr ( address ) ; <S2SV_EndBug> if ( error ) return error ; prev = vma -> vm_prev ; if ( prev && ! ( prev -> vm_flags & VM_GROWSDOWN ) && ( prev -> vm_flags & ( VM_WRITE | VM_READ | VM_EXEC ) ) ) { if ( address - prev -> vm_end < stack_guard_gap ) return - ENOMEM ; } if ( unlikely ( anon_vma_prepare ( vma ) ) ) return - ENOMEM ; anon_vma_lock_write ( vma -> anon_vma ) ; if ( address < vma -> vm_start ) { unsigned long size , grow ; size = vma -> vm_end - address ; grow = ( vma -> vm_start - address ) >> PAGE_SHIFT ; error = - ENOMEM ; if ( grow <= vma -> vm_pgoff ) { error = acct_stack_growth ( vma , size , grow ) ; if ( ! error ) { spin_lock ( & mm -> page_table_lock ) ; if ( vma -> vm_flags & VM_LOCKED ) mm -> locked_vm += grow ; vm_stat_account ( mm , vma -> vm_flags , grow ) ; anon_vma_interval_tree_pre_update_vma ( vma ) ; vma -> vm_start = address ; vma -> vm_pgoff -= grow ; anon_vma_interval_tree_post_update_vma ( vma ) ; vma_gap_update ( vma ) ; spin_unlock ( & mm -> page_table_lock ) ; perf_event_mmap ( vma ) ; } } } anon_vma_unlock_write ( vma -> anon_vma ) ; khugepaged_enter_vma_merge ( vma , vma -> vm_flags ) ; validate_mm ( mm ) ; return error ; }
CWE-476 static int tun_set_iff ( struct net * net , struct file * file , struct ifreq * ifr ) { struct tun_struct * tun ; struct tun_file * tfile = file -> private_data ; struct net_device * dev ; int err ; if ( tfile -> detached ) return - EINVAL ; dev = __dev_get_by_name ( net , ifr -> ifr_name ) ; if ( dev ) { if ( ifr -> ifr_flags & IFF_TUN_EXCL ) return - EBUSY ; if ( ( ifr -> ifr_flags & IFF_TUN ) && dev -> netdev_ops == & tun_netdev_ops ) tun = netdev_priv ( dev ) ; else if ( ( ifr -> ifr_flags & IFF_TAP ) && dev -> netdev_ops == & tap_netdev_ops ) tun = netdev_priv ( dev ) ; else return - EINVAL ; if ( ! ! ( ifr -> ifr_flags & IFF_MULTI_QUEUE ) != ! ! ( tun -> flags & IFF_MULTI_QUEUE ) ) return - EINVAL ; if ( tun_not_capable ( tun ) ) return - EPERM ; err = security_tun_dev_open ( tun -> security ) ; if ( err < 0 ) return err ; err = tun_attach ( tun , file , ifr -> ifr_flags & IFF_NOFILTER ) ; if ( err < 0 ) return err ; if ( tun -> flags & IFF_MULTI_QUEUE && ( tun -> numqueues + tun -> numdisabled > 1 ) ) { return 0 ; } } else { char * name ; unsigned long flags = 0 ; int queues = ifr -> ifr_flags & IFF_MULTI_QUEUE ? MAX_TAP_QUEUES : 1 ; if ( ! ns_capable ( net -> user_ns , CAP_NET_ADMIN ) ) return - EPERM ; err = security_tun_dev_create ( ) ; if ( err < 0 ) return err ; if ( ifr -> ifr_flags & IFF_TUN ) { flags |= IFF_TUN ; name = "tun%d" ; } else if ( ifr -> ifr_flags & IFF_TAP ) { flags |= IFF_TAP ; name = "tap%d" ; } else return - EINVAL ; if ( * ifr -> ifr_name ) name = ifr -> ifr_name ; dev = alloc_netdev_mqs ( sizeof ( struct tun_struct ) , name , NET_NAME_UNKNOWN , tun_setup , queues , queues ) ; if ( ! dev ) return - ENOMEM ; <S2SV_StartBug> dev_net_set ( dev , net ) ; <S2SV_EndBug> dev -> rtnl_link_ops = & tun_link_ops ; dev -> ifindex = tfile -> ifindex ; dev -> sysfs_groups [ 0 ] = & tun_attr_group ; tun = netdev_priv ( dev ) ; tun -> dev = dev ; tun -> flags = flags ; tun -> txflt . count = 0 ; tun -> vnet_hdr_sz = sizeof ( struct virtio_net_hdr ) ; tun -> align = NET_SKB_PAD ; tun -> filter_attached = false ; tun -> sndbuf = tfile -> socket . sk -> sk_sndbuf ; tun -> rx_batched = 0 ; tun -> pcpu_stats = netdev_alloc_pcpu_stats ( struct tun_pcpu_stats ) ; if ( ! tun -> pcpu_stats ) { err = - ENOMEM ; goto err_free_dev ; } spin_lock_init ( & tun -> lock ) ; err = security_tun_dev_alloc_security ( & tun -> security ) ; if ( err < 0 ) goto err_free_stat ; tun_net_init ( dev ) ; tun_flow_init ( tun ) ; dev -> hw_features = NETIF_F_SG | NETIF_F_FRAGLIST | TUN_USER_FEATURES | NETIF_F_HW_VLAN_CTAG_TX | NETIF_F_HW_VLAN_STAG_TX ; dev -> features = dev -> hw_features | NETIF_F_LLTX ; dev -> vlan_features = dev -> features & ~ ( NETIF_F_HW_VLAN_CTAG_TX | NETIF_F_HW_VLAN_STAG_TX ) ; INIT_LIST_HEAD ( & tun -> disabled ) ; err = tun_attach ( tun , file , false ) ; if ( err < 0 ) goto err_free_flow ; err = register_netdevice ( tun -> dev ) ; if ( err < 0 ) goto err_detach ; } netif_carrier_on ( tun -> dev ) ; tun_debug ( KERN_INFO , tun , "tun_set_iff\\n" ) ; tun -> flags = ( tun -> flags & ~ TUN_FEATURES ) | ( ifr -> ifr_flags & TUN_FEATURES ) ; if ( netif_running ( tun -> dev ) ) netif_tx_wake_all_queues ( tun -> dev ) ; strcpy ( ifr -> ifr_name , tun -> dev -> name ) ; return 0 ; err_detach : tun_detach_all ( dev ) ; goto err_free_dev ; err_free_flow : tun_flow_uninit ( tun ) ; security_tun_dev_free_security ( tun -> security ) ; err_free_stat : free_percpu ( tun -> pcpu_stats ) ; err_free_dev : free_netdev ( dev ) ; return err ; }
CWE-476 <S2SV_StartBug> static int dev_get_valid_name ( struct net * net , <S2SV_EndBug> struct net_device * dev , const char * name ) { BUG_ON ( ! net ) ; if ( ! dev_valid_name ( name ) ) return - EINVAL ; if ( strchr ( name , '%' ) ) return dev_alloc_name_ns ( net , dev , name ) ; else if ( __dev_get_by_name ( net , name ) ) return - EEXIST ; else if ( dev -> name != name ) strlcpy ( dev -> name , name , IFNAMSIZ ) ; return 0 ; }
CWE-119 static struct nvmet_fc_tgt_queue * nvmet_fc_find_target_queue ( struct nvmet_fc_tgtport * tgtport , u64 connection_id ) { struct nvmet_fc_tgt_assoc * assoc ; struct nvmet_fc_tgt_queue * queue ; u64 association_id = nvmet_fc_getassociationid ( connection_id ) ; u16 qid = nvmet_fc_getqueueid ( connection_id ) ; <S2SV_StartBug> unsigned long flags ; <S2SV_EndBug> spin_lock_irqsave ( & tgtport -> lock , flags ) ; list_for_each_entry ( assoc , & tgtport -> assoc_list , a_list ) { if ( association_id == assoc -> association_id ) { queue = assoc -> queues [ qid ] ; if ( queue && ( ! atomic_read ( & queue -> connected ) || ! nvmet_fc_tgt_q_get ( queue ) ) ) queue = NULL ; spin_unlock_irqrestore ( & tgtport -> lock , flags ) ; return queue ; } } spin_unlock_irqrestore ( & tgtport -> lock , flags ) ; return NULL ; }
CWE-772 static int hwsim_new_radio_nl ( struct sk_buff * msg , struct genl_info * info ) { struct hwsim_new_radio_params param = { 0 } ; const char * hwname = NULL ; int ret ; param . reg_strict = info -> attrs [ HWSIM_ATTR_REG_STRICT_REG ] ; param . p2p_device = info -> attrs [ HWSIM_ATTR_SUPPORT_P2P_DEVICE ] ; param . channels = channels ; param . destroy_on_close = info -> attrs [ HWSIM_ATTR_DESTROY_RADIO_ON_CLOSE ] ; if ( info -> attrs [ HWSIM_ATTR_CHANNELS ] ) param . channels = nla_get_u32 ( info -> attrs [ HWSIM_ATTR_CHANNELS ] ) ; if ( info -> attrs [ HWSIM_ATTR_NO_VIF ] ) param . no_vif = true ; if ( info -> attrs [ HWSIM_ATTR_RADIO_NAME ] ) { hwname = kasprintf ( GFP_KERNEL , "%.*s" , nla_len ( info -> attrs [ HWSIM_ATTR_RADIO_NAME ] ) , ( char * ) nla_data ( info -> attrs [ HWSIM_ATTR_RADIO_NAME ] ) ) ; if ( ! hwname ) return - ENOMEM ; param . hwname = hwname ; } if ( info -> attrs [ HWSIM_ATTR_USE_CHANCTX ] ) param . use_chanctx = true ; else param . use_chanctx = ( param . channels > 1 ) ; if ( info -> attrs [ HWSIM_ATTR_REG_HINT_ALPHA2 ] ) param . reg_alpha2 = nla_data ( info -> attrs [ HWSIM_ATTR_REG_HINT_ALPHA2 ] ) ; if ( info -> attrs [ HWSIM_ATTR_REG_CUSTOM_REG ] ) { u32 idx = nla_get_u32 ( info -> attrs [ HWSIM_ATTR_REG_CUSTOM_REG ] ) ; <S2SV_StartBug> if ( idx >= ARRAY_SIZE ( hwsim_world_regdom_custom ) ) <S2SV_EndBug> return - EINVAL ; <S2SV_StartBug> param . regd = hwsim_world_regdom_custom [ idx ] ; <S2SV_EndBug> } ret = mac80211_hwsim_new_radio ( info , & param ) ; kfree ( hwname ) ; return ret ; }
CWE-269 void inode_init_owner ( struct inode * inode , const struct inode * dir , umode_t mode ) { inode -> i_uid = current_fsuid ( ) ; if ( dir && dir -> i_mode & S_ISGID ) { inode -> i_gid = dir -> i_gid ; if ( S_ISDIR ( mode ) ) mode |= S_ISGID ; <S2SV_StartBug> } else <S2SV_EndBug> inode -> i_gid = current_fsgid ( ) ; inode -> i_mode = mode ; }
CWE-119 struct se_portal_group * tcm_loop_make_naa_tpg ( struct se_wwn * wwn , struct config_group * group , const char * name ) { struct tcm_loop_hba * tl_hba = container_of ( wwn , struct tcm_loop_hba , tl_hba_wwn ) ; struct tcm_loop_tpg * tl_tpg ; char * tpgt_str , * end_ptr ; int ret ; unsigned short int tpgt ; tpgt_str = strstr ( name , "tpgt_" ) ; if ( ! tpgt_str ) { printk ( KERN_ERR "Unable<S2SV_blank>to<S2SV_blank>locate<S2SV_blank>\\"tpgt_#\\"<S2SV_blank>directory" "<S2SV_blank>group\\n" ) ; return ERR_PTR ( - EINVAL ) ; } tpgt_str += 5 ; tpgt = ( unsigned short int ) simple_strtoul ( tpgt_str , & end_ptr , 0 ) ; <S2SV_StartBug> if ( tpgt > TL_TPGS_PER_HBA ) { <S2SV_EndBug> printk ( KERN_ERR "Passed<S2SV_blank>tpgt:<S2SV_blank>%hu<S2SV_blank>exceeds<S2SV_blank>TL_TPGS_PER_HBA:" "<S2SV_blank>%u\\n" , tpgt , TL_TPGS_PER_HBA ) ; return ERR_PTR ( - EINVAL ) ; } tl_tpg = & tl_hba -> tl_hba_tpgs [ tpgt ] ; tl_tpg -> tl_hba = tl_hba ; tl_tpg -> tl_tpgt = tpgt ; ret = core_tpg_register ( & tcm_loop_fabric_configfs -> tf_ops , wwn , & tl_tpg -> tl_se_tpg , tl_tpg , TRANSPORT_TPG_TYPE_NORMAL ) ; if ( ret < 0 ) return ERR_PTR ( - ENOMEM ) ; printk ( KERN_INFO "TCM_Loop_ConfigFS:<S2SV_blank>Allocated<S2SV_blank>Emulated<S2SV_blank>%s" "<S2SV_blank>Target<S2SV_blank>Port<S2SV_blank>%s,t,0x%04x\\n" , tcm_loop_dump_proto_id ( tl_hba ) , config_item_name ( & wwn -> wwn_group . cg_item ) , tpgt ) ; return & tl_tpg -> tl_se_tpg ; }
CWE-190 int perf_cpu_time_max_percent_handler ( struct ctl_table * table , int write , void __user * buffer , size_t * lenp , loff_t * ppos ) { <S2SV_StartBug> int ret = proc_dointvec ( table , write , buffer , lenp , ppos ) ; <S2SV_EndBug> if ( ret || ! write ) return ret ; if ( sysctl_perf_cpu_time_max_percent == 100 || sysctl_perf_cpu_time_max_percent == 0 ) { printk ( KERN_WARNING "perf:<S2SV_blank>Dynamic<S2SV_blank>interrupt<S2SV_blank>throttling<S2SV_blank>disabled,<S2SV_blank>can<S2SV_blank>hang<S2SV_blank>your<S2SV_blank>system!\\n" ) ; WRITE_ONCE ( perf_sample_allowed_ns , 0 ) ; } else { update_perf_cpu_limits ( ) ; } return 0 ; }
CWE-416 <S2SV_StartBug> void generic_pipe_buf_get ( struct pipe_inode_info * pipe , struct pipe_buffer * buf ) <S2SV_EndBug> { <S2SV_StartBug> get_page ( buf -> page ) ; <S2SV_EndBug> }
CWE-416 static int link_pipe ( struct pipe_inode_info * ipipe , struct pipe_inode_info * opipe , size_t len , unsigned int flags ) { struct pipe_buffer * ibuf , * obuf ; int ret = 0 , i = 0 , nbuf ; pipe_double_lock ( ipipe , opipe ) ; do { if ( ! opipe -> readers ) { send_sig ( SIGPIPE , current , 0 ) ; if ( ! ret ) ret = - EPIPE ; break ; } if ( i >= ipipe -> nrbufs || opipe -> nrbufs >= opipe -> buffers ) break ; ibuf = ipipe -> bufs + ( ( ipipe -> curbuf + i ) & ( ipipe -> buffers - 1 ) ) ; nbuf = ( opipe -> curbuf + opipe -> nrbufs ) & ( opipe -> buffers - 1 ) ; <S2SV_StartBug> pipe_buf_get ( ipipe , ibuf ) ; <S2SV_EndBug> obuf = opipe -> bufs + nbuf ; * obuf = * ibuf ; obuf -> flags &= ~ PIPE_BUF_FLAG_GIFT ; if ( obuf -> len > len ) obuf -> len = len ; opipe -> nrbufs ++ ; ret += obuf -> len ; len -= obuf -> len ; i ++ ; } while ( len ) ; if ( ! ret && ipipe -> waiting_writers && ( flags & SPLICE_F_NONBLOCK ) ) ret = - EAGAIN ; pipe_unlock ( ipipe ) ; pipe_unlock ( opipe ) ; if ( ret > 0 ) wakeup_pipe_readers ( opipe ) ; return ret ; }
CWE-416 static int splice_pipe_to_pipe ( struct pipe_inode_info * ipipe , struct pipe_inode_info * opipe , size_t len , unsigned int flags ) { struct pipe_buffer * ibuf , * obuf ; int ret = 0 , nbuf ; bool input_wakeup = false ; retry : ret = ipipe_prep ( ipipe , flags ) ; if ( ret ) return ret ; ret = opipe_prep ( opipe , flags ) ; if ( ret ) return ret ; pipe_double_lock ( ipipe , opipe ) ; do { if ( ! opipe -> readers ) { send_sig ( SIGPIPE , current , 0 ) ; if ( ! ret ) ret = - EPIPE ; break ; } if ( ! ipipe -> nrbufs && ! ipipe -> writers ) break ; if ( ! ipipe -> nrbufs || opipe -> nrbufs >= opipe -> buffers ) { if ( ret ) break ; if ( flags & SPLICE_F_NONBLOCK ) { ret = - EAGAIN ; break ; } pipe_unlock ( ipipe ) ; pipe_unlock ( opipe ) ; goto retry ; } ibuf = ipipe -> bufs + ipipe -> curbuf ; nbuf = ( opipe -> curbuf + opipe -> nrbufs ) & ( opipe -> buffers - 1 ) ; obuf = opipe -> bufs + nbuf ; if ( len >= ibuf -> len ) { * obuf = * ibuf ; ibuf -> ops = NULL ; opipe -> nrbufs ++ ; ipipe -> curbuf = ( ipipe -> curbuf + 1 ) & ( ipipe -> buffers - 1 ) ; ipipe -> nrbufs -- ; input_wakeup = true ; } else { <S2SV_StartBug> pipe_buf_get ( ipipe , ibuf ) ; <S2SV_EndBug> * obuf = * ibuf ; obuf -> flags &= ~ PIPE_BUF_FLAG_GIFT ; obuf -> len = len ; opipe -> nrbufs ++ ; ibuf -> offset += obuf -> len ; ibuf -> len -= obuf -> len ; } ret += obuf -> len ; len -= obuf -> len ; } while ( len ) ; pipe_unlock ( ipipe ) ; pipe_unlock ( opipe ) ; if ( ret > 0 ) wakeup_pipe_readers ( opipe ) ; if ( input_wakeup ) wakeup_pipe_writers ( ipipe ) ; return ret ; }
CWE-416 <S2SV_StartBug> static void buffer_pipe_buf_get ( struct pipe_inode_info * pipe , <S2SV_EndBug> struct pipe_buffer * buf ) { struct buffer_ref * ref = ( struct buffer_ref * ) buf -> private ; <S2SV_StartBug> ref -> ref ++ ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>
CWE-119 static int cqspi_setup_flash ( struct cqspi_st * cqspi , struct device_node * np ) { struct platform_device * pdev = cqspi -> pdev ; struct device * dev = & pdev -> dev ; struct cqspi_flash_pdata * f_pdata ; struct spi_nor * nor ; struct mtd_info * mtd ; unsigned int cs ; int i , ret ; for_each_available_child_of_node ( dev -> of_node , np ) { if ( of_property_read_u32 ( np , "reg" , & cs ) ) { dev_err ( dev , "Couldn\'t<S2SV_blank>determine<S2SV_blank>chip<S2SV_blank>select.\\n" ) ; goto err ; } <S2SV_StartBug> if ( cs > CQSPI_MAX_CHIPSELECT ) { <S2SV_EndBug> dev_err ( dev , "Chip<S2SV_blank>select<S2SV_blank>%d<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range.\\n" , cs ) ; goto err ; } f_pdata = & cqspi -> f_pdata [ cs ] ; f_pdata -> cqspi = cqspi ; f_pdata -> cs = cs ; ret = cqspi_of_get_flash_pdata ( pdev , f_pdata , np ) ; if ( ret ) goto err ; nor = & f_pdata -> nor ; mtd = & nor -> mtd ; mtd -> priv = nor ; nor -> dev = dev ; spi_nor_set_flash_node ( nor , np ) ; nor -> priv = f_pdata ; nor -> read_reg = cqspi_read_reg ; nor -> write_reg = cqspi_write_reg ; nor -> read = cqspi_read ; nor -> write = cqspi_write ; nor -> erase = cqspi_erase ; nor -> prepare = cqspi_prep ; nor -> unprepare = cqspi_unprep ; mtd -> name = devm_kasprintf ( dev , GFP_KERNEL , "%s.%d" , dev_name ( dev ) , cs ) ; if ( ! mtd -> name ) { ret = - ENOMEM ; goto err ; } ret = spi_nor_scan ( nor , NULL , SPI_NOR_QUAD ) ; if ( ret ) goto err ; ret = mtd_device_register ( mtd , NULL , 0 ) ; if ( ret ) goto err ; f_pdata -> registered = true ; } return 0 ; err : for ( i = 0 ; i < CQSPI_MAX_CHIPSELECT ; i ++ ) if ( cqspi -> f_pdata [ i ] . registered ) mtd_device_unregister ( & cqspi -> f_pdata [ i ] . nor . mtd ) ; return ret ; }
CWE-119 int hugetlb_mcopy_atomic_pte ( struct mm_struct * dst_mm , pte_t * dst_pte , struct vm_area_struct * dst_vma , unsigned long dst_addr , unsigned long src_addr , struct page * * pagep ) { <S2SV_StartBug> int vm_shared = dst_vma -> vm_flags & VM_SHARED ; <S2SV_EndBug> struct hstate * h = hstate_vma ( dst_vma ) ; pte_t _dst_pte ; spinlock_t * ptl ; int ret ; struct page * page ; if ( ! * pagep ) { ret = - ENOMEM ; page = alloc_huge_page ( dst_vma , dst_addr , 0 ) ; if ( IS_ERR ( page ) ) goto out ; ret = copy_huge_page_from_user ( page , ( const void __user * ) src_addr , pages_per_huge_page ( h ) , false ) ; if ( unlikely ( ret ) ) { ret = - EFAULT ; * pagep = page ; goto out ; } } else { page = * pagep ; * pagep = NULL ; } __SetPageUptodate ( page ) ; set_page_huge_active ( page ) ; <S2SV_StartBug> if ( vm_shared ) { <S2SV_EndBug> <S2SV_StartBug> struct address_space * mapping = dst_vma -> vm_file -> f_mapping ; <S2SV_EndBug> pgoff_t idx = vma_hugecache_offset ( h , dst_vma , dst_addr ) ; ret = huge_add_to_page_cache ( page , mapping , idx ) ; if ( ret ) goto out_release_nounlock ; } ptl = huge_pte_lockptr ( h , dst_mm , dst_pte ) ; <S2SV_StartBug> spin_lock ( ptl ) ; <S2SV_EndBug> ret = - EEXIST ; if ( ! huge_pte_none ( huge_ptep_get ( dst_pte ) ) ) goto out_release_unlock ; if ( vm_shared ) { page_dup_rmap ( page , true ) ; } else { ClearPagePrivate ( page ) ; hugepage_add_new_anon_rmap ( page , dst_vma , dst_addr ) ; } _dst_pte = make_huge_pte ( dst_vma , page , dst_vma -> vm_flags & VM_WRITE ) ; if ( dst_vma -> vm_flags & VM_WRITE ) _dst_pte = huge_pte_mkdirty ( _dst_pte ) ; _dst_pte = pte_mkyoung ( _dst_pte ) ; set_huge_pte_at ( dst_mm , dst_addr , dst_pte , _dst_pte ) ; ( void ) huge_ptep_set_access_flags ( dst_vma , dst_addr , dst_pte , _dst_pte , dst_vma -> vm_flags & VM_WRITE ) ; hugetlb_count_add ( pages_per_huge_page ( h ) , dst_mm ) ; update_mmu_cache ( dst_vma , dst_addr , dst_pte ) ; spin_unlock ( ptl ) ; if ( vm_shared ) unlock_page ( page ) ; ret = 0 ; out : return ret ; out_release_unlock : spin_unlock ( ptl ) ; if ( vm_shared ) unlock_page ( page ) ; out_release_nounlock : put_page ( page ) ; goto out ; }
CWE-119 static int cx24116_send_diseqc_msg ( struct dvb_frontend * fe , struct dvb_diseqc_master_cmd * d ) { struct cx24116_state * state = fe -> demodulator_priv ; int i , ret ; <S2SV_StartBug> if ( debug ) { <S2SV_EndBug> printk ( KERN_INFO "cx24116:<S2SV_blank>%s(" , __func__ ) ; for ( i = 0 ; i < d -> msg_len ; ) { printk ( KERN_INFO "0x%02x" , d -> msg [ i ] ) ; if ( ++ i < d -> msg_len ) printk ( KERN_INFO ",<S2SV_blank>" ) ; } printk ( ")<S2SV_blank>toneburst=%d\\n" , toneburst ) ; } <S2SV_StartBug> if ( d -> msg_len > ( CX24116_ARGLEN - CX24116_DISEQC_MSGOFS ) ) <S2SV_EndBug> return - EINVAL ; for ( i = 0 ; i < d -> msg_len ; i ++ ) state -> dsec_cmd . args [ CX24116_DISEQC_MSGOFS + i ] = d -> msg [ i ] ; state -> dsec_cmd . args [ CX24116_DISEQC_MSGLEN ] = d -> msg_len ; state -> dsec_cmd . len = CX24116_DISEQC_MSGOFS + state -> dsec_cmd . args [ CX24116_DISEQC_MSGLEN ] ; if ( toneburst == CX24116_DISEQC_MESGCACHE ) return 0 ; else if ( toneburst == CX24116_DISEQC_TONEOFF ) state -> dsec_cmd . args [ CX24116_DISEQC_BURST ] = 0 ; else if ( toneburst == CX24116_DISEQC_TONECACHE ) { if ( d -> msg_len >= 4 && d -> msg [ 2 ] == 0x38 ) state -> dsec_cmd . args [ CX24116_DISEQC_BURST ] = ( ( d -> msg [ 3 ] & 4 ) >> 2 ) ; if ( debug ) dprintk ( "%s<S2SV_blank>burst=%d\\n" , __func__ , state -> dsec_cmd . args [ CX24116_DISEQC_BURST ] ) ; } ret = cx24116_wait_for_lnb ( fe ) ; if ( ret != 0 ) return ret ; msleep ( 100 ) ; ret = cx24116_cmd_execute ( fe , & state -> dsec_cmd ) ; if ( ret != 0 ) return ret ; msleep ( ( state -> dsec_cmd . args [ CX24116_DISEQC_MSGLEN ] << 4 ) + ( ( toneburst == CX24116_DISEQC_TONEOFF ) ? 30 : 60 ) ) ; return 0 ; }
CWE-399 int xfs_setattr_nonsize ( struct xfs_inode * ip , struct iattr * iattr , int flags ) { xfs_mount_t * mp = ip -> i_mount ; struct inode * inode = VFS_I ( ip ) ; int mask = iattr -> ia_valid ; xfs_trans_t * tp ; int error ; kuid_t uid = GLOBAL_ROOT_UID , iuid = GLOBAL_ROOT_UID ; kgid_t gid = GLOBAL_ROOT_GID , igid = GLOBAL_ROOT_GID ; struct xfs_dquot * udqp = NULL , * gdqp = NULL ; struct xfs_dquot * olddquot1 = NULL , * olddquot2 = NULL ; ASSERT ( ( mask & ATTR_SIZE ) == 0 ) ; if ( XFS_IS_QUOTA_ON ( mp ) && ( mask & ( ATTR_UID | ATTR_GID ) ) ) { uint qflags = 0 ; if ( ( mask & ATTR_UID ) && XFS_IS_UQUOTA_ON ( mp ) ) { uid = iattr -> ia_uid ; qflags |= XFS_QMOPT_UQUOTA ; } else { uid = inode -> i_uid ; } if ( ( mask & ATTR_GID ) && XFS_IS_GQUOTA_ON ( mp ) ) { gid = iattr -> ia_gid ; qflags |= XFS_QMOPT_GQUOTA ; } else { gid = inode -> i_gid ; } ASSERT ( udqp == NULL ) ; ASSERT ( gdqp == NULL ) ; error = xfs_qm_vop_dqalloc ( ip , xfs_kuid_to_uid ( uid ) , xfs_kgid_to_gid ( gid ) , xfs_get_projid ( ip ) , qflags , & udqp , & gdqp , NULL ) ; if ( error ) return error ; } error = xfs_trans_alloc ( mp , & M_RES ( mp ) -> tr_ichange , 0 , 0 , 0 , & tp ) ; if ( error ) goto out_dqrele ; xfs_ilock ( ip , XFS_ILOCK_EXCL ) ; xfs_trans_ijoin ( tp , ip , 0 ) ; if ( mask & ( ATTR_UID | ATTR_GID ) ) { iuid = inode -> i_uid ; igid = inode -> i_gid ; gid = ( mask & ATTR_GID ) ? iattr -> ia_gid : igid ; uid = ( mask & ATTR_UID ) ? iattr -> ia_uid : iuid ; if ( XFS_IS_QUOTA_RUNNING ( mp ) && ( ( XFS_IS_UQUOTA_ON ( mp ) && ! uid_eq ( iuid , uid ) ) || ( XFS_IS_GQUOTA_ON ( mp ) && ! gid_eq ( igid , gid ) ) ) ) { ASSERT ( tp ) ; error = xfs_qm_vop_chown_reserve ( tp , ip , udqp , gdqp , NULL , capable ( CAP_FOWNER ) ? XFS_QMOPT_FORCE_RES : 0 ) ; if ( error ) goto out_cancel ; } } if ( mask & ( ATTR_UID | ATTR_GID ) ) { if ( ( inode -> i_mode & ( S_ISUID | S_ISGID ) ) && ! capable ( CAP_FSETID ) ) inode -> i_mode &= ~ ( S_ISUID | S_ISGID ) ; if ( ! uid_eq ( iuid , uid ) ) { if ( XFS_IS_QUOTA_RUNNING ( mp ) && XFS_IS_UQUOTA_ON ( mp ) ) { ASSERT ( mask & ATTR_UID ) ; ASSERT ( udqp ) ; olddquot1 = xfs_qm_vop_chown ( tp , ip , & ip -> i_udquot , udqp ) ; } ip -> i_d . di_uid = xfs_kuid_to_uid ( uid ) ; inode -> i_uid = uid ; } if ( ! gid_eq ( igid , gid ) ) { if ( XFS_IS_QUOTA_RUNNING ( mp ) && XFS_IS_GQUOTA_ON ( mp ) ) { ASSERT ( xfs_sb_version_has_pquotino ( & mp -> m_sb ) || ! XFS_IS_PQUOTA_ON ( mp ) ) ; ASSERT ( mask & ATTR_GID ) ; ASSERT ( gdqp ) ; olddquot2 = xfs_qm_vop_chown ( tp , ip , & ip -> i_gdquot , gdqp ) ; } ip -> i_d . di_gid = xfs_kgid_to_gid ( gid ) ; inode -> i_gid = gid ; } } if ( mask & ATTR_MODE ) xfs_setattr_mode ( ip , iattr ) ; if ( mask & ( ATTR_ATIME | ATTR_CTIME | ATTR_MTIME ) ) xfs_setattr_time ( ip , iattr ) ; xfs_trans_log_inode ( tp , ip , XFS_ILOG_CORE ) ; XFS_STATS_INC ( mp , xs_ig_attrchg ) ; if ( mp -> m_flags & XFS_MOUNT_WSYNC ) xfs_trans_set_sync ( tp ) ; error = xfs_trans_commit ( tp ) ; xfs_iunlock ( ip , XFS_ILOCK_EXCL ) ; xfs_qm_dqrele ( olddquot1 ) ; xfs_qm_dqrele ( olddquot2 ) ; xfs_qm_dqrele ( udqp ) ; xfs_qm_dqrele ( gdqp ) ; if ( error ) return error ; if ( ( mask & ATTR_MODE ) && ! ( flags & XFS_ATTR_NOACL ) ) { error = posix_acl_chmod ( inode , inode -> i_mode ) ; if ( error ) return error ; } return 0 ; out_cancel : xfs_trans_cancel ( tp ) ; <S2SV_StartBug> out_dqrele : <S2SV_EndBug> xfs_qm_dqrele ( udqp ) ; xfs_qm_dqrele ( gdqp ) ; return error ; }
CWE-416 struct net * get_net_ns_by_id ( struct net * net , int id ) { struct net * peer ; if ( id < 0 ) return NULL ; rcu_read_lock ( ) ; spin_lock_bh ( & net -> nsid_lock ) ; peer = idr_find ( & net -> netns_ids , id ) ; if ( peer ) <S2SV_StartBug> get_net ( peer ) ; <S2SV_EndBug> spin_unlock_bh ( & net -> nsid_lock ) ; rcu_read_unlock ( ) ; return peer ; }
CWE-476 xfs_failaddr_t xfs_dinode_verify ( struct xfs_mount * mp , xfs_ino_t ino , struct xfs_dinode * dip ) { xfs_failaddr_t fa ; uint16_t mode ; uint16_t flags ; uint64_t flags2 ; uint64_t di_size ; if ( dip -> di_magic != cpu_to_be16 ( XFS_DINODE_MAGIC ) ) return __this_address ; if ( dip -> di_version >= 3 ) { if ( ! xfs_sb_version_hascrc ( & mp -> m_sb ) ) return __this_address ; if ( ! xfs_verify_cksum ( ( char * ) dip , mp -> m_sb . sb_inodesize , XFS_DINODE_CRC_OFF ) ) return __this_address ; if ( be64_to_cpu ( dip -> di_ino ) != ino ) return __this_address ; if ( ! uuid_equal ( & dip -> di_uuid , & mp -> m_sb . sb_meta_uuid ) ) return __this_address ; } di_size = be64_to_cpu ( dip -> di_size ) ; if ( di_size & ( 1ULL << 63 ) ) return __this_address ; mode = be16_to_cpu ( dip -> di_mode ) ; if ( mode && xfs_mode_to_ftype ( mode ) == XFS_DIR3_FT_UNKNOWN ) return __this_address ; if ( ( S_ISLNK ( mode ) || S_ISDIR ( mode ) ) && di_size == 0 ) return __this_address ; if ( mode && be32_to_cpu ( dip -> di_nextents ) + be16_to_cpu ( dip -> di_anextents ) > be64_to_cpu ( dip -> di_nblocks ) ) return __this_address ; if ( mode && XFS_DFORK_BOFF ( dip ) > mp -> m_sb . sb_inodesize ) return __this_address ; flags = be16_to_cpu ( dip -> di_flags ) ; if ( mode && ( flags & XFS_DIFLAG_REALTIME ) && ! mp -> m_rtdev_targp ) return __this_address ; switch ( mode & S_IFMT ) { case S_IFIFO : case S_IFCHR : case S_IFBLK : case S_IFSOCK : if ( dip -> di_format != XFS_DINODE_FMT_DEV ) return __this_address ; break ; case S_IFREG : case S_IFLNK : case S_IFDIR : <S2SV_StartBug> switch ( dip -> di_format ) { <S2SV_EndBug> case XFS_DINODE_FMT_LOCAL : if ( S_ISREG ( mode ) ) return __this_address ; if ( di_size > XFS_DFORK_DSIZE ( dip , mp ) ) return __this_address ; if ( dip -> di_nextents ) return __this_address ; case XFS_DINODE_FMT_EXTENTS : case XFS_DINODE_FMT_BTREE : break ; default : return __this_address ; } break ; case 0 : break ; default : return __this_address ; } if ( XFS_DFORK_Q ( dip ) ) { switch ( dip -> di_aformat ) { case XFS_DINODE_FMT_LOCAL : if ( dip -> di_anextents ) return __this_address ; case XFS_DINODE_FMT_EXTENTS : case XFS_DINODE_FMT_BTREE : break ; default : return __this_address ; } } else { switch ( dip -> di_aformat ) { case 0 : case XFS_DINODE_FMT_EXTENTS : break ; default : return __this_address ; } if ( dip -> di_anextents ) return __this_address ; } fa = xfs_inode_validate_extsize ( mp , be32_to_cpu ( dip -> di_extsize ) , mode , flags ) ; if ( fa ) return fa ; if ( dip -> di_version < 3 ) return NULL ; flags2 = be64_to_cpu ( dip -> di_flags2 ) ; if ( ( flags2 & ( XFS_DIFLAG2_REFLINK | XFS_DIFLAG2_COWEXTSIZE ) ) && ! xfs_sb_version_hasreflink ( & mp -> m_sb ) ) return __this_address ; if ( ( flags2 & XFS_DIFLAG2_REFLINK ) && ( mode & S_IFMT ) != S_IFREG ) return __this_address ; if ( ( flags2 & XFS_DIFLAG2_REFLINK ) && ( flags & XFS_DIFLAG_REALTIME ) ) return __this_address ; if ( ( flags2 & XFS_DIFLAG2_REFLINK ) && ( flags2 & XFS_DIFLAG2_DAX ) ) return __this_address ; fa = xfs_inode_validate_cowextsize ( mp , be32_to_cpu ( dip -> di_cowextsize ) , mode , flags , flags2 ) ; if ( fa ) return fa ; return NULL ; }
CWE-200 int sbusfb_ioctl_helper ( unsigned long cmd , unsigned long arg , struct fb_info * info , int type , int fb_depth , unsigned long fb_size ) { switch ( cmd ) { case FBIOGTYPE : { struct fbtype __user * f = ( struct fbtype __user * ) arg ; if ( put_user ( type , & f -> fb_type ) || __put_user ( info -> var . yres , & f -> fb_height ) || __put_user ( info -> var . xres , & f -> fb_width ) || __put_user ( fb_depth , & f -> fb_depth ) || __put_user ( 0 , & f -> fb_cmsize ) || __put_user ( fb_size , & f -> fb_cmsize ) ) return - EFAULT ; return 0 ; } case FBIOPUTCMAP_SPARC : { struct fbcmap __user * c = ( struct fbcmap __user * ) arg ; struct fb_cmap cmap ; u16 red , green , blue ; u8 red8 , green8 , blue8 ; unsigned char __user * ured ; unsigned char __user * ugreen ; unsigned char __user * ublue ; <S2SV_StartBug> int index , count , i ; <S2SV_EndBug> if ( get_user ( index , & c -> index ) || __get_user ( count , & c -> count ) || __get_user ( ured , & c -> red ) || __get_user ( ugreen , & c -> green ) || __get_user ( ublue , & c -> blue ) ) return - EFAULT ; cmap . len = 1 ; cmap . red = & red ; cmap . green = & green ; cmap . blue = & blue ; cmap . transp = NULL ; for ( i = 0 ; i < count ; i ++ ) { int err ; if ( get_user ( red8 , & ured [ i ] ) || get_user ( green8 , & ugreen [ i ] ) || get_user ( blue8 , & ublue [ i ] ) ) return - EFAULT ; red = red8 << 8 ; green = green8 << 8 ; blue = blue8 << 8 ; cmap . start = index + i ; err = fb_set_cmap ( & cmap , info ) ; if ( err ) return err ; } return 0 ; } case FBIOGETCMAP_SPARC : { struct fbcmap __user * c = ( struct fbcmap __user * ) arg ; unsigned char __user * ured ; unsigned char __user * ugreen ; unsigned char __user * ublue ; struct fb_cmap * cmap = & info -> cmap ; <S2SV_StartBug> int index , count , i ; <S2SV_EndBug> u8 red , green , blue ; if ( get_user ( index , & c -> index ) || __get_user ( count , & c -> count ) || __get_user ( ured , & c -> red ) || __get_user ( ugreen , & c -> green ) || __get_user ( ublue , & c -> blue ) ) return - EFAULT ; if ( index + count > cmap -> len ) return - EINVAL ; for ( i = 0 ; i < count ; i ++ ) { red = cmap -> red [ index + i ] >> 8 ; green = cmap -> green [ index + i ] >> 8 ; blue = cmap -> blue [ index + i ] >> 8 ; if ( put_user ( red , & ured [ i ] ) || put_user ( green , & ugreen [ i ] ) || put_user ( blue , & ublue [ i ] ) ) return - EFAULT ; } return 0 ; } default : return - EINVAL ; } }
CWE-415 static int amd_gpio_probe ( struct platform_device * pdev ) { int ret = 0 ; int irq_base ; struct resource * res ; struct amd_gpio * gpio_dev ; gpio_dev = devm_kzalloc ( & pdev -> dev , sizeof ( struct amd_gpio ) , GFP_KERNEL ) ; if ( ! gpio_dev ) return - ENOMEM ; spin_lock_init ( & gpio_dev -> lock ) ; res = platform_get_resource ( pdev , IORESOURCE_MEM , 0 ) ; if ( ! res ) { dev_err ( & pdev -> dev , "Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>gpio<S2SV_blank>io<S2SV_blank>resource.\\n" ) ; return - EINVAL ; } gpio_dev -> base = devm_ioremap_nocache ( & pdev -> dev , res -> start , resource_size ( res ) ) ; if ( ! gpio_dev -> base ) return - ENOMEM ; irq_base = platform_get_irq ( pdev , 0 ) ; if ( irq_base < 0 ) { dev_err ( & pdev -> dev , "Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>gpio<S2SV_blank>IRQ.\\n" ) ; return - EINVAL ; } gpio_dev -> pdev = pdev ; gpio_dev -> gc . direction_input = amd_gpio_direction_input ; gpio_dev -> gc . direction_output = amd_gpio_direction_output ; gpio_dev -> gc . get = amd_gpio_get_value ; gpio_dev -> gc . set = amd_gpio_set_value ; gpio_dev -> gc . set_debounce = amd_gpio_set_debounce ; gpio_dev -> gc . dbg_show = amd_gpio_dbg_show ; gpio_dev -> gc . base = 0 ; gpio_dev -> gc . label = pdev -> name ; gpio_dev -> gc . owner = THIS_MODULE ; gpio_dev -> gc . parent = & pdev -> dev ; gpio_dev -> gc . ngpio = TOTAL_NUMBER_OF_PINS ; # if defined ( CONFIG_OF_GPIO ) gpio_dev -> gc . of_node = pdev -> dev . of_node ; # endif gpio_dev -> groups = kerncz_groups ; gpio_dev -> ngroups = ARRAY_SIZE ( kerncz_groups ) ; amd_pinctrl_desc . name = dev_name ( & pdev -> dev ) ; <S2SV_StartBug> gpio_dev -> pctrl = pinctrl_register ( & amd_pinctrl_desc , <S2SV_EndBug> <S2SV_StartBug> & pdev -> dev , gpio_dev ) ; <S2SV_EndBug> if ( IS_ERR ( gpio_dev -> pctrl ) ) { dev_err ( & pdev -> dev , "Couldn\'t<S2SV_blank>register<S2SV_blank>pinctrl<S2SV_blank>driver\\n" ) ; return PTR_ERR ( gpio_dev -> pctrl ) ; } ret = gpiochip_add_data ( & gpio_dev -> gc , gpio_dev ) ; if ( ret ) <S2SV_StartBug> goto out1 ; <S2SV_EndBug> ret = gpiochip_add_pin_range ( & gpio_dev -> gc , dev_name ( & pdev -> dev ) , 0 , 0 , TOTAL_NUMBER_OF_PINS ) ; if ( ret ) { dev_err ( & pdev -> dev , "Failed<S2SV_blank>to<S2SV_blank>add<S2SV_blank>pin<S2SV_blank>range\\n" ) ; goto out2 ; } ret = gpiochip_irqchip_add ( & gpio_dev -> gc , & amd_gpio_irqchip , 0 , handle_simple_irq , IRQ_TYPE_NONE ) ; if ( ret ) { dev_err ( & pdev -> dev , "could<S2SV_blank>not<S2SV_blank>add<S2SV_blank>irqchip\\n" ) ; ret = - ENODEV ; goto out2 ; } gpiochip_set_chained_irqchip ( & gpio_dev -> gc , & amd_gpio_irqchip , irq_base , amd_gpio_irq_handler ) ; platform_set_drvdata ( pdev , gpio_dev ) ; dev_dbg ( & pdev -> dev , "amd<S2SV_blank>gpio<S2SV_blank>driver<S2SV_blank>loaded\\n" ) ; return ret ; out2 : gpiochip_remove ( & gpio_dev -> gc ) ; <S2SV_StartBug> out1 : <S2SV_EndBug> pinctrl_unregister ( gpio_dev -> pctrl ) ; return ret ; }
CWE-415 static int amd_gpio_remove ( struct platform_device * pdev ) { struct amd_gpio * gpio_dev ; gpio_dev = platform_get_drvdata ( pdev ) ; gpiochip_remove ( & gpio_dev -> gc ) ; <S2SV_StartBug> pinctrl_unregister ( gpio_dev -> pctrl ) ; <S2SV_EndBug> return 0 ; }
CWE-416 static int tcpmss_mangle_packet ( struct sk_buff * skb , const struct xt_action_param * par , unsigned int family , unsigned int tcphoff , unsigned int minlen ) { const struct xt_tcpmss_info * info = par -> targinfo ; struct tcphdr * tcph ; int len , tcp_hdrlen ; unsigned int i ; __be16 oldval ; u16 newmss ; u8 * opt ; if ( par -> fragoff != 0 ) return 0 ; if ( ! skb_make_writable ( skb , skb -> len ) ) return - 1 ; len = skb -> len - tcphoff ; if ( len < ( int ) sizeof ( struct tcphdr ) ) return - 1 ; tcph = ( struct tcphdr * ) ( skb_network_header ( skb ) + tcphoff ) ; tcp_hdrlen = tcph -> doff * 4 ; <S2SV_StartBug> if ( len < tcp_hdrlen ) <S2SV_EndBug> return - 1 ; if ( info -> mss == XT_TCPMSS_CLAMP_PMTU ) { struct net * net = xt_net ( par ) ; unsigned int in_mtu = tcpmss_reverse_mtu ( net , skb , family ) ; unsigned int min_mtu = min ( dst_mtu ( skb_dst ( skb ) ) , in_mtu ) ; if ( min_mtu <= minlen ) { net_err_ratelimited ( "unknown<S2SV_blank>or<S2SV_blank>invalid<S2SV_blank>path-MTU<S2SV_blank>(%u)\\n" , min_mtu ) ; return - 1 ; } newmss = min_mtu - minlen ; } else newmss = info -> mss ; opt = ( u_int8_t * ) tcph ; for ( i = sizeof ( struct tcphdr ) ; i <= tcp_hdrlen - TCPOLEN_MSS ; i += optlen ( opt , i ) ) { if ( opt [ i ] == TCPOPT_MSS && opt [ i + 1 ] == TCPOLEN_MSS ) { u_int16_t oldmss ; oldmss = ( opt [ i + 2 ] << 8 ) | opt [ i + 3 ] ; if ( oldmss <= newmss ) return 0 ; opt [ i + 2 ] = ( newmss & 0xff00 ) >> 8 ; opt [ i + 3 ] = newmss & 0x00ff ; inet_proto_csum_replace2 ( & tcph -> check , skb , htons ( oldmss ) , htons ( newmss ) , false ) ; return 0 ; } } if ( len > tcp_hdrlen ) return 0 ; <S2SV_StartBug> if ( skb_tailroom ( skb ) < TCPOLEN_MSS ) { <S2SV_EndBug> if ( pskb_expand_head ( skb , 0 , TCPOLEN_MSS - skb_tailroom ( skb ) , GFP_ATOMIC ) ) return - 1 ; tcph = ( struct tcphdr * ) ( skb_network_header ( skb ) + tcphoff ) ; } skb_put ( skb , TCPOLEN_MSS ) ; if ( xt_family ( par ) == NFPROTO_IPV4 ) newmss = min ( newmss , ( u16 ) 536 ) ; else newmss = min ( newmss , ( u16 ) 1220 ) ; opt = ( u_int8_t * ) tcph + sizeof ( struct tcphdr ) ; memmove ( opt + TCPOLEN_MSS , opt , len - sizeof ( struct tcphdr ) ) ; inet_proto_csum_replace2 ( & tcph -> check , skb , htons ( len ) , htons ( len + TCPOLEN_MSS ) , true ) ; opt [ 0 ] = TCPOPT_MSS ; opt [ 1 ] = TCPOLEN_MSS ; opt [ 2 ] = ( newmss & 0xff00 ) >> 8 ; opt [ 3 ] = newmss & 0x00ff ; inet_proto_csum_replace4 ( & tcph -> check , skb , 0 , * ( ( __be32 * ) opt ) , false ) ; oldval = ( ( __be16 * ) tcph ) [ 6 ] ; tcph -> doff += TCPOLEN_MSS / 4 ; inet_proto_csum_replace2 ( & tcph -> check , skb , oldval , ( ( __be16 * ) tcph ) [ 6 ] , false ) ; return TCPOLEN_MSS ; }
CWE-416 static netdev_tx_t hns_nic_net_xmit ( struct sk_buff * skb , struct net_device * ndev ) { struct hns_nic_priv * priv = netdev_priv ( ndev ) ; <S2SV_StartBug> int ret ; <S2SV_EndBug> assert ( skb -> queue_mapping < ndev -> ae_handle -> q_num ) ; <S2SV_StartBug> ret = hns_nic_net_xmit_hw ( ndev , skb , <S2SV_EndBug> & tx_ring_data ( priv , skb -> queue_mapping ) ) ; <S2SV_StartBug> if ( ret == NETDEV_TX_OK ) { <S2SV_EndBug> netif_trans_update ( ndev ) ; ndev -> stats . tx_bytes += skb -> len ; ndev -> stats . tx_packets ++ ; } return ( netdev_tx_t ) ret ; }
CWE-416 <S2SV_StartBug> int hns_nic_net_xmit_hw ( struct net_device * ndev , <S2SV_EndBug> struct sk_buff * skb , struct hns_nic_ring_data * ring_data ) { struct hns_nic_priv * priv = netdev_priv ( ndev ) ; struct hnae_ring * ring = ring_data -> ring ; struct device * dev = ring_to_dev ( ring ) ; struct netdev_queue * dev_queue ; struct skb_frag_struct * frag ; int buf_num ; int seg_num ; dma_addr_t dma ; int size , next_to_use ; int i ; switch ( priv -> ops . maybe_stop_tx ( & skb , & buf_num , ring ) ) { case - EBUSY : ring -> stats . tx_busy ++ ; goto out_net_tx_busy ; case - ENOMEM : ring -> stats . sw_err_cnt ++ ; netdev_err ( ndev , "no<S2SV_blank>memory<S2SV_blank>to<S2SV_blank>xmit!\\n" ) ; goto out_err_tx_ok ; default : break ; } seg_num = skb_shinfo ( skb ) -> nr_frags + 1 ; next_to_use = ring -> next_to_use ; size = skb_headlen ( skb ) ; dma = dma_map_single ( dev , skb -> data , size , DMA_TO_DEVICE ) ; if ( dma_mapping_error ( dev , dma ) ) { netdev_err ( ndev , "TX<S2SV_blank>head<S2SV_blank>DMA<S2SV_blank>map<S2SV_blank>failed\\n" ) ; ring -> stats . sw_err_cnt ++ ; goto out_err_tx_ok ; } priv -> ops . fill_desc ( ring , skb , size , dma , seg_num == 1 ? 1 : 0 , buf_num , DESC_TYPE_SKB , ndev -> mtu ) ; for ( i = 1 ; i < seg_num ; i ++ ) { frag = & skb_shinfo ( skb ) -> frags [ i - 1 ] ; size = skb_frag_size ( frag ) ; dma = skb_frag_dma_map ( dev , frag , 0 , size , DMA_TO_DEVICE ) ; if ( dma_mapping_error ( dev , dma ) ) { netdev_err ( ndev , "TX<S2SV_blank>frag(%d)<S2SV_blank>DMA<S2SV_blank>map<S2SV_blank>failed\\n" , i ) ; ring -> stats . sw_err_cnt ++ ; goto out_map_frag_fail ; } priv -> ops . fill_desc ( ring , skb_frag_page ( frag ) , size , dma , seg_num - 1 == i ? 1 : 0 , buf_num , DESC_TYPE_PAGE , ndev -> mtu ) ; } dev_queue = netdev_get_tx_queue ( ndev , skb -> queue_mapping ) ; netdev_tx_sent_queue ( dev_queue , skb -> len ) ; <S2SV_StartBug> wmb ( ) ; <S2SV_EndBug> assert ( skb -> queue_mapping < priv -> ae_handle -> q_num ) ; hnae_queue_xmit ( priv -> ae_handle -> qs [ skb -> queue_mapping ] , buf_num ) ; ring -> stats . tx_pkts ++ ; ring -> stats . tx_bytes += skb -> len ; return NETDEV_TX_OK ; out_map_frag_fail : while ( ring -> next_to_use != next_to_use ) { unfill_desc ( ring ) ; if ( ring -> next_to_use != next_to_use ) dma_unmap_page ( dev , ring -> desc_cb [ ring -> next_to_use ] . dma , ring -> desc_cb [ ring -> next_to_use ] . length , DMA_TO_DEVICE ) ; else dma_unmap_single ( dev , ring -> desc_cb [ next_to_use ] . dma , ring -> desc_cb [ next_to_use ] . length , DMA_TO_DEVICE ) ; } out_err_tx_ok : dev_kfree_skb_any ( skb ) ; return NETDEV_TX_OK ; out_net_tx_busy : netif_stop_subqueue ( ndev , skb -> queue_mapping ) ; smp_mb ( ) ; return NETDEV_TX_BUSY ; }
CWE-476 static int unimac_mdio_probe ( struct platform_device * pdev ) { struct unimac_mdio_pdata * pdata = pdev -> dev . platform_data ; struct unimac_mdio_priv * priv ; struct device_node * np ; struct mii_bus * bus ; struct resource * r ; int ret ; np = pdev -> dev . of_node ; priv = devm_kzalloc ( & pdev -> dev , sizeof ( * priv ) , GFP_KERNEL ) ; if ( ! priv ) return - ENOMEM ; r = platform_get_resource ( pdev , IORESOURCE_MEM , 0 ) ; <S2SV_StartBug> priv -> base = devm_ioremap ( & pdev -> dev , r -> start , resource_size ( r ) ) ; <S2SV_EndBug> if ( ! priv -> base ) { dev_err ( & pdev -> dev , "failed<S2SV_blank>to<S2SV_blank>remap<S2SV_blank>register\\n" ) ; return - ENOMEM ; } priv -> mii_bus = mdiobus_alloc ( ) ; if ( ! priv -> mii_bus ) return - ENOMEM ; bus = priv -> mii_bus ; bus -> priv = priv ; if ( pdata ) { bus -> name = pdata -> bus_name ; priv -> wait_func = pdata -> wait_func ; priv -> wait_func_data = pdata -> wait_func_data ; bus -> phy_mask = ~ pdata -> phy_mask ; } else { bus -> name = "unimac<S2SV_blank>MII<S2SV_blank>bus" ; priv -> wait_func_data = priv ; priv -> wait_func = unimac_mdio_poll ; } bus -> parent = & pdev -> dev ; bus -> read = unimac_mdio_read ; bus -> write = unimac_mdio_write ; bus -> reset = unimac_mdio_reset ; snprintf ( bus -> id , MII_BUS_ID_SIZE , "%s-%d" , pdev -> name , pdev -> id ) ; ret = of_mdiobus_register ( bus , np ) ; if ( ret ) { dev_err ( & pdev -> dev , "MDIO<S2SV_blank>bus<S2SV_blank>registration<S2SV_blank>failed\\n" ) ; goto out_mdio_free ; } platform_set_drvdata ( pdev , priv ) ; dev_info ( & pdev -> dev , "Broadcom<S2SV_blank>UniMAC<S2SV_blank>MDIO<S2SV_blank>bus<S2SV_blank>at<S2SV_blank>0x%p\\n" , priv -> base ) ; return 0 ; out_mdio_free : mdiobus_free ( bus ) ; return ret ; }
CWE-119 static int netlbl_cipsov4_add_common ( struct genl_info * info , struct cipso_v4_doi * doi_def ) { struct nlattr * nla ; int nla_rem ; u32 iter = 0 ; doi_def -> doi = nla_get_u32 ( info -> attrs [ NLBL_CIPSOV4_A_DOI ] ) ; if ( nla_validate_nested ( info -> attrs [ NLBL_CIPSOV4_A_TAGLST ] , NLBL_CIPSOV4_A_MAX , netlbl_cipsov4_genl_policy ) != 0 ) return - EINVAL ; nla_for_each_nested ( nla , info -> attrs [ NLBL_CIPSOV4_A_TAGLST ] , nla_rem ) if ( nla -> nla_type == NLBL_CIPSOV4_A_TAG ) { <S2SV_StartBug> if ( iter > CIPSO_V4_TAG_MAXCNT ) <S2SV_EndBug> return - EINVAL ; doi_def -> tags [ iter ++ ] = nla_get_u8 ( nla ) ; } <S2SV_StartBug> if ( iter < CIPSO_V4_TAG_MAXCNT ) <S2SV_EndBug> <S2SV_StartBug> doi_def -> tags [ iter ] = CIPSO_V4_TAG_INVALID ; <S2SV_EndBug> return 0 ; }
CWE-20 static int set_core_reg ( struct kvm_vcpu * vcpu , const struct kvm_one_reg * reg ) { __u32 __user * uaddr = ( __u32 __user * ) ( unsigned long ) reg -> addr ; struct kvm_regs * regs = vcpu_gp_regs ( vcpu ) ; int nr_regs = sizeof ( * regs ) / sizeof ( __u32 ) ; __uint128_t tmp ; void * valp = & tmp ; u64 off ; int err = 0 ; off = core_reg_offset_from_id ( reg -> id ) ; if ( off >= nr_regs || ( off + ( KVM_REG_SIZE ( reg -> id ) / sizeof ( __u32 ) ) ) >= nr_regs ) return - ENOENT ; if ( validate_core_offset ( reg ) ) return - EINVAL ; if ( KVM_REG_SIZE ( reg -> id ) > sizeof ( tmp ) ) return - EINVAL ; if ( copy_from_user ( valp , uaddr , KVM_REG_SIZE ( reg -> id ) ) ) { err = - EFAULT ; goto out ; } if ( off == KVM_REG_ARM_CORE_REG ( regs . pstate ) ) { <S2SV_StartBug> u32 mode = ( * ( u32 * ) valp ) & PSR_AA32_MODE_MASK ; <S2SV_EndBug> switch ( mode ) { case PSR_AA32_MODE_USR : <S2SV_StartBug> case PSR_AA32_MODE_FIQ : <S2SV_EndBug> case PSR_AA32_MODE_IRQ : case PSR_AA32_MODE_SVC : case PSR_AA32_MODE_ABT : case PSR_AA32_MODE_UND : <S2SV_StartBug> case PSR_MODE_EL0t : <S2SV_EndBug> case PSR_MODE_EL1t : <S2SV_StartBug> case PSR_MODE_EL1h : <S2SV_EndBug> break ; default : err = - EINVAL ; goto out ; } } memcpy ( ( u32 * ) regs + off , valp , KVM_REG_SIZE ( reg -> id ) ) ; out : return err ; }
CWE-119 static int iwl_process_add_sta_resp ( struct iwl_priv * priv , struct iwl_addsta_cmd * addsta , struct iwl_rx_packet * pkt ) { u8 sta_id = addsta -> sta . sta_id ; unsigned long flags ; int ret = - EIO ; if ( pkt -> hdr . flags & IWL_CMD_FAILED_MSK ) { IWL_ERR ( priv , "Bad<S2SV_blank>return<S2SV_blank>from<S2SV_blank>REPLY_ADD_STA<S2SV_blank>(0x%08X)\\n" , pkt -> hdr . flags ) ; return ret ; } IWL_DEBUG_INFO ( priv , "Processing<S2SV_blank>response<S2SV_blank>for<S2SV_blank>adding<S2SV_blank>station<S2SV_blank>%u\\n" , sta_id ) ; spin_lock_irqsave ( & priv -> shrd -> sta_lock , flags ) ; switch ( pkt -> u . add_sta . status ) { case ADD_STA_SUCCESS_MSK : IWL_DEBUG_INFO ( priv , "REPLY_ADD_STA<S2SV_blank>PASSED\\n" ) ; <S2SV_StartBug> iwl_sta_ucode_activate ( priv , sta_id ) ; <S2SV_EndBug> ret = 0 ; break ; case ADD_STA_NO_ROOM_IN_TABLE : IWL_ERR ( priv , "Adding<S2SV_blank>station<S2SV_blank>%d<S2SV_blank>failed,<S2SV_blank>no<S2SV_blank>room<S2SV_blank>in<S2SV_blank>table.\\n" , sta_id ) ; break ; case ADD_STA_NO_BLOCK_ACK_RESOURCE : IWL_ERR ( priv , "Adding<S2SV_blank>station<S2SV_blank>%d<S2SV_blank>failed,<S2SV_blank>no<S2SV_blank>block<S2SV_blank>ack<S2SV_blank>" "resource.\\n" , sta_id ) ; break ; case ADD_STA_MODIFY_NON_EXIST_STA : IWL_ERR ( priv , "Attempting<S2SV_blank>to<S2SV_blank>modify<S2SV_blank>non-existing<S2SV_blank>station<S2SV_blank>%d\\n" , sta_id ) ; break ; default : IWL_DEBUG_ASSOC ( priv , "Received<S2SV_blank>REPLY_ADD_STA:(0x%08X)\\n" , pkt -> u . add_sta . status ) ; break ; } IWL_DEBUG_INFO ( priv , "%s<S2SV_blank>station<S2SV_blank>id<S2SV_blank>%u<S2SV_blank>addr<S2SV_blank>%pM\\n" , priv -> stations [ sta_id ] . sta . mode == STA_CONTROL_MODIFY_MSK ? "Modified" : "Added" , sta_id , priv -> stations [ sta_id ] . sta . sta . addr ) ; IWL_DEBUG_INFO ( priv , "%s<S2SV_blank>station<S2SV_blank>according<S2SV_blank>to<S2SV_blank>cmd<S2SV_blank>buffer<S2SV_blank>%pM\\n" , priv -> stations [ sta_id ] . sta . mode == STA_CONTROL_MODIFY_MSK ? "Modified" : "Added" , addsta -> sta . addr ) ; spin_unlock_irqrestore ( & priv -> shrd -> sta_lock , flags ) ; return ret ; }
CWE-119 <S2SV_StartBug> static void iwl_sta_ucode_activate ( struct iwl_priv * priv , u8 sta_id ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> if ( ! ( priv -> stations [ sta_id ] . used & IWL_STA_DRIVER_ACTIVE ) ) IWL_ERR ( priv , "ACTIVATE<S2SV_blank>a<S2SV_blank>non<S2SV_blank>DRIVER<S2SV_blank>active<S2SV_blank>station<S2SV_blank>id<S2SV_blank>%u<S2SV_blank>" "addr<S2SV_blank>%pM\\n" , sta_id , priv -> stations [ sta_id ] . sta . sta . addr ) ; if ( priv -> stations [ sta_id ] . used & IWL_STA_UCODE_ACTIVE ) { IWL_DEBUG_ASSOC ( priv , "STA<S2SV_blank>id<S2SV_blank>%u<S2SV_blank>addr<S2SV_blank>%pM<S2SV_blank>already<S2SV_blank>present<S2SV_blank>in<S2SV_blank>uCode<S2SV_blank>" "(according<S2SV_blank>to<S2SV_blank>driver)\\n" , sta_id , priv -> stations [ sta_id ] . sta . sta . addr ) ; } else { priv -> stations [ sta_id ] . used |= IWL_STA_UCODE_ACTIVE ; IWL_DEBUG_ASSOC ( priv , "Added<S2SV_blank>STA<S2SV_blank>id<S2SV_blank>%u<S2SV_blank>addr<S2SV_blank>%pM<S2SV_blank>to<S2SV_blank>uCode\\n" , sta_id , priv -> stations [ sta_id ] . sta . sta . addr ) ; } <S2SV_StartBug> } <S2SV_EndBug>
CWE-362 static bool add_free_nid ( struct f2fs_sb_info * sbi , nid_t nid , bool build ) { struct f2fs_nm_info * nm_i = NM_I ( sbi ) ; <S2SV_StartBug> struct free_nid * i ; <S2SV_EndBug> struct nat_entry * ne ; <S2SV_StartBug> int err ; <S2SV_EndBug> if ( unlikely ( nid == 0 ) ) return false ; <S2SV_StartBug> if ( build ) { <S2SV_EndBug> ne = __lookup_nat_cache ( nm_i , nid ) ; if ( ne && ( ! get_nat_flag ( ne , IS_CHECKPOINTED ) || nat_get_blkaddr ( ne ) != NULL_ADDR ) ) <S2SV_StartBug> return false ; <S2SV_EndBug> } i = f2fs_kmem_cache_alloc ( free_nid_slab , GFP_NOFS ) ; i -> nid = nid ; i -> state = NID_NEW ; if ( radix_tree_preload ( GFP_NOFS ) ) { kmem_cache_free ( free_nid_slab , i ) ; return true ; } spin_lock ( & nm_i -> nid_list_lock ) ; err = __insert_nid_to_list ( sbi , i , FREE_NID_LIST , true ) ; spin_unlock ( & nm_i -> nid_list_lock ) ; radix_tree_preload_end ( ) ; if ( err ) { kmem_cache_free ( free_nid_slab , i ) ; return true ; } return true ; }
CWE-476 static irqreturn_t i8042_interrupt ( int irq , void * dev_id ) { struct i8042_port * port ; struct serio * serio ; unsigned long flags ; unsigned char str , data ; unsigned int dfl ; unsigned int port_no ; bool filtered ; int ret = 1 ; spin_lock_irqsave ( & i8042_lock , flags ) ; str = i8042_read_status ( ) ; if ( unlikely ( ~ str & I8042_STR_OBF ) ) { spin_unlock_irqrestore ( & i8042_lock , flags ) ; if ( irq ) dbg ( "Interrupt<S2SV_blank>%d,<S2SV_blank>without<S2SV_blank>any<S2SV_blank>data\\n" , irq ) ; ret = 0 ; goto out ; } data = i8042_read_data ( ) ; if ( i8042_mux_present && ( str & I8042_STR_AUXDATA ) ) { static unsigned long last_transmit ; static unsigned char last_str ; dfl = 0 ; if ( str & I8042_STR_MUXERR ) { dbg ( "MUX<S2SV_blank>error,<S2SV_blank>status<S2SV_blank>is<S2SV_blank>%02x,<S2SV_blank>data<S2SV_blank>is<S2SV_blank>%02x\\n" , str , data ) ; switch ( data ) { default : if ( time_before ( jiffies , last_transmit + HZ / 10 ) ) { str = last_str ; break ; } case 0xfc : case 0xfd : case 0xfe : dfl = SERIO_TIMEOUT ; data = 0xfe ; break ; case 0xff : dfl = SERIO_PARITY ; data = 0xfe ; break ; } } port_no = I8042_MUX_PORT_NO + ( ( str >> 6 ) & 3 ) ; last_str = str ; last_transmit = jiffies ; } else { dfl = ( ( str & I8042_STR_PARITY ) ? SERIO_PARITY : 0 ) | ( ( str & I8042_STR_TIMEOUT && ! i8042_notimeout ) ? SERIO_TIMEOUT : 0 ) ; port_no = ( str & I8042_STR_AUXDATA ) ? I8042_AUX_PORT_NO : I8042_KBD_PORT_NO ; } port = & i8042_ports [ port_no ] ; serio = port -> exists ? port -> serio : NULL ; filter_dbg ( port -> driver_bound , data , "<-<S2SV_blank>i8042<S2SV_blank>(interrupt,<S2SV_blank>%d,<S2SV_blank>%d%s%s)\\n" , port_no , irq , dfl & SERIO_PARITY ? ",<S2SV_blank>bad<S2SV_blank>parity" : "" , dfl & SERIO_TIMEOUT ? ",<S2SV_blank>timeout" : "" ) ; filtered = i8042_filter ( data , str , serio ) ; spin_unlock_irqrestore ( & i8042_lock , flags ) ; <S2SV_StartBug> if ( likely ( port -> exists && ! filtered ) ) <S2SV_EndBug> serio_interrupt ( serio , data , dfl ) ; out : return IRQ_RETVAL ( ret ) ; }
CWE-476 static int i8042_start ( struct serio * serio ) { struct i8042_port * port = serio -> port_data ; <S2SV_StartBug> port -> exists = true ; <S2SV_EndBug> <S2SV_StartBug> mb ( ) ; <S2SV_EndBug> return 0 ; }
CWE-476 static void i8042_stop ( struct serio * serio ) { struct i8042_port * port = serio -> port_data ; <S2SV_StartBug> port -> exists = false ; <S2SV_EndBug> synchronize_irq ( I8042_AUX_IRQ ) ; synchronize_irq ( I8042_KBD_IRQ ) ; <S2SV_StartBug> port -> serio = NULL ; <S2SV_EndBug> }
CWE-200 static __net_init int setup_net ( struct net * net , struct user_namespace * user_ns ) { const struct pernet_operations * ops , * saved_ops ; int error = 0 ; LIST_HEAD ( net_exit_list ) ; refcount_set ( & net -> count , 1 ) ; refcount_set ( & net -> passive , 1 ) ; <S2SV_StartBug> net -> dev_base_seq = 1 ; <S2SV_EndBug> net -> user_ns = user_ns ; idr_init ( & net -> netns_ids ) ; spin_lock_init ( & net -> nsid_lock ) ; mutex_init ( & net -> ipv4 . ra_mutex ) ; list_for_each_entry ( ops , & pernet_list , list ) { error = ops_init ( ops , net ) ; if ( error < 0 ) goto out_undo ; } down_write ( & net_rwsem ) ; list_add_tail_rcu ( & net -> list , & net_namespace_list ) ; up_write ( & net_rwsem ) ; out : return error ; out_undo : list_add ( & net -> exit_list , & net_exit_list ) ; saved_ops = ops ; list_for_each_entry_continue_reverse ( ops , & pernet_list , list ) ops_exit_list ( ops , & net_exit_list ) ; ops = saved_ops ; list_for_each_entry_continue_reverse ( ops , & pernet_list , list ) ops_free_list ( ops , & net_exit_list ) ; rcu_barrier ( ) ; goto out ; }
CWE-416 static ssize_t userfaultfd_ctx_read ( struct userfaultfd_ctx * ctx , int no_wait , struct uffd_msg * msg ) { ssize_t ret ; DECLARE_WAITQUEUE ( wait , current ) ; struct userfaultfd_wait_queue * uwq ; LIST_HEAD ( fork_event ) ; struct userfaultfd_ctx * fork_nctx = NULL ; spin_lock ( & ctx -> fd_wqh . lock ) ; __add_wait_queue ( & ctx -> fd_wqh , & wait ) ; for ( ; ; ) { set_current_state ( TASK_INTERRUPTIBLE ) ; spin_lock ( & ctx -> fault_pending_wqh . lock ) ; uwq = find_userfault ( ctx ) ; if ( uwq ) { write_seqcount_begin ( & ctx -> refile_seq ) ; list_del ( & uwq -> wq . entry ) ; __add_wait_queue ( & ctx -> fault_wqh , & uwq -> wq ) ; write_seqcount_end ( & ctx -> refile_seq ) ; * msg = uwq -> msg ; spin_unlock ( & ctx -> fault_pending_wqh . lock ) ; ret = 0 ; break ; } spin_unlock ( & ctx -> fault_pending_wqh . lock ) ; spin_lock ( & ctx -> event_wqh . lock ) ; uwq = find_userfault_evt ( ctx ) ; if ( uwq ) { * msg = uwq -> msg ; if ( uwq -> msg . event == UFFD_EVENT_FORK ) { fork_nctx = ( struct userfaultfd_ctx * ) ( unsigned long ) uwq -> msg . arg . reserved . reserved1 ; list_move ( & uwq -> wq . entry , & fork_event ) ; <S2SV_StartBug> spin_unlock ( & ctx -> event_wqh . lock ) ; <S2SV_EndBug> ret = 0 ; break ; } userfaultfd_event_complete ( ctx , uwq ) ; spin_unlock ( & ctx -> event_wqh . lock ) ; ret = 0 ; break ; } spin_unlock ( & ctx -> event_wqh . lock ) ; if ( signal_pending ( current ) ) { ret = - ERESTARTSYS ; break ; } if ( no_wait ) { ret = - EAGAIN ; break ; } spin_unlock ( & ctx -> fd_wqh . lock ) ; schedule ( ) ; spin_lock ( & ctx -> fd_wqh . lock ) ; } __remove_wait_queue ( & ctx -> fd_wqh , & wait ) ; __set_current_state ( TASK_RUNNING ) ; spin_unlock ( & ctx -> fd_wqh . lock ) ; if ( ! ret && msg -> event == UFFD_EVENT_FORK ) { ret = resolve_userfault_fork ( ctx , fork_nctx , msg ) ; <S2SV_StartBug> if ( ! ret ) { <S2SV_EndBug> spin_lock ( & ctx -> event_wqh . lock ) ; if ( ! list_empty ( & fork_event ) ) { <S2SV_StartBug> uwq = list_first_entry ( & fork_event , <S2SV_EndBug> typeof ( * uwq ) , wq . entry ) ; list_del ( & uwq -> wq . entry ) ; __add_wait_queue ( & ctx -> event_wqh , & uwq -> wq ) ; <S2SV_StartBug> userfaultfd_event_complete ( ctx , uwq ) ; <S2SV_EndBug> } <S2SV_StartBug> spin_unlock ( & ctx -> event_wqh . lock ) ; <S2SV_EndBug> } } return ret ; }
CWE-476 static int nfc_genl_deactivate_target ( struct sk_buff * skb , struct genl_info * info ) { struct nfc_dev * dev ; u32 device_idx , target_idx ; int rc ; <S2SV_StartBug> if ( ! info -> attrs [ NFC_ATTR_DEVICE_INDEX ] ) <S2SV_EndBug> return - EINVAL ; device_idx = nla_get_u32 ( info -> attrs [ NFC_ATTR_DEVICE_INDEX ] ) ; dev = nfc_get_device ( device_idx ) ; if ( ! dev ) return - ENODEV ; target_idx = nla_get_u32 ( info -> attrs [ NFC_ATTR_TARGET_INDEX ] ) ; rc = nfc_deactivate_target ( dev , target_idx , NFC_TARGET_MODE_SLEEP ) ; nfc_put_device ( dev ) ; return rc ; }
CWE-362 static ssize_t ocfs2_direct_IO ( struct kiocb * iocb , struct iov_iter * iter ) { struct file * file = iocb -> ki_filp ; struct inode * inode = file -> f_mapping -> host ; struct ocfs2_super * osb = OCFS2_SB ( inode -> i_sb ) ; get_block_t * get_block ; if ( OCFS2_I ( inode ) -> ip_dyn_features & OCFS2_INLINE_DATA_FL ) return 0 ; if ( iocb -> ki_pos + iter -> count > i_size_read ( inode ) && ! ocfs2_supports_append_dio ( osb ) ) return 0 ; if ( iov_iter_rw ( iter ) == READ ) <S2SV_StartBug> get_block = ocfs2_get_block ; <S2SV_EndBug> else <S2SV_StartBug> get_block = ocfs2_dio_get_block ; <S2SV_EndBug> return __blockdev_direct_IO ( iocb , inode , inode -> i_sb -> s_bdev , iter , get_block , ocfs2_dio_end_io , NULL , 0 ) ; }
CWE-416 static int try_smi_init ( struct smi_info * new_smi ) { int rv = 0 ; int i ; char * init_name = NULL ; pr_info ( "Trying<S2SV_blank>%s-specified<S2SV_blank>%s<S2SV_blank>state<S2SV_blank>machine<S2SV_blank>at<S2SV_blank>%s<S2SV_blank>address<S2SV_blank>0x%lx,<S2SV_blank>slave<S2SV_blank>address<S2SV_blank>0x%x,<S2SV_blank>irq<S2SV_blank>%d\\n" , ipmi_addr_src_to_str ( new_smi -> io . addr_source ) , si_to_str [ new_smi -> io . si_type ] , addr_space_to_str [ new_smi -> io . addr_type ] , new_smi -> io . addr_data , new_smi -> io . slave_addr , new_smi -> io . irq ) ; switch ( new_smi -> io . si_type ) { case SI_KCS : new_smi -> handlers = & kcs_smi_handlers ; break ; case SI_SMIC : new_smi -> handlers = & smic_smi_handlers ; break ; case SI_BT : new_smi -> handlers = & bt_smi_handlers ; break ; default : rv = - EIO ; goto out_err ; } new_smi -> si_num = smi_num ; if ( ! new_smi -> io . dev ) { init_name = kasprintf ( GFP_KERNEL , "ipmi_si.%d" , new_smi -> si_num ) ; new_smi -> pdev = platform_device_alloc ( "ipmi_si" , new_smi -> si_num ) ; if ( ! new_smi -> pdev ) { pr_err ( "Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>platform<S2SV_blank>device\\n" ) ; rv = - ENOMEM ; goto out_err ; } new_smi -> io . dev = & new_smi -> pdev -> dev ; new_smi -> io . dev -> driver = & ipmi_platform_driver . driver ; new_smi -> io . dev -> init_name = init_name ; } new_smi -> si_sm = kmalloc ( new_smi -> handlers -> size ( ) , GFP_KERNEL ) ; if ( ! new_smi -> si_sm ) { rv = - ENOMEM ; goto out_err ; } new_smi -> io . io_size = new_smi -> handlers -> init_data ( new_smi -> si_sm , & new_smi -> io ) ; rv = new_smi -> io . io_setup ( & new_smi -> io ) ; if ( rv ) { dev_err ( new_smi -> io . dev , "Could<S2SV_blank>not<S2SV_blank>set<S2SV_blank>up<S2SV_blank>I/O<S2SV_blank>space\\n" ) ; goto out_err ; } if ( new_smi -> handlers -> detect ( new_smi -> si_sm ) ) { if ( new_smi -> io . addr_source ) dev_err ( new_smi -> io . dev , "Interface<S2SV_blank>detection<S2SV_blank>failed\\n" ) ; rv = - ENODEV ; goto out_err ; } rv = try_get_dev_id ( new_smi ) ; if ( rv ) { if ( new_smi -> io . addr_source ) dev_err ( new_smi -> io . dev , "There<S2SV_blank>appears<S2SV_blank>to<S2SV_blank>be<S2SV_blank>no<S2SV_blank>BMC<S2SV_blank>at<S2SV_blank>this<S2SV_blank>location\\n" ) ; goto out_err ; } setup_oem_data_handler ( new_smi ) ; setup_xaction_handlers ( new_smi ) ; check_for_broken_irqs ( new_smi ) ; new_smi -> waiting_msg = NULL ; new_smi -> curr_msg = NULL ; atomic_set ( & new_smi -> req_events , 0 ) ; new_smi -> run_to_completion = false ; for ( i = 0 ; i < SI_NUM_STATS ; i ++ ) atomic_set ( & new_smi -> stats [ i ] , 0 ) ; new_smi -> interrupt_disabled = true ; atomic_set ( & new_smi -> need_watch , 0 ) ; rv = try_enable_event_buffer ( new_smi ) ; if ( rv == 0 ) new_smi -> has_event_buffer = true ; start_clear_flags ( new_smi ) ; if ( new_smi -> io . irq ) { new_smi -> interrupt_disabled = false ; atomic_set ( & new_smi -> req_events , 1 ) ; } if ( new_smi -> pdev && ! new_smi -> pdev_registered ) { rv = platform_device_add ( new_smi -> pdev ) ; if ( rv ) { dev_err ( new_smi -> io . dev , "Unable<S2SV_blank>to<S2SV_blank>register<S2SV_blank>system<S2SV_blank>interface<S2SV_blank>device:<S2SV_blank>%d\\n" , rv ) ; goto out_err ; } new_smi -> pdev_registered = true ; } dev_set_drvdata ( new_smi -> io . dev , new_smi ) ; rv = device_add_group ( new_smi -> io . dev , & ipmi_si_dev_attr_group ) ; if ( rv ) { dev_err ( new_smi -> io . dev , "Unable<S2SV_blank>to<S2SV_blank>add<S2SV_blank>device<S2SV_blank>attributes:<S2SV_blank>error<S2SV_blank>%d\\n" , rv ) ; goto out_err ; } new_smi -> dev_group_added = true ; rv = ipmi_register_smi ( & handlers , new_smi , new_smi -> io . dev , new_smi -> io . slave_addr ) ; if ( rv ) { dev_err ( new_smi -> io . dev , "Unable<S2SV_blank>to<S2SV_blank>register<S2SV_blank>device:<S2SV_blank>error<S2SV_blank>%d\\n" , rv ) ; goto out_err ; } smi_num ++ ; dev_info ( new_smi -> io . dev , "IPMI<S2SV_blank>%s<S2SV_blank>interface<S2SV_blank>initialized\\n" , si_to_str [ new_smi -> io . si_type ] ) ; WARN_ON ( new_smi -> io . dev -> init_name != NULL ) ; out_err : <S2SV_StartBug> kfree ( init_name ) ; <S2SV_EndBug> return rv ; }
CWE-416 int ipmi_si_mem_setup ( struct si_sm_io * io ) { unsigned long addr = io -> addr_data ; int mapsize , idx ; if ( ! addr ) return - ENODEV ; <S2SV_StartBug> io -> io_cleanup = mem_cleanup ; <S2SV_EndBug> switch ( io -> regsize ) { case 1 : io -> inputb = intf_mem_inb ; io -> outputb = intf_mem_outb ; break ; case 2 : io -> inputb = intf_mem_inw ; io -> outputb = intf_mem_outw ; break ; case 4 : io -> inputb = intf_mem_inl ; io -> outputb = intf_mem_outl ; break ; # ifdef readq case 8 : io -> inputb = mem_inq ; io -> outputb = mem_outq ; break ; # endif default : dev_warn ( io -> dev , "Invalid<S2SV_blank>register<S2SV_blank>size:<S2SV_blank>%d\\n" , io -> regsize ) ; return - EINVAL ; } for ( idx = 0 ; idx < io -> io_size ; idx ++ ) { if ( request_mem_region ( addr + idx * io -> regspacing , io -> regsize , DEVICE_NAME ) == NULL ) { mem_region_cleanup ( io , idx ) ; return - EIO ; } } mapsize = ( ( io -> io_size * io -> regspacing ) - ( io -> regspacing - io -> regsize ) ) ; io -> addr = ioremap ( addr , mapsize ) ; if ( io -> addr == NULL ) { mem_region_cleanup ( io , io -> io_size ) ; return - EIO ; } <S2SV_StartBug> return 0 ; <S2SV_EndBug> }
CWE-416 int ipmi_si_port_setup ( struct si_sm_io * io ) { unsigned int addr = io -> addr_data ; int idx ; if ( ! addr ) return - ENODEV ; <S2SV_StartBug> io -> io_cleanup = port_cleanup ; <S2SV_EndBug> switch ( io -> regsize ) { case 1 : io -> inputb = port_inb ; io -> outputb = port_outb ; break ; case 2 : io -> inputb = port_inw ; io -> outputb = port_outw ; break ; case 4 : io -> inputb = port_inl ; io -> outputb = port_outl ; break ; default : dev_warn ( io -> dev , "Invalid<S2SV_blank>register<S2SV_blank>size:<S2SV_blank>%d\\n" , io -> regsize ) ; return - EINVAL ; } for ( idx = 0 ; idx < io -> io_size ; idx ++ ) { if ( request_region ( addr + idx * io -> regspacing , io -> regsize , DEVICE_NAME ) == NULL ) { while ( idx -- ) release_region ( addr + idx * io -> regspacing , io -> regsize ) ; return - EIO ; } } <S2SV_StartBug> return 0 ; <S2SV_EndBug> }
CWE-119 static int hns_gmac_get_sset_count ( int stringset ) { <S2SV_StartBug> if ( stringset == ETH_SS_STATS ) <S2SV_EndBug> return ARRAY_SIZE ( g_gmac_stats_string ) ; return 0 ; }
CWE-119 static int hns_xgmac_get_sset_count ( int stringset ) { <S2SV_StartBug> if ( stringset == ETH_SS_STATS ) <S2SV_EndBug> return ARRAY_SIZE ( g_xgmac_stats_string ) ; return 0 ; }
CWE-772 int sas_smp_get_phy_events ( struct sas_phy * phy ) { int res ; u8 * req ; u8 * resp ; struct sas_rphy * rphy = dev_to_rphy ( phy -> dev . parent ) ; struct domain_device * dev = sas_find_dev_by_rphy ( rphy ) ; req = alloc_smp_req ( RPEL_REQ_SIZE ) ; if ( ! req ) return - ENOMEM ; resp = alloc_smp_resp ( RPEL_RESP_SIZE ) ; if ( ! resp ) { kfree ( req ) ; return - ENOMEM ; } req [ 1 ] = SMP_REPORT_PHY_ERR_LOG ; req [ 9 ] = phy -> number ; res = smp_execute_task ( dev , req , RPEL_REQ_SIZE , resp , RPEL_RESP_SIZE ) ; if ( ! res ) goto out ; phy -> invalid_dword_count = scsi_to_u32 ( & resp [ 12 ] ) ; phy -> running_disparity_error_count = scsi_to_u32 ( & resp [ 16 ] ) ; phy -> loss_of_dword_sync_count = scsi_to_u32 ( & resp [ 20 ] ) ; phy -> phy_reset_problem_count = scsi_to_u32 ( & resp [ 24 ] ) ; out : <S2SV_StartBug> kfree ( resp ) ; <S2SV_EndBug> return res ; }
CWE-119 static int kill_something_info ( int sig , struct siginfo * info , pid_t pid ) { int ret ; if ( pid > 0 ) { rcu_read_lock ( ) ; ret = kill_pid_info ( sig , info , find_vpid ( pid ) ) ; rcu_read_unlock ( ) ; return ret ; <S2SV_StartBug> } <S2SV_EndBug> read_lock ( & tasklist_lock ) ; if ( pid != - 1 ) { ret = __kill_pgrp_info ( sig , info , pid ? find_vpid ( - pid ) : task_pgrp ( current ) ) ; } else { int retval = 0 , count = 0 ; struct task_struct * p ; for_each_process ( p ) { if ( task_pid_vnr ( p ) > 1 && ! same_thread_group ( p , current ) ) { int err = group_send_sig_info ( sig , info , p ) ; ++ count ; if ( err != - EPERM ) retval = err ; } } ret = count ? retval : - ESRCH ; } read_unlock ( & tasklist_lock ) ; return ret ; }
CWE-416 int blk_init_allocated_queue ( struct request_queue * q ) { WARN_ON_ONCE ( q -> mq_ops ) ; q -> fq = blk_alloc_flush_queue ( q , NUMA_NO_NODE , q -> cmd_size ) ; if ( ! q -> fq ) return - ENOMEM ; if ( q -> init_rq_fn && q -> init_rq_fn ( q , q -> fq -> flush_rq , GFP_KERNEL ) ) goto out_free_flush_queue ; if ( blk_init_rl ( & q -> root_rl , q , GFP_KERNEL ) ) goto out_exit_flush_rq ; INIT_WORK ( & q -> timeout_work , blk_timeout_work ) ; q -> queue_flags |= QUEUE_FLAG_DEFAULT ; blk_queue_make_request ( q , blk_queue_bio ) ; q -> sg_reserved_size = INT_MAX ; if ( elevator_init ( q ) ) goto out_exit_flush_rq ; return 0 ; out_exit_flush_rq : if ( q -> exit_rq_fn ) q -> exit_rq_fn ( q , q -> fq -> flush_rq ) ; out_free_flush_queue : blk_free_flush_queue ( q -> fq ) ; <S2SV_StartBug> return - ENOMEM ; <S2SV_EndBug> }
CWE-200 void __ip_select_ident ( struct iphdr * iph , int segs ) { static u32 ip_idents_hashrnd __read_mostly ; <S2SV_StartBug> u32 hash , id ; <S2SV_EndBug> <S2SV_StartBug> net_get_random_once ( & ip_idents_hashrnd , sizeof ( ip_idents_hashrnd ) ) ; <S2SV_EndBug> hash = jhash_3words ( ( __force u32 ) iph -> daddr , ( __force u32 ) iph -> saddr , <S2SV_StartBug> iph -> protocol , <S2SV_EndBug> ip_idents_hashrnd ) ; id = ip_idents_reserve ( hash , segs ) ; iph -> id = htons ( id ) ; }
CWE-200 static void ipv6_select_ident ( struct frag_hdr * fhdr , struct rt6_info * rt ) { static u32 ip6_idents_hashrnd __read_mostly ; <S2SV_StartBug> u32 hash , id ; <S2SV_EndBug> <S2SV_StartBug> net_get_random_once ( & ip6_idents_hashrnd , sizeof ( ip6_idents_hashrnd ) ) ; <S2SV_EndBug> hash = __ipv6_addr_jhash ( & rt -> rt6i_dst . addr , ip6_idents_hashrnd ) ; hash = __ipv6_addr_jhash ( & rt -> rt6i_src . addr , hash ) ; <S2SV_StartBug> id = ip_idents_reserve ( hash , 1 ) ; <S2SV_EndBug> fhdr -> identification = htonl ( id ) ; }
CWE-416 static int hci_uart_set_proto ( struct hci_uart * hu , int id ) { const struct hci_uart_proto * p ; int err ; p = hci_uart_get_proto ( id ) ; if ( ! p ) return - EPROTONOSUPPORT ; hu -> proto = p ; <S2SV_StartBug> set_bit ( HCI_UART_PROTO_READY , & hu -> flags ) ; <S2SV_EndBug> err = hci_uart_register_dev ( hu ) ; if ( err ) { <S2SV_StartBug> clear_bit ( HCI_UART_PROTO_READY , & hu -> flags ) ; <S2SV_EndBug> <S2SV_StartBug> return err ; <S2SV_EndBug> } return 0 ; }
CWE-200 static int mincore_pte_range ( pmd_t * pmd , unsigned long addr , unsigned long end , struct mm_walk * walk ) { spinlock_t * ptl ; struct vm_area_struct * vma = walk -> vma ; pte_t * ptep ; unsigned char * vec = walk -> private ; int nr = ( end - addr ) >> PAGE_SHIFT ; ptl = pmd_trans_huge_lock ( pmd , vma ) ; if ( ptl ) { memset ( vec , 1 , nr ) ; spin_unlock ( ptl ) ; goto out ; } if ( pmd_trans_unstable ( pmd ) ) { <S2SV_StartBug> __mincore_unmapped_range ( addr , end , vma , vec ) ; <S2SV_EndBug> goto out ; } ptep = pte_offset_map_lock ( walk -> mm , pmd , addr , & ptl ) ; for ( ; addr != end ; ptep ++ , addr += PAGE_SIZE ) { pte_t pte = * ptep ; if ( pte_none ( pte ) ) <S2SV_StartBug> __mincore_unmapped_range ( addr , addr + PAGE_SIZE , <S2SV_EndBug> vma , vec ) ; else if ( pte_present ( pte ) ) * vec = 1 ; else { swp_entry_t entry = pte_to_swp_entry ( pte ) ; <S2SV_StartBug> if ( non_swap_entry ( entry ) ) { <S2SV_EndBug> * vec = 1 ; } else { # ifdef CONFIG_SWAP * vec = mincore_page ( swap_address_space ( entry ) , swp_offset ( entry ) ) ; # else WARN_ON ( 1 ) ; * vec = 1 ; # endif } } vec ++ ; } pte_unmap_unlock ( ptep - 1 , ptl ) ; out : walk -> private += nr ; cond_resched ( ) ; return 0 ; }
CWE-200 static int mincore_unmapped_range ( unsigned long addr , unsigned long end , struct mm_walk * walk ) { <S2SV_StartBug> walk -> private += __mincore_unmapped_range ( addr , end , <S2SV_EndBug> walk -> vma , walk -> private ) ; return 0 ; }
CWE-476 unsigned int arpt_do_table ( struct sk_buff * skb , const struct nf_hook_state * state , struct xt_table * table ) { unsigned int hook = state -> hook ; static const char nulldevname [ IFNAMSIZ ] __attribute__ ( ( aligned ( sizeof ( long ) ) ) ) ; unsigned int verdict = NF_DROP ; const struct arphdr * arp ; struct arpt_entry * e , * * jumpstack ; const char * indev , * outdev ; const void * table_base ; unsigned int cpu , stackidx = 0 ; const struct xt_table_info * private ; struct xt_action_param acpar ; unsigned int addend ; if ( ! pskb_may_pull ( skb , arp_hdr_len ( skb -> dev ) ) ) return NF_DROP ; indev = state -> in ? state -> in -> name : nulldevname ; outdev = state -> out ? state -> out -> name : nulldevname ; local_bh_disable ( ) ; addend = xt_write_recseq_begin ( ) ; private = READ_ONCE ( table -> private ) ; cpu = smp_processor_id ( ) ; table_base = private -> entries ; jumpstack = ( struct arpt_entry * * ) private -> jumpstack [ cpu ] ; e = get_entry ( table_base , private -> hook_entry [ hook ] ) ; acpar . state = state ; acpar . hotdrop = false ; arp = arp_hdr ( skb ) ; do { const struct xt_entry_target * t ; struct xt_counters * counter ; if ( ! arp_packet_match ( arp , skb -> dev , indev , outdev , & e -> arp ) ) { e = arpt_next_entry ( e ) ; continue ; } counter = xt_get_this_cpu_counter ( & e -> counters ) ; ADD_COUNTER ( * counter , arp_hdr_len ( skb -> dev ) , 1 ) ; t = arpt_get_target_c ( e ) ; if ( ! t -> u . kernel . target -> target ) { int v ; v = ( ( struct xt_standard_target * ) t ) -> verdict ; if ( v < 0 ) { if ( v != XT_RETURN ) { verdict = ( unsigned int ) ( - v ) - 1 ; break ; } if ( stackidx == 0 ) { e = get_entry ( table_base , private -> underflow [ hook ] ) ; } else { e = jumpstack [ -- stackidx ] ; e = arpt_next_entry ( e ) ; } continue ; } if ( table_base + v != arpt_next_entry ( e ) ) { <S2SV_StartBug> jumpstack [ stackidx ++ ] = e ; <S2SV_EndBug> } e = get_entry ( table_base , v ) ; continue ; } acpar . target = t -> u . kernel . target ; acpar . targinfo = t -> data ; verdict = t -> u . kernel . target -> target ( skb , & acpar ) ; if ( verdict == XT_CONTINUE ) { arp = arp_hdr ( skb ) ; e = arpt_next_entry ( e ) ; } else { break ; } } while ( ! acpar . hotdrop ) ; xt_write_recseq_end ( addend ) ; local_bh_enable ( ) ; if ( acpar . hotdrop ) return NF_DROP ; else return verdict ; }
CWE-476 unsigned int ipt_do_table ( struct sk_buff * skb , const struct nf_hook_state * state , struct xt_table * table ) { unsigned int hook = state -> hook ; static const char nulldevname [ IFNAMSIZ ] __attribute__ ( ( aligned ( sizeof ( long ) ) ) ) ; const struct iphdr * ip ; unsigned int verdict = NF_DROP ; const char * indev , * outdev ; const void * table_base ; struct ipt_entry * e , * * jumpstack ; unsigned int stackidx , cpu ; const struct xt_table_info * private ; struct xt_action_param acpar ; unsigned int addend ; stackidx = 0 ; ip = ip_hdr ( skb ) ; indev = state -> in ? state -> in -> name : nulldevname ; outdev = state -> out ? state -> out -> name : nulldevname ; acpar . fragoff = ntohs ( ip -> frag_off ) & IP_OFFSET ; acpar . thoff = ip_hdrlen ( skb ) ; acpar . hotdrop = false ; acpar . state = state ; WARN_ON ( ! ( table -> valid_hooks & ( 1 << hook ) ) ) ; local_bh_disable ( ) ; addend = xt_write_recseq_begin ( ) ; private = READ_ONCE ( table -> private ) ; cpu = smp_processor_id ( ) ; table_base = private -> entries ; jumpstack = ( struct ipt_entry * * ) private -> jumpstack [ cpu ] ; if ( static_key_false ( & xt_tee_enabled ) ) jumpstack += private -> stacksize * __this_cpu_read ( nf_skb_duplicated ) ; e = get_entry ( table_base , private -> hook_entry [ hook ] ) ; do { const struct xt_entry_target * t ; const struct xt_entry_match * ematch ; struct xt_counters * counter ; WARN_ON ( ! e ) ; if ( ! ip_packet_match ( ip , indev , outdev , & e -> ip , acpar . fragoff ) ) { no_match : e = ipt_next_entry ( e ) ; continue ; } xt_ematch_foreach ( ematch , e ) { acpar . match = ematch -> u . kernel . match ; acpar . matchinfo = ematch -> data ; if ( ! acpar . match -> match ( skb , & acpar ) ) goto no_match ; } counter = xt_get_this_cpu_counter ( & e -> counters ) ; ADD_COUNTER ( * counter , skb -> len , 1 ) ; t = ipt_get_target ( e ) ; WARN_ON ( ! t -> u . kernel . target ) ; # if IS_ENABLED ( CONFIG_NETFILTER_XT_TARGET_TRACE ) if ( unlikely ( skb -> nf_trace ) ) trace_packet ( state -> net , skb , hook , state -> in , state -> out , table -> name , private , e ) ; # endif if ( ! t -> u . kernel . target -> target ) { int v ; v = ( ( struct xt_standard_target * ) t ) -> verdict ; if ( v < 0 ) { if ( v != XT_RETURN ) { verdict = ( unsigned int ) ( - v ) - 1 ; break ; } if ( stackidx == 0 ) { e = get_entry ( table_base , private -> underflow [ hook ] ) ; } else { e = jumpstack [ -- stackidx ] ; e = ipt_next_entry ( e ) ; } continue ; } if ( table_base + v != ipt_next_entry ( e ) && <S2SV_StartBug> ! ( e -> ip . flags & IPT_F_GOTO ) ) <S2SV_EndBug> jumpstack [ stackidx ++ ] = e ; <S2SV_StartBug> e = get_entry ( table_base , v ) ; <S2SV_EndBug> continue ; } acpar . target = t -> u . kernel . target ; acpar . targinfo = t -> data ; verdict = t -> u . kernel . target -> target ( skb , & acpar ) ; if ( verdict == XT_CONTINUE ) { ip = ip_hdr ( skb ) ; e = ipt_next_entry ( e ) ; } else { break ; } } while ( ! acpar . hotdrop ) ; xt_write_recseq_end ( addend ) ; local_bh_enable ( ) ; if ( acpar . hotdrop ) return NF_DROP ; else return verdict ; }
CWE-476 unsigned int ip6t_do_table ( struct sk_buff * skb , const struct nf_hook_state * state , struct xt_table * table ) { unsigned int hook = state -> hook ; static const char nulldevname [ IFNAMSIZ ] __attribute__ ( ( aligned ( sizeof ( long ) ) ) ) ; unsigned int verdict = NF_DROP ; const char * indev , * outdev ; const void * table_base ; struct ip6t_entry * e , * * jumpstack ; unsigned int stackidx , cpu ; const struct xt_table_info * private ; struct xt_action_param acpar ; unsigned int addend ; stackidx = 0 ; indev = state -> in ? state -> in -> name : nulldevname ; outdev = state -> out ? state -> out -> name : nulldevname ; acpar . hotdrop = false ; acpar . state = state ; WARN_ON ( ! ( table -> valid_hooks & ( 1 << hook ) ) ) ; local_bh_disable ( ) ; addend = xt_write_recseq_begin ( ) ; private = READ_ONCE ( table -> private ) ; cpu = smp_processor_id ( ) ; table_base = private -> entries ; jumpstack = ( struct ip6t_entry * * ) private -> jumpstack [ cpu ] ; if ( static_key_false ( & xt_tee_enabled ) ) jumpstack += private -> stacksize * __this_cpu_read ( nf_skb_duplicated ) ; e = get_entry ( table_base , private -> hook_entry [ hook ] ) ; do { const struct xt_entry_target * t ; const struct xt_entry_match * ematch ; struct xt_counters * counter ; WARN_ON ( ! e ) ; acpar . thoff = 0 ; if ( ! ip6_packet_match ( skb , indev , outdev , & e -> ipv6 , & acpar . thoff , & acpar . fragoff , & acpar . hotdrop ) ) { no_match : e = ip6t_next_entry ( e ) ; continue ; } xt_ematch_foreach ( ematch , e ) { acpar . match = ematch -> u . kernel . match ; acpar . matchinfo = ematch -> data ; if ( ! acpar . match -> match ( skb , & acpar ) ) goto no_match ; } counter = xt_get_this_cpu_counter ( & e -> counters ) ; ADD_COUNTER ( * counter , skb -> len , 1 ) ; t = ip6t_get_target_c ( e ) ; WARN_ON ( ! t -> u . kernel . target ) ; # if IS_ENABLED ( CONFIG_NETFILTER_XT_TARGET_TRACE ) if ( unlikely ( skb -> nf_trace ) ) trace_packet ( state -> net , skb , hook , state -> in , state -> out , table -> name , private , e ) ; # endif if ( ! t -> u . kernel . target -> target ) { int v ; v = ( ( struct xt_standard_target * ) t ) -> verdict ; if ( v < 0 ) { if ( v != XT_RETURN ) { verdict = ( unsigned int ) ( - v ) - 1 ; break ; } if ( stackidx == 0 ) e = get_entry ( table_base , private -> underflow [ hook ] ) ; else e = ip6t_next_entry ( jumpstack [ -- stackidx ] ) ; continue ; } if ( table_base + v != ip6t_next_entry ( e ) && ! ( e -> ipv6 . flags & IP6T_F_GOTO ) ) { <S2SV_StartBug> jumpstack [ stackidx ++ ] = e ; <S2SV_EndBug> } e = get_entry ( table_base , v ) ; continue ; } acpar . target = t -> u . kernel . target ; acpar . targinfo = t -> data ; verdict = t -> u . kernel . target -> target ( skb , & acpar ) ; if ( verdict == XT_CONTINUE ) e = ip6t_next_entry ( e ) ; else break ; } while ( ! acpar . hotdrop ) ; xt_write_recseq_end ( addend ) ; local_bh_enable ( ) ; if ( acpar . hotdrop ) return NF_DROP ; else return verdict ; }
CWE-200 unsigned paravirt_patch_call ( void * insnbuf , const void * target , u16 tgt_clobbers , unsigned long addr , u16 site_clobbers , unsigned len ) { struct branch * b = insnbuf ; unsigned long delta = ( unsigned long ) target - ( addr + 5 ) ; <S2SV_StartBug> if ( tgt_clobbers & ~ site_clobbers ) <S2SV_EndBug> return len ; <S2SV_StartBug> if ( len < 5 ) <S2SV_EndBug> return len ; b -> opcode = 0xe8 ; b -> delta = delta ; BUILD_BUG_ON ( sizeof ( * b ) != 5 ) ; return 5 ; }
CWE-200 unsigned paravirt_patch_jmp ( void * insnbuf , const void * target , unsigned long addr , unsigned len ) { struct branch * b = insnbuf ; unsigned long delta = ( unsigned long ) target - ( addr + 5 ) ; <S2SV_StartBug> if ( len < 5 ) <S2SV_EndBug> <S2SV_StartBug> return len ; <S2SV_EndBug> b -> opcode = 0xe9 ; b -> delta = delta ; return 5 ; }
CWE-476 int nfc_llcp_send_cc ( struct nfc_llcp_sock * sock ) { struct nfc_llcp_local * local ; struct sk_buff * skb ; u8 * miux_tlv = NULL , miux_tlv_length ; u8 * rw_tlv = NULL , rw_tlv_length , rw ; int err ; u16 size = 0 ; __be16 miux ; pr_debug ( "Sending<S2SV_blank>CC\\n" ) ; local = sock -> local ; if ( local == NULL ) return - ENODEV ; miux = be16_to_cpu ( sock -> miux ) > LLCP_MAX_MIUX ? local -> miux : sock -> miux ; rw = sock -> rw > LLCP_MAX_RW ? local -> rw : sock -> rw ; miux_tlv = nfc_llcp_build_tlv ( LLCP_TLV_MIUX , ( u8 * ) & miux , 0 , & miux_tlv_length ) ; <S2SV_StartBug> size += miux_tlv_length ; <S2SV_EndBug> rw_tlv = nfc_llcp_build_tlv ( LLCP_TLV_RW , & rw , 0 , & rw_tlv_length ) ; <S2SV_StartBug> size += rw_tlv_length ; <S2SV_EndBug> skb = llcp_allocate_pdu ( sock , LLCP_PDU_CC , size ) ; if ( skb == NULL ) { err = - ENOMEM ; goto error_tlv ; } llcp_add_tlv ( skb , miux_tlv , miux_tlv_length ) ; llcp_add_tlv ( skb , rw_tlv , rw_tlv_length ) ; skb_queue_tail ( & local -> tx_queue , skb ) ; err = 0 ; error_tlv : if ( err ) pr_err ( "error<S2SV_blank>%d\\n" , err ) ; kfree ( miux_tlv ) ; kfree ( rw_tlv ) ; return err ; }
CWE-476 int nfc_llcp_send_connect ( struct nfc_llcp_sock * sock ) { struct nfc_llcp_local * local ; struct sk_buff * skb ; u8 * service_name_tlv = NULL , service_name_tlv_length ; u8 * miux_tlv = NULL , miux_tlv_length ; u8 * rw_tlv = NULL , rw_tlv_length , rw ; int err ; u16 size = 0 ; __be16 miux ; pr_debug ( "Sending<S2SV_blank>CONNECT\\n" ) ; local = sock -> local ; if ( local == NULL ) return - ENODEV ; if ( sock -> service_name != NULL ) { service_name_tlv = nfc_llcp_build_tlv ( LLCP_TLV_SN , sock -> service_name , sock -> service_name_len , & service_name_tlv_length ) ; <S2SV_StartBug> size += service_name_tlv_length ; <S2SV_EndBug> } miux = be16_to_cpu ( sock -> miux ) > LLCP_MAX_MIUX ? local -> miux : sock -> miux ; rw = sock -> rw > LLCP_MAX_RW ? local -> rw : sock -> rw ; miux_tlv = nfc_llcp_build_tlv ( LLCP_TLV_MIUX , ( u8 * ) & miux , 0 , & miux_tlv_length ) ; <S2SV_StartBug> size += miux_tlv_length ; <S2SV_EndBug> rw_tlv = nfc_llcp_build_tlv ( LLCP_TLV_RW , & rw , 0 , & rw_tlv_length ) ; <S2SV_StartBug> size += rw_tlv_length ; <S2SV_EndBug> pr_debug ( "SKB<S2SV_blank>size<S2SV_blank>%d<S2SV_blank>SN<S2SV_blank>length<S2SV_blank>%zu\\n" , size , sock -> service_name_len ) ; skb = llcp_allocate_pdu ( sock , LLCP_PDU_CONNECT , size ) ; if ( skb == NULL ) { err = - ENOMEM ; goto error_tlv ; } llcp_add_tlv ( skb , service_name_tlv , service_name_tlv_length ) ; llcp_add_tlv ( skb , miux_tlv , miux_tlv_length ) ; llcp_add_tlv ( skb , rw_tlv , rw_tlv_length ) ; skb_queue_tail ( & local -> tx_queue , skb ) ; err = 0 ; error_tlv : if ( err ) pr_err ( "error<S2SV_blank>%d\\n" , err ) ; kfree ( service_name_tlv ) ; kfree ( miux_tlv ) ; kfree ( rw_tlv ) ; return err ; }
CWE-476 static int nfc_llcp_build_gb ( struct nfc_llcp_local * local ) { <S2SV_StartBug> u8 * gb_cur , * version_tlv , version , version_length ; <S2SV_EndBug> u8 * lto_tlv , lto_length ; u8 * wks_tlv , wks_length ; u8 * miux_tlv , miux_length ; __be16 wks = cpu_to_be16 ( local -> local_wks ) ; u8 gb_len = 0 ; int ret = 0 ; version = LLCP_VERSION_11 ; version_tlv = nfc_llcp_build_tlv ( LLCP_TLV_VERSION , & version , 1 , & version_length ) ; <S2SV_StartBug> gb_len += version_length ; <S2SV_EndBug> lto_tlv = nfc_llcp_build_tlv ( LLCP_TLV_LTO , & local -> lto , 1 , & lto_length ) ; <S2SV_StartBug> gb_len += lto_length ; <S2SV_EndBug> pr_debug ( "Local<S2SV_blank>wks<S2SV_blank>0x%lx\\n" , local -> local_wks ) ; wks_tlv = nfc_llcp_build_tlv ( LLCP_TLV_WKS , ( u8 * ) & wks , 2 , & wks_length ) ; <S2SV_StartBug> gb_len += wks_length ; <S2SV_EndBug> miux_tlv = nfc_llcp_build_tlv ( LLCP_TLV_MIUX , ( u8 * ) & local -> miux , 0 , <S2SV_StartBug> & miux_length ) ; <S2SV_EndBug> gb_len += miux_length ; gb_len += ARRAY_SIZE ( llcp_magic ) ; if ( gb_len > NFC_MAX_GT_LEN ) { ret = - EINVAL ; goto out ; } gb_cur = local -> gb ; memcpy ( gb_cur , llcp_magic , ARRAY_SIZE ( llcp_magic ) ) ; gb_cur += ARRAY_SIZE ( llcp_magic ) ; memcpy ( gb_cur , version_tlv , version_length ) ; gb_cur += version_length ; memcpy ( gb_cur , lto_tlv , lto_length ) ; gb_cur += lto_length ; memcpy ( gb_cur , wks_tlv , wks_length ) ; gb_cur += wks_length ; memcpy ( gb_cur , miux_tlv , miux_length ) ; gb_cur += miux_length ; local -> gb_len = gb_len ; out : kfree ( version_tlv ) ; kfree ( lto_tlv ) ; kfree ( wks_tlv ) ; kfree ( miux_tlv ) ; return ret ; }
CWE-200 static int ext4_ext_grow_indepth ( handle_t * handle , struct inode * inode , unsigned int flags ) { struct ext4_extent_header * neh ; struct buffer_head * bh ; ext4_fsblk_t newblock , goal = 0 ; struct ext4_super_block * es = EXT4_SB ( inode -> i_sb ) -> s_es ; int err = 0 ; <S2SV_StartBug> if ( ext_depth ( inode ) ) <S2SV_EndBug> goal = ext4_idx_pblock ( EXT_FIRST_INDEX ( ext_inode_hdr ( inode ) ) ) ; if ( goal > le32_to_cpu ( es -> s_first_data_block ) ) { flags |= EXT4_MB_HINT_TRY_GOAL ; goal -- ; } else goal = ext4_inode_to_goal_block ( inode ) ; newblock = ext4_new_meta_blocks ( handle , inode , goal , flags , NULL , & err ) ; if ( newblock == 0 ) return err ; bh = sb_getblk_gfp ( inode -> i_sb , newblock , __GFP_MOVABLE | GFP_NOFS ) ; if ( unlikely ( ! bh ) ) return - ENOMEM ; lock_buffer ( bh ) ; err = ext4_journal_get_create_access ( handle , bh ) ; if ( err ) { unlock_buffer ( bh ) ; goto out ; } <S2SV_StartBug> memmove ( bh -> b_data , EXT4_I ( inode ) -> i_data , <S2SV_EndBug> <S2SV_StartBug> sizeof ( EXT4_I ( inode ) -> i_data ) ) ; <S2SV_EndBug> neh = ext_block_hdr ( bh ) ; if ( ext_depth ( inode ) ) neh -> eh_max = cpu_to_le16 ( ext4_ext_space_block_idx ( inode , 0 ) ) ; else neh -> eh_max = cpu_to_le16 ( ext4_ext_space_block ( inode , 0 ) ) ; neh -> eh_magic = EXT4_EXT_MAGIC ; ext4_extent_block_csum_set ( inode , neh ) ; set_buffer_uptodate ( bh ) ; unlock_buffer ( bh ) ; err = ext4_handle_dirty_metadata ( handle , inode , bh ) ; if ( err ) goto out ; neh = ext_inode_hdr ( inode ) ; neh -> eh_entries = cpu_to_le16 ( 1 ) ; ext4_idx_store_pblock ( EXT_FIRST_INDEX ( neh ) , newblock ) ; if ( neh -> eh_depth == 0 ) { neh -> eh_max = cpu_to_le16 ( ext4_ext_space_root_idx ( inode , 0 ) ) ; EXT_FIRST_INDEX ( neh ) -> ei_block = EXT_FIRST_EXTENT ( neh ) -> ee_block ; } ext_debug ( "new<S2SV_blank>root:<S2SV_blank>num<S2SV_blank>%d(%d),<S2SV_blank>lblock<S2SV_blank>%d,<S2SV_blank>ptr<S2SV_blank>%llu\\n" , le16_to_cpu ( neh -> eh_entries ) , le16_to_cpu ( neh -> eh_max ) , le32_to_cpu ( EXT_FIRST_INDEX ( neh ) -> ei_block ) , ext4_idx_pblock ( EXT_FIRST_INDEX ( neh ) ) ) ; le16_add_cpu ( & neh -> eh_depth , 1 ) ; ext4_mark_inode_dirty ( handle , inode ) ; out : brelse ( bh ) ; return err ; }
CWE-200 static int ext4_ext_split ( handle_t * handle , struct inode * inode , unsigned int flags , struct ext4_ext_path * path , struct ext4_extent * newext , int at ) { struct buffer_head * bh = NULL ; int depth = ext_depth ( inode ) ; struct ext4_extent_header * neh ; struct ext4_extent_idx * fidx ; int i = at , k , m , a ; ext4_fsblk_t newblock , oldblock ; __le32 border ; ext4_fsblk_t * ablocks = NULL ; int err = 0 ; <S2SV_StartBug> if ( unlikely ( path [ depth ] . p_ext > EXT_MAX_EXTENT ( path [ depth ] . p_hdr ) ) ) { <S2SV_EndBug> EXT4_ERROR_INODE ( inode , "p_ext<S2SV_blank>><S2SV_blank>EXT_MAX_EXTENT!" ) ; return - EFSCORRUPTED ; } if ( path [ depth ] . p_ext != EXT_MAX_EXTENT ( path [ depth ] . p_hdr ) ) { border = path [ depth ] . p_ext [ 1 ] . ee_block ; ext_debug ( "leaf<S2SV_blank>will<S2SV_blank>be<S2SV_blank>split." "<S2SV_blank>next<S2SV_blank>leaf<S2SV_blank>starts<S2SV_blank>at<S2SV_blank>%d\\n" , le32_to_cpu ( border ) ) ; } else { border = newext -> ee_block ; ext_debug ( "leaf<S2SV_blank>will<S2SV_blank>be<S2SV_blank>added." "<S2SV_blank>next<S2SV_blank>leaf<S2SV_blank>starts<S2SV_blank>at<S2SV_blank>%d\\n" , le32_to_cpu ( border ) ) ; } ablocks = kcalloc ( depth , sizeof ( ext4_fsblk_t ) , GFP_NOFS ) ; if ( ! ablocks ) return - ENOMEM ; ext_debug ( "allocate<S2SV_blank>%d<S2SV_blank>blocks<S2SV_blank>for<S2SV_blank>indexes/leaf\\n" , depth - at ) ; for ( a = 0 ; a < depth - at ; a ++ ) { newblock = ext4_ext_new_meta_block ( handle , inode , path , newext , & err , flags ) ; if ( newblock == 0 ) goto cleanup ; ablocks [ a ] = newblock ; } newblock = ablocks [ -- a ] ; if ( unlikely ( newblock == 0 ) ) { EXT4_ERROR_INODE ( inode , "newblock<S2SV_blank>==<S2SV_blank>0!" ) ; err = - EFSCORRUPTED ; goto cleanup ; } bh = sb_getblk_gfp ( inode -> i_sb , newblock , __GFP_MOVABLE | GFP_NOFS ) ; if ( unlikely ( ! bh ) ) { err = - ENOMEM ; goto cleanup ; } lock_buffer ( bh ) ; err = ext4_journal_get_create_access ( handle , bh ) ; if ( err ) goto cleanup ; neh = ext_block_hdr ( bh ) ; neh -> eh_entries = 0 ; neh -> eh_max = cpu_to_le16 ( ext4_ext_space_block ( inode , 0 ) ) ; neh -> eh_magic = EXT4_EXT_MAGIC ; neh -> eh_depth = 0 ; if ( unlikely ( path [ depth ] . p_hdr -> eh_entries != path [ depth ] . p_hdr -> eh_max ) ) { EXT4_ERROR_INODE ( inode , "eh_entries<S2SV_blank>%d<S2SV_blank>!=<S2SV_blank>eh_max<S2SV_blank>%d!" , path [ depth ] . p_hdr -> eh_entries , path [ depth ] . p_hdr -> eh_max ) ; err = - EFSCORRUPTED ; goto cleanup ; } m = EXT_MAX_EXTENT ( path [ depth ] . p_hdr ) - path [ depth ] . p_ext ++ ; ext4_ext_show_move ( inode , path , newblock , depth ) ; if ( m ) { struct ext4_extent * ex ; ex = EXT_FIRST_EXTENT ( neh ) ; memmove ( ex , path [ depth ] . p_ext , sizeof ( struct ext4_extent ) * m ) ; le16_add_cpu ( & neh -> eh_entries , m ) ; } <S2SV_StartBug> ext4_extent_block_csum_set ( inode , neh ) ; <S2SV_EndBug> set_buffer_uptodate ( bh ) ; unlock_buffer ( bh ) ; err = ext4_handle_dirty_metadata ( handle , inode , bh ) ; if ( err ) goto cleanup ; brelse ( bh ) ; bh = NULL ; if ( m ) { err = ext4_ext_get_access ( handle , inode , path + depth ) ; if ( err ) goto cleanup ; le16_add_cpu ( & path [ depth ] . p_hdr -> eh_entries , - m ) ; err = ext4_ext_dirty ( handle , inode , path + depth ) ; if ( err ) goto cleanup ; } k = depth - at - 1 ; if ( unlikely ( k < 0 ) ) { EXT4_ERROR_INODE ( inode , "k<S2SV_blank>%d<S2SV_blank><<S2SV_blank>0!" , k ) ; err = - EFSCORRUPTED ; goto cleanup ; } if ( k ) ext_debug ( "create<S2SV_blank>%d<S2SV_blank>intermediate<S2SV_blank>indices\\n" , k ) ; i = depth - 1 ; while ( k -- ) { oldblock = newblock ; newblock = ablocks [ -- a ] ; bh = sb_getblk ( inode -> i_sb , newblock ) ; if ( unlikely ( ! bh ) ) { err = - ENOMEM ; goto cleanup ; } lock_buffer ( bh ) ; err = ext4_journal_get_create_access ( handle , bh ) ; if ( err ) goto cleanup ; neh = ext_block_hdr ( bh ) ; neh -> eh_entries = cpu_to_le16 ( 1 ) ; neh -> eh_magic = EXT4_EXT_MAGIC ; neh -> eh_max = cpu_to_le16 ( ext4_ext_space_block_idx ( inode , 0 ) ) ; neh -> eh_depth = cpu_to_le16 ( depth - i ) ; fidx = EXT_FIRST_INDEX ( neh ) ; fidx -> ei_block = border ; ext4_idx_store_pblock ( fidx , oldblock ) ; ext_debug ( "int.index<S2SV_blank>at<S2SV_blank>%d<S2SV_blank>(block<S2SV_blank>%llu):<S2SV_blank>%u<S2SV_blank>-><S2SV_blank>%llu\\n" , i , newblock , le32_to_cpu ( border ) , oldblock ) ; if ( unlikely ( EXT_MAX_INDEX ( path [ i ] . p_hdr ) != EXT_LAST_INDEX ( path [ i ] . p_hdr ) ) ) { EXT4_ERROR_INODE ( inode , "EXT_MAX_INDEX<S2SV_blank>!=<S2SV_blank>EXT_LAST_INDEX<S2SV_blank>ee_block<S2SV_blank>%d!" , le32_to_cpu ( path [ i ] . p_ext -> ee_block ) ) ; err = - EFSCORRUPTED ; goto cleanup ; } m = EXT_MAX_INDEX ( path [ i ] . p_hdr ) - path [ i ] . p_idx ++ ; ext_debug ( "cur<S2SV_blank>0x%p,<S2SV_blank>last<S2SV_blank>0x%p\\n" , path [ i ] . p_idx , EXT_MAX_INDEX ( path [ i ] . p_hdr ) ) ; ext4_ext_show_move ( inode , path , newblock , i ) ; if ( m ) { memmove ( ++ fidx , path [ i ] . p_idx , sizeof ( struct ext4_extent_idx ) * m ) ; le16_add_cpu ( & neh -> eh_entries , m ) ; } <S2SV_StartBug> ext4_extent_block_csum_set ( inode , neh ) ; <S2SV_EndBug> set_buffer_uptodate ( bh ) ; unlock_buffer ( bh ) ; err = ext4_handle_dirty_metadata ( handle , inode , bh ) ; if ( err ) goto cleanup ; brelse ( bh ) ; bh = NULL ; if ( m ) { err = ext4_ext_get_access ( handle , inode , path + i ) ; if ( err ) goto cleanup ; le16_add_cpu ( & path [ i ] . p_hdr -> eh_entries , - m ) ; err = ext4_ext_dirty ( handle , inode , path + i ) ; if ( err ) goto cleanup ; } i -- ; } err = ext4_ext_insert_index ( handle , inode , path + at , le32_to_cpu ( border ) , newblock ) ; cleanup : if ( bh ) { if ( buffer_locked ( bh ) ) unlock_buffer ( bh ) ; brelse ( bh ) ; } if ( err ) { for ( i = 0 ; i < depth ; i ++ ) { if ( ! ablocks [ i ] ) continue ; ext4_free_blocks ( handle , inode , NULL , ablocks [ i ] , 1 , EXT4_FREE_BLOCKS_METADATA ) ; } } kfree ( ablocks ) ; return err ; }
CWE-476 static int tun_set_iff ( struct net * net , struct file * file , struct ifreq * ifr ) { struct tun_struct * tun ; struct tun_file * tfile = file -> private_data ; struct net_device * dev ; int err ; if ( tfile -> detached ) return - EINVAL ; dev = __dev_get_by_name ( net , ifr -> ifr_name ) ; if ( dev ) { if ( ifr -> ifr_flags & IFF_TUN_EXCL ) return - EBUSY ; if ( ( ifr -> ifr_flags & IFF_TUN ) && dev -> netdev_ops == & tun_netdev_ops ) tun = netdev_priv ( dev ) ; else if ( ( ifr -> ifr_flags & IFF_TAP ) && dev -> netdev_ops == & tap_netdev_ops ) tun = netdev_priv ( dev ) ; else return - EINVAL ; if ( ! ! ( ifr -> ifr_flags & IFF_MULTI_QUEUE ) != ! ! ( tun -> flags & IFF_MULTI_QUEUE ) ) return - EINVAL ; if ( tun_not_capable ( tun ) ) return - EPERM ; err = security_tun_dev_open ( tun -> security ) ; if ( err < 0 ) return err ; err = tun_attach ( tun , file , ifr -> ifr_flags & IFF_NOFILTER ) ; if ( err < 0 ) return err ; if ( tun -> flags & IFF_MULTI_QUEUE && ( tun -> numqueues + tun -> numdisabled > 1 ) ) { return 0 ; } } else { char * name ; unsigned long flags = 0 ; int queues = ifr -> ifr_flags & IFF_MULTI_QUEUE ? MAX_TAP_QUEUES : 1 ; if ( ! ns_capable ( net -> user_ns , CAP_NET_ADMIN ) ) return - EPERM ; err = security_tun_dev_create ( ) ; if ( err < 0 ) return err ; if ( ifr -> ifr_flags & IFF_TUN ) { flags |= IFF_TUN ; name = "tun%d" ; } else if ( ifr -> ifr_flags & IFF_TAP ) { flags |= IFF_TAP ; name = "tap%d" ; } else return - EINVAL ; if ( * ifr -> ifr_name ) name = ifr -> ifr_name ; dev = alloc_netdev_mqs ( sizeof ( struct tun_struct ) , name , NET_NAME_UNKNOWN , tun_setup , queues , queues ) ; if ( ! dev ) return - ENOMEM ; err = dev_get_valid_name ( net , dev , name ) ; <S2SV_StartBug> if ( err ) <S2SV_EndBug> goto err_free_dev ; dev_net_set ( dev , net ) ; dev -> rtnl_link_ops = & tun_link_ops ; dev -> ifindex = tfile -> ifindex ; dev -> sysfs_groups [ 0 ] = & tun_attr_group ; tun = netdev_priv ( dev ) ; tun -> dev = dev ; tun -> flags = flags ; tun -> txflt . count = 0 ; tun -> vnet_hdr_sz = sizeof ( struct virtio_net_hdr ) ; tun -> align = NET_SKB_PAD ; tun -> filter_attached = false ; tun -> sndbuf = tfile -> socket . sk -> sk_sndbuf ; tun -> rx_batched = 0 ; tun -> pcpu_stats = netdev_alloc_pcpu_stats ( struct tun_pcpu_stats ) ; if ( ! tun -> pcpu_stats ) { err = - ENOMEM ; goto err_free_dev ; } spin_lock_init ( & tun -> lock ) ; err = security_tun_dev_alloc_security ( & tun -> security ) ; if ( err < 0 ) goto err_free_stat ; tun_net_init ( dev ) ; tun_flow_init ( tun ) ; dev -> hw_features = NETIF_F_SG | NETIF_F_FRAGLIST | TUN_USER_FEATURES | NETIF_F_HW_VLAN_CTAG_TX | NETIF_F_HW_VLAN_STAG_TX ; dev -> features = dev -> hw_features | NETIF_F_LLTX ; dev -> vlan_features = dev -> features & ~ ( NETIF_F_HW_VLAN_CTAG_TX | NETIF_F_HW_VLAN_STAG_TX ) ; INIT_LIST_HEAD ( & tun -> disabled ) ; err = tun_attach ( tun , file , false ) ; if ( err < 0 ) goto err_free_flow ; err = register_netdevice ( tun -> dev ) ; if ( err < 0 ) goto err_detach ; } netif_carrier_on ( tun -> dev ) ; tun_debug ( KERN_INFO , tun , "tun_set_iff\\n" ) ; tun -> flags = ( tun -> flags & ~ TUN_FEATURES ) | ( ifr -> ifr_flags & TUN_FEATURES ) ; if ( netif_running ( tun -> dev ) ) netif_tx_wake_all_queues ( tun -> dev ) ; strcpy ( ifr -> ifr_name , tun -> dev -> name ) ; return 0 ; err_detach : tun_detach_all ( dev ) ; goto err_free_dev ; err_free_flow : tun_flow_uninit ( tun ) ; security_tun_dev_free_security ( tun -> security ) ; err_free_stat : free_percpu ( tun -> pcpu_stats ) ; err_free_dev : free_netdev ( dev ) ; return err ; }
CWE-416 static int usb_audio_probe ( struct usb_interface * intf , const struct usb_device_id * usb_id ) { struct usb_device * dev = interface_to_usbdev ( intf ) ; const struct snd_usb_audio_quirk * quirk = ( const struct snd_usb_audio_quirk * ) usb_id -> driver_info ; struct snd_usb_audio * chip ; int i , err ; struct usb_host_interface * alts ; int ifnum ; u32 id ; alts = & intf -> altsetting [ 0 ] ; ifnum = get_iface_desc ( alts ) -> bInterfaceNumber ; id = USB_ID ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( get_alias_id ( dev , & id ) ) quirk = get_alias_quirk ( dev , id ) ; if ( quirk && quirk -> ifnum >= 0 && ifnum != quirk -> ifnum ) return - ENXIO ; err = snd_usb_apply_boot_quirk ( dev , intf , quirk , id ) ; if ( err < 0 ) return err ; chip = NULL ; mutex_lock ( & register_mutex ) ; for ( i = 0 ; i < SNDRV_CARDS ; i ++ ) { if ( usb_chip [ i ] && usb_chip [ i ] -> dev == dev ) { if ( atomic_read ( & usb_chip [ i ] -> shutdown ) ) { dev_err ( & dev -> dev , "USB<S2SV_blank>device<S2SV_blank>is<S2SV_blank>in<S2SV_blank>the<S2SV_blank>shutdown<S2SV_blank>state,<S2SV_blank>cannot<S2SV_blank>create<S2SV_blank>a<S2SV_blank>card<S2SV_blank>instance\\n" ) ; err = - EIO ; goto __error ; } chip = usb_chip [ i ] ; atomic_inc ( & chip -> active ) ; break ; } } if ( ! chip ) { for ( i = 0 ; i < SNDRV_CARDS ; i ++ ) if ( ! usb_chip [ i ] && ( vid [ i ] == - 1 || vid [ i ] == USB_ID_VENDOR ( id ) ) && ( pid [ i ] == - 1 || pid [ i ] == USB_ID_PRODUCT ( id ) ) ) { if ( enable [ i ] ) { err = snd_usb_audio_create ( intf , dev , i , quirk , id , & chip ) ; if ( err < 0 ) goto __error ; chip -> pm_intf = intf ; break ; } else if ( vid [ i ] != - 1 || pid [ i ] != - 1 ) { dev_info ( & dev -> dev , "device<S2SV_blank>(%04x:%04x)<S2SV_blank>is<S2SV_blank>disabled\\n" , USB_ID_VENDOR ( id ) , USB_ID_PRODUCT ( id ) ) ; err = - ENOENT ; goto __error ; } } if ( ! chip ) { dev_err ( & dev -> dev , "no<S2SV_blank>available<S2SV_blank>usb<S2SV_blank>audio<S2SV_blank>device\\n" ) ; err = - ENODEV ; goto __error ; } } dev_set_drvdata ( & dev -> dev , chip ) ; if ( ! chip -> ctrl_intf ) chip -> ctrl_intf = alts ; chip -> txfr_quirk = 0 ; err = 1 ; if ( quirk && quirk -> ifnum != QUIRK_NO_INTERFACE ) { err = snd_usb_create_quirk ( chip , intf , & usb_audio_driver , quirk ) ; if ( err < 0 ) goto __error ; } if ( err > 0 ) { err = snd_usb_create_streams ( chip , ifnum ) ; if ( err < 0 ) goto __error ; err = snd_usb_create_mixer ( chip , ifnum , ignore_ctl_error ) ; if ( err < 0 ) goto __error ; } err = snd_card_register ( chip -> card ) ; if ( err < 0 ) goto __error ; usb_chip [ chip -> index ] = chip ; chip -> num_interfaces ++ ; usb_set_intfdata ( intf , chip ) ; atomic_dec ( & chip -> active ) ; mutex_unlock ( & register_mutex ) ; return 0 ; __error : if ( chip ) { <S2SV_StartBug> if ( ! chip -> num_interfaces ) <S2SV_EndBug> snd_card_free ( chip -> card ) ; <S2SV_StartBug> atomic_dec ( & chip -> active ) ; <S2SV_EndBug> } mutex_unlock ( & register_mutex ) ; return err ; }
CWE-20 int f2fs_trim_fs ( struct f2fs_sb_info * sbi , struct fstrim_range * range ) { __u64 start = F2FS_BYTES_TO_BLK ( range -> start ) ; __u64 end = start + F2FS_BYTES_TO_BLK ( range -> len ) - 1 ; unsigned int start_segno , end_segno ; struct cp_control cpc ; int err = 0 ; if ( start >= MAX_BLKADDR ( sbi ) || range -> len < sbi -> blocksize ) return - EINVAL ; cpc . trimmed = 0 ; if ( end <= MAIN_BLKADDR ( sbi ) ) goto out ; if ( is_sbi_flag_set ( sbi , SBI_NEED_FSCK ) ) { f2fs_msg ( sbi -> sb , KERN_WARNING , "Found<S2SV_blank>FS<S2SV_blank>corruption,<S2SV_blank>run<S2SV_blank>fsck<S2SV_blank>to<S2SV_blank>fix." ) ; goto out ; } start_segno = ( start <= MAIN_BLKADDR ( sbi ) ) ? 0 : GET_SEGNO ( sbi , start ) ; end_segno = ( end >= MAX_BLKADDR ( sbi ) ) ? MAIN_SEGS ( sbi ) - 1 : GET_SEGNO ( sbi , end ) ; cpc . reason = CP_DISCARD ; cpc . trim_minlen = max_t ( __u64 , 1 , F2FS_BYTES_TO_BLK ( range -> minlen ) ) ; for ( ; start_segno <= end_segno ; start_segno = cpc . trim_end + 1 ) { cpc . trim_start = start_segno ; if ( sbi -> discard_blks == 0 ) break ; else if ( sbi -> discard_blks < BATCHED_TRIM_BLOCKS ( sbi ) ) cpc . trim_end = end_segno ; else cpc . trim_end = min_t ( unsigned int , rounddown ( start_segno + BATCHED_TRIM_SEGMENTS ( sbi ) , sbi -> segs_per_sec ) - 1 , end_segno ) ; mutex_lock ( & sbi -> gc_mutex ) ; err = write_checkpoint ( sbi , & cpc ) ; mutex_unlock ( & sbi -> gc_mutex ) ; if ( err ) break ; schedule ( ) ; } mark_discard_range_all ( sbi ) ; <S2SV_StartBug> f2fs_wait_discard_bios ( sbi ) ; <S2SV_EndBug> out : range -> len = F2FS_BLK_TO_BYTES ( cpc . trimmed ) ; return err ; }
CWE-20 <S2SV_StartBug> void f2fs_wait_discard_bios ( struct f2fs_sb_info * sbi ) <S2SV_EndBug> { __issue_discard_cmd ( sbi , false ) ; __drop_discard_cmd ( sbi ) ; <S2SV_StartBug> __wait_discard_cmd ( sbi , false ) ; <S2SV_EndBug> }
CWE-20 static void f2fs_put_super ( struct super_block * sb ) { struct f2fs_sb_info * sbi = F2FS_SB ( sb ) ; int i ; f2fs_quota_off_umount ( sb ) ; mutex_lock ( & sbi -> umount_mutex ) ; if ( is_sbi_flag_set ( sbi , SBI_IS_DIRTY ) || ! is_set_ckpt_flags ( sbi , CP_UMOUNT_FLAG ) ) { struct cp_control cpc = { . reason = CP_UMOUNT , } ; write_checkpoint ( sbi , & cpc ) ; } <S2SV_StartBug> f2fs_wait_discard_bios ( sbi ) ; <S2SV_EndBug> if ( f2fs_discard_en ( sbi ) && ! sbi -> discard_blks ) { struct cp_control cpc = { . reason = CP_UMOUNT | CP_TRIMMED , } ; write_checkpoint ( sbi , & cpc ) ; } f2fs_destroy_stats ( sbi ) ; release_ino_entry ( sbi , true ) ; f2fs_leave_shrinker ( sbi ) ; mutex_unlock ( & sbi -> umount_mutex ) ; f2fs_flush_merged_writes ( sbi ) ; iput ( sbi -> node_inode ) ; iput ( sbi -> meta_inode ) ; destroy_node_manager ( sbi ) ; destroy_segment_manager ( sbi ) ; kfree ( sbi -> ckpt ) ; f2fs_unregister_sysfs ( sbi ) ; sb -> s_fs_info = NULL ; if ( sbi -> s_chksum_driver ) crypto_free_shash ( sbi -> s_chksum_driver ) ; kfree ( sbi -> raw_super ) ; destroy_device_list ( sbi ) ; mempool_destroy ( sbi -> write_io_dummy ) ; # ifdef CONFIG_QUOTA for ( i = 0 ; i < MAXQUOTAS ; i ++ ) kfree ( sbi -> s_qf_names [ i ] ) ; # endif destroy_percpu_info ( sbi ) ; for ( i = 0 ; i < NR_PAGE_TYPE ; i ++ ) kfree ( sbi -> write_io [ i ] ) ; kfree ( sbi ) ; }
CWE-264 static void ptrace_link ( struct task_struct * child , struct task_struct * new_parent ) { <S2SV_StartBug> rcu_read_lock ( ) ; <S2SV_EndBug> <S2SV_StartBug> __ptrace_link ( child , new_parent , __task_cred ( new_parent ) ) ; <S2SV_EndBug> rcu_read_unlock ( ) ; }
CWE-416 int SMB2_write ( const unsigned int xid , struct cifs_io_parms * io_parms , unsigned int * nbytes , struct kvec * iov , int n_vec ) { struct smb_rqst rqst ; int rc = 0 ; struct smb2_write_req * req = NULL ; struct smb2_write_rsp * rsp = NULL ; int resp_buftype ; struct kvec rsp_iov ; int flags = 0 ; unsigned int total_len ; * nbytes = 0 ; if ( n_vec < 1 ) return rc ; rc = smb2_plain_req_init ( SMB2_WRITE , io_parms -> tcon , ( void * * ) & req , & total_len ) ; if ( rc ) return rc ; if ( io_parms -> tcon -> ses -> server == NULL ) return - ECONNABORTED ; if ( smb3_encryption_required ( io_parms -> tcon ) ) flags |= CIFS_TRANSFORM_REQ ; req -> sync_hdr . ProcessId = cpu_to_le32 ( io_parms -> pid ) ; req -> PersistentFileId = io_parms -> persistent_fid ; req -> VolatileFileId = io_parms -> volatile_fid ; req -> WriteChannelInfoOffset = 0 ; req -> WriteChannelInfoLength = 0 ; req -> Channel = 0 ; req -> Length = cpu_to_le32 ( io_parms -> length ) ; req -> Offset = cpu_to_le64 ( io_parms -> offset ) ; req -> DataOffset = cpu_to_le16 ( offsetof ( struct smb2_write_req , Buffer ) ) ; req -> RemainingBytes = 0 ; trace_smb3_write_enter ( xid , io_parms -> persistent_fid , io_parms -> tcon -> tid , io_parms -> tcon -> ses -> Suid , io_parms -> offset , io_parms -> length ) ; iov [ 0 ] . iov_base = ( char * ) req ; iov [ 0 ] . iov_len = total_len - 1 ; memset ( & rqst , 0 , sizeof ( struct smb_rqst ) ) ; rqst . rq_iov = iov ; rqst . rq_nvec = n_vec + 1 ; rc = cifs_send_recv ( xid , io_parms -> tcon -> ses , & rqst , & resp_buftype , flags , & rsp_iov ) ; <S2SV_StartBug> cifs_small_buf_release ( req ) ; <S2SV_EndBug> rsp = ( struct smb2_write_rsp * ) rsp_iov . iov_base ; if ( rc ) { trace_smb3_write_err ( xid , req -> PersistentFileId , io_parms -> tcon -> tid , io_parms -> tcon -> ses -> Suid , io_parms -> offset , io_parms -> length , rc ) ; cifs_stats_fail_inc ( io_parms -> tcon , SMB2_WRITE_HE ) ; cifs_dbg ( VFS , "Send<S2SV_blank>error<S2SV_blank>in<S2SV_blank>write<S2SV_blank>=<S2SV_blank>%d\\n" , rc ) ; } else { * nbytes = le32_to_cpu ( rsp -> DataLength ) ; trace_smb3_write_done ( xid , req -> PersistentFileId , io_parms -> tcon -> tid , io_parms -> tcon -> ses -> Suid , io_parms -> offset , * nbytes ) ; } <S2SV_StartBug> free_rsp_buf ( resp_buftype , rsp ) ; <S2SV_EndBug> return rc ; }
CWE-125 static int serdes_probe ( struct platform_device * pdev ) { struct phy_provider * provider ; struct serdes_ctrl * ctrl ; unsigned int i ; int ret ; ctrl = devm_kzalloc ( & pdev -> dev , sizeof ( * ctrl ) , GFP_KERNEL ) ; if ( ! ctrl ) return - ENOMEM ; ctrl -> dev = & pdev -> dev ; ctrl -> regs = syscon_node_to_regmap ( pdev -> dev . parent -> of_node ) ; if ( IS_ERR ( ctrl -> regs ) ) return PTR_ERR ( ctrl -> regs ) ; <S2SV_StartBug> for ( i = 0 ; i <= SERDES_MAX ; i ++ ) { <S2SV_EndBug> ret = serdes_phy_create ( ctrl , i , & ctrl -> phys [ i ] ) ; if ( ret ) return ret ; } dev_set_drvdata ( & pdev -> dev , ctrl ) ; provider = devm_of_phy_provider_register ( ctrl -> dev , serdes_simple_xlate ) ; return PTR_ERR_OR_ZERO ( provider ) ; }
CWE-125 static struct phy * serdes_simple_xlate ( struct device * dev , struct of_phandle_args * args ) { struct serdes_ctrl * ctrl = dev_get_drvdata ( dev ) ; unsigned int port , idx , i ; if ( args -> args_count != 2 ) return ERR_PTR ( - EINVAL ) ; port = args -> args [ 0 ] ; idx = args -> args [ 1 ] ; <S2SV_StartBug> for ( i = 0 ; i <= SERDES_MAX ; i ++ ) { <S2SV_EndBug> struct serdes_macro * macro = phy_get_drvdata ( ctrl -> phys [ i ] ) ; if ( idx != macro -> idx ) continue ; if ( idx != SERDES6G ( 0 ) && macro -> port >= 0 ) return ERR_PTR ( - EBUSY ) ; macro -> port = port ; return ctrl -> phys [ i ] ; } return ERR_PTR ( - ENODEV ) ; }
CWE-369 static void change_port_settings ( struct tty_struct * tty , struct edgeport_port * edge_port , struct ktermios * old_termios ) { struct device * dev = & edge_port -> port -> dev ; struct ump_uart_config * config ; int baud ; unsigned cflag ; int status ; int port_number = edge_port -> port -> port_number ; config = kmalloc ( sizeof ( * config ) , GFP_KERNEL ) ; if ( ! config ) { tty -> termios = * old_termios ; return ; } cflag = tty -> termios . c_cflag ; config -> wFlags = 0 ; config -> wFlags |= UMP_MASK_UART_FLAGS_RECEIVE_MS_INT ; config -> wFlags |= UMP_MASK_UART_FLAGS_AUTO_START_ON_ERR ; config -> bUartMode = ( __u8 ) ( edge_port -> bUartMode ) ; switch ( cflag & CSIZE ) { case CS5 : config -> bDataBits = UMP_UART_CHAR5BITS ; dev_dbg ( dev , "%s<S2SV_blank>-<S2SV_blank>data<S2SV_blank>bits<S2SV_blank>=<S2SV_blank>5\\n" , __func__ ) ; break ; case CS6 : config -> bDataBits = UMP_UART_CHAR6BITS ; dev_dbg ( dev , "%s<S2SV_blank>-<S2SV_blank>data<S2SV_blank>bits<S2SV_blank>=<S2SV_blank>6\\n" , __func__ ) ; break ; case CS7 : config -> bDataBits = UMP_UART_CHAR7BITS ; dev_dbg ( dev , "%s<S2SV_blank>-<S2SV_blank>data<S2SV_blank>bits<S2SV_blank>=<S2SV_blank>7\\n" , __func__ ) ; break ; default : case CS8 : config -> bDataBits = UMP_UART_CHAR8BITS ; dev_dbg ( dev , "%s<S2SV_blank>-<S2SV_blank>data<S2SV_blank>bits<S2SV_blank>=<S2SV_blank>8\\n" , __func__ ) ; break ; } if ( cflag & PARENB ) { if ( cflag & PARODD ) { config -> wFlags |= UMP_MASK_UART_FLAGS_PARITY ; config -> bParity = UMP_UART_ODDPARITY ; dev_dbg ( dev , "%s<S2SV_blank>-<S2SV_blank>parity<S2SV_blank>=<S2SV_blank>odd\\n" , __func__ ) ; } else { config -> wFlags |= UMP_MASK_UART_FLAGS_PARITY ; config -> bParity = UMP_UART_EVENPARITY ; dev_dbg ( dev , "%s<S2SV_blank>-<S2SV_blank>parity<S2SV_blank>=<S2SV_blank>even\\n" , __func__ ) ; } } else { config -> bParity = UMP_UART_NOPARITY ; dev_dbg ( dev , "%s<S2SV_blank>-<S2SV_blank>parity<S2SV_blank>=<S2SV_blank>none\\n" , __func__ ) ; } if ( cflag & CSTOPB ) { config -> bStopBits = UMP_UART_STOPBIT2 ; dev_dbg ( dev , "%s<S2SV_blank>-<S2SV_blank>stop<S2SV_blank>bits<S2SV_blank>=<S2SV_blank>2\\n" , __func__ ) ; } else { config -> bStopBits = UMP_UART_STOPBIT1 ; dev_dbg ( dev , "%s<S2SV_blank>-<S2SV_blank>stop<S2SV_blank>bits<S2SV_blank>=<S2SV_blank>1\\n" , __func__ ) ; } if ( cflag & CRTSCTS ) { config -> wFlags |= UMP_MASK_UART_FLAGS_OUT_X_CTS_FLOW ; config -> wFlags |= UMP_MASK_UART_FLAGS_RTS_FLOW ; dev_dbg ( dev , "%s<S2SV_blank>-<S2SV_blank>RTS/CTS<S2SV_blank>is<S2SV_blank>enabled\\n" , __func__ ) ; } else { dev_dbg ( dev , "%s<S2SV_blank>-<S2SV_blank>RTS/CTS<S2SV_blank>is<S2SV_blank>disabled\\n" , __func__ ) ; restart_read ( edge_port ) ; } config -> cXon = START_CHAR ( tty ) ; config -> cXoff = STOP_CHAR ( tty ) ; if ( I_IXOFF ( tty ) ) { config -> wFlags |= UMP_MASK_UART_FLAGS_IN_X ; dev_dbg ( dev , "%s<S2SV_blank>-<S2SV_blank>INBOUND<S2SV_blank>XON/XOFF<S2SV_blank>is<S2SV_blank>enabled,<S2SV_blank>XON<S2SV_blank>=<S2SV_blank>%2x,<S2SV_blank>XOFF<S2SV_blank>=<S2SV_blank>%2x\\n" , __func__ , config -> cXon , config -> cXoff ) ; } else dev_dbg ( dev , "%s<S2SV_blank>-<S2SV_blank>INBOUND<S2SV_blank>XON/XOFF<S2SV_blank>is<S2SV_blank>disabled\\n" , __func__ ) ; if ( I_IXON ( tty ) ) { config -> wFlags |= UMP_MASK_UART_FLAGS_OUT_X ; dev_dbg ( dev , "%s<S2SV_blank>-<S2SV_blank>OUTBOUND<S2SV_blank>XON/XOFF<S2SV_blank>is<S2SV_blank>enabled,<S2SV_blank>XON<S2SV_blank>=<S2SV_blank>%2x,<S2SV_blank>XOFF<S2SV_blank>=<S2SV_blank>%2x\\n" , __func__ , config -> cXon , config -> cXoff ) ; } else dev_dbg ( dev , "%s<S2SV_blank>-<S2SV_blank>OUTBOUND<S2SV_blank>XON/XOFF<S2SV_blank>is<S2SV_blank>disabled\\n" , __func__ ) ; tty -> termios . c_cflag &= ~ CMSPAR ; baud = tty_get_baud_rate ( tty ) ; if ( ! baud ) { baud = 9600 ; <S2SV_StartBug> } else <S2SV_EndBug> <S2SV_StartBug> tty_encode_baud_rate ( tty , baud , baud ) ; <S2SV_EndBug> edge_port -> baud_rate = baud ; config -> wBaudRate = ( __u16 ) ( ( 461550L + baud / 2 ) / baud ) ; dev_dbg ( dev , "%s<S2SV_blank>-<S2SV_blank>baud<S2SV_blank>rate<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>wBaudRate<S2SV_blank>=<S2SV_blank>%d\\n" , __func__ , baud , config -> wBaudRate ) ; dev_dbg ( dev , "wBaudRate:<S2SV_blank><S2SV_blank><S2SV_blank>%d\\n" , ( int ) ( 461550L / config -> wBaudRate ) ) ; dev_dbg ( dev , "wFlags:<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x%x\\n" , config -> wFlags ) ; dev_dbg ( dev , "bDataBits:<S2SV_blank><S2SV_blank><S2SV_blank>%d\\n" , config -> bDataBits ) ; dev_dbg ( dev , "bParity:<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%d\\n" , config -> bParity ) ; dev_dbg ( dev , "bStopBits:<S2SV_blank><S2SV_blank><S2SV_blank>%d\\n" , config -> bStopBits ) ; dev_dbg ( dev , "cXon:<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%d\\n" , config -> cXon ) ; dev_dbg ( dev , "cXoff:<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%d\\n" , config -> cXoff ) ; dev_dbg ( dev , "bUartMode:<S2SV_blank><S2SV_blank><S2SV_blank>%d\\n" , config -> bUartMode ) ; cpu_to_be16s ( & config -> wFlags ) ; cpu_to_be16s ( & config -> wBaudRate ) ; status = send_cmd ( edge_port -> port -> serial -> dev , UMPC_SET_CONFIG , ( __u8 ) ( UMPM_UART1_PORT + port_number ) , 0 , ( __u8 * ) config , sizeof ( * config ) ) ; if ( status ) dev_dbg ( dev , "%s<S2SV_blank>-<S2SV_blank>error<S2SV_blank>%d<S2SV_blank>when<S2SV_blank>trying<S2SV_blank>to<S2SV_blank>write<S2SV_blank>config<S2SV_blank>to<S2SV_blank>device\\n" , __func__ , status ) ; kfree ( config ) ; }
CWE-416 <S2SV_StartBug> void generic_pipe_buf_get ( struct pipe_inode_info * pipe , struct pipe_buffer * buf ) <S2SV_EndBug> { <S2SV_StartBug> get_page ( buf -> page ) ; <S2SV_EndBug> }
CWE-416 static int link_pipe ( struct pipe_inode_info * ipipe , struct pipe_inode_info * opipe , size_t len , unsigned int flags ) { struct pipe_buffer * ibuf , * obuf ; int ret = 0 , i = 0 , nbuf ; pipe_double_lock ( ipipe , opipe ) ; do { if ( ! opipe -> readers ) { send_sig ( SIGPIPE , current , 0 ) ; if ( ! ret ) ret = - EPIPE ; break ; } if ( i >= ipipe -> nrbufs || opipe -> nrbufs >= opipe -> buffers ) break ; ibuf = ipipe -> bufs + ( ( ipipe -> curbuf + i ) & ( ipipe -> buffers - 1 ) ) ; nbuf = ( opipe -> curbuf + opipe -> nrbufs ) & ( opipe -> buffers - 1 ) ; <S2SV_StartBug> pipe_buf_get ( ipipe , ibuf ) ; <S2SV_EndBug> obuf = opipe -> bufs + nbuf ; * obuf = * ibuf ; obuf -> flags &= ~ PIPE_BUF_FLAG_GIFT ; pipe_buf_mark_unmergeable ( obuf ) ; if ( obuf -> len > len ) obuf -> len = len ; opipe -> nrbufs ++ ; ret += obuf -> len ; len -= obuf -> len ; i ++ ; } while ( len ) ; if ( ! ret && ipipe -> waiting_writers && ( flags & SPLICE_F_NONBLOCK ) ) ret = - EAGAIN ; pipe_unlock ( ipipe ) ; pipe_unlock ( opipe ) ; if ( ret > 0 ) wakeup_pipe_readers ( opipe ) ; return ret ; }
CWE-416 static int splice_pipe_to_pipe ( struct pipe_inode_info * ipipe , struct pipe_inode_info * opipe , size_t len , unsigned int flags ) { struct pipe_buffer * ibuf , * obuf ; int ret = 0 , nbuf ; bool input_wakeup = false ; retry : ret = ipipe_prep ( ipipe , flags ) ; if ( ret ) return ret ; ret = opipe_prep ( opipe , flags ) ; if ( ret ) return ret ; pipe_double_lock ( ipipe , opipe ) ; do { if ( ! opipe -> readers ) { send_sig ( SIGPIPE , current , 0 ) ; if ( ! ret ) ret = - EPIPE ; break ; } if ( ! ipipe -> nrbufs && ! ipipe -> writers ) break ; if ( ! ipipe -> nrbufs || opipe -> nrbufs >= opipe -> buffers ) { if ( ret ) break ; if ( flags & SPLICE_F_NONBLOCK ) { ret = - EAGAIN ; break ; } pipe_unlock ( ipipe ) ; pipe_unlock ( opipe ) ; goto retry ; } ibuf = ipipe -> bufs + ipipe -> curbuf ; nbuf = ( opipe -> curbuf + opipe -> nrbufs ) & ( opipe -> buffers - 1 ) ; obuf = opipe -> bufs + nbuf ; if ( len >= ibuf -> len ) { * obuf = * ibuf ; ibuf -> ops = NULL ; opipe -> nrbufs ++ ; ipipe -> curbuf = ( ipipe -> curbuf + 1 ) & ( ipipe -> buffers - 1 ) ; ipipe -> nrbufs -- ; input_wakeup = true ; } else { <S2SV_StartBug> pipe_buf_get ( ipipe , ibuf ) ; <S2SV_EndBug> * obuf = * ibuf ; obuf -> flags &= ~ PIPE_BUF_FLAG_GIFT ; pipe_buf_mark_unmergeable ( obuf ) ; obuf -> len = len ; opipe -> nrbufs ++ ; ibuf -> offset += obuf -> len ; ibuf -> len -= obuf -> len ; } ret += obuf -> len ; len -= obuf -> len ; } while ( len ) ; pipe_unlock ( ipipe ) ; pipe_unlock ( opipe ) ; if ( ret > 0 ) wakeup_pipe_readers ( opipe ) ; if ( input_wakeup ) wakeup_pipe_writers ( ipipe ) ; return ret ; }
CWE-416 <S2SV_StartBug> static void buffer_pipe_buf_get ( struct pipe_inode_info * pipe , <S2SV_EndBug> struct pipe_buffer * buf ) { struct buffer_ref * ref = ( struct buffer_ref * ) buf -> private ; <S2SV_StartBug> ref -> ref ++ ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>
CWE-416 static struct page * follow_page_pte ( struct vm_area_struct * vma , unsigned long address , pmd_t * pmd , unsigned int flags , struct dev_pagemap * * pgmap ) { struct mm_struct * mm = vma -> vm_mm ; struct page * page ; spinlock_t * ptl ; pte_t * ptep , pte ; retry : if ( unlikely ( pmd_bad ( * pmd ) ) ) return no_page_table ( vma , flags ) ; ptep = pte_offset_map_lock ( mm , pmd , address , & ptl ) ; pte = * ptep ; if ( ! pte_present ( pte ) ) { swp_entry_t entry ; if ( likely ( ! ( flags & FOLL_MIGRATION ) ) ) goto no_page ; if ( pte_none ( pte ) ) goto no_page ; entry = pte_to_swp_entry ( pte ) ; if ( ! is_migration_entry ( entry ) ) goto no_page ; pte_unmap_unlock ( ptep , ptl ) ; migration_entry_wait ( mm , pmd , address ) ; goto retry ; } if ( ( flags & FOLL_NUMA ) && pte_protnone ( pte ) ) goto no_page ; if ( ( flags & FOLL_WRITE ) && ! can_follow_write_pte ( pte , flags ) ) { pte_unmap_unlock ( ptep , ptl ) ; return NULL ; } page = vm_normal_page ( vma , address , pte ) ; if ( ! page && pte_devmap ( pte ) && ( flags & FOLL_GET ) ) { * pgmap = get_dev_pagemap ( pte_pfn ( pte ) , * pgmap ) ; if ( * pgmap ) page = pte_page ( pte ) ; else goto no_page ; } else if ( unlikely ( ! page ) ) { if ( flags & FOLL_DUMP ) { page = ERR_PTR ( - EFAULT ) ; goto out ; } if ( is_zero_pfn ( pte_pfn ( pte ) ) ) { page = pte_page ( pte ) ; } else { int ret ; ret = follow_pfn_pte ( vma , address , ptep , flags ) ; page = ERR_PTR ( ret ) ; goto out ; } } if ( flags & FOLL_SPLIT && PageTransCompound ( page ) ) { int ret ; get_page ( page ) ; pte_unmap_unlock ( ptep , ptl ) ; lock_page ( page ) ; ret = split_huge_page ( page ) ; unlock_page ( page ) ; put_page ( page ) ; if ( ret ) return ERR_PTR ( ret ) ; goto retry ; } if ( flags & FOLL_GET ) <S2SV_StartBug> get_page ( page ) ; <S2SV_EndBug> if ( flags & FOLL_TOUCH ) { if ( ( flags & FOLL_WRITE ) && ! pte_dirty ( pte ) && ! PageDirty ( page ) ) set_page_dirty ( page ) ; mark_page_accessed ( page ) ; } if ( ( flags & FOLL_MLOCK ) && ( vma -> vm_flags & VM_LOCKED ) ) { if ( PageTransCompound ( page ) ) goto out ; if ( page -> mapping && trylock_page ( page ) ) { lru_add_drain ( ) ; mlock_vma_page ( page ) ; unlock_page ( page ) ; } } out : pte_unmap_unlock ( ptep , ptl ) ; return page ; no_page : pte_unmap_unlock ( ptep , ptl ) ; if ( ! pte_none ( pte ) ) return NULL ; return no_page_table ( vma , flags ) ; }
CWE-416 static struct page * follow_pmd_mask ( struct vm_area_struct * vma , unsigned long address , pud_t * pudp , unsigned int flags , struct follow_page_context * ctx ) { pmd_t * pmd , pmdval ; spinlock_t * ptl ; struct page * page ; struct mm_struct * mm = vma -> vm_mm ; pmd = pmd_offset ( pudp , address ) ; pmdval = READ_ONCE ( * pmd ) ; if ( pmd_none ( pmdval ) ) return no_page_table ( vma , flags ) ; if ( pmd_huge ( pmdval ) && vma -> vm_flags & VM_HUGETLB ) { page = follow_huge_pmd ( mm , address , pmd , flags ) ; if ( page ) return page ; return no_page_table ( vma , flags ) ; } if ( is_hugepd ( __hugepd ( pmd_val ( pmdval ) ) ) ) { page = follow_huge_pd ( vma , address , __hugepd ( pmd_val ( pmdval ) ) , flags , PMD_SHIFT ) ; if ( page ) return page ; return no_page_table ( vma , flags ) ; } retry : if ( ! pmd_present ( pmdval ) ) { if ( likely ( ! ( flags & FOLL_MIGRATION ) ) ) return no_page_table ( vma , flags ) ; VM_BUG_ON ( thp_migration_supported ( ) && ! is_pmd_migration_entry ( pmdval ) ) ; if ( is_pmd_migration_entry ( pmdval ) ) pmd_migration_entry_wait ( mm , pmd ) ; pmdval = READ_ONCE ( * pmd ) ; if ( pmd_none ( pmdval ) ) return no_page_table ( vma , flags ) ; goto retry ; } if ( pmd_devmap ( pmdval ) ) { ptl = pmd_lock ( mm , pmd ) ; page = follow_devmap_pmd ( vma , address , pmd , flags , & ctx -> pgmap ) ; spin_unlock ( ptl ) ; if ( page ) return page ; } if ( likely ( ! pmd_trans_huge ( pmdval ) ) ) return follow_page_pte ( vma , address , pmd , flags , & ctx -> pgmap ) ; if ( ( flags & FOLL_NUMA ) && pmd_protnone ( pmdval ) ) return no_page_table ( vma , flags ) ; retry_locked : ptl = pmd_lock ( mm , pmd ) ; if ( unlikely ( pmd_none ( * pmd ) ) ) { spin_unlock ( ptl ) ; return no_page_table ( vma , flags ) ; } if ( unlikely ( ! pmd_present ( * pmd ) ) ) { spin_unlock ( ptl ) ; if ( likely ( ! ( flags & FOLL_MIGRATION ) ) ) return no_page_table ( vma , flags ) ; pmd_migration_entry_wait ( mm , pmd ) ; goto retry_locked ; } if ( unlikely ( ! pmd_trans_huge ( * pmd ) ) ) { spin_unlock ( ptl ) ; return follow_page_pte ( vma , address , pmd , flags , & ctx -> pgmap ) ; } if ( flags & FOLL_SPLIT ) { int ret ; page = pmd_page ( * pmd ) ; if ( is_huge_zero_page ( page ) ) { spin_unlock ( ptl ) ; ret = 0 ; split_huge_pmd ( vma , pmd , address ) ; if ( pmd_trans_unstable ( pmd ) ) ret = - EBUSY ; } else { <S2SV_StartBug> get_page ( page ) ; <S2SV_EndBug> spin_unlock ( ptl ) ; lock_page ( page ) ; ret = split_huge_page ( page ) ; unlock_page ( page ) ; put_page ( page ) ; if ( pmd_none ( * pmd ) ) return no_page_table ( vma , flags ) ; } return ret ? ERR_PTR ( ret ) : follow_page_pte ( vma , address , pmd , flags , & ctx -> pgmap ) ; } page = follow_trans_huge_pmd ( vma , address , pmd , flags ) ; spin_unlock ( ptl ) ; ctx -> page_mask = HPAGE_PMD_NR - 1 ; return page ; }
CWE-416 static int get_gate_page ( struct mm_struct * mm , unsigned long address , unsigned int gup_flags , struct vm_area_struct * * vma , struct page * * page ) { pgd_t * pgd ; p4d_t * p4d ; pud_t * pud ; pmd_t * pmd ; pte_t * pte ; int ret = - EFAULT ; if ( gup_flags & FOLL_WRITE ) return - EFAULT ; if ( address > TASK_SIZE ) pgd = pgd_offset_k ( address ) ; else pgd = pgd_offset_gate ( mm , address ) ; BUG_ON ( pgd_none ( * pgd ) ) ; p4d = p4d_offset ( pgd , address ) ; BUG_ON ( p4d_none ( * p4d ) ) ; pud = pud_offset ( p4d , address ) ; BUG_ON ( pud_none ( * pud ) ) ; pmd = pmd_offset ( pud , address ) ; if ( ! pmd_present ( * pmd ) ) return - EFAULT ; VM_BUG_ON ( pmd_trans_huge ( * pmd ) ) ; pte = pte_offset_map ( pmd , address ) ; if ( pte_none ( * pte ) ) goto unmap ; * vma = get_gate_vma ( mm ) ; if ( ! page ) goto out ; * page = vm_normal_page ( * vma , address , * pte ) ; if ( ! * page ) { if ( ( gup_flags & FOLL_DUMP ) || ! is_zero_pfn ( pte_pfn ( * pte ) ) ) goto unmap ; * page = pte_page ( * pte ) ; if ( is_device_public_page ( * page ) ) goto unmap ; } <S2SV_StartBug> get_page ( * page ) ; <S2SV_EndBug> out : ret = 0 ; unmap : pte_unmap ( pte ) ; return ret ; }
CWE-416 long follow_hugetlb_page ( struct mm_struct * mm , struct vm_area_struct * vma , struct page * * pages , struct vm_area_struct * * vmas , unsigned long * position , unsigned long * nr_pages , long i , unsigned int flags , int * nonblocking ) { unsigned long pfn_offset ; unsigned long vaddr = * position ; unsigned long remainder = * nr_pages ; struct hstate * h = hstate_vma ( vma ) ; int err = - EFAULT ; while ( vaddr < vma -> vm_end && remainder ) { pte_t * pte ; spinlock_t * ptl = NULL ; int absent ; struct page * page ; if ( fatal_signal_pending ( current ) ) { remainder = 0 ; break ; } pte = huge_pte_offset ( mm , vaddr & huge_page_mask ( h ) , huge_page_size ( h ) ) ; if ( pte ) ptl = huge_pte_lock ( h , mm , pte ) ; absent = ! pte || huge_pte_none ( huge_ptep_get ( pte ) ) ; if ( absent && ( flags & FOLL_DUMP ) && ! hugetlbfs_pagecache_present ( h , vma , vaddr ) ) { if ( pte ) spin_unlock ( ptl ) ; remainder = 0 ; break ; } if ( absent || is_swap_pte ( huge_ptep_get ( pte ) ) || ( ( flags & FOLL_WRITE ) && ! huge_pte_write ( huge_ptep_get ( pte ) ) ) ) { vm_fault_t ret ; unsigned int fault_flags = 0 ; if ( pte ) spin_unlock ( ptl ) ; if ( flags & FOLL_WRITE ) fault_flags |= FAULT_FLAG_WRITE ; if ( nonblocking ) fault_flags |= FAULT_FLAG_ALLOW_RETRY ; if ( flags & FOLL_NOWAIT ) fault_flags |= FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_RETRY_NOWAIT ; if ( flags & FOLL_TRIED ) { VM_WARN_ON_ONCE ( fault_flags & FAULT_FLAG_ALLOW_RETRY ) ; fault_flags |= FAULT_FLAG_TRIED ; } ret = hugetlb_fault ( mm , vma , vaddr , fault_flags ) ; if ( ret & VM_FAULT_ERROR ) { err = vm_fault_to_errno ( ret , flags ) ; remainder = 0 ; break ; } if ( ret & VM_FAULT_RETRY ) { if ( nonblocking && ! ( fault_flags & FAULT_FLAG_RETRY_NOWAIT ) ) * nonblocking = 0 ; * nr_pages = 0 ; return i ; } continue ; } pfn_offset = ( vaddr & ~ huge_page_mask ( h ) ) >> PAGE_SHIFT ; page = pte_page ( huge_ptep_get ( pte ) ) ; <S2SV_StartBug> same_page : <S2SV_EndBug> if ( pages ) { pages [ i ] = mem_map_offset ( page , pfn_offset ) ; get_page ( pages [ i ] ) ; } if ( vmas ) vmas [ i ] = vma ; vaddr += PAGE_SIZE ; ++ pfn_offset ; -- remainder ; ++ i ; if ( vaddr < vma -> vm_end && remainder && pfn_offset < pages_per_huge_page ( h ) ) { goto same_page ; } spin_unlock ( ptl ) ; } * nr_pages = remainder ; * position = vaddr ; return i ? i : err ; }
CWE-772 int hsr_dev_finalize ( struct net_device * hsr_dev , struct net_device * slave [ 2 ] , unsigned char multicast_spec , u8 protocol_version ) { struct hsr_priv * hsr ; struct hsr_port * port ; int res ; hsr = netdev_priv ( hsr_dev ) ; INIT_LIST_HEAD ( & hsr -> ports ) ; INIT_LIST_HEAD ( & hsr -> node_db ) ; INIT_LIST_HEAD ( & hsr -> self_node_db ) ; ether_addr_copy ( hsr_dev -> dev_addr , slave [ 0 ] -> dev_addr ) ; res = hsr_create_self_node ( & hsr -> self_node_db , hsr_dev -> dev_addr , slave [ 1 ] -> dev_addr ) ; if ( res < 0 ) return res ; spin_lock_init ( & hsr -> seqnr_lock ) ; hsr -> sequence_nr = HSR_SEQNR_START ; hsr -> sup_sequence_nr = HSR_SUP_SEQNR_START ; timer_setup ( & hsr -> announce_timer , hsr_announce , 0 ) ; timer_setup ( & hsr -> prune_timer , hsr_prune_nodes , 0 ) ; ether_addr_copy ( hsr -> sup_multicast_addr , def_multicast_addr ) ; hsr -> sup_multicast_addr [ ETH_ALEN - 1 ] = multicast_spec ; hsr -> protVersion = protocol_version ; netif_carrier_off ( hsr_dev ) ; res = hsr_add_port ( hsr , hsr_dev , HSR_PT_MASTER ) ; if ( res ) <S2SV_StartBug> return res ; <S2SV_EndBug> res = register_netdevice ( hsr_dev ) ; if ( res ) goto fail ; res = hsr_add_port ( hsr , slave [ 0 ] , HSR_PT_SLAVE_A ) ; if ( res ) goto fail ; res = hsr_add_port ( hsr , slave [ 1 ] , HSR_PT_SLAVE_B ) ; if ( res ) goto fail ; mod_timer ( & hsr -> prune_timer , jiffies + msecs_to_jiffies ( PRUNE_PERIOD ) ) ; return 0 ; fail : hsr_for_each_port ( hsr , port ) hsr_del_port ( port ) ; <S2SV_StartBug> return res ; <S2SV_EndBug> }
CWE-362 static int sock_close ( struct inode * inode , struct file * filp ) { <S2SV_StartBug> sock_release ( SOCKET_I ( inode ) ) ; <S2SV_EndBug> return 0 ; }
CWE-362 void sock_release ( struct socket * sock ) { <S2SV_StartBug> if ( sock -> ops ) { <S2SV_EndBug> struct module * owner = sock -> ops -> owner ; sock -> ops -> release ( sock ) ; sock -> ops = NULL ; module_put ( owner ) ; } <S2SV_StartBug> if ( rcu_dereference_protected ( sock -> wq , 1 ) -> fasync_list ) <S2SV_EndBug> pr_err ( "%s:<S2SV_blank>fasync<S2SV_blank>list<S2SV_blank>not<S2SV_blank>empty!\\n" , __func__ ) ; if ( ! sock -> file ) { iput ( SOCK_INODE ( sock ) ) ; return ; } sock -> file = NULL ; }
CWE-362 static int sockfs_setattr ( struct dentry * dentry , struct iattr * iattr ) { int err = simple_setattr ( dentry , iattr ) ; if ( ! err && ( iattr -> ia_valid & ATTR_UID ) ) { struct socket * sock = SOCKET_I ( d_inode ( dentry ) ) ; <S2SV_StartBug> sock -> sk -> sk_uid = iattr -> ia_uid ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> return err ; }
CWE-835 static long madvise_willneed ( struct vm_area_struct * vma , struct vm_area_struct * * prev , unsigned long start , unsigned long end ) { struct file * file = vma -> vm_file ; <S2SV_StartBug> # ifdef CONFIG_SWAP <S2SV_EndBug> if ( ! file ) { <S2SV_StartBug> * prev = vma ; <S2SV_EndBug> force_swapin_readahead ( vma , start , end ) ; return 0 ; } if ( shmem_mapping ( file -> f_mapping ) ) { <S2SV_StartBug> * prev = vma ; <S2SV_EndBug> force_shm_swapin_readahead ( vma , start , end , file -> f_mapping ) ; return 0 ; } # else if ( ! file ) return - EBADF ; # endif if ( IS_DAX ( file_inode ( file ) ) ) { return 0 ; } <S2SV_StartBug> * prev = vma ; <S2SV_EndBug> start = ( ( start - vma -> vm_start ) >> PAGE_SHIFT ) + vma -> vm_pgoff ; if ( end > vma -> vm_end ) end = vma -> vm_end ; end = ( ( end - vma -> vm_start ) >> PAGE_SHIFT ) + vma -> vm_pgoff ; force_page_cache_readahead ( file -> f_mapping , file , start , end - start ) ; return 0 ; }
CWE-400 static int add_ballooned_pages ( int nr_pages ) { enum bp_state st ; if ( xen_hotplug_unpopulated ) { st = reserve_additional_memory ( ) ; if ( st != BP_ECANCELED ) { mutex_unlock ( & balloon_mutex ) ; wait_event ( balloon_wq , ! list_empty ( & ballooned_pages ) ) ; mutex_lock ( & balloon_mutex ) ; return 0 ; } } <S2SV_StartBug> st = decrease_reservation ( nr_pages , GFP_USER ) ; <S2SV_EndBug> if ( st != BP_DONE ) return - ENOMEM ; return 0 ; }
CWE-400 static void balloon_process ( struct work_struct * work ) { enum bp_state state = BP_DONE ; long credit ; do { mutex_lock ( & balloon_mutex ) ; credit = current_credit ( ) ; if ( credit > 0 ) { if ( balloon_is_inflated ( ) ) state = increase_reservation ( credit ) ; else state = reserve_additional_memory ( ) ; } <S2SV_StartBug> if ( credit < 0 ) <S2SV_EndBug> <S2SV_StartBug> state = decrease_reservation ( - credit , GFP_BALLOON ) ; <S2SV_EndBug> state = update_schedule ( state ) ; mutex_unlock ( & balloon_mutex ) ; cond_resched ( ) ; } while ( credit && state == BP_DONE ) ; if ( state == BP_EAGAIN ) schedule_delayed_work ( & balloon_worker , balloon_stats . schedule_delay * HZ ) ; }
CWE-416 int __mdiobus_register ( struct mii_bus * bus , struct module * owner ) { struct mdio_device * mdiodev ; int i , err ; struct gpio_desc * gpiod ; if ( NULL == bus || NULL == bus -> name || NULL == bus -> read || NULL == bus -> write ) return - EINVAL ; BUG_ON ( bus -> state != MDIOBUS_ALLOCATED && bus -> state != MDIOBUS_UNREGISTERED ) ; bus -> owner = owner ; bus -> dev . parent = bus -> parent ; bus -> dev . class = & mdio_bus_class ; bus -> dev . groups = NULL ; dev_set_name ( & bus -> dev , "%s" , bus -> id ) ; err = device_register ( & bus -> dev ) ; if ( err ) { pr_err ( "mii_bus<S2SV_blank>%s<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>register\\n" , bus -> id ) ; <S2SV_StartBug> put_device ( & bus -> dev ) ; <S2SV_EndBug> return - EINVAL ; } mutex_init ( & bus -> mdio_lock ) ; gpiod = devm_gpiod_get_optional ( & bus -> dev , "reset" , GPIOD_OUT_LOW ) ; if ( IS_ERR ( gpiod ) ) { dev_err ( & bus -> dev , "mii_bus<S2SV_blank>%s<S2SV_blank>couldn\'t<S2SV_blank>get<S2SV_blank>reset<S2SV_blank>GPIO\\n" , bus -> id ) ; device_del ( & bus -> dev ) ; return PTR_ERR ( gpiod ) ; } else if ( gpiod ) { bus -> reset_gpiod = gpiod ; gpiod_set_value_cansleep ( gpiod , 1 ) ; udelay ( bus -> reset_delay_us ) ; gpiod_set_value_cansleep ( gpiod , 0 ) ; } if ( bus -> reset ) bus -> reset ( bus ) ; for ( i = 0 ; i < PHY_MAX_ADDR ; i ++ ) { if ( ( bus -> phy_mask & ( 1 << i ) ) == 0 ) { struct phy_device * phydev ; phydev = mdiobus_scan ( bus , i ) ; if ( IS_ERR ( phydev ) && ( PTR_ERR ( phydev ) != - ENODEV ) ) { err = PTR_ERR ( phydev ) ; goto error ; } } } mdiobus_setup_mdiodev_from_board_info ( bus , mdiobus_create_device ) ; bus -> state = MDIOBUS_REGISTERED ; pr_info ( "%s:<S2SV_blank>probed\\n" , bus -> name ) ; return 0 ; error : while ( -- i >= 0 ) { mdiodev = bus -> mdio_map [ i ] ; if ( ! mdiodev ) continue ; mdiodev -> device_remove ( mdiodev ) ; mdiodev -> device_free ( mdiodev ) ; } if ( bus -> reset_gpiod ) gpiod_set_value_cansleep ( bus -> reset_gpiod , 1 ) ; device_del ( & bus -> dev ) ; return err ; }
CWE-400 static int usb_enumerate_device_otg ( struct usb_device * udev ) { int err = 0 ; # ifdef CONFIG_USB_OTG if ( ! udev -> bus -> is_b_host && udev -> config && udev -> parent == udev -> bus -> root_hub ) { struct usb_otg_descriptor * desc = NULL ; struct usb_bus * bus = udev -> bus ; unsigned port1 = udev -> portnum ; err = __usb_get_extra_descriptor ( udev -> rawdescriptors [ 0 ] , le16_to_cpu ( udev -> config [ 0 ] . desc . wTotalLength ) , <S2SV_StartBug> USB_DT_OTG , ( void * * ) & desc ) ; <S2SV_EndBug> if ( err || ! ( desc -> bmAttributes & USB_OTG_HNP ) ) return 0 ; dev_info ( & udev -> dev , "Dual-Role<S2SV_blank>OTG<S2SV_blank>device<S2SV_blank>on<S2SV_blank>%sHNP<S2SV_blank>port\\n" , ( port1 == bus -> otg_port ) ? "" : "non-" ) ; if ( port1 == bus -> otg_port ) { bus -> b_hnp_enable = 1 ; err = usb_control_msg ( udev , usb_sndctrlpipe ( udev , 0 ) , USB_REQ_SET_FEATURE , 0 , USB_DEVICE_B_HNP_ENABLE , 0 , NULL , 0 , USB_CTRL_SET_TIMEOUT ) ; if ( err < 0 ) { dev_err ( & udev -> dev , "can\'t<S2SV_blank>set<S2SV_blank>HNP<S2SV_blank>mode:<S2SV_blank>%d\\n" , err ) ; bus -> b_hnp_enable = 0 ; } } else if ( desc -> bLength == sizeof ( struct usb_otg_descriptor ) ) { err = usb_control_msg ( udev , usb_sndctrlpipe ( udev , 0 ) , USB_REQ_SET_FEATURE , 0 , USB_DEVICE_A_ALT_HNP_SUPPORT , 0 , NULL , 0 , USB_CTRL_SET_TIMEOUT ) ; if ( err < 0 ) dev_err ( & udev -> dev , "set<S2SV_blank>a_alt_hnp_support<S2SV_blank>failed:<S2SV_blank>%d\\n" , err ) ; } } # endif return err ; }
CWE-400 int __usb_get_extra_descriptor ( char * buffer , unsigned size , <S2SV_StartBug> unsigned char type , void * * ptr ) <S2SV_EndBug> { struct usb_descriptor_header * header ; while ( size >= sizeof ( struct usb_descriptor_header ) ) { header = ( struct usb_descriptor_header * ) buffer ; <S2SV_StartBug> if ( header -> bLength < 2 ) { <S2SV_EndBug> printk ( KERN_ERR "%s:<S2SV_blank>bogus<S2SV_blank>descriptor,<S2SV_blank>type<S2SV_blank>%d<S2SV_blank>length<S2SV_blank>%d\\n" , usbcore_name , header -> bDescriptorType , header -> bLength ) ; return - 1 ; } <S2SV_StartBug> if ( header -> bDescriptorType == type ) { <S2SV_EndBug> * ptr = header ; return 0 ; } buffer += header -> bLength ; size -= header -> bLength ; } return - 1 ; }
CWE-400 static int hwahc_security_create ( struct hwahc * hwahc ) { int result ; struct wusbhc * wusbhc = & hwahc -> wusbhc ; struct usb_device * usb_dev = hwahc -> wa . usb_dev ; struct device * dev = & usb_dev -> dev ; struct usb_security_descriptor * secd ; struct usb_encryption_descriptor * etd ; void * itr , * top ; size_t itr_size , needed , bytes ; u8 index ; char buf [ 64 ] ; index = ( usb_dev -> actconfig - usb_dev -> config ) / sizeof ( usb_dev -> config [ 0 ] ) ; itr = usb_dev -> rawdescriptors [ index ] ; itr_size = le16_to_cpu ( usb_dev -> actconfig -> desc . wTotalLength ) ; top = itr + itr_size ; result = __usb_get_extra_descriptor ( usb_dev -> rawdescriptors [ index ] , le16_to_cpu ( usb_dev -> actconfig -> desc . wTotalLength ) , <S2SV_StartBug> USB_DT_SECURITY , ( void * * ) & secd ) ; <S2SV_EndBug> if ( result == - 1 ) { dev_warn ( dev , "BUG?<S2SV_blank>WUSB<S2SV_blank>host<S2SV_blank>has<S2SV_blank>no<S2SV_blank>security<S2SV_blank>descriptors\\n" ) ; return 0 ; } needed = sizeof ( * secd ) ; if ( top - ( void * ) secd < needed ) { dev_err ( dev , "BUG?<S2SV_blank>Not<S2SV_blank>enough<S2SV_blank>data<S2SV_blank>to<S2SV_blank>process<S2SV_blank>security<S2SV_blank>" "descriptor<S2SV_blank>header<S2SV_blank>(%zu<S2SV_blank>bytes<S2SV_blank>left<S2SV_blank>vs<S2SV_blank>%zu<S2SV_blank>needed)\\n" , top - ( void * ) secd , needed ) ; return 0 ; } needed = le16_to_cpu ( secd -> wTotalLength ) ; if ( top - ( void * ) secd < needed ) { dev_err ( dev , "BUG?<S2SV_blank>Not<S2SV_blank>enough<S2SV_blank>data<S2SV_blank>to<S2SV_blank>process<S2SV_blank>security<S2SV_blank>" "descriptors<S2SV_blank>(%zu<S2SV_blank>bytes<S2SV_blank>left<S2SV_blank>vs<S2SV_blank>%zu<S2SV_blank>needed)\\n" , top - ( void * ) secd , needed ) ; return 0 ; } itr = ( void * ) secd + sizeof ( * secd ) ; top = ( void * ) secd + le16_to_cpu ( secd -> wTotalLength ) ; index = 0 ; bytes = 0 ; while ( itr < top ) { etd = itr ; if ( top - itr < sizeof ( * etd ) ) { dev_err ( dev , "BUG:<S2SV_blank>bad<S2SV_blank>host<S2SV_blank>security<S2SV_blank>descriptor;<S2SV_blank>" "not<S2SV_blank>enough<S2SV_blank>data<S2SV_blank>(%zu<S2SV_blank>vs<S2SV_blank>%zu<S2SV_blank>left)\\n" , top - itr , sizeof ( * etd ) ) ; break ; } if ( etd -> bLength < sizeof ( * etd ) ) { dev_err ( dev , "BUG:<S2SV_blank>bad<S2SV_blank>host<S2SV_blank>encryption<S2SV_blank>descriptor;<S2SV_blank>" "descriptor<S2SV_blank>is<S2SV_blank>too<S2SV_blank>short<S2SV_blank>" "(%zu<S2SV_blank>vs<S2SV_blank>%zu<S2SV_blank>needed)\\n" , ( size_t ) etd -> bLength , sizeof ( * etd ) ) ; break ; } itr += etd -> bLength ; bytes += snprintf ( buf + bytes , sizeof ( buf ) - bytes , "%s<S2SV_blank>(0x%02x)<S2SV_blank>" , wusb_et_name ( etd -> bEncryptionType ) , etd -> bEncryptionValue ) ; wusbhc -> ccm1_etd = etd ; } dev_info ( dev , "supported<S2SV_blank>encryption<S2SV_blank>types:<S2SV_blank>%s\\n" , buf ) ; if ( wusbhc -> ccm1_etd == NULL ) { dev_err ( dev , "E:<S2SV_blank>host<S2SV_blank>doesn\'t<S2SV_blank>support<S2SV_blank>CCM-1<S2SV_blank>crypto\\n" ) ; return 0 ; } return 0 ; }
CWE-20 static void __munlock_pagevec ( struct pagevec * pvec , struct zone * zone ) { int i ; int nr = pagevec_count ( pvec ) ; <S2SV_StartBug> int delta_munlocked ; <S2SV_EndBug> struct pagevec pvec_putback ; int pgrescued = 0 ; pagevec_init ( & pvec_putback , 0 ) ; spin_lock_irq ( zone_lru_lock ( zone ) ) ; for ( i = 0 ; i < nr ; i ++ ) { struct page * page = pvec -> pages [ i ] ; if ( TestClearPageMlocked ( page ) ) { if ( __munlock_isolate_lru_page ( page , false ) ) continue ; else __munlock_isolation_failed ( page ) ; <S2SV_StartBug> } <S2SV_EndBug> pagevec_add ( & pvec_putback , pvec -> pages [ i ] ) ; pvec -> pages [ i ] = NULL ; } <S2SV_StartBug> delta_munlocked = - nr + pagevec_count ( & pvec_putback ) ; <S2SV_EndBug> __mod_zone_page_state ( zone , NR_MLOCK , delta_munlocked ) ; spin_unlock_irq ( zone_lru_lock ( zone ) ) ; pagevec_release ( & pvec_putback ) ; for ( i = 0 ; i < nr ; i ++ ) { struct page * page = pvec -> pages [ i ] ; if ( page ) { lock_page ( page ) ; if ( ! __putback_lru_fast_prepare ( page , & pvec_putback , & pgrescued ) ) { get_page ( page ) ; __munlock_isolated_page ( page ) ; unlock_page ( page ) ; put_page ( page ) ; } } } if ( pagevec_count ( & pvec_putback ) ) __putback_lru_fast ( & pvec_putback , pgrescued ) ; }
CWE-416 static long do_get_mempolicy ( int * policy , nodemask_t * nmask , unsigned long addr , unsigned long flags ) { int err ; struct mm_struct * mm = current -> mm ; struct vm_area_struct * vma = NULL ; struct mempolicy * pol = current -> mempolicy ; if ( flags & ~ ( unsigned long ) ( MPOL_F_NODE | MPOL_F_ADDR | MPOL_F_MEMS_ALLOWED ) ) return - EINVAL ; if ( flags & MPOL_F_MEMS_ALLOWED ) { if ( flags & ( MPOL_F_NODE | MPOL_F_ADDR ) ) return - EINVAL ; * policy = 0 ; task_lock ( current ) ; * nmask = cpuset_current_mems_allowed ; task_unlock ( current ) ; return 0 ; } if ( flags & MPOL_F_ADDR ) { down_read ( & mm -> mmap_sem ) ; vma = find_vma_intersection ( mm , addr , addr + 1 ) ; if ( ! vma ) { up_read ( & mm -> mmap_sem ) ; return - EFAULT ; } if ( vma -> vm_ops && vma -> vm_ops -> get_policy ) pol = vma -> vm_ops -> get_policy ( vma , addr ) ; else pol = vma -> vm_policy ; } else if ( addr ) return - EINVAL ; if ( ! pol ) pol = & default_policy ; if ( flags & MPOL_F_NODE ) { if ( flags & MPOL_F_ADDR ) { err = lookup_node ( addr ) ; if ( err < 0 ) goto out ; * policy = err ; } else if ( pol == current -> mempolicy && pol -> mode == MPOL_INTERLEAVE ) { * policy = next_node_in ( current -> il_prev , pol -> v . nodes ) ; } else { err = - EINVAL ; goto out ; } } else { * policy = pol == & default_policy ? MPOL_DEFAULT : pol -> mode ; * policy |= ( pol -> flags & MPOL_MODE_FLAGS ) ; } <S2SV_StartBug> if ( vma ) { <S2SV_EndBug> up_read ( & current -> mm -> mmap_sem ) ; vma = NULL ; } err = 0 ; if ( nmask ) { if ( mpol_store_user_nodemask ( pol ) ) { * nmask = pol -> w . user_nodemask ; } else { task_lock ( current ) ; get_policy_nodemask ( pol , nmask ) ; task_unlock ( current ) ; } } out : mpol_cond_put ( pol ) ; if ( vma ) up_read ( & current -> mm -> mmap_sem ) ; return err ; }
CWE-416 static void free_user ( struct kref * ref ) { struct ipmi_user * user = container_of ( ref , struct ipmi_user , refcount ) ; <S2SV_StartBug> kfree ( user ) ; <S2SV_EndBug> }
CWE-416 int ipmi_destroy_user ( struct ipmi_user * user ) { <S2SV_StartBug> _ipmi_destroy_user ( user ) ; <S2SV_EndBug> cleanup_srcu_struct ( & user -> release_barrier ) ; kref_put ( & user -> refcount , free_user ) ; return 0 ; }
CWE-190 static void bump_cpu_timer ( struct k_itimer * timer , u64 now ) { int i ; u64 delta , incr ; if ( timer -> it . cpu . incr == 0 ) return ; if ( now < timer -> it . cpu . expires ) return ; incr = timer -> it . cpu . incr ; delta = now + incr - timer -> it . cpu . expires ; for ( i = 0 ; incr < delta - incr ; i ++ ) incr = incr << 1 ; for ( ; i >= 0 ; incr >>= 1 , i -- ) { if ( delta < incr ) continue ; timer -> it . cpu . expires += incr ; <S2SV_StartBug> timer -> it_overrun += 1 << i ; <S2SV_EndBug> delta -= incr ; } }
CWE-190 SYSCALL_DEFINE1 ( timer_getoverrun , timer_t , timer_id ) { struct k_itimer * timr ; int overrun ; unsigned long flags ; timr = lock_timer ( timer_id , & flags ) ; if ( ! timr ) return - EINVAL ; <S2SV_StartBug> overrun = timr -> it_overrun_last ; <S2SV_EndBug> unlock_timer ( timr , flags ) ; return overrun ; }
CWE-190 static void common_hrtimer_rearm ( struct k_itimer * timr ) { struct hrtimer * timer = & timr -> it . real . timer ; if ( ! timr -> it_interval ) return ; <S2SV_StartBug> timr -> it_overrun += ( unsigned int ) hrtimer_forward ( timer , <S2SV_EndBug> timer -> base -> get_time ( ) , timr -> it_interval ) ; hrtimer_restart ( timer ) ; }
CWE-190 void common_timer_get ( struct k_itimer * timr , struct itimerspec64 * cur_setting ) { const struct k_clock * kc = timr -> kclock ; ktime_t now , remaining , iv ; struct timespec64 ts64 ; bool sig_none ; sig_none = timr -> it_sigev_notify == SIGEV_NONE ; iv = timr -> it_interval ; if ( iv ) { cur_setting -> it_interval = ktime_to_timespec64 ( iv ) ; } else if ( ! timr -> it_active ) { if ( ! sig_none ) return ; } kc -> clock_get ( timr -> it_clock , & ts64 ) ; now = timespec64_to_ktime ( ts64 ) ; if ( iv && ( timr -> it_requeue_pending & REQUEUE_PENDING || sig_none ) ) <S2SV_StartBug> timr -> it_overrun += ( int ) kc -> timer_forward ( timr , now ) ; <S2SV_EndBug> remaining = kc -> timer_remaining ( timr , now ) ; if ( remaining <= 0 ) { if ( ! sig_none ) cur_setting -> it_value . tv_nsec = 1 ; } else { cur_setting -> it_value = ktime_to_timespec64 ( remaining ) ; } }
CWE-190 static int do_timer_create ( clockid_t which_clock , struct sigevent * event , timer_t __user * created_timer_id ) { const struct k_clock * kc = clockid_to_kclock ( which_clock ) ; struct k_itimer * new_timer ; int error , new_timer_id ; int it_id_set = IT_ID_NOT_SET ; if ( ! kc ) return - EINVAL ; if ( ! kc -> timer_create ) return - EOPNOTSUPP ; new_timer = alloc_posix_timer ( ) ; if ( unlikely ( ! new_timer ) ) return - EAGAIN ; spin_lock_init ( & new_timer -> it_lock ) ; new_timer_id = posix_timer_add ( new_timer ) ; if ( new_timer_id < 0 ) { error = new_timer_id ; goto out ; } it_id_set = IT_ID_SET ; new_timer -> it_id = ( timer_t ) new_timer_id ; new_timer -> it_clock = which_clock ; new_timer -> kclock = kc ; <S2SV_StartBug> new_timer -> it_overrun = - 1 ; <S2SV_EndBug> if ( event ) { rcu_read_lock ( ) ; new_timer -> it_pid = get_pid ( good_sigevent ( event ) ) ; rcu_read_unlock ( ) ; if ( ! new_timer -> it_pid ) { error = - EINVAL ; goto out ; } new_timer -> it_sigev_notify = event -> sigev_notify ; new_timer -> sigq -> info . si_signo = event -> sigev_signo ; new_timer -> sigq -> info . si_value = event -> sigev_value ; } else { new_timer -> it_sigev_notify = SIGEV_SIGNAL ; new_timer -> sigq -> info . si_signo = SIGALRM ; memset ( & new_timer -> sigq -> info . si_value , 0 , sizeof ( sigval_t ) ) ; new_timer -> sigq -> info . si_value . sival_int = new_timer -> it_id ; new_timer -> it_pid = get_pid ( task_tgid ( current ) ) ; } new_timer -> sigq -> info . si_tid = new_timer -> it_id ; new_timer -> sigq -> info . si_code = SI_TIMER ; if ( copy_to_user ( created_timer_id , & new_timer_id , sizeof ( new_timer_id ) ) ) { error = - EFAULT ; goto out ; } error = kc -> timer_create ( new_timer ) ; if ( error ) goto out ; spin_lock_irq ( & current -> sighand -> siglock ) ; new_timer -> it_signal = current -> signal ; list_add ( & new_timer -> list , & current -> signal -> posix_timers ) ; spin_unlock_irq ( & current -> sighand -> siglock ) ; return 0 ; out : release_posix_timer ( new_timer , it_id_set ) ; return error ; }
CWE-190 static enum hrtimer_restart posix_timer_fn ( struct hrtimer * timer ) { struct k_itimer * timr ; unsigned long flags ; int si_private = 0 ; enum hrtimer_restart ret = HRTIMER_NORESTART ; timr = container_of ( timer , struct k_itimer , it . real . timer ) ; spin_lock_irqsave ( & timr -> it_lock , flags ) ; timr -> it_active = 0 ; if ( timr -> it_interval != 0 ) si_private = ++ timr -> it_requeue_pending ; if ( posix_timer_event ( timr , si_private ) ) { if ( timr -> it_interval != 0 ) { ktime_t now = hrtimer_cb_get_time ( timer ) ; # ifdef CONFIG_HIGH_RES_TIMERS { ktime_t kj = NSEC_PER_SEC / HZ ; if ( timr -> it_interval < kj ) now = ktime_add ( now , kj ) ; } # endif <S2SV_StartBug> timr -> it_overrun += ( unsigned int ) <S2SV_EndBug> hrtimer_forward ( timer , now , timr -> it_interval ) ; ret = HRTIMER_RESTART ; ++ timr -> it_requeue_pending ; timr -> it_active = 1 ; } } unlock_timer ( timr , flags ) ; return ret ; }
CWE-190 void posixtimer_rearm ( struct siginfo * info ) { struct k_itimer * timr ; unsigned long flags ; timr = lock_timer ( info -> si_tid , & flags ) ; if ( ! timr ) return ; if ( timr -> it_requeue_pending == info -> si_sys_private ) { timr -> kclock -> timer_rearm ( timr ) ; timr -> it_active = 1 ; timr -> it_overrun_last = timr -> it_overrun ; <S2SV_StartBug> timr -> it_overrun = - 1 ; <S2SV_EndBug> ++ timr -> it_requeue_pending ; <S2SV_StartBug> info -> si_overrun += timr -> it_overrun_last ; <S2SV_EndBug> } unlock_timer ( timr , flags ) ; }
CWE-754 STATIC int xfs_attr_shortform_addname ( xfs_da_args_t * args ) { int newsize , forkoff , retval ; trace_xfs_attr_sf_addname ( args ) ; retval = xfs_attr_shortform_lookup ( args ) ; if ( ( args -> flags & ATTR_REPLACE ) && ( retval == - ENOATTR ) ) { return retval ; } else if ( retval == - EEXIST ) { if ( args -> flags & ATTR_CREATE ) return retval ; retval = xfs_attr_shortform_remove ( args ) ; <S2SV_StartBug> ASSERT ( retval == 0 ) ; <S2SV_EndBug> } if ( args -> namelen >= XFS_ATTR_SF_ENTSIZE_MAX || args -> valuelen >= XFS_ATTR_SF_ENTSIZE_MAX ) return - ENOSPC ; newsize = XFS_ATTR_SF_TOTSIZE ( args -> dp ) ; newsize += XFS_ATTR_SF_ENTSIZE_BYNAME ( args -> namelen , args -> valuelen ) ; forkoff = xfs_attr_shortform_bytesfit ( args -> dp , newsize ) ; if ( ! forkoff ) return - ENOSPC ; xfs_attr_shortform_add ( args , forkoff ) ; return 0 ; }
CWE-120 static int mwifiex_update_vs_ie ( const u8 * ies , int ies_len , struct mwifiex_ie * * ie_ptr , u16 mask , unsigned int oui , u8 oui_type ) { struct ieee_types_header * vs_ie ; struct mwifiex_ie * ie = * ie_ptr ; const u8 * vendor_ie ; vendor_ie = cfg80211_find_vendor_ie ( oui , oui_type , ies , ies_len ) ; if ( vendor_ie ) { if ( ! * ie_ptr ) { * ie_ptr = kzalloc ( sizeof ( struct mwifiex_ie ) , GFP_KERNEL ) ; if ( ! * ie_ptr ) return - ENOMEM ; ie = * ie_ptr ; } vs_ie = ( struct ieee_types_header * ) vendor_ie ; <S2SV_StartBug> memcpy ( ie -> ie_buffer + le16_to_cpu ( ie -> ie_length ) , <S2SV_EndBug> vs_ie , vs_ie -> len + 2 ) ; le16_unaligned_add_cpu ( & ie -> ie_length , vs_ie -> len + 2 ) ; ie -> mgmt_subtype_mask = cpu_to_le16 ( mask ) ; ie -> ie_index = cpu_to_le16 ( MWIFIEX_AUTO_IDX_MASK ) ; } * ie_ptr = ie ; return 0 ; }
CWE-120 void mwifiex_set_uap_rates ( struct mwifiex_uap_bss_param * bss_cfg , struct cfg80211_ap_settings * params ) { struct ieee_types_header * rate_ie ; int var_offset = offsetof ( struct ieee80211_mgmt , u . beacon . variable ) ; const u8 * var_pos = params -> beacon . head + var_offset ; int len = params -> beacon . head_len - var_offset ; u8 rate_len = 0 ; rate_ie = ( void * ) cfg80211_find_ie ( WLAN_EID_SUPP_RATES , var_pos , len ) ; if ( rate_ie ) { <S2SV_StartBug> memcpy ( bss_cfg -> rates , rate_ie + 1 , rate_ie -> len ) ; <S2SV_EndBug> rate_len = rate_ie -> len ; } rate_ie = ( void * ) cfg80211_find_ie ( WLAN_EID_EXT_SUPP_RATES , params -> beacon . tail , params -> beacon . tail_len ) ; <S2SV_StartBug> if ( rate_ie ) <S2SV_EndBug> <S2SV_StartBug> memcpy ( bss_cfg -> rates + rate_len , rate_ie + 1 , rate_ie -> len ) ; <S2SV_EndBug> return ; }
CWE-120 void mwifiex_set_wmm_params ( struct mwifiex_private * priv , struct mwifiex_uap_bss_param * bss_cfg , struct cfg80211_ap_settings * params ) { const u8 * vendor_ie ; const u8 * wmm_ie ; u8 wmm_oui [ ] = { 0x00 , 0x50 , 0xf2 , 0x02 } ; vendor_ie = cfg80211_find_vendor_ie ( WLAN_OUI_MICROSOFT , WLAN_OUI_TYPE_MICROSOFT_WMM , params -> beacon . tail , params -> beacon . tail_len ) ; if ( vendor_ie ) { wmm_ie = vendor_ie ; <S2SV_StartBug> memcpy ( & bss_cfg -> wmm_info , wmm_ie + <S2SV_EndBug> <S2SV_StartBug> sizeof ( struct ieee_types_header ) , * ( wmm_ie + 1 ) ) ; <S2SV_EndBug> priv -> wmm_enabled = 1 ; } else { memset ( & bss_cfg -> wmm_info , 0 , sizeof ( bss_cfg -> wmm_info ) ) ; memcpy ( & bss_cfg -> wmm_info . oui , wmm_oui , sizeof ( wmm_oui ) ) ; bss_cfg -> wmm_info . subtype = MWIFIEX_WMM_SUBTYPE ; bss_cfg -> wmm_info . version = MWIFIEX_WMM_VERSION ; priv -> wmm_enabled = 0 ; } bss_cfg -> qos_info = 0x00 ; return ; }
CWE-476 int rds_cmsg_atomic ( struct rds_sock * rs , struct rds_message * rm , struct cmsghdr * cmsg ) { struct page * page = NULL ; struct rds_atomic_args * args ; int ret = 0 ; if ( cmsg -> cmsg_len < CMSG_LEN ( sizeof ( struct rds_atomic_args ) ) || rm -> atomic . op_active ) return - EINVAL ; args = CMSG_DATA ( cmsg ) ; switch ( cmsg -> cmsg_type ) { case RDS_CMSG_ATOMIC_FADD : rm -> atomic . op_type = RDS_ATOMIC_TYPE_FADD ; rm -> atomic . op_m_fadd . add = args -> fadd . add ; rm -> atomic . op_m_fadd . nocarry_mask = 0 ; break ; case RDS_CMSG_MASKED_ATOMIC_FADD : rm -> atomic . op_type = RDS_ATOMIC_TYPE_FADD ; rm -> atomic . op_m_fadd . add = args -> m_fadd . add ; rm -> atomic . op_m_fadd . nocarry_mask = args -> m_fadd . nocarry_mask ; break ; case RDS_CMSG_ATOMIC_CSWP : rm -> atomic . op_type = RDS_ATOMIC_TYPE_CSWP ; rm -> atomic . op_m_cswp . compare = args -> cswp . compare ; rm -> atomic . op_m_cswp . swap = args -> cswp . swap ; rm -> atomic . op_m_cswp . compare_mask = ~ 0 ; rm -> atomic . op_m_cswp . swap_mask = ~ 0 ; break ; case RDS_CMSG_MASKED_ATOMIC_CSWP : rm -> atomic . op_type = RDS_ATOMIC_TYPE_CSWP ; rm -> atomic . op_m_cswp . compare = args -> m_cswp . compare ; rm -> atomic . op_m_cswp . swap = args -> m_cswp . swap ; rm -> atomic . op_m_cswp . compare_mask = args -> m_cswp . compare_mask ; rm -> atomic . op_m_cswp . swap_mask = args -> m_cswp . swap_mask ; break ; default : BUG ( ) ; } rm -> atomic . op_notify = ! ! ( args -> flags & RDS_RDMA_NOTIFY_ME ) ; rm -> atomic . op_silent = ! ! ( args -> flags & RDS_RDMA_SILENT ) ; rm -> atomic . op_active = 1 ; rm -> atomic . op_recverr = rs -> rs_recverr ; rm -> atomic . op_sg = rds_message_alloc_sgs ( rm , 1 ) ; if ( ! rm -> atomic . op_sg ) { ret = - ENOMEM ; goto err ; } if ( args -> local_addr & 0x7 ) { ret = - EFAULT ; goto err ; } ret = rds_pin_pages ( args -> local_addr , 1 , & page , 1 ) ; if ( ret != 1 ) goto err ; ret = 0 ; sg_set_page ( rm -> atomic . op_sg , page , 8 , offset_in_page ( args -> local_addr ) ) ; if ( rm -> atomic . op_notify || rm -> atomic . op_recverr ) { rm -> atomic . op_notifier = kmalloc ( sizeof ( * rm -> atomic . op_notifier ) , GFP_KERNEL ) ; if ( ! rm -> atomic . op_notifier ) { ret = - ENOMEM ; goto err ; } rm -> atomic . op_notifier -> n_user_token = args -> user_token ; rm -> atomic . op_notifier -> n_status = RDS_RDMA_SUCCESS ; } rm -> atomic . op_rkey = rds_rdma_cookie_key ( args -> cookie ) ; rm -> atomic . op_remote_addr = args -> remote_addr + rds_rdma_cookie_offset ( args -> cookie ) ; return ret ; err : if ( page ) put_page ( page ) ; <S2SV_StartBug> kfree ( rm -> atomic . op_notifier ) ; <S2SV_EndBug> return ret ; }
CWE-415 static int f_midi_set_alt ( struct usb_function * f , unsigned intf , unsigned alt ) { struct f_midi * midi = func_to_midi ( f ) ; unsigned i ; int err ; if ( intf != midi -> ms_id ) return 0 ; err = f_midi_start_ep ( midi , f , midi -> in_ep ) ; if ( err ) return err ; err = f_midi_start_ep ( midi , f , midi -> out_ep ) ; if ( err ) return err ; while ( kfifo_avail ( & midi -> in_req_fifo ) ) { struct usb_request * req = midi_alloc_ep_req ( midi -> in_ep , midi -> buflen ) ; if ( req == NULL ) return - ENOMEM ; req -> length = 0 ; req -> complete = f_midi_complete ; kfifo_put ( & midi -> in_req_fifo , req ) ; } for ( i = 0 ; i < midi -> qlen && err == 0 ; i ++ ) { struct usb_request * req = midi_alloc_ep_req ( midi -> out_ep , midi -> buflen ) ; if ( req == NULL ) return - ENOMEM ; req -> complete = f_midi_complete ; err = usb_ep_queue ( midi -> out_ep , req , GFP_ATOMIC ) ; if ( err ) { ERROR ( midi , "%s:<S2SV_blank>couldn\'t<S2SV_blank>enqueue<S2SV_blank>request:<S2SV_blank>%d\\n" , midi -> out_ep -> name , err ) ; <S2SV_StartBug> free_ep_req ( midi -> out_ep , req ) ; <S2SV_EndBug> return err ; } } return 0 ; }
CWE-787 static void __local_bh_enable ( unsigned int cnt ) { <S2SV_StartBug> lockdep_assert_irqs_disabled ( ) ; <S2SV_EndBug> if ( softirq_count ( ) == ( cnt & SOFTIRQ_MASK ) ) trace_softirqs_on ( _RET_IP_ ) ; <S2SV_StartBug> preempt_count_sub ( cnt ) ; <S2SV_EndBug> }
CWE-787 static struct prog_entry * predicate_parse ( const char * str , int nr_parens , int nr_preds , parse_pred_fn parse_pred , void * data , struct filter_parse_error * pe ) { struct prog_entry * prog_stack ; struct prog_entry * prog ; const char * ptr = str ; char * inverts = NULL ; int * op_stack ; int * top ; int invert = 0 ; int ret = - ENOMEM ; int len ; int N = 0 ; int i ; nr_preds += 2 ; op_stack = kmalloc_array ( nr_parens , sizeof ( * op_stack ) , GFP_KERNEL ) ; if ( ! op_stack ) return ERR_PTR ( - ENOMEM ) ; prog_stack = kmalloc_array ( nr_preds , sizeof ( * prog_stack ) , GFP_KERNEL ) ; if ( ! prog_stack ) { parse_error ( pe , - ENOMEM , 0 ) ; goto out_free ; } inverts = kmalloc_array ( nr_preds , sizeof ( * inverts ) , GFP_KERNEL ) ; if ( ! inverts ) { parse_error ( pe , - ENOMEM , 0 ) ; goto out_free ; } top = op_stack ; prog = prog_stack ; * top = 0 ; while ( * ptr ) { const char * next = ptr ++ ; if ( isspace ( * next ) ) continue ; switch ( * next ) { case '(' : if ( top - op_stack > nr_parens ) return ERR_PTR ( - EINVAL ) ; * ( ++ top ) = invert ; continue ; case '!' : if ( ! is_not ( next ) ) break ; invert = ! invert ; continue ; } if ( N >= nr_preds ) { parse_error ( pe , FILT_ERR_TOO_MANY_PREDS , next - str ) ; goto out_free ; } inverts [ N ] = invert ; prog [ N ] . target = N - 1 ; len = parse_pred ( next , data , ptr - str , pe , & prog [ N ] . pred ) ; if ( len < 0 ) { ret = len ; goto out_free ; } ptr = next + len ; N ++ ; ret = - 1 ; while ( 1 ) { next = ptr ++ ; if ( isspace ( * next ) ) continue ; switch ( * next ) { case ')' : case '\\0' : break ; case '&' : case '|' : if ( next [ 1 ] == next [ 0 ] ) { ptr ++ ; break ; } default : parse_error ( pe , FILT_ERR_TOO_MANY_PREDS , next - str ) ; goto out_free ; } invert = * top & INVERT ; if ( * top & PROCESS_AND ) { update_preds ( prog , N - 1 , invert ) ; * top &= ~ PROCESS_AND ; } if ( * next == '&' ) { * top |= PROCESS_AND ; break ; } if ( * top & PROCESS_OR ) { update_preds ( prog , N - 1 , ! invert ) ; * top &= ~ PROCESS_OR ; } if ( * next == '|' ) { * top |= PROCESS_OR ; break ; } if ( ! * next ) goto out ; if ( top == op_stack ) { ret = - 1 ; parse_error ( pe , FILT_ERR_TOO_MANY_CLOSE , ptr - str ) ; goto out_free ; } top -- ; } } out : if ( top != op_stack ) { parse_error ( pe , FILT_ERR_TOO_MANY_OPEN , ptr - str ) ; goto out_free ; } <S2SV_StartBug> prog [ N ] . pred = NULL ; <S2SV_EndBug> prog [ N ] . target = 1 ; prog [ N + 1 ] . pred = NULL ; prog [ N + 1 ] . target = 0 ; prog [ N - 1 ] . target = N ; prog [ N - 1 ] . when_to_branch = false ; for ( i = N - 1 ; i -- ; ) { int target = prog [ i ] . target ; if ( prog [ i ] . when_to_branch == prog [ target ] . when_to_branch ) prog [ i ] . target = prog [ target ] . target ; } for ( i = 0 ; i < N ; i ++ ) { invert = inverts [ i ] ^ prog [ i ] . when_to_branch ; prog [ i ] . when_to_branch = invert ; if ( WARN_ON ( prog [ i ] . target <= i ) ) { ret = - EINVAL ; goto out_free ; } } return prog ; out_free : kfree ( op_stack ) ; kfree ( prog_stack ) ; kfree ( inverts ) ; return ERR_PTR ( ret ) ; }
CWE-476 static ssize_t o2nm_node_ipv4_address_store ( struct config_item * item , const char * page , size_t count ) { struct o2nm_node * node = to_o2nm_node ( item ) ; <S2SV_StartBug> struct o2nm_cluster * cluster = to_o2nm_cluster_from_node ( node ) ; <S2SV_EndBug> int ret , i ; struct rb_node * * p , * parent ; unsigned int octets [ 4 ] ; __be32 ipv4_addr = 0 ; ret = sscanf ( page , "%3u.%3u.%3u.%3u" , & octets [ 3 ] , & octets [ 2 ] , & octets [ 1 ] , & octets [ 0 ] ) ; if ( ret != 4 ) return - EINVAL ; for ( i = 0 ; i < ARRAY_SIZE ( octets ) ; i ++ ) { if ( octets [ i ] > 255 ) return - ERANGE ; be32_add_cpu ( & ipv4_addr , octets [ i ] << ( i * 8 ) ) ; } <S2SV_StartBug> ret = 0 ; <S2SV_EndBug> write_lock ( & cluster -> cl_nodes_lock ) ; if ( o2nm_node_ip_tree_lookup ( cluster , ipv4_addr , & p , & parent ) ) ret = - EEXIST ; else if ( test_and_set_bit ( O2NM_NODE_ATTR_ADDRESS , & node -> nd_set_attributes ) ) ret = - EBUSY ; else { rb_link_node ( & node -> nd_ip_node , parent , p ) ; rb_insert_color ( & node -> nd_ip_node , & cluster -> cl_node_ip_tree ) ; } write_unlock ( & cluster -> cl_nodes_lock ) ; <S2SV_StartBug> if ( ret ) <S2SV_EndBug> return ret ; memcpy ( & node -> nd_ipv4_address , & ipv4_addr , sizeof ( ipv4_addr ) ) ; return count ; }
CWE-476 static ssize_t o2nm_node_local_store ( struct config_item * item , const char * page , size_t count ) { struct o2nm_node * node = to_o2nm_node ( item ) ; <S2SV_StartBug> struct o2nm_cluster * cluster = to_o2nm_cluster_from_node ( node ) ; <S2SV_EndBug> unsigned long tmp ; char * p = ( char * ) page ; ssize_t ret ; tmp = simple_strtoul ( p , & p , 0 ) ; if ( ! p || ( * p && ( * p != '\\n' ) ) ) return - EINVAL ; tmp = ! ! tmp ; if ( ! test_bit ( O2NM_NODE_ATTR_ADDRESS , & node -> nd_set_attributes ) || ! test_bit ( O2NM_NODE_ATTR_NUM , & node -> nd_set_attributes ) || ! test_bit ( O2NM_NODE_ATTR_PORT , & node -> nd_set_attributes ) ) return - EINVAL ; <S2SV_StartBug> if ( tmp && tmp == cluster -> cl_has_local && <S2SV_EndBug> cluster -> cl_local_node != node -> nd_num ) <S2SV_StartBug> return - EBUSY ; <S2SV_EndBug> <S2SV_StartBug> if ( tmp && ! cluster -> cl_has_local ) { <S2SV_EndBug> ret = o2net_start_listening ( node ) ; if ( ret ) <S2SV_StartBug> return ret ; <S2SV_EndBug> } if ( ! tmp && cluster -> cl_has_local && cluster -> cl_local_node == node -> nd_num ) { o2net_stop_listening ( node ) ; cluster -> cl_local_node = O2NM_INVALID_NODE_NUM ; } node -> nd_local = tmp ; if ( node -> nd_local ) { cluster -> cl_has_local = tmp ; cluster -> cl_local_node = node -> nd_num ; } <S2SV_StartBug> return count ; <S2SV_EndBug> }
CWE-476 static ssize_t o2nm_node_num_store ( struct config_item * item , const char * page , size_t count ) { struct o2nm_node * node = to_o2nm_node ( item ) ; <S2SV_StartBug> struct o2nm_cluster * cluster = to_o2nm_cluster_from_node ( node ) ; <S2SV_EndBug> unsigned long tmp ; char * p = ( char * ) page ; int ret = 0 ; tmp = simple_strtoul ( p , & p , 0 ) ; if ( ! p || ( * p && ( * p != '\\n' ) ) ) return - EINVAL ; if ( tmp >= O2NM_MAX_NODES ) return - ERANGE ; if ( ! test_bit ( O2NM_NODE_ATTR_ADDRESS , & node -> nd_set_attributes ) || ! test_bit ( O2NM_NODE_ATTR_PORT , & node -> nd_set_attributes ) ) return - EINVAL ; <S2SV_StartBug> write_lock ( & cluster -> cl_nodes_lock ) ; <S2SV_EndBug> if ( cluster -> cl_nodes [ tmp ] ) ret = - EEXIST ; else if ( test_and_set_bit ( O2NM_NODE_ATTR_NUM , & node -> nd_set_attributes ) ) ret = - EBUSY ; else { cluster -> cl_nodes [ tmp ] = node ; node -> nd_num = tmp ; set_bit ( tmp , cluster -> cl_nodes_bitmap ) ; } write_unlock ( & cluster -> cl_nodes_lock ) ; <S2SV_StartBug> if ( ret ) <S2SV_EndBug> return ret ; return count ; }
CWE-476 static struct o2nm_cluster * to_o2nm_cluster_from_node ( struct o2nm_node * node ) { <S2SV_StartBug> return to_o2nm_cluster ( node -> nd_item . ci_parent -> ci_parent ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>
CWE-415 static int amd_gpio_remove ( struct platform_device * pdev ) { struct amd_gpio * gpio_dev ; gpio_dev = platform_get_drvdata ( pdev ) ; gpiochip_remove ( & gpio_dev -> gc ) ; <S2SV_StartBug> pinctrl_unregister ( gpio_dev -> pctrl ) ; <S2SV_EndBug> return 0 ; }
CWE-200 static int cdrom_ioctl_drive_status ( struct cdrom_device_info * cdi , unsigned long arg ) { cd_dbg ( CD_DO_IOCTL , "entering<S2SV_blank>CDROM_DRIVE_STATUS\\n" ) ; if ( ! ( cdi -> ops -> capability & CDC_DRIVE_STATUS ) ) return - ENOSYS ; if ( ! CDROM_CAN ( CDC_SELECT_DISC ) || ( arg == CDSL_CURRENT || arg == CDSL_NONE ) ) return cdi -> ops -> drive_status ( cdi , CDSL_CURRENT ) ; <S2SV_StartBug> if ( ( ( int ) arg >= cdi -> capacity ) ) <S2SV_EndBug> return - EINVAL ; return cdrom_slot_status ( cdi , arg ) ; }
CWE-416 static struct page * follow_page_pte ( struct vm_area_struct * vma , unsigned long address , pmd_t * pmd , unsigned int flags , struct dev_pagemap * * pgmap ) { struct mm_struct * mm = vma -> vm_mm ; struct page * page ; spinlock_t * ptl ; pte_t * ptep , pte ; retry : if ( unlikely ( pmd_bad ( * pmd ) ) ) return no_page_table ( vma , flags ) ; ptep = pte_offset_map_lock ( mm , pmd , address , & ptl ) ; pte = * ptep ; if ( ! pte_present ( pte ) ) { swp_entry_t entry ; if ( likely ( ! ( flags & FOLL_MIGRATION ) ) ) goto no_page ; if ( pte_none ( pte ) ) goto no_page ; entry = pte_to_swp_entry ( pte ) ; if ( ! is_migration_entry ( entry ) ) goto no_page ; pte_unmap_unlock ( ptep , ptl ) ; migration_entry_wait ( mm , pmd , address ) ; goto retry ; } if ( ( flags & FOLL_NUMA ) && pte_protnone ( pte ) ) goto no_page ; if ( ( flags & FOLL_WRITE ) && ! can_follow_write_pte ( pte , flags ) ) { pte_unmap_unlock ( ptep , ptl ) ; return NULL ; } page = vm_normal_page ( vma , address , pte ) ; if ( ! page && pte_devmap ( pte ) && ( flags & FOLL_GET ) ) { * pgmap = get_dev_pagemap ( pte_pfn ( pte ) , * pgmap ) ; if ( * pgmap ) page = pte_page ( pte ) ; else goto no_page ; } else if ( unlikely ( ! page ) ) { if ( flags & FOLL_DUMP ) { page = ERR_PTR ( - EFAULT ) ; goto out ; } if ( is_zero_pfn ( pte_pfn ( pte ) ) ) { page = pte_page ( pte ) ; } else { int ret ; ret = follow_pfn_pte ( vma , address , ptep , flags ) ; page = ERR_PTR ( ret ) ; goto out ; } } if ( flags & FOLL_SPLIT && PageTransCompound ( page ) ) { int ret ; get_page ( page ) ; pte_unmap_unlock ( ptep , ptl ) ; lock_page ( page ) ; ret = split_huge_page ( page ) ; unlock_page ( page ) ; put_page ( page ) ; if ( ret ) return ERR_PTR ( ret ) ; goto retry ; } if ( flags & FOLL_GET ) <S2SV_StartBug> get_page ( page ) ; <S2SV_EndBug> if ( flags & FOLL_TOUCH ) { if ( ( flags & FOLL_WRITE ) && ! pte_dirty ( pte ) && ! PageDirty ( page ) ) set_page_dirty ( page ) ; mark_page_accessed ( page ) ; } if ( ( flags & FOLL_MLOCK ) && ( vma -> vm_flags & VM_LOCKED ) ) { if ( PageTransCompound ( page ) ) goto out ; if ( page -> mapping && trylock_page ( page ) ) { lru_add_drain ( ) ; mlock_vma_page ( page ) ; unlock_page ( page ) ; } } out : pte_unmap_unlock ( ptep , ptl ) ; return page ; no_page : pte_unmap_unlock ( ptep , ptl ) ; if ( ! pte_none ( pte ) ) return NULL ; return no_page_table ( vma , flags ) ; }
CWE-416 static struct page * follow_pmd_mask ( struct vm_area_struct * vma , unsigned long address , pud_t * pudp , unsigned int flags , struct follow_page_context * ctx ) { pmd_t * pmd , pmdval ; spinlock_t * ptl ; struct page * page ; struct mm_struct * mm = vma -> vm_mm ; pmd = pmd_offset ( pudp , address ) ; pmdval = READ_ONCE ( * pmd ) ; if ( pmd_none ( pmdval ) ) return no_page_table ( vma , flags ) ; if ( pmd_huge ( pmdval ) && vma -> vm_flags & VM_HUGETLB ) { page = follow_huge_pmd ( mm , address , pmd , flags ) ; if ( page ) return page ; return no_page_table ( vma , flags ) ; } if ( is_hugepd ( __hugepd ( pmd_val ( pmdval ) ) ) ) { page = follow_huge_pd ( vma , address , __hugepd ( pmd_val ( pmdval ) ) , flags , PMD_SHIFT ) ; if ( page ) return page ; return no_page_table ( vma , flags ) ; } retry : if ( ! pmd_present ( pmdval ) ) { if ( likely ( ! ( flags & FOLL_MIGRATION ) ) ) return no_page_table ( vma , flags ) ; VM_BUG_ON ( thp_migration_supported ( ) && ! is_pmd_migration_entry ( pmdval ) ) ; if ( is_pmd_migration_entry ( pmdval ) ) pmd_migration_entry_wait ( mm , pmd ) ; pmdval = READ_ONCE ( * pmd ) ; if ( pmd_none ( pmdval ) ) return no_page_table ( vma , flags ) ; goto retry ; } if ( pmd_devmap ( pmdval ) ) { ptl = pmd_lock ( mm , pmd ) ; page = follow_devmap_pmd ( vma , address , pmd , flags , & ctx -> pgmap ) ; spin_unlock ( ptl ) ; if ( page ) return page ; } if ( likely ( ! pmd_trans_huge ( pmdval ) ) ) return follow_page_pte ( vma , address , pmd , flags , & ctx -> pgmap ) ; if ( ( flags & FOLL_NUMA ) && pmd_protnone ( pmdval ) ) return no_page_table ( vma , flags ) ; retry_locked : ptl = pmd_lock ( mm , pmd ) ; if ( unlikely ( pmd_none ( * pmd ) ) ) { spin_unlock ( ptl ) ; return no_page_table ( vma , flags ) ; } if ( unlikely ( ! pmd_present ( * pmd ) ) ) { spin_unlock ( ptl ) ; if ( likely ( ! ( flags & FOLL_MIGRATION ) ) ) return no_page_table ( vma , flags ) ; pmd_migration_entry_wait ( mm , pmd ) ; goto retry_locked ; } if ( unlikely ( ! pmd_trans_huge ( * pmd ) ) ) { spin_unlock ( ptl ) ; return follow_page_pte ( vma , address , pmd , flags , & ctx -> pgmap ) ; } if ( flags & FOLL_SPLIT ) { int ret ; page = pmd_page ( * pmd ) ; if ( is_huge_zero_page ( page ) ) { spin_unlock ( ptl ) ; ret = 0 ; split_huge_pmd ( vma , pmd , address ) ; if ( pmd_trans_unstable ( pmd ) ) ret = - EBUSY ; } else { <S2SV_StartBug> get_page ( page ) ; <S2SV_EndBug> spin_unlock ( ptl ) ; lock_page ( page ) ; ret = split_huge_page ( page ) ; unlock_page ( page ) ; put_page ( page ) ; if ( pmd_none ( * pmd ) ) return no_page_table ( vma , flags ) ; } return ret ? ERR_PTR ( ret ) : follow_page_pte ( vma , address , pmd , flags , & ctx -> pgmap ) ; } page = follow_trans_huge_pmd ( vma , address , pmd , flags ) ; spin_unlock ( ptl ) ; ctx -> page_mask = HPAGE_PMD_NR - 1 ; return page ; }
CWE-416 static int get_gate_page ( struct mm_struct * mm , unsigned long address , unsigned int gup_flags , struct vm_area_struct * * vma , struct page * * page ) { pgd_t * pgd ; p4d_t * p4d ; pud_t * pud ; pmd_t * pmd ; pte_t * pte ; int ret = - EFAULT ; if ( gup_flags & FOLL_WRITE ) return - EFAULT ; if ( address > TASK_SIZE ) pgd = pgd_offset_k ( address ) ; else pgd = pgd_offset_gate ( mm , address ) ; BUG_ON ( pgd_none ( * pgd ) ) ; p4d = p4d_offset ( pgd , address ) ; BUG_ON ( p4d_none ( * p4d ) ) ; pud = pud_offset ( p4d , address ) ; BUG_ON ( pud_none ( * pud ) ) ; pmd = pmd_offset ( pud , address ) ; if ( ! pmd_present ( * pmd ) ) return - EFAULT ; VM_BUG_ON ( pmd_trans_huge ( * pmd ) ) ; pte = pte_offset_map ( pmd , address ) ; if ( pte_none ( * pte ) ) goto unmap ; * vma = get_gate_vma ( mm ) ; if ( ! page ) goto out ; * page = vm_normal_page ( * vma , address , * pte ) ; if ( ! * page ) { if ( ( gup_flags & FOLL_DUMP ) || ! is_zero_pfn ( pte_pfn ( * pte ) ) ) goto unmap ; * page = pte_page ( * pte ) ; if ( is_device_public_page ( * page ) ) goto unmap ; } <S2SV_StartBug> get_page ( * page ) ; <S2SV_EndBug> out : ret = 0 ; unmap : pte_unmap ( pte ) ; return ret ; }
CWE-416 long follow_hugetlb_page ( struct mm_struct * mm , struct vm_area_struct * vma , struct page * * pages , struct vm_area_struct * * vmas , unsigned long * position , unsigned long * nr_pages , long i , unsigned int flags , int * nonblocking ) { unsigned long pfn_offset ; unsigned long vaddr = * position ; unsigned long remainder = * nr_pages ; struct hstate * h = hstate_vma ( vma ) ; int err = - EFAULT ; while ( vaddr < vma -> vm_end && remainder ) { pte_t * pte ; spinlock_t * ptl = NULL ; int absent ; struct page * page ; if ( fatal_signal_pending ( current ) ) { remainder = 0 ; break ; } pte = huge_pte_offset ( mm , vaddr & huge_page_mask ( h ) , huge_page_size ( h ) ) ; if ( pte ) ptl = huge_pte_lock ( h , mm , pte ) ; absent = ! pte || huge_pte_none ( huge_ptep_get ( pte ) ) ; if ( absent && ( flags & FOLL_DUMP ) && ! hugetlbfs_pagecache_present ( h , vma , vaddr ) ) { if ( pte ) spin_unlock ( ptl ) ; remainder = 0 ; break ; } if ( absent || is_swap_pte ( huge_ptep_get ( pte ) ) || ( ( flags & FOLL_WRITE ) && ! huge_pte_write ( huge_ptep_get ( pte ) ) ) ) { vm_fault_t ret ; unsigned int fault_flags = 0 ; if ( pte ) spin_unlock ( ptl ) ; if ( flags & FOLL_WRITE ) fault_flags |= FAULT_FLAG_WRITE ; if ( nonblocking ) fault_flags |= FAULT_FLAG_ALLOW_RETRY ; if ( flags & FOLL_NOWAIT ) fault_flags |= FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_RETRY_NOWAIT ; if ( flags & FOLL_TRIED ) { VM_WARN_ON_ONCE ( fault_flags & FAULT_FLAG_ALLOW_RETRY ) ; fault_flags |= FAULT_FLAG_TRIED ; } ret = hugetlb_fault ( mm , vma , vaddr , fault_flags ) ; if ( ret & VM_FAULT_ERROR ) { err = vm_fault_to_errno ( ret , flags ) ; remainder = 0 ; break ; } if ( ret & VM_FAULT_RETRY ) { if ( nonblocking && ! ( fault_flags & FAULT_FLAG_RETRY_NOWAIT ) ) * nonblocking = 0 ; * nr_pages = 0 ; return i ; } continue ; } pfn_offset = ( vaddr & ~ huge_page_mask ( h ) ) >> PAGE_SHIFT ; page = pte_page ( huge_ptep_get ( pte ) ) ; <S2SV_StartBug> same_page : <S2SV_EndBug> if ( pages ) { pages [ i ] = mem_map_offset ( page , pfn_offset ) ; get_page ( pages [ i ] ) ; } if ( vmas ) vmas [ i ] = vma ; vaddr += PAGE_SIZE ; ++ pfn_offset ; -- remainder ; ++ i ; if ( vaddr < vma -> vm_end && remainder && pfn_offset < pages_per_huge_page ( h ) ) { goto same_page ; } spin_unlock ( ptl ) ; } * nr_pages = remainder ; * position = vaddr ; return i ? i : err ; }
CWE-704 static int n_tty_ioctl ( struct tty_struct * tty , struct file * file , unsigned int cmd , unsigned long arg ) { struct n_tty_data * ldata = tty -> disc_data ; int retval ; switch ( cmd ) { case TIOCOUTQ : return put_user ( tty_chars_in_buffer ( tty ) , ( int __user * ) arg ) ; case TIOCINQ : down_write ( & tty -> termios_rwsem ) ; <S2SV_StartBug> if ( L_ICANON ( tty ) ) <S2SV_EndBug> retval = inq_canon ( ldata ) ; else retval = read_cnt ( ldata ) ; up_write ( & tty -> termios_rwsem ) ; return put_user ( retval , ( unsigned int __user * ) arg ) ; default : return n_tty_ioctl_helper ( tty , file , cmd , arg ) ; } }
CWE-704 static void n_tty_set_termios ( struct tty_struct * tty , struct ktermios * old ) { struct n_tty_data * ldata = tty -> disc_data ; <S2SV_StartBug> if ( ! old || ( old -> c_lflag ^ tty -> termios . c_lflag ) & ICANON ) { <S2SV_EndBug> bitmap_zero ( ldata -> read_flags , N_TTY_BUF_SIZE ) ; ldata -> line_start = ldata -> read_tail ; if ( ! L_ICANON ( tty ) || ! read_cnt ( ldata ) ) { ldata -> canon_head = ldata -> read_tail ; ldata -> push = 0 ; } else { set_bit ( ( ldata -> read_head - 1 ) & ( N_TTY_BUF_SIZE - 1 ) , ldata -> read_flags ) ; ldata -> canon_head = ldata -> read_head ; ldata -> push = 1 ; } ldata -> commit_head = ldata -> read_head ; ldata -> erasing = 0 ; ldata -> lnext = 0 ; } ldata -> icanon = ( L_ICANON ( tty ) != 0 ) ; if ( I_ISTRIP ( tty ) || I_IUCLC ( tty ) || I_IGNCR ( tty ) || I_ICRNL ( tty ) || I_INLCR ( tty ) || L_ICANON ( tty ) || I_IXON ( tty ) || L_ISIG ( tty ) || L_ECHO ( tty ) || I_PARMRK ( tty ) ) { bitmap_zero ( ldata -> char_map , 256 ) ; if ( I_IGNCR ( tty ) || I_ICRNL ( tty ) ) set_bit ( '\\r' , ldata -> char_map ) ; if ( I_INLCR ( tty ) ) set_bit ( '\\n' , ldata -> char_map ) ; if ( L_ICANON ( tty ) ) { set_bit ( ERASE_CHAR ( tty ) , ldata -> char_map ) ; set_bit ( KILL_CHAR ( tty ) , ldata -> char_map ) ; set_bit ( EOF_CHAR ( tty ) , ldata -> char_map ) ; set_bit ( '\\n' , ldata -> char_map ) ; set_bit ( EOL_CHAR ( tty ) , ldata -> char_map ) ; if ( L_IEXTEN ( tty ) ) { set_bit ( WERASE_CHAR ( tty ) , ldata -> char_map ) ; set_bit ( LNEXT_CHAR ( tty ) , ldata -> char_map ) ; set_bit ( EOL2_CHAR ( tty ) , ldata -> char_map ) ; if ( L_ECHO ( tty ) ) set_bit ( REPRINT_CHAR ( tty ) , ldata -> char_map ) ; } } if ( I_IXON ( tty ) ) { set_bit ( START_CHAR ( tty ) , ldata -> char_map ) ; set_bit ( STOP_CHAR ( tty ) , ldata -> char_map ) ; } if ( L_ISIG ( tty ) ) { set_bit ( INTR_CHAR ( tty ) , ldata -> char_map ) ; set_bit ( QUIT_CHAR ( tty ) , ldata -> char_map ) ; set_bit ( SUSP_CHAR ( tty ) , ldata -> char_map ) ; } clear_bit ( __DISABLED_CHAR , ldata -> char_map ) ; ldata -> raw = 0 ; ldata -> real_raw = 0 ; } else { ldata -> raw = 1 ; if ( ( I_IGNBRK ( tty ) || ( ! I_BRKINT ( tty ) && ! I_PARMRK ( tty ) ) ) && ( I_IGNPAR ( tty ) || ! I_INPCK ( tty ) ) && ( tty -> driver -> flags & TTY_DRIVER_REAL_RAW ) ) ldata -> real_raw = 1 ; else ldata -> real_raw = 0 ; } if ( ! I_IXON ( tty ) && old && ( old -> c_iflag & IXON ) && ! tty -> flow_stopped ) { start_tty ( tty ) ; process_echoes ( tty ) ; } wake_up_interruptible ( & tty -> write_wait ) ; wake_up_interruptible ( & tty -> read_wait ) ; }
CWE-189 static int adjust_ptr_min_max_vals ( struct bpf_verifier_env * env , struct bpf_insn * insn , const struct bpf_reg_state * ptr_reg , const struct bpf_reg_state * off_reg ) { struct bpf_verifier_state * vstate = env -> cur_state ; struct bpf_func_state * state = vstate -> frame [ vstate -> curframe ] ; struct bpf_reg_state * regs = state -> regs , * dst_reg ; bool known = tnum_is_const ( off_reg -> var_off ) ; s64 smin_val = off_reg -> smin_value , smax_val = off_reg -> smax_value , smin_ptr = ptr_reg -> smin_value , smax_ptr = ptr_reg -> smax_value ; u64 umin_val = off_reg -> umin_value , umax_val = off_reg -> umax_value , umin_ptr = ptr_reg -> umin_value , umax_ptr = ptr_reg -> umax_value ; u32 dst = insn -> dst_reg , src = insn -> src_reg ; <S2SV_StartBug> u8 opcode = BPF_OP ( insn -> code ) ; <S2SV_EndBug> dst_reg = & regs [ dst ] ; if ( ( known && ( smin_val != smax_val || umin_val != umax_val ) ) || smin_val > smax_val || umin_val > umax_val ) { __mark_reg_unknown ( dst_reg ) ; return 0 ; } if ( BPF_CLASS ( insn -> code ) != BPF_ALU64 ) { verbose ( env , "R%d<S2SV_blank>32-bit<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>prohibited\\n" , dst ) ; return - EACCES ; } switch ( ptr_reg -> type ) { case PTR_TO_MAP_VALUE_OR_NULL : verbose ( env , "R%d<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>on<S2SV_blank>%s<S2SV_blank>prohibited,<S2SV_blank>null-check<S2SV_blank>it<S2SV_blank>first\\n" , dst , reg_type_str [ ptr_reg -> type ] ) ; return - EACCES ; case CONST_PTR_TO_MAP : case PTR_TO_PACKET_END : case PTR_TO_SOCKET : case PTR_TO_SOCKET_OR_NULL : verbose ( env , "R%d<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>on<S2SV_blank>%s<S2SV_blank>prohibited\\n" , dst , reg_type_str [ ptr_reg -> type ] ) ; return - EACCES ; case PTR_TO_MAP_VALUE : if ( ! env -> allow_ptr_leaks && ! known && ( smin_val < 0 ) != ( smax_val < 0 ) ) { verbose ( env , "R%d<S2SV_blank>has<S2SV_blank>unknown<S2SV_blank>scalar<S2SV_blank>with<S2SV_blank>mixed<S2SV_blank>signed<S2SV_blank>bounds,<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>with<S2SV_blank>it<S2SV_blank>prohibited<S2SV_blank>for<S2SV_blank>!root\\n" , off_reg == dst_reg ? dst : src ) ; return - EACCES ; } default : break ; } dst_reg -> type = ptr_reg -> type ; dst_reg -> id = ptr_reg -> id ; if ( ! check_reg_sane_offset ( env , off_reg , ptr_reg -> type ) || ! check_reg_sane_offset ( env , ptr_reg , ptr_reg -> type ) ) return - EINVAL ; switch ( opcode ) { case BPF_ADD : <S2SV_StartBug> if ( known && ( ptr_reg -> off + smin_val == <S2SV_EndBug> ( s64 ) ( s32 ) ( ptr_reg -> off + smin_val ) ) ) { dst_reg -> smin_value = smin_ptr ; dst_reg -> smax_value = smax_ptr ; dst_reg -> umin_value = umin_ptr ; dst_reg -> umax_value = umax_ptr ; dst_reg -> var_off = ptr_reg -> var_off ; dst_reg -> off = ptr_reg -> off + smin_val ; dst_reg -> raw = ptr_reg -> raw ; break ; } if ( signed_add_overflows ( smin_ptr , smin_val ) || signed_add_overflows ( smax_ptr , smax_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = smin_ptr + smin_val ; dst_reg -> smax_value = smax_ptr + smax_val ; } if ( umin_ptr + umin_val < umin_ptr || umax_ptr + umax_val < umax_ptr ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value = umin_ptr + umin_val ; dst_reg -> umax_value = umax_ptr + umax_val ; } dst_reg -> var_off = tnum_add ( ptr_reg -> var_off , off_reg -> var_off ) ; dst_reg -> off = ptr_reg -> off ; dst_reg -> raw = ptr_reg -> raw ; if ( reg_is_pkt_pointer ( ptr_reg ) ) { dst_reg -> id = ++ env -> id_gen ; dst_reg -> raw = 0 ; } break ; case BPF_SUB : <S2SV_StartBug> if ( dst_reg == off_reg ) { <S2SV_EndBug> verbose ( env , "R%d<S2SV_blank>tried<S2SV_blank>to<S2SV_blank>subtract<S2SV_blank>pointer<S2SV_blank>from<S2SV_blank>scalar\\n" , dst ) ; return - EACCES ; } if ( ptr_reg -> type == PTR_TO_STACK ) { verbose ( env , "R%d<S2SV_blank>subtraction<S2SV_blank>from<S2SV_blank>stack<S2SV_blank>pointer<S2SV_blank>prohibited\\n" , dst ) ; return - EACCES ; } if ( known && ( ptr_reg -> off - smin_val == ( s64 ) ( s32 ) ( ptr_reg -> off - smin_val ) ) ) { dst_reg -> smin_value = smin_ptr ; dst_reg -> smax_value = smax_ptr ; dst_reg -> umin_value = umin_ptr ; dst_reg -> umax_value = umax_ptr ; dst_reg -> var_off = ptr_reg -> var_off ; dst_reg -> id = ptr_reg -> id ; dst_reg -> off = ptr_reg -> off - smin_val ; dst_reg -> raw = ptr_reg -> raw ; break ; } if ( signed_sub_overflows ( smin_ptr , smax_val ) || signed_sub_overflows ( smax_ptr , smin_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = smin_ptr - smax_val ; dst_reg -> smax_value = smax_ptr - smin_val ; } if ( umin_ptr < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value = umin_ptr - umax_val ; dst_reg -> umax_value = umax_ptr - umin_val ; } dst_reg -> var_off = tnum_sub ( ptr_reg -> var_off , off_reg -> var_off ) ; dst_reg -> off = ptr_reg -> off ; dst_reg -> raw = ptr_reg -> raw ; if ( reg_is_pkt_pointer ( ptr_reg ) ) { dst_reg -> id = ++ env -> id_gen ; if ( smin_val < 0 ) dst_reg -> raw = 0 ; } break ; case BPF_AND : case BPF_OR : case BPF_XOR : verbose ( env , "R%d<S2SV_blank>bitwise<S2SV_blank>operator<S2SV_blank>%s<S2SV_blank>on<S2SV_blank>pointer<S2SV_blank>prohibited\\n" , dst , bpf_alu_string [ opcode >> 4 ] ) ; return - EACCES ; default : verbose ( env , "R%d<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>with<S2SV_blank>%s<S2SV_blank>operator<S2SV_blank>prohibited\\n" , dst , bpf_alu_string [ opcode >> 4 ] ) ; return - EACCES ; } if ( ! check_reg_sane_offset ( env , dst_reg , ptr_reg -> type ) ) return - EINVAL ; __update_reg_bounds ( dst_reg ) ; __reg_deduce_bounds ( dst_reg ) ; __reg_bound_offset ( dst_reg ) ; if ( ! env -> allow_ptr_leaks ) { if ( dst_reg -> type == PTR_TO_MAP_VALUE && check_map_access ( env , dst , dst_reg -> off , 1 , false ) ) { verbose ( env , "R%d<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>of<S2SV_blank>map<S2SV_blank>value<S2SV_blank>goes<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range,<S2SV_blank>" "prohibited<S2SV_blank>for<S2SV_blank>!root\\n" , dst ) ; return - EACCES ; } else if ( dst_reg -> type == PTR_TO_STACK && check_stack_access ( env , dst_reg , dst_reg -> off + dst_reg -> var_off . value , 1 ) ) { verbose ( env , "R%d<S2SV_blank>stack<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>goes<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range,<S2SV_blank>" "prohibited<S2SV_blank>for<S2SV_blank>!root\\n" , dst ) ; return - EACCES ; } } return 0 ; }
CWE-189 static int check_cond_jmp_op ( struct bpf_verifier_env * env , struct bpf_insn * insn , int * insn_idx ) { struct bpf_verifier_state * this_branch = env -> cur_state ; struct bpf_verifier_state * other_branch ; struct bpf_reg_state * regs = this_branch -> frame [ this_branch -> curframe ] -> regs ; struct bpf_reg_state * dst_reg , * other_branch_regs ; u8 opcode = BPF_OP ( insn -> code ) ; int err ; if ( opcode > BPF_JSLE ) { verbose ( env , "invalid<S2SV_blank>BPF_JMP<S2SV_blank>opcode<S2SV_blank>%x\\n" , opcode ) ; return - EINVAL ; } if ( BPF_SRC ( insn -> code ) == BPF_X ) { if ( insn -> imm != 0 ) { verbose ( env , "BPF_JMP<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n" ) ; return - EINVAL ; } err = check_reg_arg ( env , insn -> src_reg , SRC_OP ) ; if ( err ) return err ; if ( is_pointer_value ( env , insn -> src_reg ) ) { verbose ( env , "R%d<S2SV_blank>pointer<S2SV_blank>comparison<S2SV_blank>prohibited\\n" , insn -> src_reg ) ; return - EACCES ; } } else { if ( insn -> src_reg != BPF_REG_0 ) { verbose ( env , "BPF_JMP<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n" ) ; return - EINVAL ; } } err = check_reg_arg ( env , insn -> dst_reg , SRC_OP ) ; if ( err ) return err ; dst_reg = & regs [ insn -> dst_reg ] ; if ( BPF_SRC ( insn -> code ) == BPF_K ) { int pred = is_branch_taken ( dst_reg , insn -> imm , opcode ) ; if ( pred == 1 ) { * insn_idx += insn -> off ; return 0 ; } else if ( pred == 0 ) { return 0 ; } } <S2SV_StartBug> other_branch = push_stack ( env , * insn_idx + insn -> off + 1 , * insn_idx ) ; <S2SV_EndBug> if ( ! other_branch ) return - EFAULT ; other_branch_regs = other_branch -> frame [ other_branch -> curframe ] -> regs ; if ( BPF_SRC ( insn -> code ) == BPF_X ) { if ( dst_reg -> type == SCALAR_VALUE && regs [ insn -> src_reg ] . type == SCALAR_VALUE ) { if ( tnum_is_const ( regs [ insn -> src_reg ] . var_off ) ) reg_set_min_max ( & other_branch_regs [ insn -> dst_reg ] , dst_reg , regs [ insn -> src_reg ] . var_off . value , opcode ) ; else if ( tnum_is_const ( dst_reg -> var_off ) ) reg_set_min_max_inv ( & other_branch_regs [ insn -> src_reg ] , & regs [ insn -> src_reg ] , dst_reg -> var_off . value , opcode ) ; else if ( opcode == BPF_JEQ || opcode == BPF_JNE ) reg_combine_min_max ( & other_branch_regs [ insn -> src_reg ] , & other_branch_regs [ insn -> dst_reg ] , & regs [ insn -> src_reg ] , & regs [ insn -> dst_reg ] , opcode ) ; } } else if ( dst_reg -> type == SCALAR_VALUE ) { reg_set_min_max ( & other_branch_regs [ insn -> dst_reg ] , dst_reg , insn -> imm , opcode ) ; } if ( BPF_SRC ( insn -> code ) == BPF_K && insn -> imm == 0 && ( opcode == BPF_JEQ || opcode == BPF_JNE ) && reg_type_may_be_null ( dst_reg -> type ) ) { mark_ptr_or_null_regs ( this_branch , insn -> dst_reg , opcode == BPF_JNE ) ; mark_ptr_or_null_regs ( other_branch , insn -> dst_reg , opcode == BPF_JEQ ) ; } else if ( ! try_match_pkt_pointers ( insn , dst_reg , & regs [ insn -> src_reg ] , this_branch , other_branch ) && is_pointer_value ( env , insn -> dst_reg ) ) { verbose ( env , "R%d<S2SV_blank>pointer<S2SV_blank>comparison<S2SV_blank>prohibited\\n" , insn -> dst_reg ) ; return - EACCES ; } if ( env -> log . level ) print_verifier_state ( env , this_branch -> frame [ this_branch -> curframe ] ) ; return 0 ; }
CWE-189 static int copy_verifier_state ( struct bpf_verifier_state * dst_state , const struct bpf_verifier_state * src ) { struct bpf_func_state * dst ; int i , err ; for ( i = src -> curframe + 1 ; i <= dst_state -> curframe ; i ++ ) { free_func_state ( dst_state -> frame [ i ] ) ; dst_state -> frame [ i ] = NULL ; <S2SV_StartBug> } <S2SV_EndBug> dst_state -> curframe = src -> curframe ; for ( i = 0 ; i <= src -> curframe ; i ++ ) { dst = dst_state -> frame [ i ] ; if ( ! dst ) { dst = kzalloc ( sizeof ( * dst ) , GFP_KERNEL ) ; if ( ! dst ) return - ENOMEM ; dst_state -> frame [ i ] = dst ; } err = copy_func_state ( dst , src -> frame [ i ] ) ; if ( err ) return err ; } return 0 ; }
CWE-189 static int do_check ( struct bpf_verifier_env * env ) { struct bpf_verifier_state * state ; struct bpf_insn * insns = env -> prog -> insnsi ; struct bpf_reg_state * regs ; int insn_cnt = env -> prog -> len , i ; int insn_processed = 0 ; bool do_print_state = false ; env -> prev_linfo = NULL ; state = kzalloc ( sizeof ( struct bpf_verifier_state ) , GFP_KERNEL ) ; if ( ! state ) return - ENOMEM ; state -> curframe = 0 ; <S2SV_StartBug> state -> frame [ 0 ] = kzalloc ( sizeof ( struct bpf_func_state ) , GFP_KERNEL ) ; <S2SV_EndBug> if ( ! state -> frame [ 0 ] ) { kfree ( state ) ; return - ENOMEM ; } env -> cur_state = state ; init_func_state ( env , state -> frame [ 0 ] , BPF_MAIN_FUNC , 0 , 0 ) ; for ( ; ; ) { struct bpf_insn * insn ; u8 class ; int err ; if ( env -> insn_idx >= insn_cnt ) { verbose ( env , "invalid<S2SV_blank>insn<S2SV_blank>idx<S2SV_blank>%d<S2SV_blank>insn_cnt<S2SV_blank>%d\\n" , env -> insn_idx , insn_cnt ) ; return - EFAULT ; } insn = & insns [ env -> insn_idx ] ; class = BPF_CLASS ( insn -> code ) ; if ( ++ insn_processed > BPF_COMPLEXITY_LIMIT_INSNS ) { verbose ( env , "BPF<S2SV_blank>program<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large.<S2SV_blank>Processed<S2SV_blank>%d<S2SV_blank>insn\\n" , insn_processed ) ; return - E2BIG ; } err = is_state_visited ( env , env -> insn_idx ) ; if ( err < 0 ) return err ; if ( err == 1 ) { if ( env -> log . level ) { if ( do_print_state ) <S2SV_StartBug> verbose ( env , "\\nfrom<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%d:<S2SV_blank>safe\\n" , <S2SV_EndBug> <S2SV_StartBug> env -> prev_insn_idx , env -> insn_idx ) ; <S2SV_EndBug> else verbose ( env , "%d:<S2SV_blank>safe\\n" , env -> insn_idx ) ; } goto process_bpf_exit ; } if ( signal_pending ( current ) ) return - EAGAIN ; if ( need_resched ( ) ) cond_resched ( ) ; if ( env -> log . level > 1 || ( env -> log . level && do_print_state ) ) { if ( env -> log . level > 1 ) verbose ( env , "%d:" , env -> insn_idx ) ; else <S2SV_StartBug> verbose ( env , "\\nfrom<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%d:" , <S2SV_EndBug> <S2SV_StartBug> env -> prev_insn_idx , env -> insn_idx ) ; <S2SV_EndBug> print_verifier_state ( env , state -> frame [ state -> curframe ] ) ; do_print_state = false ; } if ( env -> log . level ) { const struct bpf_insn_cbs cbs = { . cb_print = verbose , . private_data = env , } ; verbose_linfo ( env , env -> insn_idx , ";<S2SV_blank>" ) ; verbose ( env , "%d:<S2SV_blank>" , env -> insn_idx ) ; print_bpf_insn ( & cbs , insn , env -> allow_ptr_leaks ) ; } if ( bpf_prog_is_dev_bound ( env -> prog -> aux ) ) { err = bpf_prog_offload_verify_insn ( env , env -> insn_idx , env -> prev_insn_idx ) ; if ( err ) return err ; } regs = cur_regs ( env ) ; env -> insn_aux_data [ env -> insn_idx ] . seen = true ; if ( class == BPF_ALU || class == BPF_ALU64 ) { err = check_alu_op ( env , insn ) ; if ( err ) return err ; } else if ( class == BPF_LDX ) { enum bpf_reg_type * prev_src_type , src_reg_type ; err = check_reg_arg ( env , insn -> src_reg , SRC_OP ) ; if ( err ) return err ; err = check_reg_arg ( env , insn -> dst_reg , DST_OP_NO_MARK ) ; if ( err ) return err ; src_reg_type = regs [ insn -> src_reg ] . type ; err = check_mem_access ( env , env -> insn_idx , insn -> src_reg , insn -> off , BPF_SIZE ( insn -> code ) , BPF_READ , insn -> dst_reg , false ) ; if ( err ) return err ; prev_src_type = & env -> insn_aux_data [ env -> insn_idx ] . ptr_type ; if ( * prev_src_type == NOT_INIT ) { * prev_src_type = src_reg_type ; } else if ( reg_type_mismatch ( src_reg_type , * prev_src_type ) ) { verbose ( env , "same<S2SV_blank>insn<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>used<S2SV_blank>with<S2SV_blank>different<S2SV_blank>pointers\\n" ) ; return - EINVAL ; } } else if ( class == BPF_STX ) { enum bpf_reg_type * prev_dst_type , dst_reg_type ; if ( BPF_MODE ( insn -> code ) == BPF_XADD ) { err = check_xadd ( env , env -> insn_idx , insn ) ; if ( err ) return err ; env -> insn_idx ++ ; continue ; } err = check_reg_arg ( env , insn -> src_reg , SRC_OP ) ; if ( err ) return err ; err = check_reg_arg ( env , insn -> dst_reg , SRC_OP ) ; if ( err ) return err ; dst_reg_type = regs [ insn -> dst_reg ] . type ; err = check_mem_access ( env , env -> insn_idx , insn -> dst_reg , insn -> off , BPF_SIZE ( insn -> code ) , BPF_WRITE , insn -> src_reg , false ) ; if ( err ) return err ; prev_dst_type = & env -> insn_aux_data [ env -> insn_idx ] . ptr_type ; if ( * prev_dst_type == NOT_INIT ) { * prev_dst_type = dst_reg_type ; } else if ( reg_type_mismatch ( dst_reg_type , * prev_dst_type ) ) { verbose ( env , "same<S2SV_blank>insn<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>used<S2SV_blank>with<S2SV_blank>different<S2SV_blank>pointers\\n" ) ; return - EINVAL ; } } else if ( class == BPF_ST ) { if ( BPF_MODE ( insn -> code ) != BPF_MEM || insn -> src_reg != BPF_REG_0 ) { verbose ( env , "BPF_ST<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n" ) ; return - EINVAL ; } err = check_reg_arg ( env , insn -> dst_reg , SRC_OP ) ; if ( err ) return err ; if ( is_ctx_reg ( env , insn -> dst_reg ) ) { verbose ( env , "BPF_ST<S2SV_blank>stores<S2SV_blank>into<S2SV_blank>R%d<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>allowed\\n" , insn -> dst_reg , reg_type_str [ reg_state ( env , insn -> dst_reg ) -> type ] ) ; return - EACCES ; } err = check_mem_access ( env , env -> insn_idx , insn -> dst_reg , insn -> off , BPF_SIZE ( insn -> code ) , BPF_WRITE , - 1 , false ) ; if ( err ) return err ; } else if ( class == BPF_JMP ) { u8 opcode = BPF_OP ( insn -> code ) ; if ( opcode == BPF_CALL ) { if ( BPF_SRC ( insn -> code ) != BPF_K || insn -> off != 0 || ( insn -> src_reg != BPF_REG_0 && insn -> src_reg != BPF_PSEUDO_CALL ) || insn -> dst_reg != BPF_REG_0 ) { verbose ( env , "BPF_CALL<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n" ) ; return - EINVAL ; } if ( insn -> src_reg == BPF_PSEUDO_CALL ) err = check_func_call ( env , insn , & env -> insn_idx ) ; else err = check_helper_call ( env , insn -> imm , env -> insn_idx ) ; if ( err ) return err ; } else if ( opcode == BPF_JA ) { if ( BPF_SRC ( insn -> code ) != BPF_K || insn -> imm != 0 || insn -> src_reg != BPF_REG_0 || insn -> dst_reg != BPF_REG_0 ) { verbose ( env , "BPF_JA<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n" ) ; return - EINVAL ; } env -> insn_idx += insn -> off + 1 ; continue ; } else if ( opcode == BPF_EXIT ) { if ( BPF_SRC ( insn -> code ) != BPF_K || insn -> imm != 0 || insn -> src_reg != BPF_REG_0 || insn -> dst_reg != BPF_REG_0 ) { verbose ( env , "BPF_EXIT<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n" ) ; return - EINVAL ; } if ( state -> curframe ) { env -> prev_insn_idx = env -> insn_idx ; err = prepare_func_exit ( env , & env -> insn_idx ) ; if ( err ) return err ; do_print_state = true ; continue ; } err = check_reference_leak ( env ) ; if ( err ) return err ; err = check_reg_arg ( env , BPF_REG_0 , SRC_OP ) ; if ( err ) return err ; if ( is_pointer_value ( env , BPF_REG_0 ) ) { verbose ( env , "R0<S2SV_blank>leaks<S2SV_blank>addr<S2SV_blank>as<S2SV_blank>return<S2SV_blank>value\\n" ) ; return - EACCES ; } err = check_return_code ( env ) ; if ( err ) return err ; process_bpf_exit : err = pop_stack ( env , & env -> prev_insn_idx , & env -> insn_idx ) ; if ( err < 0 ) { if ( err != - ENOENT ) return err ; break ; } else { do_print_state = true ; continue ; } } else { err = check_cond_jmp_op ( env , insn , & env -> insn_idx ) ; if ( err ) return err ; } } else if ( class == BPF_LD ) { u8 mode = BPF_MODE ( insn -> code ) ; if ( mode == BPF_ABS || mode == BPF_IND ) { err = check_ld_abs ( env , insn ) ; if ( err ) return err ; } else if ( mode == BPF_IMM ) { err = check_ld_imm ( env , insn ) ; if ( err ) return err ; env -> insn_idx ++ ; env -> insn_aux_data [ env -> insn_idx ] . seen = true ; } else { verbose ( env , "invalid<S2SV_blank>BPF_LD<S2SV_blank>mode\\n" ) ; return - EINVAL ; } } else { verbose ( env , "unknown<S2SV_blank>insn<S2SV_blank>class<S2SV_blank>%d\\n" , class ) ; return - EINVAL ; } env -> insn_idx ++ ; } verbose ( env , "processed<S2SV_blank>%d<S2SV_blank>insns<S2SV_blank>(limit<S2SV_blank>%d),<S2SV_blank>stack<S2SV_blank>depth<S2SV_blank>" , insn_processed , BPF_COMPLEXITY_LIMIT_INSNS ) ; for ( i = 0 ; i < env -> subprog_cnt ; i ++ ) { u32 depth = env -> subprog_info [ i ] . stack_depth ; verbose ( env , "%d" , depth ) ; if ( i + 1 < env -> subprog_cnt ) verbose ( env , "+" ) ; } verbose ( env , "\\n" ) ; env -> prog -> aux -> stack_depth = env -> subprog_info [ 0 ] . stack_depth ; return 0 ; }
CWE-189 static int fixup_bpf_calls ( struct bpf_verifier_env * env ) { struct bpf_prog * prog = env -> prog ; struct bpf_insn * insn = prog -> insnsi ; const struct bpf_func_proto * fn ; const int insn_cnt = prog -> len ; const struct bpf_map_ops * ops ; struct bpf_insn_aux_data * aux ; struct bpf_insn insn_buf [ 16 ] ; struct bpf_prog * new_prog ; struct bpf_map * map_ptr ; int i , cnt , delta = 0 ; for ( i = 0 ; i < insn_cnt ; i ++ , insn ++ ) { if ( insn -> code == ( BPF_ALU64 | BPF_MOD | BPF_X ) || insn -> code == ( BPF_ALU64 | BPF_DIV | BPF_X ) || insn -> code == ( BPF_ALU | BPF_MOD | BPF_X ) || insn -> code == ( BPF_ALU | BPF_DIV | BPF_X ) ) { bool is64 = BPF_CLASS ( insn -> code ) == BPF_ALU64 ; struct bpf_insn mask_and_div [ ] = { BPF_MOV32_REG ( insn -> src_reg , insn -> src_reg ) , BPF_JMP_IMM ( BPF_JNE , insn -> src_reg , 0 , 2 ) , BPF_ALU32_REG ( BPF_XOR , insn -> dst_reg , insn -> dst_reg ) , BPF_JMP_IMM ( BPF_JA , 0 , 0 , 1 ) , * insn , } ; struct bpf_insn mask_and_mod [ ] = { BPF_MOV32_REG ( insn -> src_reg , insn -> src_reg ) , BPF_JMP_IMM ( BPF_JEQ , insn -> src_reg , 0 , 1 ) , * insn , } ; struct bpf_insn * patchlet ; if ( insn -> code == ( BPF_ALU64 | BPF_DIV | BPF_X ) || insn -> code == ( BPF_ALU | BPF_DIV | BPF_X ) ) { patchlet = mask_and_div + ( is64 ? 1 : 0 ) ; cnt = ARRAY_SIZE ( mask_and_div ) - ( is64 ? 1 : 0 ) ; } else { patchlet = mask_and_mod + ( is64 ? 1 : 0 ) ; cnt = ARRAY_SIZE ( mask_and_mod ) - ( is64 ? 1 : 0 ) ; } new_prog = bpf_patch_insn_data ( env , i + delta , patchlet , cnt ) ; if ( ! new_prog ) return - ENOMEM ; delta += cnt - 1 ; env -> prog = prog = new_prog ; insn = new_prog -> insnsi + i + delta ; continue ; } if ( BPF_CLASS ( insn -> code ) == BPF_LD && ( BPF_MODE ( insn -> code ) == BPF_ABS || BPF_MODE ( insn -> code ) == BPF_IND ) ) { cnt = env -> ops -> gen_ld_abs ( insn , insn_buf ) ; if ( cnt == 0 || cnt >= ARRAY_SIZE ( insn_buf ) ) { verbose ( env , "bpf<S2SV_blank>verifier<S2SV_blank>is<S2SV_blank>misconfigured\\n" ) ; return - EINVAL ; } new_prog = bpf_patch_insn_data ( env , i + delta , insn_buf , cnt ) ; if ( ! new_prog ) return - ENOMEM ; delta += cnt - 1 ; env -> prog = prog = new_prog ; insn = new_prog -> insnsi + i + delta ; continue ; } <S2SV_StartBug> if ( insn -> code != ( BPF_JMP | BPF_CALL ) ) <S2SV_EndBug> continue ; if ( insn -> src_reg == BPF_PSEUDO_CALL ) continue ; if ( insn -> imm == BPF_FUNC_get_route_realm ) prog -> dst_needed = 1 ; if ( insn -> imm == BPF_FUNC_get_prandom_u32 ) bpf_user_rnd_init_once ( ) ; if ( insn -> imm == BPF_FUNC_override_return ) prog -> kprobe_override = 1 ; if ( insn -> imm == BPF_FUNC_tail_call ) { prog -> cb_access = 1 ; env -> prog -> aux -> stack_depth = MAX_BPF_STACK ; env -> prog -> aux -> max_pkt_offset = MAX_PACKET_OFF ; insn -> imm = 0 ; insn -> code = BPF_JMP | BPF_TAIL_CALL ; aux = & env -> insn_aux_data [ i + delta ] ; <S2SV_StartBug> if ( ! bpf_map_ptr_unpriv ( aux ) ) <S2SV_EndBug> continue ; <S2SV_StartBug> if ( bpf_map_ptr_poisoned ( aux ) ) { <S2SV_EndBug> verbose ( env , "tail_call<S2SV_blank>abusing<S2SV_blank>map_ptr\\n" ) ; return - EINVAL ; } map_ptr = BPF_MAP_PTR ( aux -> map_state ) ; insn_buf [ 0 ] = BPF_JMP_IMM ( BPF_JGE , BPF_REG_3 , map_ptr -> max_entries , 2 ) ; insn_buf [ 1 ] = BPF_ALU32_IMM ( BPF_AND , BPF_REG_3 , container_of ( map_ptr , struct bpf_array , map ) -> index_mask ) ; insn_buf [ 2 ] = * insn ; cnt = 3 ; new_prog = bpf_patch_insn_data ( env , i + delta , insn_buf , cnt ) ; if ( ! new_prog ) return - ENOMEM ; delta += cnt - 1 ; env -> prog = prog = new_prog ; insn = new_prog -> insnsi + i + delta ; continue ; } <S2SV_StartBug> if ( prog -> jit_requested && BITS_PER_LONG == 64 && <S2SV_EndBug> ( insn -> imm == BPF_FUNC_map_lookup_elem || insn -> imm == BPF_FUNC_map_update_elem || insn -> imm == BPF_FUNC_map_delete_elem || insn -> imm == BPF_FUNC_map_push_elem || insn -> imm == BPF_FUNC_map_pop_elem || insn -> imm == BPF_FUNC_map_peek_elem ) ) { aux = & env -> insn_aux_data [ i + delta ] ; <S2SV_StartBug> if ( bpf_map_ptr_poisoned ( aux ) ) <S2SV_EndBug> <S2SV_StartBug> goto patch_call_imm ; <S2SV_EndBug> map_ptr = BPF_MAP_PTR ( aux -> map_state ) ; <S2SV_StartBug> ops = map_ptr -> ops ; <S2SV_EndBug> if ( insn -> imm == BPF_FUNC_map_lookup_elem && ops -> map_gen_lookup ) { <S2SV_StartBug> cnt = ops -> map_gen_lookup ( map_ptr , insn_buf ) ; <S2SV_EndBug> if ( cnt == 0 || cnt >= ARRAY_SIZE ( insn_buf ) ) { verbose ( env , "bpf<S2SV_blank>verifier<S2SV_blank>is<S2SV_blank>misconfigured\\n" ) ; return - EINVAL ; } new_prog = bpf_patch_insn_data ( env , i + delta , insn_buf , cnt ) ; if ( ! new_prog ) return - ENOMEM ; delta += cnt - 1 ; env -> prog = prog = new_prog ; insn = new_prog -> insnsi + i + delta ; continue ; } <S2SV_StartBug> BUILD_BUG_ON ( ! __same_type ( ops -> map_lookup_elem , <S2SV_EndBug> ( void * ( * ) ( struct bpf_map * map , void * key ) ) NULL ) ) ; BUILD_BUG_ON ( ! __same_type ( ops -> map_delete_elem , ( int ( * ) ( struct bpf_map * map , void * key ) ) NULL ) ) ; BUILD_BUG_ON ( ! __same_type ( ops -> map_update_elem , ( int ( * ) ( struct bpf_map * map , void * key , void * value , u64 flags ) ) NULL ) ) ; BUILD_BUG_ON ( ! __same_type ( ops -> map_push_elem , ( int ( * ) ( struct bpf_map * map , void * value , u64 flags ) ) NULL ) ) ; BUILD_BUG_ON ( ! __same_type ( ops -> map_pop_elem , ( int ( * ) ( struct bpf_map * map , void * value ) ) NULL ) ) ; BUILD_BUG_ON ( ! __same_type ( ops -> map_peek_elem , ( int ( * ) ( struct bpf_map * map , void * value ) ) NULL ) ) ; switch ( insn -> imm ) { case BPF_FUNC_map_lookup_elem : insn -> imm = BPF_CAST_CALL ( ops -> map_lookup_elem ) - __bpf_call_base ; continue ; case BPF_FUNC_map_update_elem : insn -> imm = BPF_CAST_CALL ( ops -> map_update_elem ) - __bpf_call_base ; continue ; case BPF_FUNC_map_delete_elem : insn -> imm = BPF_CAST_CALL ( ops -> map_delete_elem ) - __bpf_call_base ; continue ; case BPF_FUNC_map_push_elem : insn -> imm = BPF_CAST_CALL ( ops -> map_push_elem ) - __bpf_call_base ; continue ; case BPF_FUNC_map_pop_elem : insn -> imm = BPF_CAST_CALL ( ops -> map_pop_elem ) - __bpf_call_base ; continue ; case BPF_FUNC_map_peek_elem : insn -> imm = BPF_CAST_CALL ( ops -> map_peek_elem ) - __bpf_call_base ; continue ; } goto patch_call_imm ; } patch_call_imm : fn = env -> ops -> get_func_proto ( insn -> imm , env -> prog ) ; if ( ! fn -> func ) { verbose ( env , "kernel<S2SV_blank>subsystem<S2SV_blank>misconfigured<S2SV_blank>func<S2SV_blank>%s#%d\\n" , func_id_name ( insn -> imm ) , insn -> imm ) ; return - EFAULT ; } insn -> imm = fn -> func - __bpf_call_base ; } return 0 ; }
CWE-189 static struct bpf_verifier_state * push_stack ( struct bpf_verifier_env * env , <S2SV_StartBug> int insn_idx , int prev_insn_idx ) <S2SV_EndBug> { struct bpf_verifier_state * cur = env -> cur_state ; struct bpf_verifier_stack_elem * elem ; int err ; elem = kzalloc ( sizeof ( struct bpf_verifier_stack_elem ) , GFP_KERNEL ) ; if ( ! elem ) goto err ; elem -> insn_idx = insn_idx ; elem -> prev_insn_idx = prev_insn_idx ; elem -> next = env -> head ; env -> head = elem ; env -> stack_size ++ ; err = copy_verifier_state ( & elem -> st , cur ) ; if ( err ) <S2SV_StartBug> goto err ; <S2SV_EndBug> if ( env -> stack_size > BPF_COMPLEXITY_LIMIT_STACK ) { verbose ( env , "BPF<S2SV_blank>program<S2SV_blank>is<S2SV_blank>too<S2SV_blank>complex\\n" ) ; goto err ; } return & elem -> st ; err : free_verifier_state ( env -> cur_state , true ) ; env -> cur_state = NULL ; while ( ! pop_stack ( env , NULL , NULL ) ) ; return NULL ; }
CWE-189 static bool states_equal ( struct bpf_verifier_env * env , struct bpf_verifier_state * old , struct bpf_verifier_state * cur ) { int i ; <S2SV_StartBug> if ( old -> curframe != cur -> curframe ) <S2SV_EndBug> return false ; for ( i = 0 ; i <= old -> curframe ; i ++ ) { if ( old -> frame [ i ] -> callsite != cur -> frame [ i ] -> callsite ) return false ; if ( ! func_states_equal ( old -> frame [ i ] , cur -> frame [ i ] ) ) return false ; } return true ; }
CWE-476 static int hi3660_stub_clk_probe ( struct platform_device * pdev ) { struct device * dev = & pdev -> dev ; struct resource * res ; unsigned int i ; int ret ; stub_clk_chan . cl . dev = dev ; stub_clk_chan . cl . tx_done = NULL ; stub_clk_chan . cl . tx_block = false ; stub_clk_chan . cl . knows_txdone = false ; stub_clk_chan . mbox = mbox_request_channel ( & stub_clk_chan . cl , 0 ) ; if ( IS_ERR ( stub_clk_chan . mbox ) ) return PTR_ERR ( stub_clk_chan . mbox ) ; res = platform_get_resource ( pdev , IORESOURCE_MEM , 0 ) ; <S2SV_StartBug> freq_reg = devm_ioremap ( dev , res -> start , resource_size ( res ) ) ; <S2SV_EndBug> if ( ! freq_reg ) return - ENOMEM ; freq_reg += HI3660_STUB_CLOCK_DATA ; for ( i = 0 ; i < HI3660_CLK_STUB_NUM ; i ++ ) { ret = devm_clk_hw_register ( & pdev -> dev , & hi3660_stub_clks [ i ] . hw ) ; if ( ret ) return ret ; } return devm_of_clk_add_hw_provider ( & pdev -> dev , hi3660_stub_clk_hw_get , hi3660_stub_clks ) ; }
CWE-415 int blkcg_init_queue ( struct request_queue * q ) { struct blkcg_gq * new_blkg , * blkg ; bool preloaded ; int ret ; new_blkg = blkg_alloc ( & blkcg_root , q , GFP_KERNEL ) ; if ( ! new_blkg ) return - ENOMEM ; preloaded = ! radix_tree_preload ( GFP_KERNEL ) ; rcu_read_lock ( ) ; spin_lock_irq ( q -> queue_lock ) ; blkg = blkg_create ( & blkcg_root , q , new_blkg ) ; spin_unlock_irq ( q -> queue_lock ) ; rcu_read_unlock ( ) ; if ( preloaded ) radix_tree_preload_end ( ) ; <S2SV_StartBug> if ( IS_ERR ( blkg ) ) { <S2SV_EndBug> blkg_free ( new_blkg ) ; return PTR_ERR ( blkg ) ; <S2SV_StartBug> } <S2SV_EndBug> q -> root_blkg = blkg ; q -> root_rl . blkg = blkg ; ret = blk_throtl_init ( q ) ; if ( ret ) { spin_lock_irq ( q -> queue_lock ) ; blkg_destroy_all ( q ) ; spin_unlock_irq ( q -> queue_lock ) ; } return ret ; }
CWE-119 static int cdrom_ioctl_media_changed ( struct cdrom_device_info * cdi , unsigned long arg ) { struct cdrom_changer_info * info ; int ret ; cd_dbg ( CD_DO_IOCTL , "entering<S2SV_blank>CDROM_MEDIA_CHANGED\\n" ) ; if ( ! CDROM_CAN ( CDC_MEDIA_CHANGED ) ) return - ENOSYS ; if ( ! CDROM_CAN ( CDC_SELECT_DISC ) || arg == CDSL_CURRENT ) return media_changed ( cdi , 1 ) ; <S2SV_StartBug> if ( ( unsigned int ) arg >= cdi -> capacity ) <S2SV_EndBug> return - EINVAL ; info = kmalloc ( sizeof ( * info ) , GFP_KERNEL ) ; if ( ! info ) return - ENOMEM ; ret = cdrom_read_mech_status ( cdi , info ) ; if ( ! ret ) ret = info -> slots [ arg ] . change ; kfree ( info ) ; return ret ; }
CWE-190 static int uvesafb_setcmap ( struct fb_cmap * cmap , struct fb_info * info ) { struct uvesafb_pal_entry * entries ; int shift = 16 - dac_width ; int i , err = 0 ; if ( info -> var . bits_per_pixel == 8 ) { if ( cmap -> start + cmap -> len > info -> cmap . start + info -> cmap . len || cmap -> start < info -> cmap . start ) return - EINVAL ; <S2SV_StartBug> entries = kmalloc ( sizeof ( * entries ) * cmap -> len , GFP_KERNEL ) ; <S2SV_EndBug> if ( ! entries ) return - ENOMEM ; for ( i = 0 ; i < cmap -> len ; i ++ ) { entries [ i ] . red = cmap -> red [ i ] >> shift ; entries [ i ] . green = cmap -> green [ i ] >> shift ; entries [ i ] . blue = cmap -> blue [ i ] >> shift ; entries [ i ] . pad = 0 ; } err = uvesafb_setpalette ( entries , cmap -> len , cmap -> start , info ) ; kfree ( entries ) ; } else { for ( i = 0 ; i < cmap -> len ; i ++ ) { err |= uvesafb_setcolreg ( cmap -> start + i , cmap -> red [ i ] , cmap -> green [ i ] , cmap -> blue [ i ] , 0 , info ) ; } } return err ; }
CWE-77 static int do_hidp_sock_ioctl ( struct socket * sock , unsigned int cmd , void __user * argp ) { struct hidp_connadd_req ca ; struct hidp_conndel_req cd ; struct hidp_connlist_req cl ; struct hidp_conninfo ci ; struct socket * csock ; struct socket * isock ; int err ; BT_DBG ( "cmd<S2SV_blank>%x<S2SV_blank>arg<S2SV_blank>%p" , cmd , argp ) ; switch ( cmd ) { case HIDPCONNADD : if ( ! capable ( CAP_NET_ADMIN ) ) return - EPERM ; if ( copy_from_user ( & ca , argp , sizeof ( ca ) ) ) return - EFAULT ; csock = sockfd_lookup ( ca . ctrl_sock , & err ) ; if ( ! csock ) return err ; isock = sockfd_lookup ( ca . intr_sock , & err ) ; if ( ! isock ) { sockfd_put ( csock ) ; return err ; <S2SV_StartBug> } <S2SV_EndBug> err = hidp_connection_add ( & ca , csock , isock ) ; if ( ! err && copy_to_user ( argp , & ca , sizeof ( ca ) ) ) err = - EFAULT ; sockfd_put ( csock ) ; sockfd_put ( isock ) ; return err ; case HIDPCONNDEL : if ( ! capable ( CAP_NET_ADMIN ) ) return - EPERM ; if ( copy_from_user ( & cd , argp , sizeof ( cd ) ) ) return - EFAULT ; return hidp_connection_del ( & cd ) ; case HIDPGETCONNLIST : if ( copy_from_user ( & cl , argp , sizeof ( cl ) ) ) return - EFAULT ; if ( cl . cnum <= 0 ) return - EINVAL ; err = hidp_get_connlist ( & cl ) ; if ( ! err && copy_to_user ( argp , & cl , sizeof ( cl ) ) ) return - EFAULT ; return err ; case HIDPGETCONNINFO : if ( copy_from_user ( & ci , argp , sizeof ( ci ) ) ) return - EFAULT ; err = hidp_get_conninfo ( & ci ) ; if ( ! err && copy_to_user ( argp , & ci , sizeof ( ci ) ) ) return - EFAULT ; return err ; } return - EINVAL ; }
CWE-416 static void lo_release ( struct gendisk * disk , fmode_t mode ) { <S2SV_StartBug> struct loop_device * lo = disk -> private_data ; <S2SV_EndBug> int err ; if ( atomic_dec_return ( & lo -> lo_refcnt ) ) return ; mutex_lock ( & lo -> lo_ctl_mutex ) ; if ( lo -> lo_flags & LO_FLAGS_AUTOCLEAR ) { err = loop_clr_fd ( lo ) ; if ( ! err ) return ; } else if ( lo -> lo_state == Lo_bound ) { blk_mq_freeze_queue ( lo -> lo_queue ) ; blk_mq_unfreeze_queue ( lo -> lo_queue ) ; } <S2SV_StartBug> mutex_unlock ( & lo -> lo_ctl_mutex ) ; <S2SV_EndBug> }
CWE-125 int SMB2_negotiate ( const unsigned int xid , struct cifs_ses * ses ) { struct smb_rqst rqst ; struct smb2_negotiate_req * req ; struct smb2_negotiate_rsp * rsp ; struct kvec iov [ 1 ] ; struct kvec rsp_iov ; int rc = 0 ; int resp_buftype ; struct TCP_Server_Info * server = ses -> server ; int blob_offset , blob_length ; char * security_blob ; int flags = CIFS_NEG_OP ; unsigned int total_len ; cifs_dbg ( FYI , "Negotiate<S2SV_blank>protocol\\n" ) ; if ( ! server ) { WARN ( 1 , "%s:<S2SV_blank>server<S2SV_blank>is<S2SV_blank>NULL!\\n" , __func__ ) ; return - EIO ; } rc = smb2_plain_req_init ( SMB2_NEGOTIATE , NULL , ( void * * ) & req , & total_len ) ; if ( rc ) return rc ; req -> sync_hdr . SessionId = 0 ; memset ( server -> preauth_sha_hash , 0 , SMB2_PREAUTH_HASH_SIZE ) ; memset ( ses -> preauth_sha_hash , 0 , SMB2_PREAUTH_HASH_SIZE ) ; if ( strcmp ( ses -> server -> vals -> version_string , SMB3ANY_VERSION_STRING ) == 0 ) { req -> Dialects [ 0 ] = cpu_to_le16 ( SMB30_PROT_ID ) ; req -> Dialects [ 1 ] = cpu_to_le16 ( SMB302_PROT_ID ) ; req -> DialectCount = cpu_to_le16 ( 2 ) ; total_len += 4 ; } else if ( strcmp ( ses -> server -> vals -> version_string , SMBDEFAULT_VERSION_STRING ) == 0 ) { req -> Dialects [ 0 ] = cpu_to_le16 ( SMB21_PROT_ID ) ; req -> Dialects [ 1 ] = cpu_to_le16 ( SMB30_PROT_ID ) ; req -> Dialects [ 2 ] = cpu_to_le16 ( SMB302_PROT_ID ) ; req -> Dialects [ 3 ] = cpu_to_le16 ( SMB311_PROT_ID ) ; req -> DialectCount = cpu_to_le16 ( 4 ) ; total_len += 8 ; } else { req -> Dialects [ 0 ] = cpu_to_le16 ( ses -> server -> vals -> protocol_id ) ; req -> DialectCount = cpu_to_le16 ( 1 ) ; total_len += 2 ; } if ( ses -> sign ) req -> SecurityMode = cpu_to_le16 ( SMB2_NEGOTIATE_SIGNING_REQUIRED ) ; else if ( global_secflags & CIFSSEC_MAY_SIGN ) req -> SecurityMode = cpu_to_le16 ( SMB2_NEGOTIATE_SIGNING_ENABLED ) ; else req -> SecurityMode = 0 ; req -> Capabilities = cpu_to_le32 ( ses -> server -> vals -> req_capabilities ) ; if ( ses -> server -> vals -> protocol_id == SMB20_PROT_ID ) memset ( req -> ClientGUID , 0 , SMB2_CLIENT_GUID_SIZE ) ; else { memcpy ( req -> ClientGUID , server -> client_guid , SMB2_CLIENT_GUID_SIZE ) ; if ( ( ses -> server -> vals -> protocol_id == SMB311_PROT_ID ) || ( strcmp ( ses -> server -> vals -> version_string , SMBDEFAULT_VERSION_STRING ) == 0 ) ) assemble_neg_contexts ( req , & total_len ) ; } iov [ 0 ] . iov_base = ( char * ) req ; iov [ 0 ] . iov_len = total_len ; memset ( & rqst , 0 , sizeof ( struct smb_rqst ) ) ; rqst . rq_iov = iov ; rqst . rq_nvec = 1 ; rc = cifs_send_recv ( xid , ses , & rqst , & resp_buftype , flags , & rsp_iov ) ; cifs_small_buf_release ( req ) ; rsp = ( struct smb2_negotiate_rsp * ) rsp_iov . iov_base ; if ( rc == - EOPNOTSUPP ) { cifs_dbg ( VFS , "Dialect<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>server.<S2SV_blank>Consider<S2SV_blank>" "specifying<S2SV_blank>vers=1.0<S2SV_blank>or<S2SV_blank>vers=2.0<S2SV_blank>on<S2SV_blank>mount<S2SV_blank>for<S2SV_blank>accessing" "<S2SV_blank>older<S2SV_blank>servers\\n" ) ; goto neg_exit ; } else if ( rc != 0 ) goto neg_exit ; if ( strcmp ( ses -> server -> vals -> version_string , SMB3ANY_VERSION_STRING ) == 0 ) { if ( rsp -> DialectRevision == cpu_to_le16 ( SMB20_PROT_ID ) ) { cifs_dbg ( VFS , "SMB2<S2SV_blank>dialect<S2SV_blank>returned<S2SV_blank>but<S2SV_blank>not<S2SV_blank>requested\\n" ) ; return - EIO ; } else if ( rsp -> DialectRevision == cpu_to_le16 ( SMB21_PROT_ID ) ) { cifs_dbg ( VFS , "SMB2.1<S2SV_blank>dialect<S2SV_blank>returned<S2SV_blank>but<S2SV_blank>not<S2SV_blank>requested\\n" ) ; return - EIO ; } } else if ( strcmp ( ses -> server -> vals -> version_string , SMBDEFAULT_VERSION_STRING ) == 0 ) { if ( rsp -> DialectRevision == cpu_to_le16 ( SMB20_PROT_ID ) ) { cifs_dbg ( VFS , "SMB2<S2SV_blank>dialect<S2SV_blank>returned<S2SV_blank>but<S2SV_blank>not<S2SV_blank>requested\\n" ) ; return - EIO ; } else if ( rsp -> DialectRevision == cpu_to_le16 ( SMB21_PROT_ID ) ) { ses -> server -> ops = & smb21_operations ; <S2SV_StartBug> } else if ( rsp -> DialectRevision == cpu_to_le16 ( SMB311_PROT_ID ) ) <S2SV_EndBug> <S2SV_StartBug> ses -> server -> ops = & smb311_operations ; <S2SV_EndBug> } else if ( le16_to_cpu ( rsp -> DialectRevision ) != ses -> server -> vals -> protocol_id ) { cifs_dbg ( VFS , "Illegal<S2SV_blank>0x%x<S2SV_blank>dialect<S2SV_blank>returned:<S2SV_blank>not<S2SV_blank>requested\\n" , le16_to_cpu ( rsp -> DialectRevision ) ) ; return - EIO ; } cifs_dbg ( FYI , "mode<S2SV_blank>0x%x\\n" , rsp -> SecurityMode ) ; if ( rsp -> DialectRevision == cpu_to_le16 ( SMB20_PROT_ID ) ) cifs_dbg ( FYI , "negotiated<S2SV_blank>smb2.0<S2SV_blank>dialect\\n" ) ; else if ( rsp -> DialectRevision == cpu_to_le16 ( SMB21_PROT_ID ) ) cifs_dbg ( FYI , "negotiated<S2SV_blank>smb2.1<S2SV_blank>dialect\\n" ) ; else if ( rsp -> DialectRevision == cpu_to_le16 ( SMB30_PROT_ID ) ) cifs_dbg ( FYI , "negotiated<S2SV_blank>smb3.0<S2SV_blank>dialect\\n" ) ; else if ( rsp -> DialectRevision == cpu_to_le16 ( SMB302_PROT_ID ) ) cifs_dbg ( FYI , "negotiated<S2SV_blank>smb3.02<S2SV_blank>dialect\\n" ) ; else if ( rsp -> DialectRevision == cpu_to_le16 ( SMB311_PROT_ID ) ) cifs_dbg ( FYI , "negotiated<S2SV_blank>smb3.1.1<S2SV_blank>dialect\\n" ) ; else { cifs_dbg ( VFS , "Illegal<S2SV_blank>dialect<S2SV_blank>returned<S2SV_blank>by<S2SV_blank>server<S2SV_blank>0x%x\\n" , le16_to_cpu ( rsp -> DialectRevision ) ) ; rc = - EIO ; goto neg_exit ; } server -> dialect = le16_to_cpu ( rsp -> DialectRevision ) ; memcpy ( server -> preauth_sha_hash , ses -> preauth_sha_hash , SMB2_PREAUTH_HASH_SIZE ) ; server -> negflavor = CIFS_NEGFLAVOR_EXTENDED ; server -> maxBuf = min_t ( unsigned int , le32_to_cpu ( rsp -> MaxTransactSize ) , SMB2_MAX_BUFFER_SIZE ) ; server -> max_read = le32_to_cpu ( rsp -> MaxReadSize ) ; server -> max_write = le32_to_cpu ( rsp -> MaxWriteSize ) ; server -> sec_mode = le16_to_cpu ( rsp -> SecurityMode ) ; if ( ( server -> sec_mode & SMB2_SEC_MODE_FLAGS_ALL ) != server -> sec_mode ) cifs_dbg ( FYI , "Server<S2SV_blank>returned<S2SV_blank>unexpected<S2SV_blank>security<S2SV_blank>mode<S2SV_blank>0x%x\\n" , server -> sec_mode ) ; server -> capabilities = le32_to_cpu ( rsp -> Capabilities ) ; server -> capabilities |= SMB2_NT_FIND | SMB2_LARGE_FILES ; security_blob = smb2_get_data_area_len ( & blob_offset , & blob_length , ( struct smb2_sync_hdr * ) rsp ) ; if ( blob_length == 0 ) { cifs_dbg ( FYI , "missing<S2SV_blank>security<S2SV_blank>blob<S2SV_blank>on<S2SV_blank>negprot\\n" ) ; server -> sec_ntlmssp = true ; } rc = cifs_enable_signing ( server , ses -> sign ) ; if ( rc ) goto neg_exit ; if ( blob_length ) { rc = decode_negTokenInit ( security_blob , blob_length , server ) ; if ( rc == 1 ) rc = 0 ; else if ( rc == 0 ) rc = - EIO ; } if ( rsp -> DialectRevision == cpu_to_le16 ( SMB311_PROT_ID ) ) { if ( rsp -> NegotiateContextCount ) rc = smb311_decode_neg_context ( rsp , server , rsp_iov . iov_len ) ; else cifs_dbg ( VFS , "Missing<S2SV_blank>expected<S2SV_blank>negotiate<S2SV_blank>contexts\\n" ) ; } neg_exit : free_rsp_buf ( resp_buftype , rsp ) ; return rc ; }
CWE-125 static int adjust_scalar_min_max_vals ( struct bpf_verifier_env * env , struct bpf_insn * insn , struct bpf_reg_state * dst_reg , struct bpf_reg_state src_reg ) { struct bpf_reg_state * regs = cur_regs ( env ) ; u8 opcode = BPF_OP ( insn -> code ) ; bool src_known , dst_known ; s64 smin_val , smax_val ; u64 umin_val , umax_val ; <S2SV_StartBug> u64 insn_bitness = ( BPF_CLASS ( insn -> code ) == BPF_ALU64 ) ? 64 : 32 ; <S2SV_EndBug> smin_val = src_reg . smin_value ; smax_val = src_reg . smax_value ; umin_val = src_reg . umin_value ; umax_val = src_reg . umax_value ; src_known = tnum_is_const ( src_reg . var_off ) ; dst_known = tnum_is_const ( dst_reg -> var_off ) ; if ( ( src_known && ( smin_val != smax_val || umin_val != umax_val ) ) || smin_val > smax_val || umin_val > umax_val ) { __mark_reg_unknown ( dst_reg ) ; return 0 ; } if ( ! src_known && opcode != BPF_ADD && opcode != BPF_SUB && opcode != BPF_AND ) { __mark_reg_unknown ( dst_reg ) ; return 0 ; } switch ( opcode ) { case BPF_ADD : if ( signed_add_overflows ( dst_reg -> smin_value , smin_val ) || signed_add_overflows ( dst_reg -> smax_value , smax_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value += smin_val ; dst_reg -> smax_value += smax_val ; } if ( dst_reg -> umin_value + umin_val < umin_val || dst_reg -> umax_value + umax_val < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value += umin_val ; dst_reg -> umax_value += umax_val ; } dst_reg -> var_off = tnum_add ( dst_reg -> var_off , src_reg . var_off ) ; break ; case BPF_SUB : if ( signed_sub_overflows ( dst_reg -> smin_value , smax_val ) || signed_sub_overflows ( dst_reg -> smax_value , smin_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value -= smax_val ; dst_reg -> smax_value -= smin_val ; } if ( dst_reg -> umin_value < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value -= umax_val ; dst_reg -> umax_value -= umin_val ; } dst_reg -> var_off = tnum_sub ( dst_reg -> var_off , src_reg . var_off ) ; break ; case BPF_MUL : dst_reg -> var_off = tnum_mul ( dst_reg -> var_off , src_reg . var_off ) ; if ( smin_val < 0 || dst_reg -> smin_value < 0 ) { __mark_reg_unbounded ( dst_reg ) ; __update_reg_bounds ( dst_reg ) ; break ; } if ( umax_val > U32_MAX || dst_reg -> umax_value > U32_MAX ) { __mark_reg_unbounded ( dst_reg ) ; __update_reg_bounds ( dst_reg ) ; break ; } dst_reg -> umin_value *= umin_val ; dst_reg -> umax_value *= umax_val ; if ( dst_reg -> umax_value > S64_MAX ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } break ; case BPF_AND : if ( src_known && dst_known ) { __mark_reg_known ( dst_reg , dst_reg -> var_off . value & src_reg . var_off . value ) ; break ; } dst_reg -> var_off = tnum_and ( dst_reg -> var_off , src_reg . var_off ) ; dst_reg -> umin_value = dst_reg -> var_off . value ; dst_reg -> umax_value = min ( dst_reg -> umax_value , umax_val ) ; if ( dst_reg -> smin_value < 0 || smin_val < 0 ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } __update_reg_bounds ( dst_reg ) ; break ; case BPF_OR : if ( src_known && dst_known ) { __mark_reg_known ( dst_reg , dst_reg -> var_off . value | src_reg . var_off . value ) ; break ; } dst_reg -> var_off = tnum_or ( dst_reg -> var_off , src_reg . var_off ) ; dst_reg -> umin_value = max ( dst_reg -> umin_value , umin_val ) ; dst_reg -> umax_value = dst_reg -> var_off . value | dst_reg -> var_off . mask ; if ( dst_reg -> smin_value < 0 || smin_val < 0 ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } __update_reg_bounds ( dst_reg ) ; break ; case BPF_LSH : if ( umax_val >= insn_bitness ) { mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; if ( dst_reg -> umax_value > 1ULL << ( 63 - umax_val ) ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value <<= umin_val ; dst_reg -> umax_value <<= umax_val ; } dst_reg -> var_off = tnum_lshift ( dst_reg -> var_off , umin_val ) ; __update_reg_bounds ( dst_reg ) ; break ; case BPF_RSH : if ( umax_val >= insn_bitness ) { mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; dst_reg -> var_off = tnum_rshift ( dst_reg -> var_off , umin_val ) ; dst_reg -> umin_value >>= umax_val ; dst_reg -> umax_value >>= umin_val ; __update_reg_bounds ( dst_reg ) ; break ; case BPF_ARSH : if ( umax_val >= insn_bitness ) { mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } dst_reg -> smin_value >>= umin_val ; dst_reg -> smax_value >>= umin_val ; dst_reg -> var_off = tnum_arshift ( dst_reg -> var_off , umin_val ) ; dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; __update_reg_bounds ( dst_reg ) ; break ; default : mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } if ( BPF_CLASS ( insn -> code ) != BPF_ALU64 ) { coerce_reg_to_size ( dst_reg , 4 ) ; <S2SV_StartBug> coerce_reg_to_size ( & src_reg , 4 ) ; <S2SV_EndBug> } __reg_deduce_bounds ( dst_reg ) ; __reg_bound_offset ( dst_reg ) ; return 0 ; }
CWE-190 static int __get_data_block ( struct inode * inode , sector_t iblock , struct buffer_head * bh , int create , int flag , pgoff_t * next_pgofs ) { struct f2fs_map_blocks map ; int err ; map . m_lblk = iblock ; map . m_len = bh -> b_size >> inode -> i_blkbits ; map . m_next_pgofs = next_pgofs ; err = f2fs_map_blocks ( inode , & map , create , flag ) ; if ( ! err ) { map_bh ( bh , inode -> i_sb , map . m_pblk ) ; bh -> b_state = ( bh -> b_state & ~ F2FS_MAP_FLAGS ) | map . m_flags ; <S2SV_StartBug> bh -> b_size = map . m_len << inode -> i_blkbits ; <S2SV_EndBug> } return err ; }
CWE-416 static void smp_task_done ( struct sas_task * task ) { <S2SV_StartBug> if ( ! del_timer ( & task -> slow_task -> timer ) ) <S2SV_EndBug> return ; complete ( & task -> slow_task -> completion ) ; }
CWE-416 static void smp_task_timedout ( struct timer_list * t ) { struct sas_task_slow * slow = from_timer ( slow , t , timer ) ; struct sas_task * task = slow -> task ; unsigned long flags ; spin_lock_irqsave ( & task -> task_state_lock , flags ) ; <S2SV_StartBug> if ( ! ( task -> task_state_flags & SAS_TASK_STATE_DONE ) ) <S2SV_EndBug> <S2SV_StartBug> task -> task_state_flags |= SAS_TASK_STATE_ABORTED ; <S2SV_EndBug> spin_unlock_irqrestore ( & task -> task_state_lock , flags ) ; complete ( & task -> slow_task -> completion ) ; <S2SV_StartBug> } <S2SV_EndBug>
CWE-362 struct mapped_device * dm_get_from_kobject ( struct kobject * kobj ) { struct mapped_device * md ; md = container_of ( kobj , struct mapped_device , kobj_holder . kobj ) ; <S2SV_StartBug> if ( test_bit ( DMF_FREEING , & md -> flags ) || <S2SV_EndBug> <S2SV_StartBug> dm_deleting_md ( md ) ) <S2SV_EndBug> return NULL ; <S2SV_StartBug> dm_get ( md ) ; <S2SV_EndBug> return md ; }
CWE-476 int xfs_attr_shortform_to_leaf ( struct xfs_da_args * args , struct xfs_buf * * leaf_bp ) { xfs_inode_t * dp ; xfs_attr_shortform_t * sf ; xfs_attr_sf_entry_t * sfe ; xfs_da_args_t nargs ; char * tmpbuffer ; int error , i , size ; xfs_dablk_t blkno ; struct xfs_buf * bp ; xfs_ifork_t * ifp ; trace_xfs_attr_sf_to_leaf ( args ) ; dp = args -> dp ; ifp = dp -> i_afp ; sf = ( xfs_attr_shortform_t * ) ifp -> if_u1 . if_data ; size = be16_to_cpu ( sf -> hdr . totsize ) ; tmpbuffer = kmem_alloc ( size , KM_SLEEP ) ; ASSERT ( tmpbuffer != NULL ) ; memcpy ( tmpbuffer , ifp -> if_u1 . if_data , size ) ; sf = ( xfs_attr_shortform_t * ) tmpbuffer ; xfs_idata_realloc ( dp , - size , XFS_ATTR_FORK ) ; xfs_bmap_local_to_extents_empty ( dp , XFS_ATTR_FORK ) ; bp = NULL ; error = xfs_da_grow_inode ( args , & blkno ) ; if ( error ) { if ( error == - EIO ) goto out ; xfs_idata_realloc ( dp , size , XFS_ATTR_FORK ) ; memcpy ( ifp -> if_u1 . if_data , tmpbuffer , size ) ; goto out ; } ASSERT ( blkno == 0 ) ; error = xfs_attr3_leaf_create ( args , blkno , & bp ) ; if ( error ) { <S2SV_StartBug> error = xfs_da_shrink_inode ( args , 0 , bp ) ; <S2SV_EndBug> bp = NULL ; if ( error ) goto out ; xfs_idata_realloc ( dp , size , XFS_ATTR_FORK ) ; memcpy ( ifp -> if_u1 . if_data , tmpbuffer , size ) ; goto out ; } memset ( ( char * ) & nargs , 0 , sizeof ( nargs ) ) ; nargs . dp = dp ; nargs . geo = args -> geo ; nargs . firstblock = args -> firstblock ; nargs . dfops = args -> dfops ; nargs . total = args -> total ; nargs . whichfork = XFS_ATTR_FORK ; nargs . trans = args -> trans ; nargs . op_flags = XFS_DA_OP_OKNOENT ; sfe = & sf -> list [ 0 ] ; for ( i = 0 ; i < sf -> hdr . count ; i ++ ) { nargs . name = sfe -> nameval ; nargs . namelen = sfe -> namelen ; nargs . value = & sfe -> nameval [ nargs . namelen ] ; nargs . valuelen = sfe -> valuelen ; nargs . hashval = xfs_da_hashname ( sfe -> nameval , sfe -> namelen ) ; nargs . flags = XFS_ATTR_NSP_ONDISK_TO_ARGS ( sfe -> flags ) ; error = xfs_attr3_leaf_lookup_int ( bp , & nargs ) ; ASSERT ( error == - ENOATTR ) ; error = xfs_attr3_leaf_add ( bp , & nargs ) ; ASSERT ( error != - ENOSPC ) ; if ( error ) goto out ; sfe = XFS_ATTR_SF_NEXTENTRY ( sfe ) ; } error = 0 ; * leaf_bp = bp ; out : kmem_free ( tmpbuffer ) ; return error ; }
CWE-476 int megasas_alloc_cmds ( struct megasas_instance * instance ) { int i ; int j ; u16 max_cmd ; struct megasas_cmd * cmd ; max_cmd = instance -> max_mfi_cmds ; instance -> cmd_list = kcalloc ( max_cmd , sizeof ( struct megasas_cmd * ) , GFP_KERNEL ) ; if ( ! instance -> cmd_list ) { dev_printk ( KERN_DEBUG , & instance -> pdev -> dev , "out<S2SV_blank>of<S2SV_blank>memory\\n" ) ; return - ENOMEM ; } memset ( instance -> cmd_list , 0 , sizeof ( struct megasas_cmd * ) * max_cmd ) ; for ( i = 0 ; i < max_cmd ; i ++ ) { instance -> cmd_list [ i ] = kmalloc ( sizeof ( struct megasas_cmd ) , GFP_KERNEL ) ; if ( ! instance -> cmd_list [ i ] ) { for ( j = 0 ; j < i ; j ++ ) kfree ( instance -> cmd_list [ j ] ) ; kfree ( instance -> cmd_list ) ; instance -> cmd_list = NULL ; return - ENOMEM ; } } for ( i = 0 ; i < max_cmd ; i ++ ) { cmd = instance -> cmd_list [ i ] ; memset ( cmd , 0 , sizeof ( struct megasas_cmd ) ) ; cmd -> index = i ; cmd -> scmd = NULL ; cmd -> instance = instance ; list_add_tail ( & cmd -> list , & instance -> cmd_pool ) ; } if ( megasas_create_frame_pool ( instance ) ) { dev_printk ( KERN_DEBUG , & instance -> pdev -> dev , "Error<S2SV_blank>creating<S2SV_blank>frame<S2SV_blank>DMA<S2SV_blank>pool\\n" ) ; megasas_free_cmds ( instance ) ; <S2SV_StartBug> } <S2SV_EndBug> return 0 ; }
CWE-362 static long vbg_misc_device_ioctl ( struct file * filp , unsigned int req , unsigned long arg ) { struct vbg_session * session = filp -> private_data ; size_t returned_size , size ; struct vbg_ioctl_hdr hdr ; bool is_vmmdev_req ; int ret = 0 ; void * buf ; if ( copy_from_user ( & hdr , ( void * ) arg , sizeof ( hdr ) ) ) return - EFAULT ; if ( hdr . version != VBG_IOCTL_HDR_VERSION ) return - EINVAL ; if ( hdr . size_in < sizeof ( hdr ) || ( hdr . size_out && hdr . size_out < sizeof ( hdr ) ) ) return - EINVAL ; size = max ( hdr . size_in , hdr . size_out ) ; if ( _IOC_SIZE ( req ) && _IOC_SIZE ( req ) != size ) return - EINVAL ; if ( size > SZ_16M ) return - E2BIG ; is_vmmdev_req = ( req & ~ IOCSIZE_MASK ) == VBG_IOCTL_VMMDEV_REQUEST ( 0 ) || req == VBG_IOCTL_VMMDEV_REQUEST_BIG ; if ( is_vmmdev_req ) buf = vbg_req_alloc ( size , VBG_IOCTL_HDR_TYPE_DEFAULT ) ; else buf = kmalloc ( size , GFP_KERNEL ) ; if ( ! buf ) return - ENOMEM ; <S2SV_StartBug> if ( copy_from_user ( buf , ( void * ) arg , hdr . size_in ) ) { <S2SV_EndBug> ret = - EFAULT ; goto out ; } if ( hdr . size_in < size ) memset ( buf + hdr . size_in , 0 , size - hdr . size_in ) ; ret = vbg_core_ioctl ( session , req , buf ) ; if ( ret ) goto out ; returned_size = ( ( struct vbg_ioctl_hdr * ) buf ) -> size_out ; if ( returned_size > size ) { vbg_debug ( "%s:<S2SV_blank>too<S2SV_blank>much<S2SV_blank>output<S2SV_blank>data<S2SV_blank>%zu<S2SV_blank>><S2SV_blank>%zu\\n" , __func__ , returned_size , size ) ; returned_size = size ; } if ( copy_to_user ( ( void * ) arg , buf , returned_size ) != 0 ) ret = - EFAULT ; out : if ( is_vmmdev_req ) vbg_req_free ( buf , size ) ; else kfree ( buf ) ; return ret ; }
CWE-787 int rds_rdma_extra_size ( struct rds_rdma_args * args ) { struct rds_iovec vec ; struct rds_iovec __user * local_vec ; int tot_pages = 0 ; unsigned int nr_pages ; unsigned int i ; <S2SV_StartBug> local_vec = ( struct rds_iovec __user * ) ( unsigned long ) args -> local_vec_addr ; <S2SV_EndBug> for ( i = 0 ; i < args -> nr_local ; i ++ ) { if ( copy_from_user ( & vec , & local_vec [ i ] , sizeof ( struct rds_iovec ) ) ) return - EFAULT ; nr_pages = rds_pages_in_vec ( & vec ) ; if ( nr_pages == 0 ) return - EINVAL ; tot_pages += nr_pages ; if ( tot_pages < 0 ) return - EINVAL ; } return tot_pages * sizeof ( struct scatterlist ) ; }
CWE-125 void qedi_dbg_err ( struct qedi_dbg_ctx * qedi , const char * func , u32 line , const char * fmt , ... ) { va_list va ; <S2SV_StartBug> struct va_format vaf ; <S2SV_EndBug> char nfunc [ 32 ] ; memset ( nfunc , 0 , sizeof ( nfunc ) ) ; memcpy ( nfunc , func , sizeof ( nfunc ) - 1 ) ; va_start ( va , fmt ) ; vaf . fmt = fmt ; vaf . va = & va ; if ( likely ( qedi ) && likely ( qedi -> pdev ) ) pr_err ( "[%s]:[%s:%d]:%d:<S2SV_blank>%pV" , dev_name ( & qedi -> pdev -> dev ) , <S2SV_StartBug> nfunc , line , qedi -> host_no , & vaf ) ; <S2SV_EndBug> else <S2SV_StartBug> pr_err ( "[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV" , nfunc , line , & vaf ) ; <S2SV_EndBug> va_end ( va ) ; }
CWE-125 void qedi_dbg_info ( struct qedi_dbg_ctx * qedi , const char * func , u32 line , u32 level , const char * fmt , ... ) { va_list va ; <S2SV_StartBug> struct va_format vaf ; <S2SV_EndBug> char nfunc [ 32 ] ; memset ( nfunc , 0 , sizeof ( nfunc ) ) ; memcpy ( nfunc , func , sizeof ( nfunc ) - 1 ) ; va_start ( va , fmt ) ; vaf . fmt = fmt ; vaf . va = & va ; if ( ! ( qedi_dbg_log & level ) ) goto ret ; if ( likely ( qedi ) && likely ( qedi -> pdev ) ) pr_info ( "[%s]:[%s:%d]:%d:<S2SV_blank>%pV" , dev_name ( & qedi -> pdev -> dev ) , <S2SV_StartBug> nfunc , line , qedi -> host_no , & vaf ) ; <S2SV_EndBug> else <S2SV_StartBug> pr_info ( "[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV" , nfunc , line , & vaf ) ; <S2SV_EndBug> ret : va_end ( va ) ; }
CWE-125 void qedi_dbg_notice ( struct qedi_dbg_ctx * qedi , const char * func , u32 line , const char * fmt , ... ) { va_list va ; <S2SV_StartBug> struct va_format vaf ; <S2SV_EndBug> char nfunc [ 32 ] ; memset ( nfunc , 0 , sizeof ( nfunc ) ) ; memcpy ( nfunc , func , sizeof ( nfunc ) - 1 ) ; va_start ( va , fmt ) ; vaf . fmt = fmt ; vaf . va = & va ; if ( ! ( qedi_dbg_log & QEDI_LOG_NOTICE ) ) goto ret ; if ( likely ( qedi ) && likely ( qedi -> pdev ) ) pr_notice ( "[%s]:[%s:%d]:%d:<S2SV_blank>%pV" , <S2SV_StartBug> dev_name ( & qedi -> pdev -> dev ) , nfunc , line , <S2SV_EndBug> qedi -> host_no , & vaf ) ; else <S2SV_StartBug> pr_notice ( "[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV" , nfunc , line , & vaf ) ; <S2SV_EndBug> ret : va_end ( va ) ; }
CWE-125 void qedi_dbg_warn ( struct qedi_dbg_ctx * qedi , const char * func , u32 line , const char * fmt , ... ) { va_list va ; <S2SV_StartBug> struct va_format vaf ; <S2SV_EndBug> char nfunc [ 32 ] ; memset ( nfunc , 0 , sizeof ( nfunc ) ) ; memcpy ( nfunc , func , sizeof ( nfunc ) - 1 ) ; va_start ( va , fmt ) ; vaf . fmt = fmt ; vaf . va = & va ; if ( ! ( qedi_dbg_log & QEDI_LOG_WARN ) ) goto ret ; if ( likely ( qedi ) && likely ( qedi -> pdev ) ) pr_warn ( "[%s]:[%s:%d]:%d:<S2SV_blank>%pV" , dev_name ( & qedi -> pdev -> dev ) , <S2SV_StartBug> nfunc , line , qedi -> host_no , & vaf ) ; <S2SV_EndBug> else <S2SV_StartBug> pr_warn ( "[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV" , nfunc , line , & vaf ) ; <S2SV_EndBug> ret : va_end ( va ) ; }
CWE-129 int snmp_helper ( void * context , size_t hdrlen , unsigned char tag , const void * data , size_t datalen ) { struct snmp_ctx * ctx = ( struct snmp_ctx * ) context ; <S2SV_StartBug> __be32 * pdata = ( __be32 * ) data ; <S2SV_EndBug> if ( * pdata == ctx -> from ) { pr_debug ( "%s:<S2SV_blank>%pI4<S2SV_blank>to<S2SV_blank>%pI4\\n" , __func__ , ( void * ) & ctx -> from , ( void * ) & ctx -> to ) ; if ( * ctx -> check ) fast_csum ( ctx , ( unsigned char * ) data - ctx -> begin ) ; * pdata = ctx -> to ; } return 1 ; }
CWE-129 int snmp_version ( void * context , size_t hdrlen , unsigned char tag , const void * data , size_t datalen ) { <S2SV_StartBug> if ( * ( unsigned char * ) data > 1 ) <S2SV_EndBug> return - ENOTSUPP ; return 1 ; }
CWE-189 static int __dwc3_gadget_kick_transfer ( struct dwc3_ep * dep ) { struct dwc3_gadget_ep_cmd_params params ; struct dwc3_request * req ; int starting ; int ret ; u32 cmd ; if ( ! dwc3_calc_trbs_left ( dep ) ) return 0 ; starting = ! ( dep -> flags & DWC3_EP_BUSY ) ; dwc3_prepare_trbs ( dep ) ; req = next_request ( & dep -> started_list ) ; if ( ! req ) { dep -> flags |= DWC3_EP_PENDING_REQUEST ; return 0 ; } memset ( & params , 0 , sizeof ( params ) ) ; if ( starting ) { params . param0 = upper_32_bits ( req -> trb_dma ) ; params . param1 = lower_32_bits ( req -> trb_dma ) ; cmd = DWC3_DEPCMD_STARTTRANSFER ; if ( usb_endpoint_xfer_isoc ( dep -> endpoint . desc ) ) cmd |= DWC3_DEPCMD_PARAM ( dep -> frame_number ) ; } else { cmd = DWC3_DEPCMD_UPDATETRANSFER | DWC3_DEPCMD_PARAM ( dep -> resource_index ) ; } ret = dwc3_send_gadget_ep_cmd ( dep , cmd , & params ) ; if ( ret < 0 ) { if ( req -> trb ) memset ( req -> trb , 0 , sizeof ( struct dwc3_trb ) ) ; dep -> queued_requests -- ; <S2SV_StartBug> dwc3_gadget_giveback ( dep , req , ret ) ; <S2SV_EndBug> return ret ; } dep -> flags |= DWC3_EP_BUSY ; if ( starting ) { dep -> resource_index = dwc3_gadget_ep_get_transfer_index ( dep ) ; WARN_ON_ONCE ( ! dep -> resource_index ) ; } return 0 ; }
CWE-189 void dwc3_gadget_giveback ( struct dwc3_ep * dep , struct dwc3_request * req , int status ) { struct dwc3 * dwc = dep -> dwc ; <S2SV_StartBug> req -> started = false ; <S2SV_EndBug> list_del ( & req -> list ) ; req -> remaining = 0 ; if ( req -> request . status == - EINPROGRESS ) req -> request . status = status ; if ( req -> trb ) usb_gadget_unmap_request_by_dev ( dwc -> sysdev , & req -> request , req -> direction ) ; req -> trb = NULL ; trace_dwc3_gadget_giveback ( req ) ; spin_unlock ( & dwc -> lock ) ; usb_gadget_giveback_request ( & dep -> endpoint , & req -> request ) ; spin_lock ( & dwc -> lock ) ; <S2SV_StartBug> if ( dep -> number > 1 ) <S2SV_EndBug> pm_runtime_put ( dwc -> dev ) ; }
CWE-476 int build_ntlmssp_auth_blob ( unsigned char * * pbuffer , u16 * buflen , struct cifs_ses * ses , const struct nls_table * nls_cp ) { int rc ; AUTHENTICATE_MESSAGE * sec_blob ; __u32 flags ; unsigned char * tmp ; rc = setup_ntlmv2_rsp ( ses , nls_cp ) ; if ( rc ) { cifs_dbg ( VFS , "Error<S2SV_blank>%d<S2SV_blank>during<S2SV_blank>NTLMSSP<S2SV_blank>authentication\\n" , rc ) ; * buflen = 0 ; goto setup_ntlmv2_ret ; } * pbuffer = kmalloc ( size_of_ntlmssp_blob ( ses ) , GFP_KERNEL ) ; sec_blob = ( AUTHENTICATE_MESSAGE * ) * pbuffer ; memcpy ( sec_blob -> Signature , NTLMSSP_SIGNATURE , 8 ) ; sec_blob -> MessageType = NtLmAuthenticate ; flags = NTLMSSP_NEGOTIATE_56 | NTLMSSP_REQUEST_TARGET | NTLMSSP_NEGOTIATE_TARGET_INFO | NTLMSSP_NEGOTIATE_128 | NTLMSSP_NEGOTIATE_UNICODE | <S2SV_StartBug> NTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC ; <S2SV_EndBug> <S2SV_StartBug> if ( ses -> server -> sign ) { <S2SV_EndBug> flags |= NTLMSSP_NEGOTIATE_SIGN ; if ( ! ses -> server -> session_estab || ses -> ntlmssp -> sesskey_per_smbsess ) flags |= NTLMSSP_NEGOTIATE_KEY_XCH ; <S2SV_StartBug> } <S2SV_EndBug> tmp = * pbuffer + sizeof ( AUTHENTICATE_MESSAGE ) ; sec_blob -> NegotiateFlags = cpu_to_le32 ( flags ) ; sec_blob -> LmChallengeResponse . BufferOffset = cpu_to_le32 ( sizeof ( AUTHENTICATE_MESSAGE ) ) ; sec_blob -> LmChallengeResponse . Length = 0 ; sec_blob -> LmChallengeResponse . MaximumLength = 0 ; sec_blob -> NtChallengeResponse . BufferOffset = cpu_to_le32 ( tmp - * pbuffer ) ; if ( ses -> user_name != NULL ) { memcpy ( tmp , ses -> auth_key . response + CIFS_SESS_KEY_SIZE , ses -> auth_key . len - CIFS_SESS_KEY_SIZE ) ; tmp += ses -> auth_key . len - CIFS_SESS_KEY_SIZE ; sec_blob -> NtChallengeResponse . Length = cpu_to_le16 ( ses -> auth_key . len - CIFS_SESS_KEY_SIZE ) ; sec_blob -> NtChallengeResponse . MaximumLength = cpu_to_le16 ( ses -> auth_key . len - CIFS_SESS_KEY_SIZE ) ; } else { sec_blob -> NtChallengeResponse . Length = 0 ; sec_blob -> NtChallengeResponse . MaximumLength = 0 ; } if ( ses -> domainName == NULL ) { sec_blob -> DomainName . BufferOffset = cpu_to_le32 ( tmp - * pbuffer ) ; sec_blob -> DomainName . Length = 0 ; sec_blob -> DomainName . MaximumLength = 0 ; tmp += 2 ; } else { int len ; len = cifs_strtoUTF16 ( ( __le16 * ) tmp , ses -> domainName , CIFS_MAX_DOMAINNAME_LEN , nls_cp ) ; len *= 2 ; sec_blob -> DomainName . BufferOffset = cpu_to_le32 ( tmp - * pbuffer ) ; sec_blob -> DomainName . Length = cpu_to_le16 ( len ) ; sec_blob -> DomainName . MaximumLength = cpu_to_le16 ( len ) ; tmp += len ; } if ( ses -> user_name == NULL ) { sec_blob -> UserName . BufferOffset = cpu_to_le32 ( tmp - * pbuffer ) ; sec_blob -> UserName . Length = 0 ; sec_blob -> UserName . MaximumLength = 0 ; tmp += 2 ; } else { int len ; len = cifs_strtoUTF16 ( ( __le16 * ) tmp , ses -> user_name , CIFS_MAX_USERNAME_LEN , nls_cp ) ; len *= 2 ; sec_blob -> UserName . BufferOffset = cpu_to_le32 ( tmp - * pbuffer ) ; sec_blob -> UserName . Length = cpu_to_le16 ( len ) ; sec_blob -> UserName . MaximumLength = cpu_to_le16 ( len ) ; tmp += len ; } sec_blob -> WorkstationName . BufferOffset = cpu_to_le32 ( tmp - * pbuffer ) ; sec_blob -> WorkstationName . Length = 0 ; sec_blob -> WorkstationName . MaximumLength = 0 ; tmp += 2 ; if ( ( ( ses -> ntlmssp -> server_flags & NTLMSSP_NEGOTIATE_KEY_XCH ) || ( ses -> ntlmssp -> server_flags & NTLMSSP_NEGOTIATE_EXTENDED_SEC ) ) && ! calc_seckey ( ses ) ) { memcpy ( tmp , ses -> ntlmssp -> ciphertext , CIFS_CPHTXT_SIZE ) ; sec_blob -> SessionKey . BufferOffset = cpu_to_le32 ( tmp - * pbuffer ) ; sec_blob -> SessionKey . Length = cpu_to_le16 ( CIFS_CPHTXT_SIZE ) ; sec_blob -> SessionKey . MaximumLength = cpu_to_le16 ( CIFS_CPHTXT_SIZE ) ; tmp += CIFS_CPHTXT_SIZE ; } else { sec_blob -> SessionKey . BufferOffset = cpu_to_le32 ( tmp - * pbuffer ) ; sec_blob -> SessionKey . Length = 0 ; sec_blob -> SessionKey . MaximumLength = 0 ; } * buflen = tmp - * pbuffer ; setup_ntlmv2_ret : return rc ; }
CWE-476 void build_ntlmssp_negotiate_blob ( unsigned char * pbuffer , struct cifs_ses * ses ) { NEGOTIATE_MESSAGE * sec_blob = ( NEGOTIATE_MESSAGE * ) pbuffer ; __u32 flags ; memset ( pbuffer , 0 , sizeof ( NEGOTIATE_MESSAGE ) ) ; memcpy ( sec_blob -> Signature , NTLMSSP_SIGNATURE , 8 ) ; sec_blob -> MessageType = NtLmNegotiate ; flags = NTLMSSP_NEGOTIATE_56 | NTLMSSP_REQUEST_TARGET | NTLMSSP_NEGOTIATE_128 | NTLMSSP_NEGOTIATE_UNICODE | <S2SV_StartBug> NTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC ; <S2SV_EndBug> <S2SV_StartBug> if ( ses -> server -> sign ) { <S2SV_EndBug> flags |= NTLMSSP_NEGOTIATE_SIGN ; if ( ! ses -> server -> session_estab || ses -> ntlmssp -> sesskey_per_smbsess ) flags |= NTLMSSP_NEGOTIATE_KEY_XCH ; <S2SV_StartBug> } <S2SV_EndBug> sec_blob -> NegotiateFlags = cpu_to_le32 ( flags ) ; sec_blob -> WorkstationName . BufferOffset = 0 ; sec_blob -> WorkstationName . Length = 0 ; sec_blob -> WorkstationName . MaximumLength = 0 ; sec_blob -> DomainName . BufferOffset = 0 ; sec_blob -> DomainName . Length = 0 ; sec_blob -> DomainName . MaximumLength = 0 ; }
CWE-476 static int SMB2_sess_establish_session ( struct SMB2_sess_data * sess_data ) { int rc = 0 ; struct cifs_ses * ses = sess_data -> ses ; mutex_lock ( & ses -> server -> srv_mutex ) ; <S2SV_StartBug> if ( ses -> server -> sign && ses -> server -> ops -> generate_signingkey ) { <S2SV_EndBug> <S2SV_StartBug> rc = ses -> server -> ops -> generate_signingkey ( ses ) ; <S2SV_EndBug> kfree ( ses -> auth_key . response ) ; ses -> auth_key . response = NULL ; if ( rc ) { cifs_dbg ( FYI , "SMB3<S2SV_blank>session<S2SV_blank>key<S2SV_blank>generation<S2SV_blank>failed\\n" ) ; mutex_unlock ( & ses -> server -> srv_mutex ) ; <S2SV_StartBug> goto keygen_exit ; <S2SV_EndBug> } } if ( ! ses -> server -> session_estab ) { ses -> server -> sequence_number = 0x2 ; ses -> server -> session_estab = true ; } mutex_unlock ( & ses -> server -> srv_mutex ) ; cifs_dbg ( FYI , "SMB2/3<S2SV_blank>session<S2SV_blank>established<S2SV_blank>successfully\\n" ) ; spin_lock ( & GlobalMid_Lock ) ; ses -> status = CifsGood ; ses -> need_reconnect = false ; spin_unlock ( & GlobalMid_Lock ) ; <S2SV_StartBug> keygen_exit : <S2SV_EndBug> if ( ! ses -> server -> sign ) { kfree ( ses -> auth_key . response ) ; ses -> auth_key . response = NULL ; } return rc ; }
CWE-416 static struct ucma_multicast * ucma_alloc_multicast ( struct ucma_context * ctx ) { struct ucma_multicast * mc ; mc = kzalloc ( sizeof ( * mc ) , GFP_KERNEL ) ; if ( ! mc ) return NULL ; mutex_lock ( & mut ) ; <S2SV_StartBug> mc -> id = idr_alloc ( & multicast_idr , mc , 0 , 0 , GFP_KERNEL ) ; <S2SV_EndBug> mutex_unlock ( & mut ) ; if ( mc -> id < 0 ) goto error ; mc -> ctx = ctx ; list_add_tail ( & mc -> list , & ctx -> mc_list ) ; return mc ; error : kfree ( mc ) ; return NULL ; }
CWE-416 static ssize_t ucma_process_join ( struct ucma_file * file , struct rdma_ucm_join_mcast * cmd , int out_len ) { struct rdma_ucm_create_id_resp resp ; struct ucma_context * ctx ; struct ucma_multicast * mc ; struct sockaddr * addr ; int ret ; u8 join_state ; if ( out_len < sizeof ( resp ) ) return - ENOSPC ; addr = ( struct sockaddr * ) & cmd -> addr ; if ( cmd -> addr_size != rdma_addr_size ( addr ) ) return - EINVAL ; if ( cmd -> join_flags == RDMA_MC_JOIN_FLAG_FULLMEMBER ) join_state = BIT ( FULLMEMBER_JOIN ) ; else if ( cmd -> join_flags == RDMA_MC_JOIN_FLAG_SENDONLY_FULLMEMBER ) join_state = BIT ( SENDONLY_FULLMEMBER_JOIN ) ; else return - EINVAL ; ctx = ucma_get_ctx_dev ( file , cmd -> id ) ; if ( IS_ERR ( ctx ) ) return PTR_ERR ( ctx ) ; mutex_lock ( & file -> mut ) ; mc = ucma_alloc_multicast ( ctx ) ; if ( ! mc ) { ret = - ENOMEM ; goto err1 ; } mc -> join_state = join_state ; mc -> uid = cmd -> uid ; memcpy ( & mc -> addr , addr , cmd -> addr_size ) ; ret = rdma_join_multicast ( ctx -> cm_id , ( struct sockaddr * ) & mc -> addr , join_state , mc ) ; if ( ret ) goto err2 ; resp . id = mc -> id ; if ( copy_to_user ( u64_to_user_ptr ( cmd -> response ) , & resp , sizeof ( resp ) ) ) { ret = - EFAULT ; goto err3 ; } <S2SV_StartBug> mutex_unlock ( & file -> mut ) ; <S2SV_EndBug> ucma_put_ctx ( ctx ) ; return 0 ; err3 : rdma_leave_multicast ( ctx -> cm_id , ( struct sockaddr * ) & mc -> addr ) ; ucma_cleanup_mc_events ( mc ) ; err2 : mutex_lock ( & mut ) ; idr_remove ( & multicast_idr , mc -> id ) ; mutex_unlock ( & mut ) ; list_del ( & mc -> list ) ; kfree ( mc ) ; err1 : mutex_unlock ( & file -> mut ) ; ucma_put_ctx ( ctx ) ; return ret ; }
CWE-362 static void rds_tcp_kill_sock ( struct net * net ) { struct rds_tcp_connection * tc , * _tc ; LIST_HEAD ( tmp_list ) ; struct rds_tcp_net * rtn = net_generic ( net , rds_tcp_netid ) ; struct socket * lsock = rtn -> rds_tcp_listen_sock ; rtn -> rds_tcp_listen_sock = NULL ; rds_tcp_listen_stop ( lsock , & rtn -> rds_tcp_accept_w ) ; spin_lock_irq ( & rds_tcp_conn_lock ) ; list_for_each_entry_safe ( tc , _tc , & rds_tcp_conn_list , t_tcp_node ) { struct net * c_net = read_pnet ( & tc -> t_cpath -> cp_conn -> c_net ) ; <S2SV_StartBug> if ( net != c_net || ! tc -> t_sock ) <S2SV_EndBug> continue ; if ( ! list_has_conn ( & tmp_list , tc -> t_cpath -> cp_conn ) ) { list_move_tail ( & tc -> t_tcp_node , & tmp_list ) ; } else { list_del ( & tc -> t_tcp_node ) ; tc -> t_tcp_node_detached = true ; } } spin_unlock_irq ( & rds_tcp_conn_lock ) ; list_for_each_entry_safe ( tc , _tc , & tmp_list , t_tcp_node ) rds_conn_destroy ( tc -> t_cpath -> cp_conn ) ; }
CWE-399 int genl_register_family ( struct genl_family * family ) { int err , i ; int start = GENL_START_ALLOC , end = GENL_MAX_ID ; err = genl_validate_ops ( family ) ; if ( err ) return err ; genl_lock_all ( ) ; if ( genl_family_find_byname ( family -> name ) ) { err = - EEXIST ; goto errout_locked ; } if ( family == & genl_ctrl ) { start = end = GENL_ID_CTRL ; } else if ( strcmp ( family -> name , "pmcraid" ) == 0 ) { start = end = GENL_ID_PMCRAID ; } else if ( strcmp ( family -> name , "VFS_DQUOT" ) == 0 ) { start = end = GENL_ID_VFS_DQUOT ; } if ( family -> maxattr && ! family -> parallel_ops ) { family -> attrbuf = kmalloc_array ( family -> maxattr + 1 , sizeof ( struct nlattr * ) , GFP_KERNEL ) ; if ( family -> attrbuf == NULL ) { err = - ENOMEM ; goto errout_locked ; } } else family -> attrbuf = NULL ; family -> id = idr_alloc ( & genl_fam_idr , family , start , end + 1 , GFP_KERNEL ) ; if ( family -> id < 0 ) { err = family -> id ; <S2SV_StartBug> goto errout_locked ; <S2SV_EndBug> } err = genl_validate_assign_mc_groups ( family ) ; if ( err ) goto errout_remove ; genl_unlock_all ( ) ; genl_ctrl_event ( CTRL_CMD_NEWFAMILY , family , NULL , 0 ) ; for ( i = 0 ; i < family -> n_mcgrps ; i ++ ) genl_ctrl_event ( CTRL_CMD_NEWMCAST_GRP , family , & family -> mcgrps [ i ] , family -> mcgrp_offset + i ) ; return 0 ; errout_remove : idr_remove ( & genl_fam_idr , family -> id ) ; <S2SV_StartBug> kfree ( family -> attrbuf ) ; <S2SV_EndBug> errout_locked : genl_unlock_all ( ) ; return err ; }
CWE-125 void common_timer_get ( struct k_itimer * timr , struct itimerspec64 * cur_setting ) { const struct k_clock * kc = timr -> kclock ; ktime_t now , remaining , iv ; struct timespec64 ts64 ; bool sig_none ; <S2SV_StartBug> sig_none = ( timr -> it_sigev_notify & ~ SIGEV_THREAD_ID ) == SIGEV_NONE ; <S2SV_EndBug> iv = timr -> it_interval ; if ( iv ) { cur_setting -> it_interval = ktime_to_timespec64 ( iv ) ; } else if ( ! timr -> it_active ) { if ( ! sig_none ) return ; } kc -> clock_get ( timr -> it_clock , & ts64 ) ; now = timespec64_to_ktime ( ts64 ) ; if ( iv && ( timr -> it_requeue_pending & REQUEUE_PENDING || sig_none ) ) timr -> it_overrun += kc -> timer_forward ( timr , now ) ; remaining = kc -> timer_remaining ( timr , now ) ; if ( remaining <= 0 ) { if ( ! sig_none ) cur_setting -> it_value . tv_nsec = 1 ; } else { cur_setting -> it_value = ktime_to_timespec64 ( remaining ) ; } }
CWE-125 int common_timer_set ( struct k_itimer * timr , int flags , struct itimerspec64 * new_setting , struct itimerspec64 * old_setting ) { const struct k_clock * kc = timr -> kclock ; bool sigev_none ; ktime_t expires ; if ( old_setting ) common_timer_get ( timr , old_setting ) ; timr -> it_interval = 0 ; if ( kc -> timer_try_to_cancel ( timr ) < 0 ) return TIMER_RETRY ; timr -> it_active = 0 ; timr -> it_requeue_pending = ( timr -> it_requeue_pending + 2 ) & ~ REQUEUE_PENDING ; timr -> it_overrun_last = 0 ; if ( ! new_setting -> it_value . tv_sec && ! new_setting -> it_value . tv_nsec ) return 0 ; timr -> it_interval = timespec64_to_ktime ( new_setting -> it_interval ) ; expires = timespec64_to_ktime ( new_setting -> it_value ) ; <S2SV_StartBug> sigev_none = ( timr -> it_sigev_notify & ~ SIGEV_THREAD_ID ) == SIGEV_NONE ; <S2SV_EndBug> kc -> timer_arm ( timr , expires , flags & TIMER_ABSTIME , sigev_none ) ; timr -> it_active = ! sigev_none ; return 0 ; }
CWE-125 static struct pid * good_sigevent ( sigevent_t * event ) { struct task_struct * rtn = current -> group_leader ; <S2SV_StartBug> if ( ( event -> sigev_notify & SIGEV_THREAD_ID ) && <S2SV_EndBug> <S2SV_StartBug> ( ! ( rtn = find_task_by_vpid ( event -> sigev_notify_thread_id ) ) || <S2SV_EndBug> <S2SV_StartBug> ! same_thread_group ( rtn , current ) || <S2SV_EndBug> ( event -> sigev_notify & ~ SIGEV_THREAD_ID ) != SIGEV_SIGNAL ) ) return NULL ; <S2SV_StartBug> if ( ( ( event -> sigev_notify & ~ SIGEV_THREAD_ID ) != SIGEV_NONE ) && <S2SV_EndBug> <S2SV_StartBug> ( ( event -> sigev_signo <= 0 ) || ( event -> sigev_signo > SIGRTMAX ) ) ) <S2SV_EndBug> <S2SV_StartBug> return NULL ; <S2SV_EndBug> return task_pid ( rtn ) ; <S2SV_StartBug> } <S2SV_EndBug>
CWE-362 static int kvm_ioctl_create_device ( struct kvm * kvm , struct kvm_create_device * cd ) { struct kvm_device_ops * ops = NULL ; struct kvm_device * dev ; bool test = cd -> flags & KVM_CREATE_DEVICE_TEST ; int ret ; if ( cd -> type >= ARRAY_SIZE ( kvm_device_ops_table ) ) return - ENODEV ; ops = kvm_device_ops_table [ cd -> type ] ; if ( ops == NULL ) return - ENODEV ; if ( test ) return 0 ; dev = kzalloc ( sizeof ( * dev ) , GFP_KERNEL ) ; if ( ! dev ) return - ENOMEM ; dev -> ops = ops ; dev -> kvm = kvm ; mutex_lock ( & kvm -> lock ) ; ret = ops -> create ( dev , cd -> type ) ; if ( ret < 0 ) { mutex_unlock ( & kvm -> lock ) ; kfree ( dev ) ; return ret ; } list_add ( & dev -> vm_node , & kvm -> devices ) ; mutex_unlock ( & kvm -> lock ) ; if ( ops -> init ) ops -> init ( dev ) ; <S2SV_StartBug> ret = anon_inode_getfd ( ops -> name , & kvm_device_fops , dev , O_RDWR | O_CLOEXEC ) ; <S2SV_EndBug> if ( ret < 0 ) { <S2SV_StartBug> mutex_lock ( & kvm -> lock ) ; <S2SV_EndBug> list_del ( & dev -> vm_node ) ; mutex_unlock ( & kvm -> lock ) ; ops -> destroy ( dev ) ; return ret ; } <S2SV_StartBug> kvm_get_kvm ( kvm ) ; <S2SV_EndBug> cd -> fd = ret ; return 0 ; }
CWE-20 static int get_core_reg ( struct kvm_vcpu * vcpu , const struct kvm_one_reg * reg ) { __u32 __user * uaddr = ( __u32 __user * ) ( unsigned long ) reg -> addr ; struct kvm_regs * regs = vcpu_gp_regs ( vcpu ) ; int nr_regs = sizeof ( * regs ) / sizeof ( __u32 ) ; u32 off ; off = core_reg_offset_from_id ( reg -> id ) ; if ( off >= nr_regs || ( off + ( KVM_REG_SIZE ( reg -> id ) / sizeof ( __u32 ) ) ) >= nr_regs ) return - ENOENT ; <S2SV_StartBug> if ( copy_to_user ( uaddr , ( ( u32 * ) regs ) + off , KVM_REG_SIZE ( reg -> id ) ) ) <S2SV_EndBug> return - EFAULT ; return 0 ; }
CWE-20 static int set_core_reg ( struct kvm_vcpu * vcpu , const struct kvm_one_reg * reg ) { __u32 __user * uaddr = ( __u32 __user * ) ( unsigned long ) reg -> addr ; struct kvm_regs * regs = vcpu_gp_regs ( vcpu ) ; int nr_regs = sizeof ( * regs ) / sizeof ( __u32 ) ; __uint128_t tmp ; void * valp = & tmp ; u64 off ; int err = 0 ; off = core_reg_offset_from_id ( reg -> id ) ; if ( off >= nr_regs || ( off + ( KVM_REG_SIZE ( reg -> id ) / sizeof ( __u32 ) ) ) >= nr_regs ) return - ENOENT ; <S2SV_StartBug> if ( KVM_REG_SIZE ( reg -> id ) > sizeof ( tmp ) ) <S2SV_EndBug> return - EINVAL ; if ( copy_from_user ( valp , uaddr , KVM_REG_SIZE ( reg -> id ) ) ) { err = - EFAULT ; goto out ; } if ( off == KVM_REG_ARM_CORE_REG ( regs . pstate ) ) { u32 mode = ( * ( u32 * ) valp ) & PSR_AA32_MODE_MASK ; switch ( mode ) { case PSR_AA32_MODE_USR : case PSR_AA32_MODE_FIQ : case PSR_AA32_MODE_IRQ : case PSR_AA32_MODE_SVC : case PSR_AA32_MODE_ABT : case PSR_AA32_MODE_UND : case PSR_MODE_EL0t : case PSR_MODE_EL1t : case PSR_MODE_EL1h : break ; default : err = - EINVAL ; goto out ; } } memcpy ( ( u32 * ) regs + off , valp , KVM_REG_SIZE ( reg -> id ) ) ; out : return err ; }
CWE-20 static ssize_t map_write ( struct file * file , const char __user * buf , size_t count , loff_t * ppos , int cap_setid , struct uid_gid_map * map , struct uid_gid_map * parent_map ) { struct seq_file * seq = file -> private_data ; struct user_namespace * ns = seq -> private ; struct uid_gid_map new_map ; unsigned idx ; struct uid_gid_extent extent ; char * kbuf = NULL , * pos , * next_line ; ssize_t ret ; if ( ( * ppos != 0 ) || ( count >= PAGE_SIZE ) ) return - EINVAL ; kbuf = memdup_user_nul ( buf , count ) ; if ( IS_ERR ( kbuf ) ) return PTR_ERR ( kbuf ) ; mutex_lock ( & userns_state_mutex ) ; memset ( & new_map , 0 , sizeof ( struct uid_gid_map ) ) ; ret = - EPERM ; if ( map -> nr_extents != 0 ) goto out ; if ( cap_valid ( cap_setid ) && ! file_ns_capable ( file , ns , CAP_SYS_ADMIN ) ) goto out ; ret = - EINVAL ; pos = kbuf ; for ( ; pos ; pos = next_line ) { next_line = strchr ( pos , '\\n' ) ; if ( next_line ) { * next_line = '\\0' ; next_line ++ ; if ( * next_line == '\\0' ) next_line = NULL ; } pos = skip_spaces ( pos ) ; extent . first = simple_strtoul ( pos , & pos , 10 ) ; if ( ! isspace ( * pos ) ) goto out ; pos = skip_spaces ( pos ) ; extent . lower_first = simple_strtoul ( pos , & pos , 10 ) ; if ( ! isspace ( * pos ) ) goto out ; pos = skip_spaces ( pos ) ; extent . count = simple_strtoul ( pos , & pos , 10 ) ; if ( * pos && ! isspace ( * pos ) ) goto out ; pos = skip_spaces ( pos ) ; if ( * pos != '\\0' ) goto out ; if ( ( extent . first == ( u32 ) - 1 ) || ( extent . lower_first == ( u32 ) - 1 ) ) goto out ; if ( ( extent . first + extent . count ) <= extent . first ) goto out ; if ( ( extent . lower_first + extent . count ) <= extent . lower_first ) goto out ; if ( mappings_overlap ( & new_map , & extent ) ) goto out ; if ( ( new_map . nr_extents + 1 ) == UID_GID_MAP_MAX_EXTENTS && ( next_line != NULL ) ) goto out ; ret = insert_extent ( & new_map , & extent ) ; if ( ret < 0 ) goto out ; ret = - EINVAL ; } if ( new_map . nr_extents == 0 ) goto out ; ret = - EPERM ; <S2SV_StartBug> if ( ! new_idmap_permitted ( file , ns , cap_setid , & new_map ) ) <S2SV_EndBug> goto out ; ret = sort_idmaps ( & new_map ) ; if ( ret < 0 ) goto out ; ret = - EPERM ; for ( idx = 0 ; idx < new_map . nr_extents ; idx ++ ) { struct uid_gid_extent * e ; u32 lower_first ; if ( new_map . nr_extents <= UID_GID_MAP_MAX_BASE_EXTENTS ) e = & new_map . extent [ idx ] ; else e = & new_map . forward [ idx ] ; lower_first = map_id_range_down ( parent_map , e -> lower_first , e -> count ) ; if ( lower_first == ( u32 ) - 1 ) goto out ; e -> lower_first = lower_first ; } <S2SV_StartBug> if ( new_map . nr_extents <= UID_GID_MAP_MAX_BASE_EXTENTS ) { <S2SV_EndBug> memcpy ( map -> extent , new_map . extent , new_map . nr_extents * sizeof ( new_map . extent [ 0 ] ) ) ; } else { map -> forward = new_map . forward ; map -> reverse = new_map . reverse ; } smp_wmb ( ) ; map -> nr_extents = new_map . nr_extents ; * ppos = count ; ret = count ; out : if ( ret < 0 && new_map . nr_extents > UID_GID_MAP_MAX_BASE_EXTENTS ) { kfree ( new_map . forward ) ; kfree ( new_map . reverse ) ; map -> forward = NULL ; map -> reverse = NULL ; map -> nr_extents = 0 ; } mutex_unlock ( & userns_state_mutex ) ; kfree ( kbuf ) ; return ret ; }
CWE-189 static int adjust_scalar_min_max_vals ( struct bpf_verifier_env * env , struct bpf_insn * insn , struct bpf_reg_state * dst_reg , struct bpf_reg_state src_reg ) { struct bpf_reg_state * regs = cur_regs ( env ) ; u8 opcode = BPF_OP ( insn -> code ) ; bool src_known , dst_known ; s64 smin_val , smax_val ; u64 umin_val , umax_val ; <S2SV_StartBug> u64 insn_bitness = ( BPF_CLASS ( insn -> code ) == BPF_ALU64 ) ? 64 : 32 ; <S2SV_EndBug> if ( insn_bitness == 32 ) { coerce_reg_to_size ( dst_reg , 4 ) ; coerce_reg_to_size ( & src_reg , 4 ) ; } smin_val = src_reg . smin_value ; smax_val = src_reg . smax_value ; umin_val = src_reg . umin_value ; umax_val = src_reg . umax_value ; src_known = tnum_is_const ( src_reg . var_off ) ; dst_known = tnum_is_const ( dst_reg -> var_off ) ; if ( ( src_known && ( smin_val != smax_val || umin_val != umax_val ) ) || smin_val > smax_val || umin_val > umax_val ) { __mark_reg_unknown ( dst_reg ) ; return 0 ; } if ( ! src_known && opcode != BPF_ADD && opcode != BPF_SUB && opcode != BPF_AND ) { __mark_reg_unknown ( dst_reg ) ; return 0 ; } switch ( opcode ) { case BPF_ADD : <S2SV_StartBug> if ( signed_add_overflows ( dst_reg -> smin_value , smin_val ) || <S2SV_EndBug> signed_add_overflows ( dst_reg -> smax_value , smax_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value += smin_val ; dst_reg -> smax_value += smax_val ; } if ( dst_reg -> umin_value + umin_val < umin_val || dst_reg -> umax_value + umax_val < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value += umin_val ; dst_reg -> umax_value += umax_val ; } dst_reg -> var_off = tnum_add ( dst_reg -> var_off , src_reg . var_off ) ; break ; case BPF_SUB : <S2SV_StartBug> if ( signed_sub_overflows ( dst_reg -> smin_value , smax_val ) || <S2SV_EndBug> signed_sub_overflows ( dst_reg -> smax_value , smin_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value -= smax_val ; dst_reg -> smax_value -= smin_val ; } if ( dst_reg -> umin_value < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value -= umax_val ; dst_reg -> umax_value -= umin_val ; } dst_reg -> var_off = tnum_sub ( dst_reg -> var_off , src_reg . var_off ) ; break ; case BPF_MUL : dst_reg -> var_off = tnum_mul ( dst_reg -> var_off , src_reg . var_off ) ; if ( smin_val < 0 || dst_reg -> smin_value < 0 ) { __mark_reg_unbounded ( dst_reg ) ; __update_reg_bounds ( dst_reg ) ; break ; } if ( umax_val > U32_MAX || dst_reg -> umax_value > U32_MAX ) { __mark_reg_unbounded ( dst_reg ) ; __update_reg_bounds ( dst_reg ) ; break ; } dst_reg -> umin_value *= umin_val ; dst_reg -> umax_value *= umax_val ; if ( dst_reg -> umax_value > S64_MAX ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } break ; case BPF_AND : if ( src_known && dst_known ) { __mark_reg_known ( dst_reg , dst_reg -> var_off . value & src_reg . var_off . value ) ; break ; } dst_reg -> var_off = tnum_and ( dst_reg -> var_off , src_reg . var_off ) ; dst_reg -> umin_value = dst_reg -> var_off . value ; dst_reg -> umax_value = min ( dst_reg -> umax_value , umax_val ) ; if ( dst_reg -> smin_value < 0 || smin_val < 0 ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } __update_reg_bounds ( dst_reg ) ; break ; case BPF_OR : if ( src_known && dst_known ) { __mark_reg_known ( dst_reg , dst_reg -> var_off . value | src_reg . var_off . value ) ; break ; } dst_reg -> var_off = tnum_or ( dst_reg -> var_off , src_reg . var_off ) ; dst_reg -> umin_value = max ( dst_reg -> umin_value , umin_val ) ; dst_reg -> umax_value = dst_reg -> var_off . value | dst_reg -> var_off . mask ; if ( dst_reg -> smin_value < 0 || smin_val < 0 ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } __update_reg_bounds ( dst_reg ) ; break ; case BPF_LSH : if ( umax_val >= insn_bitness ) { mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; if ( dst_reg -> umax_value > 1ULL << ( 63 - umax_val ) ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value <<= umin_val ; dst_reg -> umax_value <<= umax_val ; } dst_reg -> var_off = tnum_lshift ( dst_reg -> var_off , umin_val ) ; __update_reg_bounds ( dst_reg ) ; break ; case BPF_RSH : if ( umax_val >= insn_bitness ) { mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; dst_reg -> var_off = tnum_rshift ( dst_reg -> var_off , umin_val ) ; dst_reg -> umin_value >>= umax_val ; dst_reg -> umax_value >>= umin_val ; __update_reg_bounds ( dst_reg ) ; break ; case BPF_ARSH : if ( umax_val >= insn_bitness ) { mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } dst_reg -> smin_value >>= umin_val ; dst_reg -> smax_value >>= umin_val ; dst_reg -> var_off = tnum_arshift ( dst_reg -> var_off , umin_val ) ; dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; __update_reg_bounds ( dst_reg ) ; break ; default : mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } if ( BPF_CLASS ( insn -> code ) != BPF_ALU64 ) { coerce_reg_to_size ( dst_reg , 4 ) ; } __reg_deduce_bounds ( dst_reg ) ; __reg_bound_offset ( dst_reg ) ; return 0 ; }
CWE-189 static int sanitize_ptr_alu ( struct bpf_verifier_env * env , struct bpf_insn * insn , const struct bpf_reg_state * ptr_reg , struct bpf_reg_state * dst_reg , bool off_is_neg ) { struct bpf_verifier_state * vstate = env -> cur_state ; struct bpf_insn_aux_data * aux = cur_aux ( env ) ; bool ptr_is_dst_reg = ptr_reg == dst_reg ; u8 opcode = BPF_OP ( insn -> code ) ; u32 alu_state , alu_limit ; struct bpf_reg_state tmp ; bool ret ; <S2SV_StartBug> if ( env -> allow_ptr_leaks || BPF_SRC ( insn -> code ) == BPF_K ) <S2SV_EndBug> return 0 ; if ( vstate -> speculative ) goto do_sim ; alu_state = off_is_neg ? BPF_ALU_NEG_VALUE : 0 ; alu_state |= ptr_is_dst_reg ? BPF_ALU_SANITIZE_SRC : BPF_ALU_SANITIZE_DST ; if ( retrieve_ptr_limit ( ptr_reg , & alu_limit , opcode , off_is_neg ) ) return 0 ; <S2SV_StartBug> if ( aux -> alu_state && <S2SV_EndBug> ( aux -> alu_state != alu_state || aux -> alu_limit != alu_limit ) ) <S2SV_StartBug> return - EACCES ; <S2SV_EndBug> aux -> alu_state = alu_state ; aux -> alu_limit = alu_limit ; do_sim : if ( ! ptr_is_dst_reg ) { tmp = * dst_reg ; * dst_reg = * ptr_reg ; } ret = push_stack ( env , env -> insn_idx + 1 , env -> insn_idx , true ) ; if ( ! ptr_is_dst_reg ) * dst_reg = tmp ; return ! ret ? - EFAULT : 0 ; }
CWE-476 int build_segment_manager ( struct f2fs_sb_info * sbi ) { struct f2fs_super_block * raw_super = F2FS_RAW_SUPER ( sbi ) ; struct f2fs_checkpoint * ckpt = F2FS_CKPT ( sbi ) ; struct f2fs_sm_info * sm_info ; int err ; sm_info = kzalloc ( sizeof ( struct f2fs_sm_info ) , GFP_KERNEL ) ; if ( ! sm_info ) return - ENOMEM ; sbi -> sm_info = sm_info ; sm_info -> seg0_blkaddr = le32_to_cpu ( raw_super -> segment0_blkaddr ) ; sm_info -> main_blkaddr = le32_to_cpu ( raw_super -> main_blkaddr ) ; sm_info -> segment_count = le32_to_cpu ( raw_super -> segment_count ) ; sm_info -> reserved_segments = le32_to_cpu ( ckpt -> rsvd_segment_count ) ; sm_info -> ovp_segments = le32_to_cpu ( ckpt -> overprov_segment_count ) ; sm_info -> main_segments = le32_to_cpu ( raw_super -> segment_count_main ) ; sm_info -> ssa_blkaddr = le32_to_cpu ( raw_super -> ssa_blkaddr ) ; sm_info -> rec_prefree_segments = sm_info -> main_segments * DEF_RECLAIM_PREFREE_SEGMENTS / 100 ; if ( sm_info -> rec_prefree_segments > DEF_MAX_RECLAIM_PREFREE_SEGMENTS ) sm_info -> rec_prefree_segments = DEF_MAX_RECLAIM_PREFREE_SEGMENTS ; if ( ! test_opt ( sbi , LFS ) ) sm_info -> ipu_policy = 1 << F2FS_IPU_FSYNC ; sm_info -> min_ipu_util = DEF_MIN_IPU_UTIL ; sm_info -> min_fsync_blocks = DEF_MIN_FSYNC_BLOCKS ; sm_info -> min_hot_blocks = DEF_MIN_HOT_BLOCKS ; sm_info -> trim_sections = DEF_BATCHED_TRIM_SECTIONS ; INIT_LIST_HEAD ( & sm_info -> sit_entry_set ) ; <S2SV_StartBug> if ( test_opt ( sbi , FLUSH_MERGE ) && ! f2fs_readonly ( sbi -> sb ) ) { <S2SV_EndBug> err = create_flush_cmd_control ( sbi ) ; if ( err ) return err ; } err = create_discard_cmd_control ( sbi ) ; if ( err ) return err ; err = build_sit_info ( sbi ) ; if ( err ) return err ; err = build_free_segmap ( sbi ) ; if ( err ) return err ; err = build_curseg ( sbi ) ; if ( err ) return err ; build_sit_entries ( sbi ) ; init_free_segmap ( sbi ) ; err = build_dirty_segmap ( sbi ) ; if ( err ) return err ; init_min_max_mtime ( sbi ) ; return 0 ; }
CWE-476 int create_flush_cmd_control ( struct f2fs_sb_info * sbi ) { dev_t dev = sbi -> sb -> s_bdev -> bd_dev ; struct flush_cmd_control * fcc ; int err = 0 ; if ( SM_I ( sbi ) -> fcc_info ) { fcc = SM_I ( sbi ) -> fcc_info ; goto init_thread ; } fcc = kzalloc ( sizeof ( struct flush_cmd_control ) , GFP_KERNEL ) ; if ( ! fcc ) return - ENOMEM ; atomic_set ( & fcc -> issued_flush , 0 ) ; atomic_set ( & fcc -> issing_flush , 0 ) ; init_waitqueue_head ( & fcc -> flush_wait_queue ) ; init_llist_head ( & fcc -> issue_list ) ; SM_I ( sbi ) -> fcc_info = fcc ; <S2SV_StartBug> init_thread : <S2SV_EndBug> fcc -> f2fs_issue_flush = kthread_run ( issue_flush_thread , sbi , "f2fs_flush-%u:%u" , MAJOR ( dev ) , MINOR ( dev ) ) ; if ( IS_ERR ( fcc -> f2fs_issue_flush ) ) { err = PTR_ERR ( fcc -> f2fs_issue_flush ) ; kfree ( fcc ) ; SM_I ( sbi ) -> fcc_info = NULL ; return err ; } return err ; }
CWE-763 static int pcrypt_create_aead ( struct crypto_template * tmpl , struct rtattr * * tb , u32 type , u32 mask ) { struct pcrypt_instance_ctx * ctx ; struct crypto_attr_type * algt ; struct aead_instance * inst ; struct aead_alg * alg ; const char * name ; int err ; algt = crypto_get_attr_type ( tb ) ; if ( IS_ERR ( algt ) ) return PTR_ERR ( algt ) ; name = crypto_attr_alg_name ( tb [ 1 ] ) ; if ( IS_ERR ( name ) ) return PTR_ERR ( name ) ; inst = kzalloc ( sizeof ( * inst ) + sizeof ( * ctx ) , GFP_KERNEL ) ; if ( ! inst ) return - ENOMEM ; ctx = aead_instance_ctx ( inst ) ; crypto_set_aead_spawn ( & ctx -> spawn , aead_crypto_instance ( inst ) ) ; err = crypto_grab_aead ( & ctx -> spawn , name , 0 , 0 ) ; if ( err ) goto out_free_inst ; alg = crypto_spawn_aead_alg ( & ctx -> spawn ) ; err = pcrypt_init_instance ( aead_crypto_instance ( inst ) , & alg -> base ) ; if ( err ) goto out_drop_aead ; inst -> alg . base . cra_flags = CRYPTO_ALG_ASYNC ; inst -> alg . ivsize = crypto_aead_alg_ivsize ( alg ) ; inst -> alg . maxauthsize = crypto_aead_alg_maxauthsize ( alg ) ; inst -> alg . base . cra_ctxsize = sizeof ( struct pcrypt_aead_ctx ) ; inst -> alg . init = pcrypt_aead_init_tfm ; inst -> alg . exit = pcrypt_aead_exit_tfm ; inst -> alg . setkey = pcrypt_aead_setkey ; inst -> alg . setauthsize = pcrypt_aead_setauthsize ; inst -> alg . encrypt = pcrypt_aead_encrypt ; inst -> alg . decrypt = pcrypt_aead_decrypt ; <S2SV_StartBug> err = aead_register_instance ( tmpl , inst ) ; <S2SV_EndBug> if ( err ) goto out_drop_aead ; out : return err ; out_drop_aead : crypto_drop_aead ( & ctx -> spawn ) ; out_free_inst : kfree ( inst ) ; goto out ; }
CWE-763 <S2SV_StartBug> static void pcrypt_free ( struct crypto_instance * inst ) <S2SV_EndBug> { <S2SV_StartBug> struct pcrypt_instance_ctx * ctx = crypto_instance_ctx ( inst ) ; <S2SV_EndBug> crypto_drop_aead ( & ctx -> spawn ) ; kfree ( inst ) ; }
CWE-125 static int set_geometry ( unsigned int cmd , struct floppy_struct * g , int drive , int type , struct block_device * bdev ) { int cnt ; <S2SV_StartBug> if ( g -> sect <= 0 || <S2SV_EndBug> <S2SV_StartBug> g -> head <= 0 || <S2SV_EndBug> ( unsigned char ) ( ( g -> sect << 2 ) >> FD_SIZECODE ( g ) ) == 0 || g -> track <= 0 || g -> track > UDP -> tracks >> STRETCH ( g ) || ( g -> stretch & ~ ( FD_STRETCH | FD_SWAPSIDES | FD_SECTBASEMASK ) ) != 0 ) return - EINVAL ; if ( type ) { if ( ! capable ( CAP_SYS_ADMIN ) ) return - EPERM ; mutex_lock ( & open_lock ) ; if ( lock_fdc ( drive ) ) { mutex_unlock ( & open_lock ) ; return - EINTR ; } floppy_type [ type ] = * g ; floppy_type [ type ] . name = "user<S2SV_blank>format" ; for ( cnt = type << 2 ; cnt < ( type << 2 ) + 4 ; cnt ++ ) floppy_sizes [ cnt ] = floppy_sizes [ cnt + 0x80 ] = floppy_type [ type ] . size + 1 ; process_fd_request ( ) ; for ( cnt = 0 ; cnt < N_DRIVE ; cnt ++ ) { struct block_device * bdev = opened_bdev [ cnt ] ; if ( ! bdev || ITYPE ( drive_state [ cnt ] . fd_device ) != type ) continue ; __invalidate_device ( bdev , true ) ; } mutex_unlock ( & open_lock ) ; } else { int oldStretch ; if ( lock_fdc ( drive ) ) return - EINTR ; if ( cmd != FDDEFPRM ) { if ( poll_drive ( true , FD_RAW_NEED_DISK ) == - EINTR ) return - EINTR ; } oldStretch = g -> stretch ; user_params [ drive ] = * g ; if ( buffer_drive == drive ) SUPBOUND ( buffer_max , user_params [ drive ] . sect ) ; current_type [ drive ] = & user_params [ drive ] ; floppy_sizes [ drive ] = user_params [ drive ] . size ; if ( cmd == FDDEFPRM ) DRS -> keep_data = - 1 ; else DRS -> keep_data = 1 ; if ( DRS -> maxblock > user_params [ drive ] . sect || DRS -> maxtrack || ( ( user_params [ drive ] . sect ^ oldStretch ) & ( FD_SWAPSIDES | FD_SECTBASEMASK ) ) ) invalidate_drive ( bdev ) ; else process_fd_request ( ) ; } return 0 ; }
CWE-119 bool f2fs_init_extent_tree ( struct inode * inode , struct f2fs_extent * i_ext ) { <S2SV_StartBug> struct f2fs_sb_info * sbi = F2FS_I_SB ( inode ) ; <S2SV_EndBug> struct extent_tree * et ; struct extent_node * en ; struct extent_info ei ; if ( ! f2fs_may_extent_tree ( inode ) ) { if ( i_ext && i_ext -> len ) { i_ext -> len = 0 ; return true ; } return false ; } et = __grab_extent_tree ( inode ) ; <S2SV_StartBug> if ( ! i_ext || ! i_ext -> len ) <S2SV_EndBug> return false ; get_extent_info ( & ei , i_ext ) ; write_lock ( & et -> lock ) ; if ( atomic_read ( & et -> node_cnt ) ) goto out ; en = __init_extent_tree ( sbi , et , & ei ) ; if ( en ) { spin_lock ( & sbi -> extent_lock ) ; list_add_tail ( & en -> list , & sbi -> extent_list ) ; spin_unlock ( & sbi -> extent_lock ) ; } out : write_unlock ( & et -> lock ) ; <S2SV_StartBug> return false ; <S2SV_EndBug> }
CWE-20 long kernel_wait4 ( pid_t upid , int __user * stat_addr , int options , struct rusage * ru ) { struct wait_opts wo ; struct pid * pid = NULL ; enum pid_type type ; long ret ; if ( options & ~ ( WNOHANG | WUNTRACED | WCONTINUED | __WNOTHREAD | __WCLONE | __WALL ) ) return - EINVAL ; <S2SV_StartBug> if ( upid == - 1 ) <S2SV_EndBug> type = PIDTYPE_MAX ; else if ( upid < 0 ) { type = PIDTYPE_PGID ; pid = find_get_pid ( - upid ) ; } else if ( upid == 0 ) { type = PIDTYPE_PGID ; pid = get_task_pid ( current , PIDTYPE_PGID ) ; } else { type = PIDTYPE_PID ; pid = find_get_pid ( upid ) ; } wo . wo_type = type ; wo . wo_pid = pid ; wo . wo_flags = options | WEXITED ; wo . wo_info = NULL ; wo . wo_stat = 0 ; wo . wo_rusage = ru ; ret = do_wait ( & wo ) ; put_pid ( pid ) ; if ( ret > 0 && stat_addr && put_user ( wo . wo_stat , stat_addr ) ) ret = - EFAULT ; return ret ; }
CWE-362 <S2SV_StartBug> static struct desc_struct * get_desc ( unsigned short sel ) <S2SV_EndBug> { struct desc_ptr gdt_desc = { 0 , 0 } ; unsigned long desc_base ; # ifdef CONFIG_MODIFY_LDT_SYSCALL if ( ( sel & SEGMENT_TI_MASK ) == SEGMENT_LDT ) { <S2SV_StartBug> struct desc_struct * desc = NULL ; <S2SV_EndBug> struct ldt_struct * ldt ; sel >>= 3 ; mutex_lock ( & current -> active_mm -> context . lock ) ; ldt = current -> active_mm -> context . ldt ; <S2SV_StartBug> if ( ldt && sel < ldt -> nr_entries ) <S2SV_EndBug> <S2SV_StartBug> desc = & ldt -> entries [ sel ] ; <S2SV_EndBug> mutex_unlock ( & current -> active_mm -> context . lock ) ; <S2SV_StartBug> return desc ; <S2SV_EndBug> } # endif native_store_gdt ( & gdt_desc ) ; desc_base = sel & ~ ( SEGMENT_RPL_MASK | SEGMENT_TI_MASK ) ; if ( desc_base > gdt_desc . size ) <S2SV_StartBug> return NULL ; <S2SV_EndBug> return ( struct desc_struct * ) ( gdt_desc . address + desc_base ) ; <S2SV_StartBug> } <S2SV_EndBug>
CWE-362 static unsigned long get_seg_limit ( struct pt_regs * regs , int seg_reg_idx ) { <S2SV_StartBug> struct desc_struct * desc ; <S2SV_EndBug> unsigned long limit ; short sel ; sel = get_segment_selector ( regs , seg_reg_idx ) ; if ( sel < 0 ) return 0 ; if ( user_64bit_mode ( regs ) || v8086_mode ( regs ) ) return - 1L ; if ( ! sel ) return 0 ; <S2SV_StartBug> desc = get_desc ( sel ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! desc ) <S2SV_EndBug> return 0 ; <S2SV_StartBug> limit = get_desc_limit ( desc ) ; <S2SV_EndBug> <S2SV_StartBug> if ( desc -> g ) <S2SV_EndBug> limit = ( limit << 12 ) + 0xfff ; return limit ; }
CWE-362 int insn_get_code_seg_params ( struct pt_regs * regs ) { <S2SV_StartBug> struct desc_struct * desc ; <S2SV_EndBug> short sel ; if ( v8086_mode ( regs ) ) return INSN_CODE_SEG_PARAMS ( 2 , 2 ) ; sel = get_segment_selector ( regs , INAT_SEG_REG_CS ) ; if ( sel < 0 ) return sel ; <S2SV_StartBug> desc = get_desc ( sel ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! desc ) <S2SV_EndBug> return - EINVAL ; <S2SV_StartBug> if ( ! ( desc -> type & BIT ( 3 ) ) ) <S2SV_EndBug> return - EINVAL ; <S2SV_StartBug> switch ( ( desc -> l << 1 ) | desc -> d ) { <S2SV_EndBug> case 0 : return INSN_CODE_SEG_PARAMS ( 2 , 2 ) ; case 1 : return INSN_CODE_SEG_PARAMS ( 4 , 4 ) ; case 2 : return INSN_CODE_SEG_PARAMS ( 4 , 8 ) ; case 3 : default : return - EINVAL ; } }
CWE-362 unsigned long insn_get_seg_base ( struct pt_regs * regs , int seg_reg_idx ) { <S2SV_StartBug> struct desc_struct * desc ; <S2SV_EndBug> short sel ; sel = get_segment_selector ( regs , seg_reg_idx ) ; if ( sel < 0 ) return - 1L ; if ( v8086_mode ( regs ) ) return ( unsigned long ) ( sel << 4 ) ; if ( user_64bit_mode ( regs ) ) { unsigned long base ; if ( seg_reg_idx == INAT_SEG_REG_FS ) rdmsrl ( MSR_FS_BASE , base ) ; else if ( seg_reg_idx == INAT_SEG_REG_GS ) rdmsrl ( MSR_KERNEL_GS_BASE , base ) ; else base = 0 ; return base ; } if ( ! sel ) return - 1L ; <S2SV_StartBug> desc = get_desc ( sel ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! desc ) <S2SV_EndBug> return - 1L ; <S2SV_StartBug> return get_desc_base ( desc ) ; <S2SV_EndBug> }
CWE-200 void __ip_select_ident ( struct net * net , struct iphdr * iph , int segs ) { <S2SV_StartBug> static u32 ip_idents_hashrnd __read_mostly ; <S2SV_EndBug> u32 hash , id ; <S2SV_StartBug> net_get_random_once ( & ip_idents_hashrnd , sizeof ( ip_idents_hashrnd ) ) ; <S2SV_EndBug> <S2SV_StartBug> hash = jhash_3words ( ( __force u32 ) iph -> daddr , <S2SV_EndBug> ( __force u32 ) iph -> saddr , <S2SV_StartBug> iph -> protocol ^ net_hash_mix ( net ) , <S2SV_EndBug> ip_idents_hashrnd ) ; id = ip_idents_reserve ( hash , segs ) ; iph -> id = htons ( id ) ; }
CWE-200 <S2SV_StartBug> static u32 __ipv6_select_ident ( struct net * net , u32 hashrnd , <S2SV_EndBug> const struct in6_addr * dst , const struct in6_addr * src ) { <S2SV_StartBug> u32 hash , id ; <S2SV_EndBug> <S2SV_StartBug> hash = __ipv6_addr_jhash ( dst , hashrnd ) ; <S2SV_EndBug> <S2SV_StartBug> hash = __ipv6_addr_jhash ( src , hash ) ; <S2SV_EndBug> hash ^= net_hash_mix ( net ) ; id = ip_idents_reserve ( hash , 1 ) ; if ( unlikely ( ! id ) ) id = 1 << 31 ; return id ; }
CWE-200 __be32 ipv6_proxy_select_ident ( struct net * net , struct sk_buff * skb ) { <S2SV_StartBug> static u32 ip6_proxy_idents_hashrnd __read_mostly ; <S2SV_EndBug> struct in6_addr buf [ 2 ] ; struct in6_addr * addrs ; u32 id ; addrs = skb_header_pointer ( skb , skb_network_offset ( skb ) + offsetof ( struct ipv6hdr , saddr ) , sizeof ( buf ) , buf ) ; if ( ! addrs ) return 0 ; <S2SV_StartBug> net_get_random_once ( & ip6_proxy_idents_hashrnd , <S2SV_EndBug> sizeof ( ip6_proxy_idents_hashrnd ) ) ; <S2SV_StartBug> id = __ipv6_select_ident ( net , ip6_proxy_idents_hashrnd , <S2SV_EndBug> & addrs [ 1 ] , & addrs [ 0 ] ) ; return htonl ( id ) ; }
CWE-200 __be32 ipv6_select_ident ( struct net * net , const struct in6_addr * daddr , const struct in6_addr * saddr ) { <S2SV_StartBug> static u32 ip6_idents_hashrnd __read_mostly ; <S2SV_EndBug> u32 id ; net_get_random_once ( & ip6_idents_hashrnd , sizeof ( ip6_idents_hashrnd ) ) ; <S2SV_StartBug> id = __ipv6_select_ident ( net , ip6_idents_hashrnd , daddr , saddr ) ; <S2SV_EndBug> return htonl ( id ) ; }
CWE-665 static struct ib_ucontext * hns_roce_alloc_ucontext ( struct ib_device * ib_dev , struct ib_udata * udata ) { int ret = 0 ; struct hns_roce_ucontext * context ; <S2SV_StartBug> struct hns_roce_ib_alloc_ucontext_resp resp ; <S2SV_EndBug> struct hns_roce_dev * hr_dev = to_hr_dev ( ib_dev ) ; resp . qp_tab_size = hr_dev -> caps . num_qps ; context = kmalloc ( sizeof ( * context ) , GFP_KERNEL ) ; if ( ! context ) return ERR_PTR ( - ENOMEM ) ; ret = hns_roce_uar_alloc ( hr_dev , & context -> uar ) ; if ( ret ) goto error_fail_uar_alloc ; if ( hr_dev -> caps . flags & HNS_ROCE_CAP_FLAG_RECORD_DB ) { INIT_LIST_HEAD ( & context -> page_list ) ; mutex_init ( & context -> page_mutex ) ; } ret = ib_copy_to_udata ( udata , & resp , sizeof ( resp ) ) ; if ( ret ) goto error_fail_copy_to_udata ; return & context -> ibucontext ; error_fail_copy_to_udata : hns_roce_uar_free ( hr_dev , & context -> uar ) ; error_fail_uar_alloc : kfree ( context ) ; return ERR_PTR ( ret ) ; }
CWE-200 static int cdrom_ioctl_select_disc ( struct cdrom_device_info * cdi , unsigned long arg ) { cd_dbg ( CD_DO_IOCTL , "entering<S2SV_blank>CDROM_SELECT_DISC\\n" ) ; if ( ! CDROM_CAN ( CDC_SELECT_DISC ) ) return - ENOSYS ; if ( arg != CDSL_CURRENT && arg != CDSL_NONE ) { <S2SV_StartBug> if ( ( int ) arg >= cdi -> capacity ) <S2SV_EndBug> return - EINVAL ; } if ( cdi -> ops -> select_disc ) return cdi -> ops -> select_disc ( cdi , arg ) ; cd_dbg ( CD_CHANGER , "Using<S2SV_blank>generic<S2SV_blank>cdrom_select_disc()\\n" ) ; return cdrom_select_disc ( cdi , arg ) ; }
CWE-20 static void * etm_setup_aux ( int event_cpu , void * * pages , int nr_pages , bool overwrite ) { int cpu ; cpumask_t * mask ; struct coresight_device * sink ; struct etm_event_data * event_data = NULL ; event_data = alloc_event_data ( event_cpu ) ; if ( ! event_data ) return NULL ; sink = coresight_get_enabled_sink ( true ) ; if ( ! sink ) goto err ; INIT_WORK ( & event_data -> work , free_event_data ) ; mask = & event_data -> mask ; for_each_cpu ( cpu , mask ) { struct coresight_device * csdev ; csdev = per_cpu ( csdev_src , cpu ) ; if ( ! csdev ) goto err ; event_data -> path [ cpu ] = coresight_build_path ( csdev , sink ) ; if ( IS_ERR ( event_data -> path [ cpu ] ) ) goto err ; } if ( ! sink_ops ( sink ) -> alloc_buffer ) goto err ; <S2SV_StartBug> event_data -> snk_config = <S2SV_EndBug> sink_ops ( sink ) -> alloc_buffer ( sink , cpu , pages , nr_pages , overwrite ) ; if ( ! event_data -> snk_config ) goto err ; out : return event_data ; err : etm_free_aux ( event_data ) ; event_data = NULL ; goto out ; }
CWE-476 static int pcd_detect ( void ) { char id [ 18 ] ; int k , unit ; struct pcd_unit * cd ; printk ( "%s:<S2SV_blank>%s<S2SV_blank>version<S2SV_blank>%s,<S2SV_blank>major<S2SV_blank>%d,<S2SV_blank>nice<S2SV_blank>%d\\n" , name , name , PCD_VERSION , major , nice ) ; par_drv = pi_register_driver ( name ) ; if ( ! par_drv ) { pr_err ( "failed<S2SV_blank>to<S2SV_blank>register<S2SV_blank>%s<S2SV_blank>driver\\n" , name ) ; return - 1 ; } k = 0 ; if ( pcd_drive_count == 0 ) { cd = pcd ; if ( pi_init ( cd -> pi , 1 , - 1 , - 1 , - 1 , - 1 , - 1 , pcd_buffer , PI_PCD , verbose , cd -> name ) ) { if ( ! pcd_probe ( cd , - 1 , id ) && cd -> disk ) { cd -> present = 1 ; k ++ ; } else pi_release ( cd -> pi ) ; } } else { for ( unit = 0 , cd = pcd ; unit < PCD_UNITS ; unit ++ , cd ++ ) { int * conf = * drives [ unit ] ; if ( ! conf [ D_PRT ] ) continue ; if ( ! pi_init ( cd -> pi , 0 , conf [ D_PRT ] , conf [ D_MOD ] , conf [ D_UNI ] , conf [ D_PRO ] , conf [ D_DLY ] , pcd_buffer , PI_PCD , verbose , cd -> name ) ) continue ; if ( ! pcd_probe ( cd , conf [ D_SLV ] , id ) && cd -> disk ) { cd -> present = 1 ; k ++ ; } else pi_release ( cd -> pi ) ; } } if ( k ) return 0 ; printk ( "%s:<S2SV_blank>No<S2SV_blank>CD-ROM<S2SV_blank>drive<S2SV_blank>found\\n" , name ) ; for ( unit = 0 , cd = pcd ; unit < PCD_UNITS ; unit ++ , cd ++ ) { <S2SV_StartBug> blk_cleanup_queue ( cd -> disk -> queue ) ; <S2SV_EndBug> cd -> disk -> queue = NULL ; blk_mq_free_tag_set ( & cd -> tag_set ) ; put_disk ( cd -> disk ) ; } pi_unregister_driver ( par_drv ) ; return - 1 ; }
CWE-476 static void pcd_init_units ( void ) { struct pcd_unit * cd ; int unit ; pcd_drive_count = 0 ; for ( unit = 0 , cd = pcd ; unit < PCD_UNITS ; unit ++ , cd ++ ) { struct gendisk * disk = alloc_disk ( 1 ) ; if ( ! disk ) continue ; disk -> queue = blk_mq_init_sq_queue ( & cd -> tag_set , & pcd_mq_ops , 1 , BLK_MQ_F_SHOULD_MERGE ) ; if ( IS_ERR ( disk -> queue ) ) { <S2SV_StartBug> disk -> queue = NULL ; <S2SV_EndBug> continue ; } INIT_LIST_HEAD ( & cd -> rq_list ) ; disk -> queue -> queuedata = cd ; blk_queue_bounce_limit ( disk -> queue , BLK_BOUNCE_HIGH ) ; cd -> disk = disk ; cd -> pi = & cd -> pia ; cd -> present = 0 ; cd -> last_sense = 0 ; cd -> changed = 1 ; cd -> drive = ( * drives [ unit ] ) [ D_SLV ] ; if ( ( * drives [ unit ] ) [ D_PRT ] ) pcd_drive_count ++ ; cd -> name = & cd -> info . name [ 0 ] ; snprintf ( cd -> name , sizeof ( cd -> info . name ) , "%s%d" , name , unit ) ; cd -> info . ops = & pcd_dops ; cd -> info . handle = cd ; cd -> info . speed = 0 ; cd -> info . capacity = 1 ; cd -> info . mask = 0 ; disk -> major = major ; disk -> first_minor = unit ; strcpy ( disk -> disk_name , cd -> name ) ; disk -> fops = & pcd_bdops ; disk -> flags = GENHD_FL_BLOCK_EVENTS_ON_EXCL_WRITE ; } }
CWE-20 static ssize_t yurex_read ( struct file * file , char __user * buffer , size_t count , loff_t * ppos ) { struct usb_yurex * dev ; <S2SV_StartBug> int retval = 0 ; <S2SV_EndBug> int bytes_read = 0 ; char in_buffer [ 20 ] ; unsigned long flags ; dev = file -> private_data ; mutex_lock ( & dev -> io_mutex ) ; if ( ! dev -> interface ) { <S2SV_StartBug> retval = - ENODEV ; <S2SV_EndBug> goto exit ; } spin_lock_irqsave ( & dev -> lock , flags ) ; <S2SV_StartBug> bytes_read = snprintf ( in_buffer , 20 , "%lld\\n" , dev -> bbu ) ; <S2SV_EndBug> spin_unlock_irqrestore ( & dev -> lock , flags ) ; <S2SV_StartBug> if ( * ppos < bytes_read ) { <S2SV_EndBug> if ( copy_to_user ( buffer , in_buffer + * ppos , bytes_read - * ppos ) ) retval = - EFAULT ; else { retval = bytes_read - * ppos ; * ppos += bytes_read ; } } exit : mutex_unlock ( & dev -> io_mutex ) ; <S2SV_StartBug> return retval ; <S2SV_EndBug> }
CWE-476 static int __rds_rdma_map ( struct rds_sock * rs , struct rds_get_mr_args * args , u64 * cookie_ret , struct rds_mr * * mr_ret ) { struct rds_mr * mr = NULL , * found ; unsigned int nr_pages ; struct page * * pages = NULL ; struct scatterlist * sg ; void * trans_private ; unsigned long flags ; rds_rdma_cookie_t cookie ; unsigned int nents ; long i ; int ret ; <S2SV_StartBug> if ( rs -> rs_bound_addr == 0 ) { <S2SV_EndBug> ret = - ENOTCONN ; goto out ; } if ( ! rs -> rs_transport -> get_mr ) { ret = - EOPNOTSUPP ; goto out ; } nr_pages = rds_pages_in_vec ( & args -> vec ) ; if ( nr_pages == 0 ) { ret = - EINVAL ; goto out ; } if ( ( nr_pages - 1 ) > ( RDS_MAX_MSG_SIZE >> PAGE_SHIFT ) ) { ret = - EMSGSIZE ; goto out ; } rdsdebug ( "RDS:<S2SV_blank>get_mr<S2SV_blank>addr<S2SV_blank>%llx<S2SV_blank>len<S2SV_blank>%llu<S2SV_blank>nr_pages<S2SV_blank>%u\\n" , args -> vec . addr , args -> vec . bytes , nr_pages ) ; pages = kcalloc ( nr_pages , sizeof ( struct page * ) , GFP_KERNEL ) ; if ( ! pages ) { ret = - ENOMEM ; goto out ; } mr = kzalloc ( sizeof ( struct rds_mr ) , GFP_KERNEL ) ; if ( ! mr ) { ret = - ENOMEM ; goto out ; } refcount_set ( & mr -> r_refcount , 1 ) ; RB_CLEAR_NODE ( & mr -> r_rb_node ) ; mr -> r_trans = rs -> rs_transport ; mr -> r_sock = rs ; if ( args -> flags & RDS_RDMA_USE_ONCE ) mr -> r_use_once = 1 ; if ( args -> flags & RDS_RDMA_INVALIDATE ) mr -> r_invalidate = 1 ; if ( args -> flags & RDS_RDMA_READWRITE ) mr -> r_write = 1 ; ret = rds_pin_pages ( args -> vec . addr , nr_pages , pages , 1 ) ; if ( ret < 0 ) goto out ; nents = ret ; sg = kcalloc ( nents , sizeof ( * sg ) , GFP_KERNEL ) ; if ( ! sg ) { ret = - ENOMEM ; goto out ; } WARN_ON ( ! nents ) ; sg_init_table ( sg , nents ) ; for ( i = 0 ; i < nents ; i ++ ) sg_set_page ( & sg [ i ] , pages [ i ] , PAGE_SIZE , 0 ) ; rdsdebug ( "RDS:<S2SV_blank>trans_private<S2SV_blank>nents<S2SV_blank>is<S2SV_blank>%u\\n" , nents ) ; trans_private = rs -> rs_transport -> get_mr ( sg , nents , rs , & mr -> r_key ) ; if ( IS_ERR ( trans_private ) ) { for ( i = 0 ; i < nents ; i ++ ) put_page ( sg_page ( & sg [ i ] ) ) ; kfree ( sg ) ; ret = PTR_ERR ( trans_private ) ; goto out ; } mr -> r_trans_private = trans_private ; rdsdebug ( "RDS:<S2SV_blank>get_mr<S2SV_blank>put_user<S2SV_blank>key<S2SV_blank>is<S2SV_blank>%x<S2SV_blank>cookie_addr<S2SV_blank>%p\\n" , mr -> r_key , ( void * ) ( unsigned long ) args -> cookie_addr ) ; cookie = rds_rdma_make_cookie ( mr -> r_key , args -> vec . addr & ~ PAGE_MASK ) ; if ( cookie_ret ) * cookie_ret = cookie ; if ( args -> cookie_addr && put_user ( cookie , ( u64 __user * ) ( unsigned long ) args -> cookie_addr ) ) { ret = - EFAULT ; goto out ; } spin_lock_irqsave ( & rs -> rs_rdma_lock , flags ) ; found = rds_mr_tree_walk ( & rs -> rs_rdma_keys , mr -> r_key , mr ) ; spin_unlock_irqrestore ( & rs -> rs_rdma_lock , flags ) ; BUG_ON ( found && found != mr ) ; rdsdebug ( "RDS:<S2SV_blank>get_mr<S2SV_blank>key<S2SV_blank>is<S2SV_blank>%x\\n" , mr -> r_key ) ; if ( mr_ret ) { refcount_inc ( & mr -> r_refcount ) ; * mr_ret = mr ; } ret = 0 ; out : kfree ( pages ) ; if ( mr ) rds_mr_put ( mr ) ; return ret ; }
CWE-369 static int set_geometry ( unsigned int cmd , struct floppy_struct * g , int drive , int type , struct block_device * bdev ) { int cnt ; if ( g -> sect <= 0 || <S2SV_StartBug> g -> head <= 0 || <S2SV_EndBug> g -> track <= 0 || g -> track > UDP -> tracks >> STRETCH ( g ) || ( g -> stretch & ~ ( FD_STRETCH | FD_SWAPSIDES | FD_SECTBASEMASK ) ) != 0 ) return - EINVAL ; if ( type ) { if ( ! capable ( CAP_SYS_ADMIN ) ) return - EPERM ; mutex_lock ( & open_lock ) ; if ( lock_fdc ( drive ) ) { mutex_unlock ( & open_lock ) ; return - EINTR ; } floppy_type [ type ] = * g ; floppy_type [ type ] . name = "user<S2SV_blank>format" ; for ( cnt = type << 2 ; cnt < ( type << 2 ) + 4 ; cnt ++ ) floppy_sizes [ cnt ] = floppy_sizes [ cnt + 0x80 ] = floppy_type [ type ] . size + 1 ; process_fd_request ( ) ; for ( cnt = 0 ; cnt < N_DRIVE ; cnt ++ ) { struct block_device * bdev = opened_bdev [ cnt ] ; if ( ! bdev || ITYPE ( drive_state [ cnt ] . fd_device ) != type ) continue ; __invalidate_device ( bdev , true ) ; } mutex_unlock ( & open_lock ) ; } else { int oldStretch ; if ( lock_fdc ( drive ) ) return - EINTR ; if ( cmd != FDDEFPRM ) { if ( poll_drive ( true , FD_RAW_NEED_DISK ) == - EINTR ) return - EINTR ; } oldStretch = g -> stretch ; user_params [ drive ] = * g ; if ( buffer_drive == drive ) SUPBOUND ( buffer_max , user_params [ drive ] . sect ) ; current_type [ drive ] = & user_params [ drive ] ; floppy_sizes [ drive ] = user_params [ drive ] . size ; if ( cmd == FDDEFPRM ) DRS -> keep_data = - 1 ; else DRS -> keep_data = 1 ; if ( DRS -> maxblock > user_params [ drive ] . sect || DRS -> maxtrack || ( ( user_params [ drive ] . sect ^ oldStretch ) & ( FD_SWAPSIDES | FD_SECTBASEMASK ) ) ) invalidate_drive ( bdev ) ; else process_fd_request ( ) ; } return 0 ; }
CWE-369 static void setup_format_params ( int track ) { int n ; int il ; int count ; int head_shift ; int track_shift ; struct fparm { unsigned char track , head , sect , size ; } * here = ( struct fparm * ) floppy_track_buffer ; raw_cmd = & default_raw_cmd ; raw_cmd -> track = track ; raw_cmd -> flags = ( FD_RAW_WRITE | FD_RAW_INTR | FD_RAW_SPIN | FD_RAW_NEED_DISK | FD_RAW_NEED_SEEK ) ; raw_cmd -> rate = _floppy -> rate & 0x43 ; raw_cmd -> cmd_count = NR_F ; COMMAND = FM_MODE ( _floppy , FD_FORMAT ) ; DR_SELECT = UNIT ( current_drive ) + PH_HEAD ( _floppy , format_req . head ) ; F_SIZECODE = FD_SIZECODE ( _floppy ) ; F_SECT_PER_TRACK = _floppy -> sect << 2 >> F_SIZECODE ; F_GAP = _floppy -> fmt_gap ; F_FILL = FD_FILL_BYTE ; raw_cmd -> kernel_data = floppy_track_buffer ; raw_cmd -> length = 4 * F_SECT_PER_TRACK ; <S2SV_StartBug> head_shift = ( F_SECT_PER_TRACK + 5 ) / 6 ; <S2SV_EndBug> track_shift = 2 * head_shift + 3 ; n = ( track_shift * format_req . track + head_shift * format_req . head ) % F_SECT_PER_TRACK ; il = 1 ; if ( _floppy -> fmt_gap < 0x22 ) il ++ ; for ( count = 0 ; count < F_SECT_PER_TRACK ; ++ count ) { here [ count ] . track = format_req . track ; here [ count ] . head = format_req . head ; here [ count ] . sect = 0 ; here [ count ] . size = F_SIZECODE ; } for ( count = 1 ; count <= F_SECT_PER_TRACK ; ++ count ) { here [ n ] . sect = count ; n = ( n + il ) % F_SECT_PER_TRACK ; if ( here [ n ] . sect ) { ++ n ; if ( n >= F_SECT_PER_TRACK ) { n -= F_SECT_PER_TRACK ; while ( here [ n ] . sect ) ++ n ; } } } if ( _floppy -> stretch & FD_SECTBASEMASK ) { for ( count = 0 ; count < F_SECT_PER_TRACK ; count ++ ) here [ count ] . sect += FD_SECTBASE ( _floppy ) - 1 ; } }
CWE-119 int sr_do_ioctl ( Scsi_CD * cd , struct packet_command * cgc ) { struct scsi_device * SDev ; struct scsi_sense_hdr sshdr ; int result , err = 0 , retries = 0 ; <S2SV_StartBug> SDev = cd -> device ; <S2SV_EndBug> retry : if ( ! scsi_block_when_processing_errors ( SDev ) ) { err = - ENODEV ; goto out ; } result = scsi_execute ( SDev , cgc -> cmd , cgc -> data_direction , cgc -> buffer , cgc -> buflen , <S2SV_StartBug> ( unsigned char * ) cgc -> sense , & sshdr , <S2SV_EndBug> cgc -> timeout , IOCTL_RETRIES , 0 , 0 , NULL ) ; if ( driver_byte ( result ) != 0 ) { switch ( sshdr . sense_key ) { case UNIT_ATTENTION : SDev -> changed = 1 ; if ( ! cgc -> quiet ) sr_printk ( KERN_INFO , cd , "disc<S2SV_blank>change<S2SV_blank>detected.\\n" ) ; if ( retries ++ < 10 ) goto retry ; err = - ENOMEDIUM ; break ; case NOT_READY : if ( sshdr . asc == 0x04 && sshdr . ascq == 0x01 ) { if ( ! cgc -> quiet ) sr_printk ( KERN_INFO , cd , "CDROM<S2SV_blank>not<S2SV_blank>ready<S2SV_blank>yet.\\n" ) ; if ( retries ++ < 10 ) { ssleep ( 2 ) ; goto retry ; } else { err = - ENOMEDIUM ; break ; } } if ( ! cgc -> quiet ) sr_printk ( KERN_INFO , cd , "CDROM<S2SV_blank>not<S2SV_blank>ready.<S2SV_blank><S2SV_blank>Make<S2SV_blank>sure<S2SV_blank>there<S2SV_blank>" "is<S2SV_blank>a<S2SV_blank>disc<S2SV_blank>in<S2SV_blank>the<S2SV_blank>drive.\\n" ) ; err = - ENOMEDIUM ; break ; case ILLEGAL_REQUEST : err = - EIO ; if ( sshdr . asc == 0x20 && sshdr . ascq == 0x00 ) err = - EDRIVE_CANT_DO_THIS ; break ; default : err = - EIO ; } } out : cgc -> stat = err ; return err ; }
CWE-190 static int futex_requeue ( u32 __user * uaddr1 , unsigned int flags , u32 __user * uaddr2 , int nr_wake , int nr_requeue , u32 * cmpval , int requeue_pi ) { union futex_key key1 = FUTEX_KEY_INIT , key2 = FUTEX_KEY_INIT ; int drop_count = 0 , task_count = 0 , ret ; struct futex_pi_state * pi_state = NULL ; struct futex_hash_bucket * hb1 , * hb2 ; struct futex_q * this , * next ; <S2SV_StartBug> DEFINE_WAKE_Q ( wake_q ) ; <S2SV_EndBug> if ( ! IS_ENABLED ( CONFIG_FUTEX_PI ) && requeue_pi ) return - ENOSYS ; if ( requeue_pi ) { if ( uaddr1 == uaddr2 ) return - EINVAL ; if ( refill_pi_state_cache ( ) ) return - ENOMEM ; if ( nr_wake != 1 ) return - EINVAL ; } retry : ret = get_futex_key ( uaddr1 , flags & FLAGS_SHARED , & key1 , VERIFY_READ ) ; if ( unlikely ( ret != 0 ) ) goto out ; ret = get_futex_key ( uaddr2 , flags & FLAGS_SHARED , & key2 , requeue_pi ? VERIFY_WRITE : VERIFY_READ ) ; if ( unlikely ( ret != 0 ) ) goto out_put_key1 ; if ( requeue_pi && match_futex ( & key1 , & key2 ) ) { ret = - EINVAL ; goto out_put_keys ; } hb1 = hash_futex ( & key1 ) ; hb2 = hash_futex ( & key2 ) ; retry_private : hb_waiters_inc ( hb2 ) ; double_lock_hb ( hb1 , hb2 ) ; if ( likely ( cmpval != NULL ) ) { u32 curval ; ret = get_futex_value_locked ( & curval , uaddr1 ) ; if ( unlikely ( ret ) ) { double_unlock_hb ( hb1 , hb2 ) ; hb_waiters_dec ( hb2 ) ; ret = get_user ( curval , uaddr1 ) ; if ( ret ) goto out_put_keys ; if ( ! ( flags & FLAGS_SHARED ) ) goto retry_private ; put_futex_key ( & key2 ) ; put_futex_key ( & key1 ) ; goto retry ; } if ( curval != * cmpval ) { ret = - EAGAIN ; goto out_unlock ; } } if ( requeue_pi && ( task_count - nr_wake < nr_requeue ) ) { ret = futex_proxy_trylock_atomic ( uaddr2 , hb1 , hb2 , & key1 , & key2 , & pi_state , nr_requeue ) ; if ( ret > 0 ) { WARN_ON ( pi_state ) ; drop_count ++ ; task_count ++ ; ret = lookup_pi_state ( uaddr2 , ret , hb2 , & key2 , & pi_state ) ; } switch ( ret ) { case 0 : break ; case - EFAULT : double_unlock_hb ( hb1 , hb2 ) ; hb_waiters_dec ( hb2 ) ; put_futex_key ( & key2 ) ; put_futex_key ( & key1 ) ; ret = fault_in_user_writeable ( uaddr2 ) ; if ( ! ret ) goto retry ; goto out ; case - EAGAIN : double_unlock_hb ( hb1 , hb2 ) ; hb_waiters_dec ( hb2 ) ; put_futex_key ( & key2 ) ; put_futex_key ( & key1 ) ; cond_resched ( ) ; goto retry ; default : goto out_unlock ; } } plist_for_each_entry_safe ( this , next , & hb1 -> chain , list ) { if ( task_count - nr_wake >= nr_requeue ) break ; if ( ! match_futex ( & this -> key , & key1 ) ) continue ; if ( ( requeue_pi && ! this -> rt_waiter ) || ( ! requeue_pi && this -> rt_waiter ) || this -> pi_state ) { ret = - EINVAL ; break ; } if ( ++ task_count <= nr_wake && ! requeue_pi ) { mark_wake_futex ( & wake_q , this ) ; continue ; } if ( requeue_pi && ! match_futex ( this -> requeue_pi_key , & key2 ) ) { ret = - EINVAL ; break ; } if ( requeue_pi ) { get_pi_state ( pi_state ) ; this -> pi_state = pi_state ; ret = rt_mutex_start_proxy_lock ( & pi_state -> pi_mutex , this -> rt_waiter , this -> task ) ; if ( ret == 1 ) { requeue_pi_wake_futex ( this , & key2 , hb2 ) ; drop_count ++ ; continue ; } else if ( ret ) { this -> pi_state = NULL ; put_pi_state ( pi_state ) ; break ; } } requeue_futex ( this , hb1 , hb2 , & key2 ) ; drop_count ++ ; } put_pi_state ( pi_state ) ; out_unlock : double_unlock_hb ( hb1 , hb2 ) ; wake_up_q ( & wake_q ) ; hb_waiters_dec ( hb2 ) ; while ( -- drop_count >= 0 ) drop_futex_key_refs ( & key1 ) ; out_put_keys : put_futex_key ( & key2 ) ; out_put_key1 : put_futex_key ( & key1 ) ; out : return ret ? ret : task_count ; }
CWE-119 static void ssdp_recv ( int sd ) { ssize_t len ; struct sockaddr sa ; socklen_t salen ; <S2SV_StartBug> char buf [ MAX_PKT_SIZE ] ; <S2SV_EndBug> memset ( buf , 0 , sizeof ( buf ) ) ; <S2SV_StartBug> len = recvfrom ( sd , buf , sizeof ( buf ) , MSG_DONTWAIT , & sa , & salen ) ; <S2SV_EndBug> if ( len > 0 ) { <S2SV_StartBug> buf [ len ] = 0 ; <S2SV_EndBug> if ( sa . sa_family != AF_INET ) return ; if ( strstr ( buf , "M-SEARCH<S2SV_blank>*" ) ) { size_t i ; char * ptr , * type ; struct ifsock * ifs ; struct sockaddr_in * sin = ( struct sockaddr_in * ) & sa ; ifs = find_outbound ( & sa ) ; if ( ! ifs ) { logit ( LOG_DEBUG , "No<S2SV_blank>matching<S2SV_blank>socket<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s" , inet_ntoa ( sin -> sin_addr ) ) ; return ; } logit ( LOG_DEBUG , "Matching<S2SV_blank>socket<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s" , inet_ntoa ( sin -> sin_addr ) ) ; type = strcasestr ( buf , "\\r\\nST:" ) ; if ( ! type ) { logit ( LOG_DEBUG , "No<S2SV_blank>Search<S2SV_blank>Type<S2SV_blank>(ST:)<S2SV_blank>found<S2SV_blank>in<S2SV_blank>M-SEARCH<S2SV_blank>*,<S2SV_blank>assuming<S2SV_blank>" SSDP_ST_ALL ) ; type = SSDP_ST_ALL ; send_message ( ifs , type , & sa ) ; return ; } type = strchr ( type , ':' ) ; if ( ! type ) return ; type ++ ; while ( isspace ( * type ) ) type ++ ; ptr = strstr ( type , "\\r\\n" ) ; if ( ! ptr ) return ; * ptr = 0 ; for ( i = 0 ; supported_types [ i ] ; i ++ ) { if ( ! strcmp ( supported_types [ i ] , type ) ) { logit ( LOG_DEBUG , "M-SEARCH<S2SV_blank>*<S2SV_blank>ST:<S2SV_blank>%s<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>port<S2SV_blank>%d" , type , inet_ntoa ( sin -> sin_addr ) , ntohs ( sin -> sin_port ) ) ; send_message ( ifs , type , & sa ) ; return ; } } logit ( LOG_DEBUG , "M-SEARCH<S2SV_blank>*<S2SV_blank>for<S2SV_blank>unsupported<S2SV_blank>ST:<S2SV_blank>%s<S2SV_blank>from<S2SV_blank>%s" , type , inet_ntoa ( sin -> sin_addr ) ) ; } } }
CWE-190 void opj_get_all_encoding_parameters ( const opj_image_t * p_image , const opj_cp_t * p_cp , OPJ_UINT32 tileno , OPJ_INT32 * p_tx0 , OPJ_INT32 * p_tx1 , OPJ_INT32 * p_ty0 , OPJ_INT32 * p_ty1 , OPJ_UINT32 * p_dx_min , OPJ_UINT32 * p_dy_min , OPJ_UINT32 * p_max_prec , OPJ_UINT32 * p_max_res , OPJ_UINT32 * * p_resolutions ) { OPJ_UINT32 compno , resno ; const opj_tcp_t * tcp = 00 ; const opj_tccp_t * l_tccp = 00 ; const opj_image_comp_t * l_img_comp = 00 ; OPJ_UINT32 * lResolutionPtr ; OPJ_UINT32 p , q ; assert ( p_cp != 00 ) ; assert ( p_image != 00 ) ; assert ( tileno < p_cp -> tw * p_cp -> th ) ; tcp = & p_cp -> tcps [ tileno ] ; l_tccp = tcp -> tccps ; l_img_comp = p_image -> comps ; p = tileno % p_cp -> tw ; q = tileno / p_cp -> tw ; <S2SV_StartBug> * p_tx0 = opj_int_max ( ( OPJ_INT32 ) ( p_cp -> tx0 + p * p_cp -> tdx ) , ( OPJ_INT32 ) p_image -> x0 ) ; <S2SV_EndBug> <S2SV_StartBug> * p_tx1 = opj_int_min ( ( OPJ_INT32 ) ( p_cp -> tx0 + ( p + 1 ) * p_cp -> tdx ) , ( OPJ_INT32 ) p_image -> x1 ) ; <S2SV_EndBug> <S2SV_StartBug> * p_ty0 = opj_int_max ( ( OPJ_INT32 ) ( p_cp -> ty0 + q * p_cp -> tdy ) , ( OPJ_INT32 ) p_image -> y0 ) ; <S2SV_EndBug> <S2SV_StartBug> * p_ty1 = opj_int_min ( ( OPJ_INT32 ) ( p_cp -> ty0 + ( q + 1 ) * p_cp -> tdy ) , ( OPJ_INT32 ) p_image -> y1 ) ; <S2SV_EndBug> * p_max_prec = 0 ; * p_max_res = 0 ; * p_dx_min = 0x7fffffff ; * p_dy_min = 0x7fffffff ; for ( compno = 0 ; compno < p_image -> numcomps ; ++ compno ) { OPJ_UINT32 l_level_no ; OPJ_INT32 l_rx0 , l_ry0 , l_rx1 , l_ry1 ; OPJ_INT32 l_px0 , l_py0 , l_px1 , py1 ; OPJ_UINT32 l_product ; OPJ_INT32 l_tcx0 , l_tcy0 , l_tcx1 , l_tcy1 ; OPJ_UINT32 l_pdx , l_pdy , l_pw , l_ph ; lResolutionPtr = p_resolutions [ compno ] ; l_tcx0 = opj_int_ceildiv ( * p_tx0 , ( OPJ_INT32 ) l_img_comp -> dx ) ; l_tcy0 = opj_int_ceildiv ( * p_ty0 , ( OPJ_INT32 ) l_img_comp -> dy ) ; l_tcx1 = opj_int_ceildiv ( * p_tx1 , ( OPJ_INT32 ) l_img_comp -> dx ) ; l_tcy1 = opj_int_ceildiv ( * p_ty1 , ( OPJ_INT32 ) l_img_comp -> dy ) ; if ( l_tccp -> numresolutions > * p_max_res ) { * p_max_res = l_tccp -> numresolutions ; } l_level_no = l_tccp -> numresolutions - 1 ; for ( resno = 0 ; resno < l_tccp -> numresolutions ; ++ resno ) { OPJ_UINT32 l_dx , l_dy ; l_pdx = l_tccp -> prcw [ resno ] ; l_pdy = l_tccp -> prch [ resno ] ; * lResolutionPtr ++ = l_pdx ; * lResolutionPtr ++ = l_pdy ; l_dx = l_img_comp -> dx * ( 1u << ( l_pdx + l_level_no ) ) ; l_dy = l_img_comp -> dy * ( 1u << ( l_pdy + l_level_no ) ) ; * p_dx_min = ( OPJ_UINT32 ) opj_int_min ( ( OPJ_INT32 ) * p_dx_min , ( OPJ_INT32 ) l_dx ) ; * p_dy_min = ( OPJ_UINT32 ) opj_int_min ( ( OPJ_INT32 ) * p_dy_min , ( OPJ_INT32 ) l_dy ) ; l_rx0 = opj_int_ceildivpow2 ( l_tcx0 , ( OPJ_INT32 ) l_level_no ) ; l_ry0 = opj_int_ceildivpow2 ( l_tcy0 , ( OPJ_INT32 ) l_level_no ) ; l_rx1 = opj_int_ceildivpow2 ( l_tcx1 , ( OPJ_INT32 ) l_level_no ) ; l_ry1 = opj_int_ceildivpow2 ( l_tcy1 , ( OPJ_INT32 ) l_level_no ) ; l_px0 = opj_int_floordivpow2 ( l_rx0 , ( OPJ_INT32 ) l_pdx ) << l_pdx ; l_py0 = opj_int_floordivpow2 ( l_ry0 , ( OPJ_INT32 ) l_pdy ) << l_pdy ; l_px1 = opj_int_ceildivpow2 ( l_rx1 , ( OPJ_INT32 ) l_pdx ) << l_pdx ; py1 = opj_int_ceildivpow2 ( l_ry1 , ( OPJ_INT32 ) l_pdy ) << l_pdy ; l_pw = ( l_rx0 == l_rx1 ) ? 0 : ( OPJ_UINT32 ) ( ( l_px1 - l_px0 ) >> l_pdx ) ; l_ph = ( l_ry0 == l_ry1 ) ? 0 : ( OPJ_UINT32 ) ( ( py1 - l_py0 ) >> l_pdy ) ; * lResolutionPtr ++ = l_pw ; * lResolutionPtr ++ = l_ph ; l_product = l_pw * l_ph ; if ( l_product > * p_max_prec ) { * p_max_prec = l_product ; } -- l_level_no ; } ++ l_tccp ; ++ l_img_comp ; } }
CWE-400 static OPJ_BOOL bmp_read_rle8_data ( FILE * IN , OPJ_UINT8 * pData , OPJ_UINT32 stride , OPJ_UINT32 width , OPJ_UINT32 height ) { <S2SV_StartBug> OPJ_UINT32 x , y ; <S2SV_EndBug> OPJ_UINT8 * pix ; const OPJ_UINT8 * beyond ; beyond = pData + stride * height ; pix = pData ; <S2SV_StartBug> x = y = 0U ; <S2SV_EndBug> while ( y < height ) { int c = getc ( IN ) ; if ( c == EOF ) { return OPJ_FALSE ; } if ( c ) { int j , c1_int ; OPJ_UINT8 c1 ; c1_int = getc ( IN ) ; if ( c1_int == EOF ) { return OPJ_FALSE ; } c1 = ( OPJ_UINT8 ) c1_int ; for ( j = 0 ; ( j < c ) && ( x < width ) && ( ( OPJ_SIZE_T ) pix < ( OPJ_SIZE_T ) beyond ) ; j ++ , x ++ , pix ++ ) { <S2SV_StartBug> * pix = c1 ; <S2SV_EndBug> } } else { c = getc ( IN ) ; if ( c == EOF ) { return OPJ_FALSE ; } if ( c == 0x00 ) { x = 0 ; ++ y ; pix = pData + y * stride + x ; } else if ( c == 0x01 ) { break ; } else if ( c == 0x02 ) { c = getc ( IN ) ; if ( c == EOF ) { return OPJ_FALSE ; } x += ( OPJ_UINT32 ) c ; c = getc ( IN ) ; if ( c == EOF ) { return OPJ_FALSE ; } y += ( OPJ_UINT32 ) c ; pix = pData + y * stride + x ; } else { int j ; for ( j = 0 ; ( j < c ) && ( x < width ) && ( ( OPJ_SIZE_T ) pix < ( OPJ_SIZE_T ) beyond ) ; j ++ , x ++ , pix ++ ) { int c1_int ; OPJ_UINT8 c1 ; c1_int = getc ( IN ) ; if ( c1_int == EOF ) { return OPJ_FALSE ; } c1 = ( OPJ_UINT8 ) c1_int ; * pix = c1 ; <S2SV_StartBug> } <S2SV_EndBug> if ( ( OPJ_UINT32 ) c & 1U ) { c = getc ( IN ) ; if ( c == EOF ) { return OPJ_FALSE ; } } } } } <S2SV_StartBug> return OPJ_TRUE ; <S2SV_EndBug> }
CWE-119 char * uwsgi_expand_path ( char * dir , int dir_len , char * ptr ) { <S2SV_StartBug> char src [ PATH_MAX + 1 ] ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( src , dir , dir_len ) ; <S2SV_EndBug> src [ dir_len ] = 0 ; char * dst = ptr ; if ( ! dst ) dst = uwsgi_malloc ( PATH_MAX + 1 ) ; if ( ! realpath ( src , dst ) ) { uwsgi_error_realpath ( src ) ; if ( ! ptr ) free ( dst ) ; <S2SV_StartBug> return NULL ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> return dst ; }
CWE-369 void * _TIFFmalloc ( tmsize_t s ) <S2SV_StartBug> { <S2SV_EndBug> return ( malloc ( ( size_t ) s ) ) ; }
CWE-369 tdata_t _TIFFmalloc ( tsize_t s ) <S2SV_StartBug> { <S2SV_EndBug> return ( malloc ( ( size_t ) s ) ) ; }
CWE-369 void * _TIFFmalloc ( tmsize_t s ) <S2SV_StartBug> { <S2SV_EndBug> return ( malloc ( ( size_t ) s ) ) ; }
CWE-119 NTSTATUS ProcessMainDeviceControlIrp ( PDEVICE_OBJECT DeviceObject , PEXTENSION Extension , PIRP Irp ) { PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation ( Irp ) ; NTSTATUS ntStatus ; switch ( irpSp -> Parameters . DeviceIoControl . IoControlCode ) { case TC_IOCTL_GET_DRIVER_VERSION : case TC_IOCTL_LEGACY_GET_DRIVER_VERSION : if ( ValidateIOBufferSize ( Irp , sizeof ( LONG ) , ValidateOutput ) ) { LONG tmp = VERSION_NUM ; memcpy ( Irp -> AssociatedIrp . SystemBuffer , & tmp , 4 ) ; Irp -> IoStatus . Information = sizeof ( LONG ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_GET_DEVICE_REFCOUNT : if ( ValidateIOBufferSize ( Irp , sizeof ( int ) , ValidateOutput ) ) { * ( int * ) Irp -> AssociatedIrp . SystemBuffer = DeviceObject -> ReferenceCount ; Irp -> IoStatus . Information = sizeof ( int ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_IS_DRIVER_UNLOAD_DISABLED : if ( ValidateIOBufferSize ( Irp , sizeof ( int ) , ValidateOutput ) ) { LONG deviceObjectCount = 0 ; * ( int * ) Irp -> AssociatedIrp . SystemBuffer = DriverUnloadDisabled ; if ( IoEnumerateDeviceObjectList ( TCDriverObject , NULL , 0 , & deviceObjectCount ) == STATUS_BUFFER_TOO_SMALL && deviceObjectCount > 1 ) * ( int * ) Irp -> AssociatedIrp . SystemBuffer = TRUE ; Irp -> IoStatus . Information = sizeof ( int ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_IS_ANY_VOLUME_MOUNTED : if ( ValidateIOBufferSize ( Irp , sizeof ( int ) , ValidateOutput ) ) { int drive ; * ( int * ) Irp -> AssociatedIrp . SystemBuffer = 0 ; for ( drive = MIN_MOUNTED_VOLUME_DRIVE_NUMBER ; drive <= MAX_MOUNTED_VOLUME_DRIVE_NUMBER ; ++ drive ) { if ( GetVirtualVolumeDeviceObject ( drive ) ) { * ( int * ) Irp -> AssociatedIrp . SystemBuffer = 1 ; break ; } } if ( IsBootDriveMounted ( ) ) * ( int * ) Irp -> AssociatedIrp . SystemBuffer = 1 ; Irp -> IoStatus . Information = sizeof ( int ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_OPEN_TEST : { OPEN_TEST_STRUCT * opentest = ( OPEN_TEST_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; OBJECT_ATTRIBUTES ObjectAttributes ; HANDLE NtFileHandle ; UNICODE_STRING FullFileName ; IO_STATUS_BLOCK IoStatus ; LARGE_INTEGER offset ; ACCESS_MASK access = FILE_READ_ATTRIBUTES ; if ( ! ValidateIOBufferSize ( Irp , sizeof ( OPEN_TEST_STRUCT ) , ValidateInputOutput ) ) break ; EnsureNullTerminatedString ( opentest -> wszFileName , sizeof ( opentest -> wszFileName ) ) ; RtlInitUnicodeString ( & FullFileName , opentest -> wszFileName ) ; InitializeObjectAttributes ( & ObjectAttributes , & FullFileName , OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE , NULL , NULL ) ; if ( opentest -> bDetectTCBootLoader || opentest -> DetectFilesystem || opentest -> bComputeVolumeIDs ) access |= FILE_READ_DATA ; ntStatus = ZwCreateFile ( & NtFileHandle , SYNCHRONIZE | access , & ObjectAttributes , & IoStatus , NULL , 0 , FILE_SHARE_READ | FILE_SHARE_WRITE , FILE_OPEN , FILE_SYNCHRONOUS_IO_NONALERT , NULL , 0 ) ; if ( NT_SUCCESS ( ntStatus ) ) { opentest -> TCBootLoaderDetected = FALSE ; opentest -> FilesystemDetected = FALSE ; memset ( opentest -> VolumeIDComputed , 0 , sizeof ( opentest -> VolumeIDComputed ) ) ; memset ( opentest -> volumeIDs , 0 , sizeof ( opentest -> volumeIDs ) ) ; if ( opentest -> bDetectTCBootLoader || opentest -> DetectFilesystem || opentest -> bComputeVolumeIDs ) { byte * readBuffer = TCalloc ( TC_MAX_VOLUME_SECTOR_SIZE ) ; if ( ! readBuffer ) { ntStatus = STATUS_INSUFFICIENT_RESOURCES ; } else { if ( opentest -> bDetectTCBootLoader || opentest -> DetectFilesystem ) { offset . QuadPart = 0 ; ntStatus = ZwReadFile ( NtFileHandle , NULL , NULL , NULL , & IoStatus , readBuffer , TC_MAX_VOLUME_SECTOR_SIZE , & offset , NULL ) ; if ( NT_SUCCESS ( ntStatus ) ) { size_t i ; if ( opentest -> bDetectTCBootLoader && IoStatus . Information >= TC_SECTOR_SIZE_BIOS ) { for ( i = 0 ; i < TC_SECTOR_SIZE_BIOS - strlen ( TC_APP_NAME ) ; ++ i ) { if ( memcmp ( readBuffer + i , TC_APP_NAME , strlen ( TC_APP_NAME ) ) == 0 ) { opentest -> TCBootLoaderDetected = TRUE ; break ; } } } if ( opentest -> DetectFilesystem && IoStatus . Information >= sizeof ( int64 ) ) { switch ( BE64 ( * ( uint64 * ) readBuffer ) ) { case 0xEB52904E54465320ULL : case 0xEB3C904D53444F53ULL : case 0xEB58904D53444F53ULL : case 0xEB76904558464154ULL : case 0x0000005265465300ULL : case 0xEB58906D6B66732EULL : case 0xEB58906D6B646F73ULL : case 0xEB3C906D6B66732EULL : case 0xEB3C906D6B646F73ULL : opentest -> FilesystemDetected = TRUE ; break ; case 0x0000000000000000ULL : if ( IsAllZeroes ( readBuffer + 8 , TC_VOLUME_HEADER_EFFECTIVE_SIZE - 8 ) ) opentest -> FilesystemDetected = TRUE ; break ; } } } } if ( opentest -> bComputeVolumeIDs && ( ! opentest -> DetectFilesystem || ! opentest -> FilesystemDetected ) ) { int volumeType ; for ( volumeType = TC_VOLUME_TYPE_NORMAL ; volumeType < TC_VOLUME_TYPE_COUNT ; volumeType ++ ) { switch ( volumeType ) { case TC_VOLUME_TYPE_NORMAL : offset . QuadPart = TC_VOLUME_HEADER_OFFSET ; break ; case TC_VOLUME_TYPE_HIDDEN : offset . QuadPart = TC_HIDDEN_VOLUME_HEADER_OFFSET ; break ; } ntStatus = ZwReadFile ( NtFileHandle , NULL , NULL , NULL , & IoStatus , readBuffer , TC_MAX_VOLUME_SECTOR_SIZE , & offset , NULL ) ; if ( NT_SUCCESS ( ntStatus ) ) { sha256 ( opentest -> volumeIDs [ volumeType ] , readBuffer , TC_VOLUME_HEADER_EFFECTIVE_SIZE ) ; opentest -> VolumeIDComputed [ volumeType ] = TRUE ; } } } TCfree ( readBuffer ) ; } } ZwClose ( NtFileHandle ) ; Dump ( "Open<S2SV_blank>test<S2SV_blank>on<S2SV_blank>file<S2SV_blank>%ls<S2SV_blank>success.\\n" , opentest -> wszFileName ) ; } else { # if 0 Dump ( "Open<S2SV_blank>test<S2SV_blank>on<S2SV_blank>file<S2SV_blank>%ls<S2SV_blank>failed<S2SV_blank>NTSTATUS<S2SV_blank>0x%08x\\n" , opentest -> wszFileName , ntStatus ) ; # endif } Irp -> IoStatus . Information = NT_SUCCESS ( ntStatus ) ? sizeof ( OPEN_TEST_STRUCT ) : 0 ; Irp -> IoStatus . Status = ntStatus ; } break ; case TC_IOCTL_GET_SYSTEM_DRIVE_CONFIG : { GetSystemDriveConfigurationRequest * request = ( GetSystemDriveConfigurationRequest * ) Irp -> AssociatedIrp . SystemBuffer ; OBJECT_ATTRIBUTES ObjectAttributes ; HANDLE NtFileHandle ; UNICODE_STRING FullFileName ; IO_STATUS_BLOCK IoStatus ; LARGE_INTEGER offset ; <S2SV_StartBug> byte readBuffer [ TC_SECTOR_SIZE_BIOS ] ; <S2SV_EndBug> if ( ! ValidateIOBufferSize ( Irp , sizeof ( GetSystemDriveConfigurationRequest ) , ValidateInputOutput ) ) <S2SV_StartBug> break ; <S2SV_EndBug> EnsureNullTerminatedString ( request -> DevicePath , sizeof ( request -> DevicePath ) ) ; RtlInitUnicodeString ( & FullFileName , request -> DevicePath ) ; InitializeObjectAttributes ( & ObjectAttributes , & FullFileName , OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE , NULL , NULL ) ; ntStatus = ZwCreateFile ( & NtFileHandle , SYNCHRONIZE | GENERIC_READ , & ObjectAttributes , & IoStatus , NULL , FILE_ATTRIBUTE_NORMAL , FILE_SHARE_READ | FILE_SHARE_WRITE , FILE_OPEN , FILE_SYNCHRONOUS_IO_NONALERT | FILE_RANDOM_ACCESS , NULL , 0 ) ; if ( NT_SUCCESS ( ntStatus ) ) { <S2SV_StartBug> offset . QuadPart = 0 ; <S2SV_EndBug> ntStatus = ZwReadFile ( NtFileHandle , NULL , NULL , NULL , & IoStatus , readBuffer , <S2SV_StartBug> sizeof ( readBuffer ) , <S2SV_EndBug> & offset , NULL ) ; <S2SV_StartBug> if ( NT_SUCCESS ( ntStatus ) ) <S2SV_EndBug> { size_t i ; request -> DriveIsDynamic = FALSE ; if ( readBuffer [ 510 ] == 0x55 && readBuffer [ 511 ] == 0xaa ) { int i ; for ( i = 0 ; i < 4 ; ++ i ) { if ( readBuffer [ 446 + i * 16 + 4 ] == PARTITION_LDM ) { request -> DriveIsDynamic = TRUE ; break ; } } } request -> BootLoaderVersion = 0 ; request -> Configuration = 0 ; request -> UserConfiguration = 0 ; request -> CustomUserMessage [ 0 ] = 0 ; for ( i = 0 ; i < sizeof ( readBuffer ) - strlen ( TC_APP_NAME ) ; ++ i ) { if ( memcmp ( readBuffer + i , TC_APP_NAME , strlen ( TC_APP_NAME ) ) == 0 ) { request -> BootLoaderVersion = BE16 ( * ( uint16 * ) ( readBuffer + TC_BOOT_SECTOR_VERSION_OFFSET ) ) ; request -> Configuration = readBuffer [ TC_BOOT_SECTOR_CONFIG_OFFSET ] ; if ( request -> BootLoaderVersion != 0 && request -> BootLoaderVersion <= VERSION_NUM ) { request -> UserConfiguration = readBuffer [ TC_BOOT_SECTOR_USER_CONFIG_OFFSET ] ; memcpy ( request -> CustomUserMessage , readBuffer + TC_BOOT_SECTOR_USER_MESSAGE_OFFSET , TC_BOOT_SECTOR_USER_MESSAGE_MAX_LENGTH ) ; } break ; } } Irp -> IoStatus . Status = STATUS_SUCCESS ; Irp -> IoStatus . Information = sizeof ( * request ) ; } else { <S2SV_StartBug> Irp -> IoStatus . Status = ntStatus ; <S2SV_EndBug> <S2SV_StartBug> Irp -> IoStatus . Information = 0 ; <S2SV_EndBug> } ZwClose ( NtFileHandle ) ; } else { Irp -> IoStatus . Status = ntStatus ; Irp -> IoStatus . Information = 0 ; } } break ; case TC_IOCTL_WIPE_PASSWORD_CACHE : WipeCache ( ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_GET_PASSWORD_CACHE_STATUS : Irp -> IoStatus . Status = cacheEmpty ? STATUS_PIPE_EMPTY : STATUS_SUCCESS ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_SET_PORTABLE_MODE_STATUS : if ( ! UserCanAccessDriveDevice ( ) ) { Irp -> IoStatus . Status = STATUS_ACCESS_DENIED ; Irp -> IoStatus . Information = 0 ; } else { PortableMode = TRUE ; Dump ( "Setting<S2SV_blank>portable<S2SV_blank>mode\\n" ) ; } break ; case TC_IOCTL_GET_PORTABLE_MODE_STATUS : Irp -> IoStatus . Status = PortableMode ? STATUS_SUCCESS : STATUS_PIPE_EMPTY ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_GET_MOUNTED_VOLUMES : if ( ValidateIOBufferSize ( Irp , sizeof ( MOUNT_LIST_STRUCT ) , ValidateOutput ) ) { MOUNT_LIST_STRUCT * list = ( MOUNT_LIST_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; PDEVICE_OBJECT ListDevice ; int drive ; list -> ulMountedDrives = 0 ; for ( drive = MIN_MOUNTED_VOLUME_DRIVE_NUMBER ; drive <= MAX_MOUNTED_VOLUME_DRIVE_NUMBER ; ++ drive ) { PEXTENSION ListExtension ; ListDevice = GetVirtualVolumeDeviceObject ( drive ) ; if ( ! ListDevice ) continue ; ListExtension = ( PEXTENSION ) ListDevice -> DeviceExtension ; if ( IsVolumeAccessibleByCurrentUser ( ListExtension ) ) { list -> ulMountedDrives |= ( 1 << ListExtension -> nDosDriveNo ) ; RtlStringCbCopyW ( list -> wszVolume [ ListExtension -> nDosDriveNo ] , sizeof ( list -> wszVolume [ ListExtension -> nDosDriveNo ] ) , ListExtension -> wszVolume ) ; RtlStringCbCopyW ( list -> wszLabel [ ListExtension -> nDosDriveNo ] , sizeof ( list -> wszLabel [ ListExtension -> nDosDriveNo ] ) , ListExtension -> wszLabel ) ; memcpy ( list -> volumeID [ ListExtension -> nDosDriveNo ] , ListExtension -> volumeID , VOLUME_ID_SIZE ) ; list -> diskLength [ ListExtension -> nDosDriveNo ] = ListExtension -> DiskLength ; list -> ea [ ListExtension -> nDosDriveNo ] = ListExtension -> cryptoInfo -> ea ; if ( ListExtension -> cryptoInfo -> hiddenVolume ) list -> volumeType [ ListExtension -> nDosDriveNo ] = PROP_VOL_TYPE_HIDDEN ; else if ( ListExtension -> cryptoInfo -> bHiddenVolProtectionAction ) list -> volumeType [ ListExtension -> nDosDriveNo ] = PROP_VOL_TYPE_OUTER_VOL_WRITE_PREVENTED ; else if ( ListExtension -> cryptoInfo -> bProtectHiddenVolume ) list -> volumeType [ ListExtension -> nDosDriveNo ] = PROP_VOL_TYPE_OUTER ; else list -> volumeType [ ListExtension -> nDosDriveNo ] = PROP_VOL_TYPE_NORMAL ; list -> truecryptMode [ ListExtension -> nDosDriveNo ] = ListExtension -> cryptoInfo -> bTrueCryptMode ; } } Irp -> IoStatus . Status = STATUS_SUCCESS ; Irp -> IoStatus . Information = sizeof ( MOUNT_LIST_STRUCT ) ; } break ; case TC_IOCTL_LEGACY_GET_MOUNTED_VOLUMES : if ( ValidateIOBufferSize ( Irp , sizeof ( uint32 ) , ValidateOutput ) ) { memset ( Irp -> AssociatedIrp . SystemBuffer , 0 , irpSp -> Parameters . DeviceIoControl . OutputBufferLength ) ; * ( uint32 * ) Irp -> AssociatedIrp . SystemBuffer = 0xffffFFFF ; Irp -> IoStatus . Status = STATUS_SUCCESS ; Irp -> IoStatus . Information = irpSp -> Parameters . DeviceIoControl . OutputBufferLength ; } break ; case TC_IOCTL_GET_VOLUME_PROPERTIES : if ( ValidateIOBufferSize ( Irp , sizeof ( VOLUME_PROPERTIES_STRUCT ) , ValidateInputOutput ) ) { VOLUME_PROPERTIES_STRUCT * prop = ( VOLUME_PROPERTIES_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; PDEVICE_OBJECT ListDevice = GetVirtualVolumeDeviceObject ( prop -> driveNo ) ; Irp -> IoStatus . Status = STATUS_INVALID_PARAMETER ; Irp -> IoStatus . Information = 0 ; if ( ListDevice ) { PEXTENSION ListExtension = ( PEXTENSION ) ListDevice -> DeviceExtension ; if ( IsVolumeAccessibleByCurrentUser ( ListExtension ) ) { prop -> uniqueId = ListExtension -> UniqueVolumeId ; RtlStringCbCopyW ( prop -> wszVolume , sizeof ( prop -> wszVolume ) , ListExtension -> wszVolume ) ; RtlStringCbCopyW ( prop -> wszLabel , sizeof ( prop -> wszLabel ) , ListExtension -> wszLabel ) ; memcpy ( prop -> volumeID , ListExtension -> volumeID , VOLUME_ID_SIZE ) ; prop -> bDriverSetLabel = ListExtension -> bDriverSetLabel ; prop -> diskLength = ListExtension -> DiskLength ; prop -> ea = ListExtension -> cryptoInfo -> ea ; prop -> mode = ListExtension -> cryptoInfo -> mode ; prop -> pkcs5 = ListExtension -> cryptoInfo -> pkcs5 ; prop -> pkcs5Iterations = ListExtension -> cryptoInfo -> noIterations ; prop -> volumePim = ListExtension -> cryptoInfo -> volumePim ; # if 0 prop -> volumeCreationTime = ListExtension -> cryptoInfo -> volume_creation_time ; prop -> headerCreationTime = ListExtension -> cryptoInfo -> header_creation_time ; # endif prop -> volumeHeaderFlags = ListExtension -> cryptoInfo -> HeaderFlags ; prop -> readOnly = ListExtension -> bReadOnly ; prop -> removable = ListExtension -> bRemovable ; prop -> partitionInInactiveSysEncScope = ListExtension -> PartitionInInactiveSysEncScope ; prop -> hiddenVolume = ListExtension -> cryptoInfo -> hiddenVolume ; if ( ListExtension -> cryptoInfo -> bProtectHiddenVolume ) prop -> hiddenVolProtection = ListExtension -> cryptoInfo -> bHiddenVolProtectionAction ? HIDVOL_PROT_STATUS_ACTION_TAKEN : HIDVOL_PROT_STATUS_ACTIVE ; else prop -> hiddenVolProtection = HIDVOL_PROT_STATUS_NONE ; prop -> totalBytesRead = ListExtension -> Queue . TotalBytesRead ; prop -> totalBytesWritten = ListExtension -> Queue . TotalBytesWritten ; prop -> volFormatVersion = ListExtension -> cryptoInfo -> LegacyVolume ? TC_VOLUME_FORMAT_VERSION_PRE_6_0 : TC_VOLUME_FORMAT_VERSION ; Irp -> IoStatus . Status = STATUS_SUCCESS ; Irp -> IoStatus . Information = sizeof ( VOLUME_PROPERTIES_STRUCT ) ; } } } break ; case TC_IOCTL_GET_RESOLVED_SYMLINK : if ( ValidateIOBufferSize ( Irp , sizeof ( RESOLVE_SYMLINK_STRUCT ) , ValidateInputOutput ) ) { RESOLVE_SYMLINK_STRUCT * resolve = ( RESOLVE_SYMLINK_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; { NTSTATUS ntStatus ; EnsureNullTerminatedString ( resolve -> symLinkName , sizeof ( resolve -> symLinkName ) ) ; ntStatus = SymbolicLinkToTarget ( resolve -> symLinkName , resolve -> targetName , sizeof ( resolve -> targetName ) ) ; Irp -> IoStatus . Information = sizeof ( RESOLVE_SYMLINK_STRUCT ) ; Irp -> IoStatus . Status = ntStatus ; } } break ; case TC_IOCTL_GET_DRIVE_PARTITION_INFO : if ( ValidateIOBufferSize ( Irp , sizeof ( DISK_PARTITION_INFO_STRUCT ) , ValidateInputOutput ) ) { DISK_PARTITION_INFO_STRUCT * info = ( DISK_PARTITION_INFO_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; { PARTITION_INFORMATION_EX pi ; NTSTATUS ntStatus ; EnsureNullTerminatedString ( info -> deviceName , sizeof ( info -> deviceName ) ) ; ntStatus = TCDeviceIoControl ( info -> deviceName , IOCTL_DISK_GET_PARTITION_INFO_EX , NULL , 0 , & pi , sizeof ( pi ) ) ; if ( NT_SUCCESS ( ntStatus ) ) { memset ( & info -> partInfo , 0 , sizeof ( info -> partInfo ) ) ; info -> partInfo . PartitionLength = pi . PartitionLength ; info -> partInfo . PartitionNumber = pi . PartitionNumber ; info -> partInfo . StartingOffset = pi . StartingOffset ; if ( pi . PartitionStyle == PARTITION_STYLE_MBR ) { info -> partInfo . PartitionType = pi . Mbr . PartitionType ; info -> partInfo . BootIndicator = pi . Mbr . BootIndicator ; } info -> IsGPT = pi . PartitionStyle == PARTITION_STYLE_GPT ; } else { ntStatus = TCDeviceIoControl ( info -> deviceName , IOCTL_DISK_GET_PARTITION_INFO , NULL , 0 , & info -> partInfo , sizeof ( info -> partInfo ) ) ; info -> IsGPT = FALSE ; } if ( ! NT_SUCCESS ( ntStatus ) ) { GET_LENGTH_INFORMATION lengthInfo ; ntStatus = TCDeviceIoControl ( info -> deviceName , IOCTL_DISK_GET_LENGTH_INFO , NULL , 0 , & lengthInfo , sizeof ( lengthInfo ) ) ; if ( NT_SUCCESS ( ntStatus ) ) { memset ( & info -> partInfo , 0 , sizeof ( info -> partInfo ) ) ; info -> partInfo . PartitionLength = lengthInfo . Length ; } } info -> IsDynamic = FALSE ; if ( NT_SUCCESS ( ntStatus ) && OsMajorVersion >= 6 ) { # define IOCTL_VOLUME_IS_DYNAMIC CTL_CODE ( IOCTL_VOLUME_BASE , 18 , METHOD_BUFFERED , FILE_ANY_ACCESS ) if ( ! NT_SUCCESS ( TCDeviceIoControl ( info -> deviceName , IOCTL_VOLUME_IS_DYNAMIC , NULL , 0 , & info -> IsDynamic , sizeof ( info -> IsDynamic ) ) ) ) info -> IsDynamic = FALSE ; } Irp -> IoStatus . Information = sizeof ( DISK_PARTITION_INFO_STRUCT ) ; Irp -> IoStatus . Status = ntStatus ; } } break ; case TC_IOCTL_GET_DRIVE_GEOMETRY : if ( ValidateIOBufferSize ( Irp , sizeof ( DISK_GEOMETRY_STRUCT ) , ValidateInputOutput ) ) { DISK_GEOMETRY_STRUCT * g = ( DISK_GEOMETRY_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; { NTSTATUS ntStatus ; EnsureNullTerminatedString ( g -> deviceName , sizeof ( g -> deviceName ) ) ; Dump ( "Calling<S2SV_blank>IOCTL_DISK_GET_DRIVE_GEOMETRY<S2SV_blank>on<S2SV_blank>%ls\\n" , g -> deviceName ) ; ntStatus = TCDeviceIoControl ( g -> deviceName , IOCTL_DISK_GET_DRIVE_GEOMETRY , NULL , 0 , & g -> diskGeometry , sizeof ( g -> diskGeometry ) ) ; Irp -> IoStatus . Information = sizeof ( DISK_GEOMETRY_STRUCT ) ; Irp -> IoStatus . Status = ntStatus ; } } break ; case VC_IOCTL_GET_DRIVE_GEOMETRY_EX : if ( ValidateIOBufferSize ( Irp , sizeof ( DISK_GEOMETRY_EX_STRUCT ) , ValidateInputOutput ) ) { DISK_GEOMETRY_EX_STRUCT * g = ( DISK_GEOMETRY_EX_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; { NTSTATUS ntStatus ; PVOID buffer = TCalloc ( 256 ) ; if ( buffer ) { EnsureNullTerminatedString ( g -> deviceName , sizeof ( g -> deviceName ) ) ; Dump ( "Calling<S2SV_blank>IOCTL_DISK_GET_DRIVE_GEOMETRY_EX<S2SV_blank>on<S2SV_blank>%ls\\n" , g -> deviceName ) ; ntStatus = TCDeviceIoControl ( g -> deviceName , IOCTL_DISK_GET_DRIVE_GEOMETRY_EX , NULL , 0 , buffer , 256 ) ; if ( NT_SUCCESS ( ntStatus ) ) { PDISK_GEOMETRY_EX pGeo = ( PDISK_GEOMETRY_EX ) buffer ; memcpy ( & g -> diskGeometry , & pGeo -> Geometry , sizeof ( DISK_GEOMETRY ) ) ; g -> DiskSize . QuadPart = pGeo -> DiskSize . QuadPart ; } else { DISK_GEOMETRY dg = { 0 } ; Dump ( "Failed.<S2SV_blank>Calling<S2SV_blank>IOCTL_DISK_GET_DRIVE_GEOMETRY<S2SV_blank>on<S2SV_blank>%ls\\n" , g -> deviceName ) ; ntStatus = TCDeviceIoControl ( g -> deviceName , IOCTL_DISK_GET_DRIVE_GEOMETRY , NULL , 0 , & dg , sizeof ( dg ) ) ; if ( NT_SUCCESS ( ntStatus ) ) { memcpy ( & g -> diskGeometry , & dg , sizeof ( DISK_GEOMETRY ) ) ; g -> DiskSize . QuadPart = dg . Cylinders . QuadPart * dg . SectorsPerTrack * dg . TracksPerCylinder * dg . BytesPerSector ; if ( OsMajorVersion >= 6 ) { STORAGE_READ_CAPACITY storage = { 0 } ; NTSTATUS lStatus ; storage . Version = sizeof ( STORAGE_READ_CAPACITY ) ; Dump ( "Calling<S2SV_blank>IOCTL_STORAGE_READ_CAPACITY<S2SV_blank>on<S2SV_blank>%ls\\n" , g -> deviceName ) ; lStatus = TCDeviceIoControl ( g -> deviceName , IOCTL_STORAGE_READ_CAPACITY , NULL , 0 , & storage , sizeof ( STORAGE_READ_CAPACITY ) ) ; if ( NT_SUCCESS ( lStatus ) && ( storage . Size == sizeof ( STORAGE_READ_CAPACITY ) ) ) { g -> DiskSize . QuadPart = storage . DiskLength . QuadPart ; } } } } TCfree ( buffer ) ; Irp -> IoStatus . Information = sizeof ( DISK_GEOMETRY_EX_STRUCT ) ; Irp -> IoStatus . Status = ntStatus ; } else { Irp -> IoStatus . Status = STATUS_INSUFFICIENT_RESOURCES ; Irp -> IoStatus . Information = 0 ; } } } break ; case TC_IOCTL_PROBE_REAL_DRIVE_SIZE : if ( ValidateIOBufferSize ( Irp , sizeof ( ProbeRealDriveSizeRequest ) , ValidateInputOutput ) ) { ProbeRealDriveSizeRequest * request = ( ProbeRealDriveSizeRequest * ) Irp -> AssociatedIrp . SystemBuffer ; NTSTATUS status ; UNICODE_STRING name ; PFILE_OBJECT fileObject ; PDEVICE_OBJECT deviceObject ; EnsureNullTerminatedString ( request -> DeviceName , sizeof ( request -> DeviceName ) ) ; RtlInitUnicodeString ( & name , request -> DeviceName ) ; status = IoGetDeviceObjectPointer ( & name , FILE_READ_ATTRIBUTES , & fileObject , & deviceObject ) ; if ( ! NT_SUCCESS ( status ) ) { Irp -> IoStatus . Information = 0 ; Irp -> IoStatus . Status = status ; break ; } status = ProbeRealDriveSize ( deviceObject , & request -> RealDriveSize ) ; ObDereferenceObject ( fileObject ) ; if ( status == STATUS_TIMEOUT ) { request -> TimeOut = TRUE ; Irp -> IoStatus . Information = sizeof ( ProbeRealDriveSizeRequest ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } else if ( ! NT_SUCCESS ( status ) ) { Irp -> IoStatus . Information = 0 ; Irp -> IoStatus . Status = status ; } else { request -> TimeOut = FALSE ; Irp -> IoStatus . Information = sizeof ( ProbeRealDriveSizeRequest ) ; Irp -> IoStatus . Status = status ; } } break ; case TC_IOCTL_MOUNT_VOLUME : if ( ValidateIOBufferSize ( Irp , sizeof ( MOUNT_STRUCT ) , ValidateInputOutput ) ) { MOUNT_STRUCT * mount = ( MOUNT_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; if ( mount -> VolumePassword . Length > MAX_PASSWORD || mount -> ProtectedHidVolPassword . Length > MAX_PASSWORD || mount -> pkcs5_prf < 0 || mount -> pkcs5_prf > LAST_PRF_ID || mount -> VolumePim < - 1 || mount -> VolumePim == INT_MAX || mount -> ProtectedHidVolPkcs5Prf < 0 || mount -> ProtectedHidVolPkcs5Prf > LAST_PRF_ID || ( mount -> bTrueCryptMode != FALSE && mount -> bTrueCryptMode != TRUE ) ) { Irp -> IoStatus . Status = STATUS_INVALID_PARAMETER ; Irp -> IoStatus . Information = 0 ; break ; } EnsureNullTerminatedString ( mount -> wszVolume , sizeof ( mount -> wszVolume ) ) ; EnsureNullTerminatedString ( mount -> wszLabel , sizeof ( mount -> wszLabel ) ) ; Irp -> IoStatus . Information = sizeof ( MOUNT_STRUCT ) ; Irp -> IoStatus . Status = MountDevice ( DeviceObject , mount ) ; burn ( & mount -> VolumePassword , sizeof ( mount -> VolumePassword ) ) ; burn ( & mount -> ProtectedHidVolPassword , sizeof ( mount -> ProtectedHidVolPassword ) ) ; burn ( & mount -> pkcs5_prf , sizeof ( mount -> pkcs5_prf ) ) ; burn ( & mount -> VolumePim , sizeof ( mount -> VolumePim ) ) ; burn ( & mount -> bTrueCryptMode , sizeof ( mount -> bTrueCryptMode ) ) ; burn ( & mount -> ProtectedHidVolPkcs5Prf , sizeof ( mount -> ProtectedHidVolPkcs5Prf ) ) ; burn ( & mount -> ProtectedHidVolPim , sizeof ( mount -> ProtectedHidVolPim ) ) ; } break ; case TC_IOCTL_DISMOUNT_VOLUME : if ( ValidateIOBufferSize ( Irp , sizeof ( UNMOUNT_STRUCT ) , ValidateInputOutput ) ) { UNMOUNT_STRUCT * unmount = ( UNMOUNT_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; PDEVICE_OBJECT ListDevice = GetVirtualVolumeDeviceObject ( unmount -> nDosDriveNo ) ; unmount -> nReturnCode = ERR_DRIVE_NOT_FOUND ; if ( ListDevice ) { PEXTENSION ListExtension = ( PEXTENSION ) ListDevice -> DeviceExtension ; if ( IsVolumeAccessibleByCurrentUser ( ListExtension ) ) unmount -> nReturnCode = UnmountDevice ( unmount , ListDevice , unmount -> ignoreOpenFiles ) ; } Irp -> IoStatus . Information = sizeof ( UNMOUNT_STRUCT ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_DISMOUNT_ALL_VOLUMES : if ( ValidateIOBufferSize ( Irp , sizeof ( UNMOUNT_STRUCT ) , ValidateInputOutput ) ) { UNMOUNT_STRUCT * unmount = ( UNMOUNT_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; unmount -> nReturnCode = UnmountAllDevices ( unmount , unmount -> ignoreOpenFiles ) ; Irp -> IoStatus . Information = sizeof ( UNMOUNT_STRUCT ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_BOOT_ENCRYPTION_SETUP : Irp -> IoStatus . Status = StartBootEncryptionSetup ( DeviceObject , Irp , irpSp ) ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_ABORT_BOOT_ENCRYPTION_SETUP : Irp -> IoStatus . Status = AbortBootEncryptionSetup ( ) ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_GET_BOOT_ENCRYPTION_STATUS : GetBootEncryptionStatus ( Irp , irpSp ) ; break ; case TC_IOCTL_GET_BOOT_ENCRYPTION_SETUP_RESULT : Irp -> IoStatus . Information = 0 ; Irp -> IoStatus . Status = GetSetupResult ( ) ; break ; case TC_IOCTL_GET_BOOT_DRIVE_VOLUME_PROPERTIES : GetBootDriveVolumeProperties ( Irp , irpSp ) ; break ; case TC_IOCTL_GET_BOOT_LOADER_VERSION : GetBootLoaderVersion ( Irp , irpSp ) ; break ; case TC_IOCTL_REOPEN_BOOT_VOLUME_HEADER : ReopenBootVolumeHeader ( Irp , irpSp ) ; break ; case VC_IOCTL_GET_BOOT_LOADER_FINGERPRINT : GetBootLoaderFingerprint ( Irp , irpSp ) ; break ; case TC_IOCTL_GET_BOOT_ENCRYPTION_ALGORITHM_NAME : GetBootEncryptionAlgorithmName ( Irp , irpSp ) ; break ; case TC_IOCTL_IS_HIDDEN_SYSTEM_RUNNING : if ( ValidateIOBufferSize ( Irp , sizeof ( int ) , ValidateOutput ) ) { * ( int * ) Irp -> AssociatedIrp . SystemBuffer = IsHiddenSystemRunning ( ) ? 1 : 0 ; Irp -> IoStatus . Information = sizeof ( int ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_START_DECOY_SYSTEM_WIPE : Irp -> IoStatus . Status = StartDecoySystemWipe ( DeviceObject , Irp , irpSp ) ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_ABORT_DECOY_SYSTEM_WIPE : Irp -> IoStatus . Status = AbortDecoySystemWipe ( ) ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_GET_DECOY_SYSTEM_WIPE_RESULT : Irp -> IoStatus . Status = GetDecoySystemWipeResult ( ) ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_GET_DECOY_SYSTEM_WIPE_STATUS : GetDecoySystemWipeStatus ( Irp , irpSp ) ; break ; case TC_IOCTL_WRITE_BOOT_DRIVE_SECTOR : Irp -> IoStatus . Status = WriteBootDriveSector ( Irp , irpSp ) ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_GET_WARNING_FLAGS : if ( ValidateIOBufferSize ( Irp , sizeof ( GetWarningFlagsRequest ) , ValidateOutput ) ) { GetWarningFlagsRequest * flags = ( GetWarningFlagsRequest * ) Irp -> AssociatedIrp . SystemBuffer ; flags -> PagingFileCreationPrevented = PagingFileCreationPrevented ; PagingFileCreationPrevented = FALSE ; flags -> SystemFavoriteVolumeDirty = SystemFavoriteVolumeDirty ; SystemFavoriteVolumeDirty = FALSE ; Irp -> IoStatus . Information = sizeof ( GetWarningFlagsRequest ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_SET_SYSTEM_FAVORITE_VOLUME_DIRTY : if ( UserCanAccessDriveDevice ( ) ) { SystemFavoriteVolumeDirty = TRUE ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } else Irp -> IoStatus . Status = STATUS_ACCESS_DENIED ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_REREAD_DRIVER_CONFIG : Irp -> IoStatus . Status = ReadRegistryConfigFlags ( FALSE ) ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_GET_SYSTEM_DRIVE_DUMP_CONFIG : if ( ( ValidateIOBufferSize ( Irp , sizeof ( GetSystemDriveDumpConfigRequest ) , ValidateOutput ) ) && ( Irp -> RequestorMode == KernelMode ) ) { GetSystemDriveDumpConfigRequest * request = ( GetSystemDriveDumpConfigRequest * ) Irp -> AssociatedIrp . SystemBuffer ; request -> BootDriveFilterExtension = GetBootDriveFilterExtension ( ) ; if ( IsBootDriveMounted ( ) && request -> BootDriveFilterExtension ) { request -> HwEncryptionEnabled = IsHwEncryptionEnabled ( ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; Irp -> IoStatus . Information = sizeof ( * request ) ; } else { Irp -> IoStatus . Status = STATUS_INVALID_PARAMETER ; Irp -> IoStatus . Information = 0 ; } } break ; default : return TCCompleteIrp ( Irp , STATUS_INVALID_DEVICE_REQUEST , 0 ) ; } # if defined ( DEBUG ) || defined ( DEBUG_TRACE ) if ( ! NT_SUCCESS ( Irp -> IoStatus . Status ) ) { switch ( irpSp -> Parameters . DeviceIoControl . IoControlCode ) { case TC_IOCTL_GET_MOUNTED_VOLUMES : case TC_IOCTL_GET_PASSWORD_CACHE_STATUS : case TC_IOCTL_GET_PORTABLE_MODE_STATUS : case TC_IOCTL_SET_PORTABLE_MODE_STATUS : case TC_IOCTL_OPEN_TEST : case TC_IOCTL_GET_RESOLVED_SYMLINK : case TC_IOCTL_GET_DRIVE_PARTITION_INFO : case TC_IOCTL_GET_BOOT_DRIVE_VOLUME_PROPERTIES : case TC_IOCTL_GET_BOOT_ENCRYPTION_STATUS : case TC_IOCTL_IS_HIDDEN_SYSTEM_RUNNING : break ; default : Dump ( "IOCTL<S2SV_blank>error<S2SV_blank>0x%08x\\n" , Irp -> IoStatus . Status ) ; } } # endif return TCCompleteIrp ( Irp , Irp -> IoStatus . Status , Irp -> IoStatus . Information ) ; }
CWE-190 void nw_buf_free ( nw_buf_pool * pool , nw_buf * buf ) { if ( pool -> free < pool -> free_total ) { pool -> free_arr [ pool -> free ++ ] = buf ; <S2SV_StartBug> } else { <S2SV_EndBug> uint32_t new_free_total = pool -> free_total * 2 ; void * new_arr = realloc ( pool -> free_arr , new_free_total * sizeof ( nw_buf * ) ) ; if ( new_arr ) { pool -> free_total = new_free_total ; pool -> free_arr = new_arr ; pool -> free_arr [ pool -> free ++ ] = buf ; } else { free ( buf ) ; } <S2SV_StartBug> } <S2SV_EndBug> }
CWE-190 void nw_cache_free ( nw_cache * cache , void * obj ) { if ( cache -> free < cache -> free_total ) { cache -> free_arr [ cache -> free ++ ] = obj ; <S2SV_StartBug> } else { <S2SV_EndBug> uint32_t new_free_total = cache -> free_total * 2 ; void * new_arr = realloc ( cache -> free_arr , new_free_total * sizeof ( void * ) ) ; if ( new_arr ) { cache -> free_total = new_free_total ; cache -> free_arr = new_arr ; cache -> free_arr [ cache -> free ++ ] = obj ; } else { free ( obj ) ; } <S2SV_StartBug> } <S2SV_EndBug> }
CWE-190 int rpc_pack ( rpc_pkg * pkg , void * * data , uint32_t * size ) { static void * send_buf ; static size_t send_buf_size ; <S2SV_StartBug> uint32_t pkg_size = RPC_PKG_HEAD_SIZE + pkg -> ext_size + pkg -> body_size ; <S2SV_EndBug> if ( send_buf_size < pkg_size ) { if ( send_buf ) free ( send_buf ) ; send_buf_size = pkg_size * 2 ; send_buf = malloc ( send_buf_size ) ; <S2SV_StartBug> assert ( send_buf != NULL ) ; <S2SV_EndBug> } memcpy ( send_buf , pkg , RPC_PKG_HEAD_SIZE ) ; if ( pkg -> ext_size ) memcpy ( send_buf + RPC_PKG_HEAD_SIZE , pkg -> ext , pkg -> ext_size ) ; if ( pkg -> body_size ) memcpy ( send_buf + RPC_PKG_HEAD_SIZE + pkg -> ext_size , pkg -> body , pkg -> body_size ) ; pkg = send_buf ; pkg -> magic = htole32 ( RPC_PKG_MAGIC ) ; pkg -> command = htole32 ( pkg -> command ) ; pkg -> pkg_type = htole16 ( pkg -> pkg_type ) ; pkg -> result = htole32 ( pkg -> result ) ; pkg -> sequence = htole32 ( pkg -> sequence ) ; pkg -> req_id = htole64 ( pkg -> req_id ) ; pkg -> body_size = htole32 ( pkg -> body_size ) ; pkg -> ext_size = htole16 ( pkg -> ext_size ) ; pkg -> crc32 = 0 ; pkg -> crc32 = htole32 ( generate_crc32c ( send_buf , pkg_size ) ) ; * data = send_buf ; * size = pkg_size ; return 0 ; }
CWE-190 static int on_http_message_complete ( http_parser * parser ) { struct clt_info * info = parser -> data ; ws_svr * svr = ws_svr_from_ses ( info -> ses ) ; info -> request -> version_major = parser -> http_major ; info -> request -> version_minor = parser -> http_minor ; info -> request -> method = parser -> method ; dict_entry * entry ; dict_iterator * iter = dict_get_iterator ( info -> request -> headers ) ; while ( ( entry = dict_next ( iter ) ) != NULL ) { log_trace ( "Header:<S2SV_blank>%s:<S2SV_blank>%s" , ( char * ) entry -> key , ( char * ) entry -> val ) ; } dict_release_iterator ( iter ) ; if ( info -> request -> method != HTTP_GET ) goto error ; if ( http_request_get_header ( info -> request , "Host" ) == NULL ) goto error ; double version = info -> request -> version_major + info -> request -> version_minor * 0.1 ; if ( version < 1.1 ) goto error ; const char * upgrade = http_request_get_header ( info -> request , "Upgrade" ) ; if ( upgrade == NULL || strcasecmp ( upgrade , "websocket" ) != 0 ) goto error ; const char * connection = http_request_get_header ( info -> request , "Connection" ) ; <S2SV_StartBug> if ( connection == NULL ) <S2SV_EndBug> goto error ; else { bool found_upgrade = false ; int count ; sds * tokens = sdssplitlen ( connection , strlen ( connection ) , "," , 1 , & count ) ; if ( tokens == NULL ) goto error ; for ( int i = 0 ; i < count ; i ++ ) { sds token = tokens [ i ] ; sdstrim ( token , "<S2SV_blank>" ) ; if ( strcasecmp ( token , "Upgrade" ) == 0 ) { found_upgrade = true ; break ; } } sdsfreesplitres ( tokens , count ) ; if ( ! found_upgrade ) goto error ; } const char * ws_version = http_request_get_header ( info -> request , "Sec-WebSocket-Version" ) ; if ( ws_version == NULL || strcmp ( ws_version , "13" ) != 0 ) goto error ; const char * ws_key = http_request_get_header ( info -> request , "Sec-WebSocket-Key" ) ; if ( ws_key == NULL ) goto error ; const char * protocol_list = http_request_get_header ( info -> request , "Sec-WebSocket-Protocol" ) ; if ( protocol_list && ! is_good_protocol ( protocol_list , svr -> protocol ) ) goto error ; if ( strlen ( svr -> origin ) > 0 ) { const char * origin = http_request_get_header ( info -> request , "Origin" ) ; if ( origin == NULL || ! is_good_origin ( origin , svr -> origin ) ) goto error ; } if ( svr -> type . on_privdata_alloc ) { info -> privdata = svr -> type . on_privdata_alloc ( svr ) ; if ( info -> privdata == NULL ) goto error ; } info -> upgrade = true ; info -> remote = sdsnew ( http_get_remote_ip ( info -> ses , info -> request ) ) ; info -> url = sdsnew ( info -> request -> url ) ; if ( svr -> type . on_upgrade ) { svr -> type . on_upgrade ( info -> ses , info -> remote ) ; } if ( protocol_list ) { send_hand_shake_reply ( info -> ses , svr -> protocol , ws_key ) ; } else { send_hand_shake_reply ( info -> ses , NULL , ws_key ) ; } return 0 ; error : ws_svr_close_clt ( ws_svr_from_ses ( info -> ses ) , info -> ses ) ; return - 1 ; }
CWE-347 err_t verify_signed_hash ( const struct RSA_public_key * k , u_char * s , unsigned int s_max_octets , u_char * * psig , size_t hash_len , const u_char * sig_val , size_t sig_len ) { unsigned int padlen ; { chunk_t temp_s ; MP_INT c ; n_to_mpz ( & c , sig_val , sig_len ) ; oswcrypto . mod_exp ( & c , & c , & k -> e , & k -> n ) ; temp_s = mpz_to_n ( & c , sig_len ) ; if ( s_max_octets < sig_len ) { return "2" "exponentiation<S2SV_blank>failed;<S2SV_blank>too<S2SV_blank>many<S2SV_blank>octets" ; } memcpy ( s , temp_s . ptr , sig_len ) ; pfree ( temp_s . ptr ) ; mpz_clear ( & c ) ; } padlen = sig_len - 3 - hash_len ; DBG ( DBG_CRYPT , DBG_dump ( "verify_sh<S2SV_blank>decrypted<S2SV_blank>SIG1:" , s , sig_len ) ) ; DBG ( DBG_CRYPT , DBG_log ( "pad_len<S2SV_blank>calculated:<S2SV_blank>%d<S2SV_blank>hash_len:<S2SV_blank>%d" , padlen , ( int ) hash_len ) ) ; if ( s [ 0 ] != 0x00 || s [ 1 ] != 0x01 || s [ padlen + 2 ] != 0x00 ) { return "3" "SIG<S2SV_blank>padding<S2SV_blank>does<S2SV_blank>not<S2SV_blank>check<S2SV_blank>out" ; } <S2SV_StartBug> s += padlen + 3 ; <S2SV_EndBug> <S2SV_StartBug> ( * psig ) = s ; <S2SV_EndBug> return NULL ; }
CWE-400 bool ExprResolveBoolean ( struct xkb_context * ctx , const ExprDef * expr , bool * set_rtrn ) { bool ok = false ; const char * ident ; switch ( expr -> expr . op ) { case EXPR_VALUE : if ( expr -> expr . value_type != EXPR_TYPE_BOOLEAN ) { log_err ( ctx , "Found<S2SV_blank>constant<S2SV_blank>of<S2SV_blank>type<S2SV_blank>%s<S2SV_blank>where<S2SV_blank>boolean<S2SV_blank>was<S2SV_blank>expected\\n" , expr_value_type_to_string ( expr -> expr . value_type ) ) ; return false ; } * set_rtrn = expr -> boolean . set ; return true ; case EXPR_IDENT : ident = xkb_atom_text ( ctx , expr -> ident . ident ) ; if ( ident ) { if ( istreq ( ident , "true" ) || istreq ( ident , "yes" ) || istreq ( ident , "on" ) ) { * set_rtrn = true ; return true ; } else if ( istreq ( ident , "false" ) || istreq ( ident , "no" ) || istreq ( ident , "off" ) ) { * set_rtrn = false ; return true ; } } log_err ( ctx , "Identifier<S2SV_blank>\\"%s\\"<S2SV_blank>of<S2SV_blank>type<S2SV_blank>boolean<S2SV_blank>is<S2SV_blank>unknown\\n" , ident ) ; return false ; case EXPR_FIELD_REF : log_err ( ctx , "Default<S2SV_blank>\\"%s.%s\\"<S2SV_blank>of<S2SV_blank>type<S2SV_blank>boolean<S2SV_blank>is<S2SV_blank>unknown\\n" , xkb_atom_text ( ctx , expr -> field_ref . element ) , xkb_atom_text ( ctx , expr -> field_ref . field ) ) ; return false ; case EXPR_INVERT : case EXPR_NOT : <S2SV_StartBug> ok = ExprResolveBoolean ( ctx , expr , set_rtrn ) ; <S2SV_EndBug> if ( ok ) * set_rtrn = ! * set_rtrn ; return ok ; case EXPR_ADD : case EXPR_SUBTRACT : case EXPR_MULTIPLY : case EXPR_DIVIDE : case EXPR_ASSIGN : case EXPR_NEGATE : case EXPR_UNARY_PLUS : log_err ( ctx , "%s<S2SV_blank>of<S2SV_blank>boolean<S2SV_blank>values<S2SV_blank>not<S2SV_blank>permitted\\n" , expr_op_type_to_string ( expr -> expr . op ) ) ; break ; default : log_wsgo ( ctx , "Unknown<S2SV_blank>operator<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>ResolveBoolean\\n" , expr -> expr . op ) ; break ; } return false ; }
CWE-476 bool ExprResolveLhs ( struct xkb_context * ctx , const ExprDef * expr , const char * * elem_rtrn , const char * * field_rtrn , ExprDef * * index_rtrn ) { switch ( expr -> expr . op ) { case EXPR_IDENT : * elem_rtrn = NULL ; * field_rtrn = xkb_atom_text ( ctx , expr -> ident . ident ) ; * index_rtrn = NULL ; <S2SV_StartBug> return true ; <S2SV_EndBug> case EXPR_FIELD_REF : * elem_rtrn = xkb_atom_text ( ctx , expr -> field_ref . element ) ; * field_rtrn = xkb_atom_text ( ctx , expr -> field_ref . field ) ; * index_rtrn = NULL ; return true ; case EXPR_ARRAY_REF : * elem_rtrn = xkb_atom_text ( ctx , expr -> array_ref . element ) ; * field_rtrn = xkb_atom_text ( ctx , expr -> array_ref . field ) ; * index_rtrn = expr -> array_ref . entry ; return true ; default : break ; } log_wsgo ( ctx , "Unexpected<S2SV_blank>operator<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>ResolveLhs\\n" , expr -> expr . op ) ; return false ; }
CWE-476 static bool LookupModMask ( struct xkb_context * ctx , const void * priv , xkb_atom_t field , enum expr_value_type type , xkb_mod_mask_t * val_rtrn ) { const char * str ; xkb_mod_index_t ndx ; const LookupModMaskPriv * arg = priv ; const struct xkb_mod_set * mods = arg -> mods ; enum mod_type mod_type = arg -> mod_type ; if ( type != EXPR_TYPE_INT ) return false ; str = xkb_atom_text ( ctx , field ) ; <S2SV_StartBug> if ( istreq ( str , "all" ) ) { <S2SV_EndBug> * val_rtrn = MOD_REAL_MASK_ALL ; return true ; } if ( istreq ( str , "none" ) ) { * val_rtrn = 0 ; return true ; } ndx = XkbModNameToIndex ( mods , field , mod_type ) ; if ( ndx == XKB_MOD_INVALID ) return false ; * val_rtrn = ( 1u << ndx ) ; return true ; }
CWE-835 static enum rules_token lex ( struct scanner * s , union lvalue * val ) { skip_more_whitespace_and_comments : while ( is_space ( peek ( s ) ) ) if ( next ( s ) == '\\n' ) return TOK_END_OF_LINE ; if ( chr ( s , '#' ) ) { skip_to_eol ( s ) ; goto skip_more_whitespace_and_comments ; } if ( eof ( s ) ) return TOK_END_OF_FILE ; s -> token_line = s -> line ; s -> token_column = s -> column ; s -> buf_pos = 0 ; if ( chr ( s , '<' ) ) { <S2SV_StartBug> while ( peek ( s ) != '>' && ! eol ( s ) ) <S2SV_EndBug> buf_append ( s , next ( s ) ) ; if ( ! chr ( s , '>' ) ) { scanner_err ( s , "unterminated<S2SV_blank>keysym<S2SV_blank>literal" ) ; return TOK_ERROR ; } if ( ! buf_append ( s , '\\0' ) ) { scanner_err ( s , "keysym<S2SV_blank>literal<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long" ) ; return TOK_ERROR ; } val -> string . str = s -> buf ; val -> string . len = s -> buf_pos ; return TOK_LHS_KEYSYM ; } if ( chr ( s , ':' ) ) return TOK_COLON ; if ( chr ( s , '!' ) ) return TOK_BANG ; if ( chr ( s , '~' ) ) return TOK_TILDE ; if ( chr ( s , \'\\"\' ) ) { while ( ! eof ( s ) && ! eol ( s ) && peek ( s ) != \'\\"\' ) { if ( chr ( s , '\\\\' ) ) { uint8_t o ; if ( chr ( s , '\\\\' ) ) { buf_append ( s , '\\\\' ) ; } else if ( chr ( s , \'"\' ) ) { buf_append ( s , \'"\' ) ; } else if ( chr ( s , 'x' ) || chr ( s , 'X' ) ) { if ( hex ( s , & o ) ) buf_append ( s , ( char ) o ) ; else scanner_warn ( s , "illegal<S2SV_blank>hexadecimal<S2SV_blank>escape<S2SV_blank>sequence<S2SV_blank>in<S2SV_blank>string<S2SV_blank>literal" ) ; } else if ( oct ( s , & o ) ) { buf_append ( s , ( char ) o ) ; } else { scanner_warn ( s , "unknown<S2SV_blank>escape<S2SV_blank>sequence<S2SV_blank>(%c)<S2SV_blank>in<S2SV_blank>string<S2SV_blank>literal" , peek ( s ) ) ; } } else { buf_append ( s , next ( s ) ) ; } } if ( ! chr ( s , \'\\"\' ) ) { scanner_err ( s , "unterminated<S2SV_blank>string<S2SV_blank>literal" ) ; return TOK_ERROR ; } if ( ! buf_append ( s , '\\0' ) ) { scanner_err ( s , "string<S2SV_blank>literal<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long" ) ; return TOK_ERROR ; } if ( ! is_valid_utf8 ( s -> buf , s -> buf_pos - 1 ) ) { scanner_err ( s , "string<S2SV_blank>literal<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>UTF-8<S2SV_blank>string" ) ; return TOK_ERROR ; } val -> string . str = s -> buf ; val -> string . len = s -> buf_pos ; return TOK_STRING ; } if ( is_alpha ( peek ( s ) ) || peek ( s ) == '_' ) { s -> buf_pos = 0 ; while ( is_alnum ( peek ( s ) ) || peek ( s ) == '_' ) buf_append ( s , next ( s ) ) ; if ( ! buf_append ( s , '\\0' ) ) { scanner_err ( s , "identifier<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long" ) ; return TOK_ERROR ; } if ( streq ( s -> buf , "include" ) ) return TOK_INCLUDE ; val -> string . str = s -> buf ; val -> string . len = s -> buf_pos ; return TOK_IDENT ; } skip_to_eol ( s ) ; scanner_err ( s , "unrecognized<S2SV_blank>token" ) ; return TOK_ERROR ; }
CWE-476 bool CompileKeymap ( XkbFile * file , struct xkb_keymap * keymap , enum merge_mode merge ) { bool ok ; XkbFile * files [ LAST_KEYMAP_FILE_TYPE + 1 ] = { NULL } ; enum xkb_file_type type ; struct xkb_context * ctx = keymap -> ctx ; for ( file = ( XkbFile * ) file -> defs ; file ; file = ( XkbFile * ) file -> common . next ) { if ( file -> file_type < FIRST_KEYMAP_FILE_TYPE || file -> file_type > LAST_KEYMAP_FILE_TYPE ) { <S2SV_StartBug> log_err ( ctx , "Cannot<S2SV_blank>define<S2SV_blank>%s<S2SV_blank>in<S2SV_blank>a<S2SV_blank>keymap<S2SV_blank>file\\n" , <S2SV_EndBug> <S2SV_StartBug> xkb_file_type_to_string ( file -> file_type ) ) ; <S2SV_EndBug> continue ; } if ( files [ file -> file_type ] ) { log_err ( ctx , "More<S2SV_blank>than<S2SV_blank>one<S2SV_blank>%s<S2SV_blank>section<S2SV_blank>in<S2SV_blank>keymap<S2SV_blank>file;<S2SV_blank>" "All<S2SV_blank>sections<S2SV_blank>after<S2SV_blank>the<S2SV_blank>first<S2SV_blank>ignored\\n" , xkb_file_type_to_string ( file -> file_type ) ) ; continue ; } files [ file -> file_type ] = file ; } ok = true ; for ( type = FIRST_KEYMAP_FILE_TYPE ; type <= LAST_KEYMAP_FILE_TYPE ; type ++ ) { if ( files [ type ] == NULL ) { log_err ( ctx , "Required<S2SV_blank>section<S2SV_blank>%s<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>keymap\\n" , xkb_file_type_to_string ( type ) ) ; ok = false ; } } if ( ! ok ) return false ; for ( type = FIRST_KEYMAP_FILE_TYPE ; type <= LAST_KEYMAP_FILE_TYPE ; type ++ ) { log_dbg ( ctx , "Compiling<S2SV_blank>%s<S2SV_blank>\\"%s\\"\\n" , xkb_file_type_to_string ( type ) , files [ type ] -> name ) ; ok = compile_file_fns [ type ] ( files [ type ] , keymap , merge ) ; if ( ! ok ) { log_err ( ctx , "Failed<S2SV_blank>to<S2SV_blank>compile<S2SV_blank>%s\\n" , xkb_file_type_to_string ( type ) ) ; return false ; } } return UpdateDerivedKeymapFields ( keymap ) ; }
CWE-476 static bool ResolveStateAndPredicate ( ExprDef * expr , enum xkb_match_operation * pred_rtrn , xkb_mod_mask_t * mods_rtrn , CompatInfo * info ) { if ( expr == NULL ) { * pred_rtrn = MATCH_ANY_OR_NONE ; * mods_rtrn = MOD_REAL_MASK_ALL ; return true ; } * pred_rtrn = MATCH_EXACTLY ; if ( expr -> expr . op == EXPR_ACTION_DECL ) { const char * pred_txt = xkb_atom_text ( info -> ctx , expr -> action . name ) ; <S2SV_StartBug> if ( ! LookupString ( symInterpretMatchMaskNames , pred_txt , pred_rtrn ) ) { <S2SV_EndBug> log_err ( info -> ctx , "Illegal<S2SV_blank>modifier<S2SV_blank>predicate<S2SV_blank>\\"%s\\";<S2SV_blank>Ignored\\n" , pred_txt ) ; return false ; } expr = expr -> action . args ; } else if ( expr -> expr . op == EXPR_IDENT ) { const char * pred_txt = xkb_atom_text ( info -> ctx , expr -> ident . ident ) ; if ( pred_txt && istreq ( pred_txt , "any" ) ) { * pred_rtrn = MATCH_ANY ; * mods_rtrn = MOD_REAL_MASK_ALL ; return true ; } } return ExprResolveModMask ( info -> ctx , expr , MOD_REAL , & info -> mods , mods_rtrn ) ; }
CWE-476 static bool CopyKeyAliasesToKeymap ( struct xkb_keymap * keymap , KeyNamesInfo * info ) { AliasInfo * alias ; unsigned i , num_key_aliases ; struct xkb_key_alias * key_aliases ; num_key_aliases = 0 ; darray_foreach ( alias , info -> aliases ) { if ( ! XkbKeyByName ( keymap , alias -> real , false ) ) { log_vrb ( info -> ctx , 5 , "Attempt<S2SV_blank>to<S2SV_blank>alias<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>non-existent<S2SV_blank>key<S2SV_blank>%s;<S2SV_blank>Ignored\\n" , KeyNameText ( info -> ctx , alias -> alias ) , KeyNameText ( info -> ctx , alias -> real ) ) ; alias -> real = XKB_ATOM_NONE ; continue ; } if ( XkbKeyByName ( keymap , alias -> alias , false ) ) { log_vrb ( info -> ctx , 5 , "Attempt<S2SV_blank>to<S2SV_blank>create<S2SV_blank>alias<S2SV_blank>with<S2SV_blank>the<S2SV_blank>name<S2SV_blank>of<S2SV_blank>a<S2SV_blank>real<S2SV_blank>key;<S2SV_blank>" "Alias<S2SV_blank>\\"%s<S2SV_blank>=<S2SV_blank>%s\\"<S2SV_blank>ignored\\n" , KeyNameText ( info -> ctx , alias -> alias ) , KeyNameText ( info -> ctx , alias -> real ) ) ; alias -> real = XKB_ATOM_NONE ; continue ; } num_key_aliases ++ ; } key_aliases = NULL ; if ( num_key_aliases > 0 ) { key_aliases = calloc ( num_key_aliases , sizeof ( * key_aliases ) ) ; if ( ! key_aliases ) return false ; <S2SV_StartBug> } <S2SV_EndBug> i = 0 ; darray_foreach ( alias , info -> aliases ) { if ( alias -> real != XKB_ATOM_NONE ) { key_aliases [ i ] . alias = alias -> alias ; key_aliases [ i ] . real = alias -> real ; i ++ ; } } <S2SV_StartBug> keymap -> num_key_aliases = num_key_aliases ; <S2SV_EndBug> keymap -> key_aliases = key_aliases ; return true ; }
CWE-476 bool ExprResolveLhs ( struct xkb_context * ctx , const ExprDef * expr , const char * * elem_rtrn , const char * * field_rtrn , ExprDef * * index_rtrn ) { switch ( expr -> expr . op ) { case EXPR_IDENT : * elem_rtrn = NULL ; * field_rtrn = xkb_atom_text ( ctx , expr -> ident . ident ) ; * index_rtrn = NULL ; return ( * field_rtrn != NULL ) ; case EXPR_FIELD_REF : * elem_rtrn = xkb_atom_text ( ctx , expr -> field_ref . element ) ; * field_rtrn = xkb_atom_text ( ctx , expr -> field_ref . field ) ; * index_rtrn = NULL ; <S2SV_StartBug> return true ; <S2SV_EndBug> case EXPR_ARRAY_REF : * elem_rtrn = xkb_atom_text ( ctx , expr -> array_ref . element ) ; * field_rtrn = xkb_atom_text ( ctx , expr -> array_ref . field ) ; * index_rtrn = expr -> array_ref . entry ; <S2SV_StartBug> return true ; <S2SV_EndBug> default : break ; } log_wsgo ( ctx , "Unexpected<S2SV_blank>operator<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>ResolveLhs\\n" , expr -> expr . op ) ; return false ; }
CWE-416 ExprDef * ExprAppendMultiKeysymList ( ExprDef * expr , ExprDef * append ) { unsigned nSyms = darray_size ( expr -> keysym_list . syms ) ; unsigned numEntries = darray_size ( append -> keysym_list . syms ) ; darray_append ( expr -> keysym_list . symsMapIndex , nSyms ) ; darray_append ( expr -> keysym_list . symsNumEntries , numEntries ) ; darray_concat ( expr -> keysym_list . syms , append -> keysym_list . syms ) ; <S2SV_StartBug> FreeStmt ( ( ParseCommon * ) & append ) ; <S2SV_EndBug> return expr ; }
CWE-787 void * adminchild ( struct clientparam * param ) { int i , res ; char * buf ; char username [ 256 ] ; char * sb ; char * req = NULL ; struct printparam pp ; <S2SV_StartBug> int contentlen = 0 ; <S2SV_EndBug> int isform = 0 ; pp . inbuf = 0 ; pp . cp = param ; buf = myalloc ( LINESIZE ) ; if ( ! buf ) { RETURN ( 555 ) ; } i = sockgetlinebuf ( param , CLIENT , ( unsigned char * ) buf , LINESIZE - 1 , '\\n' , conf . timeouts [ STRING_S ] ) ; if ( i < 5 || ( ( buf [ 0 ] != 'G' || buf [ 1 ] != 'E' || buf [ 2 ] != 'T' || buf [ 3 ] != '<S2SV_blank>' || buf [ 4 ] != '/' ) && ( buf [ 0 ] != 'P' || buf [ 1 ] != 'O' || buf [ 2 ] != 'S' || buf [ 3 ] != 'T' || buf [ 4 ] != '<S2SV_blank>' || buf [ 5 ] != '/' ) ) ) { RETURN ( 701 ) ; } buf [ i ] = 0 ; sb = strchr ( buf + 5 , '<S2SV_blank>' ) ; if ( ! sb ) { RETURN ( 702 ) ; } * sb = 0 ; req = mystrdup ( buf + ( ( * buf == 'P' ) ? 6 : 5 ) ) ; while ( ( i = sockgetlinebuf ( param , CLIENT , ( unsigned char * ) buf , LINESIZE - 1 , '\\n' , conf . timeouts [ STRING_S ] ) ) > 2 ) { buf [ i ] = 0 ; if ( i > 19 && ( ! strncasecmp ( buf , "authorization" , 13 ) ) ) { sb = strchr ( buf , ':' ) ; if ( ! sb ) continue ; ++ sb ; while ( isspace ( * sb ) ) sb ++ ; if ( ! * sb || strncasecmp ( sb , "basic" , 5 ) ) { continue ; } sb += 5 ; while ( isspace ( * sb ) ) sb ++ ; i = de64 ( ( unsigned char * ) sb , ( unsigned char * ) username , 255 ) ; if ( i <= 0 ) continue ; username [ i ] = 0 ; sb = strchr ( ( char * ) username , ':' ) ; if ( sb ) { * sb = 0 ; if ( param -> password ) myfree ( param -> password ) ; param -> password = ( unsigned char * ) mystrdup ( sb + 1 ) ; } if ( param -> username ) myfree ( param -> username ) ; param -> username = ( unsigned char * ) mystrdup ( username ) ; continue ; } else if ( i > 15 && ( ! strncasecmp ( buf , "content-length:" , 15 ) ) ) { sb = buf + 15 ; while ( isspace ( * sb ) ) sb ++ ; <S2SV_StartBug> contentlen = atoi ( sb ) ; <S2SV_EndBug> } else if ( i > 13 && ( ! strncasecmp ( buf , "content-type:" , 13 ) ) ) { sb = buf + 13 ; while ( isspace ( * sb ) ) sb ++ ; if ( ! strncasecmp ( sb , "x-www-form-urlencoded" , 21 ) ) isform = 1 ; } } param -> operation = ADMIN ; if ( isform && contentlen ) { printstr ( & pp , "HTTP/1.0<S2SV_blank>100<S2SV_blank>Continue\\r\\n\\r\\n" ) ; stdpr ( & pp , NULL , 0 ) ; } res = ( * param -> srv -> authfunc ) ( param ) ; if ( res && res != 10 ) { printstr ( & pp , authreq ) ; RETURN ( res ) ; } if ( param -> srv -> singlepacket || param -> redirected ) { if ( * req == 'C' ) req [ 1 ] = 0 ; else * req = 0 ; } sprintf ( buf , ok , conf . stringtable ? ( char * ) conf . stringtable [ 2 ] : "3proxy" , conf . stringtable ? ( char * ) conf . stringtable [ 2 ] : "3[APA3A]<S2SV_blank>tiny<S2SV_blank>proxy" , conf . stringtable ? ( char * ) conf . stringtable [ 3 ] : "" ) ; if ( * req != 'S' ) printstr ( & pp , buf ) ; switch ( * req ) { case 'C' : printstr ( & pp , counters ) ; { struct trafcount * cp ; int num = 0 ; for ( cp = conf . trafcounter ; cp ; cp = cp -> next , num ++ ) { int inbuf = 0 ; if ( cp -> ace && ( param -> srv -> singlepacket || param -> redirected ) ) { if ( ! ACLmatches ( cp -> ace , param ) ) continue ; } if ( req [ 1 ] == 'S' && atoi ( req + 2 ) == num ) cp -> disabled = 0 ; if ( req [ 1 ] == 'D' && atoi ( req + 2 ) == num ) cp -> disabled = 1 ; inbuf += sprintf ( buf , "<tr>" "<td>%s</td><td><A<S2SV_blank>HREF=\\\'/C%c%d\\\'>%s</A></td><td>" , ( cp -> comment ) ? cp -> comment : "&nbsp;" , ( cp -> disabled ) ? 'S' : 'D' , num , ( cp -> disabled ) ? "NO" : "YES" ) ; if ( ! cp -> ace || ! cp -> ace -> users ) { inbuf += sprintf ( buf + inbuf , "<center>ANY</center>" ) ; } else { inbuf += printuserlist ( buf + inbuf , LINESIZE - 800 , cp -> ace -> users , ",<br<S2SV_blank>/>\\r\\n" ) ; } inbuf += sprintf ( buf + inbuf , "</td><td>" ) ; if ( ! cp -> ace || ! cp -> ace -> src ) { inbuf += sprintf ( buf + inbuf , "<center>ANY</center>" ) ; } else { inbuf += printiplist ( buf + inbuf , LINESIZE - 512 , cp -> ace -> src , ",<br<S2SV_blank>/>\\r\\n" ) ; } inbuf += sprintf ( buf + inbuf , "</td><td>" ) ; if ( ! cp -> ace || ! cp -> ace -> dst ) { inbuf += sprintf ( buf + inbuf , "<center>ANY</center>" ) ; } else { inbuf += printiplist ( buf + inbuf , LINESIZE - 512 , cp -> ace -> dst , ",<br<S2SV_blank>/>\\r\\n" ) ; } inbuf += sprintf ( buf + inbuf , "</td><td>" ) ; if ( ! cp -> ace || ! cp -> ace -> ports ) { inbuf += sprintf ( buf + inbuf , "<center>ANY</center>" ) ; } else { inbuf += printportlist ( buf + inbuf , LINESIZE - 128 , cp -> ace -> ports , ",<br<S2SV_blank>/>\\r\\n" ) ; } if ( cp -> type == NONE ) { inbuf += sprintf ( buf + inbuf , "</td><td<S2SV_blank>colspan=\\\'6\\\'<S2SV_blank>align=\\\'center\\\'>exclude<S2SV_blank>from<S2SV_blank>limitation</td></tr>\\r\\n" ) ; } else { inbuf += sprintf ( buf + inbuf , "</td><td>%" PRINTF_INT64_MODIFIER "u</td>" "<td>MB%s</td>" "<td>%" PRINTF_INT64_MODIFIER "u</td>" "<td>%s</td>" , cp -> traflim64 / ( 1024 * 1024 ) , rotations [ cp -> type ] , cp -> traf64 , cp -> cleared ? ctime ( & cp -> cleared ) : "never" ) ; inbuf += sprintf ( buf + inbuf , "<td>%s</td>" "<td>%i</td>" "</tr>\\r\\n" , cp -> updated ? ctime ( & cp -> updated ) : "never" , cp -> number ) ; } printstr ( & pp , buf ) ; } } printstr ( & pp , counterstail ) ; break ; case 'R' : conf . needreload = 1 ; printstr ( & pp , "<h3>Reload<S2SV_blank>scheduled</h3>" ) ; break ; case 'S' : { if ( req [ 1 ] == 'X' ) { printstr ( & pp , style ) ; break ; } printstr ( & pp , xml ) ; printval ( conf . services , TYPE_SERVER , 0 , & pp ) ; printstr ( & pp , postxml ) ; } break ; case 'F' : { FILE * fp ; char buf [ 256 ] ; fp = confopen ( ) ; if ( ! fp ) { printstr ( & pp , "<h3><font<S2SV_blank>color=\\"red\\">Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>config<S2SV_blank>file</font></h3>" ) ; break ; } printstr ( & pp , "<h3>Please<S2SV_blank>be<S2SV_blank>careful<S2SV_blank>editing<S2SV_blank>config<S2SV_blank>file<S2SV_blank>remotely</h3>" ) ; <S2SV_StartBug> printstr ( & pp , "<form<S2SV_blank>method=\\"POST\\"<S2SV_blank>action=\\"/U\\"><textarea<S2SV_blank>cols=\\"80\\"<S2SV_blank>rows=\\"30\\"<S2SV_blank>name=\\"conffile\\">" ) ; <S2SV_EndBug> while ( fgets ( buf , 256 , fp ) ) { printstr ( & pp , buf ) ; } if ( ! writable ) fclose ( fp ) ; printstr ( & pp , "</textarea><br><input<S2SV_blank>type=\\"Submit\\"></form>" ) ; break ; } case 'U' : { <S2SV_StartBug> int l = 0 ; <S2SV_EndBug> int error = 0 ; <S2SV_StartBug> if ( ! writable || fseek ( writable , 0 , 0 ) ) { <S2SV_EndBug> error = 1 ; } <S2SV_StartBug> while ( ( i = sockgetlinebuf ( param , CLIENT , ( unsigned char * ) buf , LINESIZE - 1 , '+' , conf . timeouts [ STRING_S ] ) ) > 0 ) { <S2SV_EndBug> if ( i > ( contentlen - l ) ) i = ( contentlen - l ) ; <S2SV_StartBug> buf [ i ] = 0 ; <S2SV_EndBug> if ( ! l ) { if ( strncasecmp ( buf , "conffile=" , 9 ) ) error = 1 ; } <S2SV_StartBug> if ( ! error ) { <S2SV_EndBug> decodeurl ( ( unsigned char * ) buf , 1 ) ; fprintf ( writable , "%s" , l ? buf : buf + 9 ) ; } <S2SV_StartBug> l += i ; <S2SV_EndBug> if ( l >= contentlen ) break ; } if ( writable && ! error ) { fflush ( writable ) ; # ifndef _WINCE ftruncate ( fileno ( writable ) , ftell ( writable ) ) ; # endif } printstr ( & pp , error ? "<h3><font<S2SV_blank>color=\\"red\\">Config<S2SV_blank>file<S2SV_blank>is<S2SV_blank>not<S2SV_blank>writable</font></h3>Make<S2SV_blank>sure<S2SV_blank>you<S2SV_blank>have<S2SV_blank>\\"writable\\"<S2SV_blank>command<S2SV_blank>in<S2SV_blank>configuration<S2SV_blank>file" : "<h3>Configuration<S2SV_blank>updated</h3>" ) ; } break ; default : printstr ( & pp , ( char * ) conf . stringtable [ WEBBANNERS ] ) ; break ; } if ( * req != 'S' ) printstr ( & pp , tail ) ; CLEANRET : printstr ( & pp , NULL ) ; if ( buf ) myfree ( buf ) ; ( * param -> srv -> logfunc ) ( param , ( unsigned char * ) req ) ; if ( req ) myfree ( req ) ; freeparam ( param ) ; return ( NULL ) ; }
CWE-79 static int oidc_handle_session_management_iframe_rp ( request_rec * r , oidc_cfg * c , oidc_session_t * session , const char * client_id , const char * check_session_iframe ) { oidc_debug ( r , "enter" ) ; const char * java_script = "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><script<S2SV_blank>type=\\"text/javascript\\">\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>var<S2SV_blank>targetOrigin<S2SV_blank><S2SV_blank>=<S2SV_blank>\'%s\';\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>var<S2SV_blank>message<S2SV_blank>=<S2SV_blank>\'%s\'<S2SV_blank>+<S2SV_blank>\'<S2SV_blank>\'<S2SV_blank>+<S2SV_blank>\'%s\';\\n" "\t<S2SV_blank><S2SV_blank><S2SV_blank>var<S2SV_blank>timerID;\\n" "\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>function<S2SV_blank>checkSession()<S2SV_blank>{\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>console.debug(\'checkSession:<S2SV_blank>posting<S2SV_blank>\'<S2SV_blank>+<S2SV_blank>message<S2SV_blank>+<S2SV_blank>\'<S2SV_blank>to<S2SV_blank>\'<S2SV_blank>+<S2SV_blank>targetOrigin);\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>var<S2SV_blank>win<S2SV_blank>=<S2SV_blank>window.parent.document.getElementById(\'%s\').contentWindow;\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>win.postMessage(<S2SV_blank>message,<S2SV_blank>targetOrigin);\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}\\n" "\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>function<S2SV_blank>setTimer()<S2SV_blank>{\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>checkSession();\\n" <S2SV_StartBug> "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>timerID<S2SV_blank>=<S2SV_blank>setInterval(\'checkSession()\',<S2SV_blank>%s);\\n" <S2SV_EndBug> "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}\\n" "\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>function<S2SV_blank>receiveMessage(e)<S2SV_blank>{\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>console.debug(\'receiveMessage:<S2SV_blank>\'<S2SV_blank>+<S2SV_blank>e.data<S2SV_blank>+<S2SV_blank>\'<S2SV_blank>from<S2SV_blank>\'<S2SV_blank>+<S2SV_blank>e.origin);\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>if<S2SV_blank>(e.origin<S2SV_blank>!==<S2SV_blank>targetOrigin<S2SV_blank>)<S2SV_blank>{\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>console.debug(\'receiveMessage:<S2SV_blank>cross-site<S2SV_blank>scripting<S2SV_blank>attack?\');\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>return;\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>if<S2SV_blank>(e.data<S2SV_blank>!=<S2SV_blank>\'unchanged\')<S2SV_blank>{\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>clearInterval(timerID);\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>if<S2SV_blank>(e.data<S2SV_blank>==<S2SV_blank>\'changed\')<S2SV_blank>{\\n" "\t\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>window.location.href<S2SV_blank>=<S2SV_blank>\'%s?session=check\';\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}<S2SV_blank>else<S2SV_blank>{\\n" "\t\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>window.location.href<S2SV_blank>=<S2SV_blank>\'%s?session=logout\';\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}\\n" "\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>window.addEventListener(\'message\',<S2SV_blank>receiveMessage,<S2SV_blank>false);\\n" "\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank></script>\\n" ; char * origin = apr_pstrdup ( r -> pool , check_session_iframe ) ; apr_uri_t uri ; apr_uri_parse ( r -> pool , check_session_iframe , & uri ) ; char * p = strstr ( origin , uri . path ) ; * p = '\\0' ; const char * op_iframe_id = "openidc-op" ; const char * session_state = oidc_session_get_session_state ( r , session ) ; if ( session_state == NULL ) { oidc_warn ( r , "no<S2SV_blank>session_state<S2SV_blank>found<S2SV_blank>in<S2SV_blank>the<S2SV_blank>session;<S2SV_blank>the<S2SV_blank>OP<S2SV_blank>does<S2SV_blank>probably<S2SV_blank>not<S2SV_blank>support<S2SV_blank>session<S2SV_blank>management!?" ) ; return DONE ; } char * s_poll_interval = NULL ; oidc_util_get_request_parameter ( r , "poll" , & s_poll_interval ) ; <S2SV_StartBug> if ( s_poll_interval == NULL ) <S2SV_EndBug> s_poll_interval = "3000" ; const char * redirect_uri = oidc_get_redirect_uri ( r , c ) ; java_script = apr_psprintf ( r -> pool , java_script , origin , client_id , <S2SV_StartBug> session_state , op_iframe_id , s_poll_interval , redirect_uri , <S2SV_EndBug> redirect_uri ) ; return oidc_util_html_send ( r , NULL , java_script , "setTimer" , NULL , DONE ) ; }
