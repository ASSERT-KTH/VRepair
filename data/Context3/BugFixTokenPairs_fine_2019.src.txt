CWE-125 static const char * parse_string ( cJSON * item , const char * str , const char * * ep ) { const char * ptr = str + 1 , * end_ptr = str + 1 ; char * ptr2 ; char * out ; int len = 0 ; unsigned uc , uc2 ; if ( * str != \'\\"\' ) { * ep = str ; return 0 ; } <S2SV_StartBug> while ( * end_ptr != \'\\"\' && * end_ptr && ++ len ) if ( * end_ptr ++ == '\\\\' ) end_ptr ++ ; <S2SV_EndBug> out = ( char * ) cJSON_malloc ( len + 1 ) ; if ( ! out ) return 0 ; item -> valuestring = out ; item -> type = cJSON_String ; ptr = str + 1 ; ptr2 = out ; while ( ptr < end_ptr ) { if ( * ptr != '\\\\' ) * ptr2 ++ = * ptr ++ ; else { ptr ++ ; switch ( * ptr ) { case 'b' : * ptr2 ++ = '\\b' ; break ; case 'f' : * ptr2 ++ = '\\f' ; break ; case 'n' : * ptr2 ++ = '\\n' ; break ; case 'r' : * ptr2 ++ = '\\r' ; break ; case 't' : * ptr2 ++ = '\\t' ; break ; case 'u' : uc = parse_hex4 ( ptr + 1 ) ; ptr += 4 ; if ( ptr >= end_ptr ) { * ep = str ; return 0 ; } if ( ( uc >= 0xDC00 && uc <= 0xDFFF ) || uc == 0 ) { * ep = str ; return 0 ; } if ( uc >= 0xD800 && uc <= 0xDBFF ) { if ( ptr + 6 > end_ptr ) { * ep = str ; return 0 ; } if ( ptr [ 1 ] != '\\\\' || ptr [ 2 ] != 'u' ) { * ep = str ; return 0 ; } uc2 = parse_hex4 ( ptr + 3 ) ; ptr += 6 ; if ( uc2 < 0xDC00 || uc2 > 0xDFFF ) { * ep = str ; return 0 ; } uc = 0x10000 + ( ( ( uc & 0x3FF ) << 10 ) | ( uc2 & 0x3FF ) ) ; } len = 4 ; if ( uc < 0x80 ) len = 1 ; else if ( uc < 0x800 ) len = 2 ; else if ( uc < 0x10000 ) len = 3 ; ptr2 += len ; switch ( len ) { case 4 : * -- ptr2 = ( ( uc | 0x80 ) & 0xBF ) ; uc >>= 6 ; case 3 : * -- ptr2 = ( ( uc | 0x80 ) & 0xBF ) ; uc >>= 6 ; case 2 : * -- ptr2 = ( ( uc | 0x80 ) & 0xBF ) ; uc >>= 6 ; case 1 : * -- ptr2 = ( uc | firstByteMark [ len ] ) ; } ptr2 += len ; break ; default : * ptr2 ++ = * ptr ; break ; } ptr ++ ; } } * ptr2 = 0 ; if ( * ptr == \'\\"\' ) ptr ++ ; return ptr ; }
CWE-125 static int decode_studio_vop_header ( Mpeg4DecContext * ctx , GetBitContext * gb ) { MpegEncContext * s = & ctx -> m ; if ( get_bits_left ( gb ) <= 32 ) return 0 ; s -> partitioned_frame = 0 ; <S2SV_StartBug> s -> decode_mb = mpeg4_decode_studio_mb ; <S2SV_EndBug> decode_smpte_tc ( ctx , gb ) ; skip_bits ( gb , 10 ) ; skip_bits ( gb , 2 ) ; s -> pict_type = get_bits ( gb , 2 ) + AV_PICTURE_TYPE_I ; if ( get_bits1 ( gb ) ) { skip_bits1 ( gb ) ; skip_bits1 ( gb ) ; s -> progressive_frame = get_bits1 ( gb ) ^ 1 ; } if ( s -> pict_type == AV_PICTURE_TYPE_I ) { if ( get_bits1 ( gb ) ) reset_studio_dc_predictors ( s ) ; } if ( ctx -> shape != BIN_ONLY_SHAPE ) { s -> alternate_scan = get_bits1 ( gb ) ; s -> frame_pred_frame_dct = get_bits1 ( gb ) ; s -> dct_precision = get_bits ( gb , 2 ) ; s -> intra_dc_precision = get_bits ( gb , 2 ) ; s -> q_scale_type = get_bits1 ( gb ) ; } if ( s -> alternate_scan ) { ff_init_scantable ( s -> idsp . idct_permutation , & s -> inter_scantable , ff_alternate_vertical_scan ) ; ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_scantable , ff_alternate_vertical_scan ) ; ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_h_scantable , ff_alternate_vertical_scan ) ; ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_v_scantable , ff_alternate_vertical_scan ) ; } else { ff_init_scantable ( s -> idsp . idct_permutation , & s -> inter_scantable , ff_zigzag_direct ) ; ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_scantable , ff_zigzag_direct ) ; ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_h_scantable , ff_alternate_horizontal_scan ) ; ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_v_scantable , ff_alternate_vertical_scan ) ; } mpeg4_load_default_matrices ( s ) ; next_start_code_studio ( gb ) ; extension_and_user_data ( s , gb , 4 ) ; return 0 ; }
CWE-476 static int decode_nal_unit ( HEVCContext * s , const H2645NAL * nal ) { HEVCLocalContext * lc = s -> HEVClc ; GetBitContext * gb = & lc -> gb ; int ctb_addr_ts , ret ; * gb = nal -> gb ; s -> nal_unit_type = nal -> type ; s -> temporal_id = nal -> temporal_id ; switch ( s -> nal_unit_type ) { case HEVC_NAL_VPS : if ( s -> avctx -> hwaccel && s -> avctx -> hwaccel -> decode_params ) { ret = s -> avctx -> hwaccel -> decode_params ( s -> avctx , nal -> type , nal -> raw_data , nal -> raw_size ) ; if ( ret < 0 ) goto fail ; } ret = ff_hevc_decode_nal_vps ( gb , s -> avctx , & s -> ps ) ; if ( ret < 0 ) goto fail ; break ; case HEVC_NAL_SPS : if ( s -> avctx -> hwaccel && s -> avctx -> hwaccel -> decode_params ) { ret = s -> avctx -> hwaccel -> decode_params ( s -> avctx , nal -> type , nal -> raw_data , nal -> raw_size ) ; if ( ret < 0 ) goto fail ; } ret = ff_hevc_decode_nal_sps ( gb , s -> avctx , & s -> ps , s -> apply_defdispwin ) ; if ( ret < 0 ) goto fail ; break ; case HEVC_NAL_PPS : if ( s -> avctx -> hwaccel && s -> avctx -> hwaccel -> decode_params ) { ret = s -> avctx -> hwaccel -> decode_params ( s -> avctx , nal -> type , nal -> raw_data , nal -> raw_size ) ; if ( ret < 0 ) goto fail ; } ret = ff_hevc_decode_nal_pps ( gb , s -> avctx , & s -> ps ) ; if ( ret < 0 ) goto fail ; break ; case HEVC_NAL_SEI_PREFIX : case HEVC_NAL_SEI_SUFFIX : if ( s -> avctx -> hwaccel && s -> avctx -> hwaccel -> decode_params ) { ret = s -> avctx -> hwaccel -> decode_params ( s -> avctx , nal -> type , nal -> raw_data , nal -> raw_size ) ; if ( ret < 0 ) goto fail ; } ret = ff_hevc_decode_nal_sei ( gb , s -> avctx , & s -> sei , & s -> ps , s -> nal_unit_type ) ; if ( ret < 0 ) goto fail ; break ; case HEVC_NAL_TRAIL_R : case HEVC_NAL_TRAIL_N : case HEVC_NAL_TSA_N : case HEVC_NAL_TSA_R : case HEVC_NAL_STSA_N : case HEVC_NAL_STSA_R : case HEVC_NAL_BLA_W_LP : case HEVC_NAL_BLA_W_RADL : case HEVC_NAL_BLA_N_LP : case HEVC_NAL_IDR_W_RADL : case HEVC_NAL_IDR_N_LP : case HEVC_NAL_CRA_NUT : case HEVC_NAL_RADL_N : case HEVC_NAL_RADL_R : case HEVC_NAL_RASL_N : case HEVC_NAL_RASL_R : ret = hls_slice_header ( s ) ; if ( ret < 0 ) <S2SV_StartBug> return ret ; <S2SV_EndBug> if ( ( s -> avctx -> skip_frame >= AVDISCARD_BIDIR && s -> sh . slice_type == HEVC_SLICE_B ) || ( s -> avctx -> skip_frame >= AVDISCARD_NONINTRA && s -> sh . slice_type != HEVC_SLICE_I ) || ( s -> avctx -> skip_frame >= AVDISCARD_NONKEY && ! IS_IRAP ( s ) ) ) { break ; } if ( s -> sh . first_slice_in_pic_flag ) { <S2SV_StartBug> if ( s -> ref ) { <S2SV_EndBug> av_log ( s -> avctx , AV_LOG_ERROR , "Two<S2SV_blank>slices<S2SV_blank>reporting<S2SV_blank>being<S2SV_blank>the<S2SV_blank>first<S2SV_blank>in<S2SV_blank>the<S2SV_blank>same<S2SV_blank>frame.\\n" ) ; goto fail ; } if ( s -> max_ra == INT_MAX ) { if ( s -> nal_unit_type == HEVC_NAL_CRA_NUT || IS_BLA ( s ) ) { s -> max_ra = s -> poc ; } else { if ( IS_IDR ( s ) ) s -> max_ra = INT_MIN ; } } if ( ( s -> nal_unit_type == HEVC_NAL_RASL_R || s -> nal_unit_type == HEVC_NAL_RASL_N ) && s -> poc <= s -> max_ra ) { s -> is_decoded = 0 ; break ; } else { if ( s -> nal_unit_type == HEVC_NAL_RASL_R && s -> poc > s -> max_ra ) s -> max_ra = INT_MIN ; } s -> overlap ++ ; ret = hevc_frame_start ( s ) ; if ( ret < 0 ) return ret ; } else if ( ! s -> ref ) { av_log ( s -> avctx , AV_LOG_ERROR , "First<S2SV_blank>slice<S2SV_blank>in<S2SV_blank>a<S2SV_blank>frame<S2SV_blank>missing.\\n" ) ; goto fail ; } if ( s -> nal_unit_type != s -> first_nal_type ) { av_log ( s -> avctx , AV_LOG_ERROR , "Non-matching<S2SV_blank>NAL<S2SV_blank>types<S2SV_blank>of<S2SV_blank>the<S2SV_blank>VCL<S2SV_blank>NALUs:<S2SV_blank>%d<S2SV_blank>%d\\n" , s -> first_nal_type , s -> nal_unit_type ) ; return AVERROR_INVALIDDATA ; } if ( ! s -> sh . dependent_slice_segment_flag && s -> sh . slice_type != HEVC_SLICE_I ) { ret = ff_hevc_slice_rpl ( s ) ; if ( ret < 0 ) { av_log ( s -> avctx , AV_LOG_WARNING , "Error<S2SV_blank>constructing<S2SV_blank>the<S2SV_blank>reference<S2SV_blank>lists<S2SV_blank>for<S2SV_blank>the<S2SV_blank>current<S2SV_blank>slice.\\n" ) ; goto fail ; } } if ( s -> sh . first_slice_in_pic_flag && s -> avctx -> hwaccel ) { ret = s -> avctx -> hwaccel -> start_frame ( s -> avctx , NULL , 0 ) ; if ( ret < 0 ) goto fail ; } if ( s -> avctx -> hwaccel ) { ret = s -> avctx -> hwaccel -> decode_slice ( s -> avctx , nal -> raw_data , nal -> raw_size ) ; if ( ret < 0 ) goto fail ; } else { if ( s -> threads_number > 1 && s -> sh . num_entry_point_offsets > 0 ) ctb_addr_ts = hls_slice_data_wpp ( s , nal ) ; else ctb_addr_ts = hls_slice_data ( s ) ; if ( ctb_addr_ts >= ( s -> ps . sps -> ctb_width * s -> ps . sps -> ctb_height ) ) { s -> is_decoded = 1 ; } if ( ctb_addr_ts < 0 ) { ret = ctb_addr_ts ; goto fail ; } } break ; case HEVC_NAL_EOS_NUT : case HEVC_NAL_EOB_NUT : s -> seq_decode = ( s -> seq_decode + 1 ) & 0xff ; s -> max_ra = INT_MAX ; break ; case HEVC_NAL_AUD : case HEVC_NAL_FD_NUT : break ; default : av_log ( s -> avctx , AV_LOG_INFO , "Skipping<S2SV_blank>NAL<S2SV_blank>unit<S2SV_blank>%d\\n" , s -> nal_unit_type ) ; } return 0 ; fail : if ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) return ret ; return 0 ; }
CWE-476 static int hls_slice_header ( HEVCContext * s ) { GetBitContext * gb = & s -> HEVClc -> gb ; SliceHeader * sh = & s -> sh ; int i , ret ; <S2SV_StartBug> sh -> first_slice_in_pic_flag = get_bits1 ( gb ) ; <S2SV_EndBug> if ( ( IS_IDR ( s ) || IS_BLA ( s ) ) && sh -> first_slice_in_pic_flag ) { s -> seq_decode = ( s -> seq_decode + 1 ) & 0xff ; s -> max_ra = INT_MAX ; if ( IS_IDR ( s ) ) ff_hevc_clear_refs ( s ) ; } sh -> no_output_of_prior_pics_flag = 0 ; if ( IS_IRAP ( s ) ) sh -> no_output_of_prior_pics_flag = get_bits1 ( gb ) ; sh -> pps_id = get_ue_golomb_long ( gb ) ; if ( sh -> pps_id >= HEVC_MAX_PPS_COUNT || ! s -> ps . pps_list [ sh -> pps_id ] ) { av_log ( s -> avctx , AV_LOG_ERROR , "PPS<S2SV_blank>id<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range:<S2SV_blank>%d\\n" , sh -> pps_id ) ; return AVERROR_INVALIDDATA ; } if ( ! sh -> first_slice_in_pic_flag && s -> ps . pps != ( HEVCPPS * ) s -> ps . pps_list [ sh -> pps_id ] -> data ) { av_log ( s -> avctx , AV_LOG_ERROR , "PPS<S2SV_blank>changed<S2SV_blank>between<S2SV_blank>slices.\\n" ) ; return AVERROR_INVALIDDATA ; } s -> ps . pps = ( HEVCPPS * ) s -> ps . pps_list [ sh -> pps_id ] -> data ; if ( s -> nal_unit_type == HEVC_NAL_CRA_NUT && s -> last_eos == 1 ) sh -> no_output_of_prior_pics_flag = 1 ; if ( s -> ps . sps != ( HEVCSPS * ) s -> ps . sps_list [ s -> ps . pps -> sps_id ] -> data ) { const HEVCSPS * sps = ( HEVCSPS * ) s -> ps . sps_list [ s -> ps . pps -> sps_id ] -> data ; const HEVCSPS * last_sps = s -> ps . sps ; enum AVPixelFormat pix_fmt ; if ( last_sps && IS_IRAP ( s ) && s -> nal_unit_type != HEVC_NAL_CRA_NUT ) { if ( sps -> width != last_sps -> width || sps -> height != last_sps -> height || sps -> temporal_layer [ sps -> max_sub_layers - 1 ] . max_dec_pic_buffering != last_sps -> temporal_layer [ last_sps -> max_sub_layers - 1 ] . max_dec_pic_buffering ) sh -> no_output_of_prior_pics_flag = 0 ; } ff_hevc_clear_refs ( s ) ; ret = set_sps ( s , sps , sps -> pix_fmt ) ; if ( ret < 0 ) return ret ; pix_fmt = get_format ( s , sps ) ; if ( pix_fmt < 0 ) return pix_fmt ; s -> avctx -> pix_fmt = pix_fmt ; s -> seq_decode = ( s -> seq_decode + 1 ) & 0xff ; s -> max_ra = INT_MAX ; } sh -> dependent_slice_segment_flag = 0 ; if ( ! sh -> first_slice_in_pic_flag ) { int slice_address_length ; if ( s -> ps . pps -> dependent_slice_segments_enabled_flag ) sh -> dependent_slice_segment_flag = get_bits1 ( gb ) ; slice_address_length = av_ceil_log2 ( s -> ps . sps -> ctb_width * s -> ps . sps -> ctb_height ) ; sh -> slice_segment_addr = get_bitsz ( gb , slice_address_length ) ; if ( sh -> slice_segment_addr >= s -> ps . sps -> ctb_width * s -> ps . sps -> ctb_height ) { av_log ( s -> avctx , AV_LOG_ERROR , "Invalid<S2SV_blank>slice<S2SV_blank>segment<S2SV_blank>address:<S2SV_blank>%u.\\n" , sh -> slice_segment_addr ) ; return AVERROR_INVALIDDATA ; } if ( ! sh -> dependent_slice_segment_flag ) { sh -> slice_addr = sh -> slice_segment_addr ; s -> slice_idx ++ ; } } else { sh -> slice_segment_addr = sh -> slice_addr = 0 ; s -> slice_idx = 0 ; s -> slice_initialized = 0 ; } if ( ! sh -> dependent_slice_segment_flag ) { s -> slice_initialized = 0 ; for ( i = 0 ; i < s -> ps . pps -> num_extra_slice_header_bits ; i ++ ) skip_bits ( gb , 1 ) ; sh -> slice_type = get_ue_golomb_long ( gb ) ; if ( ! ( sh -> slice_type == HEVC_SLICE_I || sh -> slice_type == HEVC_SLICE_P || sh -> slice_type == HEVC_SLICE_B ) ) { av_log ( s -> avctx , AV_LOG_ERROR , "Unknown<S2SV_blank>slice<S2SV_blank>type:<S2SV_blank>%d.\\n" , sh -> slice_type ) ; return AVERROR_INVALIDDATA ; } if ( IS_IRAP ( s ) && sh -> slice_type != HEVC_SLICE_I ) { av_log ( s -> avctx , AV_LOG_ERROR , "Inter<S2SV_blank>slices<S2SV_blank>in<S2SV_blank>an<S2SV_blank>IRAP<S2SV_blank>frame.\\n" ) ; return AVERROR_INVALIDDATA ; } sh -> pic_output_flag = 1 ; if ( s -> ps . pps -> output_flag_present_flag ) sh -> pic_output_flag = get_bits1 ( gb ) ; if ( s -> ps . sps -> separate_colour_plane_flag ) sh -> colour_plane_id = get_bits ( gb , 2 ) ; if ( ! IS_IDR ( s ) ) { int poc , pos ; sh -> pic_order_cnt_lsb = get_bits ( gb , s -> ps . sps -> log2_max_poc_lsb ) ; poc = ff_hevc_compute_poc ( s -> ps . sps , s -> pocTid0 , sh -> pic_order_cnt_lsb , s -> nal_unit_type ) ; if ( ! sh -> first_slice_in_pic_flag && poc != s -> poc ) { av_log ( s -> avctx , AV_LOG_WARNING , "Ignoring<S2SV_blank>POC<S2SV_blank>change<S2SV_blank>between<S2SV_blank>slices:<S2SV_blank>%d<S2SV_blank>-><S2SV_blank>%d\\n" , s -> poc , poc ) ; if ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) return AVERROR_INVALIDDATA ; poc = s -> poc ; } s -> poc = poc ; sh -> short_term_ref_pic_set_sps_flag = get_bits1 ( gb ) ; pos = get_bits_left ( gb ) ; if ( ! sh -> short_term_ref_pic_set_sps_flag ) { ret = ff_hevc_decode_short_term_rps ( gb , s -> avctx , & sh -> slice_rps , s -> ps . sps , 1 ) ; if ( ret < 0 ) return ret ; sh -> short_term_rps = & sh -> slice_rps ; } else { int numbits , rps_idx ; if ( ! s -> ps . sps -> nb_st_rps ) { av_log ( s -> avctx , AV_LOG_ERROR , "No<S2SV_blank>ref<S2SV_blank>lists<S2SV_blank>in<S2SV_blank>the<S2SV_blank>SPS.\\n" ) ; return AVERROR_INVALIDDATA ; } numbits = av_ceil_log2 ( s -> ps . sps -> nb_st_rps ) ; rps_idx = numbits > 0 ? get_bits ( gb , numbits ) : 0 ; sh -> short_term_rps = & s -> ps . sps -> st_rps [ rps_idx ] ; } sh -> short_term_ref_pic_set_size = pos - get_bits_left ( gb ) ; pos = get_bits_left ( gb ) ; ret = decode_lt_rps ( s , & sh -> long_term_rps , gb ) ; if ( ret < 0 ) { av_log ( s -> avctx , AV_LOG_WARNING , "Invalid<S2SV_blank>long<S2SV_blank>term<S2SV_blank>RPS.\\n" ) ; if ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) return AVERROR_INVALIDDATA ; } sh -> long_term_ref_pic_set_size = pos - get_bits_left ( gb ) ; if ( s -> ps . sps -> sps_temporal_mvp_enabled_flag ) sh -> slice_temporal_mvp_enabled_flag = get_bits1 ( gb ) ; else sh -> slice_temporal_mvp_enabled_flag = 0 ; } else { s -> sh . short_term_rps = NULL ; s -> poc = 0 ; } if ( sh -> first_slice_in_pic_flag && s -> temporal_id == 0 && s -> nal_unit_type != HEVC_NAL_TRAIL_N && s -> nal_unit_type != HEVC_NAL_TSA_N && s -> nal_unit_type != HEVC_NAL_STSA_N && s -> nal_unit_type != HEVC_NAL_RADL_N && s -> nal_unit_type != HEVC_NAL_RADL_R && s -> nal_unit_type != HEVC_NAL_RASL_N && s -> nal_unit_type != HEVC_NAL_RASL_R ) s -> pocTid0 = s -> poc ; if ( s -> ps . sps -> sao_enabled ) { sh -> slice_sample_adaptive_offset_flag [ 0 ] = get_bits1 ( gb ) ; if ( s -> ps . sps -> chroma_format_idc ) { sh -> slice_sample_adaptive_offset_flag [ 1 ] = sh -> slice_sample_adaptive_offset_flag [ 2 ] = get_bits1 ( gb ) ; } } else { sh -> slice_sample_adaptive_offset_flag [ 0 ] = 0 ; sh -> slice_sample_adaptive_offset_flag [ 1 ] = 0 ; sh -> slice_sample_adaptive_offset_flag [ 2 ] = 0 ; } sh -> nb_refs [ L0 ] = sh -> nb_refs [ L1 ] = 0 ; if ( sh -> slice_type == HEVC_SLICE_P || sh -> slice_type == HEVC_SLICE_B ) { int nb_refs ; sh -> nb_refs [ L0 ] = s -> ps . pps -> num_ref_idx_l0_default_active ; if ( sh -> slice_type == HEVC_SLICE_B ) sh -> nb_refs [ L1 ] = s -> ps . pps -> num_ref_idx_l1_default_active ; if ( get_bits1 ( gb ) ) { sh -> nb_refs [ L0 ] = get_ue_golomb_long ( gb ) + 1 ; if ( sh -> slice_type == HEVC_SLICE_B ) sh -> nb_refs [ L1 ] = get_ue_golomb_long ( gb ) + 1 ; } if ( sh -> nb_refs [ L0 ] > HEVC_MAX_REFS || sh -> nb_refs [ L1 ] > HEVC_MAX_REFS ) { av_log ( s -> avctx , AV_LOG_ERROR , "Too<S2SV_blank>many<S2SV_blank>refs:<S2SV_blank>%d/%d.\\n" , sh -> nb_refs [ L0 ] , sh -> nb_refs [ L1 ] ) ; return AVERROR_INVALIDDATA ; } sh -> rpl_modification_flag [ 0 ] = 0 ; sh -> rpl_modification_flag [ 1 ] = 0 ; nb_refs = ff_hevc_frame_nb_refs ( s ) ; if ( ! nb_refs ) { av_log ( s -> avctx , AV_LOG_ERROR , "Zero<S2SV_blank>refs<S2SV_blank>for<S2SV_blank>a<S2SV_blank>frame<S2SV_blank>with<S2SV_blank>P<S2SV_blank>or<S2SV_blank>B<S2SV_blank>slices.\\n" ) ; return AVERROR_INVALIDDATA ; } if ( s -> ps . pps -> lists_modification_present_flag && nb_refs > 1 ) { sh -> rpl_modification_flag [ 0 ] = get_bits1 ( gb ) ; if ( sh -> rpl_modification_flag [ 0 ] ) { for ( i = 0 ; i < sh -> nb_refs [ L0 ] ; i ++ ) sh -> list_entry_lx [ 0 ] [ i ] = get_bits ( gb , av_ceil_log2 ( nb_refs ) ) ; } if ( sh -> slice_type == HEVC_SLICE_B ) { sh -> rpl_modification_flag [ 1 ] = get_bits1 ( gb ) ; if ( sh -> rpl_modification_flag [ 1 ] == 1 ) for ( i = 0 ; i < sh -> nb_refs [ L1 ] ; i ++ ) sh -> list_entry_lx [ 1 ] [ i ] = get_bits ( gb , av_ceil_log2 ( nb_refs ) ) ; } } if ( sh -> slice_type == HEVC_SLICE_B ) sh -> mvd_l1_zero_flag = get_bits1 ( gb ) ; if ( s -> ps . pps -> cabac_init_present_flag ) sh -> cabac_init_flag = get_bits1 ( gb ) ; else sh -> cabac_init_flag = 0 ; sh -> collocated_ref_idx = 0 ; if ( sh -> slice_temporal_mvp_enabled_flag ) { sh -> collocated_list = L0 ; if ( sh -> slice_type == HEVC_SLICE_B ) sh -> collocated_list = ! get_bits1 ( gb ) ; if ( sh -> nb_refs [ sh -> collocated_list ] > 1 ) { sh -> collocated_ref_idx = get_ue_golomb_long ( gb ) ; if ( sh -> collocated_ref_idx >= sh -> nb_refs [ sh -> collocated_list ] ) { av_log ( s -> avctx , AV_LOG_ERROR , "Invalid<S2SV_blank>collocated_ref_idx:<S2SV_blank>%d.\\n" , sh -> collocated_ref_idx ) ; return AVERROR_INVALIDDATA ; } } } if ( ( s -> ps . pps -> weighted_pred_flag && sh -> slice_type == HEVC_SLICE_P ) || ( s -> ps . pps -> weighted_bipred_flag && sh -> slice_type == HEVC_SLICE_B ) ) { int ret = pred_weight_table ( s , gb ) ; if ( ret < 0 ) return ret ; } sh -> max_num_merge_cand = 5 - get_ue_golomb_long ( gb ) ; if ( sh -> max_num_merge_cand < 1 || sh -> max_num_merge_cand > 5 ) { av_log ( s -> avctx , AV_LOG_ERROR , "Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>merging<S2SV_blank>MVP<S2SV_blank>candidates:<S2SV_blank>%d.\\n" , sh -> max_num_merge_cand ) ; return AVERROR_INVALIDDATA ; } } sh -> slice_qp_delta = get_se_golomb ( gb ) ; if ( s -> ps . pps -> pic_slice_level_chroma_qp_offsets_present_flag ) { sh -> slice_cb_qp_offset = get_se_golomb ( gb ) ; sh -> slice_cr_qp_offset = get_se_golomb ( gb ) ; } else { sh -> slice_cb_qp_offset = 0 ; sh -> slice_cr_qp_offset = 0 ; } if ( s -> ps . pps -> chroma_qp_offset_list_enabled_flag ) sh -> cu_chroma_qp_offset_enabled_flag = get_bits1 ( gb ) ; else sh -> cu_chroma_qp_offset_enabled_flag = 0 ; if ( s -> ps . pps -> deblocking_filter_control_present_flag ) { int deblocking_filter_override_flag = 0 ; if ( s -> ps . pps -> deblocking_filter_override_enabled_flag ) deblocking_filter_override_flag = get_bits1 ( gb ) ; if ( deblocking_filter_override_flag ) { sh -> disable_deblocking_filter_flag = get_bits1 ( gb ) ; if ( ! sh -> disable_deblocking_filter_flag ) { int beta_offset_div2 = get_se_golomb ( gb ) ; int tc_offset_div2 = get_se_golomb ( gb ) ; if ( beta_offset_div2 < - 6 || beta_offset_div2 > 6 || tc_offset_div2 < - 6 || tc_offset_div2 > 6 ) { av_log ( s -> avctx , AV_LOG_ERROR , "Invalid<S2SV_blank>deblock<S2SV_blank>filter<S2SV_blank>offsets:<S2SV_blank>%d,<S2SV_blank>%d\\n" , beta_offset_div2 , tc_offset_div2 ) ; return AVERROR_INVALIDDATA ; } sh -> beta_offset = beta_offset_div2 * 2 ; sh -> tc_offset = tc_offset_div2 * 2 ; } } else { sh -> disable_deblocking_filter_flag = s -> ps . pps -> disable_dbf ; sh -> beta_offset = s -> ps . pps -> beta_offset ; sh -> tc_offset = s -> ps . pps -> tc_offset ; } } else { sh -> disable_deblocking_filter_flag = 0 ; sh -> beta_offset = 0 ; sh -> tc_offset = 0 ; } if ( s -> ps . pps -> seq_loop_filter_across_slices_enabled_flag && ( sh -> slice_sample_adaptive_offset_flag [ 0 ] || sh -> slice_sample_adaptive_offset_flag [ 1 ] || ! sh -> disable_deblocking_filter_flag ) ) { sh -> slice_loop_filter_across_slices_enabled_flag = get_bits1 ( gb ) ; } else { sh -> slice_loop_filter_across_slices_enabled_flag = s -> ps . pps -> seq_loop_filter_across_slices_enabled_flag ; } } else if ( ! s -> slice_initialized ) { av_log ( s -> avctx , AV_LOG_ERROR , "Independent<S2SV_blank>slice<S2SV_blank>segment<S2SV_blank>missing.\\n" ) ; return AVERROR_INVALIDDATA ; } sh -> num_entry_point_offsets = 0 ; if ( s -> ps . pps -> tiles_enabled_flag || s -> ps . pps -> entropy_coding_sync_enabled_flag ) { unsigned num_entry_point_offsets = get_ue_golomb_long ( gb ) ; if ( num_entry_point_offsets > get_bits_left ( gb ) ) { av_log ( s -> avctx , AV_LOG_ERROR , "num_entry_point_offsets<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>invalid\\n" , num_entry_point_offsets ) ; return AVERROR_INVALIDDATA ; } sh -> num_entry_point_offsets = num_entry_point_offsets ; if ( sh -> num_entry_point_offsets > 0 ) { int offset_len = get_ue_golomb_long ( gb ) + 1 ; if ( offset_len < 1 || offset_len > 32 ) { sh -> num_entry_point_offsets = 0 ; av_log ( s -> avctx , AV_LOG_ERROR , "offset_len<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>invalid\\n" , offset_len ) ; return AVERROR_INVALIDDATA ; } av_freep ( & sh -> entry_point_offset ) ; av_freep ( & sh -> offset ) ; av_freep ( & sh -> size ) ; sh -> entry_point_offset = av_malloc_array ( sh -> num_entry_point_offsets , sizeof ( unsigned ) ) ; sh -> offset = av_malloc_array ( sh -> num_entry_point_offsets , sizeof ( int ) ) ; sh -> size = av_malloc_array ( sh -> num_entry_point_offsets , sizeof ( int ) ) ; if ( ! sh -> entry_point_offset || ! sh -> offset || ! sh -> size ) { sh -> num_entry_point_offsets = 0 ; av_log ( s -> avctx , AV_LOG_ERROR , "Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory\\n" ) ; return AVERROR ( ENOMEM ) ; } for ( i = 0 ; i < sh -> num_entry_point_offsets ; i ++ ) { unsigned val = get_bits_long ( gb , offset_len ) ; sh -> entry_point_offset [ i ] = val + 1 ; } if ( s -> threads_number > 1 && ( s -> ps . pps -> num_tile_rows > 1 || s -> ps . pps -> num_tile_columns > 1 ) ) { s -> enable_parallel_tiles = 0 ; s -> threads_number = 1 ; } else s -> enable_parallel_tiles = 0 ; } else s -> enable_parallel_tiles = 0 ; } if ( s -> ps . pps -> slice_header_extension_present_flag ) { unsigned int length = get_ue_golomb_long ( gb ) ; if ( length * 8LL > get_bits_left ( gb ) ) { av_log ( s -> avctx , AV_LOG_ERROR , "too<S2SV_blank>many<S2SV_blank>slice_header_extension_data_bytes\\n" ) ; return AVERROR_INVALIDDATA ; } for ( i = 0 ; i < length ; i ++ ) skip_bits ( gb , 8 ) ; } sh -> slice_qp = 26U + s -> ps . pps -> pic_init_qp_minus26 + sh -> slice_qp_delta ; if ( sh -> slice_qp > 51 || sh -> slice_qp < - s -> ps . sps -> qp_bd_offset ) { av_log ( s -> avctx , AV_LOG_ERROR , "The<S2SV_blank>slice_qp<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>outside<S2SV_blank>the<S2SV_blank>valid<S2SV_blank>range<S2SV_blank>" "[%d,<S2SV_blank>51].\\n" , sh -> slice_qp , - s -> ps . sps -> qp_bd_offset ) ; return AVERROR_INVALIDDATA ; } sh -> slice_ctb_addr_rs = sh -> slice_segment_addr ; if ( ! s -> sh . slice_ctb_addr_rs && s -> sh . dependent_slice_segment_flag ) { av_log ( s -> avctx , AV_LOG_ERROR , "Impossible<S2SV_blank>slice<S2SV_blank>segment.\\n" ) ; return AVERROR_INVALIDDATA ; } if ( get_bits_left ( gb ) < 0 ) { av_log ( s -> avctx , AV_LOG_ERROR , "Overread<S2SV_blank>slice<S2SV_blank>header<S2SV_blank>by<S2SV_blank>%d<S2SV_blank>bits\\n" , - get_bits_left ( gb ) ) ; return AVERROR_INVALIDDATA ; } s -> HEVClc -> first_qp_group = ! s -> sh . dependent_slice_segment_flag ; if ( ! s -> ps . pps -> cu_qp_delta_enabled_flag ) s -> HEVClc -> qp_y = s -> sh . slice_qp ; s -> slice_initialized = 1 ; s -> HEVClc -> tu . cu_qp_offset_cb = 0 ; s -> HEVClc -> tu . cu_qp_offset_cr = 0 ; return 0 ; }
CWE-125 static int mpeg4_decode_studio_block ( MpegEncContext * s , int32_t block [ 64 ] , int n ) { Mpeg4DecContext * ctx = s -> avctx -> priv_data ; int cc , dct_dc_size , dct_diff , code , j , idx = 1 , group = 0 , run = 0 , additional_code_len , sign , mismatch ; VLC * cur_vlc = & ctx -> studio_intra_tab [ 0 ] ; uint8_t * const scantable = s -> intra_scantable . permutated ; const uint16_t * quant_matrix ; uint32_t flc ; const int min = - 1 * ( 1 << ( s -> avctx -> bits_per_raw_sample + 6 ) ) ; const int max = ( ( 1 << ( s -> avctx -> bits_per_raw_sample + 6 ) ) - 1 ) ; mismatch = 1 ; memset ( block , 0 , 64 * sizeof ( int32_t ) ) ; if ( n < 4 ) { cc = 0 ; dct_dc_size = get_vlc2 ( & s -> gb , ctx -> studio_luma_dc . table , STUDIO_INTRA_BITS , 2 ) ; quant_matrix = s -> intra_matrix ; } else { cc = ( n & 1 ) + 1 ; if ( ctx -> rgb ) dct_dc_size = get_vlc2 ( & s -> gb , ctx -> studio_luma_dc . table , STUDIO_INTRA_BITS , 2 ) ; else dct_dc_size = get_vlc2 ( & s -> gb , ctx -> studio_chroma_dc . table , STUDIO_INTRA_BITS , 2 ) ; quant_matrix = s -> chroma_intra_matrix ; } if ( dct_dc_size < 0 ) { av_log ( s -> avctx , AV_LOG_ERROR , "illegal<S2SV_blank>dct_dc_size<S2SV_blank>vlc\\n" ) ; return AVERROR_INVALIDDATA ; } else if ( dct_dc_size == 0 ) { dct_diff = 0 ; } else { dct_diff = get_xbits ( & s -> gb , dct_dc_size ) ; if ( dct_dc_size > 8 ) { if ( ! check_marker ( s -> avctx , & s -> gb , "dct_dc_size<S2SV_blank>><S2SV_blank>8" ) ) return AVERROR_INVALIDDATA ; } } s -> last_dc [ cc ] += dct_diff ; if ( s -> mpeg_quant ) block [ 0 ] = s -> last_dc [ cc ] * ( 8 >> s -> intra_dc_precision ) ; else block [ 0 ] = s -> last_dc [ cc ] * ( 8 >> s -> intra_dc_precision ) * ( 8 >> s -> dct_precision ) ; block [ 0 ] = av_clip ( block [ 0 ] , min , max ) ; mismatch ^= block [ 0 ] ; while ( 1 ) { group = get_vlc2 ( & s -> gb , cur_vlc -> table , STUDIO_INTRA_BITS , 2 ) ; if ( group < 0 ) { av_log ( s -> avctx , AV_LOG_ERROR , "illegal<S2SV_blank>ac<S2SV_blank>coefficient<S2SV_blank>group<S2SV_blank>vlc\\n" ) ; return AVERROR_INVALIDDATA ; } additional_code_len = ac_state_tab [ group ] [ 0 ] ; cur_vlc = & ctx -> studio_intra_tab [ ac_state_tab [ group ] [ 1 ] ] ; if ( group == 0 ) { break ; } else if ( group >= 1 && group <= 6 ) { run = 1 << additional_code_len ; if ( additional_code_len ) run += get_bits ( & s -> gb , additional_code_len ) ; idx += run ; continue ; } else if ( group >= 7 && group <= 12 ) { code = get_bits ( & s -> gb , additional_code_len ) ; sign = code & 1 ; code >>= 1 ; run = ( 1 << ( additional_code_len - 1 ) ) + code ; idx += run ; <S2SV_StartBug> j = scantable [ idx ++ ] ; <S2SV_EndBug> block [ j ] = sign ? 1 : - 1 ; } else if ( group >= 13 && group <= 20 ) { <S2SV_StartBug> j = scantable [ idx ++ ] ; <S2SV_EndBug> block [ j ] = get_xbits ( & s -> gb , additional_code_len ) ; <S2SV_StartBug> } else if ( group == 21 ) { <S2SV_EndBug> j = scantable [ idx ++ ] ; additional_code_len = s -> avctx -> bits_per_raw_sample + s -> dct_precision + 4 ; flc = get_bits ( & s -> gb , additional_code_len ) ; if ( flc >> ( additional_code_len - 1 ) ) block [ j ] = - 1 * ( ( flc ^ ( ( 1 << additional_code_len ) - 1 ) ) + 1 ) ; else block [ j ] = flc ; } block [ j ] = ( ( 8 * 2 * block [ j ] * quant_matrix [ j ] * s -> qscale ) >> s -> dct_precision ) / 32 ; block [ j ] = av_clip ( block [ j ] , min , max ) ; mismatch ^= block [ j ] ; } block [ 63 ] ^= mismatch & 1 ; return 0 ; }
CWE-665 static int aa_read_header ( AVFormatContext * s ) { int i , j , idx , largest_idx = - 1 ; uint32_t nkey , nval , toc_size , npairs , header_seed = 0 , start ; char key [ 128 ] , val [ 128 ] , codec_name [ 64 ] = { 0 } ; uint8_t output [ 24 ] , dst [ 8 ] , src [ 8 ] ; int64_t largest_size = - 1 , current_size = - 1 , chapter_pos ; struct toc_entry { uint32_t offset ; uint32_t size ; } TOC [ MAX_TOC_ENTRIES ] ; uint32_t header_key_part [ 4 ] ; uint8_t header_key [ 16 ] = { 0 } ; AADemuxContext * c = s -> priv_data ; AVIOContext * pb = s -> pb ; AVStream * st ; <S2SV_StartBug> avio_skip ( pb , 4 ) ; <S2SV_EndBug> avio_skip ( pb , 4 ) ; toc_size = avio_rb32 ( pb ) ; avio_skip ( pb , 4 ) ; if ( toc_size > MAX_TOC_ENTRIES ) return AVERROR_INVALIDDATA ; for ( i = 0 ; i < toc_size ; i ++ ) { avio_skip ( pb , 4 ) ; TOC [ i ] . offset = avio_rb32 ( pb ) ; TOC [ i ] . size = avio_rb32 ( pb ) ; } avio_skip ( pb , 24 ) ; npairs = avio_rb32 ( pb ) ; if ( npairs > MAX_DICTIONARY_ENTRIES ) return AVERROR_INVALIDDATA ; for ( i = 0 ; i < npairs ; i ++ ) { memset ( val , 0 , sizeof ( val ) ) ; memset ( key , 0 , sizeof ( key ) ) ; avio_skip ( pb , 1 ) ; nkey = avio_rb32 ( pb ) ; nval = avio_rb32 ( pb ) ; avio_get_str ( pb , nkey , key , sizeof ( key ) ) ; avio_get_str ( pb , nval , val , sizeof ( val ) ) ; if ( ! strcmp ( key , "codec" ) ) { av_log ( s , AV_LOG_DEBUG , "Codec<S2SV_blank>is<S2SV_blank><%s>\\n" , val ) ; strncpy ( codec_name , val , sizeof ( codec_name ) - 1 ) ; } else if ( ! strcmp ( key , "HeaderSeed" ) ) { av_log ( s , AV_LOG_DEBUG , "HeaderSeed<S2SV_blank>is<S2SV_blank><%s>\\n" , val ) ; header_seed = atoi ( val ) ; } else if ( ! strcmp ( key , "HeaderKey" ) ) { av_log ( s , AV_LOG_DEBUG , "HeaderKey<S2SV_blank>is<S2SV_blank><%s>\\n" , val ) ; <S2SV_StartBug> sscanf ( val , "%" SCNu32 "%" SCNu32 "%" SCNu32 "%" SCNu32 , <S2SV_EndBug> & header_key_part [ 0 ] , & header_key_part [ 1 ] , & header_key_part [ 2 ] , & header_key_part [ 3 ] ) ; <S2SV_StartBug> for ( idx = 0 ; idx < 4 ; idx ++ ) { <S2SV_EndBug> AV_WB32 ( & header_key [ idx * 4 ] , header_key_part [ idx ] ) ; } av_log ( s , AV_LOG_DEBUG , "Processed<S2SV_blank>HeaderKey<S2SV_blank>is<S2SV_blank>" ) ; for ( i = 0 ; i < 16 ; i ++ ) av_log ( s , AV_LOG_DEBUG , "%02x" , header_key [ i ] ) ; av_log ( s , AV_LOG_DEBUG , "\\n" ) ; } else { av_dict_set ( & s -> metadata , key , val , 0 ) ; } } if ( c -> aa_fixed_key_len != 16 ) { av_log ( s , AV_LOG_ERROR , "aa_fixed_key<S2SV_blank>value<S2SV_blank>needs<S2SV_blank>to<S2SV_blank>be<S2SV_blank>16<S2SV_blank>bytes!\\n" ) ; return AVERROR ( EINVAL ) ; } if ( ( c -> codec_second_size = get_second_size ( codec_name ) ) == - 1 ) { av_log ( s , AV_LOG_ERROR , "unknown<S2SV_blank>codec<S2SV_blank><%s>!\\n" , codec_name ) ; return AVERROR ( EINVAL ) ; } c -> tea_ctx = av_tea_alloc ( ) ; if ( ! c -> tea_ctx ) return AVERROR ( ENOMEM ) ; av_tea_init ( c -> tea_ctx , c -> aa_fixed_key , 16 ) ; output [ 0 ] = output [ 1 ] = 0 ; memcpy ( output + 2 , header_key , 16 ) ; idx = 0 ; for ( i = 0 ; i < 3 ; i ++ ) { AV_WB32 ( src , header_seed ) ; AV_WB32 ( src + 4 , header_seed + 1 ) ; header_seed += 2 ; av_tea_crypt ( c -> tea_ctx , dst , src , 1 , NULL , 0 ) ; for ( j = 0 ; j < TEA_BLOCK_SIZE && idx < 18 ; j += 1 , idx += 1 ) { output [ idx ] = output [ idx ] ^ dst [ j ] ; } } memcpy ( c -> file_key , output + 2 , 16 ) ; av_log ( s , AV_LOG_DEBUG , "File<S2SV_blank>key<S2SV_blank>is<S2SV_blank>" ) ; for ( i = 0 ; i < 16 ; i ++ ) av_log ( s , AV_LOG_DEBUG , "%02x" , c -> file_key [ i ] ) ; av_log ( s , AV_LOG_DEBUG , "\\n" ) ; st = avformat_new_stream ( s , NULL ) ; if ( ! st ) { av_freep ( & c -> tea_ctx ) ; return AVERROR ( ENOMEM ) ; } st -> codecpar -> codec_type = AVMEDIA_TYPE_AUDIO ; if ( ! strcmp ( codec_name , "mp332" ) ) { st -> codecpar -> codec_id = AV_CODEC_ID_MP3 ; st -> codecpar -> sample_rate = 22050 ; st -> need_parsing = AVSTREAM_PARSE_FULL_RAW ; avpriv_set_pts_info ( st , 64 , 8 , 32000 * TIMEPREC ) ; } else if ( ! strcmp ( codec_name , "acelp85" ) ) { st -> codecpar -> codec_id = AV_CODEC_ID_SIPR ; st -> codecpar -> block_align = 19 ; st -> codecpar -> channels = 1 ; st -> codecpar -> sample_rate = 8500 ; st -> codecpar -> bit_rate = 8500 ; st -> need_parsing = AVSTREAM_PARSE_FULL_RAW ; avpriv_set_pts_info ( st , 64 , 8 , 8500 * TIMEPREC ) ; } else if ( ! strcmp ( codec_name , "acelp16" ) ) { st -> codecpar -> codec_id = AV_CODEC_ID_SIPR ; st -> codecpar -> block_align = 20 ; st -> codecpar -> channels = 1 ; st -> codecpar -> sample_rate = 16000 ; st -> codecpar -> bit_rate = 16000 ; st -> need_parsing = AVSTREAM_PARSE_FULL_RAW ; avpriv_set_pts_info ( st , 64 , 8 , 16000 * TIMEPREC ) ; } for ( i = 1 ; i < toc_size ; i ++ ) { current_size = TOC [ i ] . size ; if ( current_size > largest_size ) { largest_idx = i ; largest_size = current_size ; } } start = TOC [ largest_idx ] . offset ; avio_seek ( pb , start , SEEK_SET ) ; st -> start_time = 0 ; c -> content_start = start ; c -> content_end = start + largest_size ; while ( ( chapter_pos = avio_tell ( pb ) ) >= 0 && chapter_pos < c -> content_end ) { int chapter_idx = s -> nb_chapters ; uint32_t chapter_size = avio_rb32 ( pb ) ; if ( chapter_size == 0 ) break ; chapter_pos -= start + CHAPTER_HEADER_SIZE * chapter_idx ; avio_skip ( pb , 4 + chapter_size ) ; if ( ! avpriv_new_chapter ( s , chapter_idx , st -> time_base , chapter_pos * TIMEPREC , ( chapter_pos + chapter_size ) * TIMEPREC , NULL ) ) return AVERROR ( ENOMEM ) ; } st -> duration = ( largest_size - CHAPTER_HEADER_SIZE * s -> nb_chapters ) * TIMEPREC ; ff_update_cur_dts ( s , st , 0 ) ; avio_seek ( pb , start , SEEK_SET ) ; c -> current_chapter_size = 0 ; c -> seek_offset = 0 ; return 0 ; }
CWE-119 static PixelChannels * * AcquirePixelThreadSet ( const Image * images ) { const Image * next ; PixelChannels * * pixels ; register ssize_t i ; size_t columns , <S2SV_StartBug> number_threads ; <S2SV_EndBug> <S2SV_StartBug> number_threads = ( size_t ) GetMagickResourceLimit ( ThreadResource ) ; <S2SV_EndBug> <S2SV_StartBug> pixels = ( PixelChannels * * ) AcquireQuantumMemory ( number_threads , <S2SV_EndBug> sizeof ( * pixels ) ) ; if ( pixels == ( PixelChannels * * ) NULL ) return ( ( PixelChannels * * ) NULL ) ; <S2SV_StartBug> ( void ) memset ( pixels , 0 , number_threads * sizeof ( * pixels ) ) ; <S2SV_EndBug> columns = images -> columns ; for ( next = images ; next != ( Image * ) NULL ; next = next -> next ) columns = MagickMax ( next -> columns , columns ) ; <S2SV_StartBug> for ( i = 0 ; i < ( ssize_t ) number_threads ; i ++ ) <S2SV_EndBug> { register ssize_t j ; pixels [ i ] = ( PixelChannels * ) AcquireQuantumMemory ( columns , sizeof ( * * pixels ) ) ; if ( pixels [ i ] == ( PixelChannels * ) NULL ) return ( DestroyPixelThreadSet ( pixels ) ) ; for ( j = 0 ; j < ( ssize_t ) columns ; j ++ ) { register ssize_t k ; for ( k = 0 ; k < MaxPixelChannels ; k ++ ) pixels [ i ] [ j ] . channel [ k ] = 0.0 ; } } return ( pixels ) ; }
CWE-399 static MagickBooleanType DecodeImage ( Image * image , unsigned char * luma , unsigned char * chroma1 , unsigned char * chroma2 , ExceptionInfo * exception ) { # define IsSync ( sum ) ( ( sum & 0xffffff00UL ) == 0xfffffe00UL ) <S2SV_StartBug> # define PCDGetBits ( n ) { sum = ( sum << n ) & 0xffffffff ; bits -= n ; while ( bits <= 24 ) { if ( p >= ( buffer + 0x800 ) ) { count = ReadBlob ( image , 0x800 , buffer ) ; p = buffer ; } sum |= ( ( unsigned int ) ( * p ) << ( 24 - bits ) ) ; bits += 8 ; p ++ ; } } <S2SV_EndBug> typedef struct PCDTable { unsigned int length , sequence ; MagickStatusType mask ; unsigned char key ; } PCDTable ; PCDTable * pcd_table [ 3 ] ; register ssize_t i , j ; register PCDTable * r ; register unsigned char * p , * q ; size_t bits , length , plane , pcd_length [ 3 ] , row , sum ; ssize_t count , quantum ; unsigned char * buffer ; assert ( image != ( const Image * ) NULL ) ; assert ( image -> signature == MagickCoreSignature ) ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , image -> filename ) ; assert ( luma != ( unsigned char * ) NULL ) ; assert ( chroma1 != ( unsigned char * ) NULL ) ; assert ( chroma2 != ( unsigned char * ) NULL ) ; buffer = ( unsigned char * ) AcquireQuantumMemory ( 0x800 , sizeof ( * buffer ) ) ; if ( buffer == ( unsigned char * ) NULL ) ThrowBinaryException ( ResourceLimitError , "MemoryAllocationFailed" , image -> filename ) ; sum = 0 ; bits = 32 ; p = buffer + 0x800 ; for ( i = 0 ; i < 3 ; i ++ ) { pcd_table [ i ] = ( PCDTable * ) NULL ; pcd_length [ i ] = 0 ; } for ( i = 0 ; i < ( image -> columns > 1536 ? 3 : 1 ) ; i ++ ) { PCDGetBits ( 8 ) ; length = ( sum & 0xff ) + 1 ; pcd_table [ i ] = ( PCDTable * ) AcquireQuantumMemory ( length , sizeof ( * pcd_table [ i ] ) ) ; if ( pcd_table [ i ] == ( PCDTable * ) NULL ) { buffer = ( unsigned char * ) RelinquishMagickMemory ( buffer ) ; <S2SV_StartBug> ThrowBinaryException ( ResourceLimitError , "MemoryAllocationFailed" , <S2SV_EndBug> image -> filename ) ; } r = pcd_table [ i ] ; for ( j = 0 ; j < ( ssize_t ) length ; j ++ ) { PCDGetBits ( 8 ) ; r -> length = ( unsigned int ) ( sum & 0xff ) + 1 ; if ( r -> length > 16 ) { <S2SV_StartBug> buffer = ( unsigned char * ) RelinquishMagickMemory ( buffer ) ; <S2SV_EndBug> return ( MagickFalse ) ; } PCDGetBits ( 16 ) ; r -> sequence = ( unsigned int ) ( sum & 0xffff ) << 16 ; PCDGetBits ( 8 ) ; r -> key = ( unsigned char ) ( sum & 0xff ) ; r -> mask = ( ~ ( ( 1U << ( 32 - r -> length ) ) - 1 ) ) ; r ++ ; } pcd_length [ i ] = ( size_t ) length ; } for ( i = 0 ; i < 1 ; i ++ ) PCDGetBits ( 16 ) ; for ( i = 0 ; i < 1 ; i ++ ) PCDGetBits ( 16 ) ; while ( ( sum & 0x00fff000UL ) != 0x00fff000UL ) PCDGetBits ( 8 ) ; while ( IsSync ( sum ) == 0 ) PCDGetBits ( 1 ) ; count = 0 ; length = 0 ; plane = 0 ; row = 0 ; q = luma ; for ( ; ; ) { if ( IsSync ( sum ) != 0 ) { PCDGetBits ( 16 ) ; row = ( ( sum >> 9 ) & 0x1fff ) ; if ( row == image -> rows ) break ; PCDGetBits ( 8 ) ; plane = sum >> 30 ; PCDGetBits ( 16 ) ; switch ( plane ) { case 0 : { q = luma + row * image -> columns ; count = ( ssize_t ) image -> columns ; break ; } case 2 : { q = chroma1 + ( row >> 1 ) * image -> columns ; count = ( ssize_t ) ( image -> columns >> 1 ) ; plane -- ; break ; } case 3 : { q = chroma2 + ( row >> 1 ) * image -> columns ; count = ( ssize_t ) ( image -> columns >> 1 ) ; plane -- ; break ; } default : { for ( i = 0 ; i < ( image -> columns > 1536 ? 3 : 1 ) ; i ++ ) pcd_table [ i ] = ( PCDTable * ) RelinquishMagickMemory ( pcd_table [ i ] ) ; buffer = ( unsigned char * ) RelinquishMagickMemory ( buffer ) ; ThrowBinaryException ( CorruptImageError , "CorruptImage" , image -> filename ) ; } } length = pcd_length [ plane ] ; continue ; } r = pcd_table [ plane ] ; for ( i = 0 ; ( ( i < ( ssize_t ) length ) && ( ( sum & r -> mask ) != r -> sequence ) ) ; i ++ ) r ++ ; if ( ( row > image -> rows ) || ( r == ( PCDTable * ) NULL ) ) { ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , CorruptImageWarning , "SkipToSyncByte" , "`%s\'" , image -> filename ) ; while ( ( sum & 0x00fff000 ) != 0x00fff000 ) PCDGetBits ( 8 ) ; while ( IsSync ( sum ) == 0 ) PCDGetBits ( 1 ) ; continue ; } if ( r -> key < 128 ) quantum = ( ssize_t ) ( * q ) + r -> key ; else quantum = ( ssize_t ) ( * q ) + r -> key - 256 ; * q = ( unsigned char ) ( ( quantum < 0 ) ? 0 : ( quantum > 255 ) ? 255 : quantum ) ; q ++ ; PCDGetBits ( r -> length ) ; count -- ; } for ( i = 0 ; i < ( image -> columns > 1536 ? 3 : 1 ) ; i ++ ) pcd_table [ i ] = ( PCDTable * ) RelinquishMagickMemory ( pcd_table [ i ] ) ; buffer = ( unsigned char * ) RelinquishMagickMemory ( buffer ) ; return ( MagickTrue ) ; }
CWE-399 static Image * ReadPSImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define BoundingBox "BoundingBox:" # define BeginDocument "BeginDocument:" # define BeginXMPPacket "<?xpacket<S2SV_blank>begin=" # define EndXMPPacket "<?xpacket<S2SV_blank>end=" # define ICCProfile "BeginICCProfile:" # define CMYKCustomColor "CMYKCustomColor:" # define CMYKProcessColor "CMYKProcessColor:" # define DocumentMedia "DocumentMedia:" # define DocumentCustomColors "DocumentCustomColors:" # define DocumentProcessColors "DocumentProcessColors:" # define EndDocument "EndDocument:" # define HiResBoundingBox "HiResBoundingBox:" # define ImageData "ImageData:" # define PageBoundingBox "PageBoundingBox:" # define LanguageLevel "LanguageLevel:" # define PageMedia "PageMedia:" # define Pages "Pages:" # define PhotoshopProfile "BeginPhotoshop:" # define PostscriptLevel "!PS-" # define RenderPostscriptText "<S2SV_blank><S2SV_blank>Rendering<S2SV_blank>Postscript...<S2SV_blank><S2SV_blank>" # define SpotColor "+<S2SV_blank>" char command [ MagickPathExtent ] , * density , filename [ MagickPathExtent ] , geometry [ MagickPathExtent ] , input_filename [ MagickPathExtent ] , message [ MagickPathExtent ] , * options , postscript_filename [ MagickPathExtent ] ; const char * option ; const DelegateInfo * delegate_info ; GeometryInfo geometry_info ; Image * image , * next , * postscript_image ; ImageInfo * read_info ; int c , file ; MagickBooleanType cmyk , fitPage , skip , status ; MagickStatusType flags ; PointInfo delta , resolution ; RectangleInfo page ; register char * p ; register ssize_t i ; SegmentInfo bounds , hires_bounds ; short int hex_digits [ 256 ] ; size_t length ; ssize_t count , priority ; StringInfo * profile ; unsigned long columns , extent , language_level , pages , rows , scene , spotcolor ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } status = AcquireUniqueSymbolicLink ( image_info -> filename , input_filename ) ; if ( status == MagickFalse ) { ThrowFileException ( exception , FileOpenError , "UnableToCreateTemporaryFile" , image_info -> filename ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) memset ( hex_digits , 0 , sizeof ( hex_digits ) ) ; hex_digits [ ( int ) '0' ] = 0 ; hex_digits [ ( int ) '1' ] = 1 ; hex_digits [ ( int ) '2' ] = 2 ; hex_digits [ ( int ) '3' ] = 3 ; hex_digits [ ( int ) '4' ] = 4 ; hex_digits [ ( int ) '5' ] = 5 ; hex_digits [ ( int ) '6' ] = 6 ; hex_digits [ ( int ) '7' ] = 7 ; hex_digits [ ( int ) '8' ] = 8 ; hex_digits [ ( int ) '9' ] = 9 ; hex_digits [ ( int ) 'a' ] = 10 ; hex_digits [ ( int ) 'b' ] = 11 ; hex_digits [ ( int ) 'c' ] = 12 ; hex_digits [ ( int ) 'd' ] = 13 ; hex_digits [ ( int ) 'e' ] = 14 ; hex_digits [ ( int ) 'f' ] = 15 ; hex_digits [ ( int ) 'A' ] = 10 ; hex_digits [ ( int ) 'B' ] = 11 ; hex_digits [ ( int ) 'C' ] = 12 ; hex_digits [ ( int ) 'D' ] = 13 ; hex_digits [ ( int ) 'E' ] = 14 ; hex_digits [ ( int ) 'F' ] = 15 ; delta . x = DefaultResolution ; delta . y = DefaultResolution ; if ( ( image -> resolution . x == 0.0 ) || ( image -> resolution . y == 0.0 ) ) { flags = ParseGeometry ( PSDensityGeometry , & geometry_info ) ; image -> resolution . x = geometry_info . rho ; image -> resolution . y = geometry_info . sigma ; if ( ( flags & SigmaValue ) == 0 ) image -> resolution . y = image -> resolution . x ; } if ( image_info -> density != ( char * ) NULL ) { flags = ParseGeometry ( image_info -> density , & geometry_info ) ; image -> resolution . x = geometry_info . rho ; image -> resolution . y = geometry_info . sigma ; if ( ( flags & SigmaValue ) == 0 ) image -> resolution . y = image -> resolution . x ; } ( void ) ParseAbsoluteGeometry ( PSPageGeometry , & page ) ; if ( image_info -> page != ( char * ) NULL ) ( void ) ParseAbsoluteGeometry ( image_info -> page , & page ) ; resolution = image -> resolution ; page . width = ( size_t ) ceil ( ( double ) ( page . width * resolution . x / delta . x ) - 0.5 ) ; page . height = ( size_t ) ceil ( ( double ) ( page . height * resolution . y / delta . y ) - 0.5 ) ; ( void ) memset ( & bounds , 0 , sizeof ( bounds ) ) ; ( void ) memset ( command , 0 , sizeof ( command ) ) ; cmyk = image_info -> colorspace == CMYKColorspace ? MagickTrue : MagickFalse ; ( void ) memset ( & hires_bounds , 0 , sizeof ( hires_bounds ) ) ; columns = 0 ; rows = 0 ; priority = 0 ; rows = 0 ; extent = 0 ; spotcolor = 0 ; language_level = 1 ; pages = ( ~ 0UL ) ; skip = MagickFalse ; p = command ; for ( c = ReadBlobByte ( image ) ; c != EOF ; c = ReadBlobByte ( image ) ) { * p ++ = ( char ) c ; if ( ( strchr ( "\\n\\r%" , c ) == ( char * ) NULL ) && ( ( size_t ) ( p - command ) < ( MagickPathExtent - 1 ) ) ) continue ; * p = '\\0' ; p = command ; if ( LocaleNCompare ( BeginDocument , command , strlen ( BeginDocument ) ) == 0 ) skip = MagickTrue ; if ( LocaleNCompare ( EndDocument , command , strlen ( EndDocument ) ) == 0 ) skip = MagickFalse ; if ( skip != MagickFalse ) continue ; if ( LocaleNCompare ( PostscriptLevel , command , strlen ( PostscriptLevel ) ) == 0 ) { ( void ) SetImageProperty ( image , "ps:Level" , command + 4 , exception ) ; if ( GlobExpression ( command , "*EPSF-*" , MagickTrue ) != MagickFalse ) pages = 1 ; } if ( LocaleNCompare ( LanguageLevel , command , strlen ( LanguageLevel ) ) == 0 ) ( void ) sscanf ( command , LanguageLevel "<S2SV_blank>%lu" , & language_level ) ; if ( LocaleNCompare ( Pages , command , strlen ( Pages ) ) == 0 ) ( void ) sscanf ( command , Pages "<S2SV_blank>%lu" , & pages ) ; if ( LocaleNCompare ( ImageData , command , strlen ( ImageData ) ) == 0 ) ( void ) sscanf ( command , ImageData "<S2SV_blank>%lu<S2SV_blank>%lu" , & columns , & rows ) ; length = strlen ( DocumentProcessColors ) ; if ( LocaleNCompare ( DocumentProcessColors , command , length ) == 0 ) { if ( ( GlobExpression ( command , "*Cyan*" , MagickTrue ) != MagickFalse ) || ( GlobExpression ( command , "*Magenta*" , MagickTrue ) != MagickFalse ) || ( GlobExpression ( command , "*Yellow*" , MagickTrue ) != MagickFalse ) ) cmyk = MagickTrue ; } if ( LocaleNCompare ( CMYKCustomColor , command , strlen ( CMYKCustomColor ) ) == 0 ) cmyk = MagickTrue ; if ( LocaleNCompare ( CMYKProcessColor , command , strlen ( CMYKProcessColor ) ) == 0 ) cmyk = MagickTrue ; length = strlen ( DocumentCustomColors ) ; if ( ( LocaleNCompare ( DocumentCustomColors , command , length ) == 0 ) || ( LocaleNCompare ( CMYKCustomColor , command , strlen ( CMYKCustomColor ) ) == 0 ) || ( LocaleNCompare ( SpotColor , command , strlen ( SpotColor ) ) == 0 ) ) { char property [ MagickPathExtent ] , * value ; register char * q ; ( void ) FormatLocaleString ( property , MagickPathExtent , "ps:SpotColor-%.20g" , ( double ) ( spotcolor ++ ) ) ; for ( q = command ; * q != '\\0' ; q ++ ) if ( isspace ( ( int ) ( unsigned char ) * q ) != 0 ) break ; value = ConstantString ( q ) ; ( void ) SubstituteString ( & value , "(" , "" ) ; ( void ) SubstituteString ( & value , ")" , "" ) ; ( void ) StripString ( value ) ; if ( * value != '\\0' ) ( void ) SetImageProperty ( image , property , value , exception ) ; value = DestroyString ( value ) ; continue ; } if ( image_info -> page != ( char * ) NULL ) continue ; count = 0 ; i = 0 ; if ( LocaleNCompare ( BoundingBox , command , strlen ( BoundingBox ) ) == 0 ) { count = ( ssize_t ) sscanf ( command , BoundingBox "<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf" , & bounds . x1 , & bounds . y1 , & bounds . x2 , & bounds . y2 ) ; i = 2 ; } if ( LocaleNCompare ( DocumentMedia , command , strlen ( DocumentMedia ) ) == 0 ) { count = ( ssize_t ) sscanf ( command , DocumentMedia "<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf" , & bounds . x1 , & bounds . y1 , & bounds . x2 , & bounds . y2 ) ; i = 1 ; } if ( LocaleNCompare ( HiResBoundingBox , command , strlen ( HiResBoundingBox ) ) == 0 ) { count = ( ssize_t ) sscanf ( command , HiResBoundingBox "<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf" , & bounds . x1 , & bounds . y1 , & bounds . x2 , & bounds . y2 ) ; i = 3 ; } if ( LocaleNCompare ( PageBoundingBox , command , strlen ( PageBoundingBox ) ) == 0 ) { count = ( ssize_t ) sscanf ( command , PageBoundingBox "<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf" , & bounds . x1 , & bounds . y1 , & bounds . x2 , & bounds . y2 ) ; i = 1 ; } if ( LocaleNCompare ( PageMedia , command , strlen ( PageMedia ) ) == 0 ) { count = ( ssize_t ) sscanf ( command , PageMedia "<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf" , & bounds . x1 , & bounds . y1 , & bounds . x2 , & bounds . y2 ) ; i = 1 ; } if ( ( count != 4 ) || ( i < ( ssize_t ) priority ) ) continue ; if ( ( fabs ( bounds . x2 - bounds . x1 ) <= fabs ( hires_bounds . x2 - hires_bounds . x1 ) ) || ( fabs ( bounds . y2 - bounds . y1 ) <= fabs ( hires_bounds . y2 - hires_bounds . y1 ) ) ) if ( i == ( ssize_t ) priority ) continue ; hires_bounds = bounds ; priority = i ; } if ( ( fabs ( hires_bounds . x2 - hires_bounds . x1 ) >= MagickEpsilon ) && ( fabs ( hires_bounds . y2 - hires_bounds . y1 ) >= MagickEpsilon ) ) { ( void ) FormatLocaleString ( geometry , MagickPathExtent , "%gx%g%+.15g%+.15g" , hires_bounds . x2 - hires_bounds . x1 , hires_bounds . y2 - hires_bounds . y1 , hires_bounds . x1 , hires_bounds . y1 ) ; ( void ) SetImageProperty ( image , "ps:HiResBoundingBox" , geometry , exception ) ; page . width = ( size_t ) ceil ( ( double ) ( ( hires_bounds . x2 - hires_bounds . x1 ) * resolution . x / delta . x ) - 0.5 ) ; page . height = ( size_t ) ceil ( ( double ) ( ( hires_bounds . y2 - hires_bounds . y1 ) * resolution . y / delta . y ) - 0.5 ) ; } fitPage = MagickFalse ; option = GetImageOption ( image_info , "eps:fit-page" ) ; if ( option != ( char * ) NULL ) { char * page_geometry ; page_geometry = GetPageGeometry ( option ) ; flags = ParseMetaGeometry ( page_geometry , & page . x , & page . y , & page . width , & page . height ) ; if ( flags == NoValue ) { ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , OptionError , <S2SV_StartBug> "InvalidGeometry" , "`%s\'" , option ) ; <S2SV_EndBug> image = DestroyImage ( image ) ; return ( ( Image * ) NULL ) ; } page . width = ( size_t ) ceil ( ( double ) ( page . width * image -> resolution . x / delta . x ) - 0.5 ) ; page . height = ( size_t ) ceil ( ( double ) ( page . height * image -> resolution . y / delta . y ) - 0.5 ) ; page_geometry = DestroyString ( page_geometry ) ; fitPage = MagickTrue ; } if ( IssRGBCompatibleColorspace ( image_info -> colorspace ) != MagickFalse ) cmyk = MagickFalse ; file = AcquireUniqueFileResource ( postscript_filename ) ; if ( file == - 1 ) { ThrowFileException ( exception , FileOpenError , "UnableToOpenFile" , image_info -> filename ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) CopyMagickString ( command , "/setpagedevice<S2SV_blank>{pop}<S2SV_blank>bind<S2SV_blank>1<S2SV_blank>index<S2SV_blank>where<S2SV_blank>{" "dup<S2SV_blank>wcheck<S2SV_blank>{3<S2SV_blank>1<S2SV_blank>roll<S2SV_blank>put}<S2SV_blank>{pop<S2SV_blank>def}<S2SV_blank>ifelse}<S2SV_blank>{def}<S2SV_blank>ifelse\\n" "<</UseCIEColor<S2SV_blank>true>>setpagedevice\\n" , MagickPathExtent ) ; count = write ( file , command , ( unsigned int ) strlen ( command ) ) ; if ( image_info -> page == ( char * ) NULL ) { char translate_geometry [ MagickPathExtent ] ; ( void ) FormatLocaleString ( translate_geometry , MagickPathExtent , "%g<S2SV_blank>%g<S2SV_blank>translate\\n" , - bounds . x1 , - bounds . y1 ) ; count = write ( file , translate_geometry , ( unsigned int ) strlen ( translate_geometry ) ) ; } file = close ( file ) - 1 ; if ( image_info -> monochrome != MagickFalse ) delegate_info = GetDelegateInfo ( "ps:mono" , ( char * ) NULL , exception ) ; else if ( cmyk != MagickFalse ) delegate_info = GetDelegateInfo ( "ps:cmyk" , ( char * ) NULL , exception ) ; else delegate_info = GetDelegateInfo ( "ps:alpha" , ( char * ) NULL , exception ) ; if ( delegate_info == ( const DelegateInfo * ) NULL ) { ( void ) RelinquishUniqueFileResource ( postscript_filename ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } density = AcquireString ( "" ) ; options = AcquireString ( "" ) ; ( void ) FormatLocaleString ( density , MagickPathExtent , "%gx%g" , resolution . x , resolution . y ) ; ( void ) FormatLocaleString ( options , MagickPathExtent , "-g%.20gx%.20g<S2SV_blank>" , ( double ) page . width , ( double ) page . height ) ; read_info = CloneImageInfo ( image_info ) ; * read_info -> magick = '\\0' ; if ( read_info -> number_scenes != 0 ) { char pages [ MagickPathExtent ] ; ( void ) FormatLocaleString ( pages , MagickPathExtent , "-dFirstPage=%.20g<S2SV_blank>" "-dLastPage=%.20g<S2SV_blank>" , ( double ) read_info -> scene + 1 , ( double ) ( read_info -> scene + read_info -> number_scenes ) ) ; ( void ) ConcatenateMagickString ( options , pages , MagickPathExtent ) ; read_info -> number_scenes = 0 ; if ( read_info -> scenes != ( char * ) NULL ) * read_info -> scenes = '\\0' ; } if ( * image_info -> magick == 'E' ) { option = GetImageOption ( image_info , "eps:use-cropbox" ) ; if ( ( option == ( const char * ) NULL ) || ( IsStringTrue ( option ) != MagickFalse ) ) ( void ) ConcatenateMagickString ( options , "-dEPSCrop<S2SV_blank>" , MagickPathExtent ) ; if ( fitPage != MagickFalse ) ( void ) ConcatenateMagickString ( options , "-dEPSFitPage<S2SV_blank>" , MagickPathExtent ) ; } ( void ) CopyMagickString ( filename , read_info -> filename , MagickPathExtent ) ; ( void ) AcquireUniqueFilename ( filename ) ; ( void ) RelinquishUniqueFileResource ( filename ) ; ( void ) ConcatenateMagickString ( filename , "%d" , MagickPathExtent ) ; ( void ) FormatLocaleString ( command , MagickPathExtent , GetDelegateCommands ( delegate_info ) , read_info -> antialias != MagickFalse ? 4 : 1 , read_info -> antialias != MagickFalse ? 4 : 1 , density , options , filename , postscript_filename , input_filename ) ; options = DestroyString ( options ) ; density = DestroyString ( density ) ; * message = '\\0' ; status = InvokePostscriptDelegate ( read_info -> verbose , command , message , exception ) ; ( void ) InterpretImageFilename ( image_info , image , filename , 1 , read_info -> filename , exception ) ; if ( ( status == MagickFalse ) || ( IsPostscriptRendered ( read_info -> filename ) == MagickFalse ) ) { ( void ) ConcatenateMagickString ( command , "<S2SV_blank>-c<S2SV_blank>showpage" , MagickPathExtent ) ; status = InvokePostscriptDelegate ( read_info -> verbose , command , message , exception ) ; } ( void ) RelinquishUniqueFileResource ( postscript_filename ) ; ( void ) RelinquishUniqueFileResource ( input_filename ) ; postscript_image = ( Image * ) NULL ; if ( status == MagickFalse ) for ( i = 1 ; ; i ++ ) { ( void ) InterpretImageFilename ( image_info , image , filename , ( int ) i , read_info -> filename , exception ) ; if ( IsPostscriptRendered ( read_info -> filename ) == MagickFalse ) break ; ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; } else for ( i = 1 ; ; i ++ ) { ( void ) InterpretImageFilename ( image_info , image , filename , ( int ) i , read_info -> filename , exception ) ; if ( IsPostscriptRendered ( read_info -> filename ) == MagickFalse ) break ; read_info -> blob = NULL ; read_info -> length = 0 ; next = ReadImage ( read_info , exception ) ; ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; if ( next == ( Image * ) NULL ) break ; AppendImageToList ( & postscript_image , next ) ; } ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; read_info = DestroyImageInfo ( read_info ) ; if ( postscript_image == ( Image * ) NULL ) { if ( * message != '\\0' ) ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , DelegateError , "PostscriptDelegateFailed" , "`%s\'" , message ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } if ( LocaleCompare ( postscript_image -> magick , "BMP" ) == 0 ) { Image * cmyk_image ; cmyk_image = ConsolidateCMYKImages ( postscript_image , exception ) ; if ( cmyk_image != ( Image * ) NULL ) { postscript_image = DestroyImageList ( postscript_image ) ; postscript_image = cmyk_image ; } } ( void ) SeekBlob ( image , 0 , SEEK_SET ) ; for ( c = ReadBlobByte ( image ) ; c != EOF ; c = ReadBlobByte ( image ) ) { * p ++ = ( char ) c ; if ( ( strchr ( "\\n\\r%" , c ) == ( char * ) NULL ) && ( ( size_t ) ( p - command ) < ( MagickPathExtent - 1 ) ) ) continue ; * p = '\\0' ; p = command ; if ( LocaleNCompare ( BeginDocument , command , strlen ( BeginDocument ) ) == 0 ) skip = MagickTrue ; if ( LocaleNCompare ( EndDocument , command , strlen ( EndDocument ) ) == 0 ) skip = MagickFalse ; if ( skip != MagickFalse ) continue ; if ( LocaleNCompare ( ICCProfile , command , strlen ( ICCProfile ) ) == 0 ) { unsigned char * datum ; profile = AcquireStringInfo ( MagickPathExtent ) ; datum = GetStringInfoDatum ( profile ) ; for ( i = 0 ; ( c = ProfileInteger ( image , hex_digits ) ) != EOF ; i ++ ) { if ( i >= ( ssize_t ) GetStringInfoLength ( profile ) ) { SetStringInfoLength ( profile , ( size_t ) i << 1 ) ; datum = GetStringInfoDatum ( profile ) ; } datum [ i ] = ( unsigned char ) c ; } SetStringInfoLength ( profile , ( size_t ) i + 1 ) ; ( void ) SetImageProfile ( image , "icc" , profile , exception ) ; profile = DestroyStringInfo ( profile ) ; continue ; } if ( LocaleNCompare ( PhotoshopProfile , command , strlen ( PhotoshopProfile ) ) == 0 ) { unsigned char * q ; count = ( ssize_t ) sscanf ( command , PhotoshopProfile "<S2SV_blank>%lu" , & extent ) ; if ( count != 1 ) continue ; length = extent ; if ( ( MagickSizeType ) length > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , "InsufficientImageDataInFile" ) ; profile = BlobToStringInfo ( ( const void * ) NULL , length ) ; if ( profile != ( StringInfo * ) NULL ) { q = GetStringInfoDatum ( profile ) ; for ( i = 0 ; i < ( ssize_t ) length ; i ++ ) * q ++ = ( unsigned char ) ProfileInteger ( image , hex_digits ) ; ( void ) SetImageProfile ( image , "8bim" , profile , exception ) ; profile = DestroyStringInfo ( profile ) ; } continue ; } if ( LocaleNCompare ( BeginXMPPacket , command , strlen ( BeginXMPPacket ) ) == 0 ) { p = command ; profile = StringToStringInfo ( command ) ; for ( i = ( ssize_t ) GetStringInfoLength ( profile ) - 1 ; c != EOF ; i ++ ) { SetStringInfoLength ( profile , ( size_t ) ( i + 1 ) ) ; c = ReadBlobByte ( image ) ; GetStringInfoDatum ( profile ) [ i ] = ( unsigned char ) c ; * p ++ = ( char ) c ; if ( ( strchr ( "\\n\\r%" , c ) == ( char * ) NULL ) && ( ( size_t ) ( p - command ) < ( MagickPathExtent - 1 ) ) ) continue ; * p = '\\0' ; p = command ; if ( LocaleNCompare ( EndXMPPacket , command , strlen ( EndXMPPacket ) ) == 0 ) break ; } SetStringInfoLength ( profile , ( size_t ) i ) ; ( void ) SetImageProfile ( image , "xmp" , profile , exception ) ; profile = DestroyStringInfo ( profile ) ; continue ; } } ( void ) CloseBlob ( image ) ; if ( image_info -> number_scenes != 0 ) { Image * clone_image ; for ( i = 0 ; i < ( ssize_t ) image_info -> scene ; i ++ ) { clone_image = CloneImage ( postscript_image , 1 , 1 , MagickTrue , exception ) ; if ( clone_image != ( Image * ) NULL ) PrependImageToList ( & postscript_image , clone_image ) ; } } do { ( void ) CopyMagickString ( postscript_image -> filename , filename , MagickPathExtent ) ; ( void ) CopyMagickString ( postscript_image -> magick , image -> magick , MagickPathExtent ) ; if ( columns != 0 ) postscript_image -> magick_columns = columns ; if ( rows != 0 ) postscript_image -> magick_rows = rows ; postscript_image -> page = page ; ( void ) CloneImageProfiles ( postscript_image , image ) ; ( void ) CloneImageProperties ( postscript_image , image ) ; next = SyncNextImageInList ( postscript_image ) ; if ( next != ( Image * ) NULL ) postscript_image = next ; } while ( next != ( Image * ) NULL ) ; image = DestroyImageList ( image ) ; scene = 0 ; for ( next = GetFirstImageInList ( postscript_image ) ; next != ( Image * ) NULL ; ) { next -> scene = scene ++ ; next = GetNextImageInList ( next ) ; } return ( GetFirstImageInList ( postscript_image ) ) ; }
CWE-119 static MagickBooleanType EncodeImage ( const ImageInfo * image_info , Image * image , const size_t data_size , ExceptionInfo * exception ) { # define MaxCode ( number_bits ) ( ( one << ( number_bits ) ) - 1 ) # define MaxHashTable 5003 # define MaxGIFBits 12UL # define MaxGIFTable ( 1UL << MaxGIFBits ) <S2SV_StartBug> # define GIFOutputCode ( code ) { if ( bits > 0 ) datum |= ( size_t ) ( code ) << bits ; else datum = ( size_t ) ( code ) ; bits += number_bits ; while ( bits >= 8 ) { packet [ length ++ ] = ( unsigned char ) ( datum & 0xff ) ; if ( length >= 254 ) { ( void ) WriteBlobByte ( image , ( unsigned char ) length ) ; ( void ) WriteBlob ( image , length , packet ) ; length = 0 ; } datum >>= 8 ; bits -= 8 ; } if ( free_code > max_code ) { number_bits ++ ; if ( number_bits == MaxGIFBits ) max_code = MaxGIFTable ; else max_code = MaxCode ( number_bits ) ; } } <S2SV_EndBug> Quantum index ; short * hash_code , * hash_prefix , waiting_code ; size_t bits , clear_code , datum , end_of_information_code , free_code , length , max_code , next_pixel , number_bits , one , pass ; ssize_t displacement , offset , k , y ; unsigned char * packet , * hash_suffix ; assert ( image != ( Image * ) NULL ) ; one = 1 ; packet = ( unsigned char * ) AcquireQuantumMemory ( 256 , sizeof ( * packet ) ) ; hash_code = ( short * ) AcquireQuantumMemory ( MaxHashTable , sizeof ( * hash_code ) ) ; hash_prefix = ( short * ) AcquireQuantumMemory ( MaxHashTable , sizeof ( * hash_prefix ) ) ; hash_suffix = ( unsigned char * ) AcquireQuantumMemory ( MaxHashTable , sizeof ( * hash_suffix ) ) ; if ( ( packet == ( unsigned char * ) NULL ) || ( hash_code == ( short * ) NULL ) || ( hash_prefix == ( short * ) NULL ) || ( hash_suffix == ( unsigned char * ) NULL ) ) { if ( packet != ( unsigned char * ) NULL ) packet = ( unsigned char * ) RelinquishMagickMemory ( packet ) ; if ( hash_code != ( short * ) NULL ) hash_code = ( short * ) RelinquishMagickMemory ( hash_code ) ; if ( hash_prefix != ( short * ) NULL ) hash_prefix = ( short * ) RelinquishMagickMemory ( hash_prefix ) ; if ( hash_suffix != ( unsigned char * ) NULL ) hash_suffix = ( unsigned char * ) RelinquishMagickMemory ( hash_suffix ) ; return ( MagickFalse ) ; } ( void ) memset ( packet , 0 , 256 * sizeof ( * packet ) ) ; ( void ) memset ( hash_code , 0 , MaxHashTable * sizeof ( * hash_code ) ) ; ( void ) memset ( hash_prefix , 0 , MaxHashTable * sizeof ( * hash_prefix ) ) ; ( void ) memset ( hash_suffix , 0 , MaxHashTable * sizeof ( * hash_suffix ) ) ; number_bits = data_size ; max_code = MaxCode ( number_bits ) ; clear_code = ( ( short ) one << ( data_size - 1 ) ) ; end_of_information_code = clear_code + 1 ; free_code = clear_code + 2 ; length = 0 ; datum = 0 ; bits = 0 ; GIFOutputCode ( clear_code ) ; offset = 0 ; pass = 0 ; waiting_code = 0 ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { register const Quantum * magick_restrict p ; register ssize_t x ; p = GetVirtualPixels ( image , 0 , offset , image -> columns , 1 , exception ) ; if ( p == ( const Quantum * ) NULL ) break ; if ( y == 0 ) { waiting_code = ( short ) GetPixelIndex ( image , p ) ; p += GetPixelChannels ( image ) ; } for ( x = ( ssize_t ) ( y == 0 ? 1 : 0 ) ; x < ( ssize_t ) image -> columns ; x ++ ) { <S2SV_StartBug> index = ( Quantum ) ( ( size_t ) GetPixelIndex ( image , p ) & 0xff ) ; <S2SV_EndBug> p += GetPixelChannels ( image ) ; k = ( ssize_t ) ( ( ( size_t ) index << ( MaxGIFBits - 8 ) ) + waiting_code ) ; if ( k >= MaxHashTable ) k -= MaxHashTable ; <S2SV_StartBug> next_pixel = MagickFalse ; <S2SV_EndBug> displacement = 1 ; if ( hash_code [ k ] > 0 ) { if ( ( hash_prefix [ k ] == waiting_code ) && ( hash_suffix [ k ] == ( unsigned char ) index ) ) { waiting_code = hash_code [ k ] ; continue ; } if ( k != 0 ) displacement = MaxHashTable - k ; for ( ; ; ) { k -= displacement ; if ( k < 0 ) k += MaxHashTable ; if ( hash_code [ k ] == 0 ) break ; if ( ( hash_prefix [ k ] == waiting_code ) && ( hash_suffix [ k ] == ( unsigned char ) index ) ) { waiting_code = hash_code [ k ] ; next_pixel = MagickTrue ; break ; } } if ( next_pixel != MagickFalse ) continue ; } GIFOutputCode ( waiting_code ) ; if ( free_code < MaxGIFTable ) { hash_code [ k ] = ( short ) free_code ++ ; hash_prefix [ k ] = waiting_code ; hash_suffix [ k ] = ( unsigned char ) index ; } else { for ( k = 0 ; k < MaxHashTable ; k ++ ) hash_code [ k ] = 0 ; free_code = clear_code + 2 ; GIFOutputCode ( clear_code ) ; number_bits = data_size ; max_code = MaxCode ( number_bits ) ; } waiting_code = ( short ) index ; } if ( image_info -> interlace == NoInterlace ) offset ++ ; else switch ( pass ) { case 0 : default : { offset += 8 ; if ( offset >= ( ssize_t ) image -> rows ) { pass ++ ; offset = 4 ; } break ; } case 1 : { offset += 8 ; if ( offset >= ( ssize_t ) image -> rows ) { pass ++ ; offset = 2 ; } break ; } case 2 : { offset += 4 ; if ( offset >= ( ssize_t ) image -> rows ) { pass ++ ; offset = 1 ; } break ; } case 3 : { offset += 2 ; break ; } } } GIFOutputCode ( waiting_code ) ; GIFOutputCode ( end_of_information_code ) ; if ( bits > 0 ) { packet [ length ++ ] = ( unsigned char ) ( datum & 0xff ) ; if ( length >= 254 ) { ( void ) WriteBlobByte ( image , ( unsigned char ) length ) ; ( void ) WriteBlob ( image , length , packet ) ; length = 0 ; } } if ( length > 0 ) { ( void ) WriteBlobByte ( image , ( unsigned char ) length ) ; ( void ) WriteBlob ( image , length , packet ) ; } hash_suffix = ( unsigned char * ) RelinquishMagickMemory ( hash_suffix ) ; hash_prefix = ( short * ) RelinquishMagickMemory ( hash_prefix ) ; hash_code = ( short * ) RelinquishMagickMemory ( hash_code ) ; packet = ( unsigned char * ) RelinquishMagickMemory ( packet ) ; return ( MagickTrue ) ; }
CWE-399 static Image * ReadSIXELImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char * sixel_buffer ; Image * image ; MagickBooleanType status ; register char * p ; register ssize_t x ; register Quantum * q ; size_t length ; ssize_t i , j , y ; unsigned char * sixel_pixels , * sixel_palette ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } length = MagickPathExtent ; sixel_buffer = ( char * ) AcquireQuantumMemory ( ( size_t ) length + MagickPathExtent , sizeof ( * sixel_buffer ) ) ; p = sixel_buffer ; if ( sixel_buffer != ( char * ) NULL ) while ( ReadBlobString ( image , p ) != ( char * ) NULL ) { if ( ( * p == '#' ) && ( ( p == sixel_buffer ) || ( * ( p - 1 ) == '\\n' ) ) ) continue ; if ( ( * p == '}' ) && ( * ( p + 1 ) == ';' ) ) break ; p += strlen ( p ) ; if ( ( size_t ) ( p - sixel_buffer + MagickPathExtent + 1 ) < length ) continue ; length <<= 1 ; sixel_buffer = ( char * ) ResizeQuantumMemory ( sixel_buffer , length + MagickPathExtent + 1 , sizeof ( * sixel_buffer ) ) ; if ( sixel_buffer == ( char * ) NULL ) break ; p = sixel_buffer + strlen ( sixel_buffer ) ; } if ( sixel_buffer == ( char * ) NULL ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; sixel_buffer [ length ] = '\\0' ; if ( sixel_decode ( image , ( unsigned char * ) sixel_buffer , & sixel_pixels , & image -> columns , & image -> rows , & sixel_palette , & image -> colors , exception ) == MagickFalse ) { <S2SV_StartBug> sixel_buffer = ( char * ) RelinquishMagickMemory ( sixel_buffer ) ; <S2SV_EndBug> ThrowReaderException ( CorruptImageError , "CorruptImage" ) ; } sixel_buffer = ( char * ) RelinquishMagickMemory ( sixel_buffer ) ; image -> depth = 24 ; image -> storage_class = PseudoClass ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) { sixel_pixels = ( unsigned char * ) RelinquishMagickMemory ( sixel_pixels ) ; sixel_palette = ( unsigned char * ) RelinquishMagickMemory ( sixel_palette ) ; return ( DestroyImageList ( image ) ) ; } if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) { sixel_pixels = ( unsigned char * ) RelinquishMagickMemory ( sixel_pixels ) ; sixel_palette = ( unsigned char * ) RelinquishMagickMemory ( sixel_palette ) ; ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; } for ( i = 0 ; i < ( ssize_t ) image -> colors ; ++ i ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( sixel_palette [ i * 4 + 0 ] ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( sixel_palette [ i * 4 + 1 ] ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( sixel_palette [ i * 4 + 2 ] ) ; } j = 0 ; if ( image_info -> ping == MagickFalse ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { j = ( ssize_t ) sixel_pixels [ y * image -> columns + x ] ; SetPixelIndex ( image , j , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } if ( y < ( ssize_t ) image -> rows ) { sixel_pixels = ( unsigned char * ) RelinquishMagickMemory ( sixel_pixels ) ; sixel_palette = ( unsigned char * ) RelinquishMagickMemory ( sixel_palette ) ; ThrowReaderException ( CorruptImageError , "NotEnoughPixelData" ) ; } } sixel_pixels = ( unsigned char * ) RelinquishMagickMemory ( sixel_pixels ) ; sixel_palette = ( unsigned char * ) RelinquishMagickMemory ( sixel_palette ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
CWE-119 <S2SV_StartBug> static PixelChannels * * AcquirePixelThreadSet ( const Image * image ) <S2SV_EndBug> { PixelChannels * * pixels ; register ssize_t i ; size_t <S2SV_StartBug> number_threads ; <S2SV_EndBug> number_threads = ( size_t ) GetMagickResourceLimit ( ThreadResource ) ; pixels = ( PixelChannels * * ) AcquireQuantumMemory ( number_threads , sizeof ( * pixels ) ) ; if ( pixels == ( PixelChannels * * ) NULL ) return ( ( PixelChannels * * ) NULL ) ; ( void ) memset ( pixels , 0 , number_threads * sizeof ( * pixels ) ) ; <S2SV_StartBug> for ( i = 0 ; i < ( ssize_t ) number_threads ; i ++ ) <S2SV_EndBug> { register ssize_t j ; <S2SV_StartBug> pixels [ i ] = ( PixelChannels * ) AcquireQuantumMemory ( image -> columns , <S2SV_EndBug> sizeof ( * * pixels ) ) ; if ( pixels [ i ] == ( PixelChannels * ) NULL ) return ( DestroyPixelThreadSet ( pixels ) ) ; <S2SV_StartBug> for ( j = 0 ; j < ( ssize_t ) image -> columns ; j ++ ) <S2SV_EndBug> { register ssize_t k ; for ( k = 0 ; k < MaxPixelChannels ; k ++ ) pixels [ i ] [ j ] . channel [ k ] = 0.0 ; } } return ( pixels ) ; }
CWE-119 static int format8BIM ( Image * ifile , Image * ofile ) { char temp [ MagickPathExtent ] ; unsigned int foundOSType ; int ID , resCount , i , c ; ssize_t count ; unsigned char * PString , * str ; resCount = 0 ; foundOSType = 0 ; ( void ) foundOSType ; c = ReadBlobByte ( ifile ) ; while ( c != EOF ) { if ( c == '8' ) { unsigned char buffer [ 5 ] ; buffer [ 0 ] = ( unsigned char ) c ; for ( i = 1 ; i < 4 ; i ++ ) { c = ReadBlobByte ( ifile ) ; if ( c == EOF ) return ( - 1 ) ; buffer [ i ] = ( unsigned char ) c ; } buffer [ 4 ] = 0 ; if ( strcmp ( ( const char * ) buffer , "8BIM" ) == 0 ) foundOSType = 1 ; else continue ; } else { c = ReadBlobByte ( ifile ) ; continue ; } ID = ReadBlobMSBSignedShort ( ifile ) ; if ( ID < 0 ) return ( - 1 ) ; { unsigned char plen ; c = ReadBlobByte ( ifile ) ; if ( c == EOF ) return ( - 1 ) ; plen = ( unsigned char ) c ; PString = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ( plen + MagickPathExtent ) , sizeof ( * PString ) ) ; if ( PString == ( unsigned char * ) NULL ) return 0 ; for ( i = 0 ; i < plen ; i ++ ) { c = ReadBlobByte ( ifile ) ; if ( c == EOF ) { PString = ( unsigned char * ) RelinquishMagickMemory ( PString ) ; return - 1 ; } PString [ i ] = ( unsigned char ) c ; } PString [ plen ] = 0 ; if ( ( plen & 0x01 ) == 0 ) { c = ReadBlobByte ( ifile ) ; if ( c == EOF ) { PString = ( unsigned char * ) RelinquishMagickMemory ( PString ) ; return - 1 ; } } } count = ( ssize_t ) ReadBlobMSBSignedLong ( ifile ) ; if ( ( count < 0 ) || ( count > GetBlobSize ( ifile ) ) ) { PString = ( unsigned char * ) RelinquishMagickMemory ( PString ) ; return - 1 ; } <S2SV_StartBug> str = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) count , sizeof ( * str ) ) ; <S2SV_EndBug> if ( str == ( unsigned char * ) NULL ) { PString = ( unsigned char * ) RelinquishMagickMemory ( PString ) ; return 0 ; } for ( i = 0 ; i < ( ssize_t ) count ; i ++ ) { c = ReadBlobByte ( ifile ) ; if ( c == EOF ) { str = ( unsigned char * ) RelinquishMagickMemory ( str ) ; PString = ( unsigned char * ) RelinquishMagickMemory ( PString ) ; return - 1 ; } str [ i ] = ( unsigned char ) c ; } if ( ID != THUMBNAIL_ID ) { if ( strlen ( ( const char * ) PString ) > 0 ) ( void ) FormatLocaleString ( temp , MagickPathExtent , "8BIM#%d#%s=" , ID , PString ) ; else ( void ) FormatLocaleString ( temp , MagickPathExtent , "8BIM#%d=" , ID ) ; ( void ) WriteBlobString ( ofile , temp ) ; if ( ID == IPTC_ID ) { formatString ( ofile , "IPTC" , 4 ) ; formatIPTCfromBuffer ( ofile , ( char * ) str , ( ssize_t ) count ) ; } else formatString ( ofile , ( char * ) str , ( ssize_t ) count ) ; } str = ( unsigned char * ) RelinquishMagickMemory ( str ) ; PString = ( unsigned char * ) RelinquishMagickMemory ( PString ) ; resCount ++ ; c = ReadBlobByte ( ifile ) ; } return resCount ; }
CWE-20 static Image * ReadCUTImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { <S2SV_StartBug> # define ThrowCUTReaderException ( severity , tag ) { if ( palette != NULL ) palette = DestroyImage ( palette ) ; if ( clone_info != NULL ) clone_info = DestroyImageInfo ( clone_info ) ; ThrowReaderException ( severity , tag ) ; } <S2SV_EndBug> Image * image , * palette ; ImageInfo * clone_info ; MagickBooleanType status ; MagickOffsetType offset ; size_t EncodedByte ; unsigned char RunCount , RunValue , RunCountMasked ; CUTHeader Header ; CUTPalHeader PalHeader ; ssize_t depth ; ssize_t i , j ; ssize_t ldblk ; unsigned char * BImgBuff = NULL , * ptrB ; register Quantum * q ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } palette = NULL ; clone_info = NULL ; Header . Width = ReadBlobLSBShort ( image ) ; Header . Height = ReadBlobLSBShort ( image ) ; Header . Reserved = ReadBlobLSBShort ( image ) ; if ( Header . Width == 0 || Header . Height == 0 || Header . Reserved != 0 ) CUT_KO : ThrowCUTReaderException ( CorruptImageError , "ImproperImageHeader" ) ; EncodedByte = ReadBlobLSBShort ( image ) ; RunCount = ( unsigned char ) ReadBlobByte ( image ) ; RunCountMasked = RunCount & 0x7F ; ldblk = 0 ; while ( ( int ) RunCountMasked != 0 ) { i = 1 ; if ( ( int ) RunCount < 0x80 ) i = ( ssize_t ) RunCountMasked ; offset = SeekBlob ( image , TellBlob ( image ) + i , SEEK_SET ) ; if ( offset < 0 ) ThrowCUTReaderException ( CorruptImageError , "ImproperImageHeader" ) ; if ( EOFBlob ( image ) != MagickFalse ) goto CUT_KO ; EncodedByte -= i + 1 ; ldblk += ( ssize_t ) RunCountMasked ; RunCount = ( unsigned char ) ReadBlobByte ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) goto CUT_KO ; RunCountMasked = RunCount & 0x7F ; } if ( EncodedByte != 1 ) goto CUT_KO ; i = 0 ; if ( ldblk == ( int ) Header . Width ) i = 8 ; if ( 2 * ldblk == ( int ) Header . Width ) i = 4 ; if ( 8 * ldblk == ( int ) Header . Width ) i = 1 ; if ( i == 0 ) goto CUT_KO ; depth = i ; image -> columns = Header . Width ; image -> rows = Header . Height ; image -> depth = 8 ; image -> colors = ( size_t ) ( GetQuantumRange ( 1UL * i ) + 1 ) ; if ( image_info -> ping != MagickFalse ) goto Finish ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; if ( ( clone_info = CloneImageInfo ( image_info ) ) == NULL ) goto NoPalette ; i = ( ssize_t ) strlen ( clone_info -> filename ) ; j = i ; while ( -- i > 0 ) { if ( clone_info -> filename [ i ] == '.' ) { break ; } if ( clone_info -> filename [ i ] == '/' || clone_info -> filename [ i ] == '\\\\' || clone_info -> filename [ i ] == ':' ) { i = j ; break ; } } ( void ) CopyMagickString ( clone_info -> filename + i , ".PAL" , ( size_t ) ( MagickPathExtent - i ) ) ; if ( ( clone_info -> file = fopen_utf8 ( clone_info -> filename , "rb" ) ) == NULL ) { ( void ) CopyMagickString ( clone_info -> filename + i , ".pal" , ( size_t ) ( MagickPathExtent - i ) ) ; if ( ( clone_info -> file = fopen_utf8 ( clone_info -> filename , "rb" ) ) == NULL ) { clone_info -> filename [ i ] = '\\0' ; if ( ( clone_info -> file = fopen_utf8 ( clone_info -> filename , "rb" ) ) == NULL ) { clone_info = DestroyImageInfo ( clone_info ) ; clone_info = NULL ; goto NoPalette ; } } } if ( ( palette = AcquireImage ( clone_info , exception ) ) == NULL ) goto NoPalette ; status = OpenBlob ( clone_info , palette , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { ErasePalette : palette = DestroyImage ( palette ) ; palette = NULL ; goto NoPalette ; } if ( palette != NULL ) { ( void ) ReadBlob ( palette , 2 , ( unsigned char * ) PalHeader . FileId ) ; if ( strncmp ( PalHeader . FileId , "AH" , 2 ) != 0 ) goto ErasePalette ; PalHeader . Version = ReadBlobLSBShort ( palette ) ; PalHeader . Size = ReadBlobLSBShort ( palette ) ; PalHeader . FileType = ( char ) ReadBlobByte ( palette ) ; PalHeader . SubType = ( char ) ReadBlobByte ( palette ) ; PalHeader . BoardID = ReadBlobLSBShort ( palette ) ; PalHeader . GraphicsMode = ReadBlobLSBShort ( palette ) ; PalHeader . MaxIndex = ReadBlobLSBShort ( palette ) ; PalHeader . MaxRed = ReadBlobLSBShort ( palette ) ; PalHeader . MaxGreen = ReadBlobLSBShort ( palette ) ; PalHeader . MaxBlue = ReadBlobLSBShort ( palette ) ; ( void ) ReadBlob ( palette , 20 , ( unsigned char * ) PalHeader . PaletteId ) ; if ( EOFBlob ( image ) ) ThrowCUTReaderException ( CorruptImageError , "UnexpectedEndOfFile" ) ; if ( PalHeader . MaxIndex < 1 ) goto ErasePalette ; image -> colors = PalHeader . MaxIndex + 1 ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) goto NoMemory ; if ( PalHeader . MaxRed == 0 ) PalHeader . MaxRed = ( unsigned int ) QuantumRange ; if ( PalHeader . MaxGreen == 0 ) PalHeader . MaxGreen = ( unsigned int ) QuantumRange ; if ( PalHeader . MaxBlue == 0 ) PalHeader . MaxBlue = ( unsigned int ) QuantumRange ; for ( i = 0 ; i <= ( int ) PalHeader . MaxIndex ; i ++ ) { j = ( ssize_t ) TellBlob ( palette ) ; if ( ( j % 512 ) > 512 - 6 ) { j = ( ( j / 512 ) + 1 ) * 512 ; offset = SeekBlob ( palette , j , SEEK_SET ) ; if ( offset < 0 ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; } image -> colormap [ i ] . red = ( Quantum ) ReadBlobLSBShort ( palette ) ; if ( QuantumRange != ( Quantum ) PalHeader . MaxRed ) { image -> colormap [ i ] . red = ClampToQuantum ( ( ( double ) image -> colormap [ i ] . red * QuantumRange + ( PalHeader . MaxRed >> 1 ) ) / PalHeader . MaxRed ) ; } image -> colormap [ i ] . green = ( Quantum ) ReadBlobLSBShort ( palette ) ; if ( QuantumRange != ( Quantum ) PalHeader . MaxGreen ) { image -> colormap [ i ] . green = ClampToQuantum ( ( ( double ) image -> colormap [ i ] . green * QuantumRange + ( PalHeader . MaxGreen >> 1 ) ) / PalHeader . MaxGreen ) ; } image -> colormap [ i ] . blue = ( Quantum ) ReadBlobLSBShort ( palette ) ; if ( QuantumRange != ( Quantum ) PalHeader . MaxBlue ) { image -> colormap [ i ] . blue = ClampToQuantum ( ( ( double ) image -> colormap [ i ] . blue * QuantumRange + ( PalHeader . MaxBlue >> 1 ) ) / PalHeader . MaxBlue ) ; } } if ( EOFBlob ( image ) ) ThrowCUTReaderException ( CorruptImageError , "UnexpectedEndOfFile" ) ; } NoPalette : if ( palette == NULL ) { image -> colors = 256 ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) { NoMemory : ThrowCUTReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; } for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( unsigned char ) i ) ; } } BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ldblk , sizeof ( * BImgBuff ) ) ; if ( BImgBuff == NULL ) goto NoMemory ; <S2SV_StartBug> offset = SeekBlob ( image , 6 , SEEK_SET ) ; <S2SV_EndBug> if ( offset < 0 ) { if ( palette != NULL ) palette = DestroyImage ( palette ) ; if ( clone_info != NULL ) clone_info = DestroyImageInfo ( clone_info ) ; BImgBuff = ( unsigned char * ) RelinquishMagickMemory ( BImgBuff ) ; ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; } for ( i = 0 ; i < ( int ) Header . Height ; i ++ ) { EncodedByte = ReadBlobLSBShort ( image ) ; ptrB = BImgBuff ; j = ldblk ; RunCount = ( unsigned char ) ReadBlobByte ( image ) ; RunCountMasked = RunCount & 0x7F ; while ( ( int ) RunCountMasked != 0 ) { if ( ( ssize_t ) RunCountMasked > j ) { RunCountMasked = ( unsigned char ) j ; if ( j == 0 ) { break ; } } if ( ( int ) RunCount > 0x80 ) { RunValue = ( unsigned char ) ReadBlobByte ( image ) ; ( void ) memset ( ptrB , ( int ) RunValue , ( size_t ) RunCountMasked ) ; } else { ( void ) ReadBlob ( image , ( size_t ) RunCountMasked , ptrB ) ; } ptrB += ( int ) RunCountMasked ; j -= ( int ) RunCountMasked ; if ( EOFBlob ( image ) != MagickFalse ) goto Finish ; RunCount = ( unsigned char ) ReadBlobByte ( image ) ; RunCountMasked = RunCount & 0x7F ; } InsertRow ( image , depth , BImgBuff , i , exception ) ; } ( void ) SyncImage ( image , exception ) ; if ( palette == NULL ) { if ( ( image -> storage_class == PseudoClass ) && ( SetImageGray ( image , exception ) != MagickFalse ) ) { if ( GetCutColors ( image , exception ) == 2 ) { for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { register Quantum sample ; sample = ScaleCharToQuantum ( ( unsigned char ) i ) ; if ( image -> colormap [ i ] . red != sample ) goto Finish ; if ( image -> colormap [ i ] . green != sample ) goto Finish ; if ( image -> colormap [ i ] . blue != sample ) goto Finish ; } image -> colormap [ 1 ] . red = image -> colormap [ 1 ] . green = image -> colormap [ 1 ] . blue = QuantumRange ; for ( i = 0 ; i < ( ssize_t ) image -> rows ; i ++ ) { q = QueueAuthenticPixels ( image , 0 , i , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( j = 0 ; j < ( ssize_t ) image -> columns ; j ++ ) { if ( GetPixelRed ( image , q ) == ScaleCharToQuantum ( 1 ) ) { SetPixelRed ( image , QuantumRange , q ) ; SetPixelGreen ( image , QuantumRange , q ) ; SetPixelBlue ( image , QuantumRange , q ) ; } q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) goto Finish ; } } } } Finish : if ( BImgBuff != NULL ) BImgBuff = ( unsigned char * ) RelinquishMagickMemory ( BImgBuff ) ; if ( palette != NULL ) palette = DestroyImage ( palette ) ; if ( clone_info != NULL ) clone_info = DestroyImageInfo ( clone_info ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowFileException ( exception , CorruptImageError , "UnexpectedEndOfFile" , image -> filename ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
CWE-400 static Image * ReadCINImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define MonoColorType 1 # define RGBColorType 3 char property [ MagickPathExtent ] ; CINInfo cin ; const unsigned char * pixels ; Image * image ; MagickBooleanType status ; MagickOffsetType offset ; QuantumInfo * quantum_info ; QuantumType quantum_type ; register ssize_t i ; register Quantum * q ; size_t length ; ssize_t count , y ; unsigned char magick [ 4 ] ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } offset = 0 ; count = ReadBlob ( image , 4 , magick ) ; offset += count ; if ( ( count != 4 ) || ( ( LocaleNCompare ( ( char * ) magick , "\\200\\052\\137\\327" , 4 ) != 0 ) ) ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; memset ( & cin , 0 , sizeof ( cin ) ) ; image -> endian = ( magick [ 0 ] == 0x80 ) && ( magick [ 1 ] == 0x2a ) && ( magick [ 2 ] == 0x5f ) && ( magick [ 3 ] == 0xd7 ) ? MSBEndian : LSBEndian ; cin . file . image_offset = ReadBlobLong ( image ) ; offset += 4 ; cin . file . generic_length = ReadBlobLong ( image ) ; offset += 4 ; cin . file . industry_length = ReadBlobLong ( image ) ; offset += 4 ; cin . file . user_length = ReadBlobLong ( image ) ; offset += 4 ; cin . file . file_size = ReadBlobLong ( image ) ; offset += 4 ; offset += ReadBlob ( image , sizeof ( cin . file . version ) , ( unsigned char * ) cin . file . version ) ; ( void ) CopyMagickString ( property , cin . file . version , sizeof ( cin . file . version ) ) ; ( void ) SetImageProperty ( image , "dpx:file.version" , property , exception ) ; offset += ReadBlob ( image , sizeof ( cin . file . filename ) , ( unsigned char * ) cin . file . filename ) ; ( void ) CopyMagickString ( property , cin . file . filename , sizeof ( cin . file . filename ) ) ; ( void ) SetImageProperty ( image , "dpx:file.filename" , property , exception ) ; offset += ReadBlob ( image , sizeof ( cin . file . create_date ) , ( unsigned char * ) cin . file . create_date ) ; ( void ) CopyMagickString ( property , cin . file . create_date , sizeof ( cin . file . create_date ) ) ; ( void ) SetImageProperty ( image , "dpx:file.create_date" , property , exception ) ; offset += ReadBlob ( image , sizeof ( cin . file . create_time ) , ( unsigned char * ) cin . file . create_time ) ; ( void ) CopyMagickString ( property , cin . file . create_time , sizeof ( cin . file . create_time ) ) ; ( void ) SetImageProperty ( image , "dpx:file.create_time" , property , exception ) ; offset += ReadBlob ( image , sizeof ( cin . file . reserve ) , ( unsigned char * ) cin . file . reserve ) ; cin . image . orientation = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; if ( cin . image . orientation != ( unsigned char ) ( ~ 0 ) ) ( void ) FormatImageProperty ( image , "dpx:image.orientation" , "%d" , cin . image . orientation ) ; switch ( cin . image . orientation ) { default : case 0 : image -> orientation = TopLeftOrientation ; break ; case 1 : image -> orientation = TopRightOrientation ; break ; case 2 : image -> orientation = BottomLeftOrientation ; break ; case 3 : image -> orientation = BottomRightOrientation ; break ; case 4 : image -> orientation = LeftTopOrientation ; break ; case 5 : image -> orientation = RightTopOrientation ; break ; case 6 : image -> orientation = LeftBottomOrientation ; break ; case 7 : image -> orientation = RightBottomOrientation ; break ; } cin . image . number_channels = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; offset += ReadBlob ( image , sizeof ( cin . image . reserve1 ) , ( unsigned char * ) cin . image . reserve1 ) ; for ( i = 0 ; i < 8 ; i ++ ) { cin . image . channel [ i ] . designator [ 0 ] = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; cin . image . channel [ i ] . designator [ 1 ] = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; cin . image . channel [ i ] . bits_per_pixel = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; cin . image . channel [ i ] . reserve = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; cin . image . channel [ i ] . pixels_per_line = ReadBlobLong ( image ) ; offset += 4 ; cin . image . channel [ i ] . lines_per_image = ReadBlobLong ( image ) ; offset += 4 ; cin . image . channel [ i ] . min_data = ReadBlobFloat ( image ) ; offset += 4 ; cin . image . channel [ i ] . min_quantity = ReadBlobFloat ( image ) ; offset += 4 ; cin . image . channel [ i ] . max_data = ReadBlobFloat ( image ) ; offset += 4 ; cin . image . channel [ i ] . max_quantity = ReadBlobFloat ( image ) ; offset += 4 ; } cin . image . white_point [ 0 ] = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . image . white_point [ 0 ] ) != MagickFalse ) image -> chromaticity . white_point . x = cin . image . white_point [ 0 ] ; cin . image . white_point [ 1 ] = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . image . white_point [ 1 ] ) != MagickFalse ) image -> chromaticity . white_point . y = cin . image . white_point [ 1 ] ; cin . image . red_primary_chromaticity [ 0 ] = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . image . red_primary_chromaticity [ 0 ] ) != MagickFalse ) image -> chromaticity . red_primary . x = cin . image . red_primary_chromaticity [ 0 ] ; cin . image . red_primary_chromaticity [ 1 ] = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . image . red_primary_chromaticity [ 1 ] ) != MagickFalse ) image -> chromaticity . red_primary . y = cin . image . red_primary_chromaticity [ 1 ] ; cin . image . green_primary_chromaticity [ 0 ] = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . image . green_primary_chromaticity [ 0 ] ) != MagickFalse ) image -> chromaticity . red_primary . x = cin . image . green_primary_chromaticity [ 0 ] ; cin . image . green_primary_chromaticity [ 1 ] = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . image . green_primary_chromaticity [ 1 ] ) != MagickFalse ) image -> chromaticity . green_primary . y = cin . image . green_primary_chromaticity [ 1 ] ; cin . image . blue_primary_chromaticity [ 0 ] = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . image . blue_primary_chromaticity [ 0 ] ) != MagickFalse ) image -> chromaticity . blue_primary . x = cin . image . blue_primary_chromaticity [ 0 ] ; cin . image . blue_primary_chromaticity [ 1 ] = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . image . blue_primary_chromaticity [ 1 ] ) != MagickFalse ) image -> chromaticity . blue_primary . y = cin . image . blue_primary_chromaticity [ 1 ] ; offset += ReadBlob ( image , sizeof ( cin . image . label ) , ( unsigned char * ) cin . image . label ) ; ( void ) CopyMagickString ( property , cin . image . label , sizeof ( cin . image . label ) ) ; ( void ) SetImageProperty ( image , "dpx:image.label" , property , exception ) ; offset += ReadBlob ( image , sizeof ( cin . image . reserve ) , ( unsigned char * ) cin . image . reserve ) ; cin . data_format . interleave = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; cin . data_format . packing = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; cin . data_format . sign = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; cin . data_format . sense = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; cin . data_format . line_pad = ReadBlobLong ( image ) ; offset += 4 ; cin . data_format . channel_pad = ReadBlobLong ( image ) ; offset += 4 ; offset += ReadBlob ( image , sizeof ( cin . data_format . reserve ) , ( unsigned char * ) cin . data_format . reserve ) ; cin . origination . x_offset = ReadBlobSignedLong ( image ) ; offset += 4 ; if ( ( size_t ) cin . origination . x_offset != ~ 0UL ) ( void ) FormatImageProperty ( image , "dpx:origination.x_offset" , "%.20g" , ( double ) cin . origination . x_offset ) ; cin . origination . y_offset = ( ssize_t ) ReadBlobLong ( image ) ; offset += 4 ; if ( ( size_t ) cin . origination . y_offset != ~ 0UL ) ( void ) FormatImageProperty ( image , "dpx:origination.y_offset" , "%.20g" , ( double ) cin . origination . y_offset ) ; offset += ReadBlob ( image , sizeof ( cin . origination . filename ) , ( unsigned char * ) cin . origination . filename ) ; ( void ) CopyMagickString ( property , cin . origination . filename , sizeof ( cin . origination . filename ) ) ; ( void ) SetImageProperty ( image , "dpx:origination.filename" , property , exception ) ; offset += ReadBlob ( image , sizeof ( cin . origination . create_date ) , ( unsigned char * ) cin . origination . create_date ) ; ( void ) CopyMagickString ( property , cin . origination . create_date , sizeof ( cin . origination . create_date ) ) ; ( void ) SetImageProperty ( image , "dpx:origination.create_date" , property , exception ) ; offset += ReadBlob ( image , sizeof ( cin . origination . create_time ) , ( unsigned char * ) cin . origination . create_time ) ; ( void ) CopyMagickString ( property , cin . origination . create_time , sizeof ( cin . origination . create_time ) ) ; ( void ) SetImageProperty ( image , "dpx:origination.create_time" , property , exception ) ; offset += ReadBlob ( image , sizeof ( cin . origination . device ) , ( unsigned char * ) cin . origination . device ) ; ( void ) CopyMagickString ( property , cin . origination . device , sizeof ( cin . origination . device ) ) ; ( void ) SetImageProperty ( image , "dpx:origination.device" , property , exception ) ; offset += ReadBlob ( image , sizeof ( cin . origination . model ) , ( unsigned char * ) cin . origination . model ) ; ( void ) CopyMagickString ( property , cin . origination . model , sizeof ( cin . origination . model ) ) ; ( void ) SetImageProperty ( image , "dpx:origination.model" , property , exception ) ; ( void ) memset ( cin . origination . serial , 0 , sizeof ( cin . origination . serial ) ) ; offset += ReadBlob ( image , sizeof ( cin . origination . serial ) , ( unsigned char * ) cin . origination . serial ) ; ( void ) CopyMagickString ( property , cin . origination . serial , sizeof ( cin . origination . serial ) ) ; ( void ) SetImageProperty ( image , "dpx:origination.serial" , property , exception ) ; cin . origination . x_pitch = ReadBlobFloat ( image ) ; offset += 4 ; cin . origination . y_pitch = ReadBlobFloat ( image ) ; offset += 4 ; cin . origination . gamma = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . origination . gamma ) != MagickFalse ) image -> gamma = cin . origination . gamma ; offset += ReadBlob ( image , sizeof ( cin . origination . reserve ) , ( unsigned char * ) cin . origination . reserve ) ; if ( ( cin . file . image_offset > 2048 ) && ( cin . file . user_length != 0 ) ) { int c ; cin . film . id = ReadBlobByte ( image ) ; offset ++ ; c = cin . film . id ; if ( c != ~ 0 ) ( void ) FormatImageProperty ( image , "dpx:film.id" , "%d" , cin . film . id ) ; cin . film . type = ReadBlobByte ( image ) ; offset ++ ; c = cin . film . type ; if ( c != ~ 0 ) ( void ) FormatImageProperty ( image , "dpx:film.type" , "%d" , cin . film . type ) ; cin . film . offset = ReadBlobByte ( image ) ; offset ++ ; c = cin . film . offset ; if ( c != ~ 0 ) ( void ) FormatImageProperty ( image , "dpx:film.offset" , "%d" , cin . film . offset ) ; cin . film . reserve1 = ReadBlobByte ( image ) ; offset ++ ; cin . film . prefix = ReadBlobLong ( image ) ; offset += 4 ; if ( cin . film . prefix != ~ 0UL ) ( void ) FormatImageProperty ( image , "dpx:film.prefix" , "%.20g" , ( double ) cin . film . prefix ) ; cin . film . count = ReadBlobLong ( image ) ; offset += 4 ; offset += ReadBlob ( image , sizeof ( cin . film . format ) , ( unsigned char * ) cin . film . format ) ; ( void ) CopyMagickString ( property , cin . film . format , sizeof ( cin . film . format ) ) ; ( void ) SetImageProperty ( image , "dpx:film.format" , property , exception ) ; cin . film . frame_position = ReadBlobLong ( image ) ; offset += 4 ; if ( cin . film . frame_position != ~ 0UL ) ( void ) FormatImageProperty ( image , "dpx:film.frame_position" , "%.20g" , ( double ) cin . film . frame_position ) ; cin . film . frame_rate = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . film . frame_rate ) != MagickFalse ) ( void ) FormatImageProperty ( image , "dpx:film.frame_rate" , "%g" , cin . film . frame_rate ) ; offset += ReadBlob ( image , sizeof ( cin . film . frame_id ) , ( unsigned char * ) cin . film . frame_id ) ; ( void ) CopyMagickString ( property , cin . film . frame_id , sizeof ( cin . film . frame_id ) ) ; ( void ) SetImageProperty ( image , "dpx:film.frame_id" , property , exception ) ; offset += ReadBlob ( image , sizeof ( cin . film . slate_info ) , ( unsigned char * ) cin . film . slate_info ) ; ( void ) CopyMagickString ( property , cin . film . slate_info , sizeof ( cin . film . slate_info ) ) ; ( void ) SetImageProperty ( image , "dpx:film.slate_info" , property , exception ) ; offset += ReadBlob ( image , sizeof ( cin . film . reserve ) , ( unsigned char * ) cin . film . reserve ) ; } if ( ( cin . file . image_offset > 2048 ) && ( cin . file . user_length != 0 ) ) { StringInfo * profile ; if ( cin . file . user_length > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , "InsufficientImageDataInFile" ) ; profile = BlobToStringInfo ( ( const unsigned char * ) NULL , cin . file . user_length ) ; if ( profile == ( StringInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; offset += ReadBlob ( image , GetStringInfoLength ( profile ) , GetStringInfoDatum ( profile ) ) ; ( void ) SetImageProfile ( image , "dpx:user.data" , profile , exception ) ; profile = DestroyStringInfo ( profile ) ; } image -> depth = cin . image . channel [ 0 ] . bits_per_pixel ; image -> columns = cin . image . channel [ 0 ] . pixels_per_line ; image -> rows = cin . image . channel [ 0 ] . lines_per_image ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( image ) ; } <S2SV_StartBug> for ( ; offset < ( MagickOffsetType ) cin . file . image_offset ; offset ++ ) <S2SV_EndBug> { int c ; c = ReadBlobByte ( image ) ; if ( c == EOF ) break ; } if ( offset < ( MagickOffsetType ) cin . file . image_offset ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; ( void ) SetImageBackgroundColor ( image , exception ) ; quantum_info = AcquireQuantumInfo ( image_info , image ) ; if ( quantum_info == ( QuantumInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; quantum_info -> quantum = 32 ; quantum_info -> pack = MagickFalse ; quantum_type = RGBQuantum ; length = GetQuantumExtent ( image , quantum_info , quantum_type ) ; length = GetBytesPerRow ( image -> columns , 3 , image -> depth , MagickTrue ) ; if ( cin . image . number_channels == 1 ) { quantum_type = GrayQuantum ; length = GetBytesPerRow ( image -> columns , 1 , image -> depth , MagickTrue ) ; } for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; pixels = ( const unsigned char * ) ReadBlobStream ( image , length , GetQuantumPixels ( quantum_info ) , & count ) ; if ( ( size_t ) count != length ) break ; ( void ) ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , quantum_type , pixels , exception ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } SetQuantumImageType ( image , quantum_type ) ; quantum_info = DestroyQuantumInfo ( quantum_info ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowFileException ( exception , CorruptImageError , "UnexpectedEndOfFile" , image -> filename ) ; SetImageColorspace ( image , LogColorspace , exception ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
CWE-416 static Image * ReadMATImageV4 ( const ImageInfo * image_info , Image * image , ExceptionInfo * exception ) { typedef struct { unsigned char Type [ 4 ] ; unsigned int nRows ; unsigned int nCols ; unsigned int imagf ; unsigned int nameLen ; } MAT4_HDR ; long ldblk ; EndianType endian ; Image * rotated_image ; MagickBooleanType status ; MAT4_HDR HDR ; QuantumInfo * quantum_info ; QuantumFormatType format_type ; register ssize_t i ; ssize_t count , y ; unsigned char * pixels ; unsigned int depth ; quantum_info = ( QuantumInfo * ) NULL ; ( void ) SeekBlob ( image , 0 , SEEK_SET ) ; status = MagickTrue ; while ( EOFBlob ( image ) == MagickFalse ) { ldblk = ReadBlobLSBLong ( image ) ; <S2SV_StartBug> if ( ( ldblk > 9999 ) || ( ldblk < 0 ) ) <S2SV_EndBug> break ; HDR . Type [ 3 ] = ldblk % 10 ; ldblk /= 10 ; HDR . Type [ 2 ] = ldblk % 10 ; ldblk /= 10 ; HDR . Type [ 1 ] = ldblk % 10 ; ldblk /= 10 ; HDR . Type [ 0 ] = ldblk ; if ( HDR . Type [ 3 ] != 0 ) break ; if ( HDR . Type [ 2 ] != 0 ) break ; if ( HDR . Type [ 0 ] == 0 ) { HDR . nRows = ReadBlobLSBLong ( image ) ; HDR . nCols = ReadBlobLSBLong ( image ) ; HDR . imagf = ReadBlobLSBLong ( image ) ; HDR . nameLen = ReadBlobLSBLong ( image ) ; endian = LSBEndian ; } else { HDR . nRows = ReadBlobMSBLong ( image ) ; HDR . nCols = ReadBlobMSBLong ( image ) ; HDR . imagf = ReadBlobMSBLong ( image ) ; HDR . nameLen = ReadBlobMSBLong ( image ) ; endian = MSBEndian ; } if ( ( HDR . imagf != 0 ) && ( HDR . imagf != 1 ) ) break ; if ( HDR . nameLen > 0xFFFF ) return ( DestroyImageList ( image ) ) ; for ( i = 0 ; i < ( ssize_t ) HDR . nameLen ; i ++ ) { int byte ; byte = ReadBlobByte ( image ) ; if ( byte == EOF ) { ThrowFileException ( exception , CorruptImageError , "UnexpectedEndOfFile" , image -> filename ) ; break ; } } image -> columns = ( size_t ) HDR . nRows ; image -> rows = ( size_t ) HDR . nCols ; if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) return ( DestroyImageList ( image ) ) ; if ( image_info -> ping != MagickFalse ) { Swap ( image -> columns , image -> rows ) ; if ( HDR . imagf == 1 ) ldblk *= 2 ; SeekBlob ( image , HDR . nCols * ldblk , SEEK_CUR ) ; if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) return ( image -> previous == ( Image * ) NULL ? DestroyImageList ( image ) : image ) ; goto skip_reading_current ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; ( void ) SetImageBackgroundColor ( image , exception ) ; ( void ) SetImageColorspace ( image , GRAYColorspace , exception ) ; quantum_info = AcquireQuantumInfo ( image_info , image ) ; if ( quantum_info == ( QuantumInfo * ) NULL ) return ( DestroyImageList ( image ) ) ; switch ( HDR . Type [ 1 ] ) { case 0 : format_type = FloatingPointQuantumFormat ; depth = 64 ; break ; case 1 : format_type = FloatingPointQuantumFormat ; depth = 32 ; break ; case 2 : format_type = UnsignedQuantumFormat ; depth = 16 ; break ; case 3 : format_type = SignedQuantumFormat ; depth = 16 ; break ; case 4 : format_type = UnsignedQuantumFormat ; depth = 8 ; break ; default : format_type = UnsignedQuantumFormat ; depth = 8 ; break ; } image -> depth = depth ; if ( HDR . Type [ 0 ] != 0 ) SetQuantumEndian ( image , quantum_info , MSBEndian ) ; status = SetQuantumFormat ( image , quantum_info , format_type ) ; status = SetQuantumDepth ( image , quantum_info , depth ) ; status = SetQuantumEndian ( image , quantum_info , endian ) ; SetQuantumScale ( quantum_info , 1.0 ) ; pixels = ( unsigned char * ) GetQuantumPixels ( quantum_info ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { register Quantum * magick_restrict q ; count = ReadBlob ( image , depth / 8 * image -> columns , ( char * ) pixels ) ; if ( count == - 1 ) break ; q = QueueAuthenticPixels ( image , 0 , image -> rows - y - 1 , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; ( void ) ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , GrayQuantum , pixels , exception ) ; if ( ( HDR . Type [ 1 ] == 2 ) || ( HDR . Type [ 1 ] == 3 ) ) FixSignedValues ( image , q , ( int ) image -> columns ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } if ( HDR . imagf == 1 ) for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { count = ReadBlob ( image , depth / 8 * image -> columns , ( char * ) pixels ) ; if ( count == - 1 ) break ; if ( HDR . Type [ 1 ] == 0 ) InsertComplexDoubleRow ( image , ( double * ) pixels , y , 0 , 0 , exception ) ; else InsertComplexFloatRow ( image , ( float * ) pixels , y , 0 , 0 , exception ) ; } if ( quantum_info != ( QuantumInfo * ) NULL ) quantum_info = DestroyQuantumInfo ( quantum_info ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , "UnexpectedEndOfFile" , image -> filename ) ; break ; } rotated_image = RotateImage ( image , 90.0 , exception ) ; if ( rotated_image != ( Image * ) NULL ) { rotated_image -> page . x = 0 ; rotated_image -> page . y = 0 ; rotated_image -> colors = image -> colors ; DestroyBlob ( rotated_image ) ; rotated_image -> blob = ReferenceBlob ( image -> blob ) ; AppendImageToList ( & image , rotated_image ) ; DeleteImageFromList ( & image ) ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; skip_reading_current : AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { status = MagickFalse ; break ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } ( void ) CloseBlob ( image ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; return ( GetFirstImageInList ( image ) ) ; }
CWE-416 static Image * ReadMATImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image , * image2 = NULL , * rotated_image ; register Quantum * q ; unsigned int status ; MATHeader MATLAB_HDR ; size_t size ; size_t CellType ; QuantumInfo * quantum_info ; ImageInfo * clone_info ; int i ; ssize_t ldblk ; unsigned char * BImgBuff = NULL ; double MinVal , MaxVal ; unsigned z , z2 ; unsigned Frames ; int logging ; int sample_size ; MagickOffsetType filepos = 0x80 ; unsigned int ( * ReadBlobXXXLong ) ( Image * image ) ; unsigned short ( * ReadBlobXXXShort ) ( Image * image ) ; void ( * ReadBlobDoublesXXX ) ( Image * image , size_t len , double * data ) ; void ( * ReadBlobFloatsXXX ) ( Image * image , size_t len , float * data ) ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; logging = LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "enter" ) ; image = AcquireImage ( image_info , exception ) ; image2 = ( Image * ) NULL ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } quantum_info = ( QuantumInfo * ) NULL ; clone_info = ( ImageInfo * ) NULL ; if ( ReadBlob ( image , 124 , ( unsigned char * ) & MATLAB_HDR . identific ) != 124 ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; if ( strncmp ( MATLAB_HDR . identific , "MATLAB" , 6 ) != 0 ) { image = ReadMATImageV4 ( image_info , image , exception ) ; if ( image == NULL ) { if ( ( image != image2 ) && ( image2 != ( Image * ) NULL ) ) image2 = DestroyImage ( image2 ) ; if ( clone_info != ( ImageInfo * ) NULL ) clone_info = DestroyImageInfo ( clone_info ) ; return ( ( Image * ) NULL ) ; } goto END_OF_READING ; } MATLAB_HDR . Version = ReadBlobLSBShort ( image ) ; if ( ReadBlob ( image , 2 , ( unsigned char * ) & MATLAB_HDR . EndianIndicator ) != 2 ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "<S2SV_blank><S2SV_blank>Endian<S2SV_blank>%c%c" , MATLAB_HDR . EndianIndicator [ 0 ] , MATLAB_HDR . EndianIndicator [ 1 ] ) ; if ( ! strncmp ( MATLAB_HDR . EndianIndicator , "IM" , 2 ) ) { ReadBlobXXXLong = ReadBlobLSBLong ; ReadBlobXXXShort = ReadBlobLSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesLSB ; ReadBlobFloatsXXX = ReadBlobFloatsLSB ; image -> endian = LSBEndian ; } else if ( ! strncmp ( MATLAB_HDR . EndianIndicator , "MI" , 2 ) ) { ReadBlobXXXLong = ReadBlobMSBLong ; ReadBlobXXXShort = ReadBlobMSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesMSB ; ReadBlobFloatsXXX = ReadBlobFloatsMSB ; image -> endian = MSBEndian ; } else { MATLAB_KO : if ( ( image != image2 ) && ( image2 != ( Image * ) NULL ) ) image2 = DestroyImage ( image2 ) ; if ( clone_info != ( ImageInfo * ) NULL ) clone_info = DestroyImageInfo ( clone_info ) ; ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; } filepos = TellBlob ( image ) ; <S2SV_StartBug> while ( ! EOFBlob ( image ) ) <S2SV_EndBug> { Frames = 1 ; <S2SV_StartBug> if ( filepos != ( unsigned int ) filepos ) <S2SV_EndBug> break ; if ( SeekBlob ( image , filepos , SEEK_SET ) != filepos ) break ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; MATLAB_HDR . ObjectSize = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; <S2SV_StartBug> if ( ( MagickSizeType ) ( MATLAB_HDR . ObjectSize + filepos ) > GetBlobSize ( image ) ) <S2SV_EndBug> goto MATLAB_KO ; filepos += ( MagickOffsetType ) MATLAB_HDR . ObjectSize + 4 + 4 ; if ( clone_info != ( ImageInfo * ) NULL ) clone_info = DestroyImageInfo ( clone_info ) ; clone_info = CloneImageInfo ( image_info ) ; if ( ( image != image2 ) && ( image2 != ( Image * ) NULL ) ) image2 = DestroyImage ( image2 ) ; image2 = image ; # if defined ( MAGICKCORE_ZLIB_DELEGATE ) if ( MATLAB_HDR . DataType == miCOMPRESSED ) { image2 = decompress_block ( image , & MATLAB_HDR . ObjectSize , clone_info , exception ) ; if ( image2 == NULL ) continue ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image2 ) ; } # endif if ( MATLAB_HDR . DataType != miMATRIX ) { clone_info = DestroyImageInfo ( clone_info ) ; # if defined ( MAGICKCORE_ZLIB_DELEGATE ) if ( image2 != image ) DeleteImageFromList ( & image2 ) ; # endif continue ; } MATLAB_HDR . unknown1 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown2 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown5 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . StructureClass = MATLAB_HDR . unknown5 & 0xFF ; MATLAB_HDR . StructureFlag = ( MATLAB_HDR . unknown5 >> 8 ) & 0xFF ; MATLAB_HDR . unknown3 = ReadBlobXXXLong ( image2 ) ; if ( image != image2 ) MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . DimFlag = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeX = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeY = ReadBlobXXXLong ( image2 ) ; switch ( MATLAB_HDR . DimFlag ) { case 8 : z2 = z = 1 ; break ; case 12 : z2 = z = ReadBlobXXXLong ( image2 ) ; ( void ) ReadBlobXXXLong ( image2 ) ; if ( z != 3 ) { if ( clone_info != ( ImageInfo * ) NULL ) clone_info = DestroyImageInfo ( clone_info ) ; if ( ( image != image2 ) && ( image2 != ( Image * ) NULL ) ) image2 = DestroyImage ( image2 ) ; ThrowReaderException ( CoderError , "MultidimensionalMatricesAreNotSupported" ) ; } break ; case 16 : z2 = z = ReadBlobXXXLong ( image2 ) ; if ( z != 3 && z != 1 ) { if ( clone_info != ( ImageInfo * ) NULL ) clone_info = DestroyImageInfo ( clone_info ) ; if ( ( image != image2 ) && ( image2 != ( Image * ) NULL ) ) image2 = DestroyImage ( image2 ) ; ThrowReaderException ( CoderError , "MultidimensionalMatricesAreNotSupported" ) ; } Frames = ReadBlobXXXLong ( image2 ) ; if ( Frames == 0 ) { if ( clone_info != ( ImageInfo * ) NULL ) clone_info = DestroyImageInfo ( clone_info ) ; if ( ( image != image2 ) && ( image2 != ( Image * ) NULL ) ) image2 = DestroyImage ( image2 ) ; ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; } if ( AcquireMagickResource ( ListLengthResource , Frames ) == MagickFalse ) { if ( clone_info != ( ImageInfo * ) NULL ) clone_info = DestroyImageInfo ( clone_info ) ; if ( ( image != image2 ) && ( image2 != ( Image * ) NULL ) ) image2 = DestroyImage ( image2 ) ; ThrowReaderException ( ResourceLimitError , "ListLengthExceedsLimit" ) ; } break ; default : if ( clone_info != ( ImageInfo * ) NULL ) clone_info = DestroyImageInfo ( clone_info ) ; if ( ( image != image2 ) && ( image2 != ( Image * ) NULL ) ) image2 = DestroyImage ( image2 ) ; ThrowReaderException ( CoderError , "MultidimensionalMatricesAreNotSupported" ) ; } MATLAB_HDR . Flag1 = ReadBlobXXXShort ( image2 ) ; MATLAB_HDR . NameFlag = ReadBlobXXXShort ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "MATLAB_HDR.StructureClass<S2SV_blank>%d" , MATLAB_HDR . StructureClass ) ; if ( MATLAB_HDR . StructureClass != mxCHAR_CLASS && MATLAB_HDR . StructureClass != mxSINGLE_CLASS && MATLAB_HDR . StructureClass != mxDOUBLE_CLASS && MATLAB_HDR . StructureClass != mxINT8_CLASS && MATLAB_HDR . StructureClass != mxUINT8_CLASS && MATLAB_HDR . StructureClass != mxINT16_CLASS && MATLAB_HDR . StructureClass != mxUINT16_CLASS && MATLAB_HDR . StructureClass != mxINT32_CLASS && MATLAB_HDR . StructureClass != mxUINT32_CLASS && MATLAB_HDR . StructureClass != mxINT64_CLASS && MATLAB_HDR . StructureClass != mxUINT64_CLASS ) { if ( ( image2 != ( Image * ) NULL ) && ( image2 != image ) ) { CloseBlob ( image2 ) ; DeleteImageFromList ( & image2 ) ; } if ( clone_info != ( ImageInfo * ) NULL ) clone_info = DestroyImageInfo ( clone_info ) ; ThrowReaderException ( CoderError , "UnsupportedCellTypeInTheMatrix" ) ; } switch ( MATLAB_HDR . NameFlag ) { case 0 : size = ReadBlobXXXLong ( image2 ) ; size = 4 * ( ( ( size_t ) size + 3 + 1 ) / 4 ) ; ( void ) SeekBlob ( image2 , size , SEEK_CUR ) ; break ; case 1 : case 2 : case 3 : case 4 : ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; break ; default : goto MATLAB_KO ; } CellType = ReadBlobXXXLong ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "MATLAB_HDR.CellType:<S2SV_blank>%.20g" , ( double ) CellType ) ; if ( ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) != 4 ) goto MATLAB_KO ; NEXT_FRAME : switch ( CellType ) { case miINT8 : case miUINT8 : sample_size = 8 ; if ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) image -> depth = 1 ; else image -> depth = 8 ; ldblk = ( ssize_t ) MATLAB_HDR . SizeX ; break ; case miINT16 : case miUINT16 : sample_size = 16 ; image -> depth = 16 ; ldblk = ( ssize_t ) ( 2 * MATLAB_HDR . SizeX ) ; break ; case miINT32 : case miUINT32 : sample_size = 32 ; image -> depth = 32 ; ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miINT64 : case miUINT64 : sample_size = 64 ; image -> depth = 64 ; ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; case miSINGLE : sample_size = 32 ; image -> depth = 32 ; ( void ) SetImageOption ( clone_info , "quantum:format" , "floating-point" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miDOUBLE : sample_size = 64 ; image -> depth = 64 ; ( void ) SetImageOption ( clone_info , "quantum:format" , "floating-point" ) ; DisableMSCWarning ( 4127 ) if ( sizeof ( double ) != 8 ) RestoreMSCWarning { if ( clone_info != ( ImageInfo * ) NULL ) clone_info = DestroyImageInfo ( clone_info ) ; if ( ( image != image2 ) && ( image2 != ( Image * ) NULL ) ) image2 = DestroyImage ( image2 ) ; ThrowReaderException ( CoderError , "IncompatibleSizeOfDouble" ) ; } if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; default : if ( ( image != image2 ) && ( image2 != ( Image * ) NULL ) ) image2 = DestroyImage ( image2 ) ; if ( clone_info ) clone_info = DestroyImageInfo ( clone_info ) ; ThrowReaderException ( CoderError , "UnsupportedCellTypeInTheMatrix" ) ; } ( void ) sample_size ; image -> columns = MATLAB_HDR . SizeX ; image -> rows = MATLAB_HDR . SizeY ; image -> colors = GetQuantumRange ( image -> depth ) ; if ( image -> columns == 0 || image -> rows == 0 ) goto MATLAB_KO ; if ( ( unsigned int ) ldblk * MATLAB_HDR . SizeY > MATLAB_HDR . ObjectSize ) goto MATLAB_KO ; if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) { image -> type = GrayscaleType ; SetImageColorspace ( image , GRAYColorspace , exception ) ; } if ( image_info -> ping ) { size_t temp = image -> columns ; image -> columns = image -> rows ; image -> rows = temp ; goto done_reading ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) { if ( clone_info != ( ImageInfo * ) NULL ) clone_info = DestroyImageInfo ( clone_info ) ; if ( ( image != image2 ) && ( image2 != ( Image * ) NULL ) ) image2 = DestroyImage ( image2 ) ; return ( DestroyImageList ( image ) ) ; } ( void ) SetImageBackgroundColor ( image , exception ) ; quantum_info = AcquireQuantumInfo ( clone_info , image ) ; if ( quantum_info == ( QuantumInfo * ) NULL ) { if ( clone_info != ( ImageInfo * ) NULL ) clone_info = DestroyImageInfo ( clone_info ) ; if ( ( image != image2 ) && ( image2 != ( Image * ) NULL ) ) image2 = DestroyImage ( image2 ) ; ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; } BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ( ldblk ) , sizeof ( double ) ) ; if ( BImgBuff == NULL ) { if ( clone_info != ( ImageInfo * ) NULL ) clone_info = DestroyImageInfo ( clone_info ) ; if ( ( image != image2 ) && ( image2 != ( Image * ) NULL ) ) image2 = DestroyImage ( image2 ) ; if ( quantum_info != ( QuantumInfo * ) NULL ) quantum_info = DestroyQuantumInfo ( quantum_info ) ; ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; } ( void ) memset ( BImgBuff , 0 , ldblk * sizeof ( double ) ) ; MinVal = 0 ; MaxVal = 0 ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & quantum_info -> minimum , & quantum_info -> maximum ) ; } if ( z == 1 ) z = 0 ; do { for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { q = GetAuthenticPixels ( image , 0 , MATLAB_HDR . SizeY - i - 1 , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "<S2SV_blank><S2SV_blank>MAT<S2SV_blank>set<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>returns<S2SV_blank>unexpected<S2SV_blank>NULL<S2SV_blank>on<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u." , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto done_reading ; } if ( ReadBlob ( image2 , ldblk , ( unsigned char * ) BImgBuff ) != ( ssize_t ) ldblk ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , <S2SV_StartBug> "<S2SV_blank><S2SV_blank>MAT<S2SV_blank>cannot<S2SV_blank>read<S2SV_blank>scanrow<S2SV_blank>%u<S2SV_blank>from<S2SV_blank>a<S2SV_blank>file." , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; <S2SV_EndBug> goto ExitLoop ; } if ( ( CellType == miINT8 || CellType == miUINT8 ) && ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) ) { FixLogical ( ( unsigned char * ) BImgBuff , ldblk ) ; if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) { ImportQuantumPixelsFailed : if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>ImportQuantumPixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; break ; } } else { if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) goto ImportQuantumPixelsFailed ; if ( z <= 1 && ( CellType == miINT8 || CellType == miINT16 || CellType == miINT32 || CellType == miINT64 ) ) FixSignedValues ( image , q , MATLAB_HDR . SizeX ) ; } if ( ! SyncAuthenticPixels ( image , exception ) ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>sync<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } } } while ( z -- >= 2 ) ; ExitLoop : if ( i != ( long ) MATLAB_HDR . SizeY ) goto END_OF_READING ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { CellType = ReadBlobXXXLong ( image2 ) ; i = ReadBlobXXXLong ( image2 ) ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & MinVal , & MaxVal ) ; } if ( CellType == miDOUBLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobDoublesXXX ( image2 , ldblk , ( double * ) BImgBuff ) ; if ( EOFBlob ( image ) != MagickFalse ) break ; InsertComplexDoubleRow ( image , ( double * ) BImgBuff , i , MinVal , MaxVal , exception ) ; } if ( CellType == miSINGLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobFloatsXXX ( image2 , ldblk , ( float * ) BImgBuff ) ; if ( EOFBlob ( image ) != MagickFalse ) break ; InsertComplexFloatRow ( image , ( float * ) BImgBuff , i , MinVal , MaxVal , exception ) ; } } if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) image -> type = GrayscaleType ; if ( image -> depth == 1 ) image -> type = BilevelType ; if ( image2 == image ) image2 = NULL ; rotated_image = RotateImage ( image , 90.0 , exception ) ; if ( rotated_image != ( Image * ) NULL ) { rotated_image -> page . x = 0 ; rotated_image -> page . y = 0 ; rotated_image -> colors = image -> colors ; DestroyBlob ( rotated_image ) ; rotated_image -> blob = ReferenceBlob ( image -> blob ) ; AppendImageToList ( & image , rotated_image ) ; DeleteImageFromList ( & image ) ; } done_reading : if ( image2 != NULL ) if ( image2 != image ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } } } if ( EOFBlob ( image ) != MagickFalse ) break ; AcquireNextImage ( image_info , image , exception ) ; if ( image -> next == ( Image * ) NULL ) break ; image = SyncNextImageInList ( image ) ; image -> columns = image -> rows = 0 ; image -> colors = 0 ; RelinquishMagickMemory ( BImgBuff ) ; BImgBuff = NULL ; if ( quantum_info != ( QuantumInfo * ) NULL ) quantum_info = DestroyQuantumInfo ( quantum_info ) ; if ( -- Frames > 0 ) { z = z2 ; if ( image2 == NULL ) image2 = image ; if ( ! EOFBlob ( image ) && TellBlob ( image ) < filepos ) goto NEXT_FRAME ; } if ( ( image2 != NULL ) && ( image2 != image ) ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } } } if ( clone_info ) clone_info = DestroyImageInfo ( clone_info ) ; } END_OF_READING : RelinquishMagickMemory ( BImgBuff ) ; if ( quantum_info != ( QuantumInfo * ) NULL ) quantum_info = DestroyQuantumInfo ( quantum_info ) ; CloseBlob ( image ) ; { Image * p ; ssize_t scene = 0 ; p = image ; image = NULL ; while ( p != ( Image * ) NULL ) { Image * tmp = p ; if ( ( p -> rows == 0 ) || ( p -> columns == 0 ) ) { p = p -> previous ; if ( tmp == image2 ) image2 = ( Image * ) NULL ; DeleteImageFromList ( & tmp ) ; } else { image = p ; p = p -> previous ; } } for ( p = image ; p != ( Image * ) NULL ; p = p -> next ) p -> scene = scene ++ ; } if ( clone_info != NULL ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } DestroyImageInfo ( clone_info ) ; clone_info = NULL ; } if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "return" ) ; if ( ( image != image2 ) && ( image2 != ( Image * ) NULL ) ) image2 = DestroyImage ( image2 ) ; if ( image == ( Image * ) NULL ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) return ( image ) ; }
CWE-399 static Image * ReadBMPImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { BMPInfo bmp_info ; Image * image ; MagickBooleanType status ; MagickOffsetType offset , profile_data , profile_size , start_position ; MemoryInfo * pixel_info ; Quantum index ; register Quantum * q ; register ssize_t i , x ; register unsigned char * p ; size_t bit , bytes_per_line , length ; ssize_t count , y ; unsigned char magick [ 12 ] , * pixels ; unsigned int blue , green , offset_bits , red ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) memset ( & bmp_info , 0 , sizeof ( bmp_info ) ) ; bmp_info . ba_offset = 0 ; start_position = 0 ; offset_bits = 0 ; count = ReadBlob ( image , 2 , magick ) ; if ( count != 2 ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; do { PixelInfo quantum_bits ; PixelPacket shift ; start_position = TellBlob ( image ) - 2 ; bmp_info . ba_offset = 0 ; while ( LocaleNCompare ( ( char * ) magick , "BA" , 2 ) == 0 ) { bmp_info . file_size = ReadBlobLSBLong ( image ) ; bmp_info . ba_offset = ReadBlobLSBLong ( image ) ; bmp_info . offset_bits = ReadBlobLSBLong ( image ) ; count = ReadBlob ( image , 2 , magick ) ; if ( count != 2 ) break ; } if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "<S2SV_blank><S2SV_blank>Magick:<S2SV_blank>%c%c" , magick [ 0 ] , magick [ 1 ] ) ; if ( ( count != 2 ) || ( ( LocaleNCompare ( ( char * ) magick , "BM" , 2 ) != 0 ) && ( LocaleNCompare ( ( char * ) magick , "CI" , 2 ) != 0 ) ) ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; bmp_info . file_size = ReadBlobLSBLong ( image ) ; ( void ) ReadBlobLSBLong ( image ) ; bmp_info . offset_bits = ReadBlobLSBLong ( image ) ; bmp_info . size = ReadBlobLSBLong ( image ) ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "<S2SV_blank><S2SV_blank>BMP<S2SV_blank>size:<S2SV_blank>%u" , bmp_info . size ) ; profile_data = 0 ; profile_size = 0 ; if ( bmp_info . size == 12 ) { ( void ) CopyMagickString ( image -> magick , "BMP2" , MagickPathExtent ) ; bmp_info . width = ( ssize_t ) ( ( short ) ReadBlobLSBShort ( image ) ) ; bmp_info . height = ( ssize_t ) ( ( short ) ReadBlobLSBShort ( image ) ) ; bmp_info . planes = ReadBlobLSBShort ( image ) ; bmp_info . bits_per_pixel = ReadBlobLSBShort ( image ) ; bmp_info . x_pixels = 0 ; bmp_info . y_pixels = 0 ; bmp_info . number_colors = 0 ; bmp_info . compression = BI_RGB ; bmp_info . image_size = 0 ; bmp_info . alpha_mask = 0 ; if ( image -> debug != MagickFalse ) { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "<S2SV_blank><S2SV_blank>Format:<S2SV_blank>OS/2<S2SV_blank>Bitmap" ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "<S2SV_blank><S2SV_blank>Geometry:<S2SV_blank>%.20gx%.20g" , ( double ) bmp_info . width , ( double ) bmp_info . height ) ; } } else { if ( bmp_info . size < 40 ) ThrowReaderException ( CorruptImageError , "NonOS2HeaderSizeError" ) ; bmp_info . width = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; bmp_info . height = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; bmp_info . planes = ReadBlobLSBShort ( image ) ; bmp_info . bits_per_pixel = ReadBlobLSBShort ( image ) ; bmp_info . compression = ReadBlobLSBLong ( image ) ; bmp_info . image_size = ReadBlobLSBLong ( image ) ; bmp_info . x_pixels = ReadBlobLSBLong ( image ) ; bmp_info . y_pixels = ReadBlobLSBLong ( image ) ; bmp_info . number_colors = ReadBlobLSBLong ( image ) ; if ( ( MagickSizeType ) bmp_info . number_colors > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , "InsufficientImageDataInFile" ) ; bmp_info . colors_important = ReadBlobLSBLong ( image ) ; if ( image -> debug != MagickFalse ) { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "<S2SV_blank><S2SV_blank>Format:<S2SV_blank>MS<S2SV_blank>Windows<S2SV_blank>bitmap" ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "<S2SV_blank><S2SV_blank>Geometry:<S2SV_blank>%.20gx%.20g" , ( double ) bmp_info . width , ( double ) bmp_info . height ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "<S2SV_blank><S2SV_blank>Bits<S2SV_blank>per<S2SV_blank>pixel:<S2SV_blank>%.20g" , ( double ) bmp_info . bits_per_pixel ) ; switch ( bmp_info . compression ) { case BI_RGB : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_RGB" ) ; break ; } case BI_RLE4 : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_RLE4" ) ; break ; } case BI_RLE8 : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_RLE8" ) ; break ; } case BI_BITFIELDS : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_BITFIELDS" ) ; break ; } case BI_PNG : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_PNG" ) ; break ; } case BI_JPEG : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_JPEG" ) ; break ; } default : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>UNKNOWN<S2SV_blank>(%u)" , bmp_info . compression ) ; } } ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "<S2SV_blank><S2SV_blank>Number<S2SV_blank>of<S2SV_blank>colors:<S2SV_blank>%u" , bmp_info . number_colors ) ; } bmp_info . red_mask = ReadBlobLSBLong ( image ) ; bmp_info . green_mask = ReadBlobLSBLong ( image ) ; bmp_info . blue_mask = ReadBlobLSBLong ( image ) ; if ( bmp_info . size > 40 ) { double gamma ; bmp_info . alpha_mask = ReadBlobLSBLong ( image ) ; bmp_info . colorspace = ReadBlobLSBSignedLong ( image ) ; # define BMP_DENOM ( ( double ) 0x40000000 ) bmp_info . red_primary . x = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . red_primary . y = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . red_primary . z = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . green_primary . x = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . green_primary . y = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . green_primary . z = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . blue_primary . x = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . blue_primary . y = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . blue_primary . z = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; gamma = bmp_info . red_primary . x + bmp_info . red_primary . y + bmp_info . red_primary . z ; gamma = PerceptibleReciprocal ( gamma ) ; bmp_info . red_primary . x *= gamma ; bmp_info . red_primary . y *= gamma ; image -> chromaticity . red_primary . x = bmp_info . red_primary . x ; image -> chromaticity . red_primary . y = bmp_info . red_primary . y ; gamma = bmp_info . green_primary . x + bmp_info . green_primary . y + bmp_info . green_primary . z ; gamma = PerceptibleReciprocal ( gamma ) ; bmp_info . green_primary . x *= gamma ; bmp_info . green_primary . y *= gamma ; image -> chromaticity . green_primary . x = bmp_info . green_primary . x ; image -> chromaticity . green_primary . y = bmp_info . green_primary . y ; gamma = bmp_info . blue_primary . x + bmp_info . blue_primary . y + bmp_info . blue_primary . z ; gamma = PerceptibleReciprocal ( gamma ) ; bmp_info . blue_primary . x *= gamma ; bmp_info . blue_primary . y *= gamma ; image -> chromaticity . blue_primary . x = bmp_info . blue_primary . x ; image -> chromaticity . blue_primary . y = bmp_info . blue_primary . y ; bmp_info . gamma_scale . x = ( double ) ReadBlobLSBLong ( image ) / 0x10000 ; bmp_info . gamma_scale . y = ( double ) ReadBlobLSBLong ( image ) / 0x10000 ; bmp_info . gamma_scale . z = ( double ) ReadBlobLSBLong ( image ) / 0x10000 ; image -> gamma = ( bmp_info . gamma_scale . x + bmp_info . gamma_scale . y + bmp_info . gamma_scale . z ) / 3.0 ; } else ( void ) CopyMagickString ( image -> magick , "BMP3" , MagickPathExtent ) ; if ( bmp_info . size > 108 ) { size_t intent ; intent = ReadBlobLSBLong ( image ) ; switch ( ( int ) intent ) { case LCS_GM_BUSINESS : { image -> rendering_intent = SaturationIntent ; break ; } case LCS_GM_GRAPHICS : { image -> rendering_intent = RelativeIntent ; break ; } case LCS_GM_IMAGES : { image -> rendering_intent = PerceptualIntent ; break ; } case LCS_GM_ABS_COLORIMETRIC : { image -> rendering_intent = AbsoluteIntent ; break ; } } profile_data = ( MagickOffsetType ) ReadBlobLSBLong ( image ) ; profile_size = ( MagickOffsetType ) ReadBlobLSBLong ( image ) ; ( void ) ReadBlobLSBLong ( image ) ; } } if ( ( MagickSizeType ) bmp_info . file_size > GetBlobSize ( image ) ) ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , CorruptImageError , "LengthAndFilesizeDoNotMatch" , "`%s\'" , image -> filename ) ; else if ( ( MagickSizeType ) bmp_info . file_size < GetBlobSize ( image ) ) ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , CorruptImageWarning , "LengthAndFilesizeDoNotMatch" , "`%s\'" , image -> filename ) ; if ( bmp_info . width <= 0 ) ThrowReaderException ( CorruptImageError , "NegativeOrZeroImageSize" ) ; if ( bmp_info . height == 0 ) ThrowReaderException ( CorruptImageError , "NegativeOrZeroImageSize" ) ; if ( bmp_info . planes != 1 ) ThrowReaderException ( CorruptImageError , "StaticPlanesValueNotEqualToOne" ) ; if ( ( bmp_info . bits_per_pixel != 1 ) && ( bmp_info . bits_per_pixel != 4 ) && ( bmp_info . bits_per_pixel != 8 ) && ( bmp_info . bits_per_pixel != 16 ) && ( bmp_info . bits_per_pixel != 24 ) && ( bmp_info . bits_per_pixel != 32 ) ) ThrowReaderException ( CorruptImageError , "UnsupportedBitsPerPixel" ) ; if ( bmp_info . bits_per_pixel < 16 && bmp_info . number_colors > ( 1U << bmp_info . bits_per_pixel ) ) ThrowReaderException ( CorruptImageError , "UnrecognizedNumberOfColors" ) ; if ( ( bmp_info . compression == 1 ) && ( bmp_info . bits_per_pixel != 8 ) ) ThrowReaderException ( CorruptImageError , "UnsupportedBitsPerPixel" ) ; if ( ( bmp_info . compression == 2 ) && ( bmp_info . bits_per_pixel != 4 ) ) ThrowReaderException ( CorruptImageError , "UnsupportedBitsPerPixel" ) ; if ( ( bmp_info . compression == 3 ) && ( bmp_info . bits_per_pixel < 16 ) ) ThrowReaderException ( CorruptImageError , "UnsupportedBitsPerPixel" ) ; switch ( bmp_info . compression ) { case BI_RGB : image -> compression = NoCompression ; break ; case BI_RLE8 : case BI_RLE4 : image -> compression = RLECompression ; break ; case BI_BITFIELDS : break ; case BI_JPEG : ThrowReaderException ( CoderError , "JPEGCompressNotSupported" ) ; case BI_PNG : ThrowReaderException ( CoderError , "PNGCompressNotSupported" ) ; default : ThrowReaderException ( CorruptImageError , "UnrecognizedImageCompression" ) ; } image -> columns = ( size_t ) MagickAbsoluteValue ( bmp_info . width ) ; image -> rows = ( size_t ) MagickAbsoluteValue ( bmp_info . height ) ; image -> depth = bmp_info . bits_per_pixel <= 8 ? bmp_info . bits_per_pixel : 8 ; image -> alpha_trait = ( ( bmp_info . alpha_mask != 0 ) && ( bmp_info . compression == BI_BITFIELDS ) ) ? BlendPixelTrait : UndefinedPixelTrait ; if ( bmp_info . bits_per_pixel < 16 ) { size_t one ; image -> storage_class = PseudoClass ; image -> colors = bmp_info . number_colors ; one = 1 ; if ( image -> colors == 0 ) image -> colors = one << bmp_info . bits_per_pixel ; } image -> resolution . x = ( double ) bmp_info . x_pixels / 100.0 ; image -> resolution . y = ( double ) bmp_info . y_pixels / 100.0 ; image -> units = PixelsPerCentimeterResolution ; if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; if ( image -> storage_class == PseudoClass ) { unsigned char * bmp_colormap ; size_t packet_size ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "<S2SV_blank><S2SV_blank>Reading<S2SV_blank>colormap<S2SV_blank>of<S2SV_blank>%.20g<S2SV_blank>colors" , ( double ) image -> colors ) ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; bmp_colormap = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) image -> colors , 4 * sizeof ( * bmp_colormap ) ) ; if ( bmp_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; if ( ( bmp_info . size == 12 ) || ( bmp_info . size == 64 ) ) packet_size = 3 ; else packet_size = 4 ; offset = SeekBlob ( image , start_position + 14 + bmp_info . size , SEEK_SET ) ; if ( offset < 0 ) { bmp_colormap = ( unsigned char * ) RelinquishMagickMemory ( bmp_colormap ) ; ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; } count = ReadBlob ( image , packet_size * image -> colors , bmp_colormap ) ; if ( count != ( ssize_t ) ( packet_size * image -> colors ) ) { bmp_colormap = ( unsigned char * ) RelinquishMagickMemory ( bmp_colormap ) ; ThrowReaderException ( CorruptImageError , "InsufficientImageDataInFile" ) ; } p = bmp_colormap ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( * p ++ ) ; image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( * p ++ ) ; image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( * p ++ ) ; if ( packet_size == 4 ) p ++ ; } bmp_colormap = ( unsigned char * ) RelinquishMagickMemory ( bmp_colormap ) ; } if ( bmp_info . offset_bits == offset_bits ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; offset_bits = bmp_info . offset_bits ; offset = SeekBlob ( image , start_position + bmp_info . offset_bits , SEEK_SET ) ; if ( offset < 0 ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; if ( bmp_info . compression == BI_RLE4 ) bmp_info . bits_per_pixel <<= 1 ; bytes_per_line = 4 * ( ( image -> columns * bmp_info . bits_per_pixel + 31 ) / 32 ) ; length = ( size_t ) bytes_per_line * image -> rows ; if ( ( MagickSizeType ) ( length / 256 ) > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , "InsufficientImageDataInFile" ) ; if ( ( bmp_info . compression == BI_RGB ) || ( bmp_info . compression == BI_BITFIELDS ) ) { pixel_info = AcquireVirtualMemory ( image -> rows , MagickMax ( bytes_per_line , image -> columns + 256UL ) * sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "<S2SV_blank><S2SV_blank>Reading<S2SV_blank>pixels<S2SV_blank>(%.20g<S2SV_blank>bytes)" , ( double ) length ) ; count = ReadBlob ( image , length , pixels ) ; if ( count != ( ssize_t ) length ) { pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , "InsufficientImageDataInFile" ) ; } } else { pixel_info = AcquireVirtualMemory ( image -> rows , MagickMax ( bytes_per_line , image -> columns + 256UL ) * sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; status = DecodeImage ( image , bmp_info . compression , pixels , image -> columns * image -> rows ) ; if ( status == MagickFalse ) { pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , "UnableToRunlengthDecodeImage" ) ; } } if ( bmp_info . compression == BI_RGB ) { if ( ( image -> alpha_trait == UndefinedPixelTrait ) && ( bmp_info . size == 40 ) && ( bmp_info . bits_per_pixel == 32 ) ) { bytes_per_line = 4 * ( image -> columns ) ; for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( * ( p + 3 ) != 0 ) { image -> alpha_trait = BlendPixelTrait ; y = - 1 ; break ; } p += 4 ; } } } bmp_info . alpha_mask = image -> alpha_trait != UndefinedPixelTrait ? 0xff000000U : 0U ; bmp_info . red_mask = 0x00ff0000U ; bmp_info . green_mask = 0x0000ff00U ; bmp_info . blue_mask = 0x000000ffU ; if ( bmp_info . bits_per_pixel == 16 ) { bmp_info . red_mask = 0x00007c00U ; bmp_info . green_mask = 0x000003e0U ; bmp_info . blue_mask = 0x0000001fU ; } } ( void ) memset ( & shift , 0 , sizeof ( shift ) ) ; ( void ) memset ( & quantum_bits , 0 , sizeof ( quantum_bits ) ) ; if ( ( bmp_info . bits_per_pixel == 16 ) || ( bmp_info . bits_per_pixel == 32 ) ) { register unsigned int sample ; if ( bmp_info . red_mask != 0 ) while ( ( ( bmp_info . red_mask << shift . red ) & 0x80000000UL ) == 0 ) { shift . red ++ ; if ( shift . red >= 32U ) break ; } if ( bmp_info . green_mask != 0 ) while ( ( ( bmp_info . green_mask << shift . green ) & 0x80000000UL ) == 0 ) { shift . green ++ ; if ( shift . green >= 32U ) break ; } if ( bmp_info . blue_mask != 0 ) while ( ( ( bmp_info . blue_mask << shift . blue ) & 0x80000000UL ) == 0 ) { shift . blue ++ ; if ( shift . blue >= 32U ) break ; } if ( bmp_info . alpha_mask != 0 ) while ( ( ( bmp_info . alpha_mask << shift . alpha ) & 0x80000000UL ) == 0 ) { shift . alpha ++ ; if ( shift . alpha >= 32U ) break ; } sample = shift . red ; while ( ( ( bmp_info . red_mask << sample ) & 0x80000000UL ) != 0 ) { sample ++ ; if ( sample >= 32U ) break ; } quantum_bits . red = ( MagickRealType ) ( sample - shift . red ) ; sample = shift . green ; while ( ( ( bmp_info . green_mask << sample ) & 0x80000000UL ) != 0 ) { sample ++ ; if ( sample >= 32U ) break ; } quantum_bits . green = ( MagickRealType ) ( sample - shift . green ) ; sample = shift . blue ; while ( ( ( bmp_info . blue_mask << sample ) & 0x80000000UL ) != 0 ) { sample ++ ; if ( sample >= 32U ) break ; } quantum_bits . blue = ( MagickRealType ) ( sample - shift . blue ) ; sample = shift . alpha ; while ( ( ( bmp_info . alpha_mask << sample ) & 0x80000000UL ) != 0 ) { sample ++ ; if ( sample >= 32U ) break ; } quantum_bits . alpha = ( MagickRealType ) ( sample - shift . alpha ) ; } switch ( bmp_info . bits_per_pixel ) { case 1 : { for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) { for ( bit = 0 ; bit < 8 ; bit ++ ) { index = ( Quantum ) ( ( ( * p ) & ( 0x80 >> bit ) ) != 0 ? 0x01 : 0x00 ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( image -> columns % 8 ) != 0 ) { for ( bit = 0 ; bit < ( image -> columns % 8 ) ; bit ++ ) { index = ( Quantum ) ( ( ( * p ) & ( 0x80 >> bit ) ) != 0 ? 0x01 : 0x00 ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image , exception ) ; break ; } case 4 : { for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 1 ) ; x += 2 ) { ValidateColormapValue ( image , ( ssize_t ) ( ( * p >> 4 ) & 0x0f ) , & index , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; ValidateColormapValue ( image , ( ssize_t ) ( * p & 0x0f ) , & index , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; p ++ ; } if ( ( image -> columns % 2 ) != 0 ) { ValidateColormapValue ( image , ( ssize_t ) ( ( * p >> 4 ) & 0xf ) , & index , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; p ++ ; x ++ ; } if ( x < ( ssize_t ) image -> columns ) break ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image , exception ) ; break ; } case 8 : { if ( ( bmp_info . compression == BI_RLE8 ) || ( bmp_info . compression == BI_RLE4 ) ) bytes_per_line = image -> columns ; for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = ( ssize_t ) image -> columns ; x != 0 ; -- x ) { ValidateColormapValue ( image , ( ssize_t ) * p ++ , & index , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; offset = ( MagickOffsetType ) ( image -> rows - y - 1 ) ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image , exception ) ; break ; } case 16 : { unsigned int alpha , pixel ; if ( ( bmp_info . compression != BI_RGB ) && ( bmp_info . compression != BI_BITFIELDS ) ) { pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , "UnrecognizedImageCompression" ) ; } bytes_per_line = 2 * ( image -> columns + image -> columns % 2 ) ; image -> storage_class = DirectClass ; for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { pixel = ( unsigned int ) ( * p ++ ) ; pixel |= ( * p ++ ) << 8 ; red = ( ( pixel & bmp_info . red_mask ) << shift . red ) >> 16 ; if ( quantum_bits . red == 5 ) red |= ( ( red & 0xe000 ) >> 5 ) ; if ( quantum_bits . red <= 8 ) red |= ( ( red & 0xff00 ) >> 8 ) ; green = ( ( pixel & bmp_info . green_mask ) << shift . green ) >> 16 ; if ( quantum_bits . green == 5 ) green |= ( ( green & 0xe000 ) >> 5 ) ; if ( quantum_bits . green == 6 ) green |= ( ( green & 0xc000 ) >> 6 ) ; if ( quantum_bits . green <= 8 ) green |= ( ( green & 0xff00 ) >> 8 ) ; blue = ( ( pixel & bmp_info . blue_mask ) << shift . blue ) >> 16 ; if ( quantum_bits . blue == 5 ) blue |= ( ( blue & 0xe000 ) >> 5 ) ; if ( quantum_bits . blue <= 8 ) blue |= ( ( blue & 0xff00 ) >> 8 ) ; SetPixelRed ( image , ScaleShortToQuantum ( ( unsigned short ) red ) , q ) ; SetPixelGreen ( image , ScaleShortToQuantum ( ( unsigned short ) green ) , q ) ; SetPixelBlue ( image , ScaleShortToQuantum ( ( unsigned short ) blue ) , q ) ; SetPixelAlpha ( image , OpaqueAlpha , q ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) { alpha = ( ( pixel & bmp_info . alpha_mask ) << shift . alpha ) >> 16 ; if ( quantum_bits . alpha <= 8 ) alpha |= ( ( alpha & 0xff00 ) >> 8 ) ; SetPixelAlpha ( image , ScaleShortToQuantum ( ( unsigned short ) alpha ) , q ) ; } q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; offset = ( MagickOffsetType ) ( image -> rows - y - 1 ) ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } break ; } case 24 : { bytes_per_line = 4 * ( ( image -> columns * 24 + 31 ) / 32 ) ; for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelAlpha ( image , OpaqueAlpha , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; offset = ( MagickOffsetType ) ( image -> rows - y - 1 ) ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } break ; } case 32 : { if ( ( bmp_info . compression != BI_RGB ) && ( bmp_info . compression != BI_BITFIELDS ) ) { pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , "UnrecognizedImageCompression" ) ; } bytes_per_line = 4 * ( image -> columns ) ; for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { unsigned int alpha , pixel ; p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { pixel = ( unsigned int ) ( * p ++ ) ; pixel |= ( ( unsigned int ) * p ++ << 8 ) ; pixel |= ( ( unsigned int ) * p ++ << 16 ) ; pixel |= ( ( unsigned int ) * p ++ << 24 ) ; red = ( ( pixel & bmp_info . red_mask ) << shift . red ) >> 16 ; if ( quantum_bits . red == 8 ) red |= ( red >> 8 ) ; green = ( ( pixel & bmp_info . green_mask ) << shift . green ) >> 16 ; if ( quantum_bits . green == 8 ) green |= ( green >> 8 ) ; blue = ( ( pixel & bmp_info . blue_mask ) << shift . blue ) >> 16 ; if ( quantum_bits . blue == 8 ) blue |= ( blue >> 8 ) ; SetPixelRed ( image , ScaleShortToQuantum ( ( unsigned short ) red ) , q ) ; SetPixelGreen ( image , ScaleShortToQuantum ( ( unsigned short ) green ) , q ) ; SetPixelBlue ( image , ScaleShortToQuantum ( ( unsigned short ) blue ) , q ) ; SetPixelAlpha ( image , OpaqueAlpha , q ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) { alpha = ( ( pixel & bmp_info . alpha_mask ) << shift . alpha ) >> 16 ; if ( quantum_bits . alpha == 8 ) alpha |= ( alpha >> 8 ) ; SetPixelAlpha ( image , ScaleShortToQuantum ( ( unsigned short ) alpha ) , q ) ; } q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; offset = ( MagickOffsetType ) ( image -> rows - y - 1 ) ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } break ; } default : { pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; } } pixel_info = RelinquishVirtualMemory ( pixel_info ) ; if ( y > 0 ) break ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , "UnexpectedEndOfFile" , image -> filename ) ; break ; } if ( bmp_info . height < 0 ) { Image * flipped_image ; flipped_image = FlipImage ( image , exception ) ; if ( flipped_image != ( Image * ) NULL ) { DuplicateBlob ( flipped_image , image ) ; ReplaceImageInList ( & image , flipped_image ) ; image = flipped_image ; } } if ( ( bmp_info . colorspace == 0x4D424544L ) && ( profile_data > 0 ) && ( profile_size > 0 ) ) { StringInfo * profile ; unsigned char * datum ; offset = start_position + 14 + profile_data ; if ( ( offset < TellBlob ( image ) ) || ( SeekBlob ( image , offset , SEEK_SET ) != offset ) || ( GetBlobSize ( image ) < ( MagickSizeType ) ( offset + profile_size ) ) ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; profile = AcquireStringInfo ( ( size_t ) profile_size ) ; if ( profile == ( StringInfo * ) NULL ) ThrowReaderException ( CorruptImageError , "MemoryAllocationFailed" ) ; datum = GetStringInfoDatum ( profile ) ; if ( ReadBlob ( image , ( size_t ) profile_size , datum ) == ( ssize_t ) profile_size ) { MagickOffsetType profile_size_orig ; profile_size_orig = ( MagickOffsetType ) datum [ 0 ] << 24 ; profile_size_orig |= ( MagickOffsetType ) datum [ 1 ] << 16 ; profile_size_orig |= ( MagickOffsetType ) datum [ 2 ] << 8 ; profile_size_orig |= ( MagickOffsetType ) datum [ 3 ] ; if ( profile_size_orig < profile_size ) SetStringInfoLength ( profile , ( size_t ) profile_size_orig ) ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "Profile:<S2SV_blank>ICC,<S2SV_blank>%u<S2SV_blank>bytes" , ( unsigned int ) profile_size_orig ) ; ( void ) SetImageProfile ( image , "icc" , profile , exception ) ; } profile = DestroyStringInfo ( profile ) ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; offset = ( MagickOffsetType ) bmp_info . ba_offset ; if ( offset != 0 ) if ( ( offset < TellBlob ( image ) ) || ( SeekBlob ( image , offset , SEEK_SET ) != offset ) ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; * magick = '\\0' ; count = ReadBlob ( image , 2 , magick ) ; if ( ( count == 2 ) && ( IsBMP ( magick , 2 ) != MagickFalse ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { status = MagickFalse ; <S2SV_StartBug> return ( ( Image * ) NULL ) ; <S2SV_EndBug> } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( IsBMP ( magick , 2 ) != MagickFalse ) ; ( void ) CloseBlob ( image ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; return ( GetFirstImageInList ( image ) ) ; }
CWE-399 static Image * ReadVIFFImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define VFF_CM_genericRGB 15 # define VFF_CM_ntscRGB 1 # define VFF_CM_NONE 0 # define VFF_DEP_DECORDER 0x4 # define VFF_DEP_NSORDER 0x8 # define VFF_DES_RAW 0 # define VFF_LOC_IMPLICIT 1 # define VFF_MAPTYP_NONE 0 # define VFF_MAPTYP_1_BYTE 1 # define VFF_MAPTYP_2_BYTE 2 # define VFF_MAPTYP_4_BYTE 4 # define VFF_MAPTYP_FLOAT 5 # define VFF_MAPTYP_DOUBLE 7 # define VFF_MS_NONE 0 # define VFF_MS_ONEPERBAND 1 # define VFF_MS_SHARED 3 # define VFF_TYP_BIT 0 # define VFF_TYP_1_BYTE 1 # define VFF_TYP_2_BYTE 2 # define VFF_TYP_4_BYTE 4 # define VFF_TYP_FLOAT 5 # define VFF_TYP_DOUBLE 9 typedef struct _ViffInfo { unsigned char identifier , file_type , release , version , machine_dependency , reserve [ 3 ] ; char comment [ 512 ] ; unsigned int rows , columns , subrows ; int x_offset , y_offset ; float x_bits_per_pixel , y_bits_per_pixel ; unsigned int location_type , location_dimension , number_of_images , number_data_bands , data_storage_type , data_encode_scheme , map_scheme , map_storage_type , map_rows , map_columns , map_subrows , map_enable , maps_per_cycle , color_space_model ; } ViffInfo ; double min_value , scale_factor , value ; Image * image ; int bit ; MagickBooleanType status ; MagickSizeType number_pixels ; register ssize_t x ; register Quantum * q ; register ssize_t i ; register unsigned char * p ; size_t bytes_per_pixel , max_packets , quantum ; ssize_t count , y ; unsigned char * pixels ; unsigned long lsb_first ; ViffInfo viff_info ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } count = ReadBlob ( image , 1 , & viff_info . identifier ) ; do { if ( ( count != 1 ) || ( ( unsigned char ) viff_info . identifier != 0xab ) ) ThrowReaderException ( CorruptImageError , "NotAVIFFImage" ) ; ( void ) ReadBlob ( image , sizeof ( viff_info . file_type ) , & viff_info . file_type ) ; ( void ) ReadBlob ( image , sizeof ( viff_info . release ) , & viff_info . release ) ; ( void ) ReadBlob ( image , sizeof ( viff_info . version ) , & viff_info . version ) ; ( void ) ReadBlob ( image , sizeof ( viff_info . machine_dependency ) , & viff_info . machine_dependency ) ; ( void ) ReadBlob ( image , sizeof ( viff_info . reserve ) , viff_info . reserve ) ; count = ReadBlob ( image , 512 , ( unsigned char * ) viff_info . comment ) ; if ( count != 512 ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; viff_info . comment [ 511 ] = '\\0' ; if ( strlen ( viff_info . comment ) > 4 ) ( void ) SetImageProperty ( image , "comment" , viff_info . comment , exception ) ; if ( ( viff_info . machine_dependency == VFF_DEP_DECORDER ) || ( viff_info . machine_dependency == VFF_DEP_NSORDER ) ) image -> endian = LSBEndian ; else image -> endian = MSBEndian ; viff_info . rows = ReadBlobLong ( image ) ; viff_info . columns = ReadBlobLong ( image ) ; viff_info . subrows = ReadBlobLong ( image ) ; viff_info . x_offset = ReadBlobSignedLong ( image ) ; viff_info . y_offset = ReadBlobSignedLong ( image ) ; viff_info . x_bits_per_pixel = ( float ) ReadBlobLong ( image ) ; viff_info . y_bits_per_pixel = ( float ) ReadBlobLong ( image ) ; viff_info . location_type = ReadBlobLong ( image ) ; viff_info . location_dimension = ReadBlobLong ( image ) ; viff_info . number_of_images = ReadBlobLong ( image ) ; viff_info . number_data_bands = ReadBlobLong ( image ) ; viff_info . data_storage_type = ReadBlobLong ( image ) ; viff_info . data_encode_scheme = ReadBlobLong ( image ) ; viff_info . map_scheme = ReadBlobLong ( image ) ; viff_info . map_storage_type = ReadBlobLong ( image ) ; viff_info . map_rows = ReadBlobLong ( image ) ; viff_info . map_columns = ReadBlobLong ( image ) ; viff_info . map_subrows = ReadBlobLong ( image ) ; viff_info . map_enable = ReadBlobLong ( image ) ; viff_info . maps_per_cycle = ReadBlobLong ( image ) ; viff_info . color_space_model = ReadBlobLong ( image ) ; for ( i = 0 ; i < 420 ; i ++ ) ( void ) ReadBlobByte ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowReaderException ( CorruptImageError , "UnexpectedEndOfFile" ) ; number_pixels = ( MagickSizeType ) viff_info . columns * viff_info . rows ; if ( number_pixels > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , "InsufficientImageDataInFile" ) ; if ( number_pixels != ( size_t ) number_pixels ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; if ( number_pixels == 0 ) ThrowReaderException ( CoderError , "ImageColumnOrRowSizeIsNotSupported" ) ; image -> columns = viff_info . rows ; image -> rows = viff_info . columns ; image -> depth = viff_info . x_bits_per_pixel <= 8 ? 8UL : MAGICKCORE_QUANTUM_DEPTH ; image -> alpha_trait = viff_info . number_data_bands == 4 ? BlendPixelTrait : UndefinedPixelTrait ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; ( void ) SetImageBackgroundColor ( image , exception ) ; if ( ( viff_info . number_data_bands < 1 ) || ( viff_info . number_data_bands > 4 ) ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; if ( ( viff_info . data_storage_type != VFF_TYP_BIT ) && ( viff_info . data_storage_type != VFF_TYP_1_BYTE ) && ( viff_info . data_storage_type != VFF_TYP_2_BYTE ) && ( viff_info . data_storage_type != VFF_TYP_4_BYTE ) && ( viff_info . data_storage_type != VFF_TYP_FLOAT ) && ( viff_info . data_storage_type != VFF_TYP_DOUBLE ) ) ThrowReaderException ( CoderError , "DataStorageTypeIsNotSupported" ) ; if ( viff_info . data_encode_scheme != VFF_DES_RAW ) ThrowReaderException ( CoderError , "DataEncodingSchemeIsNotSupported" ) ; if ( ( viff_info . map_storage_type != VFF_MAPTYP_NONE ) && ( viff_info . map_storage_type != VFF_MAPTYP_1_BYTE ) && ( viff_info . map_storage_type != VFF_MAPTYP_2_BYTE ) && ( viff_info . map_storage_type != VFF_MAPTYP_4_BYTE ) && ( viff_info . map_storage_type != VFF_MAPTYP_FLOAT ) && ( viff_info . map_storage_type != VFF_MAPTYP_DOUBLE ) ) ThrowReaderException ( CoderError , "MapStorageTypeIsNotSupported" ) ; if ( ( viff_info . color_space_model != VFF_CM_NONE ) && ( viff_info . color_space_model != VFF_CM_ntscRGB ) && ( viff_info . color_space_model != VFF_CM_genericRGB ) ) ThrowReaderException ( CoderError , "ColorspaceModelIsNotSupported" ) ; if ( viff_info . location_type != VFF_LOC_IMPLICIT ) ThrowReaderException ( CoderError , "LocationTypeIsNotSupported" ) ; if ( viff_info . number_of_images != 1 ) ThrowReaderException ( CoderError , "NumberOfImagesIsNotSupported" ) ; if ( viff_info . map_rows == 0 ) viff_info . map_scheme = VFF_MS_NONE ; switch ( ( int ) viff_info . map_scheme ) { case VFF_MS_NONE : { if ( viff_info . number_data_bands < 3 ) { if ( viff_info . data_storage_type == VFF_TYP_BIT ) image -> colors = 2 ; else if ( viff_info . data_storage_type == VFF_MAPTYP_1_BYTE ) image -> colors = 256UL ; else image -> colors = image -> depth <= 8 ? 256UL : 65536UL ; status = AcquireImageColormap ( image , image -> colors , exception ) ; if ( status == MagickFalse ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; } break ; } case VFF_MS_ONEPERBAND : case VFF_MS_SHARED : { unsigned char * viff_colormap ; switch ( ( int ) viff_info . map_storage_type ) { case VFF_MAPTYP_1_BYTE : bytes_per_pixel = 1 ; break ; case VFF_MAPTYP_2_BYTE : bytes_per_pixel = 2 ; break ; case VFF_MAPTYP_4_BYTE : bytes_per_pixel = 4 ; break ; case VFF_MAPTYP_FLOAT : bytes_per_pixel = 4 ; break ; case VFF_MAPTYP_DOUBLE : bytes_per_pixel = 8 ; break ; default : bytes_per_pixel = 1 ; break ; } image -> colors = viff_info . map_columns ; if ( ( MagickSizeType ) ( viff_info . map_rows * image -> colors ) > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , "InsufficientImageDataInFile" ) ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; if ( ( MagickSizeType ) viff_info . map_rows > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , "InsufficientImageDataInFile" ) ; if ( ( MagickSizeType ) viff_info . map_rows > ( viff_info . map_rows * bytes_per_pixel * sizeof ( * viff_colormap ) ) ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; viff_colormap = ( unsigned char * ) AcquireQuantumMemory ( image -> colors , viff_info . map_rows * bytes_per_pixel * sizeof ( * viff_colormap ) ) ; if ( viff_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; count = ReadBlob ( image , bytes_per_pixel * image -> colors * viff_info . map_rows , viff_colormap ) ; lsb_first = 1 ; if ( * ( char * ) & lsb_first && ( ( viff_info . machine_dependency != VFF_DEP_DECORDER ) && ( viff_info . machine_dependency != VFF_DEP_NSORDER ) ) ) switch ( ( int ) viff_info . map_storage_type ) { case VFF_MAPTYP_2_BYTE : { MSBOrderShort ( viff_colormap , ( bytes_per_pixel * image -> colors * viff_info . map_rows ) ) ; break ; } case VFF_MAPTYP_4_BYTE : case VFF_MAPTYP_FLOAT : { MSBOrderLong ( viff_colormap , ( bytes_per_pixel * image -> colors * viff_info . map_rows ) ) ; break ; } default : break ; } for ( i = 0 ; i < ( ssize_t ) ( viff_info . map_rows * image -> colors ) ; i ++ ) { switch ( ( int ) viff_info . map_storage_type ) { case VFF_MAPTYP_2_BYTE : value = 1.0 * ( ( short * ) viff_colormap ) [ i ] ; break ; case VFF_MAPTYP_4_BYTE : value = 1.0 * ( ( int * ) viff_colormap ) [ i ] ; break ; case VFF_MAPTYP_FLOAT : value = ( ( float * ) viff_colormap ) [ i ] ; break ; case VFF_MAPTYP_DOUBLE : value = ( ( double * ) viff_colormap ) [ i ] ; break ; default : value = 1.0 * viff_colormap [ i ] ; break ; } if ( i < ( ssize_t ) image -> colors ) { image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) value ) ; image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) value ) ; image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) value ) ; } else if ( i < ( ssize_t ) ( 2 * image -> colors ) ) image -> colormap [ i % image -> colors ] . green = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) value ) ; else if ( i < ( ssize_t ) ( 3 * image -> colors ) ) image -> colormap [ i % image -> colors ] . blue = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) value ) ; } viff_colormap = ( unsigned char * ) RelinquishMagickMemory ( viff_colormap ) ; break ; } default : ThrowReaderException ( CoderError , "ColormapTypeNotSupported" ) ; } if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; if ( viff_info . data_storage_type == VFF_TYP_BIT ) { image -> colors = 2 ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; image -> colorspace = GRAYColorspace ; } switch ( ( int ) viff_info . data_storage_type ) { case VFF_TYP_2_BYTE : bytes_per_pixel = 2 ; break ; case VFF_TYP_4_BYTE : bytes_per_pixel = 4 ; break ; case VFF_TYP_FLOAT : bytes_per_pixel = 4 ; break ; case VFF_TYP_DOUBLE : bytes_per_pixel = 8 ; break ; default : bytes_per_pixel = 1 ; break ; } if ( viff_info . data_storage_type == VFF_TYP_BIT ) { if ( HeapOverflowSanityCheck ( ( image -> columns + 7UL ) >> 3UL , image -> rows ) != MagickFalse ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; max_packets = ( ( image -> columns + 7UL ) >> 3UL ) * image -> rows ; } else { if ( HeapOverflowSanityCheck ( ( size_t ) number_pixels , viff_info . number_data_bands ) != MagickFalse ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; max_packets = ( size_t ) ( number_pixels * viff_info . number_data_bands ) ; } if ( ( MagickSizeType ) ( bytes_per_pixel * max_packets ) > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; pixels = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) MagickMax ( number_pixels , max_packets ) , bytes_per_pixel * sizeof ( * pixels ) ) ; if ( pixels == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; ( void ) memset ( pixels , 0 , MagickMax ( number_pixels , max_packets ) * bytes_per_pixel * sizeof ( * pixels ) ) ; count = ReadBlob ( image , bytes_per_pixel * max_packets , pixels ) ; lsb_first = 1 ; if ( * ( char * ) & lsb_first && ( ( viff_info . machine_dependency != VFF_DEP_DECORDER ) && ( viff_info . machine_dependency != VFF_DEP_NSORDER ) ) ) switch ( ( int ) viff_info . data_storage_type ) { case VFF_TYP_2_BYTE : { MSBOrderShort ( pixels , bytes_per_pixel * max_packets ) ; break ; } case VFF_TYP_4_BYTE : case VFF_TYP_FLOAT : { MSBOrderLong ( pixels , bytes_per_pixel * max_packets ) ; break ; } default : break ; } min_value = 0.0 ; scale_factor = 1.0 ; if ( ( viff_info . data_storage_type != VFF_TYP_1_BYTE ) && ( viff_info . map_scheme == VFF_MS_NONE ) ) { double max_value ; switch ( ( int ) viff_info . data_storage_type ) { case VFF_TYP_2_BYTE : value = 1.0 * ( ( short * ) pixels ) [ 0 ] ; break ; case VFF_TYP_4_BYTE : value = 1.0 * ( ( int * ) pixels ) [ 0 ] ; break ; case VFF_TYP_FLOAT : value = ( ( float * ) pixels ) [ 0 ] ; break ; case VFF_TYP_DOUBLE : value = ( ( double * ) pixels ) [ 0 ] ; break ; default : value = 1.0 * pixels [ 0 ] ; break ; } max_value = value ; min_value = value ; for ( i = 0 ; i < ( ssize_t ) max_packets ; i ++ ) { switch ( ( int ) viff_info . data_storage_type ) { case VFF_TYP_2_BYTE : value = 1.0 * ( ( short * ) pixels ) [ i ] ; break ; case VFF_TYP_4_BYTE : value = 1.0 * ( ( int * ) pixels ) [ i ] ; break ; case VFF_TYP_FLOAT : value = ( ( float * ) pixels ) [ i ] ; break ; case VFF_TYP_DOUBLE : value = ( ( double * ) pixels ) [ i ] ; break ; default : value = 1.0 * pixels [ i ] ; break ; } if ( value > max_value ) max_value = value ; else if ( value < min_value ) min_value = value ; } if ( ( min_value == 0 ) && ( max_value == 0 ) ) scale_factor = 0 ; else if ( min_value == max_value ) { scale_factor = ( double ) QuantumRange / min_value ; min_value = 0 ; } else scale_factor = ( double ) QuantumRange / ( max_value - min_value ) ; } p = ( unsigned char * ) pixels ; for ( i = 0 ; i < ( ssize_t ) max_packets ; i ++ ) { switch ( ( int ) viff_info . data_storage_type ) { case VFF_TYP_2_BYTE : value = 1.0 * ( ( short * ) pixels ) [ i ] ; break ; case VFF_TYP_4_BYTE : value = 1.0 * ( ( int * ) pixels ) [ i ] ; break ; case VFF_TYP_FLOAT : value = ( ( float * ) pixels ) [ i ] ; break ; case VFF_TYP_DOUBLE : value = ( ( double * ) pixels ) [ i ] ; break ; default : value = 1.0 * pixels [ i ] ; break ; } if ( viff_info . map_scheme == VFF_MS_NONE ) { value = ( value - min_value ) * scale_factor ; if ( value > QuantumRange ) value = QuantumRange ; else if ( value < 0 ) value = 0 ; } * p = ( unsigned char ) ( ( Quantum ) value ) ; p ++ ; } p = ( unsigned char * ) pixels ; if ( viff_info . data_storage_type == VFF_TYP_BIT ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) ( image -> columns - 7 ) ; x += 8 ) { for ( bit = 0 ; bit < 8 ; bit ++ ) { quantum = ( size_t ) ( ( * p ) & ( 0x01 << bit ) ? 0 : 1 ) ; SetPixelRed ( image , quantum == 0 ? 0 : QuantumRange , q ) ; SetPixelGreen ( image , quantum == 0 ? 0 : QuantumRange , q ) ; SetPixelBlue ( image , quantum == 0 ? 0 : QuantumRange , q ) ; if ( image -> storage_class == PseudoClass ) SetPixelIndex ( image , ( Quantum ) quantum , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( image -> columns % 8 ) != 0 ) { for ( bit = 0 ; bit < ( int ) ( image -> columns % 8 ) ; bit ++ ) { quantum = ( size_t ) ( ( * p ) & ( 0x01 << bit ) ? 0 : 1 ) ; SetPixelRed ( image , quantum == 0 ? 0 : QuantumRange , q ) ; SetPixelGreen ( image , quantum == 0 ? 0 : QuantumRange , q ) ; SetPixelBlue ( image , quantum == 0 ? 0 : QuantumRange , q ) ; if ( image -> storage_class == PseudoClass ) SetPixelIndex ( image , ( Quantum ) quantum , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else if ( image -> storage_class == PseudoClass ) for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelIndex ( image , * p ++ , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } else { number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( image , ScaleCharToQuantum ( * p ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * ( p + number_pixels ) ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * ( p + 2 * number_pixels ) ) , q ) ; if ( image -> colors != 0 ) { ssize_t index ; index = ( ssize_t ) GetPixelRed ( image , q ) ; SetPixelRed ( image , ClampToQuantum ( image -> colormap [ ConstrainColormapIndex ( image , index , exception ) ] . red ) , q ) ; index = ( ssize_t ) GetPixelGreen ( image , q ) ; SetPixelGreen ( image , ClampToQuantum ( image -> colormap [ ConstrainColormapIndex ( image , index , exception ) ] . green ) , q ) ; index = ( ssize_t ) GetPixelBlue ( image , q ) ; SetPixelBlue ( image , ClampToQuantum ( image -> colormap [ ConstrainColormapIndex ( image , index , exception ) ] . blue ) , q ) ; } SetPixelAlpha ( image , image -> alpha_trait != UndefinedPixelTrait ? ScaleCharToQuantum ( * ( p + number_pixels * 3 ) ) : OpaqueAlpha , q ) ; p ++ ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } pixels = ( unsigned char * ) RelinquishMagickMemory ( pixels ) ; if ( image -> storage_class == PseudoClass ) ( void ) SyncImage ( image , exception ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , "UnexpectedEndOfFile" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; count = ReadBlob ( image , 1 , & viff_info . identifier ) ; if ( ( count == 1 ) && ( viff_info . identifier == 0xab ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { <S2SV_StartBug> image = DestroyImageList ( image ) ; <S2SV_EndBug> return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( ( count != 0 ) && ( viff_info . identifier == 0xab ) ) ; ( void ) CloseBlob ( image ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; return ( GetFirstImageInList ( image ) ) ; }
CWE-119 static MagickBooleanType EncodeImage ( const ImageInfo * image_info , Image * image , const size_t data_size ) { # define MaxCode ( number_bits ) ( ( one << ( number_bits ) ) - 1 ) # define MaxHashTable 5003 # define MaxGIFBits 12UL # define MaxGIFTable ( 1UL << MaxGIFBits ) <S2SV_StartBug> # define GIFOutputCode ( code ) { if ( bits > 0 ) datum |= ( size_t ) ( code ) << bits ; else datum = ( size_t ) ( code ) ; bits += number_bits ; while ( bits >= 8 ) { packet [ length ++ ] = ( unsigned char ) ( datum & 0xff ) ; if ( length >= 254 ) { ( void ) WriteBlobByte ( image , ( unsigned char ) length ) ; ( void ) WriteBlob ( image , length , packet ) ; length = 0 ; } datum >>= 8 ; bits -= 8 ; } if ( free_code > max_code ) { number_bits ++ ; if ( number_bits == MaxGIFBits ) max_code = MaxGIFTable ; else max_code = MaxCode ( number_bits ) ; } } <S2SV_EndBug> IndexPacket index ; short * hash_code , * hash_prefix , waiting_code ; size_t bits , clear_code , datum , end_of_information_code , free_code , length , max_code , next_pixel , number_bits , one , pass ; ssize_t displacement , offset , k , y ; unsigned char * packet , * hash_suffix ; assert ( image != ( Image * ) NULL ) ; one = 1 ; packet = ( unsigned char * ) AcquireQuantumMemory ( 256 , sizeof ( * packet ) ) ; hash_code = ( short * ) AcquireQuantumMemory ( MaxHashTable , sizeof ( * hash_code ) ) ; hash_prefix = ( short * ) AcquireQuantumMemory ( MaxHashTable , sizeof ( * hash_prefix ) ) ; hash_suffix = ( unsigned char * ) AcquireQuantumMemory ( MaxHashTable , sizeof ( * hash_suffix ) ) ; if ( ( packet == ( unsigned char * ) NULL ) || ( hash_code == ( short * ) NULL ) || ( hash_prefix == ( short * ) NULL ) || ( hash_suffix == ( unsigned char * ) NULL ) ) { if ( packet != ( unsigned char * ) NULL ) packet = ( unsigned char * ) RelinquishMagickMemory ( packet ) ; if ( hash_code != ( short * ) NULL ) hash_code = ( short * ) RelinquishMagickMemory ( hash_code ) ; if ( hash_prefix != ( short * ) NULL ) hash_prefix = ( short * ) RelinquishMagickMemory ( hash_prefix ) ; if ( hash_suffix != ( unsigned char * ) NULL ) hash_suffix = ( unsigned char * ) RelinquishMagickMemory ( hash_suffix ) ; return ( MagickFalse ) ; } ( void ) memset ( packet , 0 , 256 * sizeof ( * packet ) ) ; ( void ) memset ( hash_code , 0 , MaxHashTable * sizeof ( * hash_code ) ) ; ( void ) memset ( hash_prefix , 0 , MaxHashTable * sizeof ( * hash_prefix ) ) ; ( void ) memset ( hash_suffix , 0 , MaxHashTable * sizeof ( * hash_suffix ) ) ; number_bits = data_size ; max_code = MaxCode ( number_bits ) ; clear_code = ( ( short ) one << ( data_size - 1 ) ) ; end_of_information_code = clear_code + 1 ; free_code = clear_code + 2 ; length = 0 ; datum = 0 ; bits = 0 ; GIFOutputCode ( clear_code ) ; offset = 0 ; pass = 0 ; waiting_code = 0 ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { register const IndexPacket * magick_restrict indexes ; register const PixelPacket * magick_restrict p ; register ssize_t x ; p = GetVirtualPixels ( image , 0 , offset , image -> columns , 1 , & image -> exception ) ; if ( p == ( const PixelPacket * ) NULL ) break ; indexes = GetVirtualIndexQueue ( image ) ; if ( y == 0 ) { waiting_code = ( short ) ( * indexes ) ; p ++ ; } for ( x = ( ssize_t ) ( y == 0 ? 1 : 0 ) ; x < ( ssize_t ) image -> columns ; x ++ ) { <S2SV_StartBug> index = ( IndexPacket ) ( ( size_t ) GetPixelIndex ( indexes + x ) & 0xff ) ; <S2SV_EndBug> p ++ ; k = ( ssize_t ) ( ( ( size_t ) index << ( MaxGIFBits - 8 ) ) + waiting_code ) ; if ( k >= MaxHashTable ) k -= MaxHashTable ; <S2SV_StartBug> next_pixel = MagickFalse ; <S2SV_EndBug> displacement = 1 ; if ( hash_code [ k ] > 0 ) { if ( ( hash_prefix [ k ] == waiting_code ) && ( hash_suffix [ k ] == ( unsigned char ) index ) ) { waiting_code = hash_code [ k ] ; continue ; } if ( k != 0 ) displacement = MaxHashTable - k ; for ( ; ; ) { k -= displacement ; if ( k < 0 ) k += MaxHashTable ; if ( hash_code [ k ] == 0 ) break ; if ( ( hash_prefix [ k ] == waiting_code ) && ( hash_suffix [ k ] == ( unsigned char ) index ) ) { waiting_code = hash_code [ k ] ; next_pixel = MagickTrue ; break ; } } if ( next_pixel != MagickFalse ) continue ; } GIFOutputCode ( waiting_code ) ; if ( free_code < MaxGIFTable ) { hash_code [ k ] = ( short ) free_code ++ ; hash_prefix [ k ] = waiting_code ; hash_suffix [ k ] = ( unsigned char ) index ; } else { for ( k = 0 ; k < MaxHashTable ; k ++ ) hash_code [ k ] = 0 ; free_code = clear_code + 2 ; GIFOutputCode ( clear_code ) ; number_bits = data_size ; max_code = MaxCode ( number_bits ) ; } waiting_code = ( short ) index ; } if ( image_info -> interlace == NoInterlace ) offset ++ ; else switch ( pass ) { case 0 : default : { offset += 8 ; if ( offset >= ( ssize_t ) image -> rows ) { pass ++ ; offset = 4 ; } break ; } case 1 : { offset += 8 ; if ( offset >= ( ssize_t ) image -> rows ) { pass ++ ; offset = 2 ; } break ; } case 2 : { offset += 4 ; if ( offset >= ( ssize_t ) image -> rows ) { pass ++ ; offset = 1 ; } break ; } case 3 : { offset += 2 ; break ; } } } GIFOutputCode ( waiting_code ) ; GIFOutputCode ( end_of_information_code ) ; if ( bits > 0 ) { packet [ length ++ ] = ( unsigned char ) ( datum & 0xff ) ; if ( length >= 254 ) { ( void ) WriteBlobByte ( image , ( unsigned char ) length ) ; ( void ) WriteBlob ( image , length , packet ) ; length = 0 ; } } if ( length > 0 ) { ( void ) WriteBlobByte ( image , ( unsigned char ) length ) ; ( void ) WriteBlob ( image , length , packet ) ; } hash_suffix = ( unsigned char * ) RelinquishMagickMemory ( hash_suffix ) ; hash_prefix = ( short * ) RelinquishMagickMemory ( hash_prefix ) ; hash_code = ( short * ) RelinquishMagickMemory ( hash_code ) ; packet = ( unsigned char * ) RelinquishMagickMemory ( packet ) ; return ( MagickTrue ) ; }
CWE-20 static Image * ReadCUTImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { <S2SV_StartBug> # define ThrowCUTReaderException ( severity , tag ) { if ( palette != NULL ) palette = DestroyImage ( palette ) ; if ( clone_info != NULL ) clone_info = DestroyImageInfo ( clone_info ) ; ThrowReaderException ( severity , tag ) ; } <S2SV_EndBug> Image * image , * palette ; ImageInfo * clone_info ; MagickBooleanType status ; MagickOffsetType offset ; size_t EncodedByte ; unsigned char RunCount , RunValue , RunCountMasked ; CUTHeader Header ; CUTPalHeader PalHeader ; ssize_t depth ; ssize_t i , j ; ssize_t ldblk ; unsigned char * BImgBuff = NULL , * ptrB ; PixelPacket * q ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } palette = NULL ; clone_info = NULL ; Header . Width = ReadBlobLSBShort ( image ) ; Header . Height = ReadBlobLSBShort ( image ) ; Header . Reserved = ReadBlobLSBShort ( image ) ; if ( Header . Width == 0 || Header . Height == 0 || Header . Reserved != 0 ) CUT_KO : ThrowCUTReaderException ( CorruptImageError , "ImproperImageHeader" ) ; EncodedByte = ReadBlobLSBShort ( image ) ; RunCount = ( unsigned char ) ReadBlobByte ( image ) ; RunCountMasked = RunCount & 0x7F ; ldblk = 0 ; while ( ( int ) RunCountMasked != 0 ) { i = 1 ; if ( ( int ) RunCount < 0x80 ) i = ( ssize_t ) RunCountMasked ; offset = SeekBlob ( image , TellBlob ( image ) + i , SEEK_SET ) ; if ( offset < 0 ) ThrowCUTReaderException ( CorruptImageError , "ImproperImageHeader" ) ; if ( EOFBlob ( image ) != MagickFalse ) goto CUT_KO ; EncodedByte -= i + 1 ; ldblk += ( ssize_t ) RunCountMasked ; RunCount = ( unsigned char ) ReadBlobByte ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) goto CUT_KO ; RunCountMasked = RunCount & 0x7F ; } if ( EncodedByte != 1 ) goto CUT_KO ; i = 0 ; if ( ldblk == ( int ) Header . Width ) i = 8 ; if ( 2 * ldblk == ( int ) Header . Width ) i = 4 ; if ( 8 * ldblk == ( int ) Header . Width ) i = 1 ; if ( i == 0 ) goto CUT_KO ; depth = i ; image -> columns = Header . Width ; image -> rows = Header . Height ; image -> depth = 8 ; image -> colors = ( size_t ) ( GetQuantumRange ( 1UL * i ) + 1 ) ; if ( image_info -> ping != MagickFalse ) goto Finish ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } if ( ( clone_info = CloneImageInfo ( image_info ) ) == NULL ) goto NoPalette ; i = ( ssize_t ) strlen ( clone_info -> filename ) ; j = i ; while ( -- i > 0 ) { if ( clone_info -> filename [ i ] == '.' ) { break ; } if ( clone_info -> filename [ i ] == '/' || clone_info -> filename [ i ] == '\\\\' || clone_info -> filename [ i ] == ':' ) { i = j ; break ; } } ( void ) CopyMagickString ( clone_info -> filename + i , ".PAL" , ( size_t ) ( MaxTextExtent - i ) ) ; if ( ( clone_info -> file = fopen_utf8 ( clone_info -> filename , "rb" ) ) == NULL ) { ( void ) CopyMagickString ( clone_info -> filename + i , ".pal" , ( size_t ) ( MaxTextExtent - i ) ) ; if ( ( clone_info -> file = fopen_utf8 ( clone_info -> filename , "rb" ) ) == NULL ) { clone_info -> filename [ i ] = '\\0' ; if ( ( clone_info -> file = fopen_utf8 ( clone_info -> filename , "rb" ) ) == NULL ) { clone_info = DestroyImageInfo ( clone_info ) ; clone_info = NULL ; goto NoPalette ; } } } if ( ( palette = AcquireImage ( clone_info ) ) == NULL ) goto NoPalette ; status = OpenBlob ( clone_info , palette , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { ErasePalette : palette = DestroyImage ( palette ) ; palette = NULL ; goto NoPalette ; } if ( palette != NULL ) { ( void ) ReadBlob ( palette , 2 , ( unsigned char * ) PalHeader . FileId ) ; if ( strncmp ( PalHeader . FileId , "AH" , 2 ) != 0 ) goto ErasePalette ; PalHeader . Version = ReadBlobLSBShort ( palette ) ; PalHeader . Size = ReadBlobLSBShort ( palette ) ; PalHeader . FileType = ( char ) ReadBlobByte ( palette ) ; PalHeader . SubType = ( char ) ReadBlobByte ( palette ) ; PalHeader . BoardID = ReadBlobLSBShort ( palette ) ; PalHeader . GraphicsMode = ReadBlobLSBShort ( palette ) ; PalHeader . MaxIndex = ReadBlobLSBShort ( palette ) ; PalHeader . MaxRed = ReadBlobLSBShort ( palette ) ; PalHeader . MaxGreen = ReadBlobLSBShort ( palette ) ; PalHeader . MaxBlue = ReadBlobLSBShort ( palette ) ; ( void ) ReadBlob ( palette , 20 , ( unsigned char * ) PalHeader . PaletteId ) ; if ( EOFBlob ( image ) ) ThrowCUTReaderException ( CorruptImageError , "UnexpectedEndOfFile" ) ; if ( PalHeader . MaxIndex < 1 ) goto ErasePalette ; image -> colors = PalHeader . MaxIndex + 1 ; if ( AcquireImageColormap ( image , image -> colors ) == MagickFalse ) goto NoMemory ; if ( PalHeader . MaxRed == 0 ) PalHeader . MaxRed = ( unsigned int ) QuantumRange ; if ( PalHeader . MaxGreen == 0 ) PalHeader . MaxGreen = ( unsigned int ) QuantumRange ; if ( PalHeader . MaxBlue == 0 ) PalHeader . MaxBlue = ( unsigned int ) QuantumRange ; for ( i = 0 ; i <= ( int ) PalHeader . MaxIndex ; i ++ ) { j = ( ssize_t ) TellBlob ( palette ) ; if ( ( j % 512 ) > 512 - 6 ) { j = ( ( j / 512 ) + 1 ) * 512 ; offset = SeekBlob ( palette , j , SEEK_SET ) ; if ( offset < 0 ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; } image -> colormap [ i ] . red = ( Quantum ) ReadBlobLSBShort ( palette ) ; if ( QuantumRange != ( Quantum ) PalHeader . MaxRed ) { image -> colormap [ i ] . red = ClampToQuantum ( ( ( double ) image -> colormap [ i ] . red * QuantumRange + ( PalHeader . MaxRed >> 1 ) ) / PalHeader . MaxRed ) ; } image -> colormap [ i ] . green = ( Quantum ) ReadBlobLSBShort ( palette ) ; if ( QuantumRange != ( Quantum ) PalHeader . MaxGreen ) { image -> colormap [ i ] . green = ClampToQuantum ( ( ( double ) image -> colormap [ i ] . green * QuantumRange + ( PalHeader . MaxGreen >> 1 ) ) / PalHeader . MaxGreen ) ; } image -> colormap [ i ] . blue = ( Quantum ) ReadBlobLSBShort ( palette ) ; if ( QuantumRange != ( Quantum ) PalHeader . MaxBlue ) { image -> colormap [ i ] . blue = ClampToQuantum ( ( ( double ) image -> colormap [ i ] . blue * QuantumRange + ( PalHeader . MaxBlue >> 1 ) ) / PalHeader . MaxBlue ) ; } } if ( EOFBlob ( image ) ) ThrowCUTReaderException ( CorruptImageError , "UnexpectedEndOfFile" ) ; } NoPalette : if ( palette == NULL ) { image -> colors = 256 ; if ( AcquireImageColormap ( image , image -> colors ) == MagickFalse ) { NoMemory : ThrowCUTReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; } for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( unsigned char ) i ) ; } } BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ldblk , sizeof ( * BImgBuff ) ) ; if ( BImgBuff == NULL ) goto NoMemory ; <S2SV_StartBug> offset = SeekBlob ( image , 6 , SEEK_SET ) ; <S2SV_EndBug> if ( offset < 0 ) { if ( palette != NULL ) palette = DestroyImage ( palette ) ; if ( clone_info != NULL ) clone_info = DestroyImageInfo ( clone_info ) ; BImgBuff = ( unsigned char * ) RelinquishMagickMemory ( BImgBuff ) ; ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; } for ( i = 0 ; i < ( int ) Header . Height ; i ++ ) { EncodedByte = ReadBlobLSBShort ( image ) ; ptrB = BImgBuff ; j = ldblk ; RunCount = ( unsigned char ) ReadBlobByte ( image ) ; RunCountMasked = RunCount & 0x7F ; while ( ( int ) RunCountMasked != 0 ) { if ( ( ssize_t ) RunCountMasked > j ) { RunCountMasked = ( unsigned char ) j ; if ( j == 0 ) { break ; } } if ( ( int ) RunCount > 0x80 ) { RunValue = ( unsigned char ) ReadBlobByte ( image ) ; ( void ) memset ( ptrB , ( int ) RunValue , ( size_t ) RunCountMasked ) ; } else { ( void ) ReadBlob ( image , ( size_t ) RunCountMasked , ptrB ) ; } ptrB += ( int ) RunCountMasked ; j -= ( int ) RunCountMasked ; if ( EOFBlob ( image ) != MagickFalse ) goto Finish ; RunCount = ( unsigned char ) ReadBlobByte ( image ) ; RunCountMasked = RunCount & 0x7F ; } InsertRow ( depth , BImgBuff , i , image ) ; } ( void ) SyncImage ( image ) ; if ( palette == NULL ) { if ( ( image -> storage_class == PseudoClass ) && ( SetImageGray ( image , & image -> exception ) != MagickFalse ) ) { if ( GetCutColors ( image ) == 2 ) { for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { register Quantum sample ; sample = ScaleCharToQuantum ( ( unsigned char ) i ) ; if ( image -> colormap [ i ] . red != sample ) goto Finish ; if ( image -> colormap [ i ] . green != sample ) goto Finish ; if ( image -> colormap [ i ] . blue != sample ) goto Finish ; } image -> colormap [ 1 ] . red = image -> colormap [ 1 ] . green = image -> colormap [ 1 ] . blue = QuantumRange ; for ( i = 0 ; i < ( ssize_t ) image -> rows ; i ++ ) { q = QueueAuthenticPixels ( image , 0 , i , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( j = 0 ; j < ( ssize_t ) image -> columns ; j ++ ) { if ( GetPixelRed ( q ) == ScaleCharToQuantum ( 1 ) ) { SetPixelRed ( q , QuantumRange ) ; SetPixelGreen ( q , QuantumRange ) ; SetPixelBlue ( q , QuantumRange ) ; } q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) goto Finish ; } } } } Finish : if ( BImgBuff != NULL ) BImgBuff = ( unsigned char * ) RelinquishMagickMemory ( BImgBuff ) ; if ( palette != NULL ) palette = DestroyImage ( palette ) ; if ( clone_info != NULL ) clone_info = DestroyImageInfo ( clone_info ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowFileException ( exception , CorruptImageError , "UnexpectedEndOfFile" , image -> filename ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
CWE-119 <S2SV_StartBug> static MagickPixelPacket * * AcquirePixelThreadSet ( const Image * image ) <S2SV_EndBug> { MagickPixelPacket * * pixels ; register ssize_t i , j ; size_t <S2SV_StartBug> number_threads ; <S2SV_EndBug> number_threads = ( size_t ) GetMagickResourceLimit ( ThreadResource ) ; pixels = ( MagickPixelPacket * * ) AcquireQuantumMemory ( number_threads , sizeof ( * pixels ) ) ; if ( pixels == ( MagickPixelPacket * * ) NULL ) return ( ( MagickPixelPacket * * ) NULL ) ; ( void ) memset ( pixels , 0 , number_threads * sizeof ( * pixels ) ) ; <S2SV_StartBug> for ( i = 0 ; i < ( ssize_t ) number_threads ; i ++ ) <S2SV_EndBug> { <S2SV_StartBug> pixels [ i ] = ( MagickPixelPacket * ) AcquireQuantumMemory ( image -> columns , <S2SV_EndBug> sizeof ( * * pixels ) ) ; if ( pixels [ i ] == ( MagickPixelPacket * ) NULL ) return ( DestroyPixelThreadSet ( pixels ) ) ; <S2SV_StartBug> for ( j = 0 ; j < ( ssize_t ) image -> columns ; j ++ ) <S2SV_EndBug> <S2SV_StartBug> GetMagickPixelPacket ( image , & pixels [ i ] [ j ] ) ; <S2SV_EndBug> } return ( pixels ) ; }
CWE-399 static Image * ReadPSImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define BoundingBox "BoundingBox:" # define BeginDocument "BeginDocument:" # define BeginXMPPacket "<?xpacket<S2SV_blank>begin=" # define EndXMPPacket "<?xpacket<S2SV_blank>end=" # define ICCProfile "BeginICCProfile:" # define CMYKCustomColor "CMYKCustomColor:" # define CMYKProcessColor "CMYKProcessColor:" # define DocumentMedia "DocumentMedia:" # define DocumentCustomColors "DocumentCustomColors:" # define DocumentProcessColors "DocumentProcessColors:" # define EndDocument "EndDocument:" # define HiResBoundingBox "HiResBoundingBox:" # define ImageData "ImageData:" # define PageBoundingBox "PageBoundingBox:" # define LanguageLevel "LanguageLevel:" # define PageMedia "PageMedia:" # define Pages "Pages:" # define PhotoshopProfile "BeginPhotoshop:" # define PostscriptLevel "!PS-" # define RenderPostscriptText "<S2SV_blank><S2SV_blank>Rendering<S2SV_blank>Postscript...<S2SV_blank><S2SV_blank>" # define SpotColor "+<S2SV_blank>" char command [ MaxTextExtent ] , * density , filename [ MaxTextExtent ] , geometry [ MaxTextExtent ] , input_filename [ MaxTextExtent ] , message [ MaxTextExtent ] , * options , postscript_filename [ MaxTextExtent ] ; const char * option ; const DelegateInfo * delegate_info ; GeometryInfo geometry_info ; Image * image , * next , * postscript_image ; ImageInfo * read_info ; int c , file ; MagickBooleanType cmyk , fitPage , skip , status ; MagickStatusType flags ; PointInfo delta , resolution ; RectangleInfo page ; register char * p ; register ssize_t i ; SegmentInfo bounds , hires_bounds ; short int hex_digits [ 256 ] ; size_t length , priority ; ssize_t count ; StringInfo * profile ; unsigned long columns , extent , language_level , pages , rows , scene , spotcolor ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } status = AcquireUniqueSymbolicLink ( image_info -> filename , input_filename ) ; if ( status == MagickFalse ) { ThrowFileException ( exception , FileOpenError , "UnableToCreateTemporaryFile" , image_info -> filename ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) memset ( hex_digits , 0 , sizeof ( hex_digits ) ) ; hex_digits [ ( int ) '0' ] = 0 ; hex_digits [ ( int ) '1' ] = 1 ; hex_digits [ ( int ) '2' ] = 2 ; hex_digits [ ( int ) '3' ] = 3 ; hex_digits [ ( int ) '4' ] = 4 ; hex_digits [ ( int ) '5' ] = 5 ; hex_digits [ ( int ) '6' ] = 6 ; hex_digits [ ( int ) '7' ] = 7 ; hex_digits [ ( int ) '8' ] = 8 ; hex_digits [ ( int ) '9' ] = 9 ; hex_digits [ ( int ) 'a' ] = 10 ; hex_digits [ ( int ) 'b' ] = 11 ; hex_digits [ ( int ) 'c' ] = 12 ; hex_digits [ ( int ) 'd' ] = 13 ; hex_digits [ ( int ) 'e' ] = 14 ; hex_digits [ ( int ) 'f' ] = 15 ; hex_digits [ ( int ) 'A' ] = 10 ; hex_digits [ ( int ) 'B' ] = 11 ; hex_digits [ ( int ) 'C' ] = 12 ; hex_digits [ ( int ) 'D' ] = 13 ; hex_digits [ ( int ) 'E' ] = 14 ; hex_digits [ ( int ) 'F' ] = 15 ; delta . x = DefaultResolution ; delta . y = DefaultResolution ; if ( ( image -> x_resolution == 0.0 ) || ( image -> y_resolution == 0.0 ) ) { flags = ParseGeometry ( PSDensityGeometry , & geometry_info ) ; image -> x_resolution = geometry_info . rho ; image -> y_resolution = geometry_info . sigma ; if ( ( flags & SigmaValue ) == 0 ) image -> y_resolution = image -> x_resolution ; } if ( image_info -> density != ( char * ) NULL ) { flags = ParseGeometry ( image_info -> density , & geometry_info ) ; image -> x_resolution = geometry_info . rho ; image -> y_resolution = geometry_info . sigma ; if ( ( flags & SigmaValue ) == 0 ) image -> y_resolution = image -> x_resolution ; } ( void ) ParseAbsoluteGeometry ( PSPageGeometry , & page ) ; if ( image_info -> page != ( char * ) NULL ) ( void ) ParseAbsoluteGeometry ( image_info -> page , & page ) ; resolution . x = image -> x_resolution ; resolution . y = image -> y_resolution ; page . width = ( size_t ) ceil ( ( double ) ( page . width * resolution . x / delta . x ) - 0.5 ) ; page . height = ( size_t ) ceil ( ( double ) ( page . height * resolution . y / delta . y ) - 0.5 ) ; ( void ) memset ( & bounds , 0 , sizeof ( bounds ) ) ; ( void ) memset ( command , 0 , sizeof ( command ) ) ; cmyk = image_info -> colorspace == CMYKColorspace ? MagickTrue : MagickFalse ; ( void ) memset ( & hires_bounds , 0 , sizeof ( hires_bounds ) ) ; priority = 0 ; columns = 0 ; rows = 0 ; extent = 0 ; spotcolor = 0 ; language_level = 1 ; skip = MagickFalse ; pages = ( ~ 0UL ) ; p = command ; for ( c = ReadBlobByte ( image ) ; c != EOF ; c = ReadBlobByte ( image ) ) { * p ++ = ( char ) c ; if ( ( strchr ( "\\n\\r%" , c ) == ( char * ) NULL ) && ( ( size_t ) ( p - command ) < ( MaxTextExtent - 1 ) ) ) continue ; * p = '\\0' ; p = command ; if ( LocaleNCompare ( BeginDocument , command , strlen ( BeginDocument ) ) == 0 ) skip = MagickTrue ; if ( LocaleNCompare ( EndDocument , command , strlen ( EndDocument ) ) == 0 ) skip = MagickFalse ; if ( skip != MagickFalse ) continue ; if ( LocaleNCompare ( PostscriptLevel , command , strlen ( PostscriptLevel ) ) == 0 ) { ( void ) SetImageProperty ( image , "ps:Level" , command + 4 ) ; if ( GlobExpression ( command , "*EPSF-*" , MagickTrue ) != MagickFalse ) pages = 1 ; } if ( LocaleNCompare ( LanguageLevel , command , strlen ( LanguageLevel ) ) == 0 ) ( void ) sscanf ( command , LanguageLevel "<S2SV_blank>%lu" , & language_level ) ; if ( LocaleNCompare ( Pages , command , strlen ( Pages ) ) == 0 ) ( void ) sscanf ( command , Pages "<S2SV_blank>%lu" , & pages ) ; if ( LocaleNCompare ( ImageData , command , strlen ( ImageData ) ) == 0 ) ( void ) sscanf ( command , ImageData "<S2SV_blank>%lu<S2SV_blank>%lu" , & columns , & rows ) ; length = strlen ( DocumentProcessColors ) ; if ( LocaleNCompare ( DocumentProcessColors , command , length ) == 0 ) { if ( ( GlobExpression ( command , "*Cyan*" , MagickTrue ) != MagickFalse ) || ( GlobExpression ( command , "*Magenta*" , MagickTrue ) != MagickFalse ) || ( GlobExpression ( command , "*Yellow*" , MagickTrue ) != MagickFalse ) ) cmyk = MagickTrue ; } if ( LocaleNCompare ( CMYKCustomColor , command , strlen ( CMYKCustomColor ) ) == 0 ) cmyk = MagickTrue ; if ( LocaleNCompare ( CMYKProcessColor , command , strlen ( CMYKProcessColor ) ) == 0 ) cmyk = MagickTrue ; length = strlen ( DocumentCustomColors ) ; if ( ( LocaleNCompare ( DocumentCustomColors , command , length ) == 0 ) || ( LocaleNCompare ( CMYKCustomColor , command , strlen ( CMYKCustomColor ) ) == 0 ) || ( LocaleNCompare ( SpotColor , command , strlen ( SpotColor ) ) == 0 ) ) { char property [ MaxTextExtent ] , * value ; register char * p ; ( void ) FormatLocaleString ( property , MaxTextExtent , "ps:SpotColor-%.20g" , ( double ) ( spotcolor ++ ) ) ; for ( p = command ; * p != '\\0' ; p ++ ) if ( isspace ( ( int ) ( unsigned char ) * p ) != 0 ) break ; value = ConstantString ( p ) ; ( void ) SubstituteString ( & value , "(" , "" ) ; ( void ) SubstituteString ( & value , ")" , "" ) ; ( void ) StripString ( value ) ; if ( * value != '\\0' ) ( void ) SetImageProperty ( image , property , value ) ; value = DestroyString ( value ) ; continue ; } if ( image_info -> page != ( char * ) NULL ) continue ; count = 0 ; i = 0 ; if ( LocaleNCompare ( BoundingBox , command , strlen ( BoundingBox ) ) == 0 ) { count = ( ssize_t ) sscanf ( command , BoundingBox "<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf" , & bounds . x1 , & bounds . y1 , & bounds . x2 , & bounds . y2 ) ; i = 2 ; } if ( LocaleNCompare ( DocumentMedia , command , strlen ( DocumentMedia ) ) == 0 ) { count = ( ssize_t ) sscanf ( command , DocumentMedia "<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf" , & bounds . x1 , & bounds . y1 , & bounds . x2 , & bounds . y2 ) ; i = 1 ; } if ( LocaleNCompare ( HiResBoundingBox , command , strlen ( HiResBoundingBox ) ) == 0 ) { count = ( ssize_t ) sscanf ( command , HiResBoundingBox "<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf" , & bounds . x1 , & bounds . y1 , & bounds . x2 , & bounds . y2 ) ; i = 3 ; } if ( LocaleNCompare ( PageBoundingBox , command , strlen ( PageBoundingBox ) ) == 0 ) { count = ( ssize_t ) sscanf ( command , PageBoundingBox "<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf" , & bounds . x1 , & bounds . y1 , & bounds . x2 , & bounds . y2 ) ; i = 1 ; } if ( LocaleNCompare ( PageMedia , command , strlen ( PageMedia ) ) == 0 ) { count = ( ssize_t ) sscanf ( command , PageMedia "<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf" , & bounds . x1 , & bounds . y1 , & bounds . x2 , & bounds . y2 ) ; i = 1 ; } if ( ( count != 4 ) || ( i < ( ssize_t ) priority ) ) continue ; if ( ( fabs ( bounds . x2 - bounds . x1 ) <= fabs ( hires_bounds . x2 - hires_bounds . x1 ) ) || ( fabs ( bounds . y2 - bounds . y1 ) <= fabs ( hires_bounds . y2 - hires_bounds . y1 ) ) ) if ( i == ( ssize_t ) priority ) continue ; hires_bounds = bounds ; priority = ( size_t ) i ; } if ( ( fabs ( hires_bounds . x2 - hires_bounds . x1 ) >= MagickEpsilon ) && ( fabs ( hires_bounds . y2 - hires_bounds . y1 ) >= MagickEpsilon ) ) { ( void ) FormatLocaleString ( geometry , MaxTextExtent , "%gx%g%+.15g%+.15g" , hires_bounds . x2 - hires_bounds . x1 , hires_bounds . y2 - hires_bounds . y1 , hires_bounds . x1 , hires_bounds . y1 ) ; ( void ) SetImageProperty ( image , "ps:HiResBoundingBox" , geometry ) ; page . width = ( size_t ) ceil ( ( double ) ( ( hires_bounds . x2 - hires_bounds . x1 ) * resolution . x / delta . x ) - 0.5 ) ; page . height = ( size_t ) ceil ( ( double ) ( ( hires_bounds . y2 - hires_bounds . y1 ) * resolution . y / delta . y ) - 0.5 ) ; } fitPage = MagickFalse ; option = GetImageOption ( image_info , "eps:fit-page" ) ; if ( option != ( char * ) NULL ) { char * geometry ; MagickStatusType flags ; geometry = GetPageGeometry ( option ) ; flags = ParseMetaGeometry ( geometry , & page . x , & page . y , & page . width , & page . height ) ; if ( flags == NoValue ) { ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , OptionError , <S2SV_StartBug> "InvalidGeometry" , "`%s\'" , option ) ; <S2SV_EndBug> image = DestroyImage ( image ) ; return ( ( Image * ) NULL ) ; } page . width = ( size_t ) ceil ( ( double ) ( page . width * image -> x_resolution / delta . x ) - 0.5 ) ; page . height = ( size_t ) ceil ( ( double ) ( page . height * image -> y_resolution / delta . y ) - 0.5 ) ; geometry = DestroyString ( geometry ) ; fitPage = MagickTrue ; } if ( IssRGBCompatibleColorspace ( image_info -> colorspace ) != MagickFalse ) cmyk = MagickFalse ; file = AcquireUniqueFileResource ( postscript_filename ) ; if ( file == - 1 ) { ThrowFileException ( & image -> exception , FileOpenError , "UnableToOpenFile" , image_info -> filename ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) CopyMagickString ( command , "/setpagedevice<S2SV_blank>{pop}<S2SV_blank>bind<S2SV_blank>1<S2SV_blank>index<S2SV_blank>where<S2SV_blank>{" "dup<S2SV_blank>wcheck<S2SV_blank>{3<S2SV_blank>1<S2SV_blank>roll<S2SV_blank>put}<S2SV_blank>{pop<S2SV_blank>def}<S2SV_blank>ifelse}<S2SV_blank>{def}<S2SV_blank>ifelse\\n" "<</UseCIEColor<S2SV_blank>true>>setpagedevice\\n" , MaxTextExtent ) ; count = write ( file , command , ( unsigned int ) strlen ( command ) ) ; if ( image_info -> page == ( char * ) NULL ) { char translate_geometry [ MaxTextExtent ] ; ( void ) FormatLocaleString ( translate_geometry , MaxTextExtent , "%g<S2SV_blank>%g<S2SV_blank>translate\\n" , - hires_bounds . x1 , - hires_bounds . y1 ) ; count = write ( file , translate_geometry , ( unsigned int ) strlen ( translate_geometry ) ) ; } file = close ( file ) - 1 ; if ( image_info -> monochrome != MagickFalse ) delegate_info = GetDelegateInfo ( "ps:mono" , ( char * ) NULL , exception ) ; else if ( cmyk != MagickFalse ) delegate_info = GetDelegateInfo ( "ps:cmyk" , ( char * ) NULL , exception ) ; else delegate_info = GetDelegateInfo ( "ps:alpha" , ( char * ) NULL , exception ) ; if ( delegate_info == ( const DelegateInfo * ) NULL ) { ( void ) RelinquishUniqueFileResource ( postscript_filename ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } density = AcquireString ( "" ) ; options = AcquireString ( "" ) ; ( void ) FormatLocaleString ( density , MaxTextExtent , "%gx%g" , resolution . x , resolution . y ) ; ( void ) FormatLocaleString ( options , MaxTextExtent , "-g%.20gx%.20g<S2SV_blank>" , ( double ) page . width , ( double ) page . height ) ; read_info = CloneImageInfo ( image_info ) ; * read_info -> magick = '\\0' ; if ( read_info -> number_scenes != 0 ) { char pages [ MaxTextExtent ] ; ( void ) FormatLocaleString ( pages , MaxTextExtent , "-dFirstPage=%.20g<S2SV_blank>" "-dLastPage=%.20g<S2SV_blank>" , ( double ) read_info -> scene + 1 , ( double ) ( read_info -> scene + read_info -> number_scenes ) ) ; ( void ) ConcatenateMagickString ( options , pages , MaxTextExtent ) ; read_info -> number_scenes = 0 ; if ( read_info -> scenes != ( char * ) NULL ) * read_info -> scenes = '\\0' ; } if ( * image_info -> magick == 'E' ) { option = GetImageOption ( image_info , "eps:use-cropbox" ) ; if ( ( option == ( const char * ) NULL ) || ( IsStringTrue ( option ) != MagickFalse ) ) ( void ) ConcatenateMagickString ( options , "-dEPSCrop<S2SV_blank>" , MaxTextExtent ) ; if ( fitPage != MagickFalse ) ( void ) ConcatenateMagickString ( options , "-dEPSFitPage<S2SV_blank>" , MaxTextExtent ) ; } ( void ) CopyMagickString ( filename , read_info -> filename , MaxTextExtent ) ; ( void ) AcquireUniqueFilename ( filename ) ; ( void ) RelinquishUniqueFileResource ( filename ) ; ( void ) ConcatenateMagickString ( filename , "%d" , MaxTextExtent ) ; ( void ) FormatLocaleString ( command , MaxTextExtent , GetDelegateCommands ( delegate_info ) , read_info -> antialias != MagickFalse ? 4 : 1 , read_info -> antialias != MagickFalse ? 4 : 1 , density , options , filename , postscript_filename , input_filename ) ; options = DestroyString ( options ) ; density = DestroyString ( density ) ; * message = '\\0' ; status = InvokePostscriptDelegate ( read_info -> verbose , command , message , exception ) ; ( void ) InterpretImageFilename ( image_info , image , filename , 1 , read_info -> filename ) ; if ( ( status == MagickFalse ) || ( IsPostscriptRendered ( read_info -> filename ) == MagickFalse ) ) { ( void ) ConcatenateMagickString ( command , "<S2SV_blank>-c<S2SV_blank>showpage" , MaxTextExtent ) ; status = InvokePostscriptDelegate ( read_info -> verbose , command , message , exception ) ; } ( void ) RelinquishUniqueFileResource ( postscript_filename ) ; ( void ) RelinquishUniqueFileResource ( input_filename ) ; postscript_image = ( Image * ) NULL ; if ( status == MagickFalse ) for ( i = 1 ; ; i ++ ) { ( void ) InterpretImageFilename ( image_info , image , filename , ( int ) i , read_info -> filename ) ; if ( IsPostscriptRendered ( read_info -> filename ) == MagickFalse ) break ; ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; } else for ( i = 1 ; ; i ++ ) { ( void ) InterpretImageFilename ( image_info , image , filename , ( int ) i , read_info -> filename ) ; if ( IsPostscriptRendered ( read_info -> filename ) == MagickFalse ) break ; read_info -> blob = NULL ; read_info -> length = 0 ; next = ReadImage ( read_info , exception ) ; ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; if ( next == ( Image * ) NULL ) break ; AppendImageToList ( & postscript_image , next ) ; } ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; read_info = DestroyImageInfo ( read_info ) ; if ( postscript_image == ( Image * ) NULL ) { if ( * message != '\\0' ) ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , DelegateError , "PostscriptDelegateFailed" , "`%s\'" , message ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } if ( LocaleCompare ( postscript_image -> magick , "BMP" ) == 0 ) { Image * cmyk_image ; cmyk_image = ConsolidateCMYKImages ( postscript_image , exception ) ; if ( cmyk_image != ( Image * ) NULL ) { postscript_image = DestroyImageList ( postscript_image ) ; postscript_image = cmyk_image ; } } ( void ) SeekBlob ( image , 0 , SEEK_SET ) ; for ( c = ReadBlobByte ( image ) ; c != EOF ; c = ReadBlobByte ( image ) ) { * p ++ = ( char ) c ; if ( ( strchr ( "\\n\\r%" , c ) == ( char * ) NULL ) && ( ( size_t ) ( p - command ) < ( MaxTextExtent - 1 ) ) ) continue ; * p = '\\0' ; p = command ; if ( LocaleNCompare ( BeginDocument , command , strlen ( BeginDocument ) ) == 0 ) skip = MagickTrue ; if ( LocaleNCompare ( EndDocument , command , strlen ( EndDocument ) ) == 0 ) skip = MagickFalse ; if ( skip != MagickFalse ) continue ; if ( LocaleNCompare ( PostscriptLevel , command , strlen ( PostscriptLevel ) ) == 0 ) { ( void ) SetImageProperty ( image , "ps:Level" , command + 4 ) ; if ( GlobExpression ( command , "*EPSF-*" , MagickTrue ) != MagickFalse ) pages = 1 ; } if ( LocaleNCompare ( LanguageLevel , command , strlen ( LanguageLevel ) ) == 0 ) ( void ) sscanf ( command , LanguageLevel "<S2SV_blank>%lu" , & language_level ) ; if ( LocaleNCompare ( Pages , command , strlen ( Pages ) ) == 0 ) ( void ) sscanf ( command , Pages "<S2SV_blank>%lu" , & pages ) ; if ( LocaleNCompare ( ImageData , command , strlen ( ImageData ) ) == 0 ) ( void ) sscanf ( command , ImageData "<S2SV_blank>%lu<S2SV_blank>%lu" , & columns , & rows ) ; if ( LocaleNCompare ( ICCProfile , command , strlen ( ICCProfile ) ) == 0 ) { unsigned char * datum ; profile = AcquireStringInfo ( MaxTextExtent ) ; datum = GetStringInfoDatum ( profile ) ; for ( i = 0 ; ( c = ProfileInteger ( image , hex_digits ) ) != EOF ; i ++ ) { if ( i >= ( ssize_t ) GetStringInfoLength ( profile ) ) { SetStringInfoLength ( profile , ( size_t ) i << 1 ) ; datum = GetStringInfoDatum ( profile ) ; } datum [ i ] = ( unsigned char ) c ; } SetStringInfoLength ( profile , ( size_t ) i + 1 ) ; ( void ) SetImageProfile ( image , "icc" , profile ) ; profile = DestroyStringInfo ( profile ) ; continue ; } if ( LocaleNCompare ( PhotoshopProfile , command , strlen ( PhotoshopProfile ) ) == 0 ) { unsigned char * p ; count = ( ssize_t ) sscanf ( command , PhotoshopProfile "<S2SV_blank>%lu" , & extent ) ; if ( count != 1 ) continue ; length = extent ; if ( ( MagickSizeType ) length > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , "InsufficientImageDataInFile" ) ; profile = BlobToStringInfo ( ( const void * ) NULL , length ) ; if ( profile != ( StringInfo * ) NULL ) { p = GetStringInfoDatum ( profile ) ; for ( i = 0 ; i < ( ssize_t ) length ; i ++ ) * p ++ = ( unsigned char ) ProfileInteger ( image , hex_digits ) ; ( void ) SetImageProfile ( image , "8bim" , profile ) ; profile = DestroyStringInfo ( profile ) ; } continue ; } if ( LocaleNCompare ( BeginXMPPacket , command , strlen ( BeginXMPPacket ) ) == 0 ) { register size_t i ; p = command ; profile = StringToStringInfo ( command ) ; for ( i = GetStringInfoLength ( profile ) - 1 ; c != EOF ; i ++ ) { SetStringInfoLength ( profile , ( size_t ) ( i + 1 ) ) ; c = ReadBlobByte ( image ) ; GetStringInfoDatum ( profile ) [ i ] = ( unsigned char ) c ; * p ++ = ( char ) c ; if ( ( strchr ( "\\n\\r%" , c ) == ( char * ) NULL ) && ( ( size_t ) ( p - command ) < ( MaxTextExtent - 1 ) ) ) continue ; * p = '\\0' ; p = command ; if ( LocaleNCompare ( EndXMPPacket , command , strlen ( EndXMPPacket ) ) == 0 ) break ; } SetStringInfoLength ( profile , ( size_t ) i ) ; ( void ) SetImageProfile ( image , "xmp" , profile ) ; profile = DestroyStringInfo ( profile ) ; continue ; } } ( void ) CloseBlob ( image ) ; if ( image_info -> number_scenes != 0 ) { Image * clone_image ; register ssize_t i ; for ( i = 0 ; i < ( ssize_t ) image_info -> scene ; i ++ ) { clone_image = CloneImage ( postscript_image , 1 , 1 , MagickTrue , exception ) ; if ( clone_image != ( Image * ) NULL ) PrependImageToList ( & postscript_image , clone_image ) ; } } do { ( void ) CopyMagickString ( postscript_image -> filename , filename , MaxTextExtent ) ; ( void ) CopyMagickString ( postscript_image -> magick , image -> magick , MaxTextExtent ) ; if ( columns != 0 ) postscript_image -> magick_columns = columns ; if ( rows != 0 ) postscript_image -> magick_rows = rows ; postscript_image -> page = page ; ( void ) CloneImageProfiles ( postscript_image , image ) ; ( void ) CloneImageProperties ( postscript_image , image ) ; next = SyncNextImageInList ( postscript_image ) ; if ( next != ( Image * ) NULL ) postscript_image = next ; } while ( next != ( Image * ) NULL ) ; image = DestroyImageList ( image ) ; scene = 0 ; for ( next = GetFirstImageInList ( postscript_image ) ; next != ( Image * ) NULL ; ) { next -> scene = scene ++ ; next = GetNextImageInList ( next ) ; } return ( GetFirstImageInList ( postscript_image ) ) ; }
CWE-119 static MagickPixelPacket * * AcquirePixelThreadSet ( const Image * images ) { const Image * next ; MagickPixelPacket * * pixels ; register ssize_t i , j ; size_t columns , <S2SV_StartBug> number_threads ; <S2SV_EndBug> <S2SV_StartBug> number_threads = ( size_t ) GetMagickResourceLimit ( ThreadResource ) ; <S2SV_EndBug> <S2SV_StartBug> pixels = ( MagickPixelPacket * * ) AcquireQuantumMemory ( number_threads , <S2SV_EndBug> sizeof ( * pixels ) ) ; if ( pixels == ( MagickPixelPacket * * ) NULL ) return ( ( MagickPixelPacket * * ) NULL ) ; <S2SV_StartBug> ( void ) memset ( pixels , 0 , number_threads * sizeof ( * pixels ) ) ; <S2SV_EndBug> columns = images -> columns ; for ( next = images ; next != ( Image * ) NULL ; next = next -> next ) columns = MagickMax ( next -> columns , columns ) ; <S2SV_StartBug> for ( i = 0 ; i < ( ssize_t ) number_threads ; i ++ ) <S2SV_EndBug> { pixels [ i ] = ( MagickPixelPacket * ) AcquireQuantumMemory ( columns , sizeof ( * * pixels ) ) ; if ( pixels [ i ] == ( MagickPixelPacket * ) NULL ) return ( DestroyPixelThreadSet ( pixels ) ) ; for ( j = 0 ; j < ( ssize_t ) columns ; j ++ ) GetMagickPixelPacket ( images , & pixels [ i ] [ j ] ) ; } return ( pixels ) ; }
CWE-119 TEE_Result syscall_asymm_operate ( unsigned long state , const struct utee_attribute * usr_params , size_t num_params , const void * src_data , size_t src_len , void * dst_data , uint64_t * dst_len ) { TEE_Result res ; struct tee_cryp_state * cs ; struct tee_ta_session * sess ; uint64_t dlen64 ; size_t dlen ; struct tee_obj * o ; void * label = NULL ; size_t label_len = 0 ; size_t n ; int salt_len ; TEE_Attribute * params = NULL ; struct user_ta_ctx * utc ; res = tee_ta_get_current_session ( & sess ) ; if ( res != TEE_SUCCESS ) return res ; utc = to_user_ta_ctx ( sess -> ctx ) ; res = tee_svc_cryp_get_state ( sess , tee_svc_uref_to_vaddr ( state ) , & cs ) ; if ( res != TEE_SUCCESS ) return res ; res = tee_mmu_check_access_rights ( utc , TEE_MEMORY_ACCESS_READ | TEE_MEMORY_ACCESS_ANY_OWNER , ( uaddr_t ) src_data , src_len ) ; if ( res != TEE_SUCCESS ) return res ; res = tee_svc_copy_from_user ( & dlen64 , dst_len , sizeof ( dlen64 ) ) ; if ( res != TEE_SUCCESS ) return res ; dlen = dlen64 ; res = tee_mmu_check_access_rights ( utc , TEE_MEMORY_ACCESS_READ | TEE_MEMORY_ACCESS_WRITE | TEE_MEMORY_ACCESS_ANY_OWNER , ( uaddr_t ) dst_data , dlen ) ; if ( res != TEE_SUCCESS ) return res ; <S2SV_StartBug> params = malloc ( sizeof ( TEE_Attribute ) * num_params ) ; <S2SV_EndBug> if ( ! params ) return TEE_ERROR_OUT_OF_MEMORY ; res = copy_in_attrs ( utc , usr_params , num_params , params ) ; if ( res != TEE_SUCCESS ) goto out ; res = tee_obj_get ( utc , cs -> key1 , & o ) ; if ( res != TEE_SUCCESS ) goto out ; if ( ( o -> info . handleFlags & TEE_HANDLE_FLAG_INITIALIZED ) == 0 ) { res = TEE_ERROR_GENERIC ; goto out ; } switch ( cs -> algo ) { case TEE_ALG_RSA_NOPAD : if ( cs -> mode == TEE_MODE_ENCRYPT ) { res = crypto_acipher_rsanopad_encrypt ( o -> attr , src_data , src_len , dst_data , & dlen ) ; } else if ( cs -> mode == TEE_MODE_DECRYPT ) { res = crypto_acipher_rsanopad_decrypt ( o -> attr , src_data , src_len , dst_data , & dlen ) ; } else { res = TEE_ERROR_GENERIC ; } break ; case TEE_ALG_RSAES_PKCS1_V1_5 : case TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA1 : case TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA224 : case TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA256 : case TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA384 : case TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA512 : for ( n = 0 ; n < num_params ; n ++ ) { if ( params [ n ] . attributeID == TEE_ATTR_RSA_OAEP_LABEL ) { label = params [ n ] . content . ref . buffer ; label_len = params [ n ] . content . ref . length ; break ; } } if ( cs -> mode == TEE_MODE_ENCRYPT ) { res = crypto_acipher_rsaes_encrypt ( cs -> algo , o -> attr , label , label_len , src_data , src_len , dst_data , & dlen ) ; } else if ( cs -> mode == TEE_MODE_DECRYPT ) { res = crypto_acipher_rsaes_decrypt ( cs -> algo , o -> attr , label , label_len , src_data , src_len , dst_data , & dlen ) ; } else { res = TEE_ERROR_BAD_PARAMETERS ; } break ; # if defined ( CFG_CRYPTO_RSASSA_NA1 ) case TEE_ALG_RSASSA_PKCS1_V1_5 : # endif case TEE_ALG_RSASSA_PKCS1_V1_5_MD5 : case TEE_ALG_RSASSA_PKCS1_V1_5_SHA1 : case TEE_ALG_RSASSA_PKCS1_V1_5_SHA224 : case TEE_ALG_RSASSA_PKCS1_V1_5_SHA256 : case TEE_ALG_RSASSA_PKCS1_V1_5_SHA384 : case TEE_ALG_RSASSA_PKCS1_V1_5_SHA512 : case TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA1 : case TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA224 : case TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA256 : case TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA384 : case TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA512 : if ( cs -> mode != TEE_MODE_SIGN ) { res = TEE_ERROR_BAD_PARAMETERS ; break ; } salt_len = pkcs1_get_salt_len ( params , num_params , src_len ) ; res = crypto_acipher_rsassa_sign ( cs -> algo , o -> attr , salt_len , src_data , src_len , dst_data , & dlen ) ; break ; case TEE_ALG_DSA_SHA1 : case TEE_ALG_DSA_SHA224 : case TEE_ALG_DSA_SHA256 : res = crypto_acipher_dsa_sign ( cs -> algo , o -> attr , src_data , src_len , dst_data , & dlen ) ; break ; case TEE_ALG_ECDSA_P192 : case TEE_ALG_ECDSA_P224 : case TEE_ALG_ECDSA_P256 : case TEE_ALG_ECDSA_P384 : case TEE_ALG_ECDSA_P521 : res = crypto_acipher_ecc_sign ( cs -> algo , o -> attr , src_data , src_len , dst_data , & dlen ) ; break ; default : res = TEE_ERROR_BAD_PARAMETERS ; break ; } out : free ( params ) ; if ( res == TEE_SUCCESS || res == TEE_ERROR_SHORT_BUFFER ) { TEE_Result res2 ; dlen64 = dlen ; res2 = tee_svc_copy_to_user ( dst_len , & dlen64 , sizeof ( * dst_len ) ) ; if ( res2 != TEE_SUCCESS ) return res2 ; } return res ; }
CWE-119 TEE_Result syscall_asymm_verify ( unsigned long state , const struct utee_attribute * usr_params , size_t num_params , const void * data , size_t data_len , const void * sig , size_t sig_len ) { TEE_Result res ; struct tee_cryp_state * cs ; struct tee_ta_session * sess ; struct tee_obj * o ; size_t hash_size ; int salt_len = 0 ; TEE_Attribute * params = NULL ; uint32_t hash_algo ; struct user_ta_ctx * utc ; res = tee_ta_get_current_session ( & sess ) ; if ( res != TEE_SUCCESS ) return res ; utc = to_user_ta_ctx ( sess -> ctx ) ; res = tee_svc_cryp_get_state ( sess , tee_svc_uref_to_vaddr ( state ) , & cs ) ; if ( res != TEE_SUCCESS ) return res ; if ( cs -> mode != TEE_MODE_VERIFY ) return TEE_ERROR_BAD_PARAMETERS ; res = tee_mmu_check_access_rights ( utc , TEE_MEMORY_ACCESS_READ | TEE_MEMORY_ACCESS_ANY_OWNER , ( uaddr_t ) data , data_len ) ; if ( res != TEE_SUCCESS ) return res ; res = tee_mmu_check_access_rights ( utc , TEE_MEMORY_ACCESS_READ | TEE_MEMORY_ACCESS_ANY_OWNER , ( uaddr_t ) sig , sig_len ) ; if ( res != TEE_SUCCESS ) return res ; <S2SV_StartBug> params = malloc ( sizeof ( TEE_Attribute ) * num_params ) ; <S2SV_EndBug> if ( ! params ) return TEE_ERROR_OUT_OF_MEMORY ; res = copy_in_attrs ( utc , usr_params , num_params , params ) ; if ( res != TEE_SUCCESS ) goto out ; res = tee_obj_get ( utc , cs -> key1 , & o ) ; if ( res != TEE_SUCCESS ) goto out ; if ( ( o -> info . handleFlags & TEE_HANDLE_FLAG_INITIALIZED ) == 0 ) { res = TEE_ERROR_BAD_PARAMETERS ; goto out ; } switch ( TEE_ALG_GET_MAIN_ALG ( cs -> algo ) ) { case TEE_MAIN_ALGO_RSA : if ( cs -> algo != TEE_ALG_RSASSA_PKCS1_V1_5 ) { hash_algo = TEE_DIGEST_HASH_TO_ALGO ( cs -> algo ) ; res = tee_hash_get_digest_size ( hash_algo , & hash_size ) ; if ( res != TEE_SUCCESS ) break ; if ( data_len != hash_size ) { res = TEE_ERROR_BAD_PARAMETERS ; break ; } salt_len = pkcs1_get_salt_len ( params , num_params , hash_size ) ; } res = crypto_acipher_rsassa_verify ( cs -> algo , o -> attr , salt_len , data , data_len , sig , sig_len ) ; break ; case TEE_MAIN_ALGO_DSA : hash_algo = TEE_DIGEST_HASH_TO_ALGO ( cs -> algo ) ; res = tee_hash_get_digest_size ( hash_algo , & hash_size ) ; if ( res != TEE_SUCCESS ) break ; if ( data_len > hash_size ) { res = TEE_ERROR_BAD_PARAMETERS ; break ; } res = crypto_acipher_dsa_verify ( cs -> algo , o -> attr , data , data_len , sig , sig_len ) ; break ; case TEE_MAIN_ALGO_ECDSA : res = crypto_acipher_ecc_verify ( cs -> algo , o -> attr , data , data_len , sig , sig_len ) ; break ; default : res = TEE_ERROR_NOT_SUPPORTED ; } out : free ( params ) ; return res ; }
CWE-189 static struct mobj * alloc_ta_mem ( size_t size ) { # ifdef CFG_PAGED_USER_TA return mobj_paged_alloc ( size ) ; # else struct mobj * mobj = mobj_mm_alloc ( mobj_sec_ddr , size , & tee_mm_sec_ddr ) ; <S2SV_StartBug> if ( mobj ) <S2SV_EndBug> <S2SV_StartBug> memset ( mobj_get_va ( mobj , 0 ) , 0 , size ) ; <S2SV_EndBug> return mobj ; # endif }
CWE-20 TEE_Result tee_mmu_check_access_rights ( const struct user_ta_ctx * utc , uint32_t flags , uaddr_t uaddr , size_t len ) { uaddr_t a ; <S2SV_StartBug> size_t addr_incr = MIN ( CORE_MMU_USER_CODE_SIZE , <S2SV_EndBug> CORE_MMU_USER_PARAM_SIZE ) ; <S2SV_StartBug> if ( ADD_OVERFLOW ( uaddr , len , & a ) ) <S2SV_EndBug> return TEE_ERROR_ACCESS_DENIED ; if ( ( flags & TEE_MEMORY_ACCESS_NONSECURE ) && ( flags & TEE_MEMORY_ACCESS_SECURE ) ) return TEE_ERROR_ACCESS_DENIED ; if ( ! ( flags & TEE_MEMORY_ACCESS_ANY_OWNER ) && ! tee_mmu_is_vbuf_inside_ta_private ( utc , ( void * ) uaddr , len ) ) return TEE_ERROR_ACCESS_DENIED ; <S2SV_StartBug> for ( a = uaddr ; a < ( uaddr + len ) ; a += addr_incr ) { <S2SV_EndBug> uint32_t attr ; TEE_Result res ; res = tee_mmu_user_va2pa_attr ( utc , ( void * ) a , NULL , & attr ) ; if ( res != TEE_SUCCESS ) return res ; if ( ( flags & TEE_MEMORY_ACCESS_NONSECURE ) && ( attr & TEE_MATTR_SECURE ) ) return TEE_ERROR_ACCESS_DENIED ; if ( ( flags & TEE_MEMORY_ACCESS_SECURE ) && ! ( attr & TEE_MATTR_SECURE ) ) return TEE_ERROR_ACCESS_DENIED ; if ( ( flags & TEE_MEMORY_ACCESS_WRITE ) && ! ( attr & TEE_MATTR_UW ) ) return TEE_ERROR_ACCESS_DENIED ; if ( ( flags & TEE_MEMORY_ACCESS_READ ) && ! ( attr & TEE_MATTR_UR ) ) return TEE_ERROR_ACCESS_DENIED ; } return TEE_SUCCESS ; }
CWE-119 TEE_Result syscall_cryp_derive_key ( unsigned long state , const struct utee_attribute * usr_params , unsigned long param_count , unsigned long derived_key ) { TEE_Result res = TEE_ERROR_NOT_SUPPORTED ; struct tee_ta_session * sess ; struct tee_obj * ko ; struct tee_obj * so ; struct tee_cryp_state * cs ; struct tee_cryp_obj_secret * sk ; const struct tee_cryp_obj_type_props * type_props ; TEE_Attribute * params = NULL ; struct user_ta_ctx * utc ; res = tee_ta_get_current_session ( & sess ) ; if ( res != TEE_SUCCESS ) return res ; utc = to_user_ta_ctx ( sess -> ctx ) ; res = tee_svc_cryp_get_state ( sess , tee_svc_uref_to_vaddr ( state ) , & cs ) ; if ( res != TEE_SUCCESS ) return res ; <S2SV_StartBug> params = malloc ( sizeof ( TEE_Attribute ) * param_count ) ; <S2SV_EndBug> if ( ! params ) return TEE_ERROR_OUT_OF_MEMORY ; res = copy_in_attrs ( utc , usr_params , param_count , params ) ; if ( res != TEE_SUCCESS ) goto out ; res = tee_obj_get ( utc , cs -> key1 , & ko ) ; if ( res != TEE_SUCCESS ) goto out ; res = tee_obj_get ( utc , tee_svc_uref_to_vaddr ( derived_key ) , & so ) ; if ( res != TEE_SUCCESS ) goto out ; sk = so -> attr ; type_props = tee_svc_find_type_props ( so -> info . objectType ) ; if ( ! type_props ) { res = TEE_ERROR_NOT_SUPPORTED ; goto out ; } if ( cs -> algo == TEE_ALG_DH_DERIVE_SHARED_SECRET ) { size_t alloc_size ; struct bignum * pub ; struct bignum * ss ; if ( param_count != 1 || params [ 0 ] . attributeID != TEE_ATTR_DH_PUBLIC_VALUE ) { res = TEE_ERROR_BAD_PARAMETERS ; goto out ; } alloc_size = params [ 0 ] . content . ref . length * 8 ; pub = crypto_bignum_allocate ( alloc_size ) ; ss = crypto_bignum_allocate ( alloc_size ) ; if ( pub && ss ) { crypto_bignum_bin2bn ( params [ 0 ] . content . ref . buffer , params [ 0 ] . content . ref . length , pub ) ; res = crypto_acipher_dh_shared_secret ( ko -> attr , pub , ss ) ; if ( res == TEE_SUCCESS ) { sk -> key_size = crypto_bignum_num_bytes ( ss ) ; crypto_bignum_bn2bin ( ss , ( uint8_t * ) ( sk + 1 ) ) ; so -> info . handleFlags |= TEE_HANDLE_FLAG_INITIALIZED ; set_attribute ( so , type_props , TEE_ATTR_SECRET_VALUE ) ; } } else { res = TEE_ERROR_OUT_OF_MEMORY ; } crypto_bignum_free ( pub ) ; crypto_bignum_free ( ss ) ; } else if ( TEE_ALG_GET_MAIN_ALG ( cs -> algo ) == TEE_MAIN_ALGO_ECDH ) { size_t alloc_size ; struct ecc_public_key key_public ; uint8_t * pt_secret ; unsigned long pt_secret_len ; if ( param_count != 2 || params [ 0 ] . attributeID != TEE_ATTR_ECC_PUBLIC_VALUE_X || params [ 1 ] . attributeID != TEE_ATTR_ECC_PUBLIC_VALUE_Y ) { res = TEE_ERROR_BAD_PARAMETERS ; goto out ; } switch ( cs -> algo ) { case TEE_ALG_ECDH_P192 : alloc_size = 192 ; break ; case TEE_ALG_ECDH_P224 : alloc_size = 224 ; break ; case TEE_ALG_ECDH_P256 : alloc_size = 256 ; break ; case TEE_ALG_ECDH_P384 : alloc_size = 384 ; break ; case TEE_ALG_ECDH_P521 : alloc_size = 521 ; break ; default : res = TEE_ERROR_NOT_IMPLEMENTED ; goto out ; } res = crypto_acipher_alloc_ecc_public_key ( & key_public , alloc_size ) ; if ( res != TEE_SUCCESS ) goto out ; key_public . curve = ( ( struct ecc_keypair * ) ko -> attr ) -> curve ; crypto_bignum_bin2bn ( params [ 0 ] . content . ref . buffer , params [ 0 ] . content . ref . length , key_public . x ) ; crypto_bignum_bin2bn ( params [ 1 ] . content . ref . buffer , params [ 1 ] . content . ref . length , key_public . y ) ; pt_secret = ( uint8_t * ) ( sk + 1 ) ; pt_secret_len = sk -> alloc_size ; res = crypto_acipher_ecc_shared_secret ( ko -> attr , & key_public , pt_secret , & pt_secret_len ) ; if ( res == TEE_SUCCESS ) { sk -> key_size = pt_secret_len ; so -> info . handleFlags |= TEE_HANDLE_FLAG_INITIALIZED ; set_attribute ( so , type_props , TEE_ATTR_SECRET_VALUE ) ; } crypto_acipher_free_ecc_public_key ( & key_public ) ; } # if defined ( CFG_CRYPTO_HKDF ) else if ( TEE_ALG_GET_MAIN_ALG ( cs -> algo ) == TEE_MAIN_ALGO_HKDF ) { void * salt , * info ; size_t salt_len , info_len , okm_len ; uint32_t hash_id = TEE_ALG_GET_DIGEST_HASH ( cs -> algo ) ; struct tee_cryp_obj_secret * ik = ko -> attr ; const uint8_t * ikm = ( const uint8_t * ) ( ik + 1 ) ; res = get_hkdf_params ( params , param_count , & salt , & salt_len , & info , & info_len , & okm_len ) ; if ( res != TEE_SUCCESS ) goto out ; if ( okm_len > ik -> alloc_size ) { res = TEE_ERROR_BAD_PARAMETERS ; goto out ; } res = tee_cryp_hkdf ( hash_id , ikm , ik -> key_size , salt , salt_len , info , info_len , ( uint8_t * ) ( sk + 1 ) , okm_len ) ; if ( res == TEE_SUCCESS ) { sk -> key_size = okm_len ; so -> info . handleFlags |= TEE_HANDLE_FLAG_INITIALIZED ; set_attribute ( so , type_props , TEE_ATTR_SECRET_VALUE ) ; } } # endif # if defined ( CFG_CRYPTO_CONCAT_KDF ) else if ( TEE_ALG_GET_MAIN_ALG ( cs -> algo ) == TEE_MAIN_ALGO_CONCAT_KDF ) { void * info ; size_t info_len , derived_key_len ; uint32_t hash_id = TEE_ALG_GET_DIGEST_HASH ( cs -> algo ) ; struct tee_cryp_obj_secret * ss = ko -> attr ; const uint8_t * shared_secret = ( const uint8_t * ) ( ss + 1 ) ; res = get_concat_kdf_params ( params , param_count , & info , & info_len , & derived_key_len ) ; if ( res != TEE_SUCCESS ) goto out ; if ( derived_key_len > ss -> alloc_size ) { res = TEE_ERROR_BAD_PARAMETERS ; goto out ; } res = tee_cryp_concat_kdf ( hash_id , shared_secret , ss -> key_size , info , info_len , ( uint8_t * ) ( sk + 1 ) , derived_key_len ) ; if ( res == TEE_SUCCESS ) { sk -> key_size = derived_key_len ; so -> info . handleFlags |= TEE_HANDLE_FLAG_INITIALIZED ; set_attribute ( so , type_props , TEE_ATTR_SECRET_VALUE ) ; } } # endif # if defined ( CFG_CRYPTO_PBKDF2 ) else if ( TEE_ALG_GET_MAIN_ALG ( cs -> algo ) == TEE_MAIN_ALGO_PBKDF2 ) { void * salt ; size_t salt_len , iteration_count , derived_key_len ; uint32_t hash_id = TEE_ALG_GET_DIGEST_HASH ( cs -> algo ) ; struct tee_cryp_obj_secret * ss = ko -> attr ; const uint8_t * password = ( const uint8_t * ) ( ss + 1 ) ; res = get_pbkdf2_params ( params , param_count , & salt , & salt_len , & derived_key_len , & iteration_count ) ; if ( res != TEE_SUCCESS ) goto out ; if ( derived_key_len > ss -> alloc_size ) { res = TEE_ERROR_BAD_PARAMETERS ; goto out ; } res = tee_cryp_pbkdf2 ( hash_id , password , ss -> key_size , salt , salt_len , iteration_count , ( uint8_t * ) ( sk + 1 ) , derived_key_len ) ; if ( res == TEE_SUCCESS ) { sk -> key_size = derived_key_len ; so -> info . handleFlags |= TEE_HANDLE_FLAG_INITIALIZED ; set_attribute ( so , type_props , TEE_ATTR_SECRET_VALUE ) ; } } # endif else res = TEE_ERROR_NOT_SUPPORTED ; out : free ( params ) ; return res ; }
CWE-119 TEE_Result syscall_obj_generate_key ( unsigned long obj , unsigned long key_size , const struct utee_attribute * usr_params , unsigned long param_count ) { TEE_Result res ; struct tee_ta_session * sess ; const struct tee_cryp_obj_type_props * type_props ; struct tee_obj * o ; struct tee_cryp_obj_secret * key ; size_t byte_size ; TEE_Attribute * params = NULL ; res = tee_ta_get_current_session ( & sess ) ; if ( res != TEE_SUCCESS ) return res ; res = tee_obj_get ( to_user_ta_ctx ( sess -> ctx ) , tee_svc_uref_to_vaddr ( obj ) , & o ) ; if ( res != TEE_SUCCESS ) return res ; if ( ( o -> info . handleFlags & TEE_HANDLE_FLAG_PERSISTENT ) != 0 ) return TEE_ERROR_BAD_STATE ; if ( ( o -> info . handleFlags & TEE_HANDLE_FLAG_INITIALIZED ) != 0 ) return TEE_ERROR_BAD_STATE ; type_props = tee_svc_find_type_props ( o -> info . objectType ) ; if ( ! type_props ) return TEE_ERROR_NOT_SUPPORTED ; if ( key_size % type_props -> quanta != 0 ) return TEE_ERROR_NOT_SUPPORTED ; if ( key_size < type_props -> min_size ) return TEE_ERROR_NOT_SUPPORTED ; if ( key_size > type_props -> max_size ) return TEE_ERROR_NOT_SUPPORTED ; <S2SV_StartBug> params = malloc ( sizeof ( TEE_Attribute ) * param_count ) ; <S2SV_EndBug> if ( ! params ) return TEE_ERROR_OUT_OF_MEMORY ; res = copy_in_attrs ( to_user_ta_ctx ( sess -> ctx ) , usr_params , param_count , params ) ; if ( res != TEE_SUCCESS ) goto out ; res = tee_svc_cryp_check_attr ( ATTR_USAGE_GENERATE_KEY , type_props , params , param_count ) ; if ( res != TEE_SUCCESS ) goto out ; switch ( o -> info . objectType ) { case TEE_TYPE_AES : case TEE_TYPE_DES : case TEE_TYPE_DES3 : case TEE_TYPE_HMAC_MD5 : case TEE_TYPE_HMAC_SHA1 : case TEE_TYPE_HMAC_SHA224 : case TEE_TYPE_HMAC_SHA256 : case TEE_TYPE_HMAC_SHA384 : case TEE_TYPE_HMAC_SHA512 : case TEE_TYPE_GENERIC_SECRET : byte_size = key_size / 8 ; if ( o -> info . objectType == TEE_TYPE_DES || o -> info . objectType == TEE_TYPE_DES3 ) { byte_size = ( key_size + key_size / 7 ) / 8 ; } key = ( struct tee_cryp_obj_secret * ) o -> attr ; if ( byte_size > key -> alloc_size ) { res = TEE_ERROR_EXCESS_DATA ; goto out ; } res = crypto_rng_read ( ( void * ) ( key + 1 ) , byte_size ) ; if ( res != TEE_SUCCESS ) goto out ; key -> key_size = byte_size ; o -> have_attrs = ( 1 << type_props -> num_type_attrs ) - 1 ; break ; case TEE_TYPE_RSA_KEYPAIR : res = tee_svc_obj_generate_key_rsa ( o , type_props , key_size , params , param_count ) ; if ( res != TEE_SUCCESS ) goto out ; break ; case TEE_TYPE_DSA_KEYPAIR : res = tee_svc_obj_generate_key_dsa ( o , type_props , key_size ) ; if ( res != TEE_SUCCESS ) goto out ; break ; case TEE_TYPE_DH_KEYPAIR : res = tee_svc_obj_generate_key_dh ( o , type_props , key_size , params , param_count ) ; if ( res != TEE_SUCCESS ) goto out ; break ; case TEE_TYPE_ECDSA_KEYPAIR : case TEE_TYPE_ECDH_KEYPAIR : res = tee_svc_obj_generate_key_ecc ( o , type_props , key_size , params , param_count ) ; if ( res != TEE_SUCCESS ) goto out ; break ; default : res = TEE_ERROR_BAD_FORMAT ; } out : free ( params ) ; if ( res == TEE_SUCCESS ) { o -> info . keySize = key_size ; o -> info . handleFlags |= TEE_HANDLE_FLAG_INITIALIZED ; } return res ; }
CWE-119 TEE_Result syscall_cryp_obj_populate ( unsigned long obj , struct utee_attribute * usr_attrs , unsigned long attr_count ) { TEE_Result res ; struct tee_ta_session * sess ; struct tee_obj * o ; const struct tee_cryp_obj_type_props * type_props ; TEE_Attribute * attrs = NULL ; res = tee_ta_get_current_session ( & sess ) ; if ( res != TEE_SUCCESS ) return res ; res = tee_obj_get ( to_user_ta_ctx ( sess -> ctx ) , tee_svc_uref_to_vaddr ( obj ) , & o ) ; if ( res != TEE_SUCCESS ) return res ; if ( ( o -> info . handleFlags & TEE_HANDLE_FLAG_PERSISTENT ) != 0 ) return TEE_ERROR_BAD_PARAMETERS ; if ( ( o -> info . handleFlags & TEE_HANDLE_FLAG_INITIALIZED ) != 0 ) return TEE_ERROR_BAD_PARAMETERS ; type_props = tee_svc_find_type_props ( o -> info . objectType ) ; if ( ! type_props ) return TEE_ERROR_NOT_IMPLEMENTED ; <S2SV_StartBug> attrs = malloc ( sizeof ( TEE_Attribute ) * attr_count ) ; <S2SV_EndBug> if ( ! attrs ) return TEE_ERROR_OUT_OF_MEMORY ; res = copy_in_attrs ( to_user_ta_ctx ( sess -> ctx ) , usr_attrs , attr_count , attrs ) ; if ( res != TEE_SUCCESS ) goto out ; res = tee_svc_cryp_check_attr ( ATTR_USAGE_POPULATE , type_props , attrs , attr_count ) ; if ( res != TEE_SUCCESS ) goto out ; res = tee_svc_cryp_obj_populate_type ( o , type_props , attrs , attr_count ) ; if ( res == TEE_SUCCESS ) o -> info . handleFlags |= TEE_HANDLE_FLAG_INITIALIZED ; out : free ( attrs ) ; return res ; }
CWE-119 static TEE_Result tee_svc_copy_param ( struct tee_ta_session * sess , struct tee_ta_session * called_sess , struct utee_params * callee_params , struct tee_ta_param * param , void * tmp_buf_va [ TEE_NUM_PARAMS ] , struct mobj * * mobj_tmp ) { size_t n ; TEE_Result res ; size_t req_mem = 0 ; size_t s ; uint8_t * dst = 0 ; bool ta_private_memref [ TEE_NUM_PARAMS ] ; struct user_ta_ctx * utc = to_user_ta_ctx ( sess -> ctx ) ; void * va ; size_t dst_offs ; if ( ! callee_params ) { memset ( param , 0 , sizeof ( * param ) ) ; } else { res = tee_mmu_check_access_rights ( utc , TEE_MEMORY_ACCESS_READ | TEE_MEMORY_ACCESS_ANY_OWNER , ( uaddr_t ) callee_params , sizeof ( struct utee_params ) ) ; if ( res != TEE_SUCCESS ) return res ; <S2SV_StartBug> utee_param_to_param ( param , callee_params ) ; <S2SV_EndBug> } if ( called_sess && is_pseudo_ta_ctx ( called_sess -> ctx ) ) { return TEE_SUCCESS ; } for ( n = 0 ; n < TEE_NUM_PARAMS ; n ++ ) { ta_private_memref [ n ] = false ; switch ( TEE_PARAM_TYPE_GET ( param -> types , n ) ) { case TEE_PARAM_TYPE_MEMREF_INPUT : case TEE_PARAM_TYPE_MEMREF_OUTPUT : case TEE_PARAM_TYPE_MEMREF_INOUT : va = ( void * ) param -> u [ n ] . mem . offs ; s = param -> u [ n ] . mem . size ; if ( ! va ) { if ( s ) return TEE_ERROR_BAD_PARAMETERS ; break ; } if ( tee_mmu_is_vbuf_inside_ta_private ( utc , va , s ) ) { s = ROUNDUP ( s , sizeof ( uint32_t ) ) ; if ( ADD_OVERFLOW ( req_mem , s , & req_mem ) ) return TEE_ERROR_BAD_PARAMETERS ; ta_private_memref [ n ] = true ; break ; } res = tee_mmu_vbuf_to_mobj_offs ( utc , va , s , & param -> u [ n ] . mem . mobj , & param -> u [ n ] . mem . offs ) ; if ( res != TEE_SUCCESS ) return res ; break ; default : break ; } } if ( req_mem == 0 ) return TEE_SUCCESS ; res = alloc_temp_sec_mem ( req_mem , mobj_tmp , & dst ) ; if ( res != TEE_SUCCESS ) return res ; dst_offs = 0 ; for ( n = 0 ; n < TEE_NUM_PARAMS ; n ++ ) { if ( ! ta_private_memref [ n ] ) continue ; s = ROUNDUP ( param -> u [ n ] . mem . size , sizeof ( uint32_t ) ) ; switch ( TEE_PARAM_TYPE_GET ( param -> types , n ) ) { case TEE_PARAM_TYPE_MEMREF_INPUT : case TEE_PARAM_TYPE_MEMREF_INOUT : va = ( void * ) param -> u [ n ] . mem . offs ; if ( va ) { res = tee_svc_copy_from_user ( dst , va , param -> u [ n ] . mem . size ) ; if ( res != TEE_SUCCESS ) return res ; param -> u [ n ] . mem . offs = dst_offs ; param -> u [ n ] . mem . mobj = * mobj_tmp ; tmp_buf_va [ n ] = dst ; dst += s ; dst_offs += s ; } break ; case TEE_PARAM_TYPE_MEMREF_OUTPUT : va = ( void * ) param -> u [ n ] . mem . offs ; if ( va ) { param -> u [ n ] . mem . offs = dst_offs ; param -> u [ n ] . mem . mobj = * mobj_tmp ; tmp_buf_va [ n ] = dst ; dst += s ; dst_offs += s ; } break ; default : continue ; } } return TEE_SUCCESS ; }
CWE-119 <S2SV_StartBug> static void utee_param_to_param ( struct tee_ta_param * p , struct utee_params * up ) <S2SV_EndBug> { size_t n ; uint32_t types = up -> types ; p -> types = types ; for ( n = 0 ; n < TEE_NUM_PARAMS ; n ++ ) { uintptr_t a = up -> vals [ n * 2 ] ; size_t b = up -> vals [ n * 2 + 1 ] ; <S2SV_StartBug> switch ( TEE_PARAM_TYPE_GET ( types , n ) ) { <S2SV_EndBug> <S2SV_StartBug> case TEE_PARAM_TYPE_MEMREF_INPUT : <S2SV_EndBug> case TEE_PARAM_TYPE_MEMREF_OUTPUT : case TEE_PARAM_TYPE_MEMREF_INOUT : p -> u [ n ] . mem . mobj = & mobj_virt ; p -> u [ n ] . mem . offs = a ; p -> u [ n ] . mem . size = b ; <S2SV_StartBug> break ; <S2SV_EndBug> case TEE_PARAM_TYPE_VALUE_INPUT : case TEE_PARAM_TYPE_VALUE_INOUT : p -> u [ n ] . val . a = a ; p -> u [ n ] . val . b = b ; break ; default : memset ( & p -> u [ n ] , 0 , sizeof ( p -> u [ n ] ) ) ; break ; } <S2SV_StartBug> } <S2SV_EndBug> }
CWE-119 static TEE_Result set_rmem_param ( const struct optee_msg_param_rmem * rmem , struct param_mem * mem ) <S2SV_StartBug> { <S2SV_EndBug> uint64_t shm_ref = READ_ONCE ( rmem -> shm_ref ) ; mem -> mobj = mobj_reg_shm_get_by_cookie ( shm_ref ) ; if ( ! mem -> mobj ) return TEE_ERROR_BAD_PARAMETERS ; mem -> offs = READ_ONCE ( rmem -> offs ) ; mem -> size = READ_ONCE ( rmem -> size ) ; <S2SV_StartBug> return TEE_SUCCESS ; <S2SV_EndBug> }
CWE-119 static int decode_bit_string ( const u8 * inbuf , size_t inlen , void * outbuf , size_t outlen , int invert ) { const u8 * in = inbuf ; u8 * out = ( u8 * ) outbuf ; <S2SV_StartBug> int zero_bits = * in & 0x07 ; <S2SV_EndBug> <S2SV_StartBug> size_t octets_left = inlen - 1 ; <S2SV_EndBug> <S2SV_StartBug> int i , count = 0 ; <S2SV_EndBug> memset ( outbuf , 0 , outlen ) ; in ++ ; if ( outlen < octets_left ) return SC_ERROR_BUFFER_TOO_SMALL ; if ( inlen < 1 ) return SC_ERROR_INVALID_ASN1_OBJECT ; while ( octets_left ) { int bits_to_go ; * out = 0 ; if ( octets_left == 1 ) bits_to_go = 8 - zero_bits ; else bits_to_go = 8 ; if ( invert ) for ( i = 0 ; i < bits_to_go ; i ++ ) { * out |= ( ( * in >> ( 7 - i ) ) & 1 ) << i ; } else { * out = * in ; } out ++ ; in ++ ; octets_left -- ; count ++ ; } return ( count * 8 ) - zero_bits ; }
CWE-119 static int asn1_decode_entry ( sc_context_t * ctx , struct sc_asn1_entry * entry , const u8 * obj , size_t objlen , int depth ) { void * parm = entry -> parm ; int ( * callback_func ) ( sc_context_t * nctx , void * arg , const u8 * nobj , size_t nobjlen , int ndepth ) ; size_t * len = ( size_t * ) entry -> arg ; int r = 0 ; callback_func = parm ; sc_debug ( ctx , SC_LOG_DEBUG_ASN1 , "%*.*sdecoding<S2SV_blank>\'%s\',<S2SV_blank>raw<S2SV_blank>data:%s%s\\n" , depth , depth , "" , entry -> name , sc_dump_hex ( obj , objlen > 16 ? 16 : objlen ) , objlen > 16 ? "..." : "" ) ; switch ( entry -> type ) { case SC_ASN1_STRUCT : if ( parm != NULL ) r = asn1_decode ( ctx , ( struct sc_asn1_entry * ) parm , obj , objlen , NULL , NULL , 0 , depth + 1 ) ; break ; case SC_ASN1_NULL : break ; case SC_ASN1_BOOLEAN : if ( parm != NULL ) { if ( objlen != 1 ) { sc_debug ( ctx , SC_LOG_DEBUG_ASN1 , "invalid<S2SV_blank>ASN.1<S2SV_blank>object<S2SV_blank>length:<S2SV_blank>%" SC_FORMAT_LEN_SIZE_T "u\\n" , objlen ) ; r = SC_ERROR_INVALID_ASN1_OBJECT ; } else * ( ( int * ) parm ) = obj [ 0 ] ? 1 : 0 ; } break ; case SC_ASN1_INTEGER : case SC_ASN1_ENUMERATED : if ( parm != NULL ) { r = sc_asn1_decode_integer ( obj , objlen , ( int * ) entry -> parm ) ; sc_debug ( ctx , SC_LOG_DEBUG_ASN1 , "%*.*sdecoding<S2SV_blank>\'%s\'<S2SV_blank>returned<S2SV_blank>%d\\n" , depth , depth , "" , entry -> name , * ( ( int * ) entry -> parm ) ) ; } break ; case SC_ASN1_BIT_STRING_NI : case SC_ASN1_BIT_STRING : if ( parm != NULL ) { int invert = entry -> type == SC_ASN1_BIT_STRING ? 1 : 0 ; assert ( len != NULL ) ; if ( objlen < 1 ) { r = SC_ERROR_INVALID_ASN1_OBJECT ; break ; } if ( entry -> flags & SC_ASN1_ALLOC ) { u8 * * buf = ( u8 * * ) parm ; * buf = malloc ( objlen - 1 ) ; if ( * buf == NULL ) { r = SC_ERROR_OUT_OF_MEMORY ; break ; } * len = objlen - 1 ; parm = * buf ; } r = decode_bit_string ( obj , objlen , ( u8 * ) parm , * len , invert ) ; if ( r >= 0 ) { * len = r ; r = 0 ; } } break ; case SC_ASN1_BIT_FIELD : if ( parm != NULL ) r = decode_bit_field ( obj , objlen , ( u8 * ) parm , * len ) ; break ; case SC_ASN1_OCTET_STRING : if ( parm != NULL ) { size_t c ; assert ( len != NULL ) ; if ( ( entry -> flags & SC_ASN1_UNSIGNED ) <S2SV_StartBug> && obj [ 0 ] == 0x00 && objlen > 1 ) { <S2SV_EndBug> objlen -- ; obj ++ ; } if ( entry -> flags & SC_ASN1_ALLOC ) { u8 * * buf = ( u8 * * ) parm ; * buf = malloc ( objlen ) ; if ( * buf == NULL ) { r = SC_ERROR_OUT_OF_MEMORY ; break ; } c = * len = objlen ; parm = * buf ; } else c = objlen > * len ? * len : objlen ; memcpy ( parm , obj , c ) ; * len = c ; } break ; case SC_ASN1_GENERALIZEDTIME : if ( parm != NULL ) { size_t c ; assert ( len != NULL ) ; if ( entry -> flags & SC_ASN1_ALLOC ) { u8 * * buf = ( u8 * * ) parm ; * buf = malloc ( objlen ) ; if ( * buf == NULL ) { r = SC_ERROR_OUT_OF_MEMORY ; break ; } c = * len = objlen ; parm = * buf ; } else c = objlen > * len ? * len : objlen ; memcpy ( parm , obj , c ) ; * len = c ; } break ; case SC_ASN1_OBJECT : if ( parm != NULL ) r = sc_asn1_decode_object_id ( obj , objlen , ( struct sc_object_id * ) parm ) ; break ; case SC_ASN1_PRINTABLESTRING : case SC_ASN1_UTF8STRING : if ( parm != NULL ) { assert ( len != NULL ) ; if ( entry -> flags & SC_ASN1_ALLOC ) { u8 * * buf = ( u8 * * ) parm ; * buf = malloc ( objlen + 1 ) ; if ( * buf == NULL ) { r = SC_ERROR_OUT_OF_MEMORY ; break ; } * len = objlen + 1 ; parm = * buf ; } r = sc_asn1_decode_utf8string ( obj , objlen , ( u8 * ) parm , len ) ; if ( entry -> flags & SC_ASN1_ALLOC ) { * len -= 1 ; } } break ; case SC_ASN1_PATH : if ( entry -> parm != NULL ) r = asn1_decode_path ( ctx , obj , objlen , ( sc_path_t * ) parm , depth ) ; break ; case SC_ASN1_PKCS15_ID : if ( entry -> parm != NULL ) { struct sc_pkcs15_id * id = ( struct sc_pkcs15_id * ) parm ; size_t c = objlen > sizeof ( id -> value ) ? sizeof ( id -> value ) : objlen ; memcpy ( id -> value , obj , c ) ; id -> len = c ; } break ; case SC_ASN1_PKCS15_OBJECT : if ( entry -> parm != NULL ) r = asn1_decode_p15_object ( ctx , obj , objlen , ( struct sc_asn1_pkcs15_object * ) parm , depth ) ; break ; case SC_ASN1_ALGORITHM_ID : if ( entry -> parm != NULL ) r = sc_asn1_decode_algorithm_id ( ctx , obj , objlen , ( struct sc_algorithm_id * ) parm , depth ) ; break ; case SC_ASN1_SE_INFO : if ( entry -> parm != NULL ) r = asn1_decode_se_info ( ctx , obj , objlen , ( sc_pkcs15_sec_env_info_t * * * ) entry -> parm , len , depth ) ; break ; case SC_ASN1_CALLBACK : if ( entry -> parm != NULL ) r = callback_func ( ctx , entry -> arg , obj , objlen , depth ) ; break ; default : sc_debug ( ctx , SC_LOG_DEBUG_ASN1 , "invalid<S2SV_blank>ASN.1<S2SV_blank>type:<S2SV_blank>%d\\n" , entry -> type ) ; return SC_ERROR_INVALID_ASN1_OBJECT ; } if ( r ) { sc_debug ( ctx , SC_LOG_DEBUG_ASN1 , "decoding<S2SV_blank>of<S2SV_blank>ASN.1<S2SV_blank>object<S2SV_blank>\'%s\'<S2SV_blank>failed:<S2SV_blank>%s\\n" , entry -> name , sc_strerror ( r ) ) ; return r ; } entry -> flags |= SC_ASN1_PRESENT ; return 0 ; }
CWE-119 static int key_verify ( pam_handle_t * pamh , int flags , PKCS11_KEY * authkey ) { int ok = 0 ; unsigned char challenge [ 30 ] ; <S2SV_StartBug> unsigned char signature [ 256 ] ; <S2SV_EndBug> <S2SV_StartBug> unsigned int siglen = sizeof signature ; <S2SV_EndBug> const EVP_MD * md = EVP_sha1 ( ) ; EVP_MD_CTX * md_ctx = EVP_MD_CTX_new ( ) ; EVP_PKEY * privkey = PKCS11_get_private_key ( authkey ) ; EVP_PKEY * pubkey = PKCS11_get_public_key ( authkey ) ; <S2SV_StartBug> if ( 1 != randomize ( pamh , challenge , sizeof challenge ) ) { <S2SV_EndBug> goto err ; } if ( NULL == pubkey || NULL == privkey || NULL == md_ctx || NULL == md || ! EVP_SignInit ( md_ctx , md ) || ! EVP_SignUpdate ( md_ctx , challenge , sizeof challenge ) || ! EVP_SignFinal ( md_ctx , signature , & siglen , privkey ) || ! EVP_MD_CTX_reset ( md_ctx ) || ! EVP_VerifyInit ( md_ctx , md ) || ! EVP_VerifyUpdate ( md_ctx , challenge , sizeof challenge ) || 1 != EVP_VerifyFinal ( md_ctx , signature , siglen , pubkey ) ) { pam_syslog ( pamh , LOG_DEBUG , "Error<S2SV_blank>verifying<S2SV_blank>key:<S2SV_blank>%s\\n" , ERR_reason_error_string ( ERR_get_error ( ) ) ) ; prompt ( flags , pamh , PAM_ERROR_MSG , NULL , _ ( "Error<S2SV_blank>verifying<S2SV_blank>key" ) ) ; goto err ; } ok = 1 ; <S2SV_StartBug> err : <S2SV_EndBug> if ( NULL != pubkey ) EVP_PKEY_free ( pubkey ) ; if ( NULL != privkey ) EVP_PKEY_free ( privkey ) ; if ( NULL != md_ctx ) { EVP_MD_CTX_free ( md_ctx ) ; } return ok ; }
CWE-601 int am_check_url ( request_rec * r , const char * url ) { const char * i ; for ( i = url ; * i ; i ++ ) { if ( * i >= 0 && * i < '<S2SV_blank>' ) { AM_LOG_RERROR ( APLOG_MARK , APLOG_ERR , HTTP_BAD_REQUEST , r , "Control<S2SV_blank>character<S2SV_blank>detected<S2SV_blank>in<S2SV_blank>URL." ) ; return HTTP_BAD_REQUEST ; } <S2SV_StartBug> } <S2SV_EndBug> return OK ; }
CWE-119 static int init_device ( u2fh_devs * devs , struct u2fdevice * dev ) { unsigned char resp [ 1024 ] ; unsigned char nonce [ 8 ] ; if ( obtain_nonce ( nonce ) != 0 ) { return U2FH_TRANSPORT_ERROR ; } size_t resplen = sizeof ( resp ) ; dev -> cid = CID_BROADCAST ; if ( u2fh_sendrecv ( devs , dev -> id , U2FHID_INIT , nonce , sizeof ( nonce ) , resp , & resplen ) == U2FH_OK ) { <S2SV_StartBug> U2FHID_INIT_RESP initresp ; <S2SV_EndBug> <S2SV_StartBug> if ( resplen > sizeof ( initresp ) ) <S2SV_EndBug> { return U2FH_MEMORY_ERROR ; } memcpy ( & initresp , resp , resplen ) ; <S2SV_StartBug> dev -> cid = initresp . cid ; <S2SV_EndBug> <S2SV_StartBug> dev -> versionInterface = initresp . versionInterface ; <S2SV_EndBug> <S2SV_StartBug> dev -> versionMajor = initresp . versionMajor ; <S2SV_EndBug> <S2SV_StartBug> dev -> versionMinor = initresp . versionMinor ; <S2SV_EndBug> <S2SV_StartBug> dev -> capFlags = initresp . capFlags ; <S2SV_EndBug> } else { return U2FH_TRANSPORT_ERROR ; } return U2FH_OK ; }
CWE-200 int pam_sm_authenticate ( pam_handle_t * pamh , int flags , int argc , const char * * argv ) { struct passwd * pw = NULL , pw_s ; const char * user = NULL ; cfg_t cfg_st ; cfg_t * cfg = & cfg_st ; char buffer [ BUFSIZE ] ; char * buf = NULL ; char * authfile_dir ; size_t authfile_dir_len ; int pgu_ret , gpn_ret ; int retval = PAM_IGNORE ; device_t * devices = NULL ; unsigned n_devices = 0 ; int openasuser ; int should_free_origin = 0 ; int should_free_appid = 0 ; int should_free_auth_file = 0 ; int should_free_authpending_file = 0 ; parse_cfg ( flags , argc , argv , cfg ) ; if ( ! cfg -> origin ) { strcpy ( buffer , DEFAULT_ORIGIN_PREFIX ) ; if ( gethostname ( buffer + strlen ( DEFAULT_ORIGIN_PREFIX ) , BUFSIZE - strlen ( DEFAULT_ORIGIN_PREFIX ) ) == - 1 ) { DBG ( "Unable<S2SV_blank>to<S2SV_blank>get<S2SV_blank>host<S2SV_blank>name" ) ; goto done ; } DBG ( "Origin<S2SV_blank>not<S2SV_blank>specified,<S2SV_blank>using<S2SV_blank>\\"%s\\"" , buffer ) ; cfg -> origin = strdup ( buffer ) ; if ( ! cfg -> origin ) { DBG ( "Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory" ) ; goto done ; } else { should_free_origin = 1 ; } } if ( ! cfg -> appid ) { DBG ( "Appid<S2SV_blank>not<S2SV_blank>specified,<S2SV_blank>using<S2SV_blank>the<S2SV_blank>same<S2SV_blank>value<S2SV_blank>of<S2SV_blank>origin<S2SV_blank>(%s)" , cfg -> origin ) ; cfg -> appid = strdup ( cfg -> origin ) ; if ( ! cfg -> appid ) { DBG ( "Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory" ) goto done ; } else { should_free_appid = 1 ; } } if ( cfg -> max_devs == 0 ) { DBG ( "Maximum<S2SV_blank>devices<S2SV_blank>number<S2SV_blank>not<S2SV_blank>set.<S2SV_blank>Using<S2SV_blank>default<S2SV_blank>(%d)" , MAX_DEVS ) ; cfg -> max_devs = MAX_DEVS ; } devices = malloc ( sizeof ( device_t ) * cfg -> max_devs ) ; if ( ! devices ) { DBG ( "Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory" ) ; retval = PAM_IGNORE ; goto done ; } pgu_ret = pam_get_user ( pamh , & user , NULL ) ; if ( pgu_ret != PAM_SUCCESS || user == NULL ) { DBG ( "Unable<S2SV_blank>to<S2SV_blank>access<S2SV_blank>user<S2SV_blank>%s" , user ) ; retval = PAM_CONV_ERR ; goto done ; } DBG ( "Requesting<S2SV_blank>authentication<S2SV_blank>for<S2SV_blank>user<S2SV_blank>%s" , user ) ; gpn_ret = getpwnam_r ( user , & pw_s , buffer , sizeof ( buffer ) , & pw ) ; if ( gpn_ret != 0 || pw == NULL || pw -> pw_dir == NULL || pw -> pw_dir [ 0 ] != '/' ) { DBG ( "Unable<S2SV_blank>to<S2SV_blank>retrieve<S2SV_blank>credentials<S2SV_blank>for<S2SV_blank>user<S2SV_blank>%s,<S2SV_blank>(%s)" , user , strerror ( errno ) ) ; retval = PAM_USER_UNKNOWN ; goto done ; } DBG ( "Found<S2SV_blank>user<S2SV_blank>%s" , user ) ; DBG ( "Home<S2SV_blank>directory<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>%s" , user , pw -> pw_dir ) ; if ( ! cfg -> auth_file ) { buf = NULL ; authfile_dir = secure_getenv ( DEFAULT_AUTHFILE_DIR_VAR ) ; if ( ! authfile_dir ) { DBG ( "Variable<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>set.<S2SV_blank>Using<S2SV_blank>default<S2SV_blank>value<S2SV_blank>($HOME/.config/)" , DEFAULT_AUTHFILE_DIR_VAR ) ; authfile_dir_len = strlen ( pw -> pw_dir ) + strlen ( "/.config" ) + strlen ( DEFAULT_AUTHFILE ) + 1 ; buf = malloc ( sizeof ( char ) * ( authfile_dir_len ) ) ; if ( ! buf ) { DBG ( "Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory" ) ; retval = PAM_IGNORE ; goto done ; } snprintf ( buf , authfile_dir_len , "%s/.config%s" , pw -> pw_dir , DEFAULT_AUTHFILE ) ; } else { DBG ( "Variable<S2SV_blank>%s<S2SV_blank>set<S2SV_blank>to<S2SV_blank>%s" , DEFAULT_AUTHFILE_DIR_VAR , authfile_dir ) ; authfile_dir_len = strlen ( authfile_dir ) + strlen ( DEFAULT_AUTHFILE ) + 1 ; buf = malloc ( sizeof ( char ) * ( authfile_dir_len ) ) ; if ( ! buf ) { DBG ( "Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory" ) ; retval = PAM_IGNORE ; goto done ; } snprintf ( buf , authfile_dir_len , "%s%s" , authfile_dir , DEFAULT_AUTHFILE ) ; } DBG ( "Using<S2SV_blank>default<S2SV_blank>authentication<S2SV_blank>file<S2SV_blank>%s" , buf ) ; cfg -> auth_file = buf ; should_free_auth_file = 1 ; buf = NULL ; } else { DBG ( "Using<S2SV_blank>authentication<S2SV_blank>file<S2SV_blank>%s" , cfg -> auth_file ) ; } openasuser = geteuid ( ) == 0 && cfg -> openasuser ; if ( openasuser ) { if ( seteuid ( pw_s . pw_uid ) ) { DBG ( "Unable<S2SV_blank>to<S2SV_blank>switch<S2SV_blank>user<S2SV_blank>to<S2SV_blank>uid<S2SV_blank>%i" , pw_s . pw_uid ) ; retval = PAM_IGNORE ; goto done ; } DBG ( "Switched<S2SV_blank>to<S2SV_blank>uid<S2SV_blank>%i" , pw_s . pw_uid ) ; } retval = get_devices_from_authfile ( cfg -> auth_file , user , cfg -> max_devs , cfg -> debug , cfg -> debug_file , devices , & n_devices ) ; if ( openasuser ) { if ( seteuid ( 0 ) ) { DBG ( "Unable<S2SV_blank>to<S2SV_blank>switch<S2SV_blank>back<S2SV_blank>to<S2SV_blank>uid<S2SV_blank>0" ) ; retval = PAM_IGNORE ; goto done ; } DBG ( "Switched<S2SV_blank>back<S2SV_blank>to<S2SV_blank>uid<S2SV_blank>0" ) ; } if ( retval != 1 ) { n_devices = 0 ; } if ( n_devices == 0 ) { if ( cfg -> nouserok ) { DBG ( "Found<S2SV_blank>no<S2SV_blank>devices<S2SV_blank>but<S2SV_blank>nouserok<S2SV_blank>specified.<S2SV_blank>Skipping<S2SV_blank>authentication" ) ; retval = PAM_SUCCESS ; goto done ; } else if ( retval != 1 ) { DBG ( "Unable<S2SV_blank>to<S2SV_blank>get<S2SV_blank>devices<S2SV_blank>from<S2SV_blank>file<S2SV_blank>%s" , cfg -> auth_file ) ; retval = PAM_AUTHINFO_UNAVAIL ; goto done ; } else { DBG ( "Found<S2SV_blank>no<S2SV_blank>devices.<S2SV_blank>Aborting." ) ; retval = PAM_AUTHINFO_UNAVAIL ; goto done ; } } if ( ! cfg -> authpending_file ) { int actual_size = snprintf ( buffer , BUFSIZE , DEFAULT_AUTHPENDING_FILE_PATH , getuid ( ) ) ; if ( actual_size >= 0 && actual_size < BUFSIZE ) { cfg -> authpending_file = strdup ( buffer ) ; } if ( ! cfg -> authpending_file ) { DBG ( "Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>the<S2SV_blank>authpending_file,<S2SV_blank>touch<S2SV_blank>request<S2SV_blank>notifications<S2SV_blank>will<S2SV_blank>not<S2SV_blank>be<S2SV_blank>emitted" ) ; } else { should_free_authpending_file = 1 ; } } else { if ( strlen ( cfg -> authpending_file ) == 0 ) { DBG ( "authpending_file<S2SV_blank>is<S2SV_blank>set<S2SV_blank>to<S2SV_blank>an<S2SV_blank>empty<S2SV_blank>value,<S2SV_blank>touch<S2SV_blank>request<S2SV_blank>notifications<S2SV_blank>will<S2SV_blank>be<S2SV_blank>disabled" ) ; cfg -> authpending_file = NULL ; } } int authpending_file_descriptor = - 1 ; if ( cfg -> authpending_file ) { DBG ( "Using<S2SV_blank>file<S2SV_blank>\'%s\'<S2SV_blank>for<S2SV_blank>emitting<S2SV_blank>touch<S2SV_blank>request<S2SV_blank>notifications" , cfg -> authpending_file ) ; <S2SV_StartBug> authpending_file_descriptor = open ( cfg -> authpending_file , O_RDONLY | O_CREAT , 0664 ) ; <S2SV_EndBug> if ( authpending_file_descriptor < 0 ) { DBG ( "Unable<S2SV_blank>to<S2SV_blank>emit<S2SV_blank>\'authentication<S2SV_blank>started\'<S2SV_blank>notification<S2SV_blank>by<S2SV_blank>opening<S2SV_blank>the<S2SV_blank>file<S2SV_blank>\'%s\',<S2SV_blank>(%s)" , cfg -> authpending_file , strerror ( errno ) ) ; } } if ( cfg -> manual == 0 ) { if ( cfg -> interactive ) { converse ( pamh , PAM_PROMPT_ECHO_ON , cfg -> prompt != NULL ? cfg -> prompt : DEFAULT_PROMPT ) ; } retval = do_authentication ( cfg , devices , n_devices , pamh ) ; } else { retval = do_manual_authentication ( cfg , devices , n_devices , pamh ) ; } if ( authpending_file_descriptor >= 0 ) { if ( close ( authpending_file_descriptor ) < 0 ) { DBG ( "Unable<S2SV_blank>to<S2SV_blank>emit<S2SV_blank>\'authentication<S2SV_blank>stopped\'<S2SV_blank>notification<S2SV_blank>by<S2SV_blank>closing<S2SV_blank>the<S2SV_blank>file<S2SV_blank>\'%s\',<S2SV_blank>(%s)" , cfg -> authpending_file , strerror ( errno ) ) ; } } if ( retval != 1 ) { DBG ( "do_authentication<S2SV_blank>returned<S2SV_blank>%d" , retval ) ; retval = PAM_AUTH_ERR ; goto done ; } retval = PAM_SUCCESS ; done : free_devices ( devices , n_devices ) ; if ( buf ) { free ( buf ) ; buf = NULL ; } if ( should_free_origin ) { free ( ( char * ) cfg -> origin ) ; cfg -> origin = NULL ; } if ( should_free_appid ) { free ( ( char * ) cfg -> appid ) ; cfg -> appid = NULL ; } if ( should_free_auth_file ) { free ( ( char * ) cfg -> auth_file ) ; cfg -> auth_file = NULL ; } if ( should_free_authpending_file ) { free ( ( char * ) cfg -> authpending_file ) ; cfg -> authpending_file = NULL ; } if ( cfg -> alwaysok && retval != PAM_SUCCESS ) { DBG ( "alwaysok<S2SV_blank>needed<S2SV_blank>(otherwise<S2SV_blank>return<S2SV_blank>with<S2SV_blank>%d)" , retval ) ; retval = PAM_SUCCESS ; } DBG ( "done.<S2SV_blank>[%s]" , pam_strerror ( pamh , retval ) ) ; <S2SV_StartBug> return retval ; <S2SV_EndBug> }
CWE-200 static void parse_cfg ( int flags , int argc , const char * * argv , cfg_t * cfg ) { <S2SV_StartBug> int i ; <S2SV_EndBug> memset ( cfg , 0 , sizeof ( cfg_t ) ) ; cfg -> debug_file = stderr ; for ( i = 0 ; i < argc ; i ++ ) { if ( strncmp ( argv [ i ] , "max_devices=" , 12 ) == 0 ) sscanf ( argv [ i ] , "max_devices=%u" , & cfg -> max_devs ) ; if ( strcmp ( argv [ i ] , "manual" ) == 0 ) cfg -> manual = 1 ; if ( strcmp ( argv [ i ] , "debug" ) == 0 ) cfg -> debug = 1 ; if ( strcmp ( argv [ i ] , "nouserok" ) == 0 ) cfg -> nouserok = 1 ; if ( strcmp ( argv [ i ] , "openasuser" ) == 0 ) cfg -> openasuser = 1 ; if ( strcmp ( argv [ i ] , "alwaysok" ) == 0 ) cfg -> alwaysok = 1 ; if ( strcmp ( argv [ i ] , "interactive" ) == 0 ) cfg -> interactive = 1 ; if ( strcmp ( argv [ i ] , "cue" ) == 0 ) cfg -> cue = 1 ; if ( strcmp ( argv [ i ] , "nodetect" ) == 0 ) cfg -> nodetect = 1 ; if ( strncmp ( argv [ i ] , "authfile=" , 9 ) == 0 ) cfg -> auth_file = argv [ i ] + 9 ; if ( strncmp ( argv [ i ] , "authpending_file=" , 17 ) == 0 ) cfg -> authpending_file = argv [ i ] + 17 ; if ( strncmp ( argv [ i ] , "origin=" , 7 ) == 0 ) cfg -> origin = argv [ i ] + 7 ; if ( strncmp ( argv [ i ] , "appid=" , 6 ) == 0 ) cfg -> appid = argv [ i ] + 6 ; if ( strncmp ( argv [ i ] , "prompt=" , 7 ) == 0 ) cfg -> prompt = argv [ i ] + 7 ; if ( strncmp ( argv [ i ] , "debug_file=" , 11 ) == 0 ) { const char * filename = argv [ i ] + 11 ; if ( strncmp ( filename , "stdout" , 6 ) == 0 ) { cfg -> debug_file = stdout ; } else if ( strncmp ( filename , "stderr" , 6 ) == 0 ) { cfg -> debug_file = stderr ; } else if ( strncmp ( filename , "syslog" , 6 ) == 0 ) { cfg -> debug_file = ( FILE * ) - 1 ; } else { <S2SV_StartBug> struct stat st ; <S2SV_EndBug> FILE * file ; <S2SV_StartBug> if ( lstat ( filename , & st ) == 0 ) { <S2SV_EndBug> if ( S_ISREG ( st . st_mode ) ) { <S2SV_StartBug> file = fopen ( filename , "a" ) ; <S2SV_EndBug> if ( file != NULL ) { cfg -> debug_file = file ; <S2SV_StartBug> } <S2SV_EndBug> } } } } } if ( cfg -> debug ) { D ( cfg -> debug_file , "called." ) ; D ( cfg -> debug_file , "flags<S2SV_blank>%d<S2SV_blank>argc<S2SV_blank>%d" , flags , argc ) ; for ( i = 0 ; i < argc ; i ++ ) { D ( cfg -> debug_file , "argv[%d]=%s" , i , argv [ i ] ) ; } D ( cfg -> debug_file , "max_devices=%d" , cfg -> max_devs ) ; D ( cfg -> debug_file , "debug=%d" , cfg -> debug ) ; D ( cfg -> debug_file , "interactive=%d" , cfg -> interactive ) ; D ( cfg -> debug_file , "cue=%d" , cfg -> cue ) ; D ( cfg -> debug_file , "nodetect=%d" , cfg -> nodetect ) ; D ( cfg -> debug_file , "manual=%d" , cfg -> manual ) ; D ( cfg -> debug_file , "nouserok=%d" , cfg -> nouserok ) ; D ( cfg -> debug_file , "openasuser=%d" , cfg -> openasuser ) ; D ( cfg -> debug_file , "alwaysok=%d" , cfg -> alwaysok ) ; D ( cfg -> debug_file , "authfile=%s" , cfg -> auth_file ? cfg -> auth_file : "(null)" ) ; D ( cfg -> debug_file , "authpending_file=%s" , cfg -> authpending_file ? cfg -> authpending_file : "(null)" ) ; D ( cfg -> debug_file , "origin=%s" , cfg -> origin ? cfg -> origin : "(null)" ) ; D ( cfg -> debug_file , "appid=%s" , cfg -> appid ? cfg -> appid : "(null)" ) ; D ( cfg -> debug_file , "prompt=%s" , cfg -> prompt ? cfg -> prompt : "(null)" ) ; } <S2SV_StartBug> } <S2SV_EndBug>
CWE-200 int get_devices_from_authfile ( const char * authfile , const char * username , unsigned max_devs , int verbose , FILE * debug_file , device_t * devices , unsigned * n_devs ) { char * buf = NULL ; char * s_user , * s_token ; int retval = 0 ; int fd = - 1 ; struct stat st ; struct passwd * pw = NULL , pw_s ; char buffer [ BUFSIZE ] ; int gpu_ret ; FILE * opwfile = NULL ; unsigned i , j ; * n_devs = 0 ; <S2SV_StartBug> fd = open ( authfile , O_RDONLY , 0 ) ; <S2SV_EndBug> if ( fd < 0 ) { if ( verbose ) D ( debug_file , "Cannot<S2SV_blank>open<S2SV_blank>file:<S2SV_blank>%s<S2SV_blank>(%s)" , authfile , strerror ( errno ) ) ; goto err ; } if ( fstat ( fd , & st ) < 0 ) { if ( verbose ) D ( debug_file , "Cannot<S2SV_blank>stat<S2SV_blank>file:<S2SV_blank>%s<S2SV_blank>(%s)" , authfile , strerror ( errno ) ) ; goto err ; } if ( ! S_ISREG ( st . st_mode ) ) { if ( verbose ) D ( debug_file , "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>regular<S2SV_blank>file" , authfile ) ; goto err ; } if ( st . st_size == 0 ) { if ( verbose ) D ( debug_file , "File<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>empty" , authfile ) ; goto err ; } gpu_ret = getpwuid_r ( st . st_uid , & pw_s , buffer , sizeof ( buffer ) , & pw ) ; if ( gpu_ret != 0 || pw == NULL ) { D ( debug_file , "Unable<S2SV_blank>to<S2SV_blank>retrieve<S2SV_blank>credentials<S2SV_blank>for<S2SV_blank>uid<S2SV_blank>%u,<S2SV_blank>(%s)" , st . st_uid , strerror ( errno ) ) ; goto err ; } if ( strcmp ( pw -> pw_name , username ) != 0 && strcmp ( pw -> pw_name , "root" ) != 0 ) { if ( strcmp ( username , "root" ) != 0 ) { D ( debug_file , "The<S2SV_blank>owner<S2SV_blank>of<S2SV_blank>the<S2SV_blank>authentication<S2SV_blank>file<S2SV_blank>is<S2SV_blank>neither<S2SV_blank>%s<S2SV_blank>nor<S2SV_blank>root" , username ) ; } else { D ( debug_file , "The<S2SV_blank>owner<S2SV_blank>of<S2SV_blank>the<S2SV_blank>authentication<S2SV_blank>file<S2SV_blank>is<S2SV_blank>not<S2SV_blank>root" ) ; } goto err ; } opwfile = fdopen ( fd , "r" ) ; if ( opwfile == NULL ) { if ( verbose ) D ( debug_file , "fdopen:<S2SV_blank>%s" , strerror ( errno ) ) ; <S2SV_StartBug> goto err ; <S2SV_EndBug> } buf = malloc ( sizeof ( char ) * ( DEVSIZE * max_devs ) ) ; if ( ! buf ) { if ( verbose ) D ( debug_file , "Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory" ) ; goto err ; } retval = - 2 ; while ( fgets ( buf , ( int ) ( DEVSIZE * ( max_devs - 1 ) ) , opwfile ) ) { char * saveptr = NULL ; if ( buf [ strlen ( buf ) - 1 ] == '\\n' ) buf [ strlen ( buf ) - 1 ] = '\\0' ; if ( verbose ) D ( debug_file , "Authorization<S2SV_blank>line:<S2SV_blank>%s" , buf ) ; s_user = strtok_r ( buf , ":" , & saveptr ) ; if ( s_user && strcmp ( username , s_user ) == 0 ) { if ( verbose ) D ( debug_file , "Matched<S2SV_blank>user:<S2SV_blank>%s" , s_user ) ; retval = - 1 ; for ( i = 0 ; i < * n_devs ; i ++ ) { free ( devices [ i ] . keyHandle ) ; free ( devices [ i ] . publicKey ) ; devices [ i ] . keyHandle = NULL ; devices [ i ] . publicKey = NULL ; } * n_devs = 0 ; i = 0 ; while ( ( s_token = strtok_r ( NULL , "," , & saveptr ) ) ) { devices [ i ] . keyHandle = NULL ; devices [ i ] . publicKey = NULL ; if ( ( * n_devs ) ++ > MAX_DEVS - 1 ) { * n_devs = MAX_DEVS ; if ( verbose ) D ( debug_file , "Found<S2SV_blank>more<S2SV_blank>than<S2SV_blank>%d<S2SV_blank>devices,<S2SV_blank>ignoring<S2SV_blank>the<S2SV_blank>remaining<S2SV_blank>ones" , MAX_DEVS ) ; break ; } if ( verbose ) D ( debug_file , "KeyHandle<S2SV_blank>for<S2SV_blank>device<S2SV_blank>number<S2SV_blank>%d:<S2SV_blank>%s" , i + 1 , s_token ) ; devices [ i ] . keyHandle = strdup ( s_token ) ; if ( ! devices [ i ] . keyHandle ) { if ( verbose ) D ( debug_file , "Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>keyHandle<S2SV_blank>number<S2SV_blank>%d" , i ) ; goto err ; } s_token = strtok_r ( NULL , ":" , & saveptr ) ; if ( ! s_token ) { if ( verbose ) D ( debug_file , "Unable<S2SV_blank>to<S2SV_blank>retrieve<S2SV_blank>publicKey<S2SV_blank>number<S2SV_blank>%d" , i + 1 ) ; goto err ; } if ( verbose ) D ( debug_file , "publicKey<S2SV_blank>for<S2SV_blank>device<S2SV_blank>number<S2SV_blank>%d:<S2SV_blank>%s" , i + 1 , s_token ) ; if ( strlen ( s_token ) % 2 != 0 ) { if ( verbose ) D ( debug_file , "Length<S2SV_blank>of<S2SV_blank>key<S2SV_blank>number<S2SV_blank>%d<S2SV_blank>not<S2SV_blank>even" , i + 1 ) ; goto err ; } devices [ i ] . key_len = strlen ( s_token ) / 2 ; if ( verbose ) D ( debug_file , "Length<S2SV_blank>of<S2SV_blank>key<S2SV_blank>number<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>%zu" , i + 1 , devices [ i ] . key_len ) ; devices [ i ] . publicKey = malloc ( ( sizeof ( unsigned char ) * devices [ i ] . key_len ) ) ; if ( ! devices [ i ] . publicKey ) { if ( verbose ) D ( debug_file , "Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>publicKey<S2SV_blank>number<S2SV_blank>%d" , i ) ; goto err ; } for ( j = 0 ; j < devices [ i ] . key_len ; j ++ ) { unsigned int x ; if ( sscanf ( & s_token [ 2 * j ] , "%2x" , & x ) != 1 ) { if ( verbose ) D ( debug_file , "Invalid<S2SV_blank>hex<S2SV_blank>number<S2SV_blank>in<S2SV_blank>key" ) ; goto err ; } devices [ i ] . publicKey [ j ] = ( unsigned char ) x ; } i ++ ; } } } if ( verbose ) D ( debug_file , "Found<S2SV_blank>%d<S2SV_blank>device(s)<S2SV_blank>for<S2SV_blank>user<S2SV_blank>%s" , * n_devs , username ) ; retval = 1 ; goto out ; err : for ( i = 0 ; i < * n_devs ; i ++ ) { free ( devices [ i ] . keyHandle ) ; free ( devices [ i ] . publicKey ) ; devices [ i ] . keyHandle = NULL ; devices [ i ] . publicKey = NULL ; } * n_devs = 0 ; out : if ( buf ) { free ( buf ) ; buf = NULL ; } if ( opwfile ) fclose ( opwfile ) ; <S2SV_StartBug> else if ( fd >= 0 ) <S2SV_EndBug> close ( fd ) ; return retval ; }
CWE-200 int pam_sm_authenticate ( pam_handle_t * pamh , int flags , int argc , const char * * argv ) { struct passwd * pw = NULL , pw_s ; const char * user = NULL ; cfg_t cfg_st ; cfg_t * cfg = & cfg_st ; char buffer [ BUFSIZE ] ; char * buf = NULL ; char * authfile_dir ; size_t authfile_dir_len ; int pgu_ret , gpn_ret ; int retval = PAM_IGNORE ; device_t * devices = NULL ; unsigned n_devices = 0 ; <S2SV_StartBug> int openasuser ; <S2SV_EndBug> int should_free_origin = 0 ; int should_free_appid = 0 ; int should_free_auth_file = 0 ; <S2SV_StartBug> int should_free_authpending_file = 0 ; <S2SV_EndBug> parse_cfg ( flags , argc , argv , cfg ) ; if ( ! cfg -> origin ) { strcpy ( buffer , DEFAULT_ORIGIN_PREFIX ) ; if ( gethostname ( buffer + strlen ( DEFAULT_ORIGIN_PREFIX ) , BUFSIZE - strlen ( DEFAULT_ORIGIN_PREFIX ) ) == - 1 ) { DBG ( "Unable<S2SV_blank>to<S2SV_blank>get<S2SV_blank>host<S2SV_blank>name" ) ; goto done ; } DBG ( "Origin<S2SV_blank>not<S2SV_blank>specified,<S2SV_blank>using<S2SV_blank>\\"%s\\"" , buffer ) ; cfg -> origin = strdup ( buffer ) ; if ( ! cfg -> origin ) { DBG ( "Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory" ) ; goto done ; } else { should_free_origin = 1 ; } } if ( ! cfg -> appid ) { DBG ( "Appid<S2SV_blank>not<S2SV_blank>specified,<S2SV_blank>using<S2SV_blank>the<S2SV_blank>same<S2SV_blank>value<S2SV_blank>of<S2SV_blank>origin<S2SV_blank>(%s)" , cfg -> origin ) ; cfg -> appid = strdup ( cfg -> origin ) ; if ( ! cfg -> appid ) { DBG ( "Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory" ) goto done ; } else { should_free_appid = 1 ; } } if ( cfg -> max_devs == 0 ) { DBG ( "Maximum<S2SV_blank>devices<S2SV_blank>number<S2SV_blank>not<S2SV_blank>set.<S2SV_blank>Using<S2SV_blank>default<S2SV_blank>(%d)" , MAX_DEVS ) ; cfg -> max_devs = MAX_DEVS ; } devices = malloc ( sizeof ( device_t ) * cfg -> max_devs ) ; if ( ! devices ) { DBG ( "Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory" ) ; retval = PAM_IGNORE ; goto done ; } pgu_ret = pam_get_user ( pamh , & user , NULL ) ; if ( pgu_ret != PAM_SUCCESS || user == NULL ) { DBG ( "Unable<S2SV_blank>to<S2SV_blank>access<S2SV_blank>user<S2SV_blank>%s" , user ) ; retval = PAM_CONV_ERR ; goto done ; } DBG ( "Requesting<S2SV_blank>authentication<S2SV_blank>for<S2SV_blank>user<S2SV_blank>%s" , user ) ; gpn_ret = getpwnam_r ( user , & pw_s , buffer , sizeof ( buffer ) , & pw ) ; if ( gpn_ret != 0 || pw == NULL || pw -> pw_dir == NULL || pw -> pw_dir [ 0 ] != '/' ) { DBG ( "Unable<S2SV_blank>to<S2SV_blank>retrieve<S2SV_blank>credentials<S2SV_blank>for<S2SV_blank>user<S2SV_blank>%s,<S2SV_blank>(%s)" , user , strerror ( errno ) ) ; retval = PAM_USER_UNKNOWN ; goto done ; } DBG ( "Found<S2SV_blank>user<S2SV_blank>%s" , user ) ; DBG ( "Home<S2SV_blank>directory<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>%s" , user , pw -> pw_dir ) ; if ( ! cfg -> auth_file ) { buf = NULL ; authfile_dir = secure_getenv ( DEFAULT_AUTHFILE_DIR_VAR ) ; if ( ! authfile_dir ) { DBG ( "Variable<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>set.<S2SV_blank>Using<S2SV_blank>default<S2SV_blank>value<S2SV_blank>($HOME/.config/)" , DEFAULT_AUTHFILE_DIR_VAR ) ; authfile_dir_len = strlen ( pw -> pw_dir ) + strlen ( "/.config" ) + strlen ( DEFAULT_AUTHFILE ) + 1 ; buf = malloc ( sizeof ( char ) * ( authfile_dir_len ) ) ; if ( ! buf ) { DBG ( "Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory" ) ; retval = PAM_IGNORE ; goto done ; } <S2SV_StartBug> snprintf ( buf , authfile_dir_len , <S2SV_EndBug> "%s/.config%s" , pw -> pw_dir , DEFAULT_AUTHFILE ) ; } else { DBG ( "Variable<S2SV_blank>%s<S2SV_blank>set<S2SV_blank>to<S2SV_blank>%s" , DEFAULT_AUTHFILE_DIR_VAR , authfile_dir ) ; authfile_dir_len = strlen ( authfile_dir ) + strlen ( DEFAULT_AUTHFILE ) + 1 ; buf = malloc ( sizeof ( char ) * ( authfile_dir_len ) ) ; if ( ! buf ) { DBG ( "Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory" ) ; retval = PAM_IGNORE ; goto done ; } snprintf ( buf , authfile_dir_len , "%s%s" , authfile_dir , DEFAULT_AUTHFILE ) ; <S2SV_StartBug> } <S2SV_EndBug> DBG ( "Using<S2SV_blank>default<S2SV_blank>authentication<S2SV_blank>file<S2SV_blank>%s" , buf ) ; <S2SV_StartBug> cfg -> auth_file = buf ; <S2SV_EndBug> should_free_auth_file = 1 ; buf = NULL ; } else { DBG ( "Using<S2SV_blank>authentication<S2SV_blank>file<S2SV_blank>%s" , cfg -> auth_file ) ; } <S2SV_StartBug> openasuser = geteuid ( ) == 0 && cfg -> openasuser ; <S2SV_EndBug> <S2SV_StartBug> if ( openasuser ) { <S2SV_EndBug> <S2SV_StartBug> if ( seteuid ( pw_s . pw_uid ) ) { <S2SV_EndBug> <S2SV_StartBug> DBG ( "Unable<S2SV_blank>to<S2SV_blank>switch<S2SV_blank>user<S2SV_blank>to<S2SV_blank>uid<S2SV_blank>%i" , pw_s . pw_uid ) ; <S2SV_EndBug> retval = PAM_IGNORE ; goto done ; } <S2SV_StartBug> DBG ( "Switched<S2SV_blank>to<S2SV_blank>uid<S2SV_blank>%i" , pw_s . pw_uid ) ; <S2SV_EndBug> } retval = get_devices_from_authfile ( cfg -> auth_file , user , cfg -> max_devs , cfg -> debug , cfg -> debug_file , devices , & n_devices ) ; if ( openasuser ) { <S2SV_StartBug> if ( seteuid ( 0 ) ) { <S2SV_EndBug> DBG ( "Unable<S2SV_blank>to<S2SV_blank>switch<S2SV_blank>back<S2SV_blank>to<S2SV_blank>uid<S2SV_blank>0" ) ; retval = PAM_IGNORE ; goto done ; } <S2SV_StartBug> DBG ( "Switched<S2SV_blank>back<S2SV_blank>to<S2SV_blank>uid<S2SV_blank>0" ) ; <S2SV_EndBug> } if ( retval != 1 ) { n_devices = 0 ; } if ( n_devices == 0 ) { if ( cfg -> nouserok ) { DBG ( "Found<S2SV_blank>no<S2SV_blank>devices<S2SV_blank>but<S2SV_blank>nouserok<S2SV_blank>specified.<S2SV_blank>Skipping<S2SV_blank>authentication" ) ; retval = PAM_SUCCESS ; goto done ; } else if ( retval != 1 ) { DBG ( "Unable<S2SV_blank>to<S2SV_blank>get<S2SV_blank>devices<S2SV_blank>from<S2SV_blank>file<S2SV_blank>%s" , cfg -> auth_file ) ; retval = PAM_AUTHINFO_UNAVAIL ; goto done ; } else { DBG ( "Found<S2SV_blank>no<S2SV_blank>devices.<S2SV_blank>Aborting." ) ; retval = PAM_AUTHINFO_UNAVAIL ; goto done ; } } if ( ! cfg -> authpending_file ) { int actual_size = snprintf ( buffer , BUFSIZE , DEFAULT_AUTHPENDING_FILE_PATH , getuid ( ) ) ; if ( actual_size >= 0 && actual_size < BUFSIZE ) { cfg -> authpending_file = strdup ( buffer ) ; } if ( ! cfg -> authpending_file ) { DBG ( "Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>the<S2SV_blank>authpending_file,<S2SV_blank>touch<S2SV_blank>request<S2SV_blank>notifications<S2SV_blank>will<S2SV_blank>not<S2SV_blank>be<S2SV_blank>emitted" ) ; } else { should_free_authpending_file = 1 ; } } else { if ( strlen ( cfg -> authpending_file ) == 0 ) { DBG ( "authpending_file<S2SV_blank>is<S2SV_blank>set<S2SV_blank>to<S2SV_blank>an<S2SV_blank>empty<S2SV_blank>value,<S2SV_blank>touch<S2SV_blank>request<S2SV_blank>notifications<S2SV_blank>will<S2SV_blank>be<S2SV_blank>disabled" ) ; cfg -> authpending_file = NULL ; } } int authpending_file_descriptor = - 1 ; if ( cfg -> authpending_file ) { DBG ( "Using<S2SV_blank>file<S2SV_blank>\'%s\'<S2SV_blank>for<S2SV_blank>emitting<S2SV_blank>touch<S2SV_blank>request<S2SV_blank>notifications" , cfg -> authpending_file ) ; authpending_file_descriptor = open ( cfg -> authpending_file , O_RDONLY | O_CREAT | O_CLOEXEC | O_NOFOLLOW | O_NOCTTY , 0664 ) ; if ( authpending_file_descriptor < 0 ) { DBG ( "Unable<S2SV_blank>to<S2SV_blank>emit<S2SV_blank>\'authentication<S2SV_blank>started\'<S2SV_blank>notification<S2SV_blank>by<S2SV_blank>opening<S2SV_blank>the<S2SV_blank>file<S2SV_blank>\'%s\',<S2SV_blank>(%s)" , cfg -> authpending_file , strerror ( errno ) ) ; } } if ( cfg -> manual == 0 ) { if ( cfg -> interactive ) { converse ( pamh , PAM_PROMPT_ECHO_ON , cfg -> prompt != NULL ? cfg -> prompt : DEFAULT_PROMPT ) ; } retval = do_authentication ( cfg , devices , n_devices , pamh ) ; } else { retval = do_manual_authentication ( cfg , devices , n_devices , pamh ) ; } if ( authpending_file_descriptor >= 0 ) { if ( close ( authpending_file_descriptor ) < 0 ) { DBG ( "Unable<S2SV_blank>to<S2SV_blank>emit<S2SV_blank>\'authentication<S2SV_blank>stopped\'<S2SV_blank>notification<S2SV_blank>by<S2SV_blank>closing<S2SV_blank>the<S2SV_blank>file<S2SV_blank>\'%s\',<S2SV_blank>(%s)" , cfg -> authpending_file , strerror ( errno ) ) ; } } if ( retval != 1 ) { DBG ( "do_authentication<S2SV_blank>returned<S2SV_blank>%d" , retval ) ; retval = PAM_AUTH_ERR ; goto done ; } retval = PAM_SUCCESS ; done : free_devices ( devices , n_devices ) ; if ( buf ) { free ( buf ) ; buf = NULL ; } if ( should_free_origin ) { free ( ( char * ) cfg -> origin ) ; cfg -> origin = NULL ; } if ( should_free_appid ) { free ( ( char * ) cfg -> appid ) ; cfg -> appid = NULL ; } if ( should_free_auth_file ) { free ( ( char * ) cfg -> auth_file ) ; cfg -> auth_file = NULL ; } if ( should_free_authpending_file ) { free ( ( char * ) cfg -> authpending_file ) ; cfg -> authpending_file = NULL ; } if ( cfg -> alwaysok && retval != PAM_SUCCESS ) { DBG ( "alwaysok<S2SV_blank>needed<S2SV_blank>(otherwise<S2SV_blank>return<S2SV_blank>with<S2SV_blank>%d)" , retval ) ; retval = PAM_SUCCESS ; } DBG ( "done.<S2SV_blank>[%s]" , pam_strerror ( pamh , retval ) ) ; if ( cfg -> is_custom_debug_file ) { fclose ( cfg -> debug_file ) ; } return retval ; }
CWE-772 LPSTR tr_esc_str ( LPCSTR arg , bool format ) { <S2SV_StartBug> LPSTR tmp = NULL ; <S2SV_EndBug> size_t cs = 0 , x , ds , len ; size_t s ; if ( NULL == arg ) return NULL ; s = strlen ( arg ) ; while ( ( s > 0 ) && isspace ( arg [ s - 1 ] ) ) s -- ; ds = s + 1 ; if ( s ) <S2SV_StartBug> tmp = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ; <S2SV_EndBug> if ( NULL == tmp ) { fprintf ( stderr , "Could<S2SV_blank>not<S2SV_blank>allocate<S2SV_blank>string<S2SV_blank>buffer.\\n" ) ; exit ( - 2 ) ; } memset ( tmp , 0 , ds * sizeof ( CHAR ) ) ; for ( x = 0 ; x < s ; x ++ ) { switch ( arg [ x ] ) { case '<' : len = format ? 13 : 4 ; ds += len - 1 ; <S2SV_StartBug> tmp = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ; <S2SV_EndBug> if ( NULL == tmp ) { fprintf ( stderr , "Could<S2SV_blank>not<S2SV_blank>reallocate<S2SV_blank>string<S2SV_blank>buffer.\\n" ) ; exit ( - 3 ) ; } if ( format ) strncpy ( & tmp [ cs ] , "<replaceable>" , len ) ; else strncpy ( & tmp [ cs ] , "&lt;" , len ) ; cs += len ; break ; case '>' : len = format ? 14 : 4 ; ds += len - 1 ; <S2SV_StartBug> tmp = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ; <S2SV_EndBug> if ( NULL == tmp ) { fprintf ( stderr , "Could<S2SV_blank>not<S2SV_blank>reallocate<S2SV_blank>string<S2SV_blank>buffer.\\n" ) ; exit ( - 4 ) ; } if ( format ) strncpy ( & tmp [ cs ] , "</replaceable>" , len ) ; else strncpy ( & tmp [ cs ] , "&lt;" , len ) ; cs += len ; break ; case '\\'' : ds += 5 ; <S2SV_StartBug> tmp = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ; <S2SV_EndBug> if ( NULL == tmp ) { fprintf ( stderr , "Could<S2SV_blank>not<S2SV_blank>reallocate<S2SV_blank>string<S2SV_blank>buffer.\\n" ) ; exit ( - 5 ) ; } tmp [ cs ++ ] = '&' ; tmp [ cs ++ ] = 'a' ; tmp [ cs ++ ] = 'p' ; tmp [ cs ++ ] = 'o' ; tmp [ cs ++ ] = 's' ; tmp [ cs ++ ] = ';' ; break ; case \'"\' : ds += 5 ; <S2SV_StartBug> tmp = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ; <S2SV_EndBug> if ( NULL == tmp ) { fprintf ( stderr , "Could<S2SV_blank>not<S2SV_blank>reallocate<S2SV_blank>string<S2SV_blank>buffer.\\n" ) ; exit ( - 6 ) ; } tmp [ cs ++ ] = '&' ; tmp [ cs ++ ] = 'q' ; tmp [ cs ++ ] = 'u' ; tmp [ cs ++ ] = 'o' ; tmp [ cs ++ ] = 't' ; tmp [ cs ++ ] = ';' ; break ; case '&' : ds += 4 ; <S2SV_StartBug> tmp = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( NULL == tmp ) <S2SV_EndBug> { fprintf ( stderr , "Could<S2SV_blank>not<S2SV_blank>reallocate<S2SV_blank>string<S2SV_blank>buffer.\\n" ) ; exit ( - 7 ) ; } tmp [ cs ++ ] = '&' ; tmp [ cs ++ ] = 'a' ; tmp [ cs ++ ] = 'm' ; tmp [ cs ++ ] = 'p' ; tmp [ cs ++ ] = ';' ; break ; default : tmp [ cs ++ ] = arg [ x ] ; break ; } tmp [ ds - 1 ] = '\\0' ; } return tmp ; }
CWE-400 static void Rp_test ( js_State * J ) { js_Regexp * re ; const char * text ; <S2SV_StartBug> int opts ; <S2SV_EndBug> Resub m ; re = js_toregexp ( J , 0 ) ; text = js_tostring ( J , 1 ) ; opts = 0 ; if ( re -> flags & JS_REGEXP_G ) { if ( re -> last > strlen ( text ) ) { re -> last = 0 ; js_pushboolean ( J , 0 ) ; return ; } if ( re -> last > 0 ) { text += re -> last ; opts |= REG_NOTBOL ; } } <S2SV_StartBug> if ( ! js_regexec ( re -> prog , text , & m , opts ) ) { <S2SV_EndBug> if ( re -> flags & JS_REGEXP_G ) re -> last = re -> last + ( m . sub [ 0 ] . ep - text ) ; js_pushboolean ( J , 1 ) ; return ; } if ( re -> flags & JS_REGEXP_G ) re -> last = 0 ; js_pushboolean ( J , 0 ) ; }
CWE-400 void js_RegExp_prototype_exec ( js_State * J , js_Regexp * re , const char * text ) { <S2SV_StartBug> int i ; <S2SV_EndBug> int opts ; Resub m ; opts = 0 ; if ( re -> flags & JS_REGEXP_G ) { if ( re -> last > strlen ( text ) ) { re -> last = 0 ; js_pushnull ( J ) ; return ; } if ( re -> last > 0 ) { text += re -> last ; opts |= REG_NOTBOL ; } } <S2SV_StartBug> if ( ! js_regexec ( re -> prog , text , & m , opts ) ) { <S2SV_EndBug> js_newarray ( J ) ; js_pushstring ( J , text ) ; js_setproperty ( J , - 2 , "input" ) ; js_pushnumber ( J , js_utfptrtoidx ( text , m . sub [ 0 ] . sp ) ) ; js_setproperty ( J , - 2 , "index" ) ; for ( i = 0 ; i < m . nsub ; ++ i ) { js_pushlstring ( J , m . sub [ i ] . sp , m . sub [ i ] . ep - m . sub [ i ] . sp ) ; js_setindex ( J , - 2 , i ) ; } if ( re -> flags & JS_REGEXP_G ) re -> last = re -> last + ( m . sub [ 0 ] . ep - text ) ; return ; } if ( re -> flags & JS_REGEXP_G ) re -> last = 0 ; js_pushnull ( J ) ; }
CWE-400 static void Sp_match ( js_State * J ) { js_Regexp * re ; const char * text ; int len ; const char * a , * b , * c , * e ; Resub m ; text = checkstring ( J , 0 ) ; if ( js_isregexp ( J , 1 ) ) js_copy ( J , 1 ) ; else if ( js_isundefined ( J , 1 ) ) js_newregexp ( J , "" , 0 ) ; else js_newregexp ( J , js_tostring ( J , 1 ) , 0 ) ; re = js_toregexp ( J , - 1 ) ; if ( ! ( re -> flags & JS_REGEXP_G ) ) { js_RegExp_prototype_exec ( J , re , text ) ; return ; } re -> last = 0 ; js_newarray ( J ) ; len = 0 ; a = text ; e = text + strlen ( text ) ; while ( a <= e ) { <S2SV_StartBug> if ( js_regexec ( re -> prog , a , & m , a > text ? REG_NOTBOL : 0 ) ) <S2SV_EndBug> break ; b = m . sub [ 0 ] . sp ; c = m . sub [ 0 ] . ep ; js_pushlstring ( J , b , c - b ) ; js_setindex ( J , - 2 , len ++ ) ; a = c ; if ( c - b == 0 ) ++ a ; } if ( len == 0 ) { js_pop ( J , 1 ) ; js_pushnull ( J ) ; } }
CWE-400 static void Sp_replace_regexp ( js_State * J ) { js_Regexp * re ; const char * source , * s , * r ; js_Buffer * sb = NULL ; int n , x ; Resub m ; source = checkstring ( J , 0 ) ; re = js_toregexp ( J , 1 ) ; <S2SV_StartBug> if ( js_regexec ( re -> prog , source , & m , 0 ) ) { <S2SV_EndBug> js_copy ( J , 0 ) ; return ; } re -> last = 0 ; loop : s = m . sub [ 0 ] . sp ; n = m . sub [ 0 ] . ep - m . sub [ 0 ] . sp ; if ( js_iscallable ( J , 2 ) ) { js_copy ( J , 2 ) ; js_pushundefined ( J ) ; for ( x = 0 ; m . sub [ x ] . sp ; ++ x ) js_pushlstring ( J , m . sub [ x ] . sp , m . sub [ x ] . ep - m . sub [ x ] . sp ) ; js_pushnumber ( J , s - source ) ; js_copy ( J , 0 ) ; js_call ( J , 2 + x ) ; r = js_tostring ( J , - 1 ) ; js_putm ( J , & sb , source , s ) ; js_puts ( J , & sb , r ) ; js_pop ( J , 1 ) ; } else { r = js_tostring ( J , 2 ) ; js_putm ( J , & sb , source , s ) ; while ( * r ) { if ( * r == '$' ) { switch ( * ( ++ r ) ) { case 0 : -- r ; case '$' : js_putc ( J , & sb , '$' ) ; break ; case '`' : js_putm ( J , & sb , source , s ) ; break ; case '\\'' : js_puts ( J , & sb , s + n ) ; break ; case '&' : js_putm ( J , & sb , s , s + n ) ; break ; case '0' : case '1' : case '2' : case '3' : case '4' : case '5' : case '6' : case '7' : case '8' : case '9' : x = * r - '0' ; if ( r [ 1 ] >= '0' && r [ 1 ] <= '9' ) x = x * 10 + * ( ++ r ) - '0' ; if ( x > 0 && x < m . nsub ) { js_putm ( J , & sb , m . sub [ x ] . sp , m . sub [ x ] . ep ) ; } else { js_putc ( J , & sb , '$' ) ; if ( x > 10 ) { js_putc ( J , & sb , '0' + x / 10 ) ; js_putc ( J , & sb , '0' + x % 10 ) ; } else { js_putc ( J , & sb , '0' + x ) ; } } break ; default : js_putc ( J , & sb , '$' ) ; js_putc ( J , & sb , * r ) ; break ; } ++ r ; } else { js_putc ( J , & sb , * r ++ ) ; } } } if ( re -> flags & JS_REGEXP_G ) { source = m . sub [ 0 ] . ep ; if ( n == 0 ) { if ( * source ) js_putc ( J , & sb , * source ++ ) ; else goto end ; } <S2SV_StartBug> if ( ! js_regexec ( re -> prog , source , & m , REG_NOTBOL ) ) <S2SV_EndBug> goto loop ; } end : js_puts ( J , & sb , s + n ) ; js_putc ( J , & sb , 0 ) ; if ( js_try ( J ) ) { js_free ( J , sb ) ; js_throw ( J ) ; } js_pushstring ( J , sb ? sb -> s : "" ) ; js_endtry ( J ) ; js_free ( J , sb ) ; }
CWE-400 static void Sp_search ( js_State * J ) { js_Regexp * re ; const char * text ; Resub m ; text = checkstring ( J , 0 ) ; if ( js_isregexp ( J , 1 ) ) js_copy ( J , 1 ) ; else if ( js_isundefined ( J , 1 ) ) js_newregexp ( J , "" , 0 ) ; else js_newregexp ( J , js_tostring ( J , 1 ) , 0 ) ; re = js_toregexp ( J , - 1 ) ; <S2SV_StartBug> if ( ! js_regexec ( re -> prog , text , & m , 0 ) ) <S2SV_EndBug> js_pushnumber ( J , js_utfptrtoidx ( text , m . sub [ 0 ] . sp ) ) ; else js_pushnumber ( J , - 1 ) ; }
CWE-400 static void Sp_split_regexp ( js_State * J ) { js_Regexp * re ; const char * text ; int limit , len , k ; const char * p , * a , * b , * c , * e ; Resub m ; text = checkstring ( J , 0 ) ; re = js_toregexp ( J , 1 ) ; limit = js_isdefined ( J , 2 ) ? js_tointeger ( J , 2 ) : 1 << 30 ; js_newarray ( J ) ; len = 0 ; e = text + strlen ( text ) ; if ( e == text ) { <S2SV_StartBug> if ( js_regexec ( re -> prog , text , & m , 0 ) ) { <S2SV_EndBug> if ( len == limit ) return ; js_pushliteral ( J , "" ) ; js_setindex ( J , - 2 , 0 ) ; } return ; } p = a = text ; while ( a < e ) { <S2SV_StartBug> if ( js_regexec ( re -> prog , a , & m , a > text ? REG_NOTBOL : 0 ) ) <S2SV_EndBug> break ; b = m . sub [ 0 ] . sp ; c = m . sub [ 0 ] . ep ; if ( b == p ) { ++ a ; continue ; } if ( len == limit ) return ; js_pushlstring ( J , p , b - p ) ; js_setindex ( J , - 2 , len ++ ) ; for ( k = 1 ; k < m . nsub ; ++ k ) { if ( len == limit ) return ; js_pushlstring ( J , m . sub [ k ] . sp , m . sub [ k ] . ep - m . sub [ k ] . sp ) ; js_setindex ( J , - 2 , len ++ ) ; } a = p = c ; } if ( len == limit ) return ; js_pushstring ( J , p ) ; js_setindex ( J , - 2 , len ) ; }
CWE-400 <S2SV_StartBug> static int match ( Reinst * pc , const char * sp , const char * bol , int flags , Resub * out ) <S2SV_EndBug> { Resub scratch ; <S2SV_StartBug> int i ; <S2SV_EndBug> Rune c ; <S2SV_StartBug> for ( ; ; ) { <S2SV_EndBug> switch ( pc -> opcode ) { case I_END : <S2SV_StartBug> return 1 ; <S2SV_EndBug> case I_JUMP : pc = pc -> x ; break ; case I_SPLIT : scratch = * out ; <S2SV_StartBug> if ( match ( pc -> x , sp , bol , flags , & scratch ) ) { <S2SV_EndBug> * out = scratch ; <S2SV_StartBug> return 1 ; <S2SV_EndBug> } pc = pc -> y ; break ; case I_PLA : <S2SV_StartBug> if ( ! match ( pc -> x , sp , bol , flags , out ) ) <S2SV_EndBug> return 0 ; pc = pc -> y ; break ; case I_NLA : scratch = * out ; <S2SV_StartBug> if ( match ( pc -> x , sp , bol , flags , & scratch ) ) <S2SV_EndBug> return 0 ; pc = pc -> y ; break ; case I_ANYNL : sp += chartorune ( & c , sp ) ; if ( c == 0 ) <S2SV_StartBug> return 0 ; <S2SV_EndBug> pc = pc + 1 ; break ; case I_ANY : sp += chartorune ( & c , sp ) ; if ( c == 0 ) <S2SV_StartBug> return 0 ; <S2SV_EndBug> if ( isnewline ( c ) ) <S2SV_StartBug> return 0 ; <S2SV_EndBug> pc = pc + 1 ; break ; case I_CHAR : sp += chartorune ( & c , sp ) ; if ( c == 0 ) <S2SV_StartBug> return 0 ; <S2SV_EndBug> if ( flags & REG_ICASE ) c = canon ( c ) ; if ( c != pc -> c ) <S2SV_StartBug> return 0 ; <S2SV_EndBug> pc = pc + 1 ; break ; case I_CCLASS : sp += chartorune ( & c , sp ) ; if ( c == 0 ) <S2SV_StartBug> return 0 ; <S2SV_EndBug> if ( flags & REG_ICASE ) { if ( ! incclasscanon ( pc -> cc , canon ( c ) ) ) <S2SV_StartBug> return 0 ; <S2SV_EndBug> } else { if ( ! incclass ( pc -> cc , c ) ) <S2SV_StartBug> return 0 ; <S2SV_EndBug> } pc = pc + 1 ; break ; case I_NCCLASS : sp += chartorune ( & c , sp ) ; if ( c == 0 ) <S2SV_StartBug> return 0 ; <S2SV_EndBug> if ( flags & REG_ICASE ) { if ( incclasscanon ( pc -> cc , canon ( c ) ) ) <S2SV_StartBug> return 0 ; <S2SV_EndBug> } else { if ( incclass ( pc -> cc , c ) ) <S2SV_StartBug> return 0 ; <S2SV_EndBug> } pc = pc + 1 ; break ; case I_REF : i = out -> sub [ pc -> n ] . ep - out -> sub [ pc -> n ] . sp ; if ( flags & REG_ICASE ) { if ( strncmpcanon ( sp , out -> sub [ pc -> n ] . sp , i ) ) <S2SV_StartBug> return 0 ; <S2SV_EndBug> } else { if ( strncmp ( sp , out -> sub [ pc -> n ] . sp , i ) ) <S2SV_StartBug> return 0 ; <S2SV_EndBug> } if ( i > 0 ) sp += i ; pc = pc + 1 ; break ; case I_BOL : if ( sp == bol && ! ( flags & REG_NOTBOL ) ) { pc = pc + 1 ; break ; } if ( flags & REG_NEWLINE ) { if ( sp > bol && isnewline ( sp [ - 1 ] ) ) { pc = pc + 1 ; break ; } } <S2SV_StartBug> return 0 ; <S2SV_EndBug> case I_EOL : if ( * sp == 0 ) { pc = pc + 1 ; break ; } if ( flags & REG_NEWLINE ) { if ( isnewline ( * sp ) ) { pc = pc + 1 ; break ; } } <S2SV_StartBug> return 0 ; <S2SV_EndBug> case I_WORD : i = sp > bol && iswordchar ( sp [ - 1 ] ) ; i ^= iswordchar ( sp [ 0 ] ) ; if ( ! i ) <S2SV_StartBug> return 0 ; <S2SV_EndBug> pc = pc + 1 ; break ; case I_NWORD : i = sp > bol && iswordchar ( sp [ - 1 ] ) ; i ^= iswordchar ( sp [ 0 ] ) ; if ( i ) <S2SV_StartBug> return 0 ; <S2SV_EndBug> pc = pc + 1 ; break ; case I_LPAR : out -> sub [ pc -> n ] . sp = sp ; pc = pc + 1 ; break ; case I_RPAR : out -> sub [ pc -> n ] . ep = sp ; pc = pc + 1 ; break ; default : <S2SV_StartBug> return 0 ; <S2SV_EndBug> } } }
CWE-400 int regexec ( Reprog * prog , const char * sp , Resub * sub , int eflags ) { Resub scratch ; int i ; if ( ! sub ) sub = & scratch ; sub -> nsub = prog -> nsub ; for ( i = 0 ; i < MAXSUB ; ++ i ) sub -> sub [ i ] . sp = sub -> sub [ i ] . ep = NULL ; <S2SV_StartBug> return ! match ( prog -> start , sp , sp , prog -> flags | eflags , sub ) ; <S2SV_EndBug> }
CWE-119 static void ctrycatchfinally ( JF , js_Ast * trystm , js_Ast * catchvar , js_Ast * catchstm , js_Ast * finallystm ) { int L1 , L2 , L3 ; L1 = emitjump ( J , F , OP_TRY ) ; { L2 = emitjump ( J , F , OP_TRY ) ; { cstm ( J , F , finallystm ) ; emit ( J , F , OP_THROW ) ; } label ( J , F , L2 ) ; if ( F -> strict ) { checkfutureword ( J , F , catchvar ) ; if ( ! strcmp ( catchvar -> string , "arguments" ) ) jsC_error ( J , catchvar , "redefining<S2SV_blank>\'arguments\'<S2SV_blank>is<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>in<S2SV_blank>strict<S2SV_blank>mode" ) ; if ( ! strcmp ( catchvar -> string , "eval" ) ) jsC_error ( J , catchvar , "redefining<S2SV_blank>\'eval\'<S2SV_blank>is<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>in<S2SV_blank>strict<S2SV_blank>mode" ) ; } emitline ( J , F , catchvar ) ; emitstring ( J , F , OP_CATCH , catchvar -> string ) ; cstm ( J , F , catchstm ) ; emit ( J , F , OP_ENDCATCH ) ; <S2SV_StartBug> L3 = emitjump ( J , F , OP_JUMP ) ; <S2SV_EndBug> } label ( J , F , L1 ) ; cstm ( J , F , trystm ) ; emit ( J , F , OP_ENDTRY ) ; label ( J , F , L3 ) ; cstm ( J , F , finallystm ) ; }
CWE-119 static void Np_toString ( js_State * J ) { <S2SV_StartBug> char buf [ 32 ] ; <S2SV_EndBug> js_Object * self = js_toobject ( J , 0 ) ; int radix = js_isundefined ( J , 1 ) ? 10 : js_tointeger ( J , 1 ) ; if ( self -> type != JS_CNUMBER ) js_typeerror ( J , "not<S2SV_blank>a<S2SV_blank>number" ) ; if ( radix == 10 ) { js_pushstring ( J , jsV_numbertostring ( J , buf , self -> u . number ) ) ; return ; } if ( radix < 2 || radix > 36 ) js_rangeerror ( J , "invalid<S2SV_blank>radix" ) ; { static const char digits [ ] = "0123456789abcdefghijklmnopqrstuvwxyz" ; <S2SV_StartBug> char buf [ 100 ] ; <S2SV_EndBug> double number = self -> u . number ; int sign = self -> u . number < 0 ; js_Buffer * sb = NULL ; uint64_t u , limit = ( ( uint64_t ) 1 << 52 ) ; int ndigits , exp , point ; if ( number == 0 ) { js_pushstring ( J , "0" ) ; return ; } if ( isnan ( number ) ) { js_pushstring ( J , "NaN" ) ; return ; } if ( isinf ( number ) ) { js_pushstring ( J , sign ? "-Infinity" : "Infinity" ) ; return ; } if ( sign ) number = - number ; exp = 0 ; while ( number * pow ( radix , exp ) > limit ) -- exp ; while ( number * pow ( radix , exp + 1 ) < limit ) ++ exp ; u = number * pow ( radix , exp ) + 0.5 ; while ( u > 0 && ( u % radix ) == 0 ) { u /= radix ; -- exp ; } ndigits = 0 ; while ( u > 0 ) { buf [ ndigits ++ ] = digits [ u % radix ] ; u /= radix ; } point = ndigits - exp ; if ( js_try ( J ) ) { js_free ( J , sb ) ; js_throw ( J ) ; } if ( sign ) js_putc ( J , & sb , '-' ) ; if ( point <= 0 ) { js_putc ( J , & sb , '0' ) ; js_putc ( J , & sb , '.' ) ; while ( point ++ < 0 ) js_putc ( J , & sb , '0' ) ; while ( ndigits -- > 0 ) js_putc ( J , & sb , buf [ ndigits ] ) ; } else { while ( ndigits -- > 0 ) { js_putc ( J , & sb , buf [ ndigits ] ) ; if ( -- point == 0 && ndigits > 0 ) js_putc ( J , & sb , '.' ) ; } while ( point -- > 0 ) js_putc ( J , & sb , '0' ) ; } js_putc ( J , & sb , 0 ) ; js_pushstring ( J , sb -> s ) ; js_endtry ( J ) ; js_free ( J , sb ) ; } }
CWE-119 static void numtostr ( js_State * J , const char * fmt , int w , double n ) { <S2SV_StartBug> char buf [ 32 ] , * e ; <S2SV_EndBug> sprintf ( buf , fmt , w , n ) ; e = strchr ( buf , 'e' ) ; if ( e ) { int exp = atoi ( e + 1 ) ; sprintf ( e , "e%+d" , exp ) ; } js_pushstring ( J , buf ) ; }
CWE-190 static void addArgumentToVtab ( Parse * pParse ) { if ( pParse -> sArg . z && pParse -> pNewTable ) { const char * z = ( const char * ) pParse -> sArg . z ; int n = pParse -> sArg . n ; sqlite3 * db = pParse -> db ; <S2SV_StartBug> addModuleArgument ( db , pParse -> pNewTable , sqlite3DbStrNDup ( db , z , n ) ) ; <S2SV_EndBug> } }
CWE-190 <S2SV_StartBug> static void addModuleArgument ( sqlite3 * db , Table * pTable , char * zArg ) { <S2SV_EndBug> <S2SV_StartBug> int nBytes = sizeof ( char * ) * ( 2 + pTable -> nModuleArg ) ; <S2SV_EndBug> <S2SV_StartBug> char * * azModuleArg ; <S2SV_EndBug> azModuleArg = sqlite3DbRealloc ( db , pTable -> azModuleArg , nBytes ) ; if ( azModuleArg == 0 ) { sqlite3DbFree ( db , zArg ) ; } else { int i = pTable -> nModuleArg ++ ; azModuleArg [ i ] = zArg ; azModuleArg [ i + 1 ] = 0 ; pTable -> azModuleArg = azModuleArg ; } }
CWE-190 static int growOpArray ( Vdbe * v , int nOp ) { VdbeOp * pNew ; Parse * p = v -> pParse ; # ifdef SQLITE_TEST_REALLOC_STRESS <S2SV_StartBug> int nNew = ( v -> nOpAlloc >= 512 ? v -> nOpAlloc * 2 : v -> nOpAlloc + nOp ) ; <S2SV_EndBug> # else <S2SV_StartBug> int nNew = ( v -> nOpAlloc ? v -> nOpAlloc * 2 : ( int ) ( 1024 / sizeof ( Op ) ) ) ; <S2SV_EndBug> UNUSED_PARAMETER ( nOp ) ; # endif if ( nNew > p -> db -> aLimit [ SQLITE_LIMIT_VDBE_OP ] ) { sqlite3OomFault ( p -> db ) ; return SQLITE_NOMEM ; } assert ( nOp <= ( 1024 / sizeof ( Op ) ) ) ; assert ( nNew >= ( v -> nOpAlloc + nOp ) ) ; pNew = sqlite3DbRealloc ( p -> db , v -> aOp , nNew * sizeof ( Op ) ) ; if ( pNew ) { p -> szOpAlloc = sqlite3DbMallocSize ( p -> db , pNew ) ; v -> nOpAlloc = p -> szOpAlloc / sizeof ( Op ) ; v -> aOp = pNew ; } return ( pNew ? SQLITE_OK : SQLITE_NOMEM_BKPT ) ; }
CWE-190 static int growVTrans ( sqlite3 * db ) { const int ARRAY_INCR = 5 ; if ( ( db -> nVTrans % ARRAY_INCR ) == 0 ) { VTable * * aVTrans ; <S2SV_StartBug> int nBytes = sizeof ( sqlite3_vtab * ) * ( db -> nVTrans + ARRAY_INCR ) ; <S2SV_EndBug> aVTrans = sqlite3DbRealloc ( db , ( void * ) db -> aVTrans , nBytes ) ; if ( ! aVTrans ) { return SQLITE_NOMEM_BKPT ; } memset ( & aVTrans [ db -> nVTrans ] , 0 , sizeof ( sqlite3_vtab * ) * ARRAY_INCR ) ; db -> aVTrans = aVTrans ; } return SQLITE_OK ; }
CWE-190 static int setupLookaside ( sqlite3 * db , void * pBuf , int sz , int cnt ) { # ifndef SQLITE_OMIT_LOOKASIDE void * pStart ; if ( sqlite3LookasideUsed ( db , 0 ) > 0 ) { return SQLITE_BUSY ; } if ( db -> lookaside . bMalloced ) { sqlite3_free ( db -> lookaside . pStart ) ; } sz = ROUNDDOWN8 ( sz ) ; if ( sz <= ( int ) sizeof ( LookasideSlot * ) ) sz = 0 ; if ( cnt < 0 ) cnt = 0 ; if ( sz == 0 || cnt == 0 ) { sz = 0 ; pStart = 0 ; } else if ( pBuf == 0 ) { sqlite3BeginBenignMalloc ( ) ; <S2SV_StartBug> pStart = sqlite3Malloc ( sz * cnt ) ; <S2SV_EndBug> sqlite3EndBenignMalloc ( ) ; if ( pStart ) cnt = sqlite3MallocSize ( pStart ) / sz ; } else { pStart = pBuf ; } db -> lookaside . pStart = pStart ; db -> lookaside . pInit = 0 ; db -> lookaside . pFree = 0 ; db -> lookaside . sz = ( u16 ) sz ; if ( pStart ) { int i ; LookasideSlot * p ; assert ( sz > ( int ) sizeof ( LookasideSlot * ) ) ; db -> lookaside . nSlot = cnt ; p = ( LookasideSlot * ) pStart ; for ( i = cnt - 1 ; i >= 0 ; i -- ) { p -> pNext = db -> lookaside . pInit ; db -> lookaside . pInit = p ; p = ( LookasideSlot * ) & ( ( u8 * ) p ) [ sz ] ; } db -> lookaside . pEnd = p ; db -> lookaside . bDisable = 0 ; db -> lookaside . bMalloced = pBuf == 0 ? 1 : 0 ; } else { db -> lookaside . pStart = db ; db -> lookaside . pEnd = db ; db -> lookaside . bDisable = 1 ; db -> lookaside . bMalloced = 0 ; db -> lookaside . nSlot = 0 ; } # endif return SQLITE_OK ; }
CWE-190 SQLITE_PRIVATE void * sqlite3ArrayAllocate ( sqlite3 * db , void * pArray , int szEntry , int * pnEntry , int * pIdx ) { char * z ; <S2SV_StartBug> int n = * pnEntry ; <S2SV_EndBug> if ( ( n & ( n - 1 ) ) == 0 ) { <S2SV_StartBug> int sz = ( n == 0 ) ? 1 : 2 * n ; <S2SV_EndBug> void * pNew = sqlite3DbRealloc ( db , pArray , sz * szEntry ) ; if ( pNew == 0 ) { * pIdx = - 1 ; return pArray ; } pArray = pNew ; } z = ( char * ) pArray ; memset ( & z [ n * szEntry ] , 0 , szEntry ) ; * pIdx = n ; ++ * pnEntry ; return pArray ; }
CWE-190 SQLITE_PRIVATE ExprList * sqlite3ExprListAppend ( Parse * pParse , ExprList * pList , Expr * pExpr ) { struct ExprList_item * pItem ; sqlite3 * db = pParse -> db ; assert ( db != 0 ) ; if ( pList == 0 ) { pList = sqlite3DbMallocRawNN ( db , sizeof ( ExprList ) ) ; if ( pList == 0 ) { goto no_mem ; } pList -> nExpr = 0 ; } else if ( ( pList -> nExpr & ( pList -> nExpr - 1 ) ) == 0 ) { ExprList * pNew ; pNew = sqlite3DbRealloc ( db , pList , <S2SV_StartBug> sizeof ( * pList ) + ( 2 * pList -> nExpr - 1 ) * sizeof ( pList -> a [ 0 ] ) ) ; <S2SV_EndBug> if ( pNew == 0 ) { goto no_mem ; } pList = pNew ; } pItem = & pList -> a [ pList -> nExpr ++ ] ; assert ( offsetof ( struct ExprList_item , zName ) == sizeof ( pItem -> pExpr ) ) ; assert ( offsetof ( struct ExprList_item , pExpr ) == 0 ) ; memset ( & pItem -> zName , 0 , sizeof ( * pItem ) - offsetof ( struct ExprList_item , zName ) ) ; pItem -> pExpr = pExpr ; return pList ; no_mem : sqlite3ExprDelete ( db , pExpr ) ; sqlite3ExprListDelete ( db , pList ) ; return 0 ; }
CWE-190 SQLITE_PRIVATE SrcList * sqlite3SrcListEnlarge ( Parse * pParse , SrcList * pSrc , int nExtra , int iStart ) { int i ; assert ( iStart >= 0 ) ; assert ( nExtra >= 1 ) ; assert ( pSrc != 0 ) ; assert ( iStart <= pSrc -> nSrc ) ; if ( ( u32 ) pSrc -> nSrc + nExtra > pSrc -> nAlloc ) { SrcList * pNew ; <S2SV_StartBug> int nAlloc = pSrc -> nSrc * 2 + nExtra ; <S2SV_EndBug> sqlite3 * db = pParse -> db ; if ( pSrc -> nSrc + nExtra >= SQLITE_MAX_SRCLIST ) { sqlite3ErrorMsg ( pParse , "too<S2SV_blank>many<S2SV_blank>FROM<S2SV_blank>clause<S2SV_blank>terms,<S2SV_blank>max:<S2SV_blank>%d" , SQLITE_MAX_SRCLIST ) ; return 0 ; } if ( nAlloc > SQLITE_MAX_SRCLIST ) nAlloc = SQLITE_MAX_SRCLIST ; pNew = sqlite3DbRealloc ( db , pSrc , sizeof ( * pSrc ) + ( nAlloc - 1 ) * sizeof ( pSrc -> a [ 0 ] ) ) ; if ( pNew == 0 ) { assert ( db -> mallocFailed ) ; return 0 ; } pSrc = pNew ; pSrc -> nAlloc = nAlloc ; } for ( i = pSrc -> nSrc - 1 ; i >= iStart ; i -- ) { pSrc -> a [ i + nExtra ] = pSrc -> a [ i ] ; } pSrc -> nSrc += nExtra ; memset ( & pSrc -> a [ iStart ] , 0 , sizeof ( pSrc -> a [ 0 ] ) * nExtra ) ; for ( i = iStart ; i < iStart + nExtra ; i ++ ) { pSrc -> a [ i ] . iCursor = - 1 ; } return pSrc ; }
CWE-190 SQLITE_PRIVATE VList * sqlite3VListAdd ( sqlite3 * db , VList * pIn , const char * zName , int nName , int iVal ) { int nInt ; char * z ; int i ; nInt = nName / 4 + 3 ; assert ( pIn == 0 || pIn [ 0 ] >= 3 ) ; if ( pIn == 0 || pIn [ 1 ] + nInt > pIn [ 0 ] ) { <S2SV_StartBug> int nAlloc = ( pIn ? pIn [ 0 ] * 2 : 10 ) + nInt ; <S2SV_EndBug> VList * pOut = sqlite3DbRealloc ( db , pIn , nAlloc * sizeof ( int ) ) ; if ( pOut == 0 ) return pIn ; if ( pIn == 0 ) pOut [ 1 ] = 2 ; pIn = pOut ; pIn [ 0 ] = nAlloc ; } i = pIn [ 1 ] ; pIn [ i ] = iVal ; pIn [ i + 1 ] = nInt ; z = ( char * ) & pIn [ i + 2 ] ; pIn [ 1 ] = i + nInt ; assert ( pIn [ 1 ] <= pIn [ 0 ] ) ; memcpy ( z , zName , nName ) ; z [ nName ] = 0 ; return pIn ; }
CWE-190 SQLITE_PRIVATE int sqlite3VdbeSorterWrite ( const VdbeCursor * pCsr , Mem * pVal ) { VdbeSorter * pSorter ; int rc = SQLITE_OK ; SorterRecord * pNew ; int bFlush ; int nReq ; int nPMA ; int t ; assert ( pCsr -> eCurType == CURTYPE_SORTER ) ; pSorter = pCsr -> uc . pSorter ; getVarint32 ( ( const u8 * ) & pVal -> z [ 1 ] , t ) ; if ( t > 0 && t < 10 && t != 7 ) { pSorter -> typeMask &= SORTER_TYPE_INTEGER ; } else if ( t > 10 && ( t & 0x01 ) ) { pSorter -> typeMask &= SORTER_TYPE_TEXT ; } else { pSorter -> typeMask = 0 ; } assert ( pSorter ) ; nReq = pVal -> n + sizeof ( SorterRecord ) ; nPMA = pVal -> n + sqlite3VarintLen ( pVal -> n ) ; if ( pSorter -> mxPmaSize ) { if ( pSorter -> list . aMemory ) { bFlush = pSorter -> iMemory && ( pSorter -> iMemory + nReq ) > pSorter -> mxPmaSize ; } else { bFlush = ( ( pSorter -> list . szPMA > pSorter -> mxPmaSize ) || ( pSorter -> list . szPMA > pSorter -> mnPmaSize && sqlite3HeapNearlyFull ( ) ) ) ; } if ( bFlush ) { rc = vdbeSorterFlushPMA ( pSorter ) ; pSorter -> list . szPMA = 0 ; pSorter -> iMemory = 0 ; assert ( rc != SQLITE_OK || pSorter -> list . pList == 0 ) ; } } pSorter -> list . szPMA += nPMA ; if ( nPMA > pSorter -> mxKeysize ) { pSorter -> mxKeysize = nPMA ; } if ( pSorter -> list . aMemory ) { int nMin = pSorter -> iMemory + nReq ; if ( nMin > pSorter -> nMemory ) { u8 * aNew ; int iListOff = ( u8 * ) pSorter -> list . pList - pSorter -> list . aMemory ; <S2SV_StartBug> int nNew = pSorter -> nMemory * 2 ; <S2SV_EndBug> while ( nNew < nMin ) nNew = nNew * 2 ; if ( nNew > pSorter -> mxPmaSize ) nNew = pSorter -> mxPmaSize ; if ( nNew < nMin ) nNew = nMin ; aNew = sqlite3Realloc ( pSorter -> list . aMemory , nNew ) ; if ( ! aNew ) return SQLITE_NOMEM_BKPT ; pSorter -> list . pList = ( SorterRecord * ) & aNew [ iListOff ] ; pSorter -> list . aMemory = aNew ; pSorter -> nMemory = nNew ; } pNew = ( SorterRecord * ) & pSorter -> list . aMemory [ pSorter -> iMemory ] ; pSorter -> iMemory += ROUND8 ( nReq ) ; if ( pSorter -> list . pList ) { pNew -> u . iNext = ( int ) ( ( u8 * ) ( pSorter -> list . pList ) - pSorter -> list . aMemory ) ; } } else { pNew = ( SorterRecord * ) sqlite3Malloc ( nReq ) ; if ( pNew == 0 ) { return SQLITE_NOMEM_BKPT ; } pNew -> u . pNext = pSorter -> list . pList ; } memcpy ( SRVAL ( pNew ) , pVal -> z , pVal -> n ) ; pNew -> nVal = pVal -> n ; pSorter -> list . pList = pNew ; return rc ; }
CWE-190 SQLITE_PRIVATE void sqlite3VtabBeginParse ( Parse * pParse , Token * pName1 , Token * pName2 , Token * pModuleName , int ifNotExists ) { Table * pTable ; sqlite3 * db ; sqlite3StartTable ( pParse , pName1 , pName2 , 0 , 0 , 1 , ifNotExists ) ; pTable = pParse -> pNewTable ; if ( pTable == 0 ) return ; assert ( 0 == pTable -> pIndex ) ; db = pParse -> db ; assert ( pTable -> nModuleArg == 0 ) ; <S2SV_StartBug> addModuleArgument ( db , pTable , sqlite3NameFromToken ( db , pModuleName ) ) ; <S2SV_EndBug> <S2SV_StartBug> addModuleArgument ( db , pTable , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> addModuleArgument ( db , pTable , sqlite3DbStrDup ( db , pTable -> zName ) ) ; <S2SV_EndBug> assert ( ( pParse -> sNameToken . z == pName2 -> z && pName2 -> z != 0 ) || ( pParse -> sNameToken . z == pName1 -> z && pName2 -> z == 0 ) ) ; pParse -> sNameToken . n = ( int ) ( & pModuleName -> z [ pModuleName -> n ] - pParse -> sNameToken . z ) ; # ifndef SQLITE_OMIT_AUTHORIZATION if ( pTable -> azModuleArg ) { int iDb = sqlite3SchemaToIndex ( db , pTable -> pSchema ) ; assert ( iDb >= 0 ) ; sqlite3AuthCheck ( pParse , SQLITE_CREATE_VTABLE , pTable -> zName , pTable -> azModuleArg [ 0 ] , pParse -> db -> aDb [ iDb ] . zDbSName ) ; } # endif }
CWE-190 SQLITE_PRIVATE int sqlite3VtabEponymousTableInit ( Parse * pParse , Module * pMod ) { const sqlite3_module * pModule = pMod -> pModule ; Table * pTab ; char * zErr = 0 ; int rc ; sqlite3 * db = pParse -> db ; if ( pMod -> pEpoTab ) return 1 ; if ( pModule -> xCreate != 0 && pModule -> xCreate != pModule -> xConnect ) return 0 ; pTab = sqlite3DbMallocZero ( db , sizeof ( Table ) ) ; if ( pTab == 0 ) return 0 ; pTab -> zName = sqlite3DbStrDup ( db , pMod -> zName ) ; if ( pTab -> zName == 0 ) { sqlite3DbFree ( db , pTab ) ; return 0 ; } pMod -> pEpoTab = pTab ; pTab -> nTabRef = 1 ; pTab -> pSchema = db -> aDb [ 0 ] . pSchema ; assert ( pTab -> nModuleArg == 0 ) ; pTab -> iPKey = - 1 ; <S2SV_StartBug> addModuleArgument ( db , pTab , sqlite3DbStrDup ( db , pTab -> zName ) ) ; <S2SV_EndBug> <S2SV_StartBug> addModuleArgument ( db , pTab , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> addModuleArgument ( db , pTab , sqlite3DbStrDup ( db , pTab -> zName ) ) ; <S2SV_EndBug> rc = vtabCallConstructor ( db , pTab , pMod , pModule -> xConnect , & zErr ) ; if ( rc ) { sqlite3ErrorMsg ( pParse , "%s" , zErr ) ; sqlite3DbFree ( db , zErr ) ; sqlite3VtabEponymousTableClear ( db , pMod ) ; return 0 ; } return 1 ; }
CWE-190 SQLITE_PRIVATE With * sqlite3WithAdd ( Parse * pParse , With * pWith , Token * pName , ExprList * pArglist , Select * pQuery ) { sqlite3 * db = pParse -> db ; With * pNew ; char * zName ; zName = sqlite3NameFromToken ( pParse -> db , pName ) ; if ( zName && pWith ) { int i ; for ( i = 0 ; i < pWith -> nCte ; i ++ ) { if ( sqlite3StrICmp ( zName , pWith -> a [ i ] . zName ) == 0 ) { sqlite3ErrorMsg ( pParse , "duplicate<S2SV_blank>WITH<S2SV_blank>table<S2SV_blank>name:<S2SV_blank>%s" , zName ) ; } } } if ( pWith ) { <S2SV_StartBug> int nByte = sizeof ( * pWith ) + ( sizeof ( pWith -> a [ 1 ] ) * pWith -> nCte ) ; <S2SV_EndBug> pNew = sqlite3DbRealloc ( db , pWith , nByte ) ; } else { pNew = sqlite3DbMallocZero ( db , sizeof ( * pWith ) ) ; } assert ( ( pNew != 0 && zName != 0 ) || db -> mallocFailed ) ; if ( db -> mallocFailed ) { sqlite3ExprListDelete ( db , pArglist ) ; sqlite3SelectDelete ( db , pQuery ) ; sqlite3DbFree ( db , zName ) ; pNew = pWith ; } else { pNew -> a [ pNew -> nCte ] . pSelect = pQuery ; pNew -> a [ pNew -> nCte ] . pCols = pArglist ; pNew -> a [ pNew -> nCte ] . zName = zName ; pNew -> a [ pNew -> nCte ] . zCteErr = 0 ; pNew -> nCte ++ ; } return pNew ; }
CWE-190 static int vdbePmaReadBlob ( PmaReader * p , int nByte , u8 * * ppOut ) { int iBuf ; int nAvail ; if ( p -> aMap ) { * ppOut = & p -> aMap [ p -> iReadOff ] ; p -> iReadOff += nByte ; return SQLITE_OK ; } assert ( p -> aBuffer ) ; iBuf = p -> iReadOff % p -> nBuffer ; if ( iBuf == 0 ) { int nRead ; int rc ; if ( ( p -> iEof - p -> iReadOff ) > ( i64 ) p -> nBuffer ) { nRead = p -> nBuffer ; } else { nRead = ( int ) ( p -> iEof - p -> iReadOff ) ; } assert ( nRead > 0 ) ; rc = sqlite3OsRead ( p -> pFd , p -> aBuffer , nRead , p -> iReadOff ) ; assert ( rc != SQLITE_IOERR_SHORT_READ ) ; if ( rc != SQLITE_OK ) return rc ; } nAvail = p -> nBuffer - iBuf ; if ( nByte <= nAvail ) { * ppOut = & p -> aBuffer [ iBuf ] ; p -> iReadOff += nByte ; } else { int nRem ; if ( p -> nAlloc < nByte ) { u8 * aNew ; <S2SV_StartBug> int nNew = MAX ( 128 , p -> nAlloc * 2 ) ; <S2SV_EndBug> while ( nByte > nNew ) nNew = nNew * 2 ; aNew = sqlite3Realloc ( p -> aAlloc , nNew ) ; if ( ! aNew ) return SQLITE_NOMEM_BKPT ; p -> nAlloc = nNew ; p -> aAlloc = aNew ; } memcpy ( p -> aAlloc , & p -> aBuffer [ iBuf ] , nAvail ) ; p -> iReadOff += nAvail ; nRem = nByte - nAvail ; while ( nRem > 0 ) { int rc ; int nCopy ; u8 * aNext ; nCopy = nRem ; if ( nRem > p -> nBuffer ) nCopy = p -> nBuffer ; rc = vdbePmaReadBlob ( p , nCopy , & aNext ) ; if ( rc != SQLITE_OK ) return rc ; assert ( aNext != p -> aAlloc ) ; memcpy ( & p -> aAlloc [ nByte - nRem ] , aNext , nCopy ) ; nRem -= nCopy ; } * ppOut = p -> aAlloc ; } return SQLITE_OK ; }
CWE-190 static MatchinfoBuffer * fts3MIBufferNew ( int nElem , const char * zMatchinfo ) { MatchinfoBuffer * pRet ; <S2SV_StartBug> int nByte = sizeof ( u32 ) * ( 2 * nElem + 1 ) + sizeof ( MatchinfoBuffer ) ; <S2SV_EndBug> <S2SV_StartBug> int nStr = ( int ) strlen ( zMatchinfo ) ; <S2SV_EndBug> <S2SV_StartBug> pRet = sqlite3_malloc ( nByte + nStr + 1 ) ; <S2SV_EndBug> if ( pRet ) { memset ( pRet , 0 , nByte ) ; pRet -> aMatchinfo [ 0 ] = ( u8 * ) ( & pRet -> aMatchinfo [ 1 ] ) - ( u8 * ) pRet ; pRet -> aMatchinfo [ 1 + nElem ] = pRet -> aMatchinfo [ 0 ] + sizeof ( u32 ) * ( nElem + 1 ) ; pRet -> nElem = nElem ; pRet -> zMatchinfo = ( ( char * ) pRet ) + nByte ; memcpy ( pRet -> zMatchinfo , zMatchinfo , nStr + 1 ) ; pRet -> aRef [ 0 ] = 1 ; } return pRet ; }
CWE-190 static int fts3tokFilterMethod ( sqlite3_vtab_cursor * pCursor , int idxNum , const char * idxStr , int nVal , sqlite3_value * * apVal ) { int rc = SQLITE_ERROR ; Fts3tokCursor * pCsr = ( Fts3tokCursor * ) pCursor ; Fts3tokTable * pTab = ( Fts3tokTable * ) ( pCursor -> pVtab ) ; UNUSED_PARAMETER ( idxStr ) ; UNUSED_PARAMETER ( nVal ) ; fts3tokResetCursor ( pCsr ) ; if ( idxNum == 1 ) { const char * zByte = ( const char * ) sqlite3_value_text ( apVal [ 0 ] ) ; int nByte = sqlite3_value_bytes ( apVal [ 0 ] ) ; <S2SV_StartBug> pCsr -> zInput = sqlite3_malloc ( nByte + 1 ) ; <S2SV_EndBug> if ( pCsr -> zInput == 0 ) { rc = SQLITE_NOMEM ; } else { memcpy ( pCsr -> zInput , zByte , nByte ) ; pCsr -> zInput [ nByte ] = 0 ; rc = pTab -> pMod -> xOpen ( pTab -> pTok , pCsr -> zInput , nByte , & pCsr -> pCsr ) ; if ( rc == SQLITE_OK ) { pCsr -> pCsr -> pTokenizer = pTab -> pTok ; } } } if ( rc != SQLITE_OK ) return rc ; return fts3tokNextMethod ( pCursor ) ; }
CWE-190 int sqlite3Fts3InitTokenizer ( Fts3Hash * pHash , const char * zArg , sqlite3_tokenizer * * ppTok , char * * pzErr ) { int rc ; char * z = ( char * ) zArg ; int n = 0 ; char * zCopy ; char * zEnd ; sqlite3_tokenizer_module * m ; zCopy = sqlite3_mprintf ( "%s" , zArg ) ; if ( ! zCopy ) return SQLITE_NOMEM ; zEnd = & zCopy [ strlen ( zCopy ) ] ; z = ( char * ) sqlite3Fts3NextToken ( zCopy , & n ) ; if ( z == 0 ) { assert ( n == 0 ) ; z = zCopy ; } z [ n ] = '\\0' ; sqlite3Fts3Dequote ( z ) ; m = ( sqlite3_tokenizer_module * ) sqlite3Fts3HashFind ( pHash , z , ( int ) strlen ( z ) + 1 ) ; if ( ! m ) { sqlite3Fts3ErrMsg ( pzErr , "unknown<S2SV_blank>tokenizer:<S2SV_blank>%s" , z ) ; rc = SQLITE_ERROR ; } else { char const * * aArg = 0 ; int iArg = 0 ; z = & z [ n + 1 ] ; while ( z < zEnd && ( NULL != ( z = ( char * ) sqlite3Fts3NextToken ( z , & n ) ) ) ) { <S2SV_StartBug> int nNew = sizeof ( char * ) * ( iArg + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> char const * * aNew = ( const char * * ) sqlite3_realloc ( ( void * ) aArg , nNew ) ; <S2SV_EndBug> if ( ! aNew ) { sqlite3_free ( zCopy ) ; sqlite3_free ( ( void * ) aArg ) ; return SQLITE_NOMEM ; } aArg = aNew ; aArg [ iArg ++ ] = z ; z [ n ] = '\\0' ; sqlite3Fts3Dequote ( z ) ; z = & z [ n + 1 ] ; } rc = m -> xCreate ( iArg , aArg , ppTok ) ; assert ( rc != SQLITE_OK || * ppTok ) ; if ( rc != SQLITE_OK ) { sqlite3Fts3ErrMsg ( pzErr , "unknown<S2SV_blank>tokenizer" ) ; } else { ( * ppTok ) -> pModule = m ; } sqlite3_free ( ( void * ) aArg ) ; } sqlite3_free ( zCopy ) ; return rc ; }
CWE-665 int ParseWave64HeaderConfig ( FILE * infile , char * infilename , char * fourcc , WavpackContext * wpc , WavpackConfig * config ) { int64_t total_samples = 0 , infilesize ; Wave64ChunkHeader chunk_header ; Wave64FileHeader filehdr ; WaveHeader WaveHeader ; int format_chunk = 0 ; <S2SV_StartBug> uint32_t bcount ; <S2SV_EndBug> infilesize = DoGetFileSize ( infile ) ; memcpy ( & filehdr , fourcc , 4 ) ; if ( ! DoReadFile ( infile , ( ( char * ) & filehdr ) + 4 , sizeof ( Wave64FileHeader ) - 4 , & bcount ) || bcount != sizeof ( Wave64FileHeader ) - 4 || memcmp ( filehdr . ckID , riff_guid , sizeof ( riff_guid ) ) || memcmp ( filehdr . formType , wave_guid , sizeof ( wave_guid ) ) ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & filehdr , sizeof ( filehdr ) ) ) { error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } # if 1 WavpackLittleEndianToNative ( & filehdr , Wave64ChunkHeaderFormat ) ; if ( infilesize && ! ( config -> qmode & QMODE_IGNORE_LENGTH ) && filehdr . ckSize && filehdr . ckSize + 1 && filehdr . ckSize != infilesize ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } # endif while ( 1 ) { if ( ! DoReadFile ( infile , & chunk_header , sizeof ( Wave64ChunkHeader ) , & bcount ) || bcount != sizeof ( Wave64ChunkHeader ) ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & chunk_header , sizeof ( Wave64ChunkHeader ) ) ) { error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackLittleEndianToNative ( & chunk_header , Wave64ChunkHeaderFormat ) ; chunk_header . ckSize -= sizeof ( chunk_header ) ; if ( ! memcmp ( chunk_header . ckID , fmt_guid , sizeof ( fmt_guid ) ) ) { int supported = TRUE , format ; if ( format_chunk ++ ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } chunk_header . ckSize = ( chunk_header . ckSize + 7 ) & ~ 7L ; if ( chunk_header . ckSize < 16 || chunk_header . ckSize > sizeof ( WaveHeader ) || ! DoReadFile ( infile , & WaveHeader , ( uint32_t ) chunk_header . ckSize , & bcount ) || bcount != chunk_header . ckSize ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & WaveHeader , ( uint32_t ) chunk_header . ckSize ) ) { error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackLittleEndianToNative ( & WaveHeader , WaveHeaderFormat ) ; if ( debug_logging_mode ) { error_line ( "format<S2SV_blank>tag<S2SV_blank>size<S2SV_blank>=<S2SV_blank>%d" , chunk_header . ckSize ) ; error_line ( "FormatTag<S2SV_blank>=<S2SV_blank>%x,<S2SV_blank>NumChannels<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>BitsPerSample<S2SV_blank>=<S2SV_blank>%d" , WaveHeader . FormatTag , WaveHeader . NumChannels , WaveHeader . BitsPerSample ) ; error_line ( "BlockAlign<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>SampleRate<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>BytesPerSecond<S2SV_blank>=<S2SV_blank>%d" , WaveHeader . BlockAlign , WaveHeader . SampleRate , WaveHeader . BytesPerSecond ) ; if ( chunk_header . ckSize > 16 ) error_line ( "cbSize<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>ValidBitsPerSample<S2SV_blank>=<S2SV_blank>%d" , WaveHeader . cbSize , WaveHeader . ValidBitsPerSample ) ; if ( chunk_header . ckSize > 20 ) error_line ( "ChannelMask<S2SV_blank>=<S2SV_blank>%x,<S2SV_blank>SubFormat<S2SV_blank>=<S2SV_blank>%d" , WaveHeader . ChannelMask , WaveHeader . SubFormat ) ; } if ( chunk_header . ckSize > 16 && WaveHeader . cbSize == 2 ) config -> qmode |= QMODE_ADOBE_MODE ; format = ( WaveHeader . FormatTag == 0xfffe && chunk_header . ckSize == 40 ) ? WaveHeader . SubFormat : WaveHeader . FormatTag ; config -> bits_per_sample = ( chunk_header . ckSize == 40 && WaveHeader . ValidBitsPerSample ) ? WaveHeader . ValidBitsPerSample : WaveHeader . BitsPerSample ; if ( format != 1 && format != 3 ) supported = FALSE ; if ( format == 3 && config -> bits_per_sample != 32 ) supported = FALSE ; if ( ! WaveHeader . NumChannels || WaveHeader . NumChannels > 256 || WaveHeader . BlockAlign / WaveHeader . NumChannels < ( config -> bits_per_sample + 7 ) / 8 || WaveHeader . BlockAlign / WaveHeader . NumChannels > 4 || WaveHeader . BlockAlign % WaveHeader . NumChannels ) supported = FALSE ; if ( config -> bits_per_sample < 1 || config -> bits_per_sample > 32 ) supported = FALSE ; if ( ! supported ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>an<S2SV_blank>unsupported<S2SV_blank>.W64<S2SV_blank>format!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( chunk_header . ckSize < 40 ) { if ( ! config -> channel_mask && ! ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) { if ( WaveHeader . NumChannels <= 2 ) config -> channel_mask = 0x5 - WaveHeader . NumChannels ; else if ( WaveHeader . NumChannels <= 18 ) config -> channel_mask = ( 1 << WaveHeader . NumChannels ) - 1 ; else config -> channel_mask = 0x3ffff ; } } else if ( WaveHeader . ChannelMask && ( config -> channel_mask || ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) ) { error_line ( "this<S2SV_blank>W64<S2SV_blank>file<S2SV_blank>already<S2SV_blank>has<S2SV_blank>channel<S2SV_blank>order<S2SV_blank>information!" ) ; return WAVPACK_SOFT_ERROR ; } else if ( WaveHeader . ChannelMask ) config -> channel_mask = WaveHeader . ChannelMask ; if ( format == 3 ) config -> float_norm_exp = 127 ; else if ( ( config -> qmode & QMODE_ADOBE_MODE ) && WaveHeader . BlockAlign / WaveHeader . NumChannels == 4 ) { if ( WaveHeader . BitsPerSample == 24 ) config -> float_norm_exp = 127 + 23 ; else if ( WaveHeader . BitsPerSample == 32 ) config -> float_norm_exp = 127 + 15 ; } if ( debug_logging_mode ) { if ( config -> float_norm_exp == 127 ) error_line ( "data<S2SV_blank>format:<S2SV_blank>normalized<S2SV_blank>32-bit<S2SV_blank>floating<S2SV_blank>point" ) ; else error_line ( "data<S2SV_blank>format:<S2SV_blank>%d-bit<S2SV_blank>integers<S2SV_blank>stored<S2SV_blank>in<S2SV_blank>%d<S2SV_blank>byte(s)" , config -> bits_per_sample , WaveHeader . BlockAlign / WaveHeader . NumChannels ) ; } } else if ( ! memcmp ( chunk_header . ckID , data_guid , sizeof ( data_guid ) ) ) { if ( ! WaveHeader . NumChannels ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( ( config -> qmode & QMODE_IGNORE_LENGTH ) || chunk_header . ckSize <= 0 ) { config -> qmode |= QMODE_IGNORE_LENGTH ; if ( infilesize && DoGetFilePosition ( infile ) != - 1 ) total_samples = ( infilesize - DoGetFilePosition ( infile ) ) / WaveHeader . BlockAlign ; else total_samples = - 1 ; } else { if ( infilesize && infilesize - chunk_header . ckSize > 16777216 ) { error_line ( "this<S2SV_blank>.W64<S2SV_blank>file<S2SV_blank>has<S2SV_blank>over<S2SV_blank>16<S2SV_blank>MB<S2SV_blank>of<S2SV_blank>extra<S2SV_blank>RIFF<S2SV_blank>data,<S2SV_blank>probably<S2SV_blank>is<S2SV_blank>corrupt!" ) ; return WAVPACK_SOFT_ERROR ; } total_samples = chunk_header . ckSize / WaveHeader . BlockAlign ; if ( ! total_samples ) { error_line ( "this<S2SV_blank>.W64<S2SV_blank>file<S2SV_blank>has<S2SV_blank>no<S2SV_blank>audio<S2SV_blank>samples,<S2SV_blank>probably<S2SV_blank>is<S2SV_blank>corrupt!" ) ; return WAVPACK_SOFT_ERROR ; } if ( total_samples > MAX_WAVPACK_SAMPLES ) { error_line ( "%s<S2SV_blank>has<S2SV_blank>too<S2SV_blank>many<S2SV_blank>samples<S2SV_blank>for<S2SV_blank>WavPack!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } } config -> bytes_per_sample = WaveHeader . BlockAlign / WaveHeader . NumChannels ; config -> num_channels = WaveHeader . NumChannels ; config -> sample_rate = WaveHeader . SampleRate ; break ; } else { int bytes_to_copy = ( chunk_header . ckSize + 7 ) & ~ 7L ; char * buff ; if ( bytes_to_copy < 0 || bytes_to_copy > 4194304 ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } buff = malloc ( bytes_to_copy ) ; if ( debug_logging_mode ) error_line ( "extra<S2SV_blank>unknown<S2SV_blank>chunk<S2SV_blank>\\"%c%c%c%c\\"<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes" , chunk_header . ckID [ 0 ] , chunk_header . ckID [ 1 ] , chunk_header . ckID [ 2 ] , chunk_header . ckID [ 3 ] , chunk_header . ckSize ) ; if ( ! DoReadFile ( infile , buff , bytes_to_copy , & bcount ) || bcount != bytes_to_copy || ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , buff , bytes_to_copy ) ) ) { error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; free ( buff ) ; return WAVPACK_SOFT_ERROR ; } free ( buff ) ; } } if ( ! WavpackSetConfiguration64 ( wpc , config , total_samples , NULL ) ) { error_line ( "%s:<S2SV_blank>%s" , infilename , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } return WAVPACK_NO_ERROR ; }
CWE-369 int ParseDsdiffHeaderConfig ( FILE * infile , char * infilename , char * fourcc , WavpackContext * wpc , WavpackConfig * config ) { int64_t infilesize , total_samples ; DFFFileHeader dff_file_header ; DFFChunkHeader dff_chunk_header ; uint32_t bcount ; infilesize = DoGetFileSize ( infile ) ; memcpy ( & dff_file_header , fourcc , 4 ) ; if ( ( ! DoReadFile ( infile , ( ( char * ) & dff_file_header ) + 4 , sizeof ( DFFFileHeader ) - 4 , & bcount ) || bcount != sizeof ( DFFFileHeader ) - 4 ) || strncmp ( dff_file_header . formType , "DSD<S2SV_blank>" , 4 ) ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & dff_file_header , sizeof ( DFFFileHeader ) ) ) { error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } # if 1 WavpackBigEndianToNative ( & dff_file_header , DFFFileHeaderFormat ) ; if ( infilesize && ! ( config -> qmode & QMODE_IGNORE_LENGTH ) && dff_file_header . ckDataSize && dff_file_header . ckDataSize + 1 && dff_file_header . ckDataSize + 12 != infilesize ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file<S2SV_blank>(by<S2SV_blank>total<S2SV_blank>size)!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( debug_logging_mode ) error_line ( "file<S2SV_blank>header<S2SV_blank>indicated<S2SV_blank>length<S2SV_blank>=<S2SV_blank>%lld" , dff_file_header . ckDataSize ) ; # endif while ( 1 ) { if ( ! DoReadFile ( infile , & dff_chunk_header , sizeof ( DFFChunkHeader ) , & bcount ) || bcount != sizeof ( DFFChunkHeader ) ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & dff_chunk_header , sizeof ( DFFChunkHeader ) ) ) { error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackBigEndianToNative ( & dff_chunk_header , DFFChunkHeaderFormat ) ; if ( debug_logging_mode ) error_line ( "chunk<S2SV_blank>header<S2SV_blank>indicated<S2SV_blank>length<S2SV_blank>=<S2SV_blank>%lld" , dff_chunk_header . ckDataSize ) ; if ( ! strncmp ( dff_chunk_header . ckID , "FVER" , 4 ) ) { uint32_t version ; if ( dff_chunk_header . ckDataSize != sizeof ( version ) || ! DoReadFile ( infile , & version , sizeof ( version ) , & bcount ) || bcount != sizeof ( version ) ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & version , sizeof ( version ) ) ) { error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackBigEndianToNative ( & version , "L" ) ; if ( debug_logging_mode ) error_line ( "dsdiff<S2SV_blank>file<S2SV_blank>version<S2SV_blank>=<S2SV_blank>0x%08x" , version ) ; } else if ( ! strncmp ( dff_chunk_header . ckID , "PROP" , 4 ) ) { char * prop_chunk ; if ( dff_chunk_header . ckDataSize < 4 || dff_chunk_header . ckDataSize > 1024 ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( debug_logging_mode ) error_line ( "got<S2SV_blank>PROP<S2SV_blank>chunk<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>total" , ( int ) dff_chunk_header . ckDataSize ) ; prop_chunk = malloc ( ( size_t ) dff_chunk_header . ckDataSize ) ; if ( ! DoReadFile ( infile , prop_chunk , ( uint32_t ) dff_chunk_header . ckDataSize , & bcount ) || bcount != dff_chunk_header . ckDataSize ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!" , infilename ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , prop_chunk , ( uint32_t ) dff_chunk_header . ckDataSize ) ) { error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } if ( ! strncmp ( prop_chunk , "SND<S2SV_blank>" , 4 ) ) { char * cptr = prop_chunk + 4 , * eptr = prop_chunk + dff_chunk_header . ckDataSize ; <S2SV_StartBug> uint16_t numChannels , chansSpecified , chanMask = 0 ; <S2SV_EndBug> uint32_t sampleRate ; while ( eptr - cptr >= sizeof ( dff_chunk_header ) ) { memcpy ( & dff_chunk_header , cptr , sizeof ( dff_chunk_header ) ) ; cptr += sizeof ( dff_chunk_header ) ; WavpackBigEndianToNative ( & dff_chunk_header , DFFChunkHeaderFormat ) ; if ( dff_chunk_header . ckDataSize > 0 && dff_chunk_header . ckDataSize <= eptr - cptr ) { if ( ! strncmp ( dff_chunk_header . ckID , "FS<S2SV_blank><S2SV_blank>" , 4 ) && dff_chunk_header . ckDataSize == 4 ) { memcpy ( & sampleRate , cptr , sizeof ( sampleRate ) ) ; WavpackBigEndianToNative ( & sampleRate , "L" ) ; cptr += dff_chunk_header . ckDataSize ; if ( debug_logging_mode ) error_line ( "got<S2SV_blank>sample<S2SV_blank>rate<S2SV_blank>of<S2SV_blank>%u<S2SV_blank>Hz" , sampleRate ) ; } else if ( ! strncmp ( dff_chunk_header . ckID , "CHNL" , 4 ) && dff_chunk_header . ckDataSize >= 2 ) { memcpy ( & numChannels , cptr , sizeof ( numChannels ) ) ; WavpackBigEndianToNative ( & numChannels , "S" ) ; cptr += sizeof ( numChannels ) ; chansSpecified = ( int ) ( dff_chunk_header . ckDataSize - sizeof ( numChannels ) ) / 4 ; <S2SV_StartBug> if ( numChannels < chansSpecified || numChannels < 1 ) { <S2SV_EndBug> error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!" , infilename ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } while ( chansSpecified -- ) { if ( ! strncmp ( cptr , "SLFT" , 4 ) || ! strncmp ( cptr , "MLFT" , 4 ) ) chanMask |= 0x1 ; else if ( ! strncmp ( cptr , "SRGT" , 4 ) || ! strncmp ( cptr , "MRGT" , 4 ) ) chanMask |= 0x2 ; else if ( ! strncmp ( cptr , "LS<S2SV_blank><S2SV_blank>" , 4 ) ) chanMask |= 0x10 ; else if ( ! strncmp ( cptr , "RS<S2SV_blank><S2SV_blank>" , 4 ) ) chanMask |= 0x20 ; else if ( ! strncmp ( cptr , "C<S2SV_blank><S2SV_blank><S2SV_blank>" , 4 ) ) chanMask |= 0x4 ; else if ( ! strncmp ( cptr , "LFE<S2SV_blank>" , 4 ) ) chanMask |= 0x8 ; else if ( debug_logging_mode ) error_line ( "undefined<S2SV_blank>channel<S2SV_blank>ID<S2SV_blank>%c%c%c%c" , cptr [ 0 ] , cptr [ 1 ] , cptr [ 2 ] , cptr [ 3 ] ) ; cptr += 4 ; } if ( debug_logging_mode ) error_line ( "%d<S2SV_blank>channels,<S2SV_blank>mask<S2SV_blank>=<S2SV_blank>0x%08x" , numChannels , chanMask ) ; } else if ( ! strncmp ( dff_chunk_header . ckID , "CMPR" , 4 ) && dff_chunk_header . ckDataSize >= 4 ) { if ( strncmp ( cptr , "DSD<S2SV_blank>" , 4 ) ) { error_line ( "DSDIFF<S2SV_blank>files<S2SV_blank>must<S2SV_blank>be<S2SV_blank>uncompressed,<S2SV_blank>not<S2SV_blank>\\"%c%c%c%c\\"!" , cptr [ 0 ] , cptr [ 1 ] , cptr [ 2 ] , cptr [ 3 ] ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } cptr += dff_chunk_header . ckDataSize ; } else { if ( debug_logging_mode ) error_line ( "got<S2SV_blank>PROP/SND<S2SV_blank>chunk<S2SV_blank>type<S2SV_blank>\\"%c%c%c%c\\"<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes" , dff_chunk_header . ckID [ 0 ] , dff_chunk_header . ckID [ 1 ] , dff_chunk_header . ckID [ 2 ] , dff_chunk_header . ckID [ 3 ] , dff_chunk_header . ckDataSize ) ; cptr += dff_chunk_header . ckDataSize ; } } else { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!" , infilename ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } } if ( chanMask && ( config -> channel_mask || ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) ) { error_line ( "this<S2SV_blank>DSDIFF<S2SV_blank>file<S2SV_blank>already<S2SV_blank>has<S2SV_blank>channel<S2SV_blank>order<S2SV_blank>information!" ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } else if ( chanMask ) config -> channel_mask = chanMask ; config -> bits_per_sample = 8 ; config -> bytes_per_sample = 1 ; config -> num_channels = numChannels ; config -> sample_rate = sampleRate / 8 ; config -> qmode |= QMODE_DSD_MSB_FIRST ; } else if ( debug_logging_mode ) error_line ( "got<S2SV_blank>unknown<S2SV_blank>PROP<S2SV_blank>chunk<S2SV_blank>type<S2SV_blank>\\"%c%c%c%c\\"<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes" , prop_chunk [ 0 ] , prop_chunk [ 1 ] , prop_chunk [ 2 ] , prop_chunk [ 3 ] , dff_chunk_header . ckDataSize ) ; free ( prop_chunk ) ; } else if ( ! strncmp ( dff_chunk_header . ckID , "DSD<S2SV_blank>" , 4 ) ) { <S2SV_StartBug> total_samples = dff_chunk_header . ckDataSize / config -> num_channels ; <S2SV_EndBug> break ; } else { int bytes_to_copy = ( int ) ( ( ( dff_chunk_header . ckDataSize ) + 1 ) & ~ ( int64_t ) 1 ) ; char * buff ; if ( bytes_to_copy < 0 || bytes_to_copy > 4194304 ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } buff = malloc ( bytes_to_copy ) ; if ( debug_logging_mode ) error_line ( "extra<S2SV_blank>unknown<S2SV_blank>chunk<S2SV_blank>\\"%c%c%c%c\\"<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes" , dff_chunk_header . ckID [ 0 ] , dff_chunk_header . ckID [ 1 ] , dff_chunk_header . ckID [ 2 ] , dff_chunk_header . ckID [ 3 ] , dff_chunk_header . ckDataSize ) ; if ( ! DoReadFile ( infile , buff , bytes_to_copy , & bcount ) || bcount != bytes_to_copy || ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , buff , bytes_to_copy ) ) ) { error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; free ( buff ) ; return WAVPACK_SOFT_ERROR ; } free ( buff ) ; } } if ( debug_logging_mode ) error_line ( "setting<S2SV_blank>configuration<S2SV_blank>with<S2SV_blank>%lld<S2SV_blank>samples" , total_samples ) ; if ( ! WavpackSetConfiguration64 ( wpc , config , total_samples , NULL ) ) { error_line ( "%s:<S2SV_blank>%s" , infilename , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } return WAVPACK_NO_ERROR ; }
CWE-824 int ParseDsdiffHeaderConfig ( FILE * infile , char * infilename , char * fourcc , WavpackContext * wpc , WavpackConfig * config ) { int64_t infilesize , total_samples ; DFFFileHeader dff_file_header ; DFFChunkHeader dff_chunk_header ; uint32_t bcount ; infilesize = DoGetFileSize ( infile ) ; memcpy ( & dff_file_header , fourcc , 4 ) ; if ( ( ! DoReadFile ( infile , ( ( char * ) & dff_file_header ) + 4 , sizeof ( DFFFileHeader ) - 4 , & bcount ) || bcount != sizeof ( DFFFileHeader ) - 4 ) || strncmp ( dff_file_header . formType , "DSD<S2SV_blank>" , 4 ) ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & dff_file_header , sizeof ( DFFFileHeader ) ) ) { error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } # if 1 WavpackBigEndianToNative ( & dff_file_header , DFFFileHeaderFormat ) ; if ( infilesize && ! ( config -> qmode & QMODE_IGNORE_LENGTH ) && dff_file_header . ckDataSize && dff_file_header . ckDataSize + 1 && dff_file_header . ckDataSize + 12 != infilesize ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file<S2SV_blank>(by<S2SV_blank>total<S2SV_blank>size)!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( debug_logging_mode ) error_line ( "file<S2SV_blank>header<S2SV_blank>indicated<S2SV_blank>length<S2SV_blank>=<S2SV_blank>%lld" , dff_file_header . ckDataSize ) ; # endif while ( 1 ) { if ( ! DoReadFile ( infile , & dff_chunk_header , sizeof ( DFFChunkHeader ) , & bcount ) || bcount != sizeof ( DFFChunkHeader ) ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & dff_chunk_header , sizeof ( DFFChunkHeader ) ) ) { error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackBigEndianToNative ( & dff_chunk_header , DFFChunkHeaderFormat ) ; if ( debug_logging_mode ) error_line ( "chunk<S2SV_blank>header<S2SV_blank>indicated<S2SV_blank>length<S2SV_blank>=<S2SV_blank>%lld" , dff_chunk_header . ckDataSize ) ; if ( ! strncmp ( dff_chunk_header . ckID , "FVER" , 4 ) ) { uint32_t version ; if ( dff_chunk_header . ckDataSize != sizeof ( version ) || ! DoReadFile ( infile , & version , sizeof ( version ) , & bcount ) || bcount != sizeof ( version ) ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & version , sizeof ( version ) ) ) { error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackBigEndianToNative ( & version , "L" ) ; if ( debug_logging_mode ) error_line ( "dsdiff<S2SV_blank>file<S2SV_blank>version<S2SV_blank>=<S2SV_blank>0x%08x" , version ) ; } else if ( ! strncmp ( dff_chunk_header . ckID , "PROP" , 4 ) ) { char * prop_chunk ; if ( dff_chunk_header . ckDataSize < 4 || dff_chunk_header . ckDataSize > 1024 ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( debug_logging_mode ) error_line ( "got<S2SV_blank>PROP<S2SV_blank>chunk<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>total" , ( int ) dff_chunk_header . ckDataSize ) ; prop_chunk = malloc ( ( size_t ) dff_chunk_header . ckDataSize ) ; if ( ! DoReadFile ( infile , prop_chunk , ( uint32_t ) dff_chunk_header . ckDataSize , & bcount ) || bcount != dff_chunk_header . ckDataSize ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!" , infilename ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , prop_chunk , ( uint32_t ) dff_chunk_header . ckDataSize ) ) { error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } if ( ! strncmp ( prop_chunk , "SND<S2SV_blank>" , 4 ) ) { char * cptr = prop_chunk + 4 , * eptr = prop_chunk + dff_chunk_header . ckDataSize ; uint16_t numChannels = 0 , chansSpecified , chanMask = 0 ; <S2SV_StartBug> uint32_t sampleRate ; <S2SV_EndBug> while ( eptr - cptr >= sizeof ( dff_chunk_header ) ) { memcpy ( & dff_chunk_header , cptr , sizeof ( dff_chunk_header ) ) ; cptr += sizeof ( dff_chunk_header ) ; WavpackBigEndianToNative ( & dff_chunk_header , DFFChunkHeaderFormat ) ; if ( dff_chunk_header . ckDataSize > 0 && dff_chunk_header . ckDataSize <= eptr - cptr ) { if ( ! strncmp ( dff_chunk_header . ckID , "FS<S2SV_blank><S2SV_blank>" , 4 ) && dff_chunk_header . ckDataSize == 4 ) { memcpy ( & sampleRate , cptr , sizeof ( sampleRate ) ) ; WavpackBigEndianToNative ( & sampleRate , "L" ) ; cptr += dff_chunk_header . ckDataSize ; if ( debug_logging_mode ) error_line ( "got<S2SV_blank>sample<S2SV_blank>rate<S2SV_blank>of<S2SV_blank>%u<S2SV_blank>Hz" , sampleRate ) ; } else if ( ! strncmp ( dff_chunk_header . ckID , "CHNL" , 4 ) && dff_chunk_header . ckDataSize >= 2 ) { memcpy ( & numChannels , cptr , sizeof ( numChannels ) ) ; WavpackBigEndianToNative ( & numChannels , "S" ) ; cptr += sizeof ( numChannels ) ; chansSpecified = ( int ) ( dff_chunk_header . ckDataSize - sizeof ( numChannels ) ) / 4 ; if ( numChannels < chansSpecified || numChannels < 1 || numChannels > 256 ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!" , infilename ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } while ( chansSpecified -- ) { if ( ! strncmp ( cptr , "SLFT" , 4 ) || ! strncmp ( cptr , "MLFT" , 4 ) ) chanMask |= 0x1 ; else if ( ! strncmp ( cptr , "SRGT" , 4 ) || ! strncmp ( cptr , "MRGT" , 4 ) ) chanMask |= 0x2 ; else if ( ! strncmp ( cptr , "LS<S2SV_blank><S2SV_blank>" , 4 ) ) chanMask |= 0x10 ; else if ( ! strncmp ( cptr , "RS<S2SV_blank><S2SV_blank>" , 4 ) ) chanMask |= 0x20 ; else if ( ! strncmp ( cptr , "C<S2SV_blank><S2SV_blank><S2SV_blank>" , 4 ) ) chanMask |= 0x4 ; else if ( ! strncmp ( cptr , "LFE<S2SV_blank>" , 4 ) ) chanMask |= 0x8 ; else if ( debug_logging_mode ) error_line ( "undefined<S2SV_blank>channel<S2SV_blank>ID<S2SV_blank>%c%c%c%c" , cptr [ 0 ] , cptr [ 1 ] , cptr [ 2 ] , cptr [ 3 ] ) ; cptr += 4 ; } if ( debug_logging_mode ) error_line ( "%d<S2SV_blank>channels,<S2SV_blank>mask<S2SV_blank>=<S2SV_blank>0x%08x" , numChannels , chanMask ) ; } else if ( ! strncmp ( dff_chunk_header . ckID , "CMPR" , 4 ) && dff_chunk_header . ckDataSize >= 4 ) { if ( strncmp ( cptr , "DSD<S2SV_blank>" , 4 ) ) { error_line ( "DSDIFF<S2SV_blank>files<S2SV_blank>must<S2SV_blank>be<S2SV_blank>uncompressed,<S2SV_blank>not<S2SV_blank>\\"%c%c%c%c\\"!" , cptr [ 0 ] , cptr [ 1 ] , cptr [ 2 ] , cptr [ 3 ] ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } cptr += dff_chunk_header . ckDataSize ; } else { if ( debug_logging_mode ) error_line ( "got<S2SV_blank>PROP/SND<S2SV_blank>chunk<S2SV_blank>type<S2SV_blank>\\"%c%c%c%c\\"<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes" , dff_chunk_header . ckID [ 0 ] , dff_chunk_header . ckID [ 1 ] , dff_chunk_header . ckID [ 2 ] , dff_chunk_header . ckID [ 3 ] , dff_chunk_header . ckDataSize ) ; cptr += dff_chunk_header . ckDataSize ; } } else { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!" , infilename ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } } if ( chanMask && ( config -> channel_mask || ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) ) { error_line ( "this<S2SV_blank>DSDIFF<S2SV_blank>file<S2SV_blank>already<S2SV_blank>has<S2SV_blank>channel<S2SV_blank>order<S2SV_blank>information!" ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } else if ( chanMask ) config -> channel_mask = chanMask ; config -> bits_per_sample = 8 ; config -> bytes_per_sample = 1 ; config -> num_channels = numChannels ; config -> sample_rate = sampleRate / 8 ; config -> qmode |= QMODE_DSD_MSB_FIRST ; } else if ( debug_logging_mode ) error_line ( "got<S2SV_blank>unknown<S2SV_blank>PROP<S2SV_blank>chunk<S2SV_blank>type<S2SV_blank>\\"%c%c%c%c\\"<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes" , prop_chunk [ 0 ] , prop_chunk [ 1 ] , prop_chunk [ 2 ] , prop_chunk [ 3 ] , dff_chunk_header . ckDataSize ) ; free ( prop_chunk ) ; } else if ( ! strncmp ( dff_chunk_header . ckID , "DSD<S2SV_blank>" , 4 ) ) { <S2SV_StartBug> if ( ! config -> num_channels ) { <S2SV_EndBug> error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } total_samples = dff_chunk_header . ckDataSize / config -> num_channels ; break ; } else { int bytes_to_copy = ( int ) ( ( ( dff_chunk_header . ckDataSize ) + 1 ) & ~ ( int64_t ) 1 ) ; char * buff ; if ( bytes_to_copy < 0 || bytes_to_copy > 4194304 ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } buff = malloc ( bytes_to_copy ) ; if ( debug_logging_mode ) error_line ( "extra<S2SV_blank>unknown<S2SV_blank>chunk<S2SV_blank>\\"%c%c%c%c\\"<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes" , dff_chunk_header . ckID [ 0 ] , dff_chunk_header . ckID [ 1 ] , dff_chunk_header . ckID [ 2 ] , dff_chunk_header . ckID [ 3 ] , dff_chunk_header . ckDataSize ) ; if ( ! DoReadFile ( infile , buff , bytes_to_copy , & bcount ) || bcount != bytes_to_copy || ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , buff , bytes_to_copy ) ) ) { error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; free ( buff ) ; return WAVPACK_SOFT_ERROR ; } free ( buff ) ; } } if ( debug_logging_mode ) error_line ( "setting<S2SV_blank>configuration<S2SV_blank>with<S2SV_blank>%lld<S2SV_blank>samples" , total_samples ) ; if ( ! WavpackSetConfiguration64 ( wpc , config , total_samples , NULL ) ) { error_line ( "%s:<S2SV_blank>%s" , infilename , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } return WAVPACK_NO_ERROR ; }
CWE-665 int ParseCaffHeaderConfig ( FILE * infile , char * infilename , char * fourcc , WavpackContext * wpc , WavpackConfig * config ) { <S2SV_StartBug> uint32_t chan_chunk = 0 , channel_layout = 0 , bcount ; <S2SV_EndBug> unsigned char * channel_identities = NULL ; unsigned char * channel_reorder = NULL ; int64_t total_samples = 0 , infilesize ; CAFFileHeader caf_file_header ; CAFChunkHeader caf_chunk_header ; CAFAudioFormat caf_audio_format ; int i ; infilesize = DoGetFileSize ( infile ) ; memcpy ( & caf_file_header , fourcc , 4 ) ; if ( ( ! DoReadFile ( infile , ( ( char * ) & caf_file_header ) + 4 , sizeof ( CAFFileHeader ) - 4 , & bcount ) || bcount != sizeof ( CAFFileHeader ) - 4 ) ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.CAF<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & caf_file_header , sizeof ( CAFFileHeader ) ) ) { error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackBigEndianToNative ( & caf_file_header , CAFFileHeaderFormat ) ; if ( caf_file_header . mFileVersion != 1 ) { error_line ( "%s:<S2SV_blank>can\'t<S2SV_blank>handle<S2SV_blank>version<S2SV_blank>%d<S2SV_blank>.CAF<S2SV_blank>files!" , infilename , caf_file_header . mFileVersion ) ; return WAVPACK_SOFT_ERROR ; } while ( 1 ) { if ( ! DoReadFile ( infile , & caf_chunk_header , sizeof ( CAFChunkHeader ) , & bcount ) || bcount != sizeof ( CAFChunkHeader ) ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.CAF<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & caf_chunk_header , sizeof ( CAFChunkHeader ) ) ) { error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackBigEndianToNative ( & caf_chunk_header , CAFChunkHeaderFormat ) ; if ( ! strncmp ( caf_chunk_header . mChunkType , "desc" , 4 ) ) { int supported = TRUE ; if ( caf_chunk_header . mChunkSize != sizeof ( CAFAudioFormat ) || ! DoReadFile ( infile , & caf_audio_format , ( uint32_t ) caf_chunk_header . mChunkSize , & bcount ) || bcount != caf_chunk_header . mChunkSize ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.CAF<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & caf_audio_format , ( uint32_t ) caf_chunk_header . mChunkSize ) ) { error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } <S2SV_StartBug> WavpackBigEndianToNative ( & caf_audio_format , CAFAudioFormatFormat ) ; <S2SV_EndBug> if ( debug_logging_mode ) { char formatstr [ 5 ] ; memcpy ( formatstr , caf_audio_format . mFormatID , 4 ) ; formatstr [ 4 ] = 0 ; error_line ( "format<S2SV_blank>=<S2SV_blank>%s,<S2SV_blank>flags<S2SV_blank>=<S2SV_blank>%x,<S2SV_blank>sampling<S2SV_blank>rate<S2SV_blank>=<S2SV_blank>%g" , formatstr , caf_audio_format . mFormatFlags , caf_audio_format . mSampleRate ) ; error_line ( "packet<S2SV_blank>=<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>and<S2SV_blank>%d<S2SV_blank>frames" , caf_audio_format . mBytesPerPacket , caf_audio_format . mFramesPerPacket ) ; error_line ( "channels<S2SV_blank>per<S2SV_blank>frame<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>bits<S2SV_blank>per<S2SV_blank>channel<S2SV_blank>=<S2SV_blank>%d" , caf_audio_format . mChannelsPerFrame , caf_audio_format . mBitsPerChannel ) ; } if ( strncmp ( caf_audio_format . mFormatID , "lpcm" , 4 ) || ( caf_audio_format . mFormatFlags & ~ 3 ) ) supported = FALSE ; else if ( caf_audio_format . mSampleRate < 1.0 || caf_audio_format . mSampleRate > 16777215.0 || caf_audio_format . mSampleRate != floor ( caf_audio_format . mSampleRate ) ) supported = FALSE ; else if ( ! caf_audio_format . mChannelsPerFrame || caf_audio_format . mChannelsPerFrame > 256 ) supported = FALSE ; else if ( caf_audio_format . mBitsPerChannel < 1 || caf_audio_format . mBitsPerChannel > 32 || ( ( caf_audio_format . mFormatFlags & CAF_FORMAT_FLOAT ) && caf_audio_format . mBitsPerChannel != 32 ) ) supported = FALSE ; else if ( caf_audio_format . mFramesPerPacket != 1 || caf_audio_format . mBytesPerPacket / caf_audio_format . mChannelsPerFrame < ( caf_audio_format . mBitsPerChannel + 7 ) / 8 || caf_audio_format . mBytesPerPacket / caf_audio_format . mChannelsPerFrame > 4 || caf_audio_format . mBytesPerPacket % caf_audio_format . mChannelsPerFrame ) supported = FALSE ; if ( ! supported ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>an<S2SV_blank>unsupported<S2SV_blank>.CAF<S2SV_blank>format!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } config -> bytes_per_sample = caf_audio_format . mBytesPerPacket / caf_audio_format . mChannelsPerFrame ; config -> float_norm_exp = ( caf_audio_format . mFormatFlags & CAF_FORMAT_FLOAT ) ? 127 : 0 ; config -> bits_per_sample = caf_audio_format . mBitsPerChannel ; config -> num_channels = caf_audio_format . mChannelsPerFrame ; config -> sample_rate = ( int ) caf_audio_format . mSampleRate ; if ( ! ( caf_audio_format . mFormatFlags & CAF_FORMAT_LITTLE_ENDIAN ) && config -> bytes_per_sample > 1 ) config -> qmode |= QMODE_BIG_ENDIAN ; if ( config -> bytes_per_sample == 1 ) config -> qmode |= QMODE_SIGNED_BYTES ; if ( debug_logging_mode ) { if ( config -> float_norm_exp == 127 ) error_line ( "data<S2SV_blank>format:<S2SV_blank>32-bit<S2SV_blank>%s-endian<S2SV_blank>floating<S2SV_blank>point" , ( config -> qmode & QMODE_BIG_ENDIAN ) ? "big" : "little" ) ; else error_line ( "data<S2SV_blank>format:<S2SV_blank>%d-bit<S2SV_blank>%s-endian<S2SV_blank>integers<S2SV_blank>stored<S2SV_blank>in<S2SV_blank>%d<S2SV_blank>byte(s)" , config -> bits_per_sample , ( config -> qmode & QMODE_BIG_ENDIAN ) ? "big" : "little" , config -> bytes_per_sample ) ; } } else if ( ! strncmp ( caf_chunk_header . mChunkType , "chan" , 4 ) ) { CAFChannelLayout * caf_channel_layout ; if ( caf_chunk_header . mChunkSize < 0 || caf_chunk_header . mChunkSize > 1024 || caf_chunk_header . mChunkSize < sizeof ( CAFChannelLayout ) ) { error_line ( "this<S2SV_blank>.CAF<S2SV_blank>file<S2SV_blank>has<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>\'chan\'<S2SV_blank>chunk!" ) ; return WAVPACK_SOFT_ERROR ; } if ( debug_logging_mode ) error_line ( "\'chan\'<S2SV_blank>chunk<S2SV_blank>is<S2SV_blank>%d<S2SV_blank>bytes" , ( int ) caf_chunk_header . mChunkSize ) ; caf_channel_layout = malloc ( ( size_t ) caf_chunk_header . mChunkSize ) ; if ( ! DoReadFile ( infile , caf_channel_layout , ( uint32_t ) caf_chunk_header . mChunkSize , & bcount ) || bcount != caf_chunk_header . mChunkSize ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.CAF<S2SV_blank>file!" , infilename ) ; free ( caf_channel_layout ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , caf_channel_layout , ( uint32_t ) caf_chunk_header . mChunkSize ) ) { error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; free ( caf_channel_layout ) ; return WAVPACK_SOFT_ERROR ; } WavpackBigEndianToNative ( caf_channel_layout , CAFChannelLayoutFormat ) ; chan_chunk = 1 ; if ( config -> channel_mask || ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) { error_line ( "this<S2SV_blank>CAF<S2SV_blank>file<S2SV_blank>already<S2SV_blank>has<S2SV_blank>channel<S2SV_blank>order<S2SV_blank>information!" ) ; free ( caf_channel_layout ) ; return WAVPACK_SOFT_ERROR ; } switch ( caf_channel_layout -> mChannelLayoutTag ) { case kCAFChannelLayoutTag_UseChannelDescriptions : { CAFChannelDescription * descriptions = ( CAFChannelDescription * ) ( caf_channel_layout + 1 ) ; int num_descriptions = caf_channel_layout -> mNumberChannelDescriptions ; int label , cindex = 0 , idents = 0 ; if ( caf_chunk_header . mChunkSize != sizeof ( CAFChannelLayout ) + sizeof ( CAFChannelDescription ) * num_descriptions || num_descriptions != config -> num_channels ) { error_line ( "channel<S2SV_blank>descriptions<S2SV_blank>in<S2SV_blank>\'chan\'<S2SV_blank>chunk<S2SV_blank>are<S2SV_blank>the<S2SV_blank>wrong<S2SV_blank>size!" ) ; free ( caf_channel_layout ) ; return WAVPACK_SOFT_ERROR ; } if ( num_descriptions >= 256 ) { error_line ( "%d<S2SV_blank>channel<S2SV_blank>descriptions<S2SV_blank>is<S2SV_blank>more<S2SV_blank>than<S2SV_blank>we<S2SV_blank>can<S2SV_blank>handle...ignoring!" ) ; break ; } channel_reorder = malloc ( num_descriptions ) ; memset ( channel_reorder , - 1 , num_descriptions ) ; channel_identities = malloc ( num_descriptions + 1 ) ; for ( i = 0 ; i < num_descriptions ; ++ i ) { WavpackBigEndianToNative ( descriptions + i , CAFChannelDescriptionFormat ) ; if ( debug_logging_mode ) error_line ( "chan<S2SV_blank>%d<S2SV_blank>--><S2SV_blank>%d" , i + 1 , descriptions [ i ] . mChannelLabel ) ; } for ( label = 1 ; label <= 18 ; ++ label ) for ( i = 0 ; i < num_descriptions ; ++ i ) if ( descriptions [ i ] . mChannelLabel == label ) { config -> channel_mask |= 1 << ( label - 1 ) ; channel_reorder [ i ] = cindex ++ ; break ; } for ( i = 0 ; i < num_descriptions ; ++ i ) if ( channel_reorder [ i ] == ( unsigned char ) - 1 ) { uint32_t clabel = descriptions [ i ] . mChannelLabel ; if ( clabel == 0 || clabel == 0xffffffff || clabel == 100 ) channel_identities [ idents ++ ] = 0xff ; else if ( ( clabel >= 33 && clabel <= 44 ) || ( clabel >= 200 && clabel <= 207 ) || ( clabel >= 301 && clabel <= 305 ) ) channel_identities [ idents ++ ] = clabel >= 301 ? clabel - 80 : clabel ; else { error_line ( "warning:<S2SV_blank>unknown<S2SV_blank>channel<S2SV_blank>descriptions<S2SV_blank>label:<S2SV_blank>%d" , clabel ) ; channel_identities [ idents ++ ] = 0xff ; } channel_reorder [ i ] = cindex ++ ; } for ( i = 0 ; i < num_descriptions ; ++ i ) if ( channel_reorder [ i ] != i ) break ; if ( i == num_descriptions ) { free ( channel_reorder ) ; channel_reorder = NULL ; } else { config -> qmode |= QMODE_REORDERED_CHANS ; channel_layout = num_descriptions ; } if ( ! idents ) { free ( channel_identities ) ; channel_identities = NULL ; } else channel_identities [ idents ] = 0 ; if ( debug_logging_mode ) { error_line ( "layout_tag<S2SV_blank>=<S2SV_blank>0x%08x,<S2SV_blank>so<S2SV_blank>generated<S2SV_blank>bitmap<S2SV_blank>of<S2SV_blank>0x%08x<S2SV_blank>from<S2SV_blank>%d<S2SV_blank>descriptions,<S2SV_blank>%d<S2SV_blank>non-MS" , caf_channel_layout -> mChannelLayoutTag , config -> channel_mask , caf_channel_layout -> mNumberChannelDescriptions , idents ) ; if ( channel_reorder && num_descriptions <= 8 ) { char reorder_string [ ] = "12345678" ; for ( i = 0 ; i < num_descriptions ; ++ i ) reorder_string [ i ] = channel_reorder [ i ] + '1' ; reorder_string [ i ] = 0 ; error_line ( "reordering<S2SV_blank>string<S2SV_blank>=<S2SV_blank>\\"%s\\"\\n" , reorder_string ) ; } } } break ; case kCAFChannelLayoutTag_UseChannelBitmap : config -> channel_mask = caf_channel_layout -> mChannelBitmap ; if ( debug_logging_mode ) error_line ( "layout_tag<S2SV_blank>=<S2SV_blank>0x%08x,<S2SV_blank>so<S2SV_blank>using<S2SV_blank>supplied<S2SV_blank>bitmap<S2SV_blank>of<S2SV_blank>0x%08x" , caf_channel_layout -> mChannelLayoutTag , caf_channel_layout -> mChannelBitmap ) ; break ; default : for ( i = 0 ; i < NUM_LAYOUTS ; ++ i ) if ( caf_channel_layout -> mChannelLayoutTag == layouts [ i ] . mChannelLayoutTag ) { config -> channel_mask = layouts [ i ] . mChannelBitmap ; channel_layout = layouts [ i ] . mChannelLayoutTag ; if ( layouts [ i ] . mChannelReorder ) { channel_reorder = ( unsigned char * ) strdup ( layouts [ i ] . mChannelReorder ) ; config -> qmode |= QMODE_REORDERED_CHANS ; } if ( layouts [ i ] . mChannelIdentities ) channel_identities = ( unsigned char * ) strdup ( layouts [ i ] . mChannelIdentities ) ; if ( debug_logging_mode ) error_line ( "layout_tag<S2SV_blank>0x%08x<S2SV_blank>found<S2SV_blank>in<S2SV_blank>table,<S2SV_blank>bitmap<S2SV_blank>=<S2SV_blank>0x%08x,<S2SV_blank>reorder<S2SV_blank>=<S2SV_blank>%s,<S2SV_blank>identities<S2SV_blank>=<S2SV_blank>%s" , channel_layout , config -> channel_mask , channel_reorder ? "yes" : "no" , channel_identities ? "yes" : "no" ) ; break ; } if ( i == NUM_LAYOUTS && debug_logging_mode ) error_line ( "layout_tag<S2SV_blank>0x%08x<S2SV_blank>not<S2SV_blank>found<S2SV_blank>in<S2SV_blank>table...all<S2SV_blank>channels<S2SV_blank>unassigned" , caf_channel_layout -> mChannelLayoutTag ) ; break ; } free ( caf_channel_layout ) ; } else if ( ! strncmp ( caf_chunk_header . mChunkType , "data" , 4 ) ) { uint32_t mEditCount ; <S2SV_StartBug> if ( ! DoReadFile ( infile , & mEditCount , sizeof ( mEditCount ) , & bcount ) || <S2SV_EndBug> bcount != sizeof ( mEditCount ) ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.CAF<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & mEditCount , sizeof ( mEditCount ) ) ) { error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } if ( ( config -> qmode & QMODE_IGNORE_LENGTH ) || caf_chunk_header . mChunkSize == - 1 ) { config -> qmode |= QMODE_IGNORE_LENGTH ; if ( infilesize && DoGetFilePosition ( infile ) != - 1 ) total_samples = ( infilesize - DoGetFilePosition ( infile ) ) / caf_audio_format . mBytesPerPacket ; else total_samples = - 1 ; } else { if ( infilesize && infilesize - caf_chunk_header . mChunkSize > 16777216 ) { error_line ( ".CAF<S2SV_blank>file<S2SV_blank>%s<S2SV_blank>has<S2SV_blank>over<S2SV_blank>16<S2SV_blank>MB<S2SV_blank>of<S2SV_blank>extra<S2SV_blank>CAFF<S2SV_blank>data,<S2SV_blank>probably<S2SV_blank>is<S2SV_blank>corrupt!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( ( caf_chunk_header . mChunkSize - 4 ) % caf_audio_format . mBytesPerPacket ) { error_line ( ".CAF<S2SV_blank>file<S2SV_blank>%s<S2SV_blank>has<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>data<S2SV_blank>chunk<S2SV_blank>size,<S2SV_blank>probably<S2SV_blank>is<S2SV_blank>corrupt!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } total_samples = ( caf_chunk_header . mChunkSize - 4 ) / caf_audio_format . mBytesPerPacket ; if ( ! total_samples ) { error_line ( "this<S2SV_blank>.CAF<S2SV_blank>file<S2SV_blank>has<S2SV_blank>no<S2SV_blank>audio<S2SV_blank>samples,<S2SV_blank>probably<S2SV_blank>is<S2SV_blank>corrupt!" ) ; return WAVPACK_SOFT_ERROR ; } if ( total_samples > MAX_WAVPACK_SAMPLES ) { error_line ( "%s<S2SV_blank>has<S2SV_blank>too<S2SV_blank>many<S2SV_blank>samples<S2SV_blank>for<S2SV_blank>WavPack!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } } break ; } else { uint32_t bytes_to_copy = ( uint32_t ) caf_chunk_header . mChunkSize ; char * buff ; if ( caf_chunk_header . mChunkSize < 0 || caf_chunk_header . mChunkSize > 1048576 ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.CAF<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } buff = malloc ( bytes_to_copy ) ; if ( debug_logging_mode ) error_line ( "extra<S2SV_blank>unknown<S2SV_blank>chunk<S2SV_blank>\\"%c%c%c%c\\"<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes" , caf_chunk_header . mChunkType [ 0 ] , caf_chunk_header . mChunkType [ 1 ] , caf_chunk_header . mChunkType [ 2 ] , caf_chunk_header . mChunkType [ 3 ] , caf_chunk_header . mChunkSize ) ; if ( ! DoReadFile ( infile , buff , bytes_to_copy , & bcount ) || bcount != bytes_to_copy || ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , buff , bytes_to_copy ) ) ) { error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; free ( buff ) ; return WAVPACK_SOFT_ERROR ; } free ( buff ) ; } } if ( ! chan_chunk && ! config -> channel_mask && config -> num_channels <= 2 && ! ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) config -> channel_mask = 0x5 - config -> num_channels ; if ( ! WavpackSetConfiguration64 ( wpc , config , total_samples , channel_identities ) ) { error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } if ( channel_identities ) free ( channel_identities ) ; if ( channel_layout || channel_reorder ) { if ( ! WavpackSetChannelLayout ( wpc , channel_layout , channel_reorder ) ) { error_line ( "problem<S2SV_blank>with<S2SV_blank>setting<S2SV_blank>channel<S2SV_blank>layout<S2SV_blank>(should<S2SV_blank>not<S2SV_blank>happen)" ) ; return WAVPACK_SOFT_ERROR ; } if ( channel_reorder ) free ( channel_reorder ) ; } return WAVPACK_NO_ERROR ; }
CWE-787 int main ( int argc , char * * argv ) { int i , n_valid , do_write , do_scrub ; char * c , * dname , * name ; DIR * dir ; FILE * fp ; pdf_t * pdf ; pdf_flag_t flags ; if ( argc < 2 ) usage ( ) ; do_write = do_scrub = flags = 0 ; name = NULL ; for ( i = 1 ; i < argc ; i ++ ) { if ( strncmp ( argv [ i ] , "-w" , 2 ) == 0 ) do_write = 1 ; else if ( strncmp ( argv [ i ] , "-i" , 2 ) == 0 ) flags |= PDF_FLAG_DISP_CREATOR ; else if ( strncmp ( argv [ i ] , "-q" , 2 ) == 0 ) flags |= PDF_FLAG_QUIET ; else if ( strncmp ( argv [ i ] , "-s" , 2 ) == 0 ) do_scrub = 1 ; else if ( argv [ i ] [ 0 ] != '-' ) name = argv [ i ] ; else if ( argv [ i ] [ 0 ] == '-' ) usage ( ) ; } if ( ! name ) usage ( ) ; if ( ! ( fp = fopen ( name , "r" ) ) ) { ERR ( "Could<S2SV_blank>not<S2SV_blank>open<S2SV_blank>file<S2SV_blank>\'%s\'\\n" , argv [ 1 ] ) ; return - 1 ; } else if ( ! pdf_is_pdf ( fp ) ) { ERR ( "\'%s\'<S2SV_blank>specified<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>PDF\\n" , name ) ; fclose ( fp ) ; return - 1 ; } if ( ! ( pdf = init_pdf ( fp , name ) ) ) { fclose ( fp ) ; return - 1 ; } for ( i = 0 , n_valid = 0 ; i < pdf -> n_xrefs ; i ++ ) if ( pdf -> xrefs [ i ] . version ) ++ n_valid ; if ( n_valid < 2 ) { if ( ! ( flags & ( PDF_FLAG_QUIET | PDF_FLAG_DISP_CREATOR ) ) ) printf ( "%s:<S2SV_blank>There<S2SV_blank>is<S2SV_blank>only<S2SV_blank>one<S2SV_blank>version<S2SV_blank>of<S2SV_blank>this<S2SV_blank>PDF\\n" , pdf -> name ) ; if ( do_write ) { fclose ( fp ) ; pdf_delete ( pdf ) ; return 0 ; } } dname = NULL ; if ( do_write ) { if ( ( c = strrchr ( name , '/' ) ) ) name = c + 1 ; if ( ( c = strrchr ( name , '.' ) ) ) * c = '\\0' ; <S2SV_StartBug> dname = malloc ( strlen ( name ) + 16 ) ; <S2SV_EndBug> sprintf ( dname , "%s-versions" , name ) ; if ( ! ( dir = opendir ( dname ) ) ) mkdir ( dname , S_IRWXU ) ; else { ERR ( "This<S2SV_blank>directory<S2SV_blank>already<S2SV_blank>exists,<S2SV_blank>PDF<S2SV_blank>version<S2SV_blank>extraction<S2SV_blank>will<S2SV_blank>" "not<S2SV_blank>occur.\\n" ) ; fclose ( fp ) ; closedir ( dir ) ; free ( dname ) ; pdf_delete ( pdf ) ; return - 1 ; } for ( i = 0 ; i < pdf -> n_xrefs ; i ++ ) if ( pdf -> xrefs [ i ] . version ) write_version ( fp , name , dname , & pdf -> xrefs [ i ] ) ; } pdf_summarize ( fp , pdf , dname , flags ) ; if ( do_scrub ) scrub_document ( fp , pdf ) ; if ( flags & PDF_FLAG_DISP_CREATOR ) display_creator ( fp , pdf ) ; fclose ( fp ) ; free ( dname ) ; pdf_delete ( pdf ) ; return 0 ; }
CWE-787 static void write_version ( FILE * fp , const char * fname , const char * dirname , xref_t * xref ) { long start ; char * c , * new_fname , data ; FILE * new_fp ; start = ftell ( fp ) ; if ( ( c = strstr ( fname , ".pdf" ) ) ) * c = '\\0' ; <S2SV_StartBug> new_fname = malloc ( strlen ( fname ) + strlen ( dirname ) + 16 ) ; <S2SV_EndBug> snprintf ( new_fname , strlen ( fname ) + strlen ( dirname ) + 16 , "%s/%s-version-%d.pdf" , dirname , fname , xref -> version ) ; if ( ! ( new_fp = fopen ( new_fname , "w" ) ) ) { ERR ( "Could<S2SV_blank>not<S2SV_blank>create<S2SV_blank>file<S2SV_blank>\'%s\'\\n" , new_fname ) ; fseek ( fp , start , SEEK_SET ) ; free ( new_fname ) ; return ; } fseek ( fp , 0 , SEEK_SET ) ; while ( fread ( & data , 1 , 1 , fp ) ) fwrite ( & data , 1 , 1 , new_fp ) ; fprintf ( new_fp , "\\r\\nstartxref\\r\\n%ld\\r\\n%%%%EOF" , xref -> start ) ; fclose ( new_fp ) ; free ( new_fname ) ; fseek ( fp , start , SEEK_SET ) ; }
CWE-787 static char * decode_text_string ( const char * str , size_t str_len ) { int idx , is_hex , is_utf16be , ascii_idx ; char * ascii , hex_buf [ 5 ] = { 0 } ; is_hex = is_utf16be = idx = ascii_idx = 0 ; if ( str [ 0 ] == '(' ) { <S2SV_StartBug> ascii = malloc ( strlen ( str ) + 1 ) ; <S2SV_EndBug> strncpy ( ascii , str , strlen ( str ) + 1 ) ; return ascii ; } else if ( str [ 0 ] == '<' ) { is_hex = 1 ; ++ idx ; } if ( is_hex && ( str_len > 5 ) && ( str [ idx ] == 'F' ) && ( str [ idx + 1 ] == 'E' ) && ( str [ idx + 2 ] == 'F' ) && ( str [ idx + 3 ] == 'F' ) ) { is_utf16be = 1 ; idx += 4 ; } else return NULL ; <S2SV_StartBug> ascii = malloc ( str_len ) ; <S2SV_EndBug> for ( ; idx < str_len ; ++ idx ) { hex_buf [ 0 ] = str [ idx ++ ] ; hex_buf [ 1 ] = str [ idx ++ ] ; hex_buf [ 2 ] = str [ idx ++ ] ; hex_buf [ 3 ] = str [ idx ] ; ascii [ ascii_idx ++ ] = strtol ( hex_buf , NULL , 16 ) ; } return ascii ; }
CWE-787 static char * get_header ( FILE * fp ) { <S2SV_StartBug> long start ; <S2SV_EndBug> <S2SV_StartBug> char * header ; <S2SV_EndBug> header = calloc ( 1 , 1024 ) ; <S2SV_StartBug> start = ftell ( fp ) ; <S2SV_EndBug> fseek ( fp , 0 , SEEK_SET ) ; SAFE_E ( fread ( header , 1 , 1023 , fp ) , 1023 , "Failed<S2SV_blank>to<S2SV_blank>load<S2SV_blank>PDF<S2SV_blank>header.\\n" ) ; fseek ( fp , start , SEEK_SET ) ; return header ; }
CWE-787 static char * get_object ( FILE * fp , int obj_id , const xref_t * xref , size_t * size , int * is_stream ) { static const int blk_sz = 256 ; int i , total_sz , read_sz , n_blks , search , stream ; size_t obj_sz ; char * c , * data ; long start ; const xref_entry_t * entry ; if ( size ) * size = 0 ; if ( is_stream ) * is_stream = 0 ; start = ftell ( fp ) ; entry = NULL ; for ( i = 0 ; i < xref -> n_entries ; i ++ ) if ( xref -> entries [ i ] . obj_id == obj_id ) { entry = & xref -> entries [ i ] ; break ; } if ( ! entry ) return NULL ; fseek ( fp , entry -> offset , SEEK_SET ) ; obj_sz = 0 ; total_sz = 0 ; n_blks = 1 ; <S2SV_StartBug> data = malloc ( blk_sz * n_blks ) ; <S2SV_EndBug> memset ( data , 0 , blk_sz * n_blks ) ; stream = 0 ; while ( ( read_sz = fread ( data + total_sz , 1 , blk_sz - 1 , fp ) ) && ! ferror ( fp ) ) { total_sz += read_sz ; * ( data + total_sz ) = '\\0' ; if ( total_sz + blk_sz >= ( blk_sz * n_blks ) ) data = realloc ( data , blk_sz * ( ++ n_blks ) ) ; search = total_sz - read_sz ; if ( search < 0 ) search = 0 ; if ( ( c = strstr ( data + search , "endobj" ) ) ) { * ( c + strlen ( "endobj" ) + 1 ) = '\\0' ; obj_sz = ( void * ) strstr ( data + search , "endobj" ) - ( void * ) data ; obj_sz += strlen ( "endobj" ) + 1 ; break ; } else if ( strstr ( data , "stream" ) ) stream = 1 ; } clearerr ( fp ) ; fseek ( fp , start , SEEK_SET ) ; if ( size ) * size = obj_sz ; if ( is_stream ) * is_stream = stream ; return data ; }
CWE-787 static void load_xref_from_plaintext ( FILE * fp , xref_t * xref ) { int i , buf_idx , obj_id , added_entries ; char c , buf [ 32 ] = { 0 } ; long start , pos ; start = ftell ( fp ) ; pos = xref -> end ; fseek ( fp , pos , SEEK_SET ) ; while ( ftell ( fp ) != 0 ) if ( SAFE_F ( fp , ( fgetc ( fp ) == '/' && fgetc ( fp ) == 'S' ) ) ) break ; else SAFE_E ( fseek ( fp , -- pos , SEEK_SET ) , 0 , "Failed<S2SV_blank>seek<S2SV_blank>to<S2SV_blank>xref<S2SV_blank>/Size.\\n" ) ; SAFE_E ( fread ( buf , 1 , 21 , fp ) , 21 , "Failed<S2SV_blank>to<S2SV_blank>load<S2SV_blank>entry<S2SV_blank>Size<S2SV_blank>string.\\n" ) ; xref -> n_entries = atoi ( buf + strlen ( "ize<S2SV_blank>" ) ) ; <S2SV_StartBug> xref -> entries = calloc ( 1 , xref -> n_entries * sizeof ( struct _xref_entry ) ) ; <S2SV_EndBug> obj_id = 0 ; fseek ( fp , xref -> start + strlen ( "xref" ) , SEEK_SET ) ; added_entries = 0 ; for ( i = 0 ; i < xref -> n_entries ; i ++ ) { c = fgetc ( fp ) ; while ( c == '\\n' || c == '\\r' ) c = fgetc ( fp ) ; buf_idx = 0 ; while ( c != '\\n' && c != '\\r' && ! feof ( fp ) && ! ferror ( fp ) && buf_idx < sizeof ( buf ) ) { buf [ buf_idx ++ ] = c ; c = fgetc ( fp ) ; } if ( buf_idx >= sizeof ( buf ) ) { ERR ( "Failed<S2SV_blank>to<S2SV_blank>locate<S2SV_blank>newline<S2SV_blank>character.<S2SV_blank>" "This<S2SV_blank>might<S2SV_blank>be<S2SV_blank>a<S2SV_blank>corrupt<S2SV_blank>PDF.\\n" ) ; exit ( EXIT_FAILURE ) ; } buf [ buf_idx ] = '\\0' ; if ( strchr ( buf , 't' ) ) break ; if ( strlen ( buf ) > 17 ) { xref -> entries [ i ] . obj_id = obj_id ++ ; xref -> entries [ i ] . offset = atol ( strtok ( buf , "<S2SV_blank>" ) ) ; xref -> entries [ i ] . gen_num = atoi ( strtok ( NULL , "<S2SV_blank>" ) ) ; xref -> entries [ i ] . f_or_n = buf [ 17 ] ; ++ added_entries ; } else { obj_id = atoi ( buf ) ; -- i ; } } xref -> n_entries = added_entries ; fseek ( fp , start , SEEK_SET ) ; }
CWE-787 static pdf_creator_t * new_creator ( int * n_elements ) { pdf_creator_t * daddy ; static const pdf_creator_t creator_template [ ] = { { "Title" , "" } , { "Author" , "" } , { "Subject" , "" } , { "Keywords" , "" } , { "Creator" , "" } , { "Producer" , "" } , { "CreationDate" , "" } , { "ModDate" , "" } , { "Trapped" , "" } , } ; <S2SV_StartBug> daddy = malloc ( sizeof ( creator_template ) ) ; <S2SV_EndBug> memcpy ( daddy , creator_template , sizeof ( creator_template ) ) ; if ( n_elements ) * n_elements = sizeof ( creator_template ) / sizeof ( creator_template [ 0 ] ) ; return daddy ; }
CWE-787 void pdf_load_pages_kids ( FILE * fp , pdf_t * pdf ) { int i , id , dummy ; char * buf , * c ; long start , sz ; start = ftell ( fp ) ; for ( i = 0 ; i < pdf -> n_xrefs ; i ++ ) { if ( pdf -> xrefs [ i ] . version && ( pdf -> xrefs [ i ] . end != 0 ) ) { fseek ( fp , pdf -> xrefs [ i ] . start , SEEK_SET ) ; while ( SAFE_F ( fp , ( fgetc ( fp ) != 't' ) ) ) ; sz = pdf -> xrefs [ i ] . end - ftell ( fp ) ; <S2SV_StartBug> buf = malloc ( sz + 1 ) ; <S2SV_EndBug> SAFE_E ( fread ( buf , 1 , sz , fp ) , sz , "Failed<S2SV_blank>to<S2SV_blank>load<S2SV_blank>/Root.\\n" ) ; buf [ sz ] = '\\0' ; if ( ! ( c = strstr ( buf , "/Root" ) ) ) { free ( buf ) ; continue ; } id = atoi ( c + strlen ( "/Root" ) + 1 ) ; free ( buf ) ; buf = get_object ( fp , id , & pdf -> xrefs [ i ] , NULL , & dummy ) ; if ( ! buf || ! ( c = strstr ( buf , "/Pages" ) ) ) { free ( buf ) ; continue ; } id = atoi ( c + strlen ( "/Pages" ) + 1 ) ; load_kids ( fp , id , & pdf -> xrefs [ i ] ) ; free ( buf ) ; } } fseek ( fp , start , SEEK_SET ) ; }
CWE-787 int pdf_load_xrefs ( FILE * fp , pdf_t * pdf ) { int i , ver , is_linear ; long pos , pos_count ; char x , * c , buf [ 256 ] ; c = NULL ; pdf -> n_xrefs = 0 ; fseek ( fp , 0 , SEEK_SET ) ; while ( get_next_eof ( fp ) >= 0 ) ++ pdf -> n_xrefs ; if ( ! pdf -> n_xrefs ) return 0 ; fseek ( fp , 0 , SEEK_SET ) ; <S2SV_StartBug> pdf -> xrefs = calloc ( 1 , sizeof ( xref_t ) * pdf -> n_xrefs ) ; <S2SV_EndBug> ver = 1 ; for ( i = 0 ; i < pdf -> n_xrefs ; i ++ ) { if ( ( pos = get_next_eof ( fp ) ) < 0 ) break ; pdf -> xrefs [ i ] . version = ver ++ ; pos_count = 0 ; while ( SAFE_F ( fp , ( ( x = fgetc ( fp ) ) != 'f' ) ) ) fseek ( fp , pos - ( ++ pos_count ) , SEEK_SET ) ; if ( pos_count >= sizeof ( buf ) ) { ERR ( "Failed<S2SV_blank>to<S2SV_blank>locate<S2SV_blank>the<S2SV_blank>startxref<S2SV_blank>token.<S2SV_blank>" "This<S2SV_blank>might<S2SV_blank>be<S2SV_blank>a<S2SV_blank>corrupt<S2SV_blank>PDF.\\n" ) ; return - 1 ; } memset ( buf , 0 , sizeof ( buf ) ) ; SAFE_E ( fread ( buf , 1 , pos_count , fp ) , pos_count , "Failed<S2SV_blank>to<S2SV_blank>read<S2SV_blank>startxref.\\n" ) ; c = buf ; while ( * c == '<S2SV_blank>' || * c == '\\n' || * c == '\\r' ) ++ c ; pdf -> xrefs [ i ] . start = atol ( c ) ; if ( pdf -> xrefs [ i ] . start == 0 ) get_xref_linear_skipped ( fp , & pdf -> xrefs [ i ] ) ; else { pos = ftell ( fp ) ; fseek ( fp , pdf -> xrefs [ i ] . start , SEEK_SET ) ; pdf -> xrefs [ i ] . end = get_next_eof ( fp ) ; fseek ( fp , pos , SEEK_SET ) ; } if ( ! is_valid_xref ( fp , pdf , & pdf -> xrefs [ i ] ) ) { is_linear = pdf -> xrefs [ i ] . is_linear ; memset ( & pdf -> xrefs [ i ] , 0 , sizeof ( xref_t ) ) ; pdf -> xrefs [ i ] . is_linear = is_linear ; rewind ( fp ) ; get_next_eof ( fp ) ; continue ; } load_xref_entries ( fp , & pdf -> xrefs [ i ] ) ; } if ( pdf -> xrefs [ 0 ] . is_linear ) resolve_linearized_pdf ( pdf ) ; load_creator ( fp , pdf ) ; return pdf -> n_xrefs ; }
CWE-787 pdf_t * pdf_new ( const char * name ) { const char * n ; pdf_t * pdf ; <S2SV_StartBug> pdf = calloc ( 1 , sizeof ( pdf_t ) ) ; <S2SV_EndBug> if ( name ) { if ( ( n = strrchr ( name , '/' ) ) ) ++ n ; else n = name ; <S2SV_StartBug> pdf -> name = malloc ( strlen ( n ) + 1 ) ; <S2SV_EndBug> strcpy ( pdf -> name , n ) ; } else { <S2SV_StartBug> pdf -> name = malloc ( strlen ( "Unknown" ) + 1 ) ; <S2SV_EndBug> strcpy ( pdf -> name , "Unknown" ) ; } return pdf ; }
CWE-787 void pdf_summarize ( FILE * fp , const pdf_t * pdf , const char * name , pdf_flag_t flags ) { int i , j , page , n_versions , n_entries ; FILE * dst , * out ; char * dst_name , * c ; dst = NULL ; dst_name = NULL ; if ( name ) { <S2SV_StartBug> dst_name = malloc ( strlen ( name ) * 2 + 16 ) ; <S2SV_EndBug> sprintf ( dst_name , "%s/%s" , name , name ) ; if ( ( c = strrchr ( dst_name , '.' ) ) && ( strncmp ( c , ".pdf" , 4 ) == 0 ) ) * c = '\\0' ; strcat ( dst_name , ".summary" ) ; if ( ! ( dst = fopen ( dst_name , "w" ) ) ) { ERR ( "Could<S2SV_blank>not<S2SV_blank>open<S2SV_blank>file<S2SV_blank>\'%s\'<S2SV_blank>for<S2SV_blank>writing\\n" , dst_name ) ; return ; } } out = ( dst ) ? dst : stdout ; n_versions = pdf -> n_xrefs ; if ( n_versions && pdf -> xrefs [ 0 ] . is_linear ) -- n_versions ; for ( i = 1 ; i < pdf -> n_xrefs ; ++ i ) if ( pdf -> xrefs [ i ] . end == 0 ) -- n_versions ; if ( ! pdf -> n_xrefs || ( ! n_versions && pdf -> xrefs [ 0 ] . is_linear ) ) n_versions = 1 ; n_entries = 0 ; for ( i = 0 ; ! ( const int ) pdf -> has_xref_streams && i < pdf -> n_xrefs ; i ++ ) { if ( flags & PDF_FLAG_QUIET ) continue ; for ( j = 0 ; j < pdf -> xrefs [ i ] . n_entries ; j ++ ) { ++ n_entries ; fprintf ( out , "%s:<S2SV_blank>--%c--<S2SV_blank>Version<S2SV_blank>%d<S2SV_blank>--<S2SV_blank>Object<S2SV_blank>%d<S2SV_blank>(%s)" , pdf -> name , pdf_get_object_status ( pdf , i , j ) , pdf -> xrefs [ i ] . version , pdf -> xrefs [ i ] . entries [ j ] . obj_id , get_type ( fp , pdf -> xrefs [ i ] . entries [ j ] . obj_id , & pdf -> xrefs [ i ] ) ) ; if ( 0 ) fprintf ( out , "<S2SV_blank>Page(%d)\\n" , page ) ; else fprintf ( out , "\\n" ) ; } } if ( ! ( flags & PDF_FLAG_QUIET ) ) { if ( pdf -> has_xref_streams || ! n_entries ) fprintf ( out , "%s:<S2SV_blank>This<S2SV_blank>PDF<S2SV_blank>contains<S2SV_blank>potential<S2SV_blank>cross<S2SV_blank>reference<S2SV_blank>streams.\\n" "%s:<S2SV_blank>An<S2SV_blank>object<S2SV_blank>summary<S2SV_blank>is<S2SV_blank>not<S2SV_blank>available.\\n" , pdf -> name , pdf -> name ) ; fprintf ( out , "----------<S2SV_blank>%s<S2SV_blank>----------\\n" "Versions:<S2SV_blank>%d\\n" , pdf -> name , n_versions ) ; if ( ! pdf -> has_xref_streams ) for ( i = 0 ; i < pdf -> n_xrefs ; i ++ ) { if ( pdf -> xrefs [ i ] . is_linear ) continue ; n_entries = pdf -> xrefs [ i ] . n_entries ; if ( pdf -> xrefs [ 0 ] . is_linear ) n_entries += pdf -> xrefs [ 0 ] . n_entries ; if ( pdf -> xrefs [ i ] . version && n_entries ) fprintf ( out , "Version<S2SV_blank>%d<S2SV_blank>--<S2SV_blank>%d<S2SV_blank>objects\\n" , pdf -> xrefs [ i ] . version , n_entries ) ; } } else fprintf ( out , "%s:<S2SV_blank>%d\\n" , pdf -> name , n_versions ) ; if ( dst ) { fclose ( dst ) ; free ( dst_name ) ; } }
CWE-119 static int _FVMenuClose ( FontView * fv ) { int i ; SplineFont * sf = fv -> b . cidmaster ? fv -> b . cidmaster : fv -> b . sf ; if ( ! SFCloseAllInstrs ( fv -> b . sf ) ) return ( false ) ; <S2SV_StartBug> if ( fv -> b . nextsame != NULL || fv -> b . sf -> fv != & fv -> b ) { <S2SV_EndBug> } else if ( SFAnyChanged ( sf ) ) { i = AskChanged ( fv -> b . sf ) ; if ( i == 2 ) return ( false ) ; if ( i == 0 && ! _FVMenuSave ( fv ) ) return ( false ) ; else SFClearAutoSave ( sf ) ; } _FVCloseWindows ( fv ) ; if ( sf -> filename != NULL ) RecentFilesRemember ( sf -> filename ) ; else if ( sf -> origname != NULL ) RecentFilesRemember ( sf -> origname ) ; GDrawDestroyWindow ( fv -> gw ) ; return ( true ) ; }
CWE-119 static int sd_e_h ( GWindow gw , GEvent * event ) { struct sd_data * sd = GDrawGetUserData ( gw ) ; if ( sd == NULL ) return ( true ) ; if ( event -> type == et_close ) { SD_DoCancel ( sd ) ; <S2SV_StartBug> } else if ( event -> type == et_char ) { <S2SV_EndBug> if ( event -> u . chr . keysym == GK_F1 || event -> u . chr . keysym == GK_Help ) { help ( "scripting.html" ) ; return ( true ) ; } return ( false ) ; } else if ( event -> type == et_map ) GDrawRaise ( gw ) ; else if ( event -> type == et_resize ) GDrawRequestExpose ( gw , NULL , false ) ; return ( true ) ; }
CWE-119 static void GTextFieldSave ( GTextField * gt , int utf8 ) { unichar_t * ret ; char * cret ; FILE * file ; unichar_t * pt ; if ( _ggadget_use_gettext ) { char * temp = GWidgetOpenFile8 ( _ ( "Save" ) , NULL , "*.{txt,py}" , NULL , NULL ) ; ret = utf82u_copy ( temp ) ; free ( temp ) ; } else ret = GWidgetSaveAsFile ( GStringGetResource ( _STR_Save , NULL ) , NULL , txt , NULL , NULL ) ; if ( ret == NULL ) return ; cret = u2def_copy ( ret ) ; free ( ret ) ; file = fopen ( cret , "w" ) ; if ( file == NULL ) { if ( _ggadget_use_gettext ) GWidgetError8 ( _ ( "Could<S2SV_blank>not<S2SV_blank>open<S2SV_blank>file" ) , _ ( "Could<S2SV_blank>not<S2SV_blank>open<S2SV_blank>%.100s" ) , cret ) ; else GWidgetError ( errort , error , cret ) ; free ( cret ) ; return ; } free ( cret ) ; if ( utf8 ) { putc ( 0xef , file ) ; putc ( 0xbb , file ) ; putc ( 0xbf , file ) ; for ( pt = gt -> text ; * pt ; ++ pt ) { if ( * pt < 0x80 ) putc ( * pt , file ) ; else if ( * pt < 0x800 ) { putc ( 0xc0 | ( * pt >> 6 ) , file ) ; putc ( 0x80 | ( * pt & 0x3f ) , file ) ; } else if ( * pt >= 0xd800 && * pt < 0xdc00 && pt [ 1 ] >= 0xdc00 && pt [ 1 ] < 0xe000 ) { int u = ( ( * pt >> 6 ) & 0xf ) + 1 , y = ( ( * pt & 3 ) << 4 ) | ( ( pt [ 1 ] >> 6 ) & 0xf ) ; putc ( 0xf0 | ( u >> 2 ) , file ) ; putc ( 0x80 | ( ( u & 3 ) << 4 ) | ( ( * pt >> 2 ) & 0xf ) , file ) ; putc ( 0x80 | y , file ) ; putc ( 0x80 | ( pt [ 1 ] & 0x3f ) , file ) ; } else { putc ( 0xe0 | ( * pt >> 12 ) , file ) ; putc ( 0x80 | ( ( * pt >> 6 ) & 0x3f ) , file ) ; putc ( 0x80 | ( * pt & 0x3f ) , file ) ; } } } else { putc ( 0xfeff >> 8 , file ) ; putc ( 0xfeff & 0xff , file ) ; for ( pt = gt -> text ; * pt ; ++ pt ) { putc ( * pt >> 8 , file ) ; putc ( * pt & 0xff , file ) ; } } fclose ( file ) ; <S2SV_StartBug> } <S2SV_EndBug>
CWE-787 GPMF_ERR IsValidSize ( GPMF_stream * ms , uint32_t size ) { if ( ms ) { <S2SV_StartBug> int32_t nestsize = ( int32_t ) ms -> nest_size [ ms -> nest_level ] ; <S2SV_EndBug> if ( nestsize == 0 && ms -> nest_level == 0 ) nestsize = ms -> buffer_size_longs ; if ( size + 2 <= nestsize ) return GPMF_OK ; } return GPMF_ERROR_BAD_STRUCTURE ; }
CWE-787 int main ( int argc , char * argv [ ] ) { int32_t ret = GPMF_OK ; GPMF_stream metadata_stream , * ms = & metadata_stream ; double metadatalength ; uint32_t * payload = NULL ; if ( argc != 2 ) { printf ( "usage:<S2SV_blank>%s<S2SV_blank><file_with_GPMF>\\n" , argv [ 0 ] ) ; return - 1 ; } size_t mp4 = OpenMP4Source ( argv [ 1 ] , MOV_GPMF_TRAK_TYPE , MOV_GPMF_TRAK_SUBTYPE ) ; <S2SV_StartBug> metadatalength = GetDuration ( mp4 ) ; <S2SV_EndBug> if ( metadatalength > 0.0 ) { uint32_t index , payloads = GetNumberPayloads ( mp4 ) ; # if 1 if ( payloads == 1 ) { uint32_t payloadsize = GetPayloadSize ( mp4 , 0 ) ; payload = GetPayload ( mp4 , payload , 0 ) ; if ( payload == NULL ) goto cleanup ; ret = GPMF_Init ( ms , payload , payloadsize ) ; if ( ret != GPMF_OK ) goto cleanup ; ret = GPMF_Validate ( ms , GPMF_RECURSE_LEVELS ) ; if ( GPMF_OK != ret ) { printf ( "Invalid<S2SV_blank>Structure\\n" ) ; goto cleanup ; } GPMF_ResetState ( ms ) ; do { PrintGPMF ( ms ) ; } while ( GPMF_OK == GPMF_Next ( ms , GPMF_RECURSE_LEVELS ) ) ; GPMF_ResetState ( ms ) ; printf ( "\\n" ) ; } # endif for ( index = 0 ; index < payloads ; index ++ ) { uint32_t payloadsize = GetPayloadSize ( mp4 , index ) ; <S2SV_StartBug> float in = 0.0 , out = 0.0 ; <S2SV_EndBug> payload = GetPayload ( mp4 , payload , index ) ; if ( payload == NULL ) goto cleanup ; ret = GetPayloadTime ( mp4 , index , & in , & out ) ; if ( ret != GPMF_OK ) goto cleanup ; ret = GPMF_Init ( ms , payload , payloadsize ) ; if ( ret != GPMF_OK ) goto cleanup ; # if 1 if ( index == 0 ) { ret = GPMF_FindNext ( ms , GPMF_KEY_STREAM , GPMF_RECURSE_LEVELS ) ; while ( GPMF_OK == ret ) { ret = GPMF_SeekToSamples ( ms ) ; if ( GPMF_OK == ret ) { uint32_t key = GPMF_Key ( ms ) ; GPMF_SampleType type = GPMF_Type ( ms ) ; uint32_t elements = GPMF_ElementsInStruct ( ms ) ; uint32_t samples = GPMF_PayloadSampleCount ( ms ) ; if ( samples ) { printf ( "<S2SV_blank><S2SV_blank>STRM<S2SV_blank>of<S2SV_blank>%c%c%c%c<S2SV_blank>" , PRINTF_4CC ( key ) ) ; if ( type == GPMF_TYPE_COMPLEX ) { GPMF_stream find_stream ; GPMF_CopyState ( ms , & find_stream ) ; if ( GPMF_OK == GPMF_FindPrev ( & find_stream , GPMF_KEY_TYPE , GPMF_CURRENT_LEVEL ) ) { char tmp [ 64 ] ; char * data = ( char * ) GPMF_RawData ( & find_stream ) ; int size = GPMF_RawDataSize ( & find_stream ) ; if ( size < sizeof ( tmp ) ) { memcpy ( tmp , data , size ) ; tmp [ size ] = 0 ; printf ( "of<S2SV_blank>type<S2SV_blank>%s<S2SV_blank>" , tmp ) ; } } } else { printf ( "of<S2SV_blank>type<S2SV_blank>%c<S2SV_blank>" , type ) ; } printf ( "with<S2SV_blank>%d<S2SV_blank>sample%s<S2SV_blank>" , samples , samples > 1 ? "s" : "" ) ; if ( elements > 1 ) printf ( "--<S2SV_blank>%d<S2SV_blank>elements<S2SV_blank>per<S2SV_blank>sample" , elements ) ; printf ( "\\n" ) ; } ret = GPMF_FindNext ( ms , GPMF_KEY_STREAM , GPMF_RECURSE_LEVELS ) ; } else { if ( ret == GPMF_ERROR_BAD_STRUCTURE ) { ret = GPMF_Next ( ms , GPMF_CURRENT_LEVEL ) ; } } } GPMF_ResetState ( ms ) ; printf ( "\\n" ) ; } # endif # if 1 if ( index == 0 ) { if ( GPMF_OK == GPMF_FindNext ( ms , STR2FOURCC ( "GPS5" ) , GPMF_RECURSE_LEVELS ) || GPMF_OK == GPMF_FindNext ( ms , STR2FOURCC ( "GPRI" ) , GPMF_RECURSE_LEVELS ) ) { uint32_t key = GPMF_Key ( ms ) ; uint32_t samples = GPMF_Repeat ( ms ) ; uint32_t elements = GPMF_ElementsInStruct ( ms ) ; uint32_t buffersize = samples * elements * sizeof ( double ) ; GPMF_stream find_stream ; double * ptr , * tmpbuffer = malloc ( buffersize ) ; char units [ 10 ] [ 6 ] = { "" } ; uint32_t unit_samples = 1 ; printf ( "MP4<S2SV_blank>Payload<S2SV_blank>time<S2SV_blank>%.3f<S2SV_blank>to<S2SV_blank>%.3f<S2SV_blank>seconds\\n" , in , out ) ; if ( tmpbuffer && samples ) { uint32_t i , j ; GPMF_CopyState ( ms , & find_stream ) ; if ( GPMF_OK == GPMF_FindPrev ( & find_stream , GPMF_KEY_SI_UNITS , GPMF_CURRENT_LEVEL ) || GPMF_OK == GPMF_FindPrev ( & find_stream , GPMF_KEY_UNITS , GPMF_CURRENT_LEVEL ) ) { char * data = ( char * ) GPMF_RawData ( & find_stream ) ; int ssize = GPMF_StructSize ( & find_stream ) ; unit_samples = GPMF_Repeat ( & find_stream ) ; for ( i = 0 ; i < unit_samples ; i ++ ) { memcpy ( units [ i ] , data , ssize ) ; units [ i ] [ ssize ] = 0 ; data += ssize ; } } GPMF_ScaledData ( ms , tmpbuffer , buffersize , 0 , samples , GPMF_TYPE_DOUBLE ) ; ptr = tmpbuffer ; for ( i = 0 ; i < samples ; i ++ ) { printf ( "%c%c%c%c<S2SV_blank>" , PRINTF_4CC ( key ) ) ; for ( j = 0 ; j < elements ; j ++ ) printf ( "%.3f%s,<S2SV_blank>" , * ptr ++ , units [ j % unit_samples ] ) ; printf ( "\\n" ) ; } free ( tmpbuffer ) ; } } GPMF_ResetState ( ms ) ; printf ( "\\n" ) ; } # endif } # if 1 while ( GPMF_OK == GPMF_FindNext ( ms , GPMF_KEY_STREAM , GPMF_RECURSE_LEVELS ) ) { if ( GPMF_OK == GPMF_SeekToSamples ( ms ) ) { <S2SV_StartBug> uint32_t fourcc = GPMF_Key ( ms ) ; <S2SV_EndBug> <S2SV_StartBug> double rate = GetGPMFSampleRate ( mp4 , fourcc , GPMF_SAMPLE_RATE_PRECISE ) ; <S2SV_EndBug> <S2SV_StartBug> printf ( "%c%c%c%c<S2SV_blank>sampling<S2SV_blank>rate<S2SV_blank>=<S2SV_blank>%f<S2SV_blank>Hz\\n" , PRINTF_4CC ( fourcc ) , rate ) ; <S2SV_EndBug> } } # endif cleanup : if ( payload ) FreePayload ( payload ) ; payload = NULL ; CloseSource ( mp4 ) ; } return ret ; }
CWE-787 int mp4client_main ( int argc , char * * argv ) { char c ; const char * str ; int ret_val = 0 ; u32 i , times [ 100 ] , nb_times , dump_mode ; u32 simulation_time_in_ms = 0 ; u32 initial_service_id = 0 ; Bool auto_exit = GF_FALSE ; Bool logs_set = GF_FALSE ; Bool start_fs = GF_FALSE ; Bool use_rtix = GF_FALSE ; Bool pause_at_first = GF_FALSE ; Bool no_cfg_save = GF_FALSE ; Bool is_cfg_only = GF_FALSE ; Double play_from = 0 ; # ifdef GPAC_MEMORY_TRACKING GF_MemTrackerType mem_track = GF_MemTrackerNone ; # endif Double fps = GF_IMPORT_DEFAULT_FPS ; Bool fill_ar , visible , do_uncache , has_command ; char * url_arg , * out_arg , * the_cfg , * rti_file , * views , * mosaic ; FILE * logfile = NULL ; Float scale = 1 ; # ifndef WIN32 dlopen ( NULL , RTLD_NOW | RTLD_GLOBAL ) ; # endif strcpy ( the_url , "." ) ; memset ( & user , 0 , sizeof ( GF_User ) ) ; dump_mode = DUMP_NONE ; fill_ar = visible = do_uncache = has_command = GF_FALSE ; url_arg = out_arg = the_cfg = rti_file = views = mosaic = NULL ; nb_times = 0 ; times [ 0 ] = 0 ; for ( i = 1 ; i < ( u32 ) argc ; i ++ ) { char * arg = argv [ i ] ; if ( ! strcmp ( arg , "-c" ) || ! strcmp ( arg , "-cfg" ) ) { the_cfg = argv [ i + 1 ] ; i ++ ; } else if ( ! strcmp ( arg , "-mem-track" ) || ! strcmp ( arg , "-mem-track-stack" ) ) { # ifdef GPAC_MEMORY_TRACKING mem_track = ! strcmp ( arg , "-mem-track-stack" ) ? GF_MemTrackerBackTrace : GF_MemTrackerSimple ; # else fprintf ( stderr , "WARNING<S2SV_blank>-<S2SV_blank>GPAC<S2SV_blank>not<S2SV_blank>compiled<S2SV_blank>with<S2SV_blank>Memory<S2SV_blank>Tracker<S2SV_blank>-<S2SV_blank>ignoring<S2SV_blank>\\"%s\\"\\n" , arg ) ; # endif } else if ( ! strcmp ( arg , "-gui" ) ) { gui_mode = 1 ; } else if ( ! strcmp ( arg , "-guid" ) ) { gui_mode = 2 ; } else if ( ! strcmp ( arg , "-h" ) || ! strcmp ( arg , "-help" ) ) { PrintUsage ( ) ; return 0 ; } } # ifdef GPAC_MEMORY_TRACKING gf_sys_init ( mem_track ) ; # else gf_sys_init ( GF_MemTrackerNone ) ; # endif gf_sys_set_args ( argc , ( const char * * ) argv ) ; cfg_file = gf_cfg_init ( the_cfg , NULL ) ; if ( ! cfg_file ) { fprintf ( stderr , "Error:<S2SV_blank>Configuration<S2SV_blank>File<S2SV_blank>not<S2SV_blank>found\\n" ) ; return 1 ; } if ( gf_log_set_tools_levels ( gf_cfg_get_key ( cfg_file , "General" , "Logs" ) ) != GF_OK ) { return 1 ; } if ( gf_cfg_get_key ( cfg_file , "General" , "Logs" ) != NULL ) { logs_set = GF_TRUE ; } if ( ! gui_mode ) { str = gf_cfg_get_key ( cfg_file , "General" , "ForceGUI" ) ; if ( str && ! strcmp ( str , "yes" ) ) gui_mode = 1 ; } for ( i = 1 ; i < ( u32 ) argc ; i ++ ) { char * arg = argv [ i ] ; if ( ! strcmp ( arg , "-rti" ) ) { rti_file = argv [ i + 1 ] ; i ++ ; } else if ( ! strcmp ( arg , "-rtix" ) ) { rti_file = argv [ i + 1 ] ; i ++ ; use_rtix = GF_TRUE ; } else if ( ! stricmp ( arg , "-size" ) ) { if ( sscanf ( argv [ i + 1 ] , "%dx%d" , & forced_width , & forced_height ) != 2 ) { forced_width = forced_height = 0 ; } i ++ ; } else if ( ! strcmp ( arg , "-quiet" ) ) { be_quiet = 1 ; } else if ( ! strcmp ( arg , "-strict-error" ) ) { gf_log_set_strict_error ( 1 ) ; } else if ( ! strcmp ( arg , "-log-file" ) || ! strcmp ( arg , "-lf" ) ) { logfile = gf_fopen ( argv [ i + 1 ] , "wt" ) ; gf_log_set_callback ( logfile , on_gpac_log ) ; i ++ ; } else if ( ! strcmp ( arg , "-logs" ) ) { if ( gf_log_set_tools_levels ( argv [ i + 1 ] ) != GF_OK ) { return 1 ; } logs_set = GF_TRUE ; i ++ ; } else if ( ! strcmp ( arg , "-log-clock" ) || ! strcmp ( arg , "-lc" ) ) { log_time_start = 1 ; } else if ( ! strcmp ( arg , "-log-utc" ) || ! strcmp ( arg , "-lu" ) ) { log_utc_time = 1 ; } # if defined ( __DARWIN__ ) || defined ( __APPLE__ ) else if ( ! strcmp ( arg , "-thread" ) ) threading_flags = 0 ; # else else if ( ! strcmp ( arg , "-no-thread" ) ) threading_flags = GF_TERM_NO_DECODER_THREAD | GF_TERM_NO_COMPOSITOR_THREAD | GF_TERM_WINDOW_NO_THREAD ; # endif else if ( ! strcmp ( arg , "-no-cthread" ) || ! strcmp ( arg , "-no-compositor-thread" ) ) threading_flags |= GF_TERM_NO_COMPOSITOR_THREAD ; else if ( ! strcmp ( arg , "-no-audio" ) ) no_audio = 1 ; else if ( ! strcmp ( arg , "-no-regulation" ) ) no_regulation = 1 ; else if ( ! strcmp ( arg , "-fs" ) ) start_fs = 1 ; else if ( ! strcmp ( arg , "-opt" ) ) { set_cfg_option ( argv [ i + 1 ] ) ; i ++ ; } else if ( ! strcmp ( arg , "-conf" ) ) { set_cfg_option ( argv [ i + 1 ] ) ; is_cfg_only = GF_TRUE ; i ++ ; } else if ( ! strcmp ( arg , "-ifce" ) ) { gf_cfg_set_key ( cfg_file , "Network" , "DefaultMCastInterface" , argv [ i + 1 ] ) ; i ++ ; } else if ( ! stricmp ( arg , "-help" ) ) { PrintUsage ( ) ; return 1 ; } else if ( ! stricmp ( arg , "-noprog" ) ) { no_prog = 1 ; gf_set_progress_callback ( NULL , progress_quiet ) ; } else if ( ! stricmp ( arg , "-no-save" ) || ! stricmp ( arg , "--no-save" ) ) { no_cfg_save = 1 ; } else if ( ! stricmp ( arg , "-ntp-shift" ) ) { s32 shift = atoi ( argv [ i + 1 ] ) ; i ++ ; gf_net_set_ntp_shift ( shift ) ; } else if ( ! stricmp ( arg , "-run-for" ) ) { simulation_time_in_ms = atoi ( argv [ i + 1 ] ) * 1000 ; if ( ! simulation_time_in_ms ) simulation_time_in_ms = 1 ; i ++ ; } else if ( ! strcmp ( arg , "-out" ) ) { out_arg = argv [ i + 1 ] ; i ++ ; } else if ( ! stricmp ( arg , "-fps" ) ) { fps = atof ( argv [ i + 1 ] ) ; i ++ ; } else if ( ! strcmp ( arg , "-avi" ) || ! strcmp ( arg , "-sha" ) ) { dump_mode &= 0xFFFF0000 ; if ( ! strcmp ( arg , "-sha" ) ) dump_mode |= DUMP_SHA1 ; else dump_mode |= DUMP_AVI ; if ( ( url_arg || ( i + 2 < ( u32 ) argc ) ) && get_time_list ( argv [ i + 1 ] , times , & nb_times ) ) { if ( ! strcmp ( arg , "-avi" ) && ( nb_times != 2 ) ) { fprintf ( stderr , "Only<S2SV_blank>one<S2SV_blank>time<S2SV_blank>arg<S2SV_blank>found<S2SV_blank>for<S2SV_blank>-avi<S2SV_blank>-<S2SV_blank>check<S2SV_blank>usage\\n" ) ; return 1 ; } i ++ ; } } else if ( ! strcmp ( arg , "-rgbds" ) ) { dump_mode |= DUMP_RGB_DEPTH_SHAPE ; } else if ( ! strcmp ( arg , "-rgbd" ) ) { dump_mode |= DUMP_RGB_DEPTH ; } else if ( ! strcmp ( arg , "-depth" ) ) { dump_mode |= DUMP_DEPTH_ONLY ; } else if ( ! strcmp ( arg , "-bmp" ) ) { dump_mode &= 0xFFFF0000 ; dump_mode |= DUMP_BMP ; if ( ( url_arg || ( i + 2 < ( u32 ) argc ) ) && get_time_list ( argv [ i + 1 ] , times , & nb_times ) ) i ++ ; } else if ( ! strcmp ( arg , "-png" ) ) { dump_mode &= 0xFFFF0000 ; dump_mode |= DUMP_PNG ; if ( ( url_arg || ( i + 2 < ( u32 ) argc ) ) && get_time_list ( argv [ i + 1 ] , times , & nb_times ) ) i ++ ; } else if ( ! strcmp ( arg , "-raw" ) ) { dump_mode &= 0xFFFF0000 ; dump_mode |= DUMP_RAW ; if ( ( url_arg || ( i + 2 < ( u32 ) argc ) ) && get_time_list ( argv [ i + 1 ] , times , & nb_times ) ) i ++ ; } else if ( ! stricmp ( arg , "-scale" ) ) { sscanf ( argv [ i + 1 ] , "%f" , & scale ) ; i ++ ; } else if ( ! strcmp ( arg , "-c" ) || ! strcmp ( arg , "-cfg" ) ) { i ++ ; } if ( ! gui_mode ) { if ( arg [ 0 ] != '-' ) { if ( url_arg ) { fprintf ( stderr , "Several<S2SV_blank>input<S2SV_blank>URLs<S2SV_blank>provided<S2SV_blank>(\\"%s\\",<S2SV_blank>\\"%s\\").<S2SV_blank>Check<S2SV_blank>your<S2SV_blank>command-line.\\n" , url_arg , arg ) ; return 1 ; } url_arg = arg ; } else if ( ! strcmp ( arg , "-loop" ) ) loop_at_end = 1 ; else if ( ! strcmp ( arg , "-bench" ) ) bench_mode = 1 ; else if ( ! strcmp ( arg , "-vbench" ) ) bench_mode = 2 ; else if ( ! strcmp ( arg , "-sbench" ) ) bench_mode = 3 ; else if ( ! strcmp ( arg , "-no-addon" ) ) enable_add_ons = GF_FALSE ; else if ( ! strcmp ( arg , "-pause" ) ) pause_at_first = 1 ; else if ( ! strcmp ( arg , "-play-from" ) ) { play_from = atof ( ( const char * ) argv [ i + 1 ] ) ; i ++ ; } else if ( ! strcmp ( arg , "-speed" ) ) { playback_speed = FLT2FIX ( atof ( ( const char * ) argv [ i + 1 ] ) ) ; if ( playback_speed <= 0 ) playback_speed = FIX_ONE ; i ++ ; } else if ( ! strcmp ( arg , "-no-wnd" ) ) user . init_flags |= GF_TERM_WINDOWLESS ; else if ( ! strcmp ( arg , "-no-back" ) ) user . init_flags |= GF_TERM_WINDOW_TRANSPARENT ; else if ( ! strcmp ( arg , "-align" ) ) { if ( argv [ i + 1 ] [ 0 ] == 'm' ) align_mode = 1 ; else if ( argv [ i + 1 ] [ 0 ] == 'b' ) align_mode = 2 ; align_mode <<= 8 ; if ( argv [ i + 1 ] [ 1 ] == 'm' ) align_mode |= 1 ; else if ( argv [ i + 1 ] [ 1 ] == 'r' ) align_mode |= 2 ; i ++ ; } else if ( ! strcmp ( arg , "-fill" ) ) { fill_ar = GF_TRUE ; } else if ( ! strcmp ( arg , "-show" ) ) { visible = 1 ; } else if ( ! strcmp ( arg , "-uncache" ) ) { do_uncache = GF_TRUE ; } else if ( ! strcmp ( arg , "-exit" ) ) auto_exit = GF_TRUE ; else if ( ! stricmp ( arg , "-views" ) ) { views = argv [ i + 1 ] ; i ++ ; } else if ( ! stricmp ( arg , "-mosaic" ) ) { mosaic = argv [ i + 1 ] ; i ++ ; } else if ( ! stricmp ( arg , "-com" ) ) { has_command = GF_TRUE ; i ++ ; } else if ( ! stricmp ( arg , "-service" ) ) { initial_service_id = atoi ( argv [ i + 1 ] ) ; i ++ ; } } } if ( is_cfg_only ) { gf_cfg_del ( cfg_file ) ; fprintf ( stderr , "GPAC<S2SV_blank>Config<S2SV_blank>updated\\n" ) ; return 0 ; } if ( do_uncache ) { const char * cache_dir = gf_cfg_get_key ( cfg_file , "General" , "CacheDirectory" ) ; do_flatten_cache ( cache_dir ) ; fprintf ( stderr , "GPAC<S2SV_blank>Cache<S2SV_blank>dir<S2SV_blank>%s<S2SV_blank>flattened\\n" , cache_dir ) ; gf_cfg_del ( cfg_file ) ; return 0 ; } if ( dump_mode && ! url_arg ) { FILE * test ; url_arg = ( char * ) gf_cfg_get_key ( cfg_file , "General" , "StartupFile" ) ; test = url_arg ? gf_fopen ( url_arg , "rt" ) : NULL ; if ( ! test ) url_arg = NULL ; else gf_fclose ( test ) ; if ( ! url_arg ) { fprintf ( stderr , "Missing<S2SV_blank>argument<S2SV_blank>for<S2SV_blank>dump\\n" ) ; PrintUsage ( ) ; if ( logfile ) gf_fclose ( logfile ) ; return 1 ; } } if ( ! gui_mode && ! url_arg && ( gf_cfg_get_key ( cfg_file , "General" , "StartupFile" ) != NULL ) ) { gui_mode = 1 ; } # ifdef WIN32 if ( gui_mode == 1 ) { const char * opt ; TCHAR buffer [ 1024 ] ; DWORD res = GetCurrentDirectory ( 1024 , buffer ) ; buffer [ res ] = 0 ; opt = gf_cfg_get_key ( cfg_file , "General" , "ModulesDirectory" ) ; if ( strstr ( opt , buffer ) ) { gui_mode = 1 ; } else { gui_mode = 2 ; } } # endif if ( gui_mode == 1 ) { hide_shell ( 1 ) ; } if ( gui_mode ) { no_prog = 1 ; gf_set_progress_callback ( NULL , progress_quiet ) ; } if ( ! url_arg && simulation_time_in_ms ) simulation_time_in_ms += gf_sys_clock ( ) ; # if defined ( __DARWIN__ ) || defined ( __APPLE__ ) carbon_init ( ) ; # endif if ( dump_mode ) rti_file = NULL ; if ( ! logs_set ) { gf_log_set_tool_level ( GF_LOG_ALL , GF_LOG_WARNING ) ; } if ( rti_file || logfile || log_utc_time || log_time_start ) gf_log_set_callback ( NULL , on_gpac_log ) ; if ( rti_file ) init_rti_logs ( rti_file , url_arg , use_rtix ) ; { GF_SystemRTInfo rti ; if ( gf_sys_get_rti ( 0 , & rti , 0 ) ) fprintf ( stderr , "System<S2SV_blank>info:<S2SV_blank>%d<S2SV_blank>MB<S2SV_blank>RAM<S2SV_blank>-<S2SV_blank>%d<S2SV_blank>cores\\n" , ( u32 ) ( rti . physical_memory / 1024 / 1024 ) , rti . nb_cores ) ; } if ( dump_mode ) { user . init_flags |= GF_TERM_NO_DECODER_THREAD | GF_TERM_NO_COMPOSITOR_THREAD | GF_TERM_NO_REGULATION ; if ( ! visible ) user . init_flags |= GF_TERM_INIT_HIDE ; gf_cfg_set_key ( cfg_file , "Audio" , "DriverName" , "Raw<S2SV_blank>Audio<S2SV_blank>Output" ) ; no_cfg_save = GF_TRUE ; } else { init_w = forced_width ; init_h = forced_height ; } user . modules = gf_modules_new ( NULL , cfg_file ) ; if ( user . modules ) i = gf_modules_get_count ( user . modules ) ; if ( ! i || ! user . modules ) { fprintf ( stderr , "Error:<S2SV_blank>no<S2SV_blank>modules<S2SV_blank>found<S2SV_blank>-<S2SV_blank>exiting\\n" ) ; if ( user . modules ) gf_modules_del ( user . modules ) ; gf_cfg_del ( cfg_file ) ; gf_sys_close ( ) ; if ( logfile ) gf_fclose ( logfile ) ; return 1 ; } fprintf ( stderr , "Modules<S2SV_blank>Found<S2SV_blank>:<S2SV_blank>%d<S2SV_blank>\\n" , i ) ; str = gf_cfg_get_key ( cfg_file , "General" , "GPACVersion" ) ; if ( ! str || strcmp ( str , GPAC_FULL_VERSION ) ) { gf_cfg_del_section ( cfg_file , "PluginsCache" ) ; gf_cfg_set_key ( cfg_file , "General" , "GPACVersion" , GPAC_FULL_VERSION ) ; } user . config = cfg_file ; user . EventProc = GPAC_EventProc ; user . opaque = user . modules ; if ( threading_flags ) user . init_flags |= threading_flags ; if ( no_audio ) user . init_flags |= GF_TERM_NO_AUDIO ; if ( no_regulation ) user . init_flags |= GF_TERM_NO_REGULATION ; if ( threading_flags & ( GF_TERM_NO_DECODER_THREAD | GF_TERM_NO_COMPOSITOR_THREAD ) ) term_step = GF_TRUE ; if ( dump_mode ) user . init_flags |= GF_TERM_USE_AUDIO_HW_CLOCK ; if ( bench_mode ) { gf_cfg_discard_changes ( user . config ) ; auto_exit = GF_TRUE ; gf_cfg_set_key ( user . config , "Audio" , "DriverName" , "Raw<S2SV_blank>Audio<S2SV_blank>Output" ) ; if ( bench_mode != 2 ) { gf_cfg_set_key ( user . config , "Video" , "DriverName" , "Raw<S2SV_blank>Video<S2SV_blank>Output" ) ; gf_cfg_set_key ( user . config , "RAWVideo" , "RawOutput" , "null" ) ; gf_cfg_set_key ( user . config , "Compositor" , "OpenGLMode" , "disable" ) ; } else { gf_cfg_set_key ( user . config , "Video" , "DisableVSync" , "yes" ) ; } } { char dim [ 50 ] ; sprintf ( dim , "%d" , forced_width ) ; gf_cfg_set_key ( user . config , "Compositor" , "DefaultWidth" , forced_width ? dim : NULL ) ; sprintf ( dim , "%d" , forced_height ) ; gf_cfg_set_key ( user . config , "Compositor" , "DefaultHeight" , forced_height ? dim : NULL ) ; } fprintf ( stderr , "Loading<S2SV_blank>GPAC<S2SV_blank>Terminal\\n" ) ; i = gf_sys_clock ( ) ; term = gf_term_new ( & user ) ; if ( ! term ) { fprintf ( stderr , "\\nInit<S2SV_blank>error<S2SV_blank>-<S2SV_blank>check<S2SV_blank>you<S2SV_blank>have<S2SV_blank>at<S2SV_blank>least<S2SV_blank>one<S2SV_blank>video<S2SV_blank>out<S2SV_blank>and<S2SV_blank>one<S2SV_blank>rasterizer...\\nFound<S2SV_blank>modules:\\n" ) ; list_modules ( user . modules ) ; gf_modules_del ( user . modules ) ; gf_cfg_discard_changes ( cfg_file ) ; gf_cfg_del ( cfg_file ) ; gf_sys_close ( ) ; if ( logfile ) gf_fclose ( logfile ) ; return 1 ; } fprintf ( stderr , "Terminal<S2SV_blank>Loaded<S2SV_blank>in<S2SV_blank>%d<S2SV_blank>ms\\n" , gf_sys_clock ( ) - i ) ; if ( bench_mode ) { display_rti = 2 ; gf_term_set_option ( term , GF_OPT_VIDEO_BENCH , ( bench_mode == 3 ) ? 2 : 1 ) ; if ( bench_mode == 1 ) bench_mode = 2 ; } if ( dump_mode ) { if ( fill_ar ) gf_term_set_option ( term , GF_OPT_ASPECT_RATIO , GF_ASPECT_RATIO_FILL_SCREEN ) ; } else { str = gf_cfg_get_key ( cfg_file , "Video" , "DriverName" ) ; if ( ! bench_mode && ! strcmp ( str , "Raw<S2SV_blank>Video<S2SV_blank>Output" ) ) fprintf ( stderr , "WARNING:<S2SV_blank>using<S2SV_blank>raw<S2SV_blank>output<S2SV_blank>video<S2SV_blank>(memory<S2SV_blank>only)<S2SV_blank>-<S2SV_blank>no<S2SV_blank>display<S2SV_blank>used\\n" ) ; str = gf_cfg_get_key ( cfg_file , "Audio" , "DriverName" ) ; if ( ! str || ! strcmp ( str , "No<S2SV_blank>Audio<S2SV_blank>Output<S2SV_blank>Available" ) ) fprintf ( stderr , "WARNING:<S2SV_blank>no<S2SV_blank>audio<S2SV_blank>output<S2SV_blank>available<S2SV_blank>-<S2SV_blank>make<S2SV_blank>sure<S2SV_blank>no<S2SV_blank>other<S2SV_blank>program<S2SV_blank>is<S2SV_blank>locking<S2SV_blank>the<S2SV_blank>sound<S2SV_blank>card\\n" ) ; str = gf_cfg_get_key ( cfg_file , "General" , "NoMIMETypeFetch" ) ; no_mime_check = ( str && ! stricmp ( str , "yes" ) ) ? 1 : 0 ; } str = gf_cfg_get_key ( cfg_file , "HTTPProxy" , "Enabled" ) ; if ( str && ! strcmp ( str , "yes" ) ) { str = gf_cfg_get_key ( cfg_file , "HTTPProxy" , "Name" ) ; if ( str ) fprintf ( stderr , "HTTP<S2SV_blank>Proxy<S2SV_blank>%s<S2SV_blank>enabled\\n" , str ) ; } if ( rti_file ) { str = gf_cfg_get_key ( cfg_file , "General" , "RTIRefreshPeriod" ) ; if ( str ) { rti_update_time_ms = atoi ( str ) ; } else { gf_cfg_set_key ( cfg_file , "General" , "RTIRefreshPeriod" , "200" ) ; } UpdateRTInfo ( "At<S2SV_blank>GPAC<S2SV_blank>load<S2SV_blank>time\\n" ) ; } Run = 1 ; if ( dump_mode ) { if ( ! nb_times ) { times [ 0 ] = 0 ; nb_times ++ ; } ret_val = dump_file ( url_arg , out_arg , dump_mode , fps , forced_width , forced_height , scale , times , nb_times ) ; Run = 0 ; } else if ( views ) { } else if ( ! gui_mode && url_arg ) { char * ext ; if ( strlen ( url_arg ) >= sizeof ( the_url ) ) { fprintf ( stderr , "Input<S2SV_blank>url<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long,<S2SV_blank>truncating<S2SV_blank>to<S2SV_blank>%d<S2SV_blank>chars.\\n" , url_arg , ( int ) ( sizeof ( the_url ) - 1 ) ) ; strncpy ( the_url , url_arg , sizeof ( the_url ) - 1 ) ; the_url [ sizeof ( the_url ) - 1 ] = 0 ; } else { strcpy ( the_url , url_arg ) ; } ext = strrchr ( the_url , '.' ) ; if ( ext && ( ! stricmp ( ext , ".m3u" ) || ! stricmp ( ext , ".pls" ) ) ) { GF_Err e = GF_OK ; fprintf ( stderr , "Opening<S2SV_blank>Playlist<S2SV_blank>%s\\n" , the_url ) ; strcpy ( pl_path , the_url ) ; if ( ! strncmp ( "http:" , the_url , 5 ) ) { GF_DownloadSession * sess = gf_dm_sess_new ( term -> downloader , the_url , GF_NETIO_SESSION_NOT_THREADED , NULL , NULL , & e ) ; if ( sess ) { e = gf_dm_sess_process ( sess ) ; if ( ! e ) { strncpy ( the_url , gf_dm_sess_get_cache_name ( sess ) , sizeof ( the_url ) - 1 ) ; <S2SV_StartBug> the_url [ sizeof ( the_cfg ) - 1 ] = 0 ; <S2SV_EndBug> } gf_dm_sess_del ( sess ) ; } } playlist = e ? NULL : gf_fopen ( the_url , "rt" ) ; readonly_playlist = 1 ; if ( playlist ) { request_next_playlist_item = GF_TRUE ; } else { if ( e ) fprintf ( stderr , "Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>playlist<S2SV_blank>%s:<S2SV_blank>%s\\n" , the_url , gf_error_to_string ( e ) ) ; fprintf ( stderr , "Hit<S2SV_blank>\'h\'<S2SV_blank>for<S2SV_blank>help\\n\\n" ) ; } } else { fprintf ( stderr , "Opening<S2SV_blank>URL<S2SV_blank>%s\\n" , the_url ) ; if ( pause_at_first ) fprintf ( stderr , "[Status:<S2SV_blank>Paused]\\n" ) ; gf_term_connect_from_time ( term , the_url , ( u64 ) ( play_from * 1000 ) , pause_at_first ) ; } } else { fprintf ( stderr , "Hit<S2SV_blank>\'h\'<S2SV_blank>for<S2SV_blank>help\\n\\n" ) ; str = gf_cfg_get_key ( cfg_file , "General" , "StartupFile" ) ; if ( str ) { strncpy ( the_url , "MP4Client<S2SV_blank>" GPAC_FULL_VERSION , sizeof ( the_url ) - 1 ) ; the_url [ sizeof ( the_url ) - 1 ] = 0 ; gf_term_connect ( term , str ) ; startup_file = 1 ; is_connected = 1 ; } } if ( gui_mode == 2 ) gui_mode = 0 ; if ( start_fs ) gf_term_set_option ( term , GF_OPT_FULLSCREEN , 1 ) ; if ( views ) { char szTemp [ 4046 ] ; sprintf ( szTemp , "views://%s" , views ) ; gf_term_connect ( term , szTemp ) ; } if ( mosaic ) { char szTemp [ 4046 ] ; sprintf ( szTemp , "mosaic://%s" , mosaic ) ; gf_term_connect ( term , szTemp ) ; } if ( bench_mode ) { rti_update_time_ms = 500 ; bench_mode_start = gf_sys_clock ( ) ; } while ( Run ) { if ( ( gui_mode == 1 ) || ! gf_prompt_has_input ( ) ) { if ( reload ) { reload = 0 ; gf_term_disconnect ( term ) ; gf_term_connect ( term , startup_file ? gf_cfg_get_key ( cfg_file , "General" , "StartupFile" ) : the_url ) ; } if ( restart && gf_term_get_option ( term , GF_OPT_IS_OVER ) ) { restart = 0 ; gf_term_play_from_time ( term , 0 , 0 ) ; } if ( request_next_playlist_item ) { c = '\\n' ; request_next_playlist_item = 0 ; goto force_input ; } if ( has_command && is_connected ) { has_command = GF_FALSE ; for ( i = 0 ; i < ( u32 ) argc ; i ++ ) { if ( ! strcmp ( argv [ i ] , "-com" ) ) { gf_term_scene_update ( term , NULL , argv [ i + 1 ] ) ; i ++ ; } } } if ( initial_service_id && is_connected ) { GF_ObjectManager * root_od = gf_term_get_root_object ( term ) ; if ( root_od ) { gf_term_select_service ( term , root_od , initial_service_id ) ; initial_service_id = 0 ; } } if ( ! use_rtix || display_rti ) UpdateRTInfo ( NULL ) ; if ( term_step ) { gf_term_process_step ( term ) ; } else { gf_sleep ( rti_update_time_ms ) ; } if ( auto_exit && eos_seen && gf_term_get_option ( term , GF_OPT_IS_OVER ) ) { Run = GF_FALSE ; } if ( simulation_time_in_ms && ( ( gf_term_get_elapsed_time_in_ms ( term ) > simulation_time_in_ms ) || ( ! url_arg && gf_sys_clock ( ) > simulation_time_in_ms ) ) ) { Run = GF_FALSE ; } continue ; } c = gf_prompt_get_char ( ) ; force_input : switch ( c ) { case 'q' : { GF_Event evt ; memset ( & evt , 0 , sizeof ( GF_Event ) ) ; evt . type = GF_EVENT_QUIT ; gf_term_send_event ( term , & evt ) ; } break ; case 'X' : exit ( 0 ) ; break ; case 'Q' : break ; case 'o' : startup_file = 0 ; gf_term_disconnect ( term ) ; fprintf ( stderr , "Enter<S2SV_blank>the<S2SV_blank>absolute<S2SV_blank>URL\\n" ) ; if ( 1 > scanf ( "%s" , the_url ) ) { fprintf ( stderr , "Cannot<S2SV_blank>read<S2SV_blank>absolute<S2SV_blank>URL,<S2SV_blank>aborting\\n" ) ; break ; } if ( rti_file ) init_rti_logs ( rti_file , the_url , use_rtix ) ; gf_term_connect ( term , the_url ) ; break ; case 'O' : gf_term_disconnect ( term ) ; fprintf ( stderr , "Enter<S2SV_blank>the<S2SV_blank>absolute<S2SV_blank>URL<S2SV_blank>to<S2SV_blank>the<S2SV_blank>playlist\\n" ) ; if ( 1 > scanf ( "%s" , the_url ) ) { fprintf ( stderr , "Cannot<S2SV_blank>read<S2SV_blank>the<S2SV_blank>absolute<S2SV_blank>URL,<S2SV_blank>aborting.\\n" ) ; break ; } playlist = gf_fopen ( the_url , "rt" ) ; if ( playlist ) { if ( 1 > fscanf ( playlist , "%s" , the_url ) ) { fprintf ( stderr , "Cannot<S2SV_blank>read<S2SV_blank>any<S2SV_blank>URL<S2SV_blank>from<S2SV_blank>playlist,<S2SV_blank>aborting.\\n" ) ; gf_fclose ( playlist ) ; break ; } fprintf ( stderr , "Opening<S2SV_blank>URL<S2SV_blank>%s\\n" , the_url ) ; gf_term_connect ( term , the_url ) ; } break ; case '\\n' : case 'N' : if ( playlist ) { int res ; gf_term_disconnect ( term ) ; res = fscanf ( playlist , "%s" , the_url ) ; if ( ( res == EOF ) && loop_at_end ) { fseek ( playlist , 0 , SEEK_SET ) ; res = fscanf ( playlist , "%s" , the_url ) ; } if ( res == EOF ) { fprintf ( stderr , "No<S2SV_blank>more<S2SV_blank>items<S2SV_blank>-<S2SV_blank>exiting\\n" ) ; Run = 0 ; } else if ( the_url [ 0 ] == '#' ) { request_next_playlist_item = GF_TRUE ; } else { fprintf ( stderr , "Opening<S2SV_blank>URL<S2SV_blank>%s\\n" , the_url ) ; gf_term_connect_with_path ( term , the_url , pl_path ) ; } } break ; case 'P' : if ( playlist ) { u32 count ; gf_term_disconnect ( term ) ; if ( 1 > scanf ( "%u" , & count ) ) { fprintf ( stderr , "Cannot<S2SV_blank>read<S2SV_blank>number,<S2SV_blank>aborting.\\n" ) ; break ; } while ( count ) { if ( fscanf ( playlist , "%s" , the_url ) ) { fprintf ( stderr , "Failed<S2SV_blank>to<S2SV_blank>read<S2SV_blank>line,<S2SV_blank>aborting\\n" ) ; break ; } count -- ; } fprintf ( stderr , "Opening<S2SV_blank>URL<S2SV_blank>%s\\n" , the_url ) ; gf_term_connect ( term , the_url ) ; } break ; case 'r' : if ( is_connected ) reload = 1 ; break ; case 'D' : if ( is_connected ) gf_term_disconnect ( term ) ; break ; case 'p' : if ( is_connected ) { Bool is_pause = gf_term_get_option ( term , GF_OPT_PLAY_STATE ) ; fprintf ( stderr , "[Status:<S2SV_blank>%s]\\n" , is_pause ? "Playing" : "Paused" ) ; gf_term_set_option ( term , GF_OPT_PLAY_STATE , is_pause ? GF_STATE_PLAYING : GF_STATE_PAUSED ) ; } break ; case 's' : if ( is_connected ) { gf_term_set_option ( term , GF_OPT_PLAY_STATE , GF_STATE_STEP_PAUSE ) ; fprintf ( stderr , "Step<S2SV_blank>time:<S2SV_blank>" ) ; PrintTime ( gf_term_get_time_in_ms ( term ) ) ; fprintf ( stderr , "\\n" ) ; } break ; case 'z' : case 'T' : if ( ! CanSeek || ( Duration <= 2000 ) ) { fprintf ( stderr , "scene<S2SV_blank>not<S2SV_blank>seekable\\n" ) ; } else { Double res ; s32 seekTo ; fprintf ( stderr , "Duration:<S2SV_blank>" ) ; PrintTime ( Duration ) ; res = gf_term_get_time_in_ms ( term ) ; if ( c == 'z' ) { res *= 100 ; res /= ( s64 ) Duration ; fprintf ( stderr , "<S2SV_blank>(current<S2SV_blank>%.2f<S2SV_blank>%%)\\nEnter<S2SV_blank>Seek<S2SV_blank>percentage:\\n" , res ) ; if ( scanf ( "%d" , & seekTo ) == 1 ) { if ( seekTo > 100 ) seekTo = 100 ; res = ( Double ) ( s64 ) Duration ; res /= 100 ; res *= seekTo ; gf_term_play_from_time ( term , ( u64 ) ( s64 ) res , 0 ) ; } } else { u32 r , h , m , s ; fprintf ( stderr , "<S2SV_blank>-<S2SV_blank>Current<S2SV_blank>Time:<S2SV_blank>" ) ; PrintTime ( ( u64 ) res ) ; fprintf ( stderr , "\\nEnter<S2SV_blank>seek<S2SV_blank>time<S2SV_blank>(Format:<S2SV_blank>s,<S2SV_blank>m:s<S2SV_blank>or<S2SV_blank>h:m:s):\\n" ) ; h = m = s = 0 ; r = scanf ( "%d:%d:%d" , & h , & m , & s ) ; if ( r == 2 ) { s = m ; m = h ; h = 0 ; } else if ( r == 1 ) { s = h ; m = h = 0 ; } if ( r && ( r <= 3 ) ) { u64 time = h * 3600 + m * 60 + s ; gf_term_play_from_time ( term , time * 1000 , 0 ) ; } } } break ; case 't' : { if ( is_connected ) { fprintf ( stderr , "Current<S2SV_blank>Time:<S2SV_blank>" ) ; PrintTime ( gf_term_get_time_in_ms ( term ) ) ; fprintf ( stderr , "<S2SV_blank>-<S2SV_blank>Duration:<S2SV_blank>" ) ; PrintTime ( Duration ) ; fprintf ( stderr , "\\n" ) ; } } break ; case 'w' : if ( is_connected ) PrintWorldInfo ( term ) ; break ; case 'v' : if ( is_connected ) PrintODList ( term , NULL , 0 , 0 , "Root" ) ; break ; case 'i' : if ( is_connected ) { u32 ID ; fprintf ( stderr , "Enter<S2SV_blank>OD<S2SV_blank>ID<S2SV_blank>(0<S2SV_blank>for<S2SV_blank>main<S2SV_blank>OD):<S2SV_blank>" ) ; fflush ( stderr ) ; if ( scanf ( "%ud" , & ID ) == 1 ) { ViewOD ( term , ID , ( u32 ) - 1 , NULL ) ; } else { char str_url [ GF_MAX_PATH ] ; if ( scanf ( "%s" , str_url ) == 1 ) ViewOD ( term , 0 , ( u32 ) - 1 , str_url ) ; } } break ; case 'j' : if ( is_connected ) { u32 num ; do { fprintf ( stderr , "Enter<S2SV_blank>OD<S2SV_blank>number<S2SV_blank>(0<S2SV_blank>for<S2SV_blank>main<S2SV_blank>OD):<S2SV_blank>" ) ; fflush ( stderr ) ; } while ( 1 > scanf ( "%ud" , & num ) ) ; ViewOD ( term , ( u32 ) - 1 , num , NULL ) ; } break ; case 'b' : if ( is_connected ) ViewODs ( term , 1 ) ; break ; case 'm' : if ( is_connected ) ViewODs ( term , 0 ) ; break ; case 'l' : list_modules ( user . modules ) ; break ; case 'n' : if ( is_connected ) set_navigation ( ) ; break ; case 'x' : if ( is_connected ) gf_term_set_option ( term , GF_OPT_NAVIGATION_TYPE , 0 ) ; break ; case 'd' : if ( is_connected ) { GF_ObjectManager * odm = NULL ; char radname [ GF_MAX_PATH ] , * sExt ; GF_Err e ; u32 i , count , odid ; Bool xml_dump , std_out ; radname [ 0 ] = 0 ; do { fprintf ( stderr , "Enter<S2SV_blank>Inline<S2SV_blank>OD<S2SV_blank>ID<S2SV_blank>if<S2SV_blank>any<S2SV_blank>or<S2SV_blank>0<S2SV_blank>:<S2SV_blank>" ) ; fflush ( stderr ) ; } while ( 1 > scanf ( "%ud" , & odid ) ) ; if ( odid ) { GF_ObjectManager * root_odm = gf_term_get_root_object ( term ) ; if ( ! root_odm ) break ; count = gf_term_get_object_count ( term , root_odm ) ; for ( i = 0 ; i < count ; i ++ ) { GF_MediaInfo info ; odm = gf_term_get_object ( term , root_odm , i ) ; if ( gf_term_get_object_info ( term , odm , & info ) == GF_OK ) { if ( info . od -> objectDescriptorID == odid ) break ; } odm = NULL ; } } do { fprintf ( stderr , "Enter<S2SV_blank>file<S2SV_blank>radical<S2SV_blank>name<S2SV_blank>(+\\\'.x\\\'<S2SV_blank>for<S2SV_blank>XML<S2SV_blank>dumping)<S2SV_blank>-<S2SV_blank>\\"std\\"<S2SV_blank>for<S2SV_blank>stderr:<S2SV_blank>" ) ; fflush ( stderr ) ; } while ( 1 > scanf ( "%s" , radname ) ) ; sExt = strrchr ( radname , '.' ) ; xml_dump = 0 ; if ( sExt ) { if ( ! stricmp ( sExt , ".x" ) ) xml_dump = 1 ; sExt [ 0 ] = 0 ; } std_out = strnicmp ( radname , "std" , 3 ) ? 0 : 1 ; e = gf_term_dump_scene ( term , std_out ? NULL : radname , NULL , xml_dump , 0 , odm ) ; fprintf ( stderr , "Dump<S2SV_blank>done<S2SV_blank>(%s)\\n" , gf_error_to_string ( e ) ) ; } break ; case 'c' : PrintGPACConfig ( ) ; break ; case '3' : { Bool use_3d = ! gf_term_get_option ( term , GF_OPT_USE_OPENGL ) ; if ( gf_term_set_option ( term , GF_OPT_USE_OPENGL , use_3d ) == GF_OK ) { fprintf ( stderr , "Using<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>2D<S2SV_blank>drawing\\n" , use_3d ? "OpenGL" : "2D<S2SV_blank>rasterizer" ) ; } } break ; case 'k' : { Bool opt = gf_term_get_option ( term , GF_OPT_STRESS_MODE ) ; opt = ! opt ; fprintf ( stderr , "Turning<S2SV_blank>stress<S2SV_blank>mode<S2SV_blank>%s\\n" , opt ? "on" : "off" ) ; gf_term_set_option ( term , GF_OPT_STRESS_MODE , opt ) ; } break ; case '4' : gf_term_set_option ( term , GF_OPT_ASPECT_RATIO , GF_ASPECT_RATIO_4_3 ) ; break ; case '5' : gf_term_set_option ( term , GF_OPT_ASPECT_RATIO , GF_ASPECT_RATIO_16_9 ) ; break ; case '6' : gf_term_set_option ( term , GF_OPT_ASPECT_RATIO , GF_ASPECT_RATIO_FILL_SCREEN ) ; break ; case '7' : gf_term_set_option ( term , GF_OPT_ASPECT_RATIO , GF_ASPECT_RATIO_KEEP ) ; break ; case 'C' : switch ( gf_term_get_option ( term , GF_OPT_MEDIA_CACHE ) ) { case GF_MEDIA_CACHE_DISABLED : gf_term_set_option ( term , GF_OPT_MEDIA_CACHE , GF_MEDIA_CACHE_ENABLED ) ; break ; case GF_MEDIA_CACHE_ENABLED : gf_term_set_option ( term , GF_OPT_MEDIA_CACHE , GF_MEDIA_CACHE_DISABLED ) ; break ; case GF_MEDIA_CACHE_RUNNING : fprintf ( stderr , "Streaming<S2SV_blank>Cache<S2SV_blank>is<S2SV_blank>running<S2SV_blank>-<S2SV_blank>please<S2SV_blank>stop<S2SV_blank>it<S2SV_blank>first\\n" ) ; continue ; } switch ( gf_term_get_option ( term , GF_OPT_MEDIA_CACHE ) ) { case GF_MEDIA_CACHE_ENABLED : fprintf ( stderr , "Streaming<S2SV_blank>Cache<S2SV_blank>Enabled\\n" ) ; break ; case GF_MEDIA_CACHE_DISABLED : fprintf ( stderr , "Streaming<S2SV_blank>Cache<S2SV_blank>Disabled\\n" ) ; break ; case GF_MEDIA_CACHE_RUNNING : fprintf ( stderr , "Streaming<S2SV_blank>Cache<S2SV_blank>Running\\n" ) ; break ; } break ; case 'S' : case 'A' : if ( gf_term_get_option ( term , GF_OPT_MEDIA_CACHE ) == GF_MEDIA_CACHE_RUNNING ) { gf_term_set_option ( term , GF_OPT_MEDIA_CACHE , ( c == 'S' ) ? GF_MEDIA_CACHE_DISABLED : GF_MEDIA_CACHE_DISCARD ) ; fprintf ( stderr , "Streaming<S2SV_blank>Cache<S2SV_blank>stopped\\n" ) ; } else { fprintf ( stderr , "Streaming<S2SV_blank>Cache<S2SV_blank>not<S2SV_blank>running\\n" ) ; } break ; case 'R' : display_rti = ! display_rti ; ResetCaption ( ) ; break ; case 'F' : if ( display_rti ) display_rti = 0 ; else display_rti = 2 ; ResetCaption ( ) ; break ; case 'u' : { GF_Err e ; char szCom [ 8192 ] ; fprintf ( stderr , "Enter<S2SV_blank>command<S2SV_blank>to<S2SV_blank>send:\\n" ) ; fflush ( stdin ) ; szCom [ 0 ] = 0 ; if ( 1 > scanf ( "%[^\\t\\n]" , szCom ) ) { fprintf ( stderr , "Cannot<S2SV_blank>read<S2SV_blank>command<S2SV_blank>to<S2SV_blank>send,<S2SV_blank>aborting.\\n" ) ; break ; } e = gf_term_scene_update ( term , NULL , szCom ) ; if ( e ) fprintf ( stderr , "Processing<S2SV_blank>command<S2SV_blank>failed:<S2SV_blank>%s\\n" , gf_error_to_string ( e ) ) ; } break ; case 'e' : { GF_Err e ; char jsCode [ 8192 ] ; fprintf ( stderr , "Enter<S2SV_blank>JavaScript<S2SV_blank>code<S2SV_blank>to<S2SV_blank>evaluate:\\n" ) ; fflush ( stdin ) ; jsCode [ 0 ] = 0 ; if ( 1 > scanf ( "%[^\\t\\n]" , jsCode ) ) { fprintf ( stderr , "Cannot<S2SV_blank>read<S2SV_blank>code<S2SV_blank>to<S2SV_blank>evaluate,<S2SV_blank>aborting.\\n" ) ; break ; } e = gf_term_scene_update ( term , "application/ecmascript" , jsCode ) ; if ( e ) fprintf ( stderr , "Processing<S2SV_blank>JS<S2SV_blank>code<S2SV_blank>failed:<S2SV_blank>%s\\n" , gf_error_to_string ( e ) ) ; } break ; case 'L' : { char szLog [ 1024 ] , * cur_logs ; cur_logs = gf_log_get_tools_levels ( ) ; fprintf ( stderr , "Enter<S2SV_blank>new<S2SV_blank>log<S2SV_blank>level<S2SV_blank>(current<S2SV_blank>tools<S2SV_blank>%s):\\n" , cur_logs ) ; gf_free ( cur_logs ) ; if ( scanf ( "%s" , szLog ) < 1 ) { fprintf ( stderr , "Cannot<S2SV_blank>read<S2SV_blank>new<S2SV_blank>log<S2SV_blank>level,<S2SV_blank>aborting.\\n" ) ; break ; } gf_log_modify_tools_levels ( szLog ) ; } break ; case 'g' : { GF_SystemRTInfo rti ; gf_sys_get_rti ( rti_update_time_ms , & rti , 0 ) ; fprintf ( stderr , "GPAC<S2SV_blank>allocated<S2SV_blank>memory<S2SV_blank>" LLD "\\n" , rti . gpac_memory ) ; } break ; case 'M' : { u32 size ; do { fprintf ( stderr , "Enter<S2SV_blank>new<S2SV_blank>video<S2SV_blank>cache<S2SV_blank>memory<S2SV_blank>in<S2SV_blank>kBytes<S2SV_blank>(current<S2SV_blank>%ud):\\n" , gf_term_get_option ( term , GF_OPT_VIDEO_CACHE_SIZE ) ) ; } while ( 1 > scanf ( "%ud" , & size ) ) ; gf_term_set_option ( term , GF_OPT_VIDEO_CACHE_SIZE , size ) ; } break ; case 'H' : { u32 http_bitrate = gf_term_get_option ( term , GF_OPT_HTTP_MAX_RATE ) ; do { fprintf ( stderr , "Enter<S2SV_blank>new<S2SV_blank>http<S2SV_blank>bitrate<S2SV_blank>in<S2SV_blank>bps<S2SV_blank>(0<S2SV_blank>for<S2SV_blank>none)<S2SV_blank>-<S2SV_blank>current<S2SV_blank>limit:<S2SV_blank>%d\\n" , http_bitrate ) ; } while ( 1 > scanf ( "%ud" , & http_bitrate ) ) ; gf_term_set_option ( term , GF_OPT_HTTP_MAX_RATE , http_bitrate ) ; } break ; case 'E' : gf_term_set_option ( term , GF_OPT_RELOAD_CONFIG , 1 ) ; break ; case 'B' : switch_bench ( ! bench_mode ) ; break ; case 'Y' : { char szOpt [ 8192 ] ; fprintf ( stderr , "Enter<S2SV_blank>option<S2SV_blank>to<S2SV_blank>set<S2SV_blank>(Section:Name=Value):\\n" ) ; fflush ( stdin ) ; szOpt [ 0 ] = 0 ; if ( 1 > scanf ( "%[^\\t\\n]" , szOpt ) ) { fprintf ( stderr , "Cannot<S2SV_blank>read<S2SV_blank>option\\n" ) ; break ; } set_cfg_option ( szOpt ) ; } break ; case 'Z' : { char szFileName [ 100 ] ; u32 nb_pass , nb_views , offscreen_view = 0 ; GF_VideoSurface fb ; GF_Err e ; nb_pass = 1 ; nb_views = gf_term_get_option ( term , GF_OPT_NUM_STEREO_VIEWS ) ; if ( nb_views > 1 ) { fprintf ( stderr , "Auto-stereo<S2SV_blank>mode<S2SV_blank>detected<S2SV_blank>-<S2SV_blank>type<S2SV_blank>number<S2SV_blank>of<S2SV_blank>view<S2SV_blank>to<S2SV_blank>dump<S2SV_blank>(0<S2SV_blank>is<S2SV_blank>main<S2SV_blank>output,<S2SV_blank>1<S2SV_blank>to<S2SV_blank>%d<S2SV_blank>offscreen<S2SV_blank>view,<S2SV_blank>%d<S2SV_blank>for<S2SV_blank>all<S2SV_blank>offscreen,<S2SV_blank>%d<S2SV_blank>for<S2SV_blank>all<S2SV_blank>offscreen<S2SV_blank>and<S2SV_blank>main)\\n" , nb_views , nb_views + 1 , nb_views + 2 ) ; if ( scanf ( "%d" , & offscreen_view ) != 1 ) { offscreen_view = 0 ; } if ( offscreen_view == nb_views + 1 ) { offscreen_view = 1 ; nb_pass = nb_views ; } else if ( offscreen_view == nb_views + 2 ) { offscreen_view = 0 ; nb_pass = nb_views + 1 ; } } while ( nb_pass ) { nb_pass -- ; if ( offscreen_view ) { sprintf ( szFileName , "view%d_dump.png" , offscreen_view ) ; e = gf_term_get_offscreen_buffer ( term , & fb , offscreen_view - 1 , 0 ) ; } else { sprintf ( szFileName , "gpac_video_dump_" LLU ".png" , gf_net_get_utc ( ) ) ; e = gf_term_get_screen_buffer ( term , & fb ) ; } offscreen_view ++ ; if ( e ) { fprintf ( stderr , "Error<S2SV_blank>dumping<S2SV_blank>screen<S2SV_blank>buffer<S2SV_blank>%s\\n" , gf_error_to_string ( e ) ) ; nb_pass = 0 ; } else { # ifndef GPAC_DISABLE_AV_PARSERS u32 dst_size = fb . width * fb . height * 4 ; char * dst = ( char * ) gf_malloc ( sizeof ( char ) * dst_size ) ; e = gf_img_png_enc ( fb . video_buffer , fb . width , fb . height , fb . pitch_y , fb . pixel_format , dst , & dst_size ) ; if ( e ) { fprintf ( stderr , "Error<S2SV_blank>encoding<S2SV_blank>PNG<S2SV_blank>%s\\n" , gf_error_to_string ( e ) ) ; nb_pass = 0 ; } else { FILE * png = gf_fopen ( szFileName , "wb" ) ; if ( ! png ) { fprintf ( stderr , "Error<S2SV_blank>writing<S2SV_blank>file<S2SV_blank>%s\\n" , szFileName ) ; nb_pass = 0 ; } else { gf_fwrite ( dst , dst_size , 1 , png ) ; gf_fclose ( png ) ; fprintf ( stderr , "Dump<S2SV_blank>to<S2SV_blank>%s\\n" , szFileName ) ; } } if ( dst ) gf_free ( dst ) ; gf_term_release_screen_buffer ( term , & fb ) ; # endif } } fprintf ( stderr , "Done:<S2SV_blank>%s\\n" , szFileName ) ; } break ; case 'G' : { GF_ObjectManager * root_od , * odm ; u32 index ; char szOpt [ 8192 ] ; fprintf ( stderr , "Enter<S2SV_blank>0-based<S2SV_blank>index<S2SV_blank>of<S2SV_blank>object<S2SV_blank>to<S2SV_blank>select<S2SV_blank>or<S2SV_blank>service<S2SV_blank>ID:\\n" ) ; fflush ( stdin ) ; szOpt [ 0 ] = 0 ; if ( 1 > scanf ( "%[^\\t\\n]" , szOpt ) ) { fprintf ( stderr , "Cannot<S2SV_blank>read<S2SV_blank>OD<S2SV_blank>ID\\n" ) ; break ; } index = atoi ( szOpt ) ; odm = NULL ; root_od = gf_term_get_root_object ( term ) ; if ( root_od ) { if ( gf_term_find_service ( term , root_od , index ) ) { gf_term_select_service ( term , root_od , index ) ; } else { fprintf ( stderr , "Cannot<S2SV_blank>find<S2SV_blank>service<S2SV_blank>%d<S2SV_blank>-<S2SV_blank>trying<S2SV_blank>with<S2SV_blank>object<S2SV_blank>index\\n" , index ) ; odm = gf_term_get_object ( term , root_od , index ) ; if ( odm ) { gf_term_select_object ( term , odm ) ; } else { fprintf ( stderr , "Cannot<S2SV_blank>find<S2SV_blank>object<S2SV_blank>at<S2SV_blank>index<S2SV_blank>%d\\n" , index ) ; } } } } break ; case 'h' : PrintHelp ( ) ; break ; default : break ; } } if ( bench_mode ) { PrintAVInfo ( GF_TRUE ) ; } if ( simulation_time_in_ms ) { gf_log_set_strict_error ( 0 ) ; } i = gf_sys_clock ( ) ; gf_term_disconnect ( term ) ; if ( rti_file ) UpdateRTInfo ( "Disconnected\\n" ) ; fprintf ( stderr , "Deleting<S2SV_blank>terminal...<S2SV_blank>" ) ; if ( playlist ) gf_fclose ( playlist ) ; # if defined ( __DARWIN__ ) || defined ( __APPLE__ ) carbon_uninit ( ) ; # endif gf_term_del ( term ) ; fprintf ( stderr , "done<S2SV_blank>(in<S2SV_blank>%d<S2SV_blank>ms)<S2SV_blank>-<S2SV_blank>ran<S2SV_blank>for<S2SV_blank>%d<S2SV_blank>ms\\n" , gf_sys_clock ( ) - i , gf_sys_clock ( ) ) ; fprintf ( stderr , "GPAC<S2SV_blank>cleanup<S2SV_blank>...\\n" ) ; gf_modules_del ( user . modules ) ; if ( no_cfg_save ) gf_cfg_discard_changes ( cfg_file ) ; gf_cfg_del ( cfg_file ) ; gf_sys_close ( ) ; if ( rti_logs ) gf_fclose ( rti_logs ) ; if ( logfile ) gf_fclose ( logfile ) ; if ( gui_mode ) { hide_shell ( 2 ) ; } # ifdef GPAC_MEMORY_TRACKING if ( mem_track && ( gf_memory_size ( ) || gf_file_handles_count ( ) ) ) { gf_log_set_tool_level ( GF_LOG_MEMORY , GF_LOG_INFO ) ; gf_memory_print ( ) ; return 2 ; } # endif return ret_val ; }
CWE-787 char * gf_text_get_utf8_line ( char * szLine , u32 lineSize , FILE * txt_in , s32 unicode_type ) { u32 i , j , len ; char * sOK ; char szLineConv [ 1024 ] ; unsigned short * sptr ; memset ( szLine , 0 , sizeof ( char ) * lineSize ) ; sOK = fgets ( szLine , lineSize , txt_in ) ; if ( ! sOK ) return NULL ; if ( unicode_type <= 1 ) { j = 0 ; len = ( u32 ) strlen ( szLine ) ; <S2SV_StartBug> for ( i = 0 ; i < len ; i ++ ) { <S2SV_EndBug> if ( ! unicode_type && ( szLine [ i ] & 0x80 ) ) { if ( ( szLine [ i + 1 ] & 0xc0 ) != 0x80 ) { <S2SV_StartBug> szLineConv [ j ] = 0xc0 | ( ( szLine [ i ] >> 6 ) & 0x3 ) ; <S2SV_EndBug> j ++ ; szLine [ i ] &= 0xbf ; } <S2SV_StartBug> else if ( ( szLine [ i ] & 0xe0 ) == 0xc0 ) { <S2SV_EndBug> <S2SV_StartBug> szLineConv [ j ] = szLine [ i ] ; <S2SV_EndBug> i ++ ; j ++ ; } else if ( ( szLine [ i ] & 0xf0 ) == 0xe0 ) { <S2SV_StartBug> szLineConv [ j ] = szLine [ i ] ; <S2SV_EndBug> i ++ ; j ++ ; szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; } else if ( ( szLine [ i ] & 0xf8 ) == 0xf0 ) { <S2SV_StartBug> szLineConv [ j ] = szLine [ i ] ; <S2SV_EndBug> i ++ ; j ++ ; szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; } else { i += 1 ; continue ; } } <S2SV_StartBug> szLineConv [ j ] = szLine [ i ] ; <S2SV_EndBug> j ++ ; } szLineConv [ j ] = 0 ; strcpy ( szLine , szLineConv ) ; return sOK ; } # ifdef GPAC_BIG_ENDIAN if ( unicode_type == 3 ) { # else if ( unicode_type == 2 ) { # endif i = 0 ; while ( 1 ) { char c ; if ( ! szLine [ i ] && ! szLine [ i + 1 ] ) break ; c = szLine [ i + 1 ] ; szLine [ i + 1 ] = szLine [ i ] ; szLine [ i ] = c ; i += 2 ; } } sptr = ( u16 * ) szLine ; i = ( u32 ) gf_utf8_wcstombs ( szLineConv , 1024 , ( const unsigned short * * ) & sptr ) ; if ( i >= ( u32 ) ARRAY_LENGTH ( szLineConv ) ) return NULL ; szLineConv [ i ] = 0 ; strcpy ( szLine , szLineConv ) ; if ( unicode_type == 3 ) fgetc ( txt_in ) ; return sOK ; }
CWE-119 GF_Err cat_multiple_files ( GF_ISOFile * dest , char * fileName , u32 import_flags , Double force_fps , u32 frames_per_sample , char * tmp_dir , Bool force_cat , Bool align_timelines , Bool allow_add_in_command ) { CATEnum cat_enum ; char * sep ; cat_enum . dest = dest ; cat_enum . import_flags = import_flags ; cat_enum . force_fps = force_fps ; cat_enum . frames_per_sample = frames_per_sample ; cat_enum . tmp_dir = tmp_dir ; cat_enum . force_cat = force_cat ; cat_enum . align_timelines = align_timelines ; cat_enum . allow_add_in_command = allow_add_in_command ; <S2SV_StartBug> strcpy ( cat_enum . szPath , fileName ) ; <S2SV_EndBug> sep = strrchr ( cat_enum . szPath , GF_PATH_SEPARATOR ) ; if ( ! sep ) sep = strrchr ( cat_enum . szPath , '/' ) ; if ( ! sep ) { strcpy ( cat_enum . szPath , "." ) ; <S2SV_StartBug> strcpy ( cat_enum . szRad1 , fileName ) ; <S2SV_EndBug> } else { <S2SV_StartBug> strcpy ( cat_enum . szRad1 , sep + 1 ) ; <S2SV_EndBug> sep [ 0 ] = 0 ; } <S2SV_StartBug> sep = strchr ( cat_enum . szRad1 , '*' ) ; <S2SV_EndBug> <S2SV_StartBug> strcpy ( cat_enum . szRad2 , sep + 1 ) ; <S2SV_EndBug> sep [ 0 ] = 0 ; <S2SV_StartBug> sep = strchr ( cat_enum . szRad2 , '%' ) ; <S2SV_EndBug> if ( ! sep ) sep = strchr ( cat_enum . szRad2 , '#' ) ; if ( ! sep ) sep = strchr ( cat_enum . szRad2 , ':' ) ; strcpy ( cat_enum . szOpt , "" ) ; <S2SV_StartBug> if ( sep ) { <S2SV_EndBug> strcpy ( cat_enum . szOpt , sep ) ; sep [ 0 ] = 0 ; } return gf_enum_directory ( cat_enum . szPath , 0 , cat_enumerate , & cat_enum , NULL ) ; }
CWE-119 Bool GPAC_EventProc ( void * ptr , GF_Event * evt ) { if ( ! term ) return 0 ; if ( gui_mode == 1 ) { if ( evt -> type == GF_EVENT_QUIT ) { Run = 0 ; } else if ( evt -> type == GF_EVENT_KEYDOWN ) { switch ( evt -> key . key_code ) { case GF_KEY_C : if ( evt -> key . flags & ( GF_KEY_MOD_CTRL | GF_KEY_MOD_ALT ) ) { hide_shell ( shell_visible ? 1 : 0 ) ; if ( shell_visible ) gui_mode = 2 ; } break ; default : break ; } } return 0 ; } switch ( evt -> type ) { case GF_EVENT_DURATION : Duration = ( u64 ) ( 1000 * ( s64 ) evt -> duration . duration ) ; CanSeek = evt -> duration . can_seek ; break ; case GF_EVENT_MESSAGE : { const char * servName ; if ( ! evt -> message . service || ! strcmp ( evt -> message . service , the_url ) ) { servName = "" ; } else if ( ! strnicmp ( evt -> message . service , "data:" , 5 ) ) { servName = "(embedded<S2SV_blank>data)" ; } else { servName = evt -> message . service ; } if ( ! evt -> message . message ) return 0 ; if ( evt -> message . error ) { if ( ! is_connected ) last_error = evt -> message . error ; if ( evt -> message . error == GF_SCRIPT_INFO ) { GF_LOG ( GF_LOG_INFO , GF_LOG_CONSOLE , ( "%s\\n" , evt -> message . message ) ) ; } else { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONSOLE , ( "%s<S2SV_blank>%s:<S2SV_blank>%s\\n" , servName , evt -> message . message , gf_error_to_string ( evt -> message . error ) ) ) ; } } else if ( ! be_quiet ) GF_LOG ( GF_LOG_INFO , GF_LOG_CONSOLE , ( "%s<S2SV_blank>%s\\n" , servName , evt -> message . message ) ) ; } break ; case GF_EVENT_PROGRESS : { char * szTitle = "" ; if ( evt -> progress . progress_type == 0 ) { szTitle = "Buffer<S2SV_blank>" ; if ( bench_mode && ( bench_mode != 3 ) ) { if ( evt -> progress . done >= evt -> progress . total ) bench_buffer = 0 ; else bench_buffer = 1 + 100 * evt -> progress . done / evt -> progress . total ; break ; } } else if ( evt -> progress . progress_type == 1 ) { if ( bench_mode ) break ; szTitle = "Download<S2SV_blank>" ; } else if ( evt -> progress . progress_type == 2 ) szTitle = "Import<S2SV_blank>" ; gf_set_progress ( szTitle , evt -> progress . done , evt -> progress . total ) ; } break ; case GF_EVENT_DBLCLICK : gf_term_set_option ( term , GF_OPT_FULLSCREEN , ! gf_term_get_option ( term , GF_OPT_FULLSCREEN ) ) ; return 0 ; case GF_EVENT_MOUSEDOWN : if ( evt -> mouse . button == GF_MOUSE_RIGHT ) { right_down = 1 ; last_x = evt -> mouse . x ; last_y = evt -> mouse . y ; } return 0 ; case GF_EVENT_MOUSEUP : if ( evt -> mouse . button == GF_MOUSE_RIGHT ) { right_down = 0 ; last_x = evt -> mouse . x ; last_y = evt -> mouse . y ; } return 0 ; case GF_EVENT_MOUSEMOVE : if ( right_down && ( user . init_flags & GF_TERM_WINDOWLESS ) ) { GF_Event move ; move . move . x = evt -> mouse . x - last_x ; move . move . y = last_y - evt -> mouse . y ; move . type = GF_EVENT_MOVE ; move . move . relative = 1 ; gf_term_user_event ( term , & move ) ; } return 0 ; case GF_EVENT_KEYUP : switch ( evt -> key . key_code ) { case GF_KEY_SPACE : if ( evt -> key . flags & GF_KEY_MOD_CTRL ) switch_bench ( ! bench_mode ) ; break ; } break ; case GF_EVENT_KEYDOWN : gf_term_process_shortcut ( term , evt ) ; switch ( evt -> key . key_code ) { case GF_KEY_SPACE : if ( evt -> key . flags & GF_KEY_MOD_CTRL ) { if ( ! bench_mode ) switch_bench ( ! bench_mode ) ; } break ; case GF_KEY_PAGEDOWN : case GF_KEY_MEDIANEXTTRACK : request_next_playlist_item = 1 ; break ; case GF_KEY_MEDIAPREVIOUSTRACK : break ; case GF_KEY_ESCAPE : gf_term_set_option ( term , GF_OPT_FULLSCREEN , ! gf_term_get_option ( term , GF_OPT_FULLSCREEN ) ) ; break ; case GF_KEY_C : if ( evt -> key . flags & ( GF_KEY_MOD_CTRL | GF_KEY_MOD_ALT ) ) { hide_shell ( shell_visible ? 1 : 0 ) ; if ( ! shell_visible ) gui_mode = 1 ; } break ; case GF_KEY_F : if ( evt -> key . flags & GF_KEY_MOD_CTRL ) fprintf ( stderr , "Rendering<S2SV_blank>rate:<S2SV_blank>%f<S2SV_blank>FPS\\n" , gf_term_get_framerate ( term , 0 ) ) ; break ; case GF_KEY_T : if ( evt -> key . flags & GF_KEY_MOD_CTRL ) fprintf ( stderr , "Scene<S2SV_blank>Time:<S2SV_blank>%f<S2SV_blank>\\n" , gf_term_get_time_in_ms ( term ) / 1000.0 ) ; break ; case GF_KEY_D : if ( evt -> key . flags & GF_KEY_MOD_CTRL ) gf_term_set_option ( term , GF_OPT_DRAW_MODE , ( gf_term_get_option ( term , GF_OPT_DRAW_MODE ) == GF_DRAW_MODE_DEFER ) ? GF_DRAW_MODE_IMMEDIATE : GF_DRAW_MODE_DEFER ) ; break ; case GF_KEY_4 : if ( evt -> key . flags & GF_KEY_MOD_CTRL ) gf_term_set_option ( term , GF_OPT_ASPECT_RATIO , GF_ASPECT_RATIO_4_3 ) ; break ; case GF_KEY_5 : if ( evt -> key . flags & GF_KEY_MOD_CTRL ) gf_term_set_option ( term , GF_OPT_ASPECT_RATIO , GF_ASPECT_RATIO_16_9 ) ; break ; case GF_KEY_6 : if ( evt -> key . flags & GF_KEY_MOD_CTRL ) gf_term_set_option ( term , GF_OPT_ASPECT_RATIO , GF_ASPECT_RATIO_FILL_SCREEN ) ; break ; case GF_KEY_7 : if ( evt -> key . flags & GF_KEY_MOD_CTRL ) gf_term_set_option ( term , GF_OPT_ASPECT_RATIO , GF_ASPECT_RATIO_KEEP ) ; break ; case GF_KEY_O : if ( ( evt -> key . flags & GF_KEY_MOD_CTRL ) && is_connected ) { if ( gf_term_get_option ( term , GF_OPT_MAIN_ADDON ) ) { fprintf ( stderr , "Resuming<S2SV_blank>to<S2SV_blank>main<S2SV_blank>content\\n" ) ; gf_term_set_option ( term , GF_OPT_PLAY_STATE , GF_STATE_PLAY_LIVE ) ; } else { fprintf ( stderr , "Main<S2SV_blank>addon<S2SV_blank>not<S2SV_blank>enabled\\n" ) ; } } break ; case GF_KEY_P : if ( ( evt -> key . flags & GF_KEY_MOD_CTRL ) && is_connected ) { u32 pause_state = gf_term_get_option ( term , GF_OPT_PLAY_STATE ) ; fprintf ( stderr , "[Status:<S2SV_blank>%s]\\n" , pause_state ? "Playing" : "Paused" ) ; if ( ( pause_state == GF_STATE_PAUSED ) && ( evt -> key . flags & GF_KEY_MOD_SHIFT ) ) { gf_term_set_option ( term , GF_OPT_PLAY_STATE , GF_STATE_PLAY_LIVE ) ; } else { gf_term_set_option ( term , GF_OPT_PLAY_STATE , ( pause_state == GF_STATE_PAUSED ) ? GF_STATE_PLAYING : GF_STATE_PAUSED ) ; } } break ; case GF_KEY_S : if ( ( evt -> key . flags & GF_KEY_MOD_CTRL ) && is_connected ) { gf_term_set_option ( term , GF_OPT_PLAY_STATE , GF_STATE_STEP_PAUSE ) ; fprintf ( stderr , "Step<S2SV_blank>time:<S2SV_blank>" ) ; PrintTime ( gf_term_get_time_in_ms ( term ) ) ; fprintf ( stderr , "\\n" ) ; } break ; case GF_KEY_B : if ( ( evt -> key . flags & GF_KEY_MOD_CTRL ) && is_connected ) ViewODs ( term , 1 ) ; break ; case GF_KEY_M : if ( ( evt -> key . flags & GF_KEY_MOD_CTRL ) && is_connected ) ViewODs ( term , 0 ) ; break ; case GF_KEY_H : if ( ( evt -> key . flags & GF_KEY_MOD_CTRL ) && is_connected ) { gf_term_switch_quality ( term , 1 ) ; } break ; case GF_KEY_L : if ( ( evt -> key . flags & GF_KEY_MOD_CTRL ) && is_connected ) { gf_term_switch_quality ( term , 0 ) ; } break ; case GF_KEY_F5 : if ( is_connected ) reload = 1 ; break ; case GF_KEY_A : addon_visible = ! addon_visible ; gf_term_toggle_addons ( term , addon_visible ) ; break ; case GF_KEY_UP : if ( ( evt -> key . flags & VK_MOD ) && is_connected ) { do_set_speed ( playback_speed * 2 ) ; } break ; case GF_KEY_DOWN : if ( ( evt -> key . flags & VK_MOD ) && is_connected ) { do_set_speed ( playback_speed / 2 ) ; } break ; case GF_KEY_LEFT : if ( ( evt -> key . flags & VK_MOD ) && is_connected ) { do_set_speed ( - 1 * playback_speed ) ; } break ; } break ; case GF_EVENT_CONNECT : if ( evt -> connect . is_connected ) { is_connected = 1 ; fprintf ( stderr , "Service<S2SV_blank>Connected\\n" ) ; eos_seen = GF_FALSE ; if ( playback_speed != FIX_ONE ) gf_term_set_speed ( term , playback_speed ) ; } else if ( is_connected ) { fprintf ( stderr , "Service<S2SV_blank>%s\\n" , is_connected ? "Disconnected" : "Connection<S2SV_blank>Failed" ) ; is_connected = 0 ; Duration = 0 ; } if ( init_w && init_h ) { gf_term_set_size ( term , init_w , init_h ) ; } ResetCaption ( ) ; break ; case GF_EVENT_EOS : eos_seen = GF_TRUE ; if ( playlist ) { if ( Duration > 1500 ) request_next_playlist_item = GF_TRUE ; } else if ( loop_at_end ) { restart = 1 ; } break ; case GF_EVENT_SIZE : if ( user . init_flags & GF_TERM_WINDOWLESS ) { GF_Event move ; move . type = GF_EVENT_MOVE ; move . move . align_x = align_mode & 0xFF ; move . move . align_y = ( align_mode >> 8 ) & 0xFF ; move . move . relative = 2 ; gf_term_user_event ( term , & move ) ; } break ; case GF_EVENT_SCENE_SIZE : if ( forced_width && forced_height ) { GF_Event size ; size . type = GF_EVENT_SIZE ; size . size . width = forced_width ; size . size . height = forced_height ; gf_term_user_event ( term , & size ) ; } break ; case GF_EVENT_METADATA : ResetCaption ( ) ; break ; case GF_EVENT_RELOAD : if ( is_connected ) reload = 1 ; break ; case GF_EVENT_DROPFILE : { u32 i , pos ; if ( readonly_playlist ) { gf_fclose ( playlist ) ; playlist = NULL ; } readonly_playlist = 0 ; if ( ! playlist ) { readonly_playlist = 0 ; playlist = gf_temp_file_new ( NULL ) ; } pos = ftell ( playlist ) ; i = 0 ; while ( i < evt -> open_file . nb_files ) { if ( evt -> open_file . files [ i ] != NULL ) { fprintf ( playlist , "%s\\n" , evt -> open_file . files [ i ] ) ; } i ++ ; } fseek ( playlist , pos , SEEK_SET ) ; request_next_playlist_item = 1 ; } return 1 ; case GF_EVENT_QUIT : if ( evt -> message . error ) { fprintf ( stderr , "A<S2SV_blank>fatal<S2SV_blank>error<S2SV_blank>was<S2SV_blank>encoutered:<S2SV_blank>%s<S2SV_blank>(%s)<S2SV_blank>-<S2SV_blank>exiting<S2SV_blank>...\\n" , evt -> message . message ? evt -> message . message : "no<S2SV_blank>details" , gf_error_to_string ( evt -> message . error ) ) ; } Run = 0 ; break ; case GF_EVENT_DISCONNECT : gf_term_disconnect ( term ) ; break ; case GF_EVENT_MIGRATE : { } break ; case GF_EVENT_NAVIGATE_INFO : if ( evt -> navigate . to_url ) fprintf ( stderr , "Go<S2SV_blank>to<S2SV_blank>URL:<S2SV_blank>\\"%s\\"\\r" , evt -> navigate . to_url ) ; break ; case GF_EVENT_NAVIGATE : if ( gf_term_is_supported_url ( term , evt -> navigate . to_url , 1 , no_mime_check ) ) { <S2SV_StartBug> strcpy ( the_url , evt -> navigate . to_url ) ; <S2SV_EndBug> fprintf ( stderr , "Navigating<S2SV_blank>to<S2SV_blank>URL<S2SV_blank>%s\\n" , the_url ) ; gf_term_navigate_to ( term , evt -> navigate . to_url ) ; return 1 ; } else { fprintf ( stderr , "Navigation<S2SV_blank>destination<S2SV_blank>not<S2SV_blank>supported\\nGo<S2SV_blank>to<S2SV_blank>URL:<S2SV_blank>%s\\n" , evt -> navigate . to_url ) ; } break ; case GF_EVENT_SET_CAPTION : gf_term_user_event ( term , evt ) ; break ; case GF_EVENT_AUTHORIZATION : { int maxTries = 1 ; assert ( evt -> type == GF_EVENT_AUTHORIZATION ) ; assert ( evt -> auth . user ) ; assert ( evt -> auth . password ) ; assert ( evt -> auth . site_url ) ; while ( ( ! strlen ( evt -> auth . user ) || ! strlen ( evt -> auth . password ) ) && ( maxTries -- ) >= 0 ) { fprintf ( stderr , "****<S2SV_blank>Authorization<S2SV_blank>required<S2SV_blank>for<S2SV_blank>site<S2SV_blank>%s<S2SV_blank>****\\n" , evt -> auth . site_url ) ; fprintf ( stderr , "login<S2SV_blank><S2SV_blank><S2SV_blank>:<S2SV_blank>" ) ; read_line_input ( evt -> auth . user , 50 , 1 ) ; fprintf ( stderr , "\\npassword:<S2SV_blank>" ) ; read_line_input ( evt -> auth . password , 50 , 0 ) ; fprintf ( stderr , "*********\\n" ) ; } if ( maxTries < 0 ) { fprintf ( stderr , "****<S2SV_blank>No<S2SV_blank>User<S2SV_blank>or<S2SV_blank>password<S2SV_blank>has<S2SV_blank>been<S2SV_blank>filled,<S2SV_blank>aborting<S2SV_blank>***\\n" ) ; return 0 ; } return 1 ; } case GF_EVENT_ADDON_DETECTED : if ( enable_add_ons ) { fprintf ( stderr , "Media<S2SV_blank>Addon<S2SV_blank>%s<S2SV_blank>detected<S2SV_blank>-<S2SV_blank>enabling<S2SV_blank>it\\n" , evt -> addon_connect . addon_url ) ; addon_visible = 1 ; } return enable_add_ons ; } return 0 ; }
CWE-119 int mp4client_main ( int argc , char * * argv ) { char c ; const char * str ; int ret_val = 0 ; u32 i , times [ 100 ] , nb_times , dump_mode ; u32 simulation_time_in_ms = 0 ; u32 initial_service_id = 0 ; Bool auto_exit = GF_FALSE ; Bool logs_set = GF_FALSE ; Bool start_fs = GF_FALSE ; Bool use_rtix = GF_FALSE ; Bool pause_at_first = GF_FALSE ; Bool no_cfg_save = GF_FALSE ; Bool is_cfg_only = GF_FALSE ; Double play_from = 0 ; # ifdef GPAC_MEMORY_TRACKING GF_MemTrackerType mem_track = GF_MemTrackerNone ; # endif Double fps = GF_IMPORT_DEFAULT_FPS ; Bool fill_ar , visible , do_uncache , has_command ; char * url_arg , * out_arg , * the_cfg , * rti_file , * views , * mosaic ; FILE * logfile = NULL ; Float scale = 1 ; # ifndef WIN32 dlopen ( NULL , RTLD_NOW | RTLD_GLOBAL ) ; # endif strcpy ( the_url , "." ) ; memset ( & user , 0 , sizeof ( GF_User ) ) ; dump_mode = DUMP_NONE ; fill_ar = visible = do_uncache = has_command = GF_FALSE ; url_arg = out_arg = the_cfg = rti_file = views = mosaic = NULL ; nb_times = 0 ; times [ 0 ] = 0 ; for ( i = 1 ; i < ( u32 ) argc ; i ++ ) { char * arg = argv [ i ] ; if ( ! strcmp ( arg , "-c" ) || ! strcmp ( arg , "-cfg" ) ) { the_cfg = argv [ i + 1 ] ; i ++ ; } else if ( ! strcmp ( arg , "-mem-track" ) || ! strcmp ( arg , "-mem-track-stack" ) ) { # ifdef GPAC_MEMORY_TRACKING mem_track = ! strcmp ( arg , "-mem-track-stack" ) ? GF_MemTrackerBackTrace : GF_MemTrackerSimple ; # else fprintf ( stderr , "WARNING<S2SV_blank>-<S2SV_blank>GPAC<S2SV_blank>not<S2SV_blank>compiled<S2SV_blank>with<S2SV_blank>Memory<S2SV_blank>Tracker<S2SV_blank>-<S2SV_blank>ignoring<S2SV_blank>\\"%s\\"\\n" , arg ) ; # endif } else if ( ! strcmp ( arg , "-gui" ) ) { gui_mode = 1 ; } else if ( ! strcmp ( arg , "-guid" ) ) { gui_mode = 2 ; } else if ( ! strcmp ( arg , "-h" ) || ! strcmp ( arg , "-help" ) ) { PrintUsage ( ) ; return 0 ; } } # ifdef GPAC_MEMORY_TRACKING gf_sys_init ( mem_track ) ; # else gf_sys_init ( GF_MemTrackerNone ) ; # endif gf_sys_set_args ( argc , ( const char * * ) argv ) ; cfg_file = gf_cfg_init ( the_cfg , NULL ) ; if ( ! cfg_file ) { fprintf ( stderr , "Error:<S2SV_blank>Configuration<S2SV_blank>File<S2SV_blank>not<S2SV_blank>found\\n" ) ; return 1 ; } if ( gf_log_set_tools_levels ( gf_cfg_get_key ( cfg_file , "General" , "Logs" ) ) != GF_OK ) { return 1 ; } if ( gf_cfg_get_key ( cfg_file , "General" , "Logs" ) != NULL ) { logs_set = GF_TRUE ; } if ( ! gui_mode ) { str = gf_cfg_get_key ( cfg_file , "General" , "ForceGUI" ) ; if ( str && ! strcmp ( str , "yes" ) ) gui_mode = 1 ; } for ( i = 1 ; i < ( u32 ) argc ; i ++ ) { char * arg = argv [ i ] ; if ( ! strcmp ( arg , "-rti" ) ) { rti_file = argv [ i + 1 ] ; i ++ ; } else if ( ! strcmp ( arg , "-rtix" ) ) { rti_file = argv [ i + 1 ] ; i ++ ; use_rtix = GF_TRUE ; } else if ( ! stricmp ( arg , "-size" ) ) { if ( sscanf ( argv [ i + 1 ] , "%dx%d" , & forced_width , & forced_height ) != 2 ) { forced_width = forced_height = 0 ; } i ++ ; } else if ( ! strcmp ( arg , "-quiet" ) ) { be_quiet = 1 ; } else if ( ! strcmp ( arg , "-strict-error" ) ) { gf_log_set_strict_error ( 1 ) ; } else if ( ! strcmp ( arg , "-log-file" ) || ! strcmp ( arg , "-lf" ) ) { logfile = gf_fopen ( argv [ i + 1 ] , "wt" ) ; gf_log_set_callback ( logfile , on_gpac_log ) ; i ++ ; } else if ( ! strcmp ( arg , "-logs" ) ) { if ( gf_log_set_tools_levels ( argv [ i + 1 ] ) != GF_OK ) { return 1 ; } logs_set = GF_TRUE ; i ++ ; } else if ( ! strcmp ( arg , "-log-clock" ) || ! strcmp ( arg , "-lc" ) ) { log_time_start = 1 ; } else if ( ! strcmp ( arg , "-log-utc" ) || ! strcmp ( arg , "-lu" ) ) { log_utc_time = 1 ; } # if defined ( __DARWIN__ ) || defined ( __APPLE__ ) else if ( ! strcmp ( arg , "-thread" ) ) threading_flags = 0 ; # else else if ( ! strcmp ( arg , "-no-thread" ) ) threading_flags = GF_TERM_NO_DECODER_THREAD | GF_TERM_NO_COMPOSITOR_THREAD | GF_TERM_WINDOW_NO_THREAD ; # endif else if ( ! strcmp ( arg , "-no-cthread" ) || ! strcmp ( arg , "-no-compositor-thread" ) ) threading_flags |= GF_TERM_NO_COMPOSITOR_THREAD ; else if ( ! strcmp ( arg , "-no-audio" ) ) no_audio = 1 ; else if ( ! strcmp ( arg , "-no-regulation" ) ) no_regulation = 1 ; else if ( ! strcmp ( arg , "-fs" ) ) start_fs = 1 ; else if ( ! strcmp ( arg , "-opt" ) ) { set_cfg_option ( argv [ i + 1 ] ) ; i ++ ; } else if ( ! strcmp ( arg , "-conf" ) ) { set_cfg_option ( argv [ i + 1 ] ) ; is_cfg_only = GF_TRUE ; i ++ ; } else if ( ! strcmp ( arg , "-ifce" ) ) { gf_cfg_set_key ( cfg_file , "Network" , "DefaultMCastInterface" , argv [ i + 1 ] ) ; i ++ ; } else if ( ! stricmp ( arg , "-help" ) ) { PrintUsage ( ) ; return 1 ; } else if ( ! stricmp ( arg , "-noprog" ) ) { no_prog = 1 ; gf_set_progress_callback ( NULL , progress_quiet ) ; } else if ( ! stricmp ( arg , "-no-save" ) || ! stricmp ( arg , "--no-save" ) ) { no_cfg_save = 1 ; } else if ( ! stricmp ( arg , "-ntp-shift" ) ) { s32 shift = atoi ( argv [ i + 1 ] ) ; i ++ ; gf_net_set_ntp_shift ( shift ) ; } else if ( ! stricmp ( arg , "-run-for" ) ) { simulation_time_in_ms = atoi ( argv [ i + 1 ] ) * 1000 ; if ( ! simulation_time_in_ms ) simulation_time_in_ms = 1 ; i ++ ; } else if ( ! strcmp ( arg , "-out" ) ) { out_arg = argv [ i + 1 ] ; i ++ ; } else if ( ! stricmp ( arg , "-fps" ) ) { fps = atof ( argv [ i + 1 ] ) ; i ++ ; } else if ( ! strcmp ( arg , "-avi" ) || ! strcmp ( arg , "-sha" ) ) { dump_mode &= 0xFFFF0000 ; if ( ! strcmp ( arg , "-sha" ) ) dump_mode |= DUMP_SHA1 ; else dump_mode |= DUMP_AVI ; if ( ( url_arg || ( i + 2 < ( u32 ) argc ) ) && get_time_list ( argv [ i + 1 ] , times , & nb_times ) ) { if ( ! strcmp ( arg , "-avi" ) && ( nb_times != 2 ) ) { fprintf ( stderr , "Only<S2SV_blank>one<S2SV_blank>time<S2SV_blank>arg<S2SV_blank>found<S2SV_blank>for<S2SV_blank>-avi<S2SV_blank>-<S2SV_blank>check<S2SV_blank>usage\\n" ) ; return 1 ; } i ++ ; } } else if ( ! strcmp ( arg , "-rgbds" ) ) { dump_mode |= DUMP_RGB_DEPTH_SHAPE ; } else if ( ! strcmp ( arg , "-rgbd" ) ) { dump_mode |= DUMP_RGB_DEPTH ; } else if ( ! strcmp ( arg , "-depth" ) ) { dump_mode |= DUMP_DEPTH_ONLY ; } else if ( ! strcmp ( arg , "-bmp" ) ) { dump_mode &= 0xFFFF0000 ; dump_mode |= DUMP_BMP ; if ( ( url_arg || ( i + 2 < ( u32 ) argc ) ) && get_time_list ( argv [ i + 1 ] , times , & nb_times ) ) i ++ ; } else if ( ! strcmp ( arg , "-png" ) ) { dump_mode &= 0xFFFF0000 ; dump_mode |= DUMP_PNG ; if ( ( url_arg || ( i + 2 < ( u32 ) argc ) ) && get_time_list ( argv [ i + 1 ] , times , & nb_times ) ) i ++ ; } else if ( ! strcmp ( arg , "-raw" ) ) { dump_mode &= 0xFFFF0000 ; dump_mode |= DUMP_RAW ; if ( ( url_arg || ( i + 2 < ( u32 ) argc ) ) && get_time_list ( argv [ i + 1 ] , times , & nb_times ) ) i ++ ; } else if ( ! stricmp ( arg , "-scale" ) ) { sscanf ( argv [ i + 1 ] , "%f" , & scale ) ; i ++ ; } else if ( ! strcmp ( arg , "-c" ) || ! strcmp ( arg , "-cfg" ) ) { i ++ ; } if ( ! gui_mode ) { if ( arg [ 0 ] != '-' ) { if ( url_arg ) { fprintf ( stderr , "Several<S2SV_blank>input<S2SV_blank>URLs<S2SV_blank>provided<S2SV_blank>(\\"%s\\",<S2SV_blank>\\"%s\\").<S2SV_blank>Check<S2SV_blank>your<S2SV_blank>command-line.\\n" , url_arg , arg ) ; return 1 ; } url_arg = arg ; } else if ( ! strcmp ( arg , "-loop" ) ) loop_at_end = 1 ; else if ( ! strcmp ( arg , "-bench" ) ) bench_mode = 1 ; else if ( ! strcmp ( arg , "-vbench" ) ) bench_mode = 2 ; else if ( ! strcmp ( arg , "-sbench" ) ) bench_mode = 3 ; else if ( ! strcmp ( arg , "-no-addon" ) ) enable_add_ons = GF_FALSE ; else if ( ! strcmp ( arg , "-pause" ) ) pause_at_first = 1 ; else if ( ! strcmp ( arg , "-play-from" ) ) { play_from = atof ( ( const char * ) argv [ i + 1 ] ) ; i ++ ; } else if ( ! strcmp ( arg , "-speed" ) ) { playback_speed = FLT2FIX ( atof ( ( const char * ) argv [ i + 1 ] ) ) ; if ( playback_speed <= 0 ) playback_speed = FIX_ONE ; i ++ ; } else if ( ! strcmp ( arg , "-no-wnd" ) ) user . init_flags |= GF_TERM_WINDOWLESS ; else if ( ! strcmp ( arg , "-no-back" ) ) user . init_flags |= GF_TERM_WINDOW_TRANSPARENT ; else if ( ! strcmp ( arg , "-align" ) ) { if ( argv [ i + 1 ] [ 0 ] == 'm' ) align_mode = 1 ; else if ( argv [ i + 1 ] [ 0 ] == 'b' ) align_mode = 2 ; align_mode <<= 8 ; if ( argv [ i + 1 ] [ 1 ] == 'm' ) align_mode |= 1 ; else if ( argv [ i + 1 ] [ 1 ] == 'r' ) align_mode |= 2 ; i ++ ; } else if ( ! strcmp ( arg , "-fill" ) ) { fill_ar = GF_TRUE ; } else if ( ! strcmp ( arg , "-show" ) ) { visible = 1 ; } else if ( ! strcmp ( arg , "-uncache" ) ) { do_uncache = GF_TRUE ; } else if ( ! strcmp ( arg , "-exit" ) ) auto_exit = GF_TRUE ; else if ( ! stricmp ( arg , "-views" ) ) { views = argv [ i + 1 ] ; i ++ ; } else if ( ! stricmp ( arg , "-mosaic" ) ) { mosaic = argv [ i + 1 ] ; i ++ ; } else if ( ! stricmp ( arg , "-com" ) ) { has_command = GF_TRUE ; i ++ ; } else if ( ! stricmp ( arg , "-service" ) ) { initial_service_id = atoi ( argv [ i + 1 ] ) ; i ++ ; } } } if ( is_cfg_only ) { gf_cfg_del ( cfg_file ) ; fprintf ( stderr , "GPAC<S2SV_blank>Config<S2SV_blank>updated\\n" ) ; return 0 ; } if ( do_uncache ) { const char * cache_dir = gf_cfg_get_key ( cfg_file , "General" , "CacheDirectory" ) ; do_flatten_cache ( cache_dir ) ; fprintf ( stderr , "GPAC<S2SV_blank>Cache<S2SV_blank>dir<S2SV_blank>%s<S2SV_blank>flattened\\n" , cache_dir ) ; gf_cfg_del ( cfg_file ) ; return 0 ; } if ( dump_mode && ! url_arg ) { FILE * test ; url_arg = ( char * ) gf_cfg_get_key ( cfg_file , "General" , "StartupFile" ) ; test = url_arg ? gf_fopen ( url_arg , "rt" ) : NULL ; if ( ! test ) url_arg = NULL ; else gf_fclose ( test ) ; if ( ! url_arg ) { fprintf ( stderr , "Missing<S2SV_blank>argument<S2SV_blank>for<S2SV_blank>dump\\n" ) ; PrintUsage ( ) ; if ( logfile ) gf_fclose ( logfile ) ; return 1 ; } } if ( ! gui_mode && ! url_arg && ( gf_cfg_get_key ( cfg_file , "General" , "StartupFile" ) != NULL ) ) { gui_mode = 1 ; } # ifdef WIN32 if ( gui_mode == 1 ) { const char * opt ; TCHAR buffer [ 1024 ] ; DWORD res = GetCurrentDirectory ( 1024 , buffer ) ; buffer [ res ] = 0 ; opt = gf_cfg_get_key ( cfg_file , "General" , "ModulesDirectory" ) ; if ( strstr ( opt , buffer ) ) { gui_mode = 1 ; } else { gui_mode = 2 ; } } # endif if ( gui_mode == 1 ) { hide_shell ( 1 ) ; } if ( gui_mode ) { no_prog = 1 ; gf_set_progress_callback ( NULL , progress_quiet ) ; } if ( ! url_arg && simulation_time_in_ms ) simulation_time_in_ms += gf_sys_clock ( ) ; # if defined ( __DARWIN__ ) || defined ( __APPLE__ ) carbon_init ( ) ; # endif if ( dump_mode ) rti_file = NULL ; if ( ! logs_set ) { gf_log_set_tool_level ( GF_LOG_ALL , GF_LOG_WARNING ) ; } if ( rti_file || logfile || log_utc_time || log_time_start ) gf_log_set_callback ( NULL , on_gpac_log ) ; if ( rti_file ) init_rti_logs ( rti_file , url_arg , use_rtix ) ; { GF_SystemRTInfo rti ; if ( gf_sys_get_rti ( 0 , & rti , 0 ) ) fprintf ( stderr , "System<S2SV_blank>info:<S2SV_blank>%d<S2SV_blank>MB<S2SV_blank>RAM<S2SV_blank>-<S2SV_blank>%d<S2SV_blank>cores\\n" , ( u32 ) ( rti . physical_memory / 1024 / 1024 ) , rti . nb_cores ) ; } if ( dump_mode ) { user . init_flags |= GF_TERM_NO_DECODER_THREAD | GF_TERM_NO_COMPOSITOR_THREAD | GF_TERM_NO_REGULATION ; if ( ! visible ) user . init_flags |= GF_TERM_INIT_HIDE ; gf_cfg_set_key ( cfg_file , "Audio" , "DriverName" , "Raw<S2SV_blank>Audio<S2SV_blank>Output" ) ; no_cfg_save = GF_TRUE ; } else { init_w = forced_width ; init_h = forced_height ; } user . modules = gf_modules_new ( NULL , cfg_file ) ; if ( user . modules ) i = gf_modules_get_count ( user . modules ) ; if ( ! i || ! user . modules ) { fprintf ( stderr , "Error:<S2SV_blank>no<S2SV_blank>modules<S2SV_blank>found<S2SV_blank>-<S2SV_blank>exiting\\n" ) ; if ( user . modules ) gf_modules_del ( user . modules ) ; gf_cfg_del ( cfg_file ) ; gf_sys_close ( ) ; if ( logfile ) gf_fclose ( logfile ) ; return 1 ; } fprintf ( stderr , "Modules<S2SV_blank>Found<S2SV_blank>:<S2SV_blank>%d<S2SV_blank>\\n" , i ) ; str = gf_cfg_get_key ( cfg_file , "General" , "GPACVersion" ) ; if ( ! str || strcmp ( str , GPAC_FULL_VERSION ) ) { gf_cfg_del_section ( cfg_file , "PluginsCache" ) ; gf_cfg_set_key ( cfg_file , "General" , "GPACVersion" , GPAC_FULL_VERSION ) ; } user . config = cfg_file ; user . EventProc = GPAC_EventProc ; user . opaque = user . modules ; if ( threading_flags ) user . init_flags |= threading_flags ; if ( no_audio ) user . init_flags |= GF_TERM_NO_AUDIO ; if ( no_regulation ) user . init_flags |= GF_TERM_NO_REGULATION ; if ( threading_flags & ( GF_TERM_NO_DECODER_THREAD | GF_TERM_NO_COMPOSITOR_THREAD ) ) term_step = GF_TRUE ; if ( dump_mode ) user . init_flags |= GF_TERM_USE_AUDIO_HW_CLOCK ; if ( bench_mode ) { gf_cfg_discard_changes ( user . config ) ; auto_exit = GF_TRUE ; gf_cfg_set_key ( user . config , "Audio" , "DriverName" , "Raw<S2SV_blank>Audio<S2SV_blank>Output" ) ; if ( bench_mode != 2 ) { gf_cfg_set_key ( user . config , "Video" , "DriverName" , "Raw<S2SV_blank>Video<S2SV_blank>Output" ) ; gf_cfg_set_key ( user . config , "RAWVideo" , "RawOutput" , "null" ) ; gf_cfg_set_key ( user . config , "Compositor" , "OpenGLMode" , "disable" ) ; } else { gf_cfg_set_key ( user . config , "Video" , "DisableVSync" , "yes" ) ; } } { char dim [ 50 ] ; sprintf ( dim , "%d" , forced_width ) ; gf_cfg_set_key ( user . config , "Compositor" , "DefaultWidth" , forced_width ? dim : NULL ) ; sprintf ( dim , "%d" , forced_height ) ; gf_cfg_set_key ( user . config , "Compositor" , "DefaultHeight" , forced_height ? dim : NULL ) ; } fprintf ( stderr , "Loading<S2SV_blank>GPAC<S2SV_blank>Terminal\\n" ) ; i = gf_sys_clock ( ) ; term = gf_term_new ( & user ) ; if ( ! term ) { fprintf ( stderr , "\\nInit<S2SV_blank>error<S2SV_blank>-<S2SV_blank>check<S2SV_blank>you<S2SV_blank>have<S2SV_blank>at<S2SV_blank>least<S2SV_blank>one<S2SV_blank>video<S2SV_blank>out<S2SV_blank>and<S2SV_blank>one<S2SV_blank>rasterizer...\\nFound<S2SV_blank>modules:\\n" ) ; list_modules ( user . modules ) ; gf_modules_del ( user . modules ) ; gf_cfg_discard_changes ( cfg_file ) ; gf_cfg_del ( cfg_file ) ; gf_sys_close ( ) ; if ( logfile ) gf_fclose ( logfile ) ; return 1 ; } fprintf ( stderr , "Terminal<S2SV_blank>Loaded<S2SV_blank>in<S2SV_blank>%d<S2SV_blank>ms\\n" , gf_sys_clock ( ) - i ) ; if ( bench_mode ) { display_rti = 2 ; gf_term_set_option ( term , GF_OPT_VIDEO_BENCH , ( bench_mode == 3 ) ? 2 : 1 ) ; if ( bench_mode == 1 ) bench_mode = 2 ; } if ( dump_mode ) { if ( fill_ar ) gf_term_set_option ( term , GF_OPT_ASPECT_RATIO , GF_ASPECT_RATIO_FILL_SCREEN ) ; } else { str = gf_cfg_get_key ( cfg_file , "Video" , "DriverName" ) ; if ( ! bench_mode && ! strcmp ( str , "Raw<S2SV_blank>Video<S2SV_blank>Output" ) ) fprintf ( stderr , "WARNING:<S2SV_blank>using<S2SV_blank>raw<S2SV_blank>output<S2SV_blank>video<S2SV_blank>(memory<S2SV_blank>only)<S2SV_blank>-<S2SV_blank>no<S2SV_blank>display<S2SV_blank>used\\n" ) ; str = gf_cfg_get_key ( cfg_file , "Audio" , "DriverName" ) ; if ( ! str || ! strcmp ( str , "No<S2SV_blank>Audio<S2SV_blank>Output<S2SV_blank>Available" ) ) fprintf ( stderr , "WARNING:<S2SV_blank>no<S2SV_blank>audio<S2SV_blank>output<S2SV_blank>available<S2SV_blank>-<S2SV_blank>make<S2SV_blank>sure<S2SV_blank>no<S2SV_blank>other<S2SV_blank>program<S2SV_blank>is<S2SV_blank>locking<S2SV_blank>the<S2SV_blank>sound<S2SV_blank>card\\n" ) ; str = gf_cfg_get_key ( cfg_file , "General" , "NoMIMETypeFetch" ) ; no_mime_check = ( str && ! stricmp ( str , "yes" ) ) ? 1 : 0 ; } str = gf_cfg_get_key ( cfg_file , "HTTPProxy" , "Enabled" ) ; if ( str && ! strcmp ( str , "yes" ) ) { str = gf_cfg_get_key ( cfg_file , "HTTPProxy" , "Name" ) ; if ( str ) fprintf ( stderr , "HTTP<S2SV_blank>Proxy<S2SV_blank>%s<S2SV_blank>enabled\\n" , str ) ; } if ( rti_file ) { str = gf_cfg_get_key ( cfg_file , "General" , "RTIRefreshPeriod" ) ; if ( str ) { rti_update_time_ms = atoi ( str ) ; } else { gf_cfg_set_key ( cfg_file , "General" , "RTIRefreshPeriod" , "200" ) ; } UpdateRTInfo ( "At<S2SV_blank>GPAC<S2SV_blank>load<S2SV_blank>time\\n" ) ; } Run = 1 ; if ( dump_mode ) { if ( ! nb_times ) { times [ 0 ] = 0 ; nb_times ++ ; } ret_val = dump_file ( url_arg , out_arg , dump_mode , fps , forced_width , forced_height , scale , times , nb_times ) ; Run = 0 ; } else if ( views ) { } else if ( ! gui_mode && url_arg ) { char * ext ; <S2SV_StartBug> strcpy ( the_url , url_arg ) ; <S2SV_EndBug> ext = strrchr ( the_url , '.' ) ; if ( ext && ( ! stricmp ( ext , ".m3u" ) || ! stricmp ( ext , ".pls" ) ) ) { GF_Err e = GF_OK ; fprintf ( stderr , "Opening<S2SV_blank>Playlist<S2SV_blank>%s\\n" , the_url ) ; strcpy ( pl_path , the_url ) ; if ( ! strncmp ( "http:" , the_url , 5 ) ) { GF_DownloadSession * sess = gf_dm_sess_new ( term -> downloader , the_url , GF_NETIO_SESSION_NOT_THREADED , NULL , NULL , & e ) ; if ( sess ) { e = gf_dm_sess_process ( sess ) ; <S2SV_StartBug> if ( ! e ) strcpy ( the_url , gf_dm_sess_get_cache_name ( sess ) ) ; <S2SV_EndBug> gf_dm_sess_del ( sess ) ; } } playlist = e ? NULL : gf_fopen ( the_url , "rt" ) ; readonly_playlist = 1 ; if ( playlist ) { request_next_playlist_item = GF_TRUE ; } else { if ( e ) fprintf ( stderr , "Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>playlist<S2SV_blank>%s:<S2SV_blank>%s\\n" , the_url , gf_error_to_string ( e ) ) ; fprintf ( stderr , "Hit<S2SV_blank>\'h\'<S2SV_blank>for<S2SV_blank>help\\n\\n" ) ; } } else { fprintf ( stderr , "Opening<S2SV_blank>URL<S2SV_blank>%s\\n" , the_url ) ; if ( pause_at_first ) fprintf ( stderr , "[Status:<S2SV_blank>Paused]\\n" ) ; gf_term_connect_from_time ( term , the_url , ( u64 ) ( play_from * 1000 ) , pause_at_first ) ; } } else { fprintf ( stderr , "Hit<S2SV_blank>\'h\'<S2SV_blank>for<S2SV_blank>help\\n\\n" ) ; str = gf_cfg_get_key ( cfg_file , "General" , "StartupFile" ) ; if ( str ) { <S2SV_StartBug> strcpy ( the_url , "MP4Client<S2SV_blank>" GPAC_FULL_VERSION ) ; <S2SV_EndBug> gf_term_connect ( term , str ) ; startup_file = 1 ; is_connected = 1 ; } } if ( gui_mode == 2 ) gui_mode = 0 ; if ( start_fs ) gf_term_set_option ( term , GF_OPT_FULLSCREEN , 1 ) ; if ( views ) { char szTemp [ 4046 ] ; sprintf ( szTemp , "views://%s" , views ) ; gf_term_connect ( term , szTemp ) ; } if ( mosaic ) { char szTemp [ 4046 ] ; sprintf ( szTemp , "mosaic://%s" , mosaic ) ; gf_term_connect ( term , szTemp ) ; } if ( bench_mode ) { rti_update_time_ms = 500 ; bench_mode_start = gf_sys_clock ( ) ; } while ( Run ) { if ( ( gui_mode == 1 ) || ! gf_prompt_has_input ( ) ) { if ( reload ) { reload = 0 ; gf_term_disconnect ( term ) ; gf_term_connect ( term , startup_file ? gf_cfg_get_key ( cfg_file , "General" , "StartupFile" ) : the_url ) ; } if ( restart && gf_term_get_option ( term , GF_OPT_IS_OVER ) ) { restart = 0 ; gf_term_play_from_time ( term , 0 , 0 ) ; } if ( request_next_playlist_item ) { c = '\\n' ; request_next_playlist_item = 0 ; goto force_input ; } if ( has_command && is_connected ) { has_command = GF_FALSE ; for ( i = 0 ; i < ( u32 ) argc ; i ++ ) { if ( ! strcmp ( argv [ i ] , "-com" ) ) { gf_term_scene_update ( term , NULL , argv [ i + 1 ] ) ; i ++ ; } } } if ( initial_service_id && is_connected ) { GF_ObjectManager * root_od = gf_term_get_root_object ( term ) ; if ( root_od ) { gf_term_select_service ( term , root_od , initial_service_id ) ; initial_service_id = 0 ; } } if ( ! use_rtix || display_rti ) UpdateRTInfo ( NULL ) ; if ( term_step ) { gf_term_process_step ( term ) ; } else { gf_sleep ( rti_update_time_ms ) ; } if ( auto_exit && eos_seen && gf_term_get_option ( term , GF_OPT_IS_OVER ) ) { Run = GF_FALSE ; } if ( simulation_time_in_ms && ( ( gf_term_get_elapsed_time_in_ms ( term ) > simulation_time_in_ms ) || ( ! url_arg && gf_sys_clock ( ) > simulation_time_in_ms ) ) ) { Run = GF_FALSE ; } continue ; } c = gf_prompt_get_char ( ) ; force_input : switch ( c ) { case 'q' : { GF_Event evt ; memset ( & evt , 0 , sizeof ( GF_Event ) ) ; evt . type = GF_EVENT_QUIT ; gf_term_send_event ( term , & evt ) ; } break ; case 'X' : exit ( 0 ) ; break ; case 'Q' : break ; case 'o' : startup_file = 0 ; gf_term_disconnect ( term ) ; fprintf ( stderr , "Enter<S2SV_blank>the<S2SV_blank>absolute<S2SV_blank>URL\\n" ) ; if ( 1 > scanf ( "%s" , the_url ) ) { fprintf ( stderr , "Cannot<S2SV_blank>read<S2SV_blank>absolute<S2SV_blank>URL,<S2SV_blank>aborting\\n" ) ; break ; } if ( rti_file ) init_rti_logs ( rti_file , the_url , use_rtix ) ; gf_term_connect ( term , the_url ) ; break ; case 'O' : gf_term_disconnect ( term ) ; fprintf ( stderr , "Enter<S2SV_blank>the<S2SV_blank>absolute<S2SV_blank>URL<S2SV_blank>to<S2SV_blank>the<S2SV_blank>playlist\\n" ) ; if ( 1 > scanf ( "%s" , the_url ) ) { fprintf ( stderr , "Cannot<S2SV_blank>read<S2SV_blank>the<S2SV_blank>absolute<S2SV_blank>URL,<S2SV_blank>aborting.\\n" ) ; break ; } playlist = gf_fopen ( the_url , "rt" ) ; if ( playlist ) { if ( 1 > fscanf ( playlist , "%s" , the_url ) ) { fprintf ( stderr , "Cannot<S2SV_blank>read<S2SV_blank>any<S2SV_blank>URL<S2SV_blank>from<S2SV_blank>playlist,<S2SV_blank>aborting.\\n" ) ; gf_fclose ( playlist ) ; break ; } fprintf ( stderr , "Opening<S2SV_blank>URL<S2SV_blank>%s\\n" , the_url ) ; gf_term_connect ( term , the_url ) ; } break ; case '\\n' : case 'N' : if ( playlist ) { int res ; gf_term_disconnect ( term ) ; res = fscanf ( playlist , "%s" , the_url ) ; if ( ( res == EOF ) && loop_at_end ) { fseek ( playlist , 0 , SEEK_SET ) ; res = fscanf ( playlist , "%s" , the_url ) ; } if ( res == EOF ) { fprintf ( stderr , "No<S2SV_blank>more<S2SV_blank>items<S2SV_blank>-<S2SV_blank>exiting\\n" ) ; Run = 0 ; } else if ( the_url [ 0 ] == '#' ) { request_next_playlist_item = GF_TRUE ; } else { fprintf ( stderr , "Opening<S2SV_blank>URL<S2SV_blank>%s\\n" , the_url ) ; gf_term_connect_with_path ( term , the_url , pl_path ) ; } } break ; case 'P' : if ( playlist ) { u32 count ; gf_term_disconnect ( term ) ; if ( 1 > scanf ( "%u" , & count ) ) { fprintf ( stderr , "Cannot<S2SV_blank>read<S2SV_blank>number,<S2SV_blank>aborting.\\n" ) ; break ; } while ( count ) { if ( fscanf ( playlist , "%s" , the_url ) ) { fprintf ( stderr , "Failed<S2SV_blank>to<S2SV_blank>read<S2SV_blank>line,<S2SV_blank>aborting\\n" ) ; break ; } count -- ; } fprintf ( stderr , "Opening<S2SV_blank>URL<S2SV_blank>%s\\n" , the_url ) ; gf_term_connect ( term , the_url ) ; } break ; case 'r' : if ( is_connected ) reload = 1 ; break ; case 'D' : if ( is_connected ) gf_term_disconnect ( term ) ; break ; case 'p' : if ( is_connected ) { Bool is_pause = gf_term_get_option ( term , GF_OPT_PLAY_STATE ) ; fprintf ( stderr , "[Status:<S2SV_blank>%s]\\n" , is_pause ? "Playing" : "Paused" ) ; gf_term_set_option ( term , GF_OPT_PLAY_STATE , is_pause ? GF_STATE_PLAYING : GF_STATE_PAUSED ) ; } break ; case 's' : if ( is_connected ) { gf_term_set_option ( term , GF_OPT_PLAY_STATE , GF_STATE_STEP_PAUSE ) ; fprintf ( stderr , "Step<S2SV_blank>time:<S2SV_blank>" ) ; PrintTime ( gf_term_get_time_in_ms ( term ) ) ; fprintf ( stderr , "\\n" ) ; } break ; case 'z' : case 'T' : if ( ! CanSeek || ( Duration <= 2000 ) ) { fprintf ( stderr , "scene<S2SV_blank>not<S2SV_blank>seekable\\n" ) ; } else { Double res ; s32 seekTo ; fprintf ( stderr , "Duration:<S2SV_blank>" ) ; PrintTime ( Duration ) ; res = gf_term_get_time_in_ms ( term ) ; if ( c == 'z' ) { res *= 100 ; res /= ( s64 ) Duration ; fprintf ( stderr , "<S2SV_blank>(current<S2SV_blank>%.2f<S2SV_blank>%%)\\nEnter<S2SV_blank>Seek<S2SV_blank>percentage:\\n" , res ) ; if ( scanf ( "%d" , & seekTo ) == 1 ) { if ( seekTo > 100 ) seekTo = 100 ; res = ( Double ) ( s64 ) Duration ; res /= 100 ; res *= seekTo ; gf_term_play_from_time ( term , ( u64 ) ( s64 ) res , 0 ) ; } } else { u32 r , h , m , s ; fprintf ( stderr , "<S2SV_blank>-<S2SV_blank>Current<S2SV_blank>Time:<S2SV_blank>" ) ; PrintTime ( ( u64 ) res ) ; fprintf ( stderr , "\\nEnter<S2SV_blank>seek<S2SV_blank>time<S2SV_blank>(Format:<S2SV_blank>s,<S2SV_blank>m:s<S2SV_blank>or<S2SV_blank>h:m:s):\\n" ) ; h = m = s = 0 ; r = scanf ( "%d:%d:%d" , & h , & m , & s ) ; if ( r == 2 ) { s = m ; m = h ; h = 0 ; } else if ( r == 1 ) { s = h ; m = h = 0 ; } if ( r && ( r <= 3 ) ) { u64 time = h * 3600 + m * 60 + s ; gf_term_play_from_time ( term , time * 1000 , 0 ) ; } } } break ; case 't' : { if ( is_connected ) { fprintf ( stderr , "Current<S2SV_blank>Time:<S2SV_blank>" ) ; PrintTime ( gf_term_get_time_in_ms ( term ) ) ; fprintf ( stderr , "<S2SV_blank>-<S2SV_blank>Duration:<S2SV_blank>" ) ; PrintTime ( Duration ) ; fprintf ( stderr , "\\n" ) ; } } break ; case 'w' : if ( is_connected ) PrintWorldInfo ( term ) ; break ; case 'v' : if ( is_connected ) PrintODList ( term , NULL , 0 , 0 , "Root" ) ; break ; case 'i' : if ( is_connected ) { u32 ID ; fprintf ( stderr , "Enter<S2SV_blank>OD<S2SV_blank>ID<S2SV_blank>(0<S2SV_blank>for<S2SV_blank>main<S2SV_blank>OD):<S2SV_blank>" ) ; fflush ( stderr ) ; if ( scanf ( "%ud" , & ID ) == 1 ) { ViewOD ( term , ID , ( u32 ) - 1 , NULL ) ; } else { char str_url [ GF_MAX_PATH ] ; if ( scanf ( "%s" , str_url ) == 1 ) ViewOD ( term , 0 , ( u32 ) - 1 , str_url ) ; } } break ; case 'j' : if ( is_connected ) { u32 num ; do { fprintf ( stderr , "Enter<S2SV_blank>OD<S2SV_blank>number<S2SV_blank>(0<S2SV_blank>for<S2SV_blank>main<S2SV_blank>OD):<S2SV_blank>" ) ; fflush ( stderr ) ; } while ( 1 > scanf ( "%ud" , & num ) ) ; ViewOD ( term , ( u32 ) - 1 , num , NULL ) ; } break ; case 'b' : if ( is_connected ) ViewODs ( term , 1 ) ; break ; case 'm' : if ( is_connected ) ViewODs ( term , 0 ) ; break ; case 'l' : list_modules ( user . modules ) ; break ; case 'n' : if ( is_connected ) set_navigation ( ) ; break ; case 'x' : if ( is_connected ) gf_term_set_option ( term , GF_OPT_NAVIGATION_TYPE , 0 ) ; break ; case 'd' : if ( is_connected ) { GF_ObjectManager * odm = NULL ; char radname [ GF_MAX_PATH ] , * sExt ; GF_Err e ; u32 i , count , odid ; Bool xml_dump , std_out ; radname [ 0 ] = 0 ; do { fprintf ( stderr , "Enter<S2SV_blank>Inline<S2SV_blank>OD<S2SV_blank>ID<S2SV_blank>if<S2SV_blank>any<S2SV_blank>or<S2SV_blank>0<S2SV_blank>:<S2SV_blank>" ) ; fflush ( stderr ) ; } while ( 1 > scanf ( "%ud" , & odid ) ) ; if ( odid ) { GF_ObjectManager * root_odm = gf_term_get_root_object ( term ) ; if ( ! root_odm ) break ; count = gf_term_get_object_count ( term , root_odm ) ; for ( i = 0 ; i < count ; i ++ ) { GF_MediaInfo info ; odm = gf_term_get_object ( term , root_odm , i ) ; if ( gf_term_get_object_info ( term , odm , & info ) == GF_OK ) { if ( info . od -> objectDescriptorID == odid ) break ; } odm = NULL ; } } do { fprintf ( stderr , "Enter<S2SV_blank>file<S2SV_blank>radical<S2SV_blank>name<S2SV_blank>(+\\\'.x\\\'<S2SV_blank>for<S2SV_blank>XML<S2SV_blank>dumping)<S2SV_blank>-<S2SV_blank>\\"std\\"<S2SV_blank>for<S2SV_blank>stderr:<S2SV_blank>" ) ; fflush ( stderr ) ; } while ( 1 > scanf ( "%s" , radname ) ) ; sExt = strrchr ( radname , '.' ) ; xml_dump = 0 ; if ( sExt ) { if ( ! stricmp ( sExt , ".x" ) ) xml_dump = 1 ; sExt [ 0 ] = 0 ; } std_out = strnicmp ( radname , "std" , 3 ) ? 0 : 1 ; e = gf_term_dump_scene ( term , std_out ? NULL : radname , NULL , xml_dump , 0 , odm ) ; fprintf ( stderr , "Dump<S2SV_blank>done<S2SV_blank>(%s)\\n" , gf_error_to_string ( e ) ) ; } break ; case 'c' : PrintGPACConfig ( ) ; break ; case '3' : { Bool use_3d = ! gf_term_get_option ( term , GF_OPT_USE_OPENGL ) ; if ( gf_term_set_option ( term , GF_OPT_USE_OPENGL , use_3d ) == GF_OK ) { fprintf ( stderr , "Using<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>2D<S2SV_blank>drawing\\n" , use_3d ? "OpenGL" : "2D<S2SV_blank>rasterizer" ) ; } } break ; case 'k' : { Bool opt = gf_term_get_option ( term , GF_OPT_STRESS_MODE ) ; opt = ! opt ; fprintf ( stderr , "Turning<S2SV_blank>stress<S2SV_blank>mode<S2SV_blank>%s\\n" , opt ? "on" : "off" ) ; gf_term_set_option ( term , GF_OPT_STRESS_MODE , opt ) ; } break ; case '4' : gf_term_set_option ( term , GF_OPT_ASPECT_RATIO , GF_ASPECT_RATIO_4_3 ) ; break ; case '5' : gf_term_set_option ( term , GF_OPT_ASPECT_RATIO , GF_ASPECT_RATIO_16_9 ) ; break ; case '6' : gf_term_set_option ( term , GF_OPT_ASPECT_RATIO , GF_ASPECT_RATIO_FILL_SCREEN ) ; break ; case '7' : gf_term_set_option ( term , GF_OPT_ASPECT_RATIO , GF_ASPECT_RATIO_KEEP ) ; break ; case 'C' : switch ( gf_term_get_option ( term , GF_OPT_MEDIA_CACHE ) ) { case GF_MEDIA_CACHE_DISABLED : gf_term_set_option ( term , GF_OPT_MEDIA_CACHE , GF_MEDIA_CACHE_ENABLED ) ; break ; case GF_MEDIA_CACHE_ENABLED : gf_term_set_option ( term , GF_OPT_MEDIA_CACHE , GF_MEDIA_CACHE_DISABLED ) ; break ; case GF_MEDIA_CACHE_RUNNING : fprintf ( stderr , "Streaming<S2SV_blank>Cache<S2SV_blank>is<S2SV_blank>running<S2SV_blank>-<S2SV_blank>please<S2SV_blank>stop<S2SV_blank>it<S2SV_blank>first\\n" ) ; continue ; } switch ( gf_term_get_option ( term , GF_OPT_MEDIA_CACHE ) ) { case GF_MEDIA_CACHE_ENABLED : fprintf ( stderr , "Streaming<S2SV_blank>Cache<S2SV_blank>Enabled\\n" ) ; break ; case GF_MEDIA_CACHE_DISABLED : fprintf ( stderr , "Streaming<S2SV_blank>Cache<S2SV_blank>Disabled\\n" ) ; break ; case GF_MEDIA_CACHE_RUNNING : fprintf ( stderr , "Streaming<S2SV_blank>Cache<S2SV_blank>Running\\n" ) ; break ; } break ; case 'S' : case 'A' : if ( gf_term_get_option ( term , GF_OPT_MEDIA_CACHE ) == GF_MEDIA_CACHE_RUNNING ) { gf_term_set_option ( term , GF_OPT_MEDIA_CACHE , ( c == 'S' ) ? GF_MEDIA_CACHE_DISABLED : GF_MEDIA_CACHE_DISCARD ) ; fprintf ( stderr , "Streaming<S2SV_blank>Cache<S2SV_blank>stopped\\n" ) ; } else { fprintf ( stderr , "Streaming<S2SV_blank>Cache<S2SV_blank>not<S2SV_blank>running\\n" ) ; } break ; case 'R' : display_rti = ! display_rti ; ResetCaption ( ) ; break ; case 'F' : if ( display_rti ) display_rti = 0 ; else display_rti = 2 ; ResetCaption ( ) ; break ; case 'u' : { GF_Err e ; char szCom [ 8192 ] ; fprintf ( stderr , "Enter<S2SV_blank>command<S2SV_blank>to<S2SV_blank>send:\\n" ) ; fflush ( stdin ) ; szCom [ 0 ] = 0 ; if ( 1 > scanf ( "%[^\\t\\n]" , szCom ) ) { fprintf ( stderr , "Cannot<S2SV_blank>read<S2SV_blank>command<S2SV_blank>to<S2SV_blank>send,<S2SV_blank>aborting.\\n" ) ; break ; } e = gf_term_scene_update ( term , NULL , szCom ) ; if ( e ) fprintf ( stderr , "Processing<S2SV_blank>command<S2SV_blank>failed:<S2SV_blank>%s\\n" , gf_error_to_string ( e ) ) ; } break ; case 'e' : { GF_Err e ; char jsCode [ 8192 ] ; fprintf ( stderr , "Enter<S2SV_blank>JavaScript<S2SV_blank>code<S2SV_blank>to<S2SV_blank>evaluate:\\n" ) ; fflush ( stdin ) ; jsCode [ 0 ] = 0 ; if ( 1 > scanf ( "%[^\\t\\n]" , jsCode ) ) { fprintf ( stderr , "Cannot<S2SV_blank>read<S2SV_blank>code<S2SV_blank>to<S2SV_blank>evaluate,<S2SV_blank>aborting.\\n" ) ; break ; } e = gf_term_scene_update ( term , "application/ecmascript" , jsCode ) ; if ( e ) fprintf ( stderr , "Processing<S2SV_blank>JS<S2SV_blank>code<S2SV_blank>failed:<S2SV_blank>%s\\n" , gf_error_to_string ( e ) ) ; } break ; case 'L' : { char szLog [ 1024 ] , * cur_logs ; cur_logs = gf_log_get_tools_levels ( ) ; fprintf ( stderr , "Enter<S2SV_blank>new<S2SV_blank>log<S2SV_blank>level<S2SV_blank>(current<S2SV_blank>tools<S2SV_blank>%s):\\n" , cur_logs ) ; gf_free ( cur_logs ) ; if ( scanf ( "%s" , szLog ) < 1 ) { fprintf ( stderr , "Cannot<S2SV_blank>read<S2SV_blank>new<S2SV_blank>log<S2SV_blank>level,<S2SV_blank>aborting.\\n" ) ; break ; } gf_log_modify_tools_levels ( szLog ) ; } break ; case 'g' : { GF_SystemRTInfo rti ; gf_sys_get_rti ( rti_update_time_ms , & rti , 0 ) ; fprintf ( stderr , "GPAC<S2SV_blank>allocated<S2SV_blank>memory<S2SV_blank>" LLD "\\n" , rti . gpac_memory ) ; } break ; case 'M' : { u32 size ; do { fprintf ( stderr , "Enter<S2SV_blank>new<S2SV_blank>video<S2SV_blank>cache<S2SV_blank>memory<S2SV_blank>in<S2SV_blank>kBytes<S2SV_blank>(current<S2SV_blank>%ud):\\n" , gf_term_get_option ( term , GF_OPT_VIDEO_CACHE_SIZE ) ) ; } while ( 1 > scanf ( "%ud" , & size ) ) ; gf_term_set_option ( term , GF_OPT_VIDEO_CACHE_SIZE , size ) ; } break ; case 'H' : { u32 http_bitrate = gf_term_get_option ( term , GF_OPT_HTTP_MAX_RATE ) ; do { fprintf ( stderr , "Enter<S2SV_blank>new<S2SV_blank>http<S2SV_blank>bitrate<S2SV_blank>in<S2SV_blank>bps<S2SV_blank>(0<S2SV_blank>for<S2SV_blank>none)<S2SV_blank>-<S2SV_blank>current<S2SV_blank>limit:<S2SV_blank>%d\\n" , http_bitrate ) ; } while ( 1 > scanf ( "%ud" , & http_bitrate ) ) ; gf_term_set_option ( term , GF_OPT_HTTP_MAX_RATE , http_bitrate ) ; } break ; case 'E' : gf_term_set_option ( term , GF_OPT_RELOAD_CONFIG , 1 ) ; break ; case 'B' : switch_bench ( ! bench_mode ) ; break ; case 'Y' : { char szOpt [ 8192 ] ; fprintf ( stderr , "Enter<S2SV_blank>option<S2SV_blank>to<S2SV_blank>set<S2SV_blank>(Section:Name=Value):\\n" ) ; fflush ( stdin ) ; szOpt [ 0 ] = 0 ; if ( 1 > scanf ( "%[^\\t\\n]" , szOpt ) ) { fprintf ( stderr , "Cannot<S2SV_blank>read<S2SV_blank>option\\n" ) ; break ; } set_cfg_option ( szOpt ) ; } break ; case 'Z' : { char szFileName [ 100 ] ; u32 nb_pass , nb_views , offscreen_view = 0 ; GF_VideoSurface fb ; GF_Err e ; nb_pass = 1 ; nb_views = gf_term_get_option ( term , GF_OPT_NUM_STEREO_VIEWS ) ; if ( nb_views > 1 ) { fprintf ( stderr , "Auto-stereo<S2SV_blank>mode<S2SV_blank>detected<S2SV_blank>-<S2SV_blank>type<S2SV_blank>number<S2SV_blank>of<S2SV_blank>view<S2SV_blank>to<S2SV_blank>dump<S2SV_blank>(0<S2SV_blank>is<S2SV_blank>main<S2SV_blank>output,<S2SV_blank>1<S2SV_blank>to<S2SV_blank>%d<S2SV_blank>offscreen<S2SV_blank>view,<S2SV_blank>%d<S2SV_blank>for<S2SV_blank>all<S2SV_blank>offscreen,<S2SV_blank>%d<S2SV_blank>for<S2SV_blank>all<S2SV_blank>offscreen<S2SV_blank>and<S2SV_blank>main)\\n" , nb_views , nb_views + 1 , nb_views + 2 ) ; if ( scanf ( "%d" , & offscreen_view ) != 1 ) { offscreen_view = 0 ; } if ( offscreen_view == nb_views + 1 ) { offscreen_view = 1 ; nb_pass = nb_views ; } else if ( offscreen_view == nb_views + 2 ) { offscreen_view = 0 ; nb_pass = nb_views + 1 ; } } while ( nb_pass ) { nb_pass -- ; if ( offscreen_view ) { sprintf ( szFileName , "view%d_dump.png" , offscreen_view ) ; e = gf_term_get_offscreen_buffer ( term , & fb , offscreen_view - 1 , 0 ) ; } else { sprintf ( szFileName , "gpac_video_dump_" LLU ".png" , gf_net_get_utc ( ) ) ; e = gf_term_get_screen_buffer ( term , & fb ) ; } offscreen_view ++ ; if ( e ) { fprintf ( stderr , "Error<S2SV_blank>dumping<S2SV_blank>screen<S2SV_blank>buffer<S2SV_blank>%s\\n" , gf_error_to_string ( e ) ) ; nb_pass = 0 ; } else { # ifndef GPAC_DISABLE_AV_PARSERS u32 dst_size = fb . width * fb . height * 4 ; char * dst = ( char * ) gf_malloc ( sizeof ( char ) * dst_size ) ; e = gf_img_png_enc ( fb . video_buffer , fb . width , fb . height , fb . pitch_y , fb . pixel_format , dst , & dst_size ) ; if ( e ) { fprintf ( stderr , "Error<S2SV_blank>encoding<S2SV_blank>PNG<S2SV_blank>%s\\n" , gf_error_to_string ( e ) ) ; nb_pass = 0 ; } else { FILE * png = gf_fopen ( szFileName , "wb" ) ; if ( ! png ) { fprintf ( stderr , "Error<S2SV_blank>writing<S2SV_blank>file<S2SV_blank>%s\\n" , szFileName ) ; nb_pass = 0 ; } else { gf_fwrite ( dst , dst_size , 1 , png ) ; gf_fclose ( png ) ; fprintf ( stderr , "Dump<S2SV_blank>to<S2SV_blank>%s\\n" , szFileName ) ; } } if ( dst ) gf_free ( dst ) ; gf_term_release_screen_buffer ( term , & fb ) ; # endif } } fprintf ( stderr , "Done:<S2SV_blank>%s\\n" , szFileName ) ; } break ; case 'G' : { GF_ObjectManager * root_od , * odm ; u32 index ; char szOpt [ 8192 ] ; fprintf ( stderr , "Enter<S2SV_blank>0-based<S2SV_blank>index<S2SV_blank>of<S2SV_blank>object<S2SV_blank>to<S2SV_blank>select<S2SV_blank>or<S2SV_blank>service<S2SV_blank>ID:\\n" ) ; fflush ( stdin ) ; szOpt [ 0 ] = 0 ; if ( 1 > scanf ( "%[^\\t\\n]" , szOpt ) ) { fprintf ( stderr , "Cannot<S2SV_blank>read<S2SV_blank>OD<S2SV_blank>ID\\n" ) ; break ; } index = atoi ( szOpt ) ; odm = NULL ; root_od = gf_term_get_root_object ( term ) ; if ( root_od ) { if ( gf_term_find_service ( term , root_od , index ) ) { gf_term_select_service ( term , root_od , index ) ; } else { fprintf ( stderr , "Cannot<S2SV_blank>find<S2SV_blank>service<S2SV_blank>%d<S2SV_blank>-<S2SV_blank>trying<S2SV_blank>with<S2SV_blank>object<S2SV_blank>index\\n" , index ) ; odm = gf_term_get_object ( term , root_od , index ) ; if ( odm ) { gf_term_select_object ( term , odm ) ; } else { fprintf ( stderr , "Cannot<S2SV_blank>find<S2SV_blank>object<S2SV_blank>at<S2SV_blank>index<S2SV_blank>%d\\n" , index ) ; } } } } break ; case 'h' : PrintHelp ( ) ; break ; default : break ; } } if ( bench_mode ) { PrintAVInfo ( GF_TRUE ) ; } if ( simulation_time_in_ms ) { gf_log_set_strict_error ( 0 ) ; } i = gf_sys_clock ( ) ; gf_term_disconnect ( term ) ; if ( rti_file ) UpdateRTInfo ( "Disconnected\\n" ) ; fprintf ( stderr , "Deleting<S2SV_blank>terminal...<S2SV_blank>" ) ; if ( playlist ) gf_fclose ( playlist ) ; # if defined ( __DARWIN__ ) || defined ( __APPLE__ ) carbon_uninit ( ) ; # endif gf_term_del ( term ) ; fprintf ( stderr , "done<S2SV_blank>(in<S2SV_blank>%d<S2SV_blank>ms)<S2SV_blank>-<S2SV_blank>ran<S2SV_blank>for<S2SV_blank>%d<S2SV_blank>ms\\n" , gf_sys_clock ( ) - i , gf_sys_clock ( ) ) ; fprintf ( stderr , "GPAC<S2SV_blank>cleanup<S2SV_blank>...\\n" ) ; gf_modules_del ( user . modules ) ; if ( no_cfg_save ) gf_cfg_discard_changes ( cfg_file ) ; gf_cfg_del ( cfg_file ) ; gf_sys_close ( ) ; if ( rti_logs ) gf_fclose ( rti_logs ) ; if ( logfile ) gf_fclose ( logfile ) ; if ( gui_mode ) { hide_shell ( 2 ) ; } # ifdef GPAC_MEMORY_TRACKING if ( mem_track && ( gf_memory_size ( ) || gf_file_handles_count ( ) ) ) { gf_log_set_tool_level ( GF_LOG_MEMORY , GF_LOG_INFO ) ; gf_memory_print ( ) ; return 2 ; } # endif return ret_val ; }
CWE-119 void set_cfg_option ( char * opt_string ) { char * sep , * sep2 , szSec [ 1024 ] , szKey [ 1024 ] , szVal [ 1024 ] ; sep = strchr ( opt_string , ':' ) ; if ( ! sep ) { fprintf ( stderr , "Badly<S2SV_blank>formatted<S2SV_blank>option<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>expected<S2SV_blank>Section:Name=Value\\n" , opt_string ) ; return ; } { const size_t sepIdx = sep - opt_string ; <S2SV_StartBug> strncpy ( szSec , opt_string , sepIdx ) ; <S2SV_EndBug> szSec [ sepIdx ] = 0 ; } sep ++ ; sep2 = strchr ( sep , '=' ) ; if ( ! sep2 ) { fprintf ( stderr , "Badly<S2SV_blank>formatted<S2SV_blank>option<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>expected<S2SV_blank>Section:Name=Value\\n" , opt_string ) ; return ; } { const size_t sepIdx = sep2 - sep ; <S2SV_StartBug> strncpy ( szKey , sep , sepIdx ) ; <S2SV_EndBug> szKey [ sepIdx ] = 0 ; <S2SV_StartBug> strcpy ( szVal , sep2 + 1 ) ; <S2SV_EndBug> } if ( ! stricmp ( szKey , "*" ) ) { if ( stricmp ( szVal , "null" ) ) { fprintf ( stderr , "Badly<S2SV_blank>formatted<S2SV_blank>option<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>expected<S2SV_blank>Section:*=null\\n" , opt_string ) ; return ; } gf_cfg_del_section ( cfg_file , szSec ) ; return ; } if ( ! stricmp ( szVal , "null" ) ) { szVal [ 0 ] = 0 ; } gf_cfg_set_key ( cfg_file , szSec , szKey , szVal [ 0 ] ? szVal : NULL ) ; }
CWE-119 static Bool FFD_CanHandleURL ( GF_InputService * plug , const char * url ) { Bool has_audio , has_video ; s32 i ; AVFormatContext * ctx ; AVOutputFormat * fmt_out ; Bool ret = GF_FALSE ; <S2SV_StartBug> char * ext , szName [ 1000 ] , szExt [ 20 ] ; <S2SV_EndBug> const char * szExtList ; FFDemux * ffd ; if ( ! plug || ! url ) return GF_FALSE ; if ( ! strnicmp ( url , "rtsp://" , 7 ) ) return GF_FALSE ; if ( ! strnicmp ( url , "rtspu://" , 8 ) ) return GF_FALSE ; if ( ! strnicmp ( url , "rtp://" , 6 ) ) return GF_FALSE ; if ( ! strnicmp ( url , "plato://" , 8 ) ) return GF_FALSE ; if ( ! strnicmp ( url , "udp://" , 6 ) ) return GF_FALSE ; if ( ! strnicmp ( url , "tcp://" , 6 ) ) return GF_FALSE ; if ( ! strnicmp ( url , "data:" , 5 ) ) return GF_FALSE ; ffd = ( FFDemux * ) plug -> priv ; <S2SV_StartBug> strcpy ( szName , url ) ; <S2SV_EndBug> ext = strrchr ( szName , '#' ) ; if ( ext ) ext [ 0 ] = 0 ; ext = strrchr ( szName , '?' ) ; if ( ext ) ext [ 0 ] = 0 ; ext = strrchr ( szName , '.' ) ; if ( ext && strlen ( ext ) > 19 ) ext = NULL ; <S2SV_StartBug> if ( ext && strlen ( ext ) > 1 ) { <S2SV_EndBug> strcpy ( szExt , & ext [ 1 ] ) ; strlwr ( szExt ) ; # ifndef FFMPEG_DEMUX_ENABLE_MPEG2TS if ( strstr ( "ts<S2SV_blank>m2t<S2SV_blank>mts<S2SV_blank>dmb<S2SV_blank>trp" , szExt ) ) return GF_FALSE ; # endif if ( ! strcmp ( szExt , "mp4" ) || ! strcmp ( szExt , "mpg4" ) || ! strcmp ( szExt , "m4a" ) || ! strcmp ( szExt , "m21" ) || ! strcmp ( szExt , "m4v" ) || ! strcmp ( szExt , "m4a" ) || ! strcmp ( szExt , "m4s" ) || ! strcmp ( szExt , "3gs" ) || ! strcmp ( szExt , "3gp" ) || ! strcmp ( szExt , "3gpp" ) || ! strcmp ( szExt , "3gp2" ) || ! strcmp ( szExt , "3g2" ) || ! strcmp ( szExt , "mp3" ) || ! strcmp ( szExt , "ac3" ) || ! strcmp ( szExt , "amr" ) || ! strcmp ( szExt , "bt" ) || ! strcmp ( szExt , "wrl" ) || ! strcmp ( szExt , "x3dv" ) || ! strcmp ( szExt , "xmt" ) || ! strcmp ( szExt , "xmta" ) || ! strcmp ( szExt , "x3d" ) || ! strcmp ( szExt , "jpg" ) || ! strcmp ( szExt , "jpeg" ) || ! strcmp ( szExt , "png" ) ) return GF_FALSE ; { u32 i ; for ( i = 0 ; FFD_MIME_TYPES [ i ] ; i += 3 ) { if ( gf_service_check_mime_register ( plug , FFD_MIME_TYPES [ i ] , FFD_MIME_TYPES [ i + 1 ] , FFD_MIME_TYPES [ i + 2 ] , ext ) ) return GF_TRUE ; } } } ffd_parse_options ( ffd , url ) ; ctx = NULL ; if ( open_file ( & ctx , szName , NULL , ffd -> options ? & ffd -> options : NULL ) < 0 ) { AVInputFormat * av_in = NULL ; if ( ext && ! strcmp ( szExt , "cmp" ) ) av_in = av_find_input_format ( "m4v" ) ; if ( open_file ( & ctx , szName , av_in , ffd -> options ? & ffd -> options : NULL ) < 0 ) { return GF_FALSE ; } } if ( ! ctx ) goto exit ; if ( av_find_stream_info ( ctx ) < 0 ) goto exit ; has_video = has_audio = GF_FALSE ; for ( i = 0 ; i < ( s32 ) ctx -> nb_streams ; i ++ ) { AVCodecContext * enc = ctx -> streams [ i ] -> codec ; switch ( enc -> codec_type ) { case AVMEDIA_TYPE_AUDIO : if ( ! has_audio ) has_audio = GF_TRUE ; break ; case AVMEDIA_TYPE_VIDEO : if ( ! has_video ) has_video = GF_TRUE ; break ; default : break ; } } if ( ! has_audio && ! has_video ) goto exit ; ret = GF_TRUE ; # if ( ( LIBAVFORMAT_VERSION_MAJOR == 52 ) && ( LIBAVFORMAT_VERSION_MINOR <= 47 ) ) || ( LIBAVFORMAT_VERSION_MAJOR < 52 ) fmt_out = guess_stream_format ( NULL , url , NULL ) ; # else fmt_out = av_guess_format ( NULL , url , NULL ) ; # endif if ( fmt_out ) gf_service_register_mime ( plug , fmt_out -> mime_type , fmt_out -> extensions , fmt_out -> name ) ; else { ext = strrchr ( szName , '.' ) ; if ( ext ) { strcpy ( szExt , & ext [ 1 ] ) ; strlwr ( szExt ) ; szExtList = gf_modules_get_option ( ( GF_BaseInterface * ) plug , "MimeTypes" , "application/x-ffmpeg" ) ; if ( ! szExtList ) { gf_service_register_mime ( plug , "application/x-ffmpeg" , szExt , "Other<S2SV_blank>Movies<S2SV_blank>(FFMPEG)" ) ; } else if ( ! strstr ( szExtList , szExt ) ) { u32 len ; char * buf ; len = ( u32 ) ( strlen ( szExtList ) + strlen ( szExt ) + 10 ) ; buf = ( char * ) gf_malloc ( sizeof ( char ) * len ) ; sprintf ( buf , "\\"%s<S2SV_blank>" , szExt ) ; strcat ( buf , & szExtList [ 1 ] ) ; gf_modules_set_option ( ( GF_BaseInterface * ) plug , "MimeTypes" , "application/x-ffmpeg" , buf ) ; gf_free ( buf ) ; } } } exit : # if FF_API_CLOSE_INPUT_FILE if ( ctx ) av_close_input_file ( ctx ) ; # else if ( ctx ) avformat_close_input ( & ctx ) ; # endif return ret ; }
CWE-787 char * gf_text_get_utf8_line ( char * szLine , u32 lineSize , FILE * txt_in , s32 unicode_type ) { u32 i , j , len ; char * sOK ; char szLineConv [ 1024 ] ; unsigned short * sptr ; memset ( szLine , 0 , sizeof ( char ) * lineSize ) ; sOK = fgets ( szLine , lineSize , txt_in ) ; if ( ! sOK ) return NULL ; if ( unicode_type <= 1 ) { j = 0 ; len = ( u32 ) strlen ( szLine ) ; for ( i = 0 ; i < len ; i ++ ) { if ( ! unicode_type && ( szLine [ i ] & 0x80 ) ) { if ( ( szLine [ i + 1 ] & 0xc0 ) != 0x80 ) { szLineConv [ j ] = 0xc0 | ( ( szLine [ i ] >> 6 ) & 0x3 ) ; j ++ ; szLine [ i ] &= 0xbf ; } else if ( ( szLine [ i ] & 0xe0 ) == 0xc0 ) { szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; } else if ( ( szLine [ i ] & 0xf0 ) == 0xe0 ) { szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; } else if ( ( szLine [ i ] & 0xf8 ) == 0xf0 ) { szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; } else { i += 1 ; continue ; } } szLineConv [ j ] = szLine [ i ] ; j ++ ; } szLineConv [ j ] = 0 ; strcpy ( szLine , szLineConv ) ; return sOK ; } # ifdef GPAC_BIG_ENDIAN if ( unicode_type == 3 ) { # else if ( unicode_type == 2 ) { # endif i = 0 ; while ( 1 ) { char c ; if ( ! szLine [ i ] && ! szLine [ i + 1 ] ) break ; c = szLine [ i + 1 ] ; szLine [ i + 1 ] = szLine [ i ] ; szLine [ i ] = c ; i += 2 ; } } sptr = ( u16 * ) szLine ; i = ( u32 ) gf_utf8_wcstombs ( szLineConv , 1024 , ( const unsigned short * * ) & sptr ) ; <S2SV_StartBug> szLineConv [ i ] = 0 ; <S2SV_EndBug> strcpy ( szLine , szLineConv ) ; if ( unicode_type == 3 ) fgetc ( txt_in ) ; return sOK ; }
CWE-400 GF_Err dinf_Read ( GF_Box * s , GF_BitStream * bs ) { GF_Err e = gf_isom_box_array_read ( s , bs , dinf_AddBox ) ; if ( e ) { return e ; } if ( ! ( ( GF_DataInformationBox * ) s ) -> dref ) { <S2SV_StartBug> GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( "[iso<S2SV_blank>file]<S2SV_blank>Missing<S2SV_blank>dref<S2SV_blank>box<S2SV_blank>in<S2SV_blank>dinf\\n" ) ) ; <S2SV_EndBug> <S2SV_StartBug> ( ( GF_DataInformationBox * ) s ) -> dref = ( GF_DataReferenceBox * ) gf_isom_box_new ( GF_ISOM_BOX_TYPE_DREF ) ; <S2SV_EndBug> } return GF_OK ; }
CWE-310 static unsigned int do_decrypt ( const RIJNDAEL_context * ctx , unsigned char * bx , const unsigned char * ax ) { # ifdef USE_AMD64_ASM return _gcry_aes_amd64_decrypt_block ( ctx -> keyschdec , bx , ax , ctx -> rounds , <S2SV_StartBug> & dec_tables ) ; <S2SV_EndBug> # elif defined ( USE_ARM_ASM ) return _gcry_aes_arm_decrypt_block ( ctx -> keyschdec , bx , ax , ctx -> rounds , <S2SV_StartBug> & dec_tables ) ; <S2SV_EndBug> # else return do_decrypt_fn ( ctx , bx , ax ) ; # endif }
CWE-310 static unsigned int do_encrypt ( const RIJNDAEL_context * ctx , unsigned char * bx , const unsigned char * ax ) { # ifdef USE_AMD64_ASM return _gcry_aes_amd64_encrypt_block ( ctx -> keyschenc , bx , ax , ctx -> rounds , <S2SV_StartBug> encT ) ; <S2SV_EndBug> # elif defined ( USE_ARM_ASM ) <S2SV_StartBug> return _gcry_aes_arm_encrypt_block ( ctx -> keyschenc , bx , ax , ctx -> rounds , encT ) ; <S2SV_EndBug> # else return do_encrypt_fn ( ctx , bx , ax ) ; # endif }
CWE-310 static void prefetch_dec ( void ) <S2SV_StartBug> { <S2SV_EndBug> prefetch_table ( ( const void * ) & dec_tables , sizeof ( dec_tables ) ) ; }
CWE-310 static void prefetch_enc ( void ) { <S2SV_StartBug> prefetch_table ( ( const void * ) encT , sizeof ( encT ) ) ; <S2SV_EndBug> }
CWE-310 <S2SV_StartBug> static void prefetch_table ( const volatile byte * tab , size_t len ) <S2SV_EndBug> { size_t i ; <S2SV_StartBug> for ( i = 0 ; i < len ; i += 8 * 32 ) <S2SV_EndBug> { ( void ) tab [ i + 0 * 32 ] ; ( void ) tab [ i + 1 * 32 ] ; ( void ) tab [ i + 2 * 32 ] ; ( void ) tab [ i + 3 * 32 ] ; ( void ) tab [ i + 4 * 32 ] ; ( void ) tab [ i + 5 * 32 ] ; ( void ) tab [ i + 6 * 32 ] ; ( void ) tab [ i + 7 * 32 ] ; } <S2SV_StartBug> ( void ) tab [ len - 1 ] ; <S2SV_EndBug> }
CWE-20 int treeRead ( struct READER * reader , struct DATAOBJECT * data ) { int i , j , err , olen , elements , size , x , y , z , b , e , dy , dz , sx , sy , sz , dzy , szy ; char * input , * output ; uint8_t node_type , node_level ; uint16_t entries_used ; uint32_t size_of_chunk ; uint32_t filter_mask ; uint64_t address_of_left_sibling , address_of_right_sibling , start [ 4 ] , child_pointer , key , store ; char buf [ 4 ] ; UNUSED ( node_level ) ; UNUSED ( address_of_right_sibling ) ; UNUSED ( address_of_left_sibling ) ; UNUSED ( key ) ; if ( data -> ds . dimensionality > 3 ) { log ( "TREE<S2SV_blank>dimensions<S2SV_blank>><S2SV_blank>3" ) ; return MYSOFA_INVALID_FORMAT ; } if ( fread ( buf , 1 , 4 , reader -> fhd ) != 4 || strncmp ( buf , "TREE" , 4 ) ) { log ( "cannot<S2SV_blank>read<S2SV_blank>signature<S2SV_blank>of<S2SV_blank>TREE\\n" ) ; return MYSOFA_INVALID_FORMAT ; } log ( "%08lX<S2SV_blank>%.4s\\n" , ( uint64_t ) ftell ( reader -> fhd ) - 4 , buf ) ; node_type = ( uint8_t ) fgetc ( reader -> fhd ) ; node_level = ( uint8_t ) fgetc ( reader -> fhd ) ; entries_used = ( uint16_t ) readValue ( reader , 2 ) ; if ( entries_used > 0x1000 ) return MYSOFA_UNSUPPORTED_FORMAT ; address_of_left_sibling = readValue ( reader , reader -> superblock . size_of_offsets ) ; address_of_right_sibling = readValue ( reader , reader -> superblock . size_of_offsets ) ; elements = 1 ; for ( j = 0 ; j < data -> ds . dimensionality ; j ++ ) elements *= data -> datalayout_chunk [ j ] ; dy = data -> datalayout_chunk [ 1 ] ; dz = data -> datalayout_chunk [ 2 ] ; sx = data -> ds . dimension_size [ 0 ] ; sy = data -> ds . dimension_size [ 1 ] ; sz = data -> ds . dimension_size [ 2 ] ; dzy = dz * dy ; szy = sz * sy ; size = data -> datalayout_chunk [ data -> ds . dimensionality ] ; log ( "elements<S2SV_blank>%d<S2SV_blank>size<S2SV_blank>%d\\n" , elements , size ) ; if ( ! ( output = malloc ( elements * size ) ) ) { return MYSOFA_NO_MEMORY ; } for ( e = 0 ; e < entries_used * 2 ; e ++ ) { if ( node_type == 0 ) { key = readValue ( reader , reader -> superblock . size_of_lengths ) ; } else { size_of_chunk = ( uint32_t ) readValue ( reader , 4 ) ; filter_mask = ( uint32_t ) readValue ( reader , 4 ) ; if ( filter_mask ) { log ( "TREE<S2SV_blank>all<S2SV_blank>filters<S2SV_blank>must<S2SV_blank>be<S2SV_blank>enabled\\n" ) ; free ( output ) ; return MYSOFA_INVALID_FORMAT ; } for ( j = 0 ; j < data -> ds . dimensionality ; j ++ ) { start [ j ] = readValue ( reader , 8 ) ; log ( "start<S2SV_blank>%d<S2SV_blank>%lu\\n" , j , start [ j ] ) ; } if ( readValue ( reader , 8 ) ) { break ; } child_pointer = readValue ( reader , reader -> superblock . size_of_offsets ) ; log ( "<S2SV_blank>data<S2SV_blank>at<S2SV_blank>%lX<S2SV_blank>len<S2SV_blank>%u\\n" , child_pointer , size_of_chunk ) ; store = ftell ( reader -> fhd ) ; if ( fseek ( reader -> fhd , child_pointer , SEEK_SET ) < 0 ) { free ( output ) ; return errno ; } if ( ! ( input = malloc ( size_of_chunk ) ) ) { free ( output ) ; return MYSOFA_NO_MEMORY ; } if ( fread ( input , 1 , size_of_chunk , reader -> fhd ) != size_of_chunk ) { free ( output ) ; free ( input ) ; return MYSOFA_INVALID_FORMAT ; } olen = elements * size ; err = gunzip ( size_of_chunk , input , & olen , output ) ; free ( input ) ; log ( "<S2SV_blank><S2SV_blank><S2SV_blank>gunzip<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%d\\n" , err , olen , elements * size ) ; if ( err || olen != elements * size ) { free ( output ) ; return MYSOFA_INVALID_FORMAT ; } switch ( data -> ds . dimensionality ) { case 1 : for ( i = 0 ; i < olen ; i ++ ) { b = i / elements ; x = i % elements + start [ 0 ] ; <S2SV_StartBug> if ( x < sx ) { <S2SV_EndBug> <S2SV_StartBug> j = x * size + b ; <S2SV_EndBug> ( ( char * ) data -> data ) [ j ] = output [ i ] ; } } break ; case 2 : for ( i = 0 ; i < olen ; i ++ ) { b = i / elements ; x = i % elements ; y = x % dy + start [ 1 ] ; x = x / dy + start [ 0 ] ; <S2SV_StartBug> if ( y < sy && x < sx ) { <S2SV_EndBug> <S2SV_StartBug> j = ( ( x * sy + y ) * size ) + b ; <S2SV_EndBug> ( ( char * ) data -> data ) [ j ] = output [ i ] ; } } break ; case 3 : for ( i = 0 ; i < olen ; i ++ ) { b = i / elements ; x = i % elements ; z = x % dz + start [ 2 ] ; y = ( x / dz ) % dy + start [ 1 ] ; x = ( x / dzy ) + start [ 0 ] ; <S2SV_StartBug> if ( z < sz && y < sy && x < sx ) { <S2SV_EndBug> j = ( x * szy + y * sz + z ) * size + b ; <S2SV_StartBug> ( ( char * ) data -> data ) [ j ] = output [ i ] ; <S2SV_EndBug> } } break ; default : log ( "invalid<S2SV_blank>dim\\n" ) ; return MYSOFA_INTERNAL_ERROR ; } if ( fseek ( reader -> fhd , store , SEEK_SET ) < 0 ) { free ( output ) ; return errno ; } } } free ( output ) ; if ( fseek ( reader -> fhd , 4 , SEEK_CUR ) < 0 ) return errno ; return MYSOFA_OK ; }
CWE-416 static void destroy_server_connect ( SERVER_CONNECT_REC * conn ) { IRC_SERVER_CONNECT_REC * ircconn ; ircconn = IRC_SERVER_CONNECT ( conn ) ; if ( ircconn == NULL ) return ; g_free_not_null ( ircconn -> usermode ) ; g_free_not_null ( ircconn -> alternate_nick ) ; <S2SV_StartBug> } <S2SV_EndBug>
CWE-416 static void sig_server_connect_copy ( SERVER_CONNECT_REC * * dest , IRC_SERVER_CONNECT_REC * src ) { IRC_SERVER_CONNECT_REC * rec ; g_return_if_fail ( dest != NULL ) ; if ( ! IS_IRC_SERVER_CONNECT ( src ) ) return ; rec = g_new0 ( IRC_SERVER_CONNECT_REC , 1 ) ; rec -> chat_type = IRC_PROTOCOL ; rec -> max_cmds_at_once = src -> max_cmds_at_once ; rec -> cmd_queue_speed = src -> cmd_queue_speed ; rec -> max_query_chans = src -> max_query_chans ; rec -> max_kicks = src -> max_kicks ; rec -> max_modes = src -> max_modes ; rec -> max_msgs = src -> max_msgs ; rec -> max_whois = src -> max_whois ; rec -> usermode = g_strdup ( src -> usermode ) ; rec -> alternate_nick = g_strdup ( src -> alternate_nick ) ; rec -> sasl_mechanism = src -> sasl_mechanism ; <S2SV_StartBug> rec -> sasl_username = src -> sasl_username ; <S2SV_EndBug> <S2SV_StartBug> rec -> sasl_password = src -> sasl_password ; <S2SV_EndBug> * dest = ( SERVER_CONNECT_REC * ) rec ; }
CWE-416 static void sig_server_setup_fill_chatnet ( IRC_SERVER_CONNECT_REC * conn , IRC_CHATNET_REC * ircnet ) { if ( ! IS_IRC_SERVER_CONNECT ( conn ) ) return ; g_return_if_fail ( IS_IRCNET ( ircnet ) ) ; if ( ircnet -> alternate_nick != NULL ) { g_free_and_null ( conn -> alternate_nick ) ; conn -> alternate_nick = g_strdup ( ircnet -> alternate_nick ) ; } if ( ircnet -> usermode != NULL ) { g_free_and_null ( conn -> usermode ) ; conn -> usermode = g_strdup ( ircnet -> usermode ) ; } if ( ircnet -> max_kicks > 0 ) conn -> max_kicks = ircnet -> max_kicks ; if ( ircnet -> max_msgs > 0 ) conn -> max_msgs = ircnet -> max_msgs ; if ( ircnet -> max_modes > 0 ) conn -> max_modes = ircnet -> max_modes ; if ( ircnet -> max_whois > 0 ) conn -> max_whois = ircnet -> max_whois ; if ( ircnet -> max_cmds_at_once > 0 ) conn -> max_cmds_at_once = ircnet -> max_cmds_at_once ; if ( ircnet -> cmd_queue_speed > 0 ) conn -> cmd_queue_speed = ircnet -> cmd_queue_speed ; if ( ircnet -> max_query_chans > 0 ) conn -> max_query_chans = ircnet -> max_query_chans ; conn -> sasl_mechanism = SASL_MECHANISM_NONE ; conn -> sasl_username = NULL ; conn -> sasl_password = NULL ; if ( ircnet -> sasl_mechanism != NULL ) { if ( ! g_ascii_strcasecmp ( ircnet -> sasl_mechanism , "plain" ) ) { conn -> sasl_mechanism = SASL_MECHANISM_PLAIN ; if ( ircnet -> sasl_username != NULL && * ircnet -> sasl_username && ircnet -> sasl_password != NULL && * ircnet -> sasl_password ) { <S2SV_StartBug> conn -> sasl_username = ircnet -> sasl_username ; <S2SV_EndBug> conn -> sasl_password = ircnet -> sasl_password ; } else g_warning ( "The<S2SV_blank>fields<S2SV_blank>sasl_username<S2SV_blank>and<S2SV_blank>sasl_password<S2SV_blank>are<S2SV_blank>either<S2SV_blank>missing<S2SV_blank>or<S2SV_blank>empty" ) ; } else if ( ! g_ascii_strcasecmp ( ircnet -> sasl_mechanism , "external" ) ) { conn -> sasl_mechanism = SASL_MECHANISM_EXTERNAL ; } else g_warning ( "Unsupported<S2SV_blank>SASL<S2SV_blank>mechanism<S2SV_blank>\\"%s\\"<S2SV_blank>selected" , ircnet -> sasl_mechanism ) ; } }
CWE-476 static int fetch_token ( OnigToken * tok , UChar * * src , UChar * end , ScanEnv * env ) { int r , num ; OnigCodePoint c ; OnigEncoding enc = env -> enc ; const OnigSyntaxType * syn = env -> syntax ; UChar * prev ; UChar * p = * src ; PFETCH_READY ; start : if ( PEND ) { tok -> type = TK_EOT ; return tok -> type ; } tok -> type = TK_STRING ; tok -> base = 0 ; tok -> backp = p ; PFETCH ( c ) ; if ( IS_MC_ESC_CODE ( c , syn ) ) { if ( PEND ) return ONIGERR_END_PATTERN_AT_ESCAPE ; tok -> backp = p ; PFETCH ( c ) ; tok -> u . c = c ; tok -> escaped = 1 ; switch ( c ) { case '*' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_ASTERISK_ZERO_INF ) ) break ; tok -> type = TK_OP_REPEAT ; tok -> u . repeat . lower = 0 ; tok -> u . repeat . upper = REPEAT_INFINITE ; goto greedy_check ; break ; case '+' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_PLUS_ONE_INF ) ) break ; tok -> type = TK_OP_REPEAT ; tok -> u . repeat . lower = 1 ; tok -> u . repeat . upper = REPEAT_INFINITE ; goto greedy_check ; break ; case '?' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_QMARK_ZERO_ONE ) ) break ; tok -> type = TK_OP_REPEAT ; tok -> u . repeat . lower = 0 ; tok -> u . repeat . upper = 1 ; greedy_check : if ( ! PEND && PPEEK_IS ( '?' ) && IS_SYNTAX_OP ( syn , ONIG_SYN_OP_QMARK_NON_GREEDY ) ) { PFETCH ( c ) ; tok -> u . repeat . greedy = 0 ; tok -> u . repeat . possessive = 0 ; } else { possessive_check : if ( ! PEND && PPEEK_IS ( '+' ) && ( ( IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_PLUS_POSSESSIVE_REPEAT ) && tok -> type != TK_INTERVAL ) || ( IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_PLUS_POSSESSIVE_INTERVAL ) && tok -> type == TK_INTERVAL ) ) ) { PFETCH ( c ) ; tok -> u . repeat . greedy = 1 ; tok -> u . repeat . possessive = 1 ; } else { tok -> u . repeat . greedy = 1 ; tok -> u . repeat . possessive = 0 ; } } break ; case '{' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_BRACE_INTERVAL ) ) break ; r = fetch_range_quantifier ( & p , end , tok , env ) ; if ( r < 0 ) return r ; if ( r == 0 ) goto greedy_check ; else if ( r == 2 ) { if ( IS_SYNTAX_BV ( syn , ONIG_SYN_FIXED_INTERVAL_IS_GREEDY_ONLY ) ) goto possessive_check ; goto greedy_check ; } break ; case '|' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_VBAR_ALT ) ) break ; tok -> type = TK_ALT ; break ; case '(' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_LPAREN_SUBEXP ) ) break ; tok -> type = TK_SUBEXP_OPEN ; break ; case ')' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_LPAREN_SUBEXP ) ) break ; tok -> type = TK_SUBEXP_CLOSE ; break ; case 'w' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_W_WORD ) ) break ; tok -> type = TK_CHAR_TYPE ; tok -> u . prop . ctype = ONIGENC_CTYPE_WORD ; tok -> u . prop . not = 0 ; break ; case 'W' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_W_WORD ) ) break ; tok -> type = TK_CHAR_TYPE ; tok -> u . prop . ctype = ONIGENC_CTYPE_WORD ; tok -> u . prop . not = 1 ; break ; case 'b' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_B_WORD_BOUND ) ) break ; tok -> type = TK_ANCHOR ; tok -> u . anchor . subtype = ANCHOR_WORD_BOUND ; tok -> u . anchor . ascii_range = IS_ASCII_RANGE ( env -> option ) && ! IS_WORD_BOUND_ALL_RANGE ( env -> option ) ; break ; case 'B' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_B_WORD_BOUND ) ) break ; tok -> type = TK_ANCHOR ; tok -> u . anchor . subtype = ANCHOR_NOT_WORD_BOUND ; tok -> u . anchor . ascii_range = IS_ASCII_RANGE ( env -> option ) && ! IS_WORD_BOUND_ALL_RANGE ( env -> option ) ; break ; # ifdef USE_WORD_BEGIN_END case '<' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_LTGT_WORD_BEGIN_END ) ) break ; tok -> type = TK_ANCHOR ; tok -> u . anchor . subtype = ANCHOR_WORD_BEGIN ; tok -> u . anchor . ascii_range = IS_ASCII_RANGE ( env -> option ) ; break ; case '>' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_LTGT_WORD_BEGIN_END ) ) break ; tok -> type = TK_ANCHOR ; tok -> u . anchor . subtype = ANCHOR_WORD_END ; tok -> u . anchor . ascii_range = IS_ASCII_RANGE ( env -> option ) ; break ; # endif case 's' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_S_WHITE_SPACE ) ) break ; tok -> type = TK_CHAR_TYPE ; tok -> u . prop . ctype = ONIGENC_CTYPE_SPACE ; tok -> u . prop . not = 0 ; break ; case 'S' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_S_WHITE_SPACE ) ) break ; tok -> type = TK_CHAR_TYPE ; tok -> u . prop . ctype = ONIGENC_CTYPE_SPACE ; tok -> u . prop . not = 1 ; break ; case 'd' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_D_DIGIT ) ) break ; tok -> type = TK_CHAR_TYPE ; tok -> u . prop . ctype = ONIGENC_CTYPE_DIGIT ; tok -> u . prop . not = 0 ; break ; case 'D' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_D_DIGIT ) ) break ; tok -> type = TK_CHAR_TYPE ; tok -> u . prop . ctype = ONIGENC_CTYPE_DIGIT ; tok -> u . prop . not = 1 ; break ; case 'h' : if ( ! IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_ESC_H_XDIGIT ) ) break ; tok -> type = TK_CHAR_TYPE ; tok -> u . prop . ctype = ONIGENC_CTYPE_XDIGIT ; tok -> u . prop . not = 0 ; break ; case 'H' : if ( ! IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_ESC_H_XDIGIT ) ) break ; tok -> type = TK_CHAR_TYPE ; tok -> u . prop . ctype = ONIGENC_CTYPE_XDIGIT ; tok -> u . prop . not = 1 ; break ; case 'A' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_AZ_BUF_ANCHOR ) ) break ; begin_buf : tok -> type = TK_ANCHOR ; tok -> u . anchor . subtype = ANCHOR_BEGIN_BUF ; break ; case 'Z' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_AZ_BUF_ANCHOR ) ) break ; tok -> type = TK_ANCHOR ; tok -> u . anchor . subtype = ANCHOR_SEMI_END_BUF ; break ; case 'z' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_AZ_BUF_ANCHOR ) ) break ; end_buf : tok -> type = TK_ANCHOR ; tok -> u . anchor . subtype = ANCHOR_END_BUF ; break ; case 'G' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_CAPITAL_G_BEGIN_ANCHOR ) ) break ; tok -> type = TK_ANCHOR ; tok -> u . anchor . subtype = ANCHOR_BEGIN_POSITION ; break ; case '`' : if ( ! IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_ESC_GNU_BUF_ANCHOR ) ) break ; goto begin_buf ; break ; case '\\'' : if ( ! IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_ESC_GNU_BUF_ANCHOR ) ) break ; goto end_buf ; break ; case 'x' : if ( PEND ) break ; prev = p ; if ( PPEEK_IS ( '{' ) && IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_X_BRACE_HEX8 ) ) { PINC ; num = scan_unsigned_hexadecimal_number ( & p , end , 0 , 8 , enc ) ; if ( num < 0 ) return ONIGERR_TOO_BIG_WIDE_CHAR_VALUE ; if ( ! PEND ) { if ( ONIGENC_IS_CODE_XDIGIT ( enc , PPEEK ) ) return ONIGERR_TOO_LONG_WIDE_CHAR_VALUE ; } if ( ( p > prev + enclen ( enc , prev , end ) ) && ! PEND && PPEEK_IS ( '}' ) ) { PINC ; tok -> type = TK_CODE_POINT ; tok -> u . code = ( OnigCodePoint ) num ; } else { p = prev ; } } else if ( IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_X_HEX2 ) ) { num = scan_unsigned_hexadecimal_number ( & p , end , 0 , 2 , enc ) ; if ( num < 0 ) return ONIGERR_TOO_BIG_NUMBER ; if ( p == prev ) { num = 0 ; } tok -> type = TK_RAW_BYTE ; tok -> base = 16 ; tok -> u . c = num ; } break ; case 'u' : if ( PEND ) break ; prev = p ; if ( IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_ESC_U_HEX4 ) ) { num = scan_unsigned_hexadecimal_number ( & p , end , 4 , 4 , enc ) ; if ( num < - 1 ) return ONIGERR_TOO_SHORT_DIGITS ; else if ( num < 0 ) return ONIGERR_TOO_BIG_NUMBER ; if ( p == prev ) { num = 0 ; } tok -> type = TK_CODE_POINT ; tok -> base = 16 ; tok -> u . code = ( OnigCodePoint ) num ; } break ; case 'o' : if ( PEND ) break ; prev = p ; if ( PPEEK_IS ( '{' ) && IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_O_BRACE_OCTAL ) ) { PINC ; num = scan_unsigned_octal_number ( & p , end , 11 , enc ) ; if ( num < 0 ) return ONIGERR_TOO_BIG_WIDE_CHAR_VALUE ; if ( ! PEND ) { OnigCodePoint c = PPEEK ; if ( ONIGENC_IS_CODE_DIGIT ( enc , c ) && c < '8' ) return ONIGERR_TOO_LONG_WIDE_CHAR_VALUE ; } if ( ( p > prev + enclen ( enc , prev , end ) ) && ! PEND && PPEEK_IS ( '}' ) ) { PINC ; tok -> type = TK_CODE_POINT ; tok -> u . code = ( OnigCodePoint ) num ; } else { p = prev ; } } break ; case '1' : case '2' : case '3' : case '4' : case '5' : case '6' : case '7' : case '8' : case '9' : PUNFETCH ; prev = p ; num = onig_scan_unsigned_number ( & p , end , enc ) ; if ( num < 0 || num > ONIG_MAX_BACKREF_NUM ) { goto skip_backref ; } if ( IS_SYNTAX_OP ( syn , ONIG_SYN_OP_DECIMAL_BACKREF ) && ( num <= env -> num_mem || num <= 9 ) ) { if ( IS_SYNTAX_BV ( syn , ONIG_SYN_STRICT_CHECK_BACKREF ) ) { if ( num > env -> num_mem || IS_NULL ( SCANENV_MEM_NODES ( env ) [ num ] ) ) return ONIGERR_INVALID_BACKREF ; } tok -> type = TK_BACKREF ; tok -> u . backref . num = 1 ; tok -> u . backref . ref1 = num ; tok -> u . backref . by_name = 0 ; # ifdef USE_BACKREF_WITH_LEVEL tok -> u . backref . exist_level = 0 ; # endif break ; } skip_backref : if ( c == '8' || c == '9' ) { p = prev ; PINC ; break ; } p = prev ; case '0' : if ( IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_OCTAL3 ) ) { prev = p ; num = scan_unsigned_octal_number ( & p , end , ( c == '0' ? 2 : 3 ) , enc ) ; if ( num < 0 || 0xff < num ) return ONIGERR_TOO_BIG_NUMBER ; if ( p == prev ) { num = 0 ; } tok -> type = TK_RAW_BYTE ; tok -> base = 8 ; tok -> u . c = num ; } else if ( c != '0' ) { PINC ; } break ; # ifdef USE_NAMED_GROUP case 'k' : if ( ! PEND && IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_ESC_K_NAMED_BACKREF ) ) { PFETCH ( c ) ; if ( c == '<' || c == '\\'' ) { r = fetch_named_backref_token ( c , tok , & p , end , env ) ; if ( r < 0 ) return r ; } else { PUNFETCH ; onig_syntax_warn ( env , "invalid<S2SV_blank>back<S2SV_blank>reference" ) ; } } break ; # endif # if defined ( USE_SUBEXP_CALL ) || defined ( USE_NAMED_GROUP ) case 'g' : # ifdef USE_NAMED_GROUP if ( ! PEND && IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_ESC_G_BRACE_BACKREF ) ) { PFETCH ( c ) ; if ( c == '{' ) { r = fetch_named_backref_token ( c , tok , & p , end , env ) ; if ( r < 0 ) return r ; } else PUNFETCH ; } # endif # ifdef USE_SUBEXP_CALL if ( ! PEND && IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_ESC_G_SUBEXP_CALL ) ) { PFETCH ( c ) ; if ( c == '<' || c == '\\'' ) { int gnum = - 1 , rel = 0 ; UChar * name_end ; OnigCodePoint cnext ; cnext = PPEEK ; if ( cnext == '0' ) { PINC ; if ( PPEEK_IS ( get_name_end_code_point ( c ) ) ) { PINC ; name_end = p ; gnum = 0 ; } } else if ( cnext == '+' ) { PINC ; rel = 1 ; } prev = p ; if ( gnum < 0 ) { r = fetch_name ( ( OnigCodePoint ) c , & p , end , & name_end , env , & gnum , 1 ) ; if ( r < 0 ) return r ; } tok -> type = TK_CALL ; tok -> u . call . name = prev ; tok -> u . call . name_end = name_end ; tok -> u . call . gnum = gnum ; tok -> u . call . rel = rel ; } else { onig_syntax_warn ( env , "invalid<S2SV_blank>subexp<S2SV_blank>call" ) ; PUNFETCH ; } } # endif break ; # endif case 'Q' : if ( IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_ESC_CAPITAL_Q_QUOTE ) ) { tok -> type = TK_QUOTE_OPEN ; } break ; case 'p' : case 'P' : if ( PPEEK_IS ( '{' ) && IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_ESC_P_BRACE_CHAR_PROPERTY ) ) { PINC ; tok -> type = TK_CHAR_PROPERTY ; tok -> u . prop . not = ( c == 'P' ? 1 : 0 ) ; if ( ! PEND && IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_ESC_P_BRACE_CIRCUMFLEX_NOT ) ) { PFETCH ( c ) ; if ( c == '^' ) { tok -> u . prop . not = ( tok -> u . prop . not == 0 ? 1 : 0 ) ; } else PUNFETCH ; } } else { onig_syntax_warn ( env , "invalid<S2SV_blank>Unicode<S2SV_blank>Property<S2SV_blank>\\\\%c" , c ) ; } break ; case 'R' : if ( IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_ESC_CAPITAL_R_LINEBREAK ) ) { tok -> type = TK_LINEBREAK ; } break ; case 'X' : if ( IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_ESC_CAPITAL_X_EXTENDED_GRAPHEME_CLUSTER ) ) { tok -> type = TK_EXTENDED_GRAPHEME_CLUSTER ; } break ; case 'K' : if ( IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_ESC_CAPITAL_K_KEEP ) ) { tok -> type = TK_KEEP ; } break ; default : { OnigCodePoint c2 ; PUNFETCH ; num = fetch_escaped_value ( & p , end , env , & c2 ) ; if ( num < 0 ) return num ; if ( ( OnigCodePoint ) tok -> u . c != c2 ) { tok -> type = TK_CODE_POINT ; tok -> u . code = ( OnigCodePoint ) c2 ; } else { p = tok -> backp + enclen ( enc , tok -> backp , end ) ; } } break ; } } else { tok -> u . c = c ; tok -> escaped = 0 ; # ifdef USE_VARIABLE_META_CHARS if ( ( c != ONIG_INEFFECTIVE_META_CHAR ) && IS_SYNTAX_OP ( syn , ONIG_SYN_OP_VARIABLE_META_CHARACTERS ) ) { if ( c == MC_ANYCHAR ( syn ) ) goto any_char ; else if ( c == MC_ANYTIME ( syn ) ) goto anytime ; else if ( c == MC_ZERO_OR_ONE_TIME ( syn ) ) goto zero_or_one_time ; else if ( c == MC_ONE_OR_MORE_TIME ( syn ) ) goto one_or_more_time ; else if ( c == MC_ANYCHAR_ANYTIME ( syn ) ) { tok -> type = TK_ANYCHAR_ANYTIME ; goto out ; } } # endif switch ( c ) { case '.' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_DOT_ANYCHAR ) ) break ; # ifdef USE_VARIABLE_META_CHARS any_char : # endif tok -> type = TK_ANYCHAR ; break ; case '*' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ASTERISK_ZERO_INF ) ) break ; # ifdef USE_VARIABLE_META_CHARS anytime : # endif tok -> type = TK_OP_REPEAT ; tok -> u . repeat . lower = 0 ; tok -> u . repeat . upper = REPEAT_INFINITE ; goto greedy_check ; break ; case '+' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_PLUS_ONE_INF ) ) break ; # ifdef USE_VARIABLE_META_CHARS one_or_more_time : # endif tok -> type = TK_OP_REPEAT ; tok -> u . repeat . lower = 1 ; tok -> u . repeat . upper = REPEAT_INFINITE ; goto greedy_check ; break ; case '?' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_QMARK_ZERO_ONE ) ) break ; # ifdef USE_VARIABLE_META_CHARS zero_or_one_time : # endif tok -> type = TK_OP_REPEAT ; tok -> u . repeat . lower = 0 ; tok -> u . repeat . upper = 1 ; goto greedy_check ; break ; case '{' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_BRACE_INTERVAL ) ) break ; r = fetch_range_quantifier ( & p , end , tok , env ) ; if ( r < 0 ) return r ; if ( r == 0 ) goto greedy_check ; else if ( r == 2 ) { if ( IS_SYNTAX_BV ( syn , ONIG_SYN_FIXED_INTERVAL_IS_GREEDY_ONLY ) ) goto possessive_check ; goto greedy_check ; } break ; case '|' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_VBAR_ALT ) ) break ; tok -> type = TK_ALT ; break ; case '(' : if ( PPEEK_IS ( '?' ) && IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_QMARK_GROUP_EFFECT ) ) { PINC ; if ( PPEEK_IS ( '#' ) ) { PFETCH ( c ) ; while ( 1 ) { if ( PEND ) return ONIGERR_END_PATTERN_IN_GROUP ; PFETCH ( c ) ; if ( c == MC_ESC ( syn ) ) { if ( ! PEND ) PFETCH ( c ) ; } else { if ( c == ')' ) break ; } } goto start ; } # ifdef USE_PERL_SUBEXP_CALL c = PPEEK ; if ( ( c == '&' || c == 'R' || ONIGENC_IS_CODE_DIGIT ( enc , c ) ) && IS_SYNTAX_OP2 ( env -> syntax , ONIG_SYN_OP2_QMARK_SUBEXP_CALL ) ) { int gnum ; UChar * name ; UChar * name_end ; if ( c == 'R' || c == '0' ) { PINC ; <S2SV_StartBug> if ( ! PPEEK_IS ( ')' ) ) return ONIGERR_INVALID_GROUP_NAME ; <S2SV_EndBug> PINC ; name_end = name = p ; gnum = 0 ; } else { int numref = 1 ; if ( c == '&' ) { PINC ; numref = 0 ; } name = p ; r = fetch_name ( ( OnigCodePoint ) '(' , & p , end , & name_end , env , & gnum , numref ) ; if ( r < 0 ) return r ; } tok -> type = TK_CALL ; tok -> u . call . name = name ; tok -> u . call . name_end = name_end ; tok -> u . call . gnum = gnum ; tok -> u . call . rel = 0 ; break ; } else if ( ( c == '-' || c == '+' ) && IS_SYNTAX_OP2 ( env -> syntax , ONIG_SYN_OP2_QMARK_SUBEXP_CALL ) ) { int gnum ; UChar * name ; UChar * name_end ; OnigCodePoint cnext ; PFETCH_READY ; PINC ; cnext = PPEEK ; if ( ONIGENC_IS_CODE_DIGIT ( enc , cnext ) ) { if ( c == '-' ) PUNFETCH ; name = p ; r = fetch_name ( ( OnigCodePoint ) '(' , & p , end , & name_end , env , & gnum , 1 ) ; if ( r < 0 ) return r ; tok -> type = TK_CALL ; tok -> u . call . name = name ; tok -> u . call . name_end = name_end ; tok -> u . call . gnum = gnum ; tok -> u . call . rel = 1 ; break ; } } # endif # ifdef USE_CAPITAL_P_NAMED_GROUP if ( PPEEK_IS ( 'P' ) && IS_SYNTAX_OP2 ( env -> syntax , ONIG_SYN_OP2_QMARK_CAPITAL_P_NAMED_GROUP ) ) { int gnum ; UChar * name ; UChar * name_end ; PFETCH_READY ; PINC ; if ( PEND ) return ONIGERR_UNDEFINED_GROUP_OPTION ; PFETCH ( c ) ; if ( c == '=' ) { r = fetch_named_backref_token ( ( OnigCodePoint ) '(' , tok , & p , end , env ) ; if ( r < 0 ) return r ; break ; } else if ( c == '>' ) { name = p ; r = fetch_name ( ( OnigCodePoint ) '(' , & p , end , & name_end , env , & gnum , 0 ) ; if ( r < 0 ) return r ; tok -> type = TK_CALL ; tok -> u . call . name = name ; tok -> u . call . name_end = name_end ; tok -> u . call . gnum = gnum ; tok -> u . call . rel = 0 ; break ; } } # endif PUNFETCH ; } if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_LPAREN_SUBEXP ) ) break ; tok -> type = TK_SUBEXP_OPEN ; break ; case ')' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_LPAREN_SUBEXP ) ) break ; tok -> type = TK_SUBEXP_CLOSE ; break ; case '^' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_LINE_ANCHOR ) ) break ; tok -> type = TK_ANCHOR ; tok -> u . anchor . subtype = ( IS_SINGLELINE ( env -> option ) ? ANCHOR_BEGIN_BUF : ANCHOR_BEGIN_LINE ) ; break ; case '$' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_LINE_ANCHOR ) ) break ; tok -> type = TK_ANCHOR ; tok -> u . anchor . subtype = ( IS_SINGLELINE ( env -> option ) ? ANCHOR_SEMI_END_BUF : ANCHOR_END_LINE ) ; break ; case '[' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_BRACKET_CC ) ) break ; tok -> type = TK_CC_OPEN ; break ; case ']' : if ( * src > env -> pattern ) CLOSE_BRACKET_WITHOUT_ESC_WARN ( env , ( UChar * ) "]" ) ; break ; case '#' : if ( IS_EXTEND ( env -> option ) ) { while ( ! PEND ) { PFETCH ( c ) ; if ( ONIGENC_IS_CODE_NEWLINE ( enc , c ) ) break ; } goto start ; break ; } break ; case '<S2SV_blank>' : case '\\t' : case '\\n' : case '\\r' : case '\\f' : if ( IS_EXTEND ( env -> option ) ) goto start ; break ; default : break ; } } # ifdef USE_VARIABLE_META_CHARS out : # endif * src = p ; return tok -> type ; }
CWE-416 extern int onig_new_deluxe ( regex_t * * reg , const UChar * pattern , const UChar * pattern_end , OnigCompileInfo * ci , OnigErrorInfo * einfo ) { int r ; UChar * cpat , * cpat_end ; if ( IS_NOT_NULL ( einfo ) ) einfo -> par = ( UChar * ) NULL ; if ( ci -> pattern_enc != ci -> target_enc ) { <S2SV_StartBug> r = conv_encoding ( ci -> pattern_enc , ci -> target_enc , pattern , pattern_end , <S2SV_EndBug> & cpat , & cpat_end ) ; if ( r != 0 ) return r ; } else { cpat = ( UChar * ) pattern ; cpat_end = ( UChar * ) pattern_end ; } * reg = ( regex_t * ) xmalloc ( sizeof ( regex_t ) ) ; if ( IS_NULL ( * reg ) ) { r = ONIGERR_MEMORY ; goto err2 ; } r = onig_reg_init ( * reg , ci -> option , ci -> case_fold_flag , ci -> target_enc , ci -> syntax ) ; if ( r != 0 ) goto err ; r = onig_compile ( * reg , cpat , cpat_end , einfo ) ; if ( r != 0 ) { err : onig_free ( * reg ) ; * reg = NULL ; } err2 : if ( cpat != pattern ) xfree ( cpat ) ; return r ; }
CWE-400 static int parse_exp ( Node * * np , PToken * tok , int term , UChar * * src , UChar * end , ScanEnv * env , int group_head ) { <S2SV_StartBug> int r , len , group = 0 ; <S2SV_EndBug> Node * qn ; <S2SV_StartBug> Node * * tp ; <S2SV_EndBug> * np = NULL ; if ( tok -> type == ( enum TokenSyms ) term ) <S2SV_StartBug> goto end_of_token ; <S2SV_EndBug> switch ( tok -> type ) { case TK_ALT : case TK_EOT : end_of_token : * np = node_new_empty ( ) ; CHECK_NULL_RETURN_MEMERR ( * np ) ; return tok -> type ; break ; case TK_SUBEXP_OPEN : r = parse_bag ( np , tok , TK_SUBEXP_CLOSE , src , end , env ) ; if ( r < 0 ) return r ; if ( r == 1 ) { if ( group_head == 0 ) group = 1 ; else { Node * target = * np ; * np = node_new_group ( target ) ; if ( IS_NULL ( * np ) ) { onig_node_free ( target ) ; return ONIGERR_MEMORY ; } group = 2 ; } } else if ( r == 2 ) { Node * target ; OnigOptionType prev = env -> options ; env -> options = BAG_ ( * np ) -> o . options ; r = fetch_token ( tok , src , end , env ) ; if ( r < 0 ) return r ; r = parse_subexp ( & target , tok , term , src , end , env , 0 ) ; env -> options = prev ; if ( r < 0 ) { onig_node_free ( target ) ; return r ; } NODE_BODY ( * np ) = target ; return tok -> type ; } break ; case TK_SUBEXP_CLOSE : if ( ! IS_SYNTAX_BV ( env -> syntax , ONIG_SYN_ALLOW_UNMATCHED_CLOSE_SUBEXP ) ) return ONIGERR_UNMATCHED_CLOSE_PARENTHESIS ; if ( tok -> escaped ) goto tk_raw_byte ; else goto tk_byte ; break ; case TK_STRING : tk_byte : { * np = node_new_str ( tok -> backp , * src ) ; CHECK_NULL_RETURN_MEMERR ( * np ) ; while ( 1 ) { r = fetch_token ( tok , src , end , env ) ; if ( r < 0 ) return r ; if ( r != TK_STRING ) break ; r = onig_node_str_cat ( * np , tok -> backp , * src ) ; if ( r < 0 ) return r ; } string_end : tp = np ; goto repeat ; } break ; case TK_RAW_BYTE : tk_raw_byte : { * np = node_new_str_raw_char ( ( UChar ) tok -> u . c ) ; CHECK_NULL_RETURN_MEMERR ( * np ) ; len = 1 ; while ( 1 ) { if ( len >= ONIGENC_MBC_MINLEN ( env -> enc ) ) { if ( len == enclen ( env -> enc , STR_ ( * np ) -> s ) ) { r = fetch_token ( tok , src , end , env ) ; goto tk_raw_byte_end ; } } r = fetch_token ( tok , src , end , env ) ; if ( r < 0 ) return r ; if ( r != TK_RAW_BYTE ) return ONIGERR_TOO_SHORT_MULTI_BYTE_STRING ; r = node_str_cat_char ( * np , ( UChar ) tok -> u . c ) ; if ( r < 0 ) return r ; len ++ ; } tk_raw_byte_end : if ( ! ONIGENC_IS_VALID_MBC_STRING ( env -> enc , STR_ ( * np ) -> s , STR_ ( * np ) -> end ) ) return ONIGERR_INVALID_WIDE_CHAR_VALUE ; NODE_STRING_CLEAR_RAW ( * np ) ; goto string_end ; } break ; case TK_CODE_POINT : { UChar buf [ ONIGENC_CODE_TO_MBC_MAXLEN ] ; len = ONIGENC_CODE_TO_MBC ( env -> enc , tok -> u . code , buf ) ; if ( len < 0 ) return len ; # ifdef NUMBERED_CHAR_IS_NOT_CASE_AMBIG * np = node_new_str_raw ( buf , buf + len ) ; # else * np = node_new_str ( buf , buf + len ) ; # endif CHECK_NULL_RETURN_MEMERR ( * np ) ; } break ; case TK_QUOTE_OPEN : { OnigCodePoint end_op [ 2 ] ; UChar * qstart , * qend , * nextp ; end_op [ 0 ] = ( OnigCodePoint ) MC_ESC ( env -> syntax ) ; end_op [ 1 ] = ( OnigCodePoint ) 'E' ; qstart = * src ; qend = find_str_position ( end_op , 2 , qstart , end , & nextp , env -> enc ) ; if ( IS_NULL ( qend ) ) { nextp = qend = end ; } * np = node_new_str ( qstart , qend ) ; CHECK_NULL_RETURN_MEMERR ( * np ) ; * src = nextp ; } break ; case TK_CHAR_TYPE : { switch ( tok -> u . prop . ctype ) { case ONIGENC_CTYPE_WORD : * np = node_new_ctype ( tok -> u . prop . ctype , tok -> u . prop . not , env -> options ) ; CHECK_NULL_RETURN_MEMERR ( * np ) ; break ; case ONIGENC_CTYPE_SPACE : case ONIGENC_CTYPE_DIGIT : case ONIGENC_CTYPE_XDIGIT : { CClassNode * cc ; * np = node_new_cclass ( ) ; CHECK_NULL_RETURN_MEMERR ( * np ) ; cc = CCLASS_ ( * np ) ; add_ctype_to_cc ( cc , tok -> u . prop . ctype , 0 , env ) ; if ( tok -> u . prop . not != 0 ) NCCLASS_SET_NOT ( cc ) ; } break ; default : return ONIGERR_PARSER_BUG ; break ; } } break ; case TK_CHAR_PROPERTY : r = parse_char_property ( np , tok , src , end , env ) ; if ( r != 0 ) return r ; break ; case TK_CC_OPEN : { CClassNode * cc ; r = parse_char_class ( np , tok , src , end , env ) ; if ( r != 0 ) return r ; cc = CCLASS_ ( * np ) ; if ( IS_IGNORECASE ( env -> options ) ) { IApplyCaseFoldArg iarg ; iarg . env = env ; iarg . cc = cc ; iarg . alt_root = NULL_NODE ; iarg . ptail = & ( iarg . alt_root ) ; r = ONIGENC_APPLY_ALL_CASE_FOLD ( env -> enc , env -> case_fold_flag , i_apply_case_fold , & iarg ) ; if ( r != 0 ) { onig_node_free ( iarg . alt_root ) ; return r ; } if ( IS_NOT_NULL ( iarg . alt_root ) ) { Node * work = onig_node_new_alt ( * np , iarg . alt_root ) ; if ( IS_NULL ( work ) ) { onig_node_free ( iarg . alt_root ) ; return ONIGERR_MEMORY ; } * np = work ; } } } break ; case TK_ANYCHAR : * np = node_new_anychar ( ) ; CHECK_NULL_RETURN_MEMERR ( * np ) ; break ; case TK_ANYCHAR_ANYTIME : * np = node_new_anychar ( ) ; CHECK_NULL_RETURN_MEMERR ( * np ) ; qn = node_new_quantifier ( 0 , INFINITE_REPEAT , 0 ) ; CHECK_NULL_RETURN_MEMERR ( qn ) ; NODE_BODY ( qn ) = * np ; * np = qn ; break ; case TK_BACKREF : len = tok -> u . backref . num ; * np = node_new_backref ( len , ( len > 1 ? tok -> u . backref . refs : & ( tok -> u . backref . ref1 ) ) , tok -> u . backref . by_name , # ifdef USE_BACKREF_WITH_LEVEL tok -> u . backref . exist_level , tok -> u . backref . level , # endif env ) ; CHECK_NULL_RETURN_MEMERR ( * np ) ; break ; # ifdef USE_CALL case TK_CALL : { int gnum = tok -> u . call . gnum ; * np = node_new_call ( tok -> u . call . name , tok -> u . call . name_end , gnum , tok -> u . call . by_number ) ; CHECK_NULL_RETURN_MEMERR ( * np ) ; env -> num_call ++ ; if ( tok -> u . call . by_number != 0 && gnum == 0 ) { env -> has_call_zero = 1 ; } } break ; # endif case TK_ANCHOR : { int ascii_mode = IS_WORD_ASCII ( env -> options ) && IS_WORD_ANCHOR_TYPE ( tok -> u . anchor ) ? 1 : 0 ; * np = onig_node_new_anchor ( tok -> u . anchor , ascii_mode ) ; CHECK_NULL_RETURN_MEMERR ( * np ) ; } break ; case TK_REPEAT : case TK_INTERVAL : if ( IS_SYNTAX_BV ( env -> syntax , ONIG_SYN_CONTEXT_INDEP_REPEAT_OPS ) ) { if ( IS_SYNTAX_BV ( env -> syntax , ONIG_SYN_CONTEXT_INVALID_REPEAT_OPS ) ) return ONIGERR_TARGET_OF_REPEAT_OPERATOR_NOT_SPECIFIED ; else { * np = node_new_empty ( ) ; CHECK_NULL_RETURN_MEMERR ( * np ) ; } } else { goto tk_byte ; } break ; case TK_KEEP : r = node_new_keep ( np , env ) ; if ( r < 0 ) return r ; break ; case TK_GENERAL_NEWLINE : r = node_new_general_newline ( np , env ) ; if ( r < 0 ) return r ; break ; case TK_NO_NEWLINE : r = node_new_no_newline ( np , env ) ; if ( r < 0 ) return r ; break ; case TK_TRUE_ANYCHAR : r = node_new_true_anychar ( np , env ) ; if ( r < 0 ) return r ; break ; case TK_TEXT_SEGMENT : r = make_text_segment ( np , env ) ; if ( r < 0 ) return r ; break ; default : return ONIGERR_PARSER_BUG ; break ; } { tp = np ; re_entry : r = fetch_token ( tok , src , end , env ) ; if ( r < 0 ) return r ; repeat : if ( r == TK_REPEAT || r == TK_INTERVAL ) { Node * target ; if ( is_invalid_quantifier_target ( * tp ) ) return ONIGERR_TARGET_OF_REPEAT_OPERATOR_INVALID ; <S2SV_StartBug> qn = node_new_quantifier ( tok -> u . repeat . lower , tok -> u . repeat . upper , <S2SV_EndBug> r == TK_INTERVAL ) ; CHECK_NULL_RETURN_MEMERR ( qn ) ; QUANT_ ( qn ) -> greedy = tok -> u . repeat . greedy ; if ( group == 2 ) { target = node_drop_group ( * tp ) ; * tp = NULL_NODE ; } else { target = * tp ; } r = set_quantifier ( qn , target , group , env ) ; if ( r < 0 ) { onig_node_free ( qn ) ; return r ; } if ( tok -> u . repeat . possessive != 0 ) { Node * en ; en = node_new_bag ( BAG_STOP_BACKTRACK ) ; if ( IS_NULL ( en ) ) { onig_node_free ( qn ) ; return ONIGERR_MEMORY ; } NODE_BODY ( en ) = qn ; qn = en ; } if ( r == 0 ) { * tp = qn ; } else if ( r == 1 ) { onig_node_free ( qn ) ; * tp = target ; } else if ( r == 2 ) { Node * tmp ; * tp = node_new_list ( * tp , NULL ) ; if ( IS_NULL ( * tp ) ) { onig_node_free ( qn ) ; return ONIGERR_MEMORY ; } tmp = NODE_CDR ( * tp ) = node_new_list ( qn , NULL ) ; if ( IS_NULL ( tmp ) ) { onig_node_free ( qn ) ; return ONIGERR_MEMORY ; } tp = & ( NODE_CAR ( tmp ) ) ; } group = 0 ; goto re_entry ; } } return r ; }
CWE-476 static int compile_bag_node ( BagNode * node , regex_t * reg , ScanEnv * env ) { int r , len ; switch ( node -> type ) { case BAG_MEMORY : r = compile_bag_memory_node ( node , reg , env ) ; break ; case BAG_OPTION : r = compile_option_node ( node , reg , env ) ; break ; case BAG_STOP_BACKTRACK : if ( NODE_IS_STOP_BT_SIMPLE_REPEAT ( node ) ) { QuantNode * qn = QUANT_ ( NODE_BAG_BODY ( node ) ) ; r = compile_tree_n_times ( NODE_QUANT_BODY ( qn ) , qn -> lower , reg , env ) ; if ( r != 0 ) return r ; len = compile_length_tree ( NODE_QUANT_BODY ( qn ) , reg ) ; if ( len < 0 ) return len ; r = add_op ( reg , OP_PUSH ) ; if ( r != 0 ) return r ; COP ( reg ) -> push . addr = SIZE_INC_OP + len + SIZE_OP_POP_OUT + SIZE_OP_JUMP ; r = compile_tree ( NODE_QUANT_BODY ( qn ) , reg , env ) ; if ( r != 0 ) return r ; r = add_op ( reg , OP_POP_OUT ) ; if ( r != 0 ) return r ; r = add_op ( reg , OP_JUMP ) ; if ( r != 0 ) return r ; COP ( reg ) -> jump . addr = - ( ( int ) SIZE_OP_PUSH + len + ( int ) SIZE_OP_POP_OUT ) ; } else { r = add_op ( reg , OP_ATOMIC_START ) ; if ( r != 0 ) return r ; r = compile_tree ( NODE_BAG_BODY ( node ) , reg , env ) ; if ( r != 0 ) return r ; r = add_op ( reg , OP_ATOMIC_END ) ; } break ; case BAG_IF_ELSE : { <S2SV_StartBug> int cond_len , then_len , jump_len ; <S2SV_EndBug> Node * cond = NODE_BAG_BODY ( node ) ; Node * Then = node -> te . Then ; Node * Else = node -> te . Else ; r = add_op ( reg , OP_ATOMIC_START ) ; if ( r != 0 ) return r ; cond_len = compile_length_tree ( cond , reg ) ; if ( cond_len < 0 ) return cond_len ; if ( IS_NOT_NULL ( Then ) ) { then_len = compile_length_tree ( Then , reg ) ; if ( then_len < 0 ) return then_len ; } else then_len = 0 ; <S2SV_StartBug> jump_len = cond_len + then_len + SIZE_OP_ATOMIC_END ; <S2SV_EndBug> if ( IS_NOT_NULL ( Else ) ) jump_len += SIZE_OP_JUMP ; r = add_op ( reg , OP_PUSH ) ; if ( r != 0 ) return r ; COP ( reg ) -> push . addr = SIZE_INC_OP + jump_len ; r = compile_tree ( cond , reg , env ) ; if ( r != 0 ) return r ; r = add_op ( reg , OP_ATOMIC_END ) ; if ( r != 0 ) return r ; if ( IS_NOT_NULL ( Then ) ) { r = compile_tree ( Then , reg , env ) ; if ( r != 0 ) return r ; } if ( IS_NOT_NULL ( Else ) ) { <S2SV_StartBug> int else_len = compile_length_tree ( Else , reg ) ; <S2SV_EndBug> r = add_op ( reg , OP_JUMP ) ; if ( r != 0 ) return r ; <S2SV_StartBug> COP ( reg ) -> jump . addr = else_len + SIZE_INC_OP ; <S2SV_EndBug> <S2SV_StartBug> r = compile_tree ( Else , reg , env ) ; <S2SV_EndBug> } } break ; } return r ; }
CWE-476 static int compile_length_bag_node ( BagNode * node , regex_t * reg ) { int len ; int tlen ; if ( node -> type == BAG_OPTION ) return compile_length_option_node ( node , reg ) ; if ( NODE_BAG_BODY ( node ) ) { tlen = compile_length_tree ( NODE_BAG_BODY ( node ) , reg ) ; if ( tlen < 0 ) return tlen ; } else tlen = 0 ; switch ( node -> type ) { case BAG_MEMORY : # ifdef USE_CALL if ( node -> m . regnum == 0 && NODE_IS_CALLED ( node ) ) { len = tlen + SIZE_OP_CALL + SIZE_OP_JUMP + SIZE_OP_RETURN ; return len ; } if ( NODE_IS_CALLED ( node ) ) { len = SIZE_OP_MEMORY_START_PUSH + tlen + SIZE_OP_CALL + SIZE_OP_JUMP + SIZE_OP_RETURN ; if ( MEM_STATUS_AT0 ( reg -> bt_mem_end , node -> m . regnum ) ) len += ( NODE_IS_RECURSION ( node ) ? SIZE_OP_MEMORY_END_PUSH_REC : SIZE_OP_MEMORY_END_PUSH ) ; else len += ( NODE_IS_RECURSION ( node ) ? SIZE_OP_MEMORY_END_REC : SIZE_OP_MEMORY_END ) ; } else if ( NODE_IS_RECURSION ( node ) ) { len = SIZE_OP_MEMORY_START_PUSH ; len += tlen + ( MEM_STATUS_AT0 ( reg -> bt_mem_end , node -> m . regnum ) ? SIZE_OP_MEMORY_END_PUSH_REC : SIZE_OP_MEMORY_END_REC ) ; } else # endif { if ( MEM_STATUS_AT0 ( reg -> bt_mem_start , node -> m . regnum ) ) len = SIZE_OP_MEMORY_START_PUSH ; else len = SIZE_OP_MEMORY_START ; len += tlen + ( MEM_STATUS_AT0 ( reg -> bt_mem_end , node -> m . regnum ) ? SIZE_OP_MEMORY_END_PUSH : SIZE_OP_MEMORY_END ) ; } break ; case BAG_STOP_BACKTRACK : if ( NODE_IS_STOP_BT_SIMPLE_REPEAT ( node ) ) { int v ; QuantNode * qn ; qn = QUANT_ ( NODE_BAG_BODY ( node ) ) ; tlen = compile_length_tree ( NODE_QUANT_BODY ( qn ) , reg ) ; if ( tlen < 0 ) return tlen ; v = onig_positive_int_multiply ( qn -> lower , tlen ) ; if ( v < 0 ) return ONIGERR_TOO_BIG_NUMBER_FOR_REPEAT_RANGE ; len = v + SIZE_OP_PUSH + tlen + SIZE_OP_POP_OUT + SIZE_OP_JUMP ; } else { len = SIZE_OP_ATOMIC_START + tlen + SIZE_OP_ATOMIC_END ; } break ; case BAG_IF_ELSE : { Node * cond = NODE_BAG_BODY ( node ) ; Node * Then = node -> te . Then ; Node * Else = node -> te . Else ; len = compile_length_tree ( cond , reg ) ; if ( len < 0 ) return len ; len += SIZE_OP_PUSH ; len += SIZE_OP_ATOMIC_START + SIZE_OP_ATOMIC_END ; if ( IS_NOT_NULL ( Then ) ) { tlen = compile_length_tree ( Then , reg ) ; if ( tlen < 0 ) return tlen ; len += tlen ; } <S2SV_StartBug> if ( IS_NOT_NULL ( Else ) ) { <S2SV_EndBug> <S2SV_StartBug> len += SIZE_OP_JUMP ; <S2SV_EndBug> tlen = compile_length_tree ( Else , reg ) ; if ( tlen < 0 ) return tlen ; len += tlen ; } } break ; case BAG_OPTION : len = 0 ; break ; } return len ; }
CWE-119 void faad_resetbits ( bitfile * ld , int bits ) { uint32_t tmp ; int words = bits >> 5 ; int remainder = bits & 0x1F ; <S2SV_StartBug> ld -> bytes_left = ld -> buffer_size - words * 4 ; <S2SV_EndBug> if ( ld -> bytes_left >= 4 ) { tmp = getdword ( & ld -> start [ words ] ) ; ld -> bytes_left -= 4 ; } else { tmp = getdword_n ( & ld -> start [ words ] , ld -> bytes_left ) ; ld -> bytes_left = 0 ; } ld -> bufa = tmp ; if ( ld -> bytes_left >= 4 ) { tmp = getdword ( & ld -> start [ words + 1 ] ) ; ld -> bytes_left -= 4 ; } else { tmp = getdword_n ( & ld -> start [ words + 1 ] , ld -> bytes_left ) ; ld -> bytes_left = 0 ; } ld -> bufb = tmp ; ld -> bits_left = 32 - remainder ; ld -> tail = & ld -> start [ words + 2 ] ; ld -> error = 0 ; }
CWE-119 static uint8_t excluded_channels ( bitfile * ld , drc_info * drc ) { uint8_t i , n = 0 ; uint8_t num_excl_chan = 7 ; for ( i = 0 ; i < 7 ; i ++ ) { drc -> exclude_mask [ i ] = faad_get1bit ( ld DEBUGVAR ( 1 , 103 , "excluded_channels():<S2SV_blank>exclude_mask" ) ) ; } n ++ ; while ( ( drc -> additional_excluded_chns [ n - 1 ] = faad_get1bit ( ld DEBUGVAR ( 1 , 104 , "excluded_channels():<S2SV_blank>additional_excluded_chns" ) ) ) == 1 ) { <S2SV_StartBug> for ( i = num_excl_chan ; i < num_excl_chan + 7 ; i ++ ) <S2SV_EndBug> { drc -> exclude_mask [ i ] = faad_get1bit ( ld DEBUGVAR ( 1 , 105 , "excluded_channels():<S2SV_blank>exclude_mask" ) ) ; } n ++ ; num_excl_chan += 7 ; } return n ; }
CWE-119 static int chmd_read_headers ( struct mspack_system * sys , struct mspack_file * fh , struct mschmd_header * chm , int entire ) { unsigned int section , name_len , x , errors , num_chunks ; unsigned char buf [ 0x54 ] , * chunk = NULL , * name , * p , * end ; struct mschmd_file * fi , * link = NULL ; off_t offset , length ; int num_entries ; chm -> files = NULL ; chm -> sysfiles = NULL ; chm -> chunk_cache = NULL ; chm -> sec0 . base . chm = chm ; chm -> sec0 . base . id = 0 ; chm -> sec1 . base . chm = chm ; chm -> sec1 . base . id = 1 ; chm -> sec1 . content = NULL ; chm -> sec1 . control = NULL ; chm -> sec1 . spaninfo = NULL ; chm -> sec1 . rtable = NULL ; if ( sys -> read ( fh , & buf [ 0 ] , chmhead_SIZEOF ) != chmhead_SIZEOF ) { return MSPACK_ERR_READ ; } if ( EndGetI32 ( & buf [ chmhead_Signature ] ) != 0x46535449 ) { return MSPACK_ERR_SIGNATURE ; } if ( memcmp ( & buf [ chmhead_GUID1 ] , & guids [ 0 ] , 32L ) != 0 ) { D ( ( "incorrect<S2SV_blank>GUIDs" ) ) return MSPACK_ERR_SIGNATURE ; } chm -> version = EndGetI32 ( & buf [ chmhead_Version ] ) ; chm -> timestamp = EndGetM32 ( & buf [ chmhead_Timestamp ] ) ; chm -> language = EndGetI32 ( & buf [ chmhead_LanguageID ] ) ; if ( chm -> version > 3 ) { sys -> message ( fh , "WARNING;<S2SV_blank>CHM<S2SV_blank>version<S2SV_blank>><S2SV_blank>3" ) ; } if ( sys -> read ( fh , & buf [ 0 ] , chmhst3_SIZEOF ) != chmhst3_SIZEOF ) { return MSPACK_ERR_READ ; } if ( read_off64 ( & offset , & buf [ chmhst_OffsetHS0 ] , sys , fh ) || read_off64 ( & chm -> dir_offset , & buf [ chmhst_OffsetHS1 ] , sys , fh ) || read_off64 ( & chm -> sec0 . offset , & buf [ chmhst3_OffsetCS0 ] , sys , fh ) ) { return MSPACK_ERR_DATAFORMAT ; } if ( sys -> seek ( fh , offset , MSPACK_SYS_SEEK_START ) ) { return MSPACK_ERR_SEEK ; } if ( sys -> read ( fh , & buf [ 0 ] , chmhs0_SIZEOF ) != chmhs0_SIZEOF ) { return MSPACK_ERR_READ ; } if ( read_off64 ( & chm -> length , & buf [ chmhs0_FileLen ] , sys , fh ) ) { return MSPACK_ERR_DATAFORMAT ; } if ( sys -> seek ( fh , chm -> dir_offset , MSPACK_SYS_SEEK_START ) ) { return MSPACK_ERR_SEEK ; } if ( sys -> read ( fh , & buf [ 0 ] , chmhs1_SIZEOF ) != chmhs1_SIZEOF ) { return MSPACK_ERR_READ ; } chm -> dir_offset = sys -> tell ( fh ) ; chm -> chunk_size = EndGetI32 ( & buf [ chmhs1_ChunkSize ] ) ; chm -> density = EndGetI32 ( & buf [ chmhs1_Density ] ) ; chm -> depth = EndGetI32 ( & buf [ chmhs1_Depth ] ) ; chm -> index_root = EndGetI32 ( & buf [ chmhs1_IndexRoot ] ) ; chm -> num_chunks = EndGetI32 ( & buf [ chmhs1_NumChunks ] ) ; chm -> first_pmgl = EndGetI32 ( & buf [ chmhs1_FirstPMGL ] ) ; chm -> last_pmgl = EndGetI32 ( & buf [ chmhs1_LastPMGL ] ) ; if ( chm -> version < 3 ) { chm -> sec0 . offset = chm -> dir_offset + ( chm -> chunk_size * chm -> num_chunks ) ; } if ( chm -> sec0 . offset > chm -> length ) { D ( ( "content<S2SV_blank>section<S2SV_blank>begins<S2SV_blank>after<S2SV_blank>file<S2SV_blank>has<S2SV_blank>ended" ) ) return MSPACK_ERR_DATAFORMAT ; } if ( chm -> chunk_size < ( pmgl_Entries + 2 ) ) { D ( ( "chunk<S2SV_blank>size<S2SV_blank>not<S2SV_blank>large<S2SV_blank>enough" ) ) return MSPACK_ERR_DATAFORMAT ; } if ( chm -> num_chunks == 0 ) { D ( ( "no<S2SV_blank>chunks" ) ) return MSPACK_ERR_DATAFORMAT ; } if ( chm -> num_chunks > 100000 ) { D ( ( "more<S2SV_blank>than<S2SV_blank>100,000<S2SV_blank>chunks" ) ) return MSPACK_ERR_DATAFORMAT ; } if ( ( off_t ) chm -> chunk_size * ( off_t ) chm -> num_chunks > chm -> length ) { D ( ( "chunks<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>entire<S2SV_blank>file" ) ) return MSPACK_ERR_DATAFORMAT ; } if ( ( chm -> chunk_size & ( chm -> chunk_size - 1 ) ) != 0 ) { sys -> message ( fh , "WARNING;<S2SV_blank>chunk<S2SV_blank>size<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>power<S2SV_blank>of<S2SV_blank>two" ) ; } if ( chm -> first_pmgl != 0 ) { sys -> message ( fh , "WARNING;<S2SV_blank>first<S2SV_blank>PMGL<S2SV_blank>chunk<S2SV_blank>is<S2SV_blank>not<S2SV_blank>zero" ) ; } if ( chm -> first_pmgl > chm -> last_pmgl ) { D ( ( "first<S2SV_blank>pmgl<S2SV_blank>chunk<S2SV_blank>is<S2SV_blank>after<S2SV_blank>last<S2SV_blank>pmgl<S2SV_blank>chunk" ) ) return MSPACK_ERR_DATAFORMAT ; } if ( chm -> index_root != 0xFFFFFFFF && chm -> index_root >= chm -> num_chunks ) { D ( ( "index_root<S2SV_blank>outside<S2SV_blank>valid<S2SV_blank>range" ) ) return MSPACK_ERR_DATAFORMAT ; } if ( ! entire ) { return MSPACK_ERR_OK ; } if ( ( x = chm -> first_pmgl ) != 0 ) { if ( sys -> seek ( fh , ( off_t ) ( x * chm -> chunk_size ) , MSPACK_SYS_SEEK_CUR ) ) { return MSPACK_ERR_SEEK ; } } num_chunks = chm -> last_pmgl - x + 1 ; if ( ! ( chunk = ( unsigned char * ) sys -> alloc ( sys , ( size_t ) chm -> chunk_size ) ) ) { return MSPACK_ERR_NOMEMORY ; } errors = 0 ; while ( num_chunks -- ) { if ( sys -> read ( fh , chunk , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { sys -> free ( chunk ) ; return MSPACK_ERR_READ ; } if ( EndGetI32 ( & chunk [ pmgl_Signature ] ) != 0x4C474D50 ) continue ; if ( EndGetI32 ( & chunk [ pmgl_QuickRefSize ] ) < 2 ) { sys -> message ( fh , "WARNING;<S2SV_blank>PMGL<S2SV_blank>quickref<S2SV_blank>area<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small" ) ; } if ( EndGetI32 ( & chunk [ pmgl_QuickRefSize ] ) > ( ( int ) chm -> chunk_size - pmgl_Entries ) ) { sys -> message ( fh , "WARNING;<S2SV_blank>PMGL<S2SV_blank>quickref<S2SV_blank>area<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large" ) ; } p = & chunk [ pmgl_Entries ] ; end = & chunk [ chm -> chunk_size - 2 ] ; num_entries = EndGetI16 ( end ) ; while ( num_entries -- ) { READ_ENCINT ( name_len ) ; if ( name_len > ( unsigned int ) ( end - p ) ) goto chunk_end ; name = p ; p += name_len ; READ_ENCINT ( section ) ; READ_ENCINT ( offset ) ; READ_ENCINT ( length ) ; if ( name_len < 2 || ! name [ 0 ] || ! name [ 1 ] ) continue ; if ( ( offset == 0 ) && ( length == 0 ) ) { if ( ( name_len > 0 ) && ( name [ name_len - 1 ] == '/' ) ) continue ; } if ( section > 1 ) { sys -> message ( fh , "invalid<S2SV_blank>section<S2SV_blank>number<S2SV_blank>\'%u\'." , section ) ; continue ; } if ( ! ( fi = ( struct mschmd_file * ) sys -> alloc ( sys , sizeof ( struct mschmd_file ) + name_len + 1 ) ) ) { sys -> free ( chunk ) ; return MSPACK_ERR_NOMEMORY ; } fi -> next = NULL ; fi -> filename = ( char * ) & fi [ 1 ] ; fi -> section = ( ( section == 0 ) ? ( struct mschmd_section * ) ( & chm -> sec0 ) : ( struct mschmd_section * ) ( & chm -> sec1 ) ) ; fi -> offset = offset ; fi -> length = length ; sys -> copy ( name , fi -> filename , ( size_t ) name_len ) ; fi -> filename [ name_len ] = '\\0' ; if ( name [ 0 ] == ':' && name [ 1 ] == ':' ) { <S2SV_StartBug> if ( memcmp ( & name [ 2 ] , & content_name [ 2 ] , 31L ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> if ( memcmp ( & name [ 33 ] , & content_name [ 33 ] , 8L ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> chm -> sec1 . content = fi ; <S2SV_EndBug> } <S2SV_StartBug> else if ( memcmp ( & name [ 33 ] , & control_name [ 33 ] , 11L ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> chm -> sec1 . control = fi ; <S2SV_EndBug> } <S2SV_StartBug> else if ( memcmp ( & name [ 33 ] , & spaninfo_name [ 33 ] , 8L ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> chm -> sec1 . spaninfo = fi ; <S2SV_EndBug> } else if ( memcmp ( & name [ 33 ] , & rtable_name [ 33 ] , 72L ) == 0 ) { chm -> sec1 . rtable = fi ; <S2SV_StartBug> } <S2SV_EndBug> } fi -> next = chm -> sysfiles ; chm -> sysfiles = fi ; } else { if ( link ) link -> next = fi ; else chm -> files = fi ; link = fi ; } } chunk_end : if ( num_entries >= 0 ) { D ( ( "chunk<S2SV_blank>ended<S2SV_blank>before<S2SV_blank>all<S2SV_blank>entries<S2SV_blank>could<S2SV_blank>be<S2SV_blank>read" ) ) errors ++ ; } } sys -> free ( chunk ) ; return ( errors > 0 ) ? MSPACK_ERR_DATAFORMAT : MSPACK_ERR_OK ; }
CWE-399 static int archive_read_format_zip_cleanup ( struct archive_read * a ) { struct zip * zip ; struct zip_entry * zip_entry , * next_zip_entry ; zip = ( struct zip * ) ( a -> format -> data ) ; # ifdef HAVE_ZLIB_H if ( zip -> stream_valid ) inflateEnd ( & zip -> stream ) ; # endif <S2SV_StartBug> # if HAVA_LZMA_H && HAVE_LIBLZMA <S2SV_EndBug> if ( zip -> zipx_lzma_valid ) { lzma_end ( & zip -> zipx_lzma_stream ) ; } # endif # ifdef HAVE_BZLIB_H if ( zip -> bzstream_valid ) { BZ2_bzDecompressEnd ( & zip -> bzstream ) ; } # endif free ( zip -> uncompressed_buffer ) ; if ( zip -> ppmd8_valid ) __archive_ppmd8_functions . Ppmd8_Free ( & zip -> ppmd8 ) ; if ( zip -> zip_entries ) { zip_entry = zip -> zip_entries ; while ( zip_entry != NULL ) { next_zip_entry = zip_entry -> next ; archive_string_free ( & zip_entry -> rsrcname ) ; free ( zip_entry ) ; zip_entry = next_zip_entry ; } } free ( zip -> decrypted_buffer ) ; if ( zip -> cctx_valid ) archive_decrypto_aes_ctr_release ( & zip -> cctx ) ; if ( zip -> hctx_valid ) archive_hmac_sha1_cleanup ( & zip -> hctx ) ; free ( zip -> iv ) ; free ( zip -> erd ) ; free ( zip -> v_data ) ; archive_string_free ( & zip -> format_name ) ; free ( zip ) ; ( a -> format -> data ) = NULL ; return ( ARCHIVE_OK ) ; }
CWE-415 BGD_DECLARE ( void ) gdImageGifCtx ( gdImagePtr im , gdIOCtxPtr out ) { <S2SV_StartBug> gdImagePtr pim = 0 , tim = im ; <S2SV_EndBug> int interlace , BitsPerPixel ; interlace = im -> interlace ; if ( im -> trueColor ) { <S2SV_StartBug> pim = gdImageCreatePaletteFromTrueColor ( im , 1 , 256 ) ; <S2SV_EndBug> if ( ! pim ) { return ; } tim = pim ; } BitsPerPixel = colorstobpp ( tim -> colorsTotal ) ; GIFEncode ( out , tim -> sx , tim -> sy , interlace , 0 , tim -> transparent , BitsPerPixel , tim -> red , tim -> green , tim -> blue , tim ) ; if ( pim ) { gdImageDestroy ( pim ) ; } <S2SV_StartBug> } <S2SV_EndBug>
CWE-415 BGD_DECLARE ( void * ) gdImageGifPtr ( gdImagePtr im , int * size ) { void * rv ; gdIOCtx * out = gdNewDynamicCtx ( 2048 , NULL ) ; if ( out == NULL ) return NULL ; <S2SV_StartBug> gdImageGifCtx ( im , out ) ; <S2SV_EndBug> <S2SV_StartBug> rv = gdDPExtractData ( out , size ) ; <S2SV_EndBug> out -> gd_free ( out ) ; return rv ; }
CWE-415 BGD_DECLARE ( void ) gdImageWBMPCtx ( gdImagePtr image , int fg , gdIOCtx * out ) { <S2SV_StartBug> int x , y , pos ; <S2SV_EndBug> Wbmp * wbmp ; if ( ( wbmp = createwbmp ( gdImageSX ( image ) , gdImageSY ( image ) , WBMP_WHITE ) ) == NULL ) { gd_error ( "Could<S2SV_blank>not<S2SV_blank>create<S2SV_blank>WBMP\\n" ) ; return ; } pos = 0 ; for ( y = 0 ; y < gdImageSY ( image ) ; y ++ ) { for ( x = 0 ; x < gdImageSX ( image ) ; x ++ ) { <S2SV_StartBug> if ( gdImageGetPixel ( image , x , y ) == fg ) { <S2SV_EndBug> wbmp -> bitmap [ pos ] = WBMP_BLACK ; } pos ++ ; } } if ( writewbmp ( wbmp , & gd_putout , out ) ) { gd_error ( "Could<S2SV_blank>not<S2SV_blank>save<S2SV_blank>WBMP\\n" ) ; } freewbmp ( wbmp ) ; }
CWE-415 BGD_DECLARE ( void * ) gdImageWBMPPtr ( gdImagePtr im , int * size , int fg ) { void * rv ; gdIOCtx * out = gdNewDynamicCtx ( 2048 , NULL ) ; if ( out == NULL ) return NULL ; <S2SV_StartBug> gdImageWBMPCtx ( im , fg , out ) ; <S2SV_EndBug> <S2SV_StartBug> rv = gdDPExtractData ( out , size ) ; <S2SV_EndBug> out -> gd_free ( out ) ; return rv ; }
CWE-200 void * vips_malloc ( VipsObject * object , size_t size ) { void * buf ; <S2SV_StartBug> buf = g_malloc ( size ) ; <S2SV_EndBug> if ( object ) { g_signal_connect ( object , "postclose" , G_CALLBACK ( vips_malloc_cb ) , buf ) ; object -> local_memory += size ; } return ( buf ) ; }
CWE-200 void * vips_tracked_malloc ( size_t size ) { void * buf ; vips_tracked_init ( ) ; size += 16 ; <S2SV_StartBug> if ( ! ( buf = g_try_malloc ( size ) ) ) { <S2SV_EndBug> # ifdef DEBUG g_assert_not_reached ( ) ; # endif vips_error ( "vips_tracked" , _ ( "out<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>---<S2SV_blank>size<S2SV_blank>==<S2SV_blank>%dMB" ) , ( int ) ( size / ( 1024.0 * 1024.0 ) ) ) ; g_warning ( _ ( "out<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>---<S2SV_blank>size<S2SV_blank>==<S2SV_blank>%dMB" ) , ( int ) ( size / ( 1024.0 * 1024.0 ) ) ) ; return ( NULL ) ; } g_mutex_lock ( vips_tracked_mutex ) ; * ( ( size_t * ) buf ) = size ; buf = ( void * ) ( ( char * ) buf + 16 ) ; vips_tracked_mem += size ; if ( vips_tracked_mem > vips_tracked_mem_highwater ) vips_tracked_mem_highwater = vips_tracked_mem ; vips_tracked_allocs += 1 ; # ifdef DEBUG_VERBOSE printf ( "vips_tracked_malloc:<S2SV_blank>%p,<S2SV_blank>%zd<S2SV_blank>bytes\\n" , buf , size ) ; # endif g_mutex_unlock ( vips_tracked_mutex ) ; VIPS_GATE_MALLOC ( size ) ; return ( buf ) ; }
CWE-254 int virDomainGetTime ( virDomainPtr dom , long long * seconds , unsigned int * nseconds , unsigned int flags ) { VIR_DOMAIN_DEBUG ( dom , "seconds=%p,<S2SV_blank>nseconds=%p,<S2SV_blank>flags=%x" , seconds , nseconds , flags ) ; virResetLastError ( ) ; <S2SV_StartBug> virCheckDomainReturn ( dom , - 1 ) ; <S2SV_EndBug> if ( dom -> conn -> driver -> domainGetTime ) { int ret = dom -> conn -> driver -> domainGetTime ( dom , seconds , nseconds , flags ) ; if ( ret < 0 ) goto error ; return ret ; } virReportUnsupportedError ( ) ; error : virDispatchError ( dom -> conn ) ; return - 1 ; }
CWE-190 static int burl_normalize_2F_to_slash_fix ( buffer * b , int qs , int i ) { char * const s = b -> ptr ; const int blen = ( int ) buffer_string_length ( b ) ; const int used = qs < 0 ? blen : qs ; int j = i ; for ( ; i < used ; ++ i , ++ j ) { s [ j ] = s [ i ] ; if ( s [ i ] == '%' && s [ i + 1 ] == '2' && s [ i + 2 ] == 'F' ) { s [ j ] = '/' ; i += 2 ; } } if ( qs >= 0 ) { <S2SV_StartBug> memmove ( s + j , s + qs , blen - qs ) ; <S2SV_EndBug> <S2SV_StartBug> j += blen - qs ; <S2SV_EndBug> } buffer_string_set_length ( b , j ) ; return qs ; }
CWE-190 static void test_burl_normalize ( void ) { buffer * psrc = buffer_init ( ) ; buffer * ptmp = buffer_init ( ) ; int flags ; flags = HTTP_PARSEOPT_URL_NORMALIZE_UNRESERVED ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "no-slash" ) , CONST_STR_LEN ( "no-slash" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/" ) , CONST_STR_LEN ( "/" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/abc" ) , CONST_STR_LEN ( "/abc" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/abc/" ) , CONST_STR_LEN ( "/abc/" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/abc/def" ) , CONST_STR_LEN ( "/abc/def" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/abc?" ) , CONST_STR_LEN ( "/abc?" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/abc?d" ) , CONST_STR_LEN ( "/abc?d" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/abc?d=" ) , CONST_STR_LEN ( "/abc?d=" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/abc?d=e" ) , CONST_STR_LEN ( "/abc?d=e" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/abc?d=e&" ) , CONST_STR_LEN ( "/abc?d=e&" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/abc?d=e&f" ) , CONST_STR_LEN ( "/abc?d=e&f" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/abc?d=e&f=g" ) , CONST_STR_LEN ( "/abc?d=e&f=g" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/abc?d=e&f=g#" ) , CONST_STR_LEN ( "/abc?d=e&f=g" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/abc?d=e&f=g#any" ) , CONST_STR_LEN ( "/abc?d=e&f=g" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/%2F" ) , CONST_STR_LEN ( "/%2F" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/%2f" ) , CONST_STR_LEN ( "/%2F" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/%20" ) , CONST_STR_LEN ( "/%20" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/%2b" ) , CONST_STR_LEN ( "/%2B" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/%2B" ) , CONST_STR_LEN ( "/%2B" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/%3a" ) , CONST_STR_LEN ( "/%3A" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/%3A" ) , CONST_STR_LEN ( "/%3A" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/~test%20_" ) , CONST_STR_LEN ( "/~test%20%C3%A4_" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/\\375" ) , "" , ( size_t ) - 2 ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/\\376" ) , "" , ( size_t ) - 2 ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/\\377" ) , "" , ( size_t ) - 2 ) ; flags = HTTP_PARSEOPT_URL_NORMALIZE_REQUIRED ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/" ) , CONST_STR_LEN ( "/" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/abc" ) , CONST_STR_LEN ( "/abc" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/abc/" ) , CONST_STR_LEN ( "/abc/" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/abc/def" ) , CONST_STR_LEN ( "/abc/def" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/abc?" ) , CONST_STR_LEN ( "/abc?" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/abc?d" ) , CONST_STR_LEN ( "/abc?d" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/abc?d=" ) , CONST_STR_LEN ( "/abc?d=" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/abc?d=e" ) , CONST_STR_LEN ( "/abc?d=e" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/abc?d=e&" ) , CONST_STR_LEN ( "/abc?d=e&" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/abc?d=e&f" ) , CONST_STR_LEN ( "/abc?d=e&f" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/abc?d=e&f=g" ) , CONST_STR_LEN ( "/abc?d=e&f=g" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/abc?d=e&f=g#" ) , CONST_STR_LEN ( "/abc?d=e&f=g" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/abc?d=e&f=g#any" ) , CONST_STR_LEN ( "/abc?d=e&f=g" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/%2F" ) , CONST_STR_LEN ( "/%2F" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/%2f" ) , CONST_STR_LEN ( "/%2F" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/%20" ) , CONST_STR_LEN ( "/%20" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/%2b" ) , CONST_STR_LEN ( "/+" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/%2B" ) , CONST_STR_LEN ( "/+" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/%3a" ) , CONST_STR_LEN ( "/:" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/%3A" ) , CONST_STR_LEN ( "/:" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/~test%20_" ) , CONST_STR_LEN ( "/~test%20%C3%A4_" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/\\375" ) , "" , ( size_t ) - 2 ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/\\376" ) , "" , ( size_t ) - 2 ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/\\377" ) , "" , ( size_t ) - 2 ) ; flags |= HTTP_PARSEOPT_URL_NORMALIZE_CTRLS_REJECT ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/\\a" ) , "" , ( size_t ) - 2 ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/\\t" ) , "" , ( size_t ) - 2 ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/\\r" ) , "" , ( size_t ) - 2 ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/\\177" ) , "" , ( size_t ) - 2 ) ; # if defined ( __WIN32 ) || defined ( __CYGWIN__ ) flags |= HTTP_PARSEOPT_URL_NORMALIZE_PATH_BACKSLASH_TRANS ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/a\\\\b" ) , CONST_STR_LEN ( "/a/b" ) ) ; # endif flags |= HTTP_PARSEOPT_URL_NORMALIZE_PATH_2F_DECODE ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/a/b?c=/" ) , CONST_STR_LEN ( "/a/b?c=/" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/a/b?c=%2f" ) , CONST_STR_LEN ( "/a/b?c=/" ) ) ; <S2SV_StartBug> run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/a%2fb" ) , CONST_STR_LEN ( "/a/b" ) ) ; <S2SV_EndBug> run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/a%2Fb" ) , CONST_STR_LEN ( "/a/b" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/a%2fb?c=/" ) , CONST_STR_LEN ( "/a/b?c=/" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/a%2fb?c=%2f" ) , CONST_STR_LEN ( "/a/b?c=/" ) ) ; flags &= ~ HTTP_PARSEOPT_URL_NORMALIZE_PATH_2F_DECODE ; flags |= HTTP_PARSEOPT_URL_NORMALIZE_PATH_2F_REJECT ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/a%2fb" ) , "" , ( size_t ) - 2 ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/a%2Fb" ) , "" , ( size_t ) - 2 ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/a/b?c=%2f" ) , CONST_STR_LEN ( "/a/b?c=/" ) ) ; flags &= ~ HTTP_PARSEOPT_URL_NORMALIZE_PATH_2F_REJECT ; flags |= HTTP_PARSEOPT_URL_NORMALIZE_PATH_DOTSEG_REMOVE ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "./a/b" ) , CONST_STR_LEN ( "/a/b" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "../a/b" ) , CONST_STR_LEN ( "/a/b" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/a/./b" ) , CONST_STR_LEN ( "/a/b" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/a/../b" ) , CONST_STR_LEN ( "/b" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/a/b/." ) , CONST_STR_LEN ( "/a/b/" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/a/b/.." ) , CONST_STR_LEN ( "/a/" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/a/../b/.." ) , CONST_STR_LEN ( "/" ) ) ; flags &= ~ HTTP_PARSEOPT_URL_NORMALIZE_PATH_DOTSEG_REMOVE ; flags |= HTTP_PARSEOPT_URL_NORMALIZE_PATH_DOTSEG_REJECT ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "./a/b" ) , "" , ( size_t ) - 2 ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "../a/b" ) , "" , ( size_t ) - 2 ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/a/./b" ) , "" , ( size_t ) - 2 ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/a/../b" ) , "" , ( size_t ) - 2 ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/a/b/." ) , "" , ( size_t ) - 2 ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/a/b/.." ) , "" , ( size_t ) - 2 ) ; flags &= ~ HTTP_PARSEOPT_URL_NORMALIZE_PATH_DOTSEG_REJECT ; flags |= HTTP_PARSEOPT_URL_NORMALIZE_QUERY_20_PLUS ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/a/b?c=d+e" ) , CONST_STR_LEN ( "/a/b?c=d+e" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/a/b?c=d%20e" ) , CONST_STR_LEN ( "/a/b?c=d+e" ) ) ; flags &= ~ HTTP_PARSEOPT_URL_NORMALIZE_QUERY_20_PLUS ; buffer_free ( psrc ) ; buffer_free ( ptmp ) ; }
CWE-704 static void merge_param ( HashTable * params , zval * zdata , zval * * * current_param , zval * * * current_args TSRMLS_DC ) { zval * * ptr , * * zdata_ptr ; php_http_array_hashkey_t hkey = php_http_array_hashkey_init ( 0 ) ; # if 0 { zval tmp ; INIT_PZVAL_ARRAY ( & tmp , params ) ; fprintf ( stderr , "params<S2SV_blank>=<S2SV_blank>" ) ; zend_print_zval_r ( & tmp , 1 TSRMLS_CC ) ; fprintf ( stderr , "\\n" ) ; } # endif hkey . type = zend_hash_get_current_key_ex ( Z_ARRVAL_P ( zdata ) , & hkey . str , & hkey . len , & hkey . num , hkey . dup , NULL ) ; if ( ( hkey . type == HASH_KEY_IS_STRING && ! zend_hash_exists ( params , hkey . str , hkey . len ) ) || ( hkey . type == HASH_KEY_IS_LONG && ! zend_hash_index_exists ( params , hkey . num ) ) ) { zval * tmp , * arg , * * args ; zend_hash_get_current_data ( Z_ARRVAL_P ( zdata ) , ( void * ) & ptr ) ; Z_ADDREF_PP ( ptr ) ; MAKE_STD_ZVAL ( tmp ) ; array_init ( tmp ) ; add_assoc_zval_ex ( tmp , ZEND_STRS ( "value" ) , * ptr ) ; MAKE_STD_ZVAL ( arg ) ; array_init ( arg ) ; zend_hash_update ( Z_ARRVAL_P ( tmp ) , "arguments" , sizeof ( "arguments" ) , ( void * ) & arg , sizeof ( zval * ) , ( void * ) & args ) ; * current_args = args ; if ( hkey . type == HASH_KEY_IS_STRING ) { zend_hash_update ( params , hkey . str , hkey . len , ( void * ) & tmp , sizeof ( zval * ) , ( void * ) & ptr ) ; } else { zend_hash_index_update ( params , hkey . num , ( void * ) & tmp , sizeof ( zval * ) , ( void * ) & ptr ) ; } } else { if ( hkey . type == HASH_KEY_IS_STRING ) { zend_hash_find ( params , hkey . str , hkey . len , ( void * ) & ptr ) ; } else { zend_hash_index_find ( params , hkey . num , ( void * ) & ptr ) ; } zdata_ptr = & zdata ; if ( Z_TYPE_PP ( ptr ) == IS_ARRAY && SUCCESS == zend_hash_find ( Z_ARRVAL_PP ( ptr ) , "value" , sizeof ( "value" ) , ( void * ) & ptr ) && SUCCESS == zend_hash_get_current_data ( Z_ARRVAL_PP ( zdata_ptr ) , ( void * ) & zdata_ptr ) ) { zval * * test_ptr ; while ( Z_TYPE_PP ( zdata_ptr ) == IS_ARRAY && SUCCESS == zend_hash_get_current_data ( Z_ARRVAL_PP ( zdata_ptr ) , ( void * ) & test_ptr ) ) { <S2SV_StartBug> if ( Z_TYPE_PP ( test_ptr ) == IS_ARRAY ) { <S2SV_EndBug> if ( HASH_KEY_IS_STRING == zend_hash_get_current_key_ex ( Z_ARRVAL_PP ( zdata_ptr ) , & hkey . str , & hkey . len , & hkey . num , hkey . dup , NULL ) ) { if ( SUCCESS == zend_hash_find ( Z_ARRVAL_PP ( ptr ) , hkey . str , hkey . len , ( void * ) & ptr ) ) { zdata_ptr = test_ptr ; } else { Z_ADDREF_PP ( test_ptr ) ; zend_hash_update ( Z_ARRVAL_PP ( ptr ) , hkey . str , hkey . len , ( void * ) test_ptr , sizeof ( zval * ) , ( void * ) & ptr ) ; break ; } } else { if ( SUCCESS == zend_hash_index_find ( Z_ARRVAL_PP ( ptr ) , hkey . num , ( void * ) & ptr ) ) { zdata_ptr = test_ptr ; } else if ( hkey . num ) { Z_ADDREF_PP ( test_ptr ) ; zend_hash_index_update ( Z_ARRVAL_PP ( ptr ) , hkey . num , ( void * ) test_ptr , sizeof ( zval * ) , ( void * ) & ptr ) ; break ; } else { Z_ADDREF_PP ( test_ptr ) ; zend_hash_next_index_insert ( Z_ARRVAL_PP ( ptr ) , ( void * ) test_ptr , sizeof ( zval * ) , ( void * ) & ptr ) ; break ; } } } else { Z_ADDREF_PP ( test_ptr ) ; if ( Z_TYPE_PP ( ptr ) != IS_ARRAY ) { zval_dtor ( * ptr ) ; array_init ( * ptr ) ; } if ( HASH_KEY_IS_STRING == zend_hash_get_current_key_ex ( Z_ARRVAL_PP ( zdata_ptr ) , & hkey . str , & hkey . len , & hkey . num , hkey . dup , NULL ) ) { zend_hash_update ( Z_ARRVAL_PP ( ptr ) , hkey . str , hkey . len , ( void * ) test_ptr , sizeof ( zval * ) , ( void * ) & ptr ) ; } else if ( hkey . num ) { zend_hash_index_update ( Z_ARRVAL_PP ( ptr ) , hkey . num , ( void * ) test_ptr , sizeof ( zval * ) , ( void * ) & ptr ) ; } else { zend_hash_next_index_insert ( Z_ARRVAL_PP ( ptr ) , ( void * ) test_ptr , sizeof ( zval * ) , ( void * ) & ptr ) ; } break ; } } } } while ( Z_TYPE_PP ( ptr ) == IS_ARRAY && SUCCESS == zend_hash_get_current_data ( Z_ARRVAL_PP ( ptr ) , ( void * ) & ptr ) ) ; * current_param = ptr ; }
CWE-125 static inline void get_conn_text ( const conn * c , const int af , char * addr , struct sockaddr * sock_addr ) { char addr_text [ MAXPATHLEN ] ; addr_text [ 0 ] = '\\0' ; const char * protoname = "?" ; unsigned short port = 0 ; <S2SV_StartBug> switch ( af ) { <S2SV_EndBug> case AF_INET : ( void ) inet_ntop ( af , & ( ( struct sockaddr_in * ) sock_addr ) -> sin_addr , addr_text , sizeof ( addr_text ) - 1 ) ; port = ntohs ( ( ( struct sockaddr_in * ) sock_addr ) -> sin_port ) ; protoname = IS_UDP ( c -> transport ) ? "udp" : "tcp" ; break ; case AF_INET6 : addr_text [ 0 ] = '[' ; addr_text [ 1 ] = '\\0' ; if ( inet_ntop ( af , & ( ( struct sockaddr_in6 * ) sock_addr ) -> sin6_addr , addr_text + 1 , sizeof ( addr_text ) - 2 ) ) { strcat ( addr_text , "]" ) ; } port = ntohs ( ( ( struct sockaddr_in6 * ) sock_addr ) -> sin6_port ) ; protoname = IS_UDP ( c -> transport ) ? "udp6" : "tcp6" ; break ; case AF_UNIX : <S2SV_StartBug> strncpy ( addr_text , <S2SV_EndBug> <S2SV_StartBug> ( ( struct sockaddr_un * ) sock_addr ) -> sun_path , <S2SV_EndBug> sizeof ( addr_text ) - 1 ) ; addr_text [ sizeof ( addr_text ) - 1 ] = '\\0' ; protoname = "unix" ; break ; } if ( strlen ( addr_text ) < 2 ) { sprintf ( addr_text , "<AF<S2SV_blank>%d>" , af ) ; } if ( port ) { sprintf ( addr , "%s:%s:%u" , protoname , addr_text , port ) ; } else { sprintf ( addr , "%s:%s" , protoname , addr_text ) ; } }
CWE-476 static void process_lru_command ( conn * c , token_t * tokens , const size_t ntokens ) { uint32_t pct_hot ; uint32_t pct_warm ; double hot_factor ; int32_t ttl ; double factor ; set_noreply_maybe ( c , tokens , ntokens ) ; if ( strcmp ( tokens [ 1 ] . value , "tune" ) == 0 && ntokens >= 7 ) { if ( ! safe_strtoul ( tokens [ 2 ] . value , & pct_hot ) || ! safe_strtoul ( tokens [ 3 ] . value , & pct_warm ) || ! safe_strtod ( tokens [ 4 ] . value , & hot_factor ) || ! safe_strtod ( tokens [ 5 ] . value , & factor ) ) { out_string ( c , "ERROR" ) ; } else { if ( pct_hot + pct_warm > 80 ) { out_string ( c , "ERROR<S2SV_blank>hot<S2SV_blank>and<S2SV_blank>warm<S2SV_blank>pcts<S2SV_blank>must<S2SV_blank>not<S2SV_blank>exceed<S2SV_blank>80" ) ; } else if ( factor <= 0 || hot_factor <= 0 ) { out_string ( c , "ERROR<S2SV_blank>hot/warm<S2SV_blank>age<S2SV_blank>factors<S2SV_blank>must<S2SV_blank>be<S2SV_blank>greater<S2SV_blank>than<S2SV_blank>0" ) ; } else { settings . hot_lru_pct = pct_hot ; settings . warm_lru_pct = pct_warm ; settings . hot_max_factor = hot_factor ; settings . warm_max_factor = factor ; out_string ( c , "OK" ) ; } } <S2SV_StartBug> } else if ( strcmp ( tokens [ 1 ] . value , "mode" ) == 0 && ntokens >= 3 && <S2SV_EndBug> settings . lru_maintainer_thread ) { if ( strcmp ( tokens [ 2 ] . value , "flat" ) == 0 ) { settings . lru_segmented = false ; out_string ( c , "OK" ) ; } else if ( strcmp ( tokens [ 2 ] . value , "segmented" ) == 0 ) { settings . lru_segmented = true ; out_string ( c , "OK" ) ; } else { out_string ( c , "ERROR" ) ; } <S2SV_StartBug> } else if ( strcmp ( tokens [ 1 ] . value , "temp_ttl" ) == 0 && ntokens >= 3 && <S2SV_EndBug> settings . lru_maintainer_thread ) { if ( ! safe_strtol ( tokens [ 2 ] . value , & ttl ) ) { out_string ( c , "ERROR" ) ; } else { if ( ttl < 0 ) { settings . temp_lru = false ; } else { settings . temp_lru = true ; settings . temporary_ttl = ttl ; } out_string ( c , "OK" ) ; } } else { out_string ( c , "ERROR" ) ; } }
CWE-416 static int updateDevice ( const struct header * headers , time_t t ) { struct device * * pp = & devlist ; struct device * p = * pp ; while ( p ) { if ( p -> headers [ HEADER_NT ] . l == headers [ HEADER_NT ] . l && ( 0 == memcmp ( p -> headers [ HEADER_NT ] . p , headers [ HEADER_NT ] . p , headers [ HEADER_NT ] . l ) ) && p -> headers [ HEADER_USN ] . l == headers [ HEADER_USN ] . l && ( 0 == memcmp ( p -> headers [ HEADER_USN ] . p , headers [ HEADER_USN ] . p , headers [ HEADER_USN ] . l ) ) ) { syslog ( LOG_DEBUG , "device<S2SV_blank>updated<S2SV_blank>:<S2SV_blank>%.*s" , headers [ HEADER_USN ] . l , headers [ HEADER_USN ] . p ) ; p -> t = t ; if ( headers [ HEADER_LOCATION ] . l > p -> headers [ HEADER_LOCATION ] . l ) { struct device * tmp ; tmp = realloc ( p , sizeof ( struct device ) + headers [ 0 ] . l + headers [ 1 ] . l + headers [ 2 ] . l ) ; if ( ! tmp ) { syslog ( LOG_ERR , "updateDevice()<S2SV_blank>:<S2SV_blank>memory<S2SV_blank>allocation<S2SV_blank>error" ) ; <S2SV_StartBug> free ( p ) ; <S2SV_EndBug> return 0 ; } p = tmp ; * pp = p ; } memcpy ( p -> data + p -> headers [ 0 ] . l + p -> headers [ 1 ] . l , headers [ 2 ] . p , headers [ 2 ] . l ) ; return 0 ; } pp = & p -> next ; p = * pp ; } syslog ( LOG_INFO , "new<S2SV_blank>device<S2SV_blank>discovered<S2SV_blank>:<S2SV_blank>%.*s" , headers [ HEADER_USN ] . l , headers [ HEADER_USN ] . p ) ; { char * pc ; int i ; p = malloc ( sizeof ( struct device ) + headers [ 0 ] . l + headers [ 1 ] . l + headers [ 2 ] . l ) ; if ( ! p ) { syslog ( LOG_ERR , "updateDevice():<S2SV_blank>cannot<S2SV_blank>allocate<S2SV_blank>memory" ) ; return - 1 ; } p -> next = devlist ; p -> t = t ; pc = p -> data ; for ( i = 0 ; i < 3 ; i ++ ) { p -> headers [ i ] . p = pc ; p -> headers [ i ] . l = headers [ i ] . l ; memcpy ( pc , headers [ i ] . p , headers [ i ] . l ) ; pc += headers [ i ] . l ; } devlist = p ; sendNotifications ( NOTIF_NEW , p , NULL ) ; } return 1 ; }
CWE-476 int upnp_redirect ( const char * rhost , unsigned short eport , const char * iaddr , unsigned short iport , const char * protocol , const char * desc , unsigned int leaseduration ) { int proto , r ; char iaddr_old [ 32 ] ; char rhost_old [ 32 ] ; unsigned short iport_old ; struct in_addr address ; unsigned int timestamp ; proto = proto_atoi ( protocol ) ; if ( inet_aton ( iaddr , & address ) <= 0 ) { syslog ( LOG_ERR , "inet_aton(%s)<S2SV_blank>FAILED" , iaddr ) ; return - 1 ; } if ( ! check_upnp_rule_against_permissions ( upnppermlist , num_upnpperm , eport , address , iport ) ) { syslog ( LOG_INFO , "redirection<S2SV_blank>permission<S2SV_blank>check<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>" "%hu->%s:%hu<S2SV_blank>%s" , eport , iaddr , iport , protocol ) ; return - 3 ; } <S2SV_StartBug> rhost_old [ 0 ] = '\\0' ; <S2SV_EndBug> r = get_redirect_rule ( ext_if_name , eport , proto , iaddr_old , sizeof ( iaddr_old ) , & iport_old , 0 , 0 , rhost_old , sizeof ( rhost_old ) , & timestamp , 0 , 0 ) ; if ( r == 0 ) { if ( strcmp ( iaddr , iaddr_old ) == 0 && ( ( rhost == NULL && rhost_old [ 0 ] == '\\0' ) || ( rhost && ( strcmp ( rhost , "*" ) == 0 ) && rhost_old [ 0 ] == '\\0' ) || ( rhost && ( strcmp ( rhost , rhost_old ) == 0 ) ) ) ) { syslog ( LOG_INFO , "updating<S2SV_blank>existing<S2SV_blank>port<S2SV_blank>mapping<S2SV_blank>%hu<S2SV_blank>%s<S2SV_blank>(rhost<S2SV_blank>\'%s\')<S2SV_blank>=><S2SV_blank>%s:%hu" , eport , protocol , rhost_old , iaddr_old , iport_old ) ; timestamp = ( leaseduration > 0 ) ? upnp_time ( ) + leaseduration : 0 ; if ( iport != iport_old ) { r = update_portmapping ( ext_if_name , eport , proto , iport , desc , timestamp ) ; } else { r = update_portmapping_desc_timestamp ( ext_if_name , eport , proto , desc , timestamp ) ; } # ifdef ENABLE_LEASEFILE if ( r == 0 ) { lease_file_remove ( eport , proto ) ; lease_file_add ( eport , iaddr , iport , proto , desc , timestamp ) ; } # endif return r ; } else { syslog ( LOG_INFO , "port<S2SV_blank>%hu<S2SV_blank>%s<S2SV_blank>(rhost<S2SV_blank>\'%s\')<S2SV_blank>already<S2SV_blank>redirected<S2SV_blank>to<S2SV_blank>%s:%hu" , eport , protocol , rhost_old , iaddr_old , iport_old ) ; return - 2 ; } # ifdef CHECK_PORTINUSE } else if ( port_in_use ( ext_if_name , eport , proto , iaddr , iport ) > 0 ) { syslog ( LOG_INFO , "port<S2SV_blank>%hu<S2SV_blank>protocol<S2SV_blank>%s<S2SV_blank>already<S2SV_blank>in<S2SV_blank>use" , eport , protocol ) ; return - 4 ; # endif } else { timestamp = ( leaseduration > 0 ) ? upnp_time ( ) + leaseduration : 0 ; syslog ( LOG_INFO , "redirecting<S2SV_blank>port<S2SV_blank>%hu<S2SV_blank>to<S2SV_blank>%s:%hu<S2SV_blank>protocol<S2SV_blank>%s<S2SV_blank>for:<S2SV_blank>%s" , eport , iaddr , iport , protocol , desc ) ; return upnp_redirect_internal ( rhost , eport , iaddr , iport , proto , desc , timestamp ) ; } }
CWE-119 static void WritePixel ( struct ngiflib_img * i , struct ngiflib_decode_context * context , u8 v ) { struct ngiflib_gif * p = i -> parent ; if ( v != i -> gce . transparent_color || ! i -> gce . transparent_flag ) { # ifndef NGIFLIB_INDEXED_ONLY if ( p -> mode & NGIFLIB_MODE_INDEXED ) { # endif * context -> frbuff_p . p8 = v ; # ifndef NGIFLIB_INDEXED_ONLY } else * context -> frbuff_p . p32 = GifIndexToTrueColor ( i -> palette , v ) ; # endif } if ( -- ( context -> Xtogo ) <= 0 ) { # ifdef NGIFLIB_ENABLE_CALLBACKS if ( p -> line_cb ) p -> line_cb ( p , context -> line_p , context -> curY ) ; # endif context -> Xtogo = i -> width ; switch ( context -> pass ) { case 0 : context -> curY ++ ; break ; case 1 : context -> curY += 8 ; <S2SV_StartBug> if ( context -> curY >= p -> height ) { <S2SV_EndBug> context -> pass ++ ; context -> curY = i -> posY + 4 ; } break ; case 2 : context -> curY += 8 ; <S2SV_StartBug> if ( context -> curY >= p -> height ) { <S2SV_EndBug> context -> pass ++ ; context -> curY = i -> posY + 2 ; } break ; case 3 : context -> curY += 4 ; <S2SV_StartBug> if ( context -> curY >= p -> height ) { <S2SV_EndBug> context -> pass ++ ; context -> curY = i -> posY + 1 ; } break ; case 4 : context -> curY += 2 ; <S2SV_StartBug> break ; <S2SV_EndBug> } # ifndef NGIFLIB_INDEXED_ONLY if ( p -> mode & NGIFLIB_MODE_INDEXED ) { # endif # ifdef NGIFLIB_ENABLE_CALLBACKS context -> line_p . p8 = p -> frbuff . p8 + ( u32 ) context -> curY * p -> width ; context -> frbuff_p . p8 = context -> line_p . p8 + i -> posX ; # else context -> frbuff_p . p8 = p -> frbuff . p8 + ( u32 ) context -> curY * p -> width + i -> posX ; # endif # ifndef NGIFLIB_INDEXED_ONLY } else { # ifdef NGIFLIB_ENABLE_CALLBACKS context -> line_p . p32 = p -> frbuff . p32 + ( u32 ) context -> curY * p -> width ; context -> frbuff_p . p32 = context -> line_p . p32 + i -> posX ; # else context -> frbuff_p . p32 = p -> frbuff . p32 + ( u32 ) context -> curY * p -> width + i -> posX ; # endif } # endif } else { # ifndef NGIFLIB_INDEXED_ONLY if ( p -> mode & NGIFLIB_MODE_INDEXED ) { # endif context -> frbuff_p . p8 ++ ; # ifndef NGIFLIB_INDEXED_ONLY } else { context -> frbuff_p . p32 ++ ; } # endif } }
CWE-119 static void WritePixels ( struct ngiflib_img * i , struct ngiflib_decode_context * context , const u8 * pixels , u16 n ) { u16 tocopy ; struct ngiflib_gif * p = i -> parent ; while ( n > 0 ) { tocopy = ( context -> Xtogo < n ) ? context -> Xtogo : n ; if ( ! i -> gce . transparent_flag ) { # ifndef NGIFLIB_INDEXED_ONLY if ( p -> mode & NGIFLIB_MODE_INDEXED ) { # endif ngiflib_memcpy ( context -> frbuff_p . p8 , pixels , tocopy ) ; pixels += tocopy ; context -> frbuff_p . p8 += tocopy ; # ifndef NGIFLIB_INDEXED_ONLY } else { int j ; for ( j = ( int ) tocopy ; j > 0 ; j -- ) { * ( context -> frbuff_p . p32 ++ ) = GifIndexToTrueColor ( i -> palette , * pixels ++ ) ; } } # endif } else { int j ; # ifndef NGIFLIB_INDEXED_ONLY if ( p -> mode & NGIFLIB_MODE_INDEXED ) { # endif for ( j = ( int ) tocopy ; j > 0 ; j -- ) { if ( * pixels != i -> gce . transparent_color ) * context -> frbuff_p . p8 = * pixels ; pixels ++ ; context -> frbuff_p . p8 ++ ; } # ifndef NGIFLIB_INDEXED_ONLY } else { for ( j = ( int ) tocopy ; j > 0 ; j -- ) { if ( * pixels != i -> gce . transparent_color ) { * context -> frbuff_p . p32 = GifIndexToTrueColor ( i -> palette , * pixels ) ; } pixels ++ ; context -> frbuff_p . p32 ++ ; } } # endif } context -> Xtogo -= tocopy ; if ( context -> Xtogo == 0 ) { # ifdef NGIFLIB_ENABLE_CALLBACKS if ( p -> line_cb ) p -> line_cb ( p , context -> line_p , context -> curY ) ; # endif context -> Xtogo = i -> width ; switch ( context -> pass ) { case 0 : context -> curY ++ ; break ; case 1 : context -> curY += 8 ; <S2SV_StartBug> if ( context -> curY >= p -> height ) { <S2SV_EndBug> context -> pass ++ ; context -> curY = i -> posY + 4 ; } break ; case 2 : context -> curY += 8 ; <S2SV_StartBug> if ( context -> curY >= p -> height ) { <S2SV_EndBug> context -> pass ++ ; context -> curY = i -> posY + 2 ; } break ; case 3 : context -> curY += 4 ; <S2SV_StartBug> if ( context -> curY >= p -> height ) { <S2SV_EndBug> context -> pass ++ ; context -> curY = i -> posY + 1 ; } break ; case 4 : context -> curY += 2 ; <S2SV_StartBug> break ; <S2SV_EndBug> } # ifndef NGIFLIB_INDEXED_ONLY if ( p -> mode & NGIFLIB_MODE_INDEXED ) { # endif # ifdef NGIFLIB_ENABLE_CALLBACKS context -> line_p . p8 = p -> frbuff . p8 + ( u32 ) context -> curY * p -> width ; context -> frbuff_p . p8 = context -> line_p . p8 + i -> posX ; # else context -> frbuff_p . p8 = p -> frbuff . p8 + ( u32 ) context -> curY * p -> width + i -> posX ; # endif # ifndef NGIFLIB_INDEXED_ONLY } else { # ifdef NGIFLIB_ENABLE_CALLBACKS context -> line_p . p32 = p -> frbuff . p32 + ( u32 ) context -> curY * p -> width ; context -> frbuff_p . p32 = context -> line_p . p32 + i -> posX ; # else context -> frbuff_p . p32 = p -> frbuff . p32 + ( u32 ) context -> curY * p -> width + i -> posX ; # endif } # endif } n -= tocopy ; } }
CWE-284 void fslib_copy_libs ( const char * full_path ) { assert ( full_path ) ; if ( arg_debug || arg_debug_private_lib ) printf ( "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>fslib_copy_libs<S2SV_blank>%s\\n" , full_path ) ; if ( access ( full_path , R_OK ) ) { if ( arg_debug || arg_debug_private_lib ) printf ( "cannot<S2SV_blank>find<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>private-lib,<S2SV_blank>skipping...\\n" , full_path ) ; return ; } unlink ( RUN_LIB_FILE ) ; create_empty_file_as_root ( RUN_LIB_FILE , 0644 ) ; if ( chown ( RUN_LIB_FILE , getuid ( ) , getgid ( ) ) ) errExit ( "chown" ) ; if ( arg_debug || arg_debug_private_lib ) printf ( "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>running<S2SV_blank>fldd<S2SV_blank>%s\\n" , full_path ) ; sbox_run ( SBOX_USER | SBOX_SECCOMP | SBOX_CAPS_NONE , 3 , PATH_FLDD , full_path , RUN_LIB_FILE ) ; FILE * fp = fopen ( RUN_LIB_FILE , "r" ) ; if ( ! fp ) errExit ( "fopen" ) ; char buf [ MAXBUF ] ; while ( fgets ( buf , MAXBUF , fp ) ) { char * ptr = strchr ( buf , '\\n' ) ; if ( ptr ) * ptr = '\\0' ; fslib_duplicate ( buf ) ; } fclose ( fp ) ; <S2SV_StartBug> } <S2SV_EndBug>
CWE-284 void preproc_mount_mnt_dir ( void ) { if ( ! tmpfs_mounted ) { if ( arg_debug ) printf ( "Mounting<S2SV_blank>tmpfs<S2SV_blank>on<S2SV_blank>%s<S2SV_blank>directory\\n" , RUN_MNT_DIR ) ; if ( mount ( "tmpfs" , RUN_MNT_DIR , "tmpfs" , MS_NOSUID | MS_STRICTATIME , "mode=755,gid=0" ) < 0 ) errExit ( "mounting<S2SV_blank>/run/firejail/mnt" ) ; tmpfs_mounted = 1 ; fs_logger2 ( "tmpfs" , RUN_MNT_DIR ) ; # ifdef HAVE_SECCOMP <S2SV_StartBug> if ( arg_seccomp_block_secondary ) <S2SV_EndBug> copy_file ( PATH_SECCOMP_BLOCK_SECONDARY , RUN_SECCOMP_BLOCK_SECONDARY , getuid ( ) , getgid ( ) , 0644 ) ; else { copy_file ( PATH_SECCOMP_32 , RUN_SECCOMP_32 , getuid ( ) , getgid ( ) , 0644 ) ; } if ( arg_allow_debuggers ) copy_file ( PATH_SECCOMP_DEFAULT_DEBUG , RUN_SECCOMP_CFG , getuid ( ) , getgid ( ) , 0644 ) ; else copy_file ( PATH_SECCOMP_DEFAULT , RUN_SECCOMP_CFG , getuid ( ) , getgid ( ) , 0644 ) ; if ( arg_memory_deny_write_execute ) copy_file ( PATH_SECCOMP_MDWX , RUN_SECCOMP_MDWX , getuid ( ) , getgid ( ) , 0644 ) ; create_empty_file_as_root ( RUN_SECCOMP_PROTOCOL , 0644 ) ; if ( set_perms ( RUN_SECCOMP_PROTOCOL , getuid ( ) , getgid ( ) , 0644 ) ) errExit ( "set_perms" ) ; create_empty_file_as_root ( RUN_SECCOMP_POSTEXEC , 0644 ) ; if ( set_perms ( RUN_SECCOMP_POSTEXEC , getuid ( ) , getgid ( ) , 0644 ) ) errExit ( "set_perms" ) ; # endif } }
CWE-284 int sandbox ( void * sandbox_arg ) { ( void ) sandbox_arg ; pid_t child_pid = getpid ( ) ; if ( arg_debug ) printf ( "Initializing<S2SV_blank>child<S2SV_blank>process\\n" ) ; close ( parent_to_child_fds [ 1 ] ) ; close ( child_to_parent_fds [ 0 ] ) ; wait_for_other ( parent_to_child_fds [ 0 ] ) ; if ( arg_debug && child_pid == 1 ) printf ( "PID<S2SV_blank>namespace<S2SV_blank>installed\\n" ) ; if ( cfg . hostname ) { if ( sethostname ( cfg . hostname , strlen ( cfg . hostname ) ) < 0 ) errExit ( "sethostname" ) ; } if ( mount ( NULL , "/" , NULL , MS_SLAVE | MS_REC , NULL ) < 0 ) { chk_chroot ( ) ; } preproc_mount_mnt_dir ( ) ; if ( mount ( LIBDIR "/firejail" , RUN_FIREJAIL_LIB_DIR , "none" , MS_BIND , NULL ) < 0 ) errExit ( "mounting<S2SV_blank>" RUN_FIREJAIL_LIB_DIR ) ; if ( cfg . name ) fs_logger2 ( "sandbox<S2SV_blank>name:" , cfg . name ) ; fs_logger2int ( "sandbox<S2SV_blank>pid:" , ( int ) sandbox_pid ) ; if ( cfg . chrootdir ) fs_logger ( "sandbox<S2SV_blank>filesystem:<S2SV_blank>chroot" ) ; else if ( arg_overlay ) fs_logger ( "sandbox<S2SV_blank>filesystem:<S2SV_blank>overlay" ) ; else fs_logger ( "sandbox<S2SV_blank>filesystem:<S2SV_blank>local" ) ; fs_logger ( "install<S2SV_blank>mount<S2SV_blank>namespace" ) ; if ( arg_netfilter && any_bridge_configured ( ) ) { netfilter ( arg_netfilter_file ) ; } if ( arg_netfilter6 && any_bridge_configured ( ) ) { netfilter6 ( arg_netfilter6_file ) ; } int gw_cfg_failed = 0 ; if ( arg_nonetwork ) { net_if_up ( "lo" ) ; if ( arg_debug ) printf ( "Network<S2SV_blank>namespace<S2SV_blank>enabled,<S2SV_blank>only<S2SV_blank>loopback<S2SV_blank>interface<S2SV_blank>available\\n" ) ; } else if ( arg_netns ) { netns ( arg_netns ) ; if ( arg_debug ) printf ( "Network<S2SV_blank>namespace<S2SV_blank>\'%s\'<S2SV_blank>activated\\n" , arg_netns ) ; } else if ( any_bridge_configured ( ) || any_interface_configured ( ) ) { net_if_up ( "lo" ) ; if ( mac_not_zero ( cfg . bridge0 . macsandbox ) ) net_config_mac ( cfg . bridge0 . devsandbox , cfg . bridge0 . macsandbox ) ; sandbox_if_up ( & cfg . bridge0 ) ; if ( mac_not_zero ( cfg . bridge1 . macsandbox ) ) net_config_mac ( cfg . bridge1 . devsandbox , cfg . bridge1 . macsandbox ) ; sandbox_if_up ( & cfg . bridge1 ) ; if ( mac_not_zero ( cfg . bridge2 . macsandbox ) ) net_config_mac ( cfg . bridge2 . devsandbox , cfg . bridge2 . macsandbox ) ; sandbox_if_up ( & cfg . bridge2 ) ; if ( mac_not_zero ( cfg . bridge3 . macsandbox ) ) net_config_mac ( cfg . bridge3 . devsandbox , cfg . bridge3 . macsandbox ) ; sandbox_if_up ( & cfg . bridge3 ) ; if ( cfg . interface0 . configured && cfg . interface0 . ip ) { if ( arg_debug ) printf ( "Configuring<S2SV_blank>%d.%d.%d.%d<S2SV_blank>address<S2SV_blank>on<S2SV_blank>interface<S2SV_blank>%s\\n" , PRINT_IP ( cfg . interface0 . ip ) , cfg . interface0 . dev ) ; net_config_interface ( cfg . interface0 . dev , cfg . interface0 . ip , cfg . interface0 . mask , cfg . interface0 . mtu ) ; } if ( cfg . interface1 . configured && cfg . interface1 . ip ) { if ( arg_debug ) printf ( "Configuring<S2SV_blank>%d.%d.%d.%d<S2SV_blank>address<S2SV_blank>on<S2SV_blank>interface<S2SV_blank>%s\\n" , PRINT_IP ( cfg . interface1 . ip ) , cfg . interface1 . dev ) ; net_config_interface ( cfg . interface1 . dev , cfg . interface1 . ip , cfg . interface1 . mask , cfg . interface1 . mtu ) ; } if ( cfg . interface2 . configured && cfg . interface2 . ip ) { if ( arg_debug ) printf ( "Configuring<S2SV_blank>%d.%d.%d.%d<S2SV_blank>address<S2SV_blank>on<S2SV_blank>interface<S2SV_blank>%s\\n" , PRINT_IP ( cfg . interface2 . ip ) , cfg . interface2 . dev ) ; net_config_interface ( cfg . interface2 . dev , cfg . interface2 . ip , cfg . interface2 . mask , cfg . interface2 . mtu ) ; } if ( cfg . interface3 . configured && cfg . interface3 . ip ) { if ( arg_debug ) printf ( "Configuring<S2SV_blank>%d.%d.%d.%d<S2SV_blank>address<S2SV_blank>on<S2SV_blank>interface<S2SV_blank>%s\\n" , PRINT_IP ( cfg . interface3 . ip ) , cfg . interface3 . dev ) ; net_config_interface ( cfg . interface3 . dev , cfg . interface3 . ip , cfg . interface3 . mask , cfg . interface3 . mtu ) ; } if ( cfg . defaultgw ) { if ( net_add_route ( 0 , 0 , cfg . defaultgw ) ) { fwarning ( "cannot<S2SV_blank>configure<S2SV_blank>default<S2SV_blank>route\\n" ) ; gw_cfg_failed = 1 ; } } if ( arg_debug ) printf ( "Network<S2SV_blank>namespace<S2SV_blank>enabled\\n" ) ; } if ( ! arg_quiet ) { if ( any_bridge_configured ( ) || any_interface_configured ( ) || cfg . defaultgw || cfg . dns1 ) { fmessage ( "\\n" ) ; if ( any_bridge_configured ( ) || any_interface_configured ( ) ) { if ( arg_scan ) sbox_run ( SBOX_ROOT | SBOX_CAPS_NETWORK | SBOX_SECCOMP , 3 , PATH_FNET , "printif" , "scan" ) ; else sbox_run ( SBOX_ROOT | SBOX_CAPS_NETWORK | SBOX_SECCOMP , 2 , PATH_FNET , "printif" ) ; } if ( cfg . defaultgw != 0 ) { if ( gw_cfg_failed ) fmessage ( "Default<S2SV_blank>gateway<S2SV_blank>configuration<S2SV_blank>failed\\n" ) ; else fmessage ( "Default<S2SV_blank>gateway<S2SV_blank>%d.%d.%d.%d\\n" , PRINT_IP ( cfg . defaultgw ) ) ; } if ( cfg . dns1 != NULL ) fmessage ( "DNS<S2SV_blank>server<S2SV_blank>%s\\n" , cfg . dns1 ) ; if ( cfg . dns2 != NULL ) fmessage ( "DNS<S2SV_blank>server<S2SV_blank>%s\\n" , cfg . dns2 ) ; if ( cfg . dns3 != NULL ) fmessage ( "DNS<S2SV_blank>server<S2SV_blank>%s\\n" , cfg . dns3 ) ; if ( cfg . dns4 != NULL ) fmessage ( "DNS<S2SV_blank>server<S2SV_blank>%s\\n" , cfg . dns4 ) ; fmessage ( "\\n" ) ; } } if ( arg_nonetwork || any_bridge_configured ( ) || any_interface_configured ( ) ) { } else { EUID_USER ( ) ; env_ibus_load ( ) ; EUID_ROOT ( ) ; } # ifdef HAVE_SECCOMP if ( cfg . protocol ) { if ( arg_debug ) printf ( "Build<S2SV_blank>protocol<S2SV_blank>filter:<S2SV_blank>%s\\n" , cfg . protocol ) ; int rv = sbox_run ( SBOX_USER | SBOX_CAPS_NONE | SBOX_SECCOMP , 5 , PATH_FSECCOMP , "protocol" , "build" , cfg . protocol , RUN_SECCOMP_PROTOCOL ) ; if ( rv ) exit ( rv ) ; } if ( arg_seccomp && ( cfg . seccomp_list || cfg . seccomp_list_drop || cfg . seccomp_list_keep ) ) arg_seccomp_postexec = 1 ; # endif bool need_preload = arg_trace || arg_tracelog || arg_seccomp_postexec ; if ( getuid ( ) != 0 && ( arg_appimage || cfg . chrootdir || arg_overlay ) ) { enforce_filters ( ) ; need_preload = arg_trace || arg_tracelog ; } if ( need_preload ) fs_trace_preload ( ) ; if ( cfg . hosts_file ) fs_store_hosts_file ( ) ; # ifdef HAVE_CHROOT if ( cfg . chrootdir ) { fs_chroot ( cfg . chrootdir ) ; if ( need_preload ) fs_trace_preload ( ) ; } else # endif # ifdef HAVE_OVERLAYFS if ( arg_overlay ) fs_overlayfs ( ) ; else # endif fs_basic_fs ( ) ; if ( arg_private ) { if ( cfg . home_private ) { if ( cfg . chrootdir ) fwarning ( "private=directory<S2SV_blank>feature<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>chroot\\n" ) ; else if ( arg_overlay ) fwarning ( "private=directory<S2SV_blank>feature<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>overlay\\n" ) ; else fs_private_homedir ( ) ; } else if ( cfg . home_private_keep ) { if ( cfg . chrootdir ) fwarning ( "private-home=<S2SV_blank>feature<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>chroot\\n" ) ; else if ( arg_overlay ) fwarning ( "private-home=<S2SV_blank>feature<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>overlay\\n" ) ; else fs_private_home_list ( ) ; } else fs_private ( ) ; } if ( arg_private_dev ) fs_private_dev ( ) ; if ( arg_private_etc ) { if ( cfg . chrootdir ) fwarning ( "private-etc<S2SV_blank>feature<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>chroot\\n" ) ; else if ( arg_overlay ) fwarning ( "private-etc<S2SV_blank>feature<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>overlay\\n" ) ; else { fs_private_dir_list ( "/etc" , RUN_ETC_DIR , cfg . etc_private_keep ) ; if ( need_preload ) fs_trace_preload ( ) ; } } if ( arg_private_opt ) { if ( cfg . chrootdir ) fwarning ( "private-opt<S2SV_blank>feature<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>chroot\\n" ) ; else if ( arg_overlay ) fwarning ( "private-opt<S2SV_blank>feature<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>overlay\\n" ) ; else { fs_private_dir_list ( "/opt" , RUN_OPT_DIR , cfg . opt_private_keep ) ; } } if ( arg_private_srv ) { if ( cfg . chrootdir ) fwarning ( "private-srv<S2SV_blank>feature<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>chroot\\n" ) ; else if ( arg_overlay ) fwarning ( "private-srv<S2SV_blank>feature<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>overlay\\n" ) ; else { fs_private_dir_list ( "/srv" , RUN_SRV_DIR , cfg . srv_private_keep ) ; } } if ( arg_private_bin && ! arg_appimage ) { if ( cfg . chrootdir ) fwarning ( "private-bin<S2SV_blank>feature<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>chroot\\n" ) ; else if ( arg_overlay ) fwarning ( "private-bin<S2SV_blank>feature<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>overlay\\n" ) ; else { if ( arg_x11_xorg ) { EUID_USER ( ) ; char * tmp ; if ( asprintf ( & tmp , "%s,xauth" , cfg . bin_private_keep ) == - 1 ) errExit ( "asprintf" ) ; cfg . bin_private_keep = tmp ; EUID_ROOT ( ) ; } fs_private_bin_list ( ) ; } } if ( arg_private_lib && ! arg_appimage ) { if ( cfg . chrootdir ) fwarning ( "private-lib<S2SV_blank>feature<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>chroot\\n" ) ; else if ( arg_overlay ) fwarning ( "private-lib<S2SV_blank>feature<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>overlay\\n" ) ; else { fs_private_lib ( ) ; } } if ( arg_private_cache ) { if ( cfg . chrootdir ) fwarning ( "private-cache<S2SV_blank>feature<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>chroot\\n" ) ; else if ( arg_overlay ) fwarning ( "private-cache<S2SV_blank>feature<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>overlay\\n" ) ; else fs_private_cache ( ) ; } if ( arg_private_tmp ) { EUID_USER ( ) ; fs_private_tmp ( ) ; EUID_ROOT ( ) ; } if ( arg_nodbus ) dbus_session_disable ( ) ; if ( cfg . hostname ) fs_hostname ( cfg . hostname ) ; if ( cfg . hosts_file ) fs_mount_hosts_file ( ) ; if ( arg_netns ) netns_mounts ( arg_netns ) ; fs_proc_sys_dev_boot ( ) ; if ( checkcfg ( CFG_DISABLE_MNT ) ) fs_mnt ( 1 ) ; else if ( arg_disable_mnt ) fs_mnt ( 0 ) ; fs_whitelist ( ) ; fs_blacklist ( ) ; if ( arg_nosound ) { pulseaudio_disable ( ) ; fs_dev_disable_sound ( ) ; } else if ( ! arg_noautopulse ) pulseaudio_init ( ) ; if ( arg_no3d ) fs_dev_disable_3d ( ) ; if ( arg_notv ) fs_dev_disable_tv ( ) ; if ( arg_nodvd ) fs_dev_disable_dvd ( ) ; if ( arg_nou2f ) fs_dev_disable_u2f ( ) ; if ( arg_novideo ) fs_dev_disable_video ( ) ; if ( need_preload ) fs_trace ( ) ; fs_resolvconf ( ) ; fs_logger_print ( ) ; fs_logger_change_owner ( ) ; EUID_USER ( ) ; int cwd = 0 ; if ( cfg . cwd ) { if ( chdir ( cfg . cwd ) == 0 ) cwd = 1 ; } if ( ! cwd ) { if ( chdir ( "/" ) < 0 ) errExit ( "chdir" ) ; if ( cfg . homedir ) { struct stat s ; if ( stat ( cfg . homedir , & s ) == 0 ) { if ( chdir ( cfg . homedir ) < 0 ) errExit ( "chdir" ) ; } } } if ( arg_debug ) { char * cpath = get_current_dir_name ( ) ; if ( cpath ) { printf ( "Current<S2SV_blank>directory:<S2SV_blank>%s\\n" , cpath ) ; free ( cpath ) ; } } EUID_ROOT ( ) ; fs_x11 ( ) ; if ( arg_x11_xorg ) x11_xorg ( ) ; save_umask ( ) ; save_nonewprivs ( ) ; <S2SV_StartBug> set_caps ( ) ; <S2SV_EndBug> save_cpu ( ) ; save_cgroup ( ) ; # ifdef HAVE_SECCOMP # ifdef SYS_socket if ( cfg . protocol ) { if ( arg_debug ) printf ( "Install<S2SV_blank>protocol<S2SV_blank>filter:<S2SV_blank>%s\\n" , cfg . protocol ) ; seccomp_load ( RUN_SECCOMP_PROTOCOL ) ; protocol_filter_save ( ) ; } else { int rv = unlink ( RUN_SECCOMP_PROTOCOL ) ; ( void ) rv ; } # endif if ( arg_seccomp == 1 ) { if ( cfg . seccomp_list_keep ) seccomp_filter_keep ( ) ; else seccomp_filter_drop ( ) ; } else { int rv = unlink ( RUN_SECCOMP_CFG ) ; rv |= unlink ( RUN_SECCOMP_32 ) ; ( void ) rv ; } if ( arg_memory_deny_write_execute ) { if ( arg_debug ) printf ( "Install<S2SV_blank>memory<S2SV_blank>write&execute<S2SV_blank>filter\\n" ) ; seccomp_load ( RUN_SECCOMP_MDWX ) ; } else { int rv = unlink ( RUN_SECCOMP_MDWX ) ; ( void ) rv ; } <S2SV_StartBug> # endif <S2SV_EndBug> FILE * rj = create_ready_for_join_file ( ) ; save_nogroups ( ) ; if ( arg_noroot ) { int rv = unshare ( CLONE_NEWUSER ) ; if ( rv == - 1 ) { fwarning ( "cannot<S2SV_blank>create<S2SV_blank>a<S2SV_blank>new<S2SV_blank>user<S2SV_blank>namespace,<S2SV_blank>going<S2SV_blank>forward<S2SV_blank>without<S2SV_blank>it...\\n" ) ; arg_noroot = 0 ; } } notify_other ( child_to_parent_fds [ 1 ] ) ; close ( child_to_parent_fds [ 1 ] ) ; wait_for_other ( parent_to_child_fds [ 0 ] ) ; close ( parent_to_child_fds [ 0 ] ) ; if ( arg_noroot ) { if ( arg_debug ) printf ( "noroot<S2SV_blank>user<S2SV_blank>namespace<S2SV_blank>installed\\n" ) ; set_caps ( ) ; } if ( arg_nonewprivs ) { prctl ( PR_SET_NO_NEW_PRIVS , 1 , 0 , 0 , 0 ) ; if ( prctl ( PR_GET_NO_NEW_PRIVS , 0 , 0 , 0 , 0 ) != 1 ) { fwarning ( "cannot<S2SV_blank>set<S2SV_blank>NO_NEW_PRIVS,<S2SV_blank>it<S2SV_blank>requires<S2SV_blank>a<S2SV_blank>Linux<S2SV_blank>kernel<S2SV_blank>version<S2SV_blank>3.5<S2SV_blank>or<S2SV_blank>newer.\\n" ) ; if ( force_nonewprivs ) { fprintf ( stderr , "Error:<S2SV_blank>NO_NEW_PRIVS<S2SV_blank>required<S2SV_blank>for<S2SV_blank>this<S2SV_blank>sandbox,<S2SV_blank>exiting<S2SV_blank>...\\n" ) ; exit ( 1 ) ; } } else if ( arg_debug ) printf ( "NO_NEW_PRIVS<S2SV_blank>set\\n" ) ; } drop_privs ( arg_nogroups ) ; prctl ( PR_SET_PDEATHSIG , SIGKILL , 0 , 0 , 0 ) ; if ( cfg . cpus ) set_cpu_affinity ( ) ; pid_t app_pid = fork ( ) ; if ( app_pid == - 1 ) errExit ( "fork" ) ; if ( app_pid == 0 ) { # ifdef HAVE_APPARMOR if ( checkcfg ( CFG_APPARMOR ) && arg_apparmor ) { errno = 0 ; if ( aa_change_onexec ( "firejail-default" ) ) { fwarning ( "Cannot<S2SV_blank>confine<S2SV_blank>the<S2SV_blank>application<S2SV_blank>using<S2SV_blank>AppArmor.\\n" "Maybe<S2SV_blank>firejail-default<S2SV_blank>AppArmor<S2SV_blank>profile<S2SV_blank>is<S2SV_blank>not<S2SV_blank>loaded<S2SV_blank>into<S2SV_blank>the<S2SV_blank>kernel.\\n" "As<S2SV_blank>root,<S2SV_blank>run<S2SV_blank>\\"aa-enforce<S2SV_blank>firejail-default\\"<S2SV_blank>to<S2SV_blank>load<S2SV_blank>it.\\n" ) ; } else if ( arg_debug ) printf ( "AppArmor<S2SV_blank>enabled\\n" ) ; } # endif if ( arg_nice ) set_nice ( cfg . nice ) ; set_rlimits ( ) ; start_application ( 0 , rj ) ; } fclose ( rj ) ; int status = monitor_application ( app_pid ) ; flush_stdin ( ) ; if ( WIFEXITED ( status ) ) { return WEXITSTATUS ( status ) ; } else { return - 1 ; } }
CWE-200 char * url_decode_r ( char * to , char * url , size_t size ) { char * s = url , * d = to , * e = & to [ size - 1 ] ; while ( * s && d < e ) { if ( unlikely ( * s == '%' ) ) { if ( likely ( s [ 1 ] && s [ 2 ] ) ) { <S2SV_StartBug> * d ++ = from_hex ( s [ 1 ] ) << 4 | from_hex ( s [ 2 ] ) ; <S2SV_EndBug> s += 2 ; } } else if ( unlikely ( * s == '+' ) ) * d ++ = '<S2SV_blank>' ; else * d ++ = * s ; s ++ ; } * d = '\\0' ; return to ; }
CWE-200 inline int web_client_api_request_v1_data ( RRDHOST * host , struct web_client * w , char * url ) { debug ( D_WEB_CLIENT , "%llu:<S2SV_blank>API<S2SV_blank>v1<S2SV_blank>data<S2SV_blank>with<S2SV_blank>URL<S2SV_blank>\'%s\'" , w -> id , url ) ; int ret = 400 ; BUFFER * dimensions = NULL ; buffer_flush ( w -> response . data ) ; char * google_version = "0.6" , * google_reqId = "0" , * google_sig = "0" , * google_out = "json" , * responseHandler = NULL , * outFileName = NULL ; time_t last_timestamp_in_data = 0 , google_timestamp = 0 ; char * chart = NULL , * before_str = NULL , * after_str = NULL , * group_time_str = NULL , * points_str = NULL ; int group = RRDR_GROUPING_AVERAGE ; uint32_t format = DATASOURCE_JSON ; uint32_t options = 0x00000000 ; while ( url ) { char * value = mystrsep ( & url , "?&" ) ; if ( ! value || ! * value ) continue ; char * name = mystrsep ( & value , "=" ) ; if ( ! name || ! * name ) continue ; if ( ! value || ! * value ) continue ; debug ( D_WEB_CLIENT , "%llu:<S2SV_blank>API<S2SV_blank>v1<S2SV_blank>data<S2SV_blank>query<S2SV_blank>param<S2SV_blank>\'%s\'<S2SV_blank>with<S2SV_blank>value<S2SV_blank>\'%s\'" , w -> id , name , value ) ; if ( ! strcmp ( name , "chart" ) ) chart = value ; else if ( ! strcmp ( name , "dimension" ) || ! strcmp ( name , "dim" ) || ! strcmp ( name , "dimensions" ) || ! strcmp ( name , "dims" ) ) { if ( ! dimensions ) dimensions = buffer_create ( 100 ) ; buffer_strcat ( dimensions , "|" ) ; buffer_strcat ( dimensions , value ) ; } else if ( ! strcmp ( name , "after" ) ) after_str = value ; else if ( ! strcmp ( name , "before" ) ) before_str = value ; else if ( ! strcmp ( name , "points" ) ) points_str = value ; else if ( ! strcmp ( name , "gtime" ) ) group_time_str = value ; else if ( ! strcmp ( name , "group" ) ) { group = web_client_api_request_v1_data_group ( value , RRDR_GROUPING_AVERAGE ) ; } else if ( ! strcmp ( name , "format" ) ) { format = web_client_api_request_v1_data_format ( value ) ; } else if ( ! strcmp ( name , "options" ) ) { options |= web_client_api_request_v1_data_options ( value ) ; } else if ( ! strcmp ( name , "callback" ) ) { responseHandler = value ; } else if ( ! strcmp ( name , "filename" ) ) { outFileName = value ; } else if ( ! strcmp ( name , "tqx" ) ) { char * tqx_name , * tqx_value ; while ( value ) { tqx_value = mystrsep ( & value , ";" ) ; if ( ! tqx_value || ! * tqx_value ) continue ; tqx_name = mystrsep ( & tqx_value , ":" ) ; if ( ! tqx_name || ! * tqx_name ) continue ; if ( ! tqx_value || ! * tqx_value ) continue ; if ( ! strcmp ( tqx_name , "version" ) ) google_version = tqx_value ; else if ( ! strcmp ( tqx_name , "reqId" ) ) google_reqId = tqx_value ; else if ( ! strcmp ( tqx_name , "sig" ) ) { google_sig = tqx_value ; google_timestamp = strtoul ( google_sig , NULL , 0 ) ; } else if ( ! strcmp ( tqx_name , "out" ) ) { google_out = tqx_value ; format = web_client_api_request_v1_data_google_format ( google_out ) ; } else if ( ! strcmp ( tqx_name , "responseHandler" ) ) responseHandler = tqx_value ; else if ( ! strcmp ( tqx_name , "outFileName" ) ) outFileName = tqx_value ; } } } <S2SV_StartBug> if ( ! chart || ! * chart ) { <S2SV_EndBug> buffer_sprintf ( w -> response . data , "No<S2SV_blank>chart<S2SV_blank>id<S2SV_blank>is<S2SV_blank>given<S2SV_blank>at<S2SV_blank>the<S2SV_blank>request." ) ; goto cleanup ; } RRDSET * st = rrdset_find ( host , chart ) ; if ( ! st ) st = rrdset_find_byname ( host , chart ) ; if ( ! st ) { buffer_strcat ( w -> response . data , "Chart<S2SV_blank>is<S2SV_blank>not<S2SV_blank>found:<S2SV_blank>" ) ; buffer_strcat_htmlescape ( w -> response . data , chart ) ; ret = 404 ; goto cleanup ; } st -> last_accessed_time = now_realtime_sec ( ) ; long long before = ( before_str && * before_str ) ? str2l ( before_str ) : 0 ; long long after = ( after_str && * after_str ) ? str2l ( after_str ) : 0 ; int points = ( points_str && * points_str ) ? str2i ( points_str ) : 0 ; long group_time = ( group_time_str && * group_time_str ) ? str2l ( group_time_str ) : 0 ; debug ( D_WEB_CLIENT , "%llu:<S2SV_blank>API<S2SV_blank>command<S2SV_blank>\'data\'<S2SV_blank>for<S2SV_blank>chart<S2SV_blank>\'%s\',<S2SV_blank>dimensions<S2SV_blank>\'%s\',<S2SV_blank>after<S2SV_blank>\'%lld\',<S2SV_blank>before<S2SV_blank>\'%lld\',<S2SV_blank>points<S2SV_blank>\'%d\',<S2SV_blank>group<S2SV_blank>\'%d\',<S2SV_blank>format<S2SV_blank>\'%u\',<S2SV_blank>options<S2SV_blank>\'0x%08x\'" , w -> id , chart , ( dimensions ) ? buffer_tostring ( dimensions ) : "" , after , before , points , group , format , options ) ; if ( outFileName && * outFileName ) { buffer_sprintf ( w -> response . header , "Content-Disposition:<S2SV_blank>attachment;<S2SV_blank>filename=\\"%s\\"\\r\\n" , outFileName ) ; debug ( D_WEB_CLIENT , "%llu:<S2SV_blank>generating<S2SV_blank>outfilename<S2SV_blank>header:<S2SV_blank>\'%s\'" , w -> id , outFileName ) ; } if ( format == DATASOURCE_DATATABLE_JSONP ) { if ( responseHandler == NULL ) responseHandler = "google.visualization.Query.setResponse" ; debug ( D_WEB_CLIENT_ACCESS , "%llu:<S2SV_blank>GOOGLE<S2SV_blank>JSON/JSONP:<S2SV_blank>version<S2SV_blank>=<S2SV_blank>\'%s\',<S2SV_blank>reqId<S2SV_blank>=<S2SV_blank>\'%s\',<S2SV_blank>sig<S2SV_blank>=<S2SV_blank>\'%s\',<S2SV_blank>out<S2SV_blank>=<S2SV_blank>\'%s\',<S2SV_blank>responseHandler<S2SV_blank>=<S2SV_blank>\'%s\',<S2SV_blank>outFileName<S2SV_blank>=<S2SV_blank>\'%s\'" , w -> id , google_version , google_reqId , google_sig , google_out , responseHandler , outFileName ) ; buffer_sprintf ( w -> response . data , "%s({version:\'%s\',reqId:\'%s\',status:\'ok\',sig:\'%ld\',table:" , responseHandler , google_version , google_reqId , st -> last_updated . tv_sec ) ; } else if ( format == DATASOURCE_JSONP ) { if ( responseHandler == NULL ) responseHandler = "callback" ; buffer_strcat ( w -> response . data , responseHandler ) ; buffer_strcat ( w -> response . data , "(" ) ; } ret = rrdset2anything_api_v1 ( st , w -> response . data , dimensions , format , points , after , before , group , group_time , options , & last_timestamp_in_data ) ; if ( format == DATASOURCE_DATATABLE_JSONP ) { if ( google_timestamp < last_timestamp_in_data ) buffer_strcat ( w -> response . data , "});" ) ; else { buffer_flush ( w -> response . data ) ; buffer_sprintf ( w -> response . data , "%s({version:\'%s\',reqId:\'%s\',status:\'error\',errors:[{reason:\'not_modified\',message:\'Data<S2SV_blank>not<S2SV_blank>modified\'}]});" , responseHandler , google_version , google_reqId ) ; } } else if ( format == DATASOURCE_JSONP ) buffer_strcat ( w -> response . data , ");" ) ; cleanup : buffer_free ( dimensions ) ; return ret ; }
CWE-119 static __forceinline void draw_line ( float * output , int x0 , int y0 , int x1 , int y1 , int n ) { int dy = y1 - y0 ; int adx = x1 - x0 ; int ady = abs ( dy ) ; int base ; int x = x0 , y = y0 ; int err = 0 ; int sy ; # ifdef STB_VORBIS_DIVIDE_TABLE if ( adx < DIVTAB_DENOM && ady < DIVTAB_NUMER ) { if ( dy < 0 ) { base = - integer_divide_table [ ady ] [ adx ] ; sy = base - 1 ; } else { base = integer_divide_table [ ady ] [ adx ] ; sy = base + 1 ; } } else { base = dy / adx ; if ( dy < 0 ) sy = base - 1 ; else sy = base + 1 ; } # else base = dy / adx ; if ( dy < 0 ) sy = base - 1 ; else sy = base + 1 ; # endif ady -= abs ( base ) * adx ; if ( x1 > n ) x1 = n ; if ( x < x1 ) { <S2SV_StartBug> LINE_OP ( output [ x ] , inverse_db_table [ y ] ) ; <S2SV_EndBug> for ( ++ x ; x < x1 ; ++ x ) { err += ady ; if ( err >= adx ) { err -= adx ; y += sy ; } else y += base ; <S2SV_StartBug> LINE_OP ( output [ x ] , inverse_db_table [ y ] ) ; <S2SV_EndBug> } } }
CWE-119 static float * get_window ( vorb * f , int len ) { len <<= 1 ; if ( len == f -> blocksize_0 ) return f -> window [ 0 ] ; if ( len == f -> blocksize_1 ) return f -> window [ 1 ] ; <S2SV_StartBug> assert ( 0 ) ; <S2SV_EndBug> return NULL ; }
CWE-119 static int lookup1_values ( int entries , int dim ) { int r = ( int ) floor ( exp ( ( float ) log ( ( float ) entries ) / dim ) ) ; if ( ( int ) floor ( pow ( ( float ) r + 1 , dim ) ) <= entries ) ++ r ; <S2SV_StartBug> assert ( pow ( ( float ) r + 1 , dim ) > entries ) ; <S2SV_EndBug> <S2SV_StartBug> assert ( ( int ) floor ( pow ( ( float ) r , dim ) ) <= entries ) ; <S2SV_EndBug> return r ; }
CWE-119 static int start_decoder ( vorb * f ) { uint8 header [ 6 ] , x , y ; int len , i , j , k , max_submaps = 0 ; int longest_floorlist = 0 ; if ( ! start_page ( f ) ) return FALSE ; if ( ! ( f -> page_flag & PAGEFLAG_first_page ) ) return error ( f , VORBIS_invalid_first_page ) ; if ( f -> page_flag & PAGEFLAG_last_page ) return error ( f , VORBIS_invalid_first_page ) ; if ( f -> page_flag & PAGEFLAG_continued_packet ) return error ( f , VORBIS_invalid_first_page ) ; if ( f -> segment_count != 1 ) return error ( f , VORBIS_invalid_first_page ) ; if ( f -> segments [ 0 ] != 30 ) { if ( f -> segments [ 0 ] == 64 && getn ( f , header , 6 ) && header [ 0 ] == 'f' && header [ 1 ] == 'i' && header [ 2 ] == 's' && header [ 3 ] == 'h' && header [ 4 ] == 'e' && header [ 5 ] == 'a' && get8 ( f ) == 'd' && get8 ( f ) == '\\0' ) return error ( f , VORBIS_ogg_skeleton_not_supported ) ; else return error ( f , VORBIS_invalid_first_page ) ; } if ( get8 ( f ) != VORBIS_packet_id ) return error ( f , VORBIS_invalid_first_page ) ; if ( ! getn ( f , header , 6 ) ) return error ( f , VORBIS_unexpected_eof ) ; if ( ! vorbis_validate ( header ) ) return error ( f , VORBIS_invalid_first_page ) ; if ( get32 ( f ) != 0 ) return error ( f , VORBIS_invalid_first_page ) ; f -> channels = get8 ( f ) ; if ( ! f -> channels ) return error ( f , VORBIS_invalid_first_page ) ; if ( f -> channels > STB_VORBIS_MAX_CHANNELS ) return error ( f , VORBIS_too_many_channels ) ; f -> sample_rate = get32 ( f ) ; if ( ! f -> sample_rate ) return error ( f , VORBIS_invalid_first_page ) ; get32 ( f ) ; get32 ( f ) ; get32 ( f ) ; x = get8 ( f ) ; { int log0 , log1 ; log0 = x & 15 ; log1 = x >> 4 ; f -> blocksize_0 = 1 << log0 ; f -> blocksize_1 = 1 << log1 ; if ( log0 < 6 || log0 > 13 ) return error ( f , VORBIS_invalid_setup ) ; if ( log1 < 6 || log1 > 13 ) return error ( f , VORBIS_invalid_setup ) ; if ( log0 > log1 ) return error ( f , VORBIS_invalid_setup ) ; } x = get8 ( f ) ; if ( ! ( x & 1 ) ) return error ( f , VORBIS_invalid_first_page ) ; if ( ! start_page ( f ) ) return FALSE ; if ( ! start_packet ( f ) ) return FALSE ; do { len = next_segment ( f ) ; skip ( f , len ) ; f -> bytes_in_seg = 0 ; } while ( len ) ; if ( ! start_packet ( f ) ) return FALSE ; # ifndef STB_VORBIS_NO_PUSHDATA_API if ( IS_PUSH_MODE ( f ) ) { if ( ! is_whole_packet_present ( f , TRUE ) ) { if ( f -> error == VORBIS_invalid_stream ) f -> error = VORBIS_invalid_setup ; return FALSE ; } } # endif crc32_init ( ) ; if ( get8_packet ( f ) != VORBIS_packet_setup ) return error ( f , VORBIS_invalid_setup ) ; for ( i = 0 ; i < 6 ; ++ i ) header [ i ] = get8_packet ( f ) ; if ( ! vorbis_validate ( header ) ) return error ( f , VORBIS_invalid_setup ) ; f -> codebook_count = get_bits ( f , 8 ) + 1 ; f -> codebooks = ( Codebook * ) setup_malloc ( f , sizeof ( * f -> codebooks ) * f -> codebook_count ) ; if ( f -> codebooks == NULL ) return error ( f , VORBIS_outofmem ) ; memset ( f -> codebooks , 0 , sizeof ( * f -> codebooks ) * f -> codebook_count ) ; for ( i = 0 ; i < f -> codebook_count ; ++ i ) { uint32 * values ; int ordered , sorted_count ; int total = 0 ; uint8 * lengths ; Codebook * c = f -> codebooks + i ; CHECK ( f ) ; x = get_bits ( f , 8 ) ; if ( x != 0x42 ) return error ( f , VORBIS_invalid_setup ) ; x = get_bits ( f , 8 ) ; if ( x != 0x43 ) return error ( f , VORBIS_invalid_setup ) ; x = get_bits ( f , 8 ) ; if ( x != 0x56 ) return error ( f , VORBIS_invalid_setup ) ; x = get_bits ( f , 8 ) ; c -> dimensions = ( get_bits ( f , 8 ) << 8 ) + x ; x = get_bits ( f , 8 ) ; y = get_bits ( f , 8 ) ; c -> entries = ( get_bits ( f , 8 ) << 16 ) + ( y << 8 ) + x ; ordered = get_bits ( f , 1 ) ; c -> sparse = ordered ? 0 : get_bits ( f , 1 ) ; if ( c -> dimensions == 0 && c -> entries != 0 ) return error ( f , VORBIS_invalid_setup ) ; if ( c -> sparse ) lengths = ( uint8 * ) setup_temp_malloc ( f , c -> entries ) ; else lengths = c -> codeword_lengths = ( uint8 * ) setup_malloc ( f , c -> entries ) ; if ( ! lengths ) return error ( f , VORBIS_outofmem ) ; if ( ordered ) { int current_entry = 0 ; int current_length = get_bits ( f , 5 ) + 1 ; while ( current_entry < c -> entries ) { int limit = c -> entries - current_entry ; int n = get_bits ( f , ilog ( limit ) ) ; <S2SV_StartBug> if ( current_entry + n > ( int ) c -> entries ) { return error ( f , VORBIS_invalid_setup ) ; } <S2SV_EndBug> memset ( lengths + current_entry , current_length , n ) ; current_entry += n ; ++ current_length ; } } else { for ( j = 0 ; j < c -> entries ; ++ j ) { int present = c -> sparse ? get_bits ( f , 1 ) : 1 ; if ( present ) { lengths [ j ] = get_bits ( f , 5 ) + 1 ; ++ total ; if ( lengths [ j ] == 32 ) return error ( f , VORBIS_invalid_setup ) ; } else { lengths [ j ] = NO_CODE ; } } } if ( c -> sparse && total >= c -> entries >> 2 ) { if ( c -> entries > ( int ) f -> setup_temp_memory_required ) f -> setup_temp_memory_required = c -> entries ; c -> codeword_lengths = ( uint8 * ) setup_malloc ( f , c -> entries ) ; if ( c -> codeword_lengths == NULL ) return error ( f , VORBIS_outofmem ) ; memcpy ( c -> codeword_lengths , lengths , c -> entries ) ; setup_temp_free ( f , lengths , c -> entries ) ; lengths = c -> codeword_lengths ; c -> sparse = 0 ; } if ( c -> sparse ) { sorted_count = total ; } else { sorted_count = 0 ; # ifndef STB_VORBIS_NO_HUFFMAN_BINARY_SEARCH for ( j = 0 ; j < c -> entries ; ++ j ) if ( lengths [ j ] > STB_VORBIS_FAST_HUFFMAN_LENGTH && lengths [ j ] != NO_CODE ) ++ sorted_count ; # endif } c -> sorted_entries = sorted_count ; values = NULL ; CHECK ( f ) ; if ( ! c -> sparse ) { c -> codewords = ( uint32 * ) setup_malloc ( f , sizeof ( c -> codewords [ 0 ] ) * c -> entries ) ; if ( ! c -> codewords ) return error ( f , VORBIS_outofmem ) ; } else { unsigned int size ; if ( c -> sorted_entries ) { c -> codeword_lengths = ( uint8 * ) setup_malloc ( f , c -> sorted_entries ) ; if ( ! c -> codeword_lengths ) return error ( f , VORBIS_outofmem ) ; c -> codewords = ( uint32 * ) setup_temp_malloc ( f , sizeof ( * c -> codewords ) * c -> sorted_entries ) ; if ( ! c -> codewords ) return error ( f , VORBIS_outofmem ) ; values = ( uint32 * ) setup_temp_malloc ( f , sizeof ( * values ) * c -> sorted_entries ) ; if ( ! values ) return error ( f , VORBIS_outofmem ) ; } size = c -> entries + ( sizeof ( * c -> codewords ) + sizeof ( * values ) ) * c -> sorted_entries ; if ( size > f -> setup_temp_memory_required ) f -> setup_temp_memory_required = size ; } if ( ! compute_codewords ( c , lengths , c -> entries , values ) ) { if ( c -> sparse ) setup_temp_free ( f , values , 0 ) ; return error ( f , VORBIS_invalid_setup ) ; } if ( c -> sorted_entries ) { c -> sorted_codewords = ( uint32 * ) setup_malloc ( f , sizeof ( * c -> sorted_codewords ) * ( c -> sorted_entries + 1 ) ) ; if ( c -> sorted_codewords == NULL ) return error ( f , VORBIS_outofmem ) ; c -> sorted_values = ( int * ) setup_malloc ( f , sizeof ( * c -> sorted_values ) * ( c -> sorted_entries + 1 ) ) ; if ( c -> sorted_values == NULL ) return error ( f , VORBIS_outofmem ) ; ++ c -> sorted_values ; c -> sorted_values [ - 1 ] = - 1 ; compute_sorted_huffman ( c , lengths , values ) ; } if ( c -> sparse ) { setup_temp_free ( f , values , sizeof ( * values ) * c -> sorted_entries ) ; setup_temp_free ( f , c -> codewords , sizeof ( * c -> codewords ) * c -> sorted_entries ) ; setup_temp_free ( f , lengths , c -> entries ) ; c -> codewords = NULL ; } compute_accelerated_huffman ( c ) ; CHECK ( f ) ; c -> lookup_type = get_bits ( f , 4 ) ; if ( c -> lookup_type > 2 ) return error ( f , VORBIS_invalid_setup ) ; if ( c -> lookup_type > 0 ) { uint16 * mults ; c -> minimum_value = float32_unpack ( get_bits ( f , 32 ) ) ; c -> delta_value = float32_unpack ( get_bits ( f , 32 ) ) ; c -> value_bits = get_bits ( f , 4 ) + 1 ; c -> sequence_p = get_bits ( f , 1 ) ; if ( c -> lookup_type == 1 ) { <S2SV_StartBug> c -> lookup_values = lookup1_values ( c -> entries , c -> dimensions ) ; <S2SV_EndBug> } else { c -> lookup_values = c -> entries * c -> dimensions ; } if ( c -> lookup_values == 0 ) return error ( f , VORBIS_invalid_setup ) ; mults = ( uint16 * ) setup_temp_malloc ( f , sizeof ( mults [ 0 ] ) * c -> lookup_values ) ; if ( mults == NULL ) return error ( f , VORBIS_outofmem ) ; for ( j = 0 ; j < ( int ) c -> lookup_values ; ++ j ) { int q = get_bits ( f , c -> value_bits ) ; if ( q == EOP ) { setup_temp_free ( f , mults , sizeof ( mults [ 0 ] ) * c -> lookup_values ) ; return error ( f , VORBIS_invalid_setup ) ; } mults [ j ] = q ; } # ifndef STB_VORBIS_DIVIDES_IN_CODEBOOK if ( c -> lookup_type == 1 ) { int len , sparse = c -> sparse ; float last = 0 ; if ( sparse ) { if ( c -> sorted_entries == 0 ) goto skip ; c -> multiplicands = ( codetype * ) setup_malloc ( f , sizeof ( c -> multiplicands [ 0 ] ) * c -> sorted_entries * c -> dimensions ) ; } else c -> multiplicands = ( codetype * ) setup_malloc ( f , sizeof ( c -> multiplicands [ 0 ] ) * c -> entries * c -> dimensions ) ; if ( c -> multiplicands == NULL ) { setup_temp_free ( f , mults , sizeof ( mults [ 0 ] ) * c -> lookup_values ) ; return error ( f , VORBIS_outofmem ) ; } len = sparse ? c -> sorted_entries : c -> entries ; for ( j = 0 ; j < len ; ++ j ) { unsigned int z = sparse ? c -> sorted_values [ j ] : j ; unsigned int div = 1 ; for ( k = 0 ; k < c -> dimensions ; ++ k ) { int off = ( z / div ) % c -> lookup_values ; float val = mults [ off ] ; val = mults [ off ] * c -> delta_value + c -> minimum_value + last ; c -> multiplicands [ j * c -> dimensions + k ] = val ; if ( c -> sequence_p ) last = val ; if ( k + 1 < c -> dimensions ) { if ( div > UINT_MAX / ( unsigned int ) c -> lookup_values ) { setup_temp_free ( f , mults , sizeof ( mults [ 0 ] ) * c -> lookup_values ) ; return error ( f , VORBIS_invalid_setup ) ; } div *= c -> lookup_values ; } } } c -> lookup_type = 2 ; } else # endif { float last = 0 ; CHECK ( f ) ; c -> multiplicands = ( codetype * ) setup_malloc ( f , sizeof ( c -> multiplicands [ 0 ] ) * c -> lookup_values ) ; if ( c -> multiplicands == NULL ) { setup_temp_free ( f , mults , sizeof ( mults [ 0 ] ) * c -> lookup_values ) ; return error ( f , VORBIS_outofmem ) ; } for ( j = 0 ; j < ( int ) c -> lookup_values ; ++ j ) { float val = mults [ j ] * c -> delta_value + c -> minimum_value + last ; c -> multiplicands [ j ] = val ; if ( c -> sequence_p ) last = val ; } } # ifndef STB_VORBIS_DIVIDES_IN_CODEBOOK skip : ; # endif setup_temp_free ( f , mults , sizeof ( mults [ 0 ] ) * c -> lookup_values ) ; CHECK ( f ) ; } CHECK ( f ) ; } x = get_bits ( f , 6 ) + 1 ; for ( i = 0 ; i < x ; ++ i ) { uint32 z = get_bits ( f , 16 ) ; if ( z != 0 ) return error ( f , VORBIS_invalid_setup ) ; } f -> floor_count = get_bits ( f , 6 ) + 1 ; f -> floor_config = ( Floor * ) setup_malloc ( f , f -> floor_count * sizeof ( * f -> floor_config ) ) ; if ( f -> floor_config == NULL ) return error ( f , VORBIS_outofmem ) ; for ( i = 0 ; i < f -> floor_count ; ++ i ) { f -> floor_types [ i ] = get_bits ( f , 16 ) ; if ( f -> floor_types [ i ] > 1 ) return error ( f , VORBIS_invalid_setup ) ; if ( f -> floor_types [ i ] == 0 ) { Floor0 * g = & f -> floor_config [ i ] . floor0 ; g -> order = get_bits ( f , 8 ) ; g -> rate = get_bits ( f , 16 ) ; g -> bark_map_size = get_bits ( f , 16 ) ; g -> amplitude_bits = get_bits ( f , 6 ) ; g -> amplitude_offset = get_bits ( f , 8 ) ; g -> number_of_books = get_bits ( f , 4 ) + 1 ; for ( j = 0 ; j < g -> number_of_books ; ++ j ) g -> book_list [ j ] = get_bits ( f , 8 ) ; return error ( f , VORBIS_feature_not_supported ) ; } else { stbv__floor_ordering p [ 31 * 8 + 2 ] ; Floor1 * g = & f -> floor_config [ i ] . floor1 ; int max_class = - 1 ; g -> partitions = get_bits ( f , 5 ) ; for ( j = 0 ; j < g -> partitions ; ++ j ) { g -> partition_class_list [ j ] = get_bits ( f , 4 ) ; if ( g -> partition_class_list [ j ] > max_class ) max_class = g -> partition_class_list [ j ] ; } for ( j = 0 ; j <= max_class ; ++ j ) { g -> class_dimensions [ j ] = get_bits ( f , 3 ) + 1 ; g -> class_subclasses [ j ] = get_bits ( f , 2 ) ; if ( g -> class_subclasses [ j ] ) { g -> class_masterbooks [ j ] = get_bits ( f , 8 ) ; if ( g -> class_masterbooks [ j ] >= f -> codebook_count ) return error ( f , VORBIS_invalid_setup ) ; } for ( k = 0 ; k < 1 << g -> class_subclasses [ j ] ; ++ k ) { g -> subclass_books [ j ] [ k ] = get_bits ( f , 8 ) - 1 ; if ( g -> subclass_books [ j ] [ k ] >= f -> codebook_count ) return error ( f , VORBIS_invalid_setup ) ; } } g -> floor1_multiplier = get_bits ( f , 2 ) + 1 ; g -> rangebits = get_bits ( f , 4 ) ; g -> Xlist [ 0 ] = 0 ; g -> Xlist [ 1 ] = 1 << g -> rangebits ; g -> values = 2 ; for ( j = 0 ; j < g -> partitions ; ++ j ) { int c = g -> partition_class_list [ j ] ; for ( k = 0 ; k < g -> class_dimensions [ c ] ; ++ k ) { g -> Xlist [ g -> values ] = get_bits ( f , g -> rangebits ) ; ++ g -> values ; } } for ( j = 0 ; j < g -> values ; ++ j ) { p [ j ] . x = g -> Xlist [ j ] ; p [ j ] . id = j ; } qsort ( p , g -> values , sizeof ( p [ 0 ] ) , point_compare ) ; <S2SV_StartBug> for ( j = 0 ; j < g -> values ; ++ j ) <S2SV_EndBug> g -> sorted_order [ j ] = ( uint8 ) p [ j ] . id ; for ( j = 2 ; j < g -> values ; ++ j ) { int low , hi ; neighbors ( g -> Xlist , j , & low , & hi ) ; g -> neighbors [ j ] [ 0 ] = low ; g -> neighbors [ j ] [ 1 ] = hi ; } if ( g -> values > longest_floorlist ) longest_floorlist = g -> values ; } } f -> residue_count = get_bits ( f , 6 ) + 1 ; f -> residue_config = ( Residue * ) setup_malloc ( f , f -> residue_count * sizeof ( f -> residue_config [ 0 ] ) ) ; if ( f -> residue_config == NULL ) return error ( f , VORBIS_outofmem ) ; memset ( f -> residue_config , 0 , f -> residue_count * sizeof ( f -> residue_config [ 0 ] ) ) ; for ( i = 0 ; i < f -> residue_count ; ++ i ) { uint8 residue_cascade [ 64 ] ; Residue * r = f -> residue_config + i ; f -> residue_types [ i ] = get_bits ( f , 16 ) ; if ( f -> residue_types [ i ] > 2 ) return error ( f , VORBIS_invalid_setup ) ; r -> begin = get_bits ( f , 24 ) ; r -> end = get_bits ( f , 24 ) ; if ( r -> end < r -> begin ) return error ( f , VORBIS_invalid_setup ) ; r -> part_size = get_bits ( f , 24 ) + 1 ; r -> classifications = get_bits ( f , 6 ) + 1 ; r -> classbook = get_bits ( f , 8 ) ; if ( r -> classbook >= f -> codebook_count ) return error ( f , VORBIS_invalid_setup ) ; for ( j = 0 ; j < r -> classifications ; ++ j ) { uint8 high_bits = 0 ; uint8 low_bits = get_bits ( f , 3 ) ; if ( get_bits ( f , 1 ) ) high_bits = get_bits ( f , 5 ) ; residue_cascade [ j ] = high_bits * 8 + low_bits ; } r -> residue_books = ( short ( * ) [ 8 ] ) setup_malloc ( f , sizeof ( r -> residue_books [ 0 ] ) * r -> classifications ) ; if ( r -> residue_books == NULL ) return error ( f , VORBIS_outofmem ) ; for ( j = 0 ; j < r -> classifications ; ++ j ) { for ( k = 0 ; k < 8 ; ++ k ) { if ( residue_cascade [ j ] & ( 1 << k ) ) { r -> residue_books [ j ] [ k ] = get_bits ( f , 8 ) ; if ( r -> residue_books [ j ] [ k ] >= f -> codebook_count ) return error ( f , VORBIS_invalid_setup ) ; } else { r -> residue_books [ j ] [ k ] = - 1 ; } } } r -> classdata = ( uint8 * * ) setup_malloc ( f , sizeof ( * r -> classdata ) * f -> codebooks [ r -> classbook ] . entries ) ; if ( ! r -> classdata ) return error ( f , VORBIS_outofmem ) ; memset ( r -> classdata , 0 , sizeof ( * r -> classdata ) * f -> codebooks [ r -> classbook ] . entries ) ; for ( j = 0 ; j < f -> codebooks [ r -> classbook ] . entries ; ++ j ) { int classwords = f -> codebooks [ r -> classbook ] . dimensions ; int temp = j ; r -> classdata [ j ] = ( uint8 * ) setup_malloc ( f , sizeof ( r -> classdata [ j ] [ 0 ] ) * classwords ) ; if ( r -> classdata [ j ] == NULL ) return error ( f , VORBIS_outofmem ) ; for ( k = classwords - 1 ; k >= 0 ; -- k ) { r -> classdata [ j ] [ k ] = temp % r -> classifications ; temp /= r -> classifications ; } } } f -> mapping_count = get_bits ( f , 6 ) + 1 ; f -> mapping = ( Mapping * ) setup_malloc ( f , f -> mapping_count * sizeof ( * f -> mapping ) ) ; if ( f -> mapping == NULL ) return error ( f , VORBIS_outofmem ) ; memset ( f -> mapping , 0 , f -> mapping_count * sizeof ( * f -> mapping ) ) ; for ( i = 0 ; i < f -> mapping_count ; ++ i ) { Mapping * m = f -> mapping + i ; int mapping_type = get_bits ( f , 16 ) ; if ( mapping_type != 0 ) return error ( f , VORBIS_invalid_setup ) ; m -> chan = ( MappingChannel * ) setup_malloc ( f , f -> channels * sizeof ( * m -> chan ) ) ; if ( m -> chan == NULL ) return error ( f , VORBIS_outofmem ) ; if ( get_bits ( f , 1 ) ) m -> submaps = get_bits ( f , 4 ) + 1 ; else m -> submaps = 1 ; if ( m -> submaps > max_submaps ) max_submaps = m -> submaps ; if ( get_bits ( f , 1 ) ) { <S2SV_StartBug> m -> coupling_steps = get_bits ( f , 8 ) + 1 ; <S2SV_EndBug> for ( k = 0 ; k < m -> coupling_steps ; ++ k ) { m -> chan [ k ] . magnitude = get_bits ( f , ilog ( f -> channels - 1 ) ) ; m -> chan [ k ] . angle = get_bits ( f , ilog ( f -> channels - 1 ) ) ; if ( m -> chan [ k ] . magnitude >= f -> channels ) return error ( f , VORBIS_invalid_setup ) ; if ( m -> chan [ k ] . angle >= f -> channels ) return error ( f , VORBIS_invalid_setup ) ; if ( m -> chan [ k ] . magnitude == m -> chan [ k ] . angle ) return error ( f , VORBIS_invalid_setup ) ; } } else m -> coupling_steps = 0 ; if ( get_bits ( f , 2 ) ) return error ( f , VORBIS_invalid_setup ) ; if ( m -> submaps > 1 ) { for ( j = 0 ; j < f -> channels ; ++ j ) { m -> chan [ j ] . mux = get_bits ( f , 4 ) ; if ( m -> chan [ j ] . mux >= m -> submaps ) return error ( f , VORBIS_invalid_setup ) ; } } else for ( j = 0 ; j < f -> channels ; ++ j ) m -> chan [ j ] . mux = 0 ; for ( j = 0 ; j < m -> submaps ; ++ j ) { get_bits ( f , 8 ) ; m -> submap_floor [ j ] = get_bits ( f , 8 ) ; m -> submap_residue [ j ] = get_bits ( f , 8 ) ; if ( m -> submap_floor [ j ] >= f -> floor_count ) return error ( f , VORBIS_invalid_setup ) ; if ( m -> submap_residue [ j ] >= f -> residue_count ) return error ( f , VORBIS_invalid_setup ) ; } } f -> mode_count = get_bits ( f , 6 ) + 1 ; for ( i = 0 ; i < f -> mode_count ; ++ i ) { Mode * m = f -> mode_config + i ; m -> blockflag = get_bits ( f , 1 ) ; m -> windowtype = get_bits ( f , 16 ) ; m -> transformtype = get_bits ( f , 16 ) ; m -> mapping = get_bits ( f , 8 ) ; if ( m -> windowtype != 0 ) return error ( f , VORBIS_invalid_setup ) ; if ( m -> transformtype != 0 ) return error ( f , VORBIS_invalid_setup ) ; if ( m -> mapping >= f -> mapping_count ) return error ( f , VORBIS_invalid_setup ) ; } flush_packet ( f ) ; f -> previous_length = 0 ; for ( i = 0 ; i < f -> channels ; ++ i ) { f -> channel_buffers [ i ] = ( float * ) setup_malloc ( f , sizeof ( float ) * f -> blocksize_1 ) ; f -> previous_window [ i ] = ( float * ) setup_malloc ( f , sizeof ( float ) * f -> blocksize_1 / 2 ) ; f -> finalY [ i ] = ( int16 * ) setup_malloc ( f , sizeof ( int16 ) * longest_floorlist ) ; if ( f -> channel_buffers [ i ] == NULL || f -> previous_window [ i ] == NULL || f -> finalY [ i ] == NULL ) return error ( f , VORBIS_outofmem ) ; memset ( f -> channel_buffers [ i ] , 0 , sizeof ( float ) * f -> blocksize_1 ) ; # ifdef STB_VORBIS_NO_DEFER_FLOOR f -> floor_buffers [ i ] = ( float * ) setup_malloc ( f , sizeof ( float ) * f -> blocksize_1 / 2 ) ; if ( f -> floor_buffers [ i ] == NULL ) return error ( f , VORBIS_outofmem ) ; # endif } if ( ! init_blocksize ( f , 0 , f -> blocksize_0 ) ) return FALSE ; if ( ! init_blocksize ( f , 1 , f -> blocksize_1 ) ) return FALSE ; f -> blocksize [ 0 ] = f -> blocksize_0 ; f -> blocksize [ 1 ] = f -> blocksize_1 ; # ifdef STB_VORBIS_DIVIDE_TABLE if ( integer_divide_table [ 1 ] [ 1 ] == 0 ) for ( i = 0 ; i < DIVTAB_NUMER ; ++ i ) for ( j = 1 ; j < DIVTAB_DENOM ; ++ j ) integer_divide_table [ i ] [ j ] = i / j ; # endif { uint32 imdct_mem = ( f -> blocksize_1 * sizeof ( float ) >> 1 ) ; uint32 classify_mem ; int i , max_part_read = 0 ; for ( i = 0 ; i < f -> residue_count ; ++ i ) { Residue * r = f -> residue_config + i ; unsigned int actual_size = f -> blocksize_1 / 2 ; unsigned int limit_r_begin = r -> begin < actual_size ? r -> begin : actual_size ; unsigned int limit_r_end = r -> end < actual_size ? r -> end : actual_size ; int n_read = limit_r_end - limit_r_begin ; int part_read = n_read / r -> part_size ; if ( part_read > max_part_read ) max_part_read = part_read ; } # ifndef STB_VORBIS_DIVIDES_IN_RESIDUE classify_mem = f -> channels * ( sizeof ( void * ) + max_part_read * sizeof ( uint8 * ) ) ; # else classify_mem = f -> channels * ( sizeof ( void * ) + max_part_read * sizeof ( int * ) ) ; # endif f -> temp_memory_required = classify_mem ; if ( imdct_mem > f -> temp_memory_required ) f -> temp_memory_required = imdct_mem ; } f -> first_decode = TRUE ; if ( f -> alloc . alloc_buffer ) { assert ( f -> temp_offset == f -> alloc . alloc_buffer_length_in_bytes ) ; if ( f -> setup_offset + sizeof ( * f ) + f -> temp_memory_required > ( unsigned ) f -> temp_offset ) return error ( f , VORBIS_outofmem ) ; } f -> first_audio_page_offset = stb_vorbis_get_file_offset ( f ) ; return TRUE ; }
CWE-119 static int vorbis_finish_frame ( stb_vorbis * f , int len , int left , int right ) { int prev , i , j ; if ( f -> previous_length ) { int i , j , n = f -> previous_length ; <S2SV_StartBug> float * w = get_window ( f , n ) ; <S2SV_EndBug> for ( i = 0 ; i < f -> channels ; ++ i ) { for ( j = 0 ; j < n ; ++ j ) f -> channel_buffers [ i ] [ left + j ] = f -> channel_buffers [ i ] [ left + j ] * w [ j ] + f -> previous_window [ i ] [ j ] * w [ n - 1 - j ] ; } } prev = f -> previous_length ; f -> previous_length = len - right ; for ( i = 0 ; i < f -> channels ; ++ i ) for ( j = 0 ; right + j < len ; ++ j ) f -> previous_window [ i ] [ j ] = f -> channel_buffers [ i ] [ right + j ] ; if ( ! prev ) return 0 ; if ( len < right ) right = len ; f -> samples_output += right - left ; return right - left ; }
CWE-20 void tcp_sack_option ( struct tcpcb * tp , struct tcphdr * th , u_char * cp , int optlen ) { int tmp_olen ; u_char * tmp_cp ; struct sackhole * cur , * p , * temp ; if ( ! tp -> sack_enable ) return ; if ( ( th -> th_flags & TH_ACK ) == 0 ) return ; if ( SEQ_LT ( th -> th_ack , tp -> snd_una ) || SEQ_GT ( th -> th_ack , tp -> snd_max ) ) return ; if ( optlen <= 2 || ( optlen - 2 ) % TCPOLEN_SACK != 0 ) return ; tmp_cp = cp + 2 ; tmp_olen = optlen - 2 ; tcpstat_inc ( tcps_sack_rcv_opts ) ; if ( tp -> snd_numholes < 0 ) tp -> snd_numholes = 0 ; if ( tp -> t_maxseg == 0 ) panic ( "tcp_sack_option" ) ; while ( tmp_olen > 0 ) { struct sackblk sack ; memcpy ( & sack . start , tmp_cp , sizeof ( tcp_seq ) ) ; sack . start = ntohl ( sack . start ) ; memcpy ( & sack . end , tmp_cp + sizeof ( tcp_seq ) , sizeof ( tcp_seq ) ) ; sack . end = ntohl ( sack . end ) ; tmp_olen -= TCPOLEN_SACK ; tmp_cp += TCPOLEN_SACK ; if ( SEQ_LEQ ( sack . end , sack . start ) ) continue ; if ( SEQ_LEQ ( sack . end , tp -> snd_una ) ) continue ; if ( SEQ_GT ( th -> th_ack , tp -> snd_una ) ) { if ( SEQ_LT ( sack . start , th -> th_ack ) ) continue ; } if ( SEQ_GT ( sack . end , tp -> snd_max ) ) continue ; if ( tp -> snd_holes == NULL ) { tp -> snd_holes = ( struct sackhole * ) pool_get ( & sackhl_pool , PR_NOWAIT ) ; if ( tp -> snd_holes == NULL ) { goto done ; } cur = tp -> snd_holes ; cur -> start = th -> th_ack ; cur -> end = sack . start ; cur -> rxmit = cur -> start ; cur -> next = NULL ; tp -> snd_numholes = 1 ; tp -> rcv_lastsack = sack . end ; cur -> dups = min ( tcprexmtthresh , ( ( sack . end - cur -> end ) / tp -> t_maxseg ) ) ; if ( cur -> dups < 1 ) cur -> dups = 1 ; continue ; } p = cur = tp -> snd_holes ; while ( cur ) { if ( SEQ_LEQ ( sack . end , cur -> start ) ) break ; if ( SEQ_GEQ ( sack . start , cur -> end ) ) { cur -> dups ++ ; if ( ( ( sack . end - cur -> end ) / tp -> t_maxseg ) >= tcprexmtthresh ) cur -> dups = tcprexmtthresh ; p = cur ; cur = cur -> next ; continue ; } if ( SEQ_LEQ ( sack . start , cur -> start ) ) { if ( SEQ_GEQ ( sack . end , cur -> end ) ) { if ( p != cur ) { p -> next = cur -> next ; pool_put ( & sackhl_pool , cur ) ; cur = p -> next ; } else { cur = cur -> next ; pool_put ( & sackhl_pool , p ) ; p = cur ; tp -> snd_holes = p ; } tp -> snd_numholes -- ; continue ; } cur -> start = sack . end ; cur -> rxmit = SEQ_MAX ( cur -> rxmit , cur -> start ) ; p = cur ; cur = cur -> next ; continue ; } if ( SEQ_GEQ ( sack . end , cur -> end ) ) { cur -> end = sack . start ; cur -> rxmit = SEQ_MIN ( cur -> rxmit , cur -> end ) ; cur -> dups ++ ; if ( ( ( sack . end - cur -> end ) / tp -> t_maxseg ) >= tcprexmtthresh ) cur -> dups = tcprexmtthresh ; p = cur ; cur = cur -> next ; continue ; } if ( SEQ_LT ( cur -> start , sack . start ) && SEQ_GT ( cur -> end , sack . end ) ) { <S2SV_StartBug> temp = ( struct sackhole * ) <S2SV_EndBug> pool_get ( & sackhl_pool , PR_NOWAIT ) ; if ( temp == NULL ) goto done ; temp -> next = cur -> next ; temp -> start = sack . end ; temp -> end = cur -> end ; temp -> dups = cur -> dups ; temp -> rxmit = SEQ_MAX ( cur -> rxmit , temp -> start ) ; cur -> end = sack . start ; cur -> rxmit = SEQ_MIN ( cur -> rxmit , cur -> end ) ; cur -> dups ++ ; if ( ( ( sack . end - cur -> end ) / tp -> t_maxseg ) >= tcprexmtthresh ) cur -> dups = tcprexmtthresh ; cur -> next = temp ; p = temp ; cur = p -> next ; tp -> snd_numholes ++ ; } } if ( SEQ_LT ( tp -> rcv_lastsack , sack . start ) ) { <S2SV_StartBug> temp = ( struct sackhole * ) <S2SV_EndBug> pool_get ( & sackhl_pool , PR_NOWAIT ) ; if ( temp == NULL ) goto done ; temp -> start = tp -> rcv_lastsack ; temp -> end = sack . start ; temp -> dups = min ( tcprexmtthresh , ( ( sack . end - sack . start ) / tp -> t_maxseg ) ) ; if ( temp -> dups < 1 ) temp -> dups = 1 ; temp -> rxmit = temp -> start ; temp -> next = 0 ; p -> next = temp ; tp -> rcv_lastsack = sack . end ; tp -> snd_numholes ++ ; } } done : return ; }
CWE-706 void sink ( int argc , char * * argv ) { static BUF buffer ; struct stat stb ; enum { YES , NO , DISPLAYED } wrerr ; BUF * bp ; off_t i ; size_t j , count ; int amt , exists , first , ofd ; mode_t mode , omode , mask ; off_t size , statbytes ; unsigned long long ull ; int setimes , targisdir , wrerrno = 0 ; char ch , * cp , * np , * targ , * why , * vect [ 1 ] , buf [ 2048 ] , visbuf [ 2048 ] ; struct timeval tv [ 2 ] ; # define atime tv [ 0 ] # define mtime tv [ 1 ] # define SCREWUP ( str ) { why = str ; goto screwup ; } if ( TYPE_OVERFLOW ( time_t , 0 ) || TYPE_OVERFLOW ( off_t , 0 ) ) SCREWUP ( "Unexpected<S2SV_blank>off_t/time_t<S2SV_blank>size" ) ; setimes = targisdir = 0 ; mask = umask ( 0 ) ; if ( ! pflag ) ( void ) umask ( mask ) ; if ( argc != 1 ) { run_err ( "ambiguous<S2SV_blank>target" ) ; exit ( 1 ) ; } targ = * argv ; if ( targetshouldbedirectory ) verifydir ( targ ) ; ( void ) atomicio ( vwrite , remout , "" , 1 ) ; if ( stat ( targ , & stb ) == 0 && S_ISDIR ( stb . st_mode ) ) targisdir = 1 ; for ( first = 1 ; ; first = 0 ) { cp = buf ; if ( atomicio ( read , remin , cp , 1 ) != 1 ) return ; if ( * cp ++ == '\\n' ) SCREWUP ( "unexpected<S2SV_blank><newline>" ) ; do { if ( atomicio ( read , remin , & ch , sizeof ( ch ) ) != sizeof ( ch ) ) SCREWUP ( "lost<S2SV_blank>connection" ) ; * cp ++ = ch ; } while ( cp < & buf [ sizeof ( buf ) - 1 ] && ch != '\\n' ) ; * cp = 0 ; if ( verbose_mode ) fmprintf ( stderr , "Sink:<S2SV_blank>%s" , buf ) ; if ( buf [ 0 ] == '\\01' || buf [ 0 ] == '\\02' ) { if ( iamremote == 0 ) { ( void ) snmprintf ( visbuf , sizeof ( visbuf ) , NULL , "%s" , buf + 1 ) ; ( void ) atomicio ( vwrite , STDERR_FILENO , visbuf , strlen ( visbuf ) ) ; } if ( buf [ 0 ] == '\\02' ) exit ( 1 ) ; ++ errs ; continue ; } if ( buf [ 0 ] == 'E' ) { ( void ) atomicio ( vwrite , remout , "" , 1 ) ; return ; } if ( ch == '\\n' ) * -- cp = 0 ; cp = buf ; if ( * cp == 'T' ) { setimes ++ ; cp ++ ; if ( ! isdigit ( ( unsigned char ) * cp ) ) SCREWUP ( "mtime.sec<S2SV_blank>not<S2SV_blank>present" ) ; ull = strtoull ( cp , & cp , 10 ) ; if ( ! cp || * cp ++ != '<S2SV_blank>' ) SCREWUP ( "mtime.sec<S2SV_blank>not<S2SV_blank>delimited" ) ; if ( TYPE_OVERFLOW ( time_t , ull ) ) setimes = 0 ; mtime . tv_sec = ull ; mtime . tv_usec = strtol ( cp , & cp , 10 ) ; if ( ! cp || * cp ++ != '<S2SV_blank>' || mtime . tv_usec < 0 || mtime . tv_usec > 999999 ) SCREWUP ( "mtime.usec<S2SV_blank>not<S2SV_blank>delimited" ) ; if ( ! isdigit ( ( unsigned char ) * cp ) ) SCREWUP ( "atime.sec<S2SV_blank>not<S2SV_blank>present" ) ; ull = strtoull ( cp , & cp , 10 ) ; if ( ! cp || * cp ++ != '<S2SV_blank>' ) SCREWUP ( "atime.sec<S2SV_blank>not<S2SV_blank>delimited" ) ; if ( TYPE_OVERFLOW ( time_t , ull ) ) setimes = 0 ; atime . tv_sec = ull ; atime . tv_usec = strtol ( cp , & cp , 10 ) ; if ( ! cp || * cp ++ != '\\0' || atime . tv_usec < 0 || atime . tv_usec > 999999 ) SCREWUP ( "atime.usec<S2SV_blank>not<S2SV_blank>delimited" ) ; ( void ) atomicio ( vwrite , remout , "" , 1 ) ; continue ; } if ( * cp != 'C' && * cp != 'D' ) { if ( first ) { run_err ( "%s" , cp ) ; exit ( 1 ) ; } SCREWUP ( "expected<S2SV_blank>control<S2SV_blank>record" ) ; } mode = 0 ; for ( ++ cp ; cp < buf + 5 ; cp ++ ) { if ( * cp < '0' || * cp > '7' ) SCREWUP ( "bad<S2SV_blank>mode" ) ; mode = ( mode << 3 ) | ( * cp - '0' ) ; } if ( ! pflag ) mode &= ~ mask ; if ( * cp ++ != '<S2SV_blank>' ) SCREWUP ( "mode<S2SV_blank>not<S2SV_blank>delimited" ) ; if ( ! isdigit ( ( unsigned char ) * cp ) ) SCREWUP ( "size<S2SV_blank>not<S2SV_blank>present" ) ; ull = strtoull ( cp , & cp , 10 ) ; if ( ! cp || * cp ++ != '<S2SV_blank>' ) SCREWUP ( "size<S2SV_blank>not<S2SV_blank>delimited" ) ; if ( TYPE_OVERFLOW ( off_t , ull ) ) SCREWUP ( "size<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range" ) ; size = ( off_t ) ull ; <S2SV_StartBug> if ( ( strchr ( cp , '/' ) != NULL ) || ( strcmp ( cp , ".." ) == 0 ) ) { <S2SV_EndBug> run_err ( "error:<S2SV_blank>unexpected<S2SV_blank>filename:<S2SV_blank>%s" , cp ) ; exit ( 1 ) ; } if ( targisdir ) { static char * namebuf ; static size_t cursize ; size_t need ; need = strlen ( targ ) + strlen ( cp ) + 250 ; if ( need > cursize ) { free ( namebuf ) ; namebuf = xmalloc ( need ) ; cursize = need ; } ( void ) snprintf ( namebuf , need , "%s%s%s" , targ , strcmp ( targ , "/" ) ? "/" : "" , cp ) ; np = namebuf ; } else np = targ ; curfile = cp ; exists = stat ( np , & stb ) == 0 ; if ( buf [ 0 ] == 'D' ) { int mod_flag = pflag ; if ( ! iamrecursive ) SCREWUP ( "received<S2SV_blank>directory<S2SV_blank>without<S2SV_blank>-r" ) ; if ( exists ) { if ( ! S_ISDIR ( stb . st_mode ) ) { errno = ENOTDIR ; goto bad ; } if ( pflag ) ( void ) chmod ( np , mode ) ; } else { mod_flag = 1 ; if ( mkdir ( np , mode | S_IRWXU ) < 0 ) goto bad ; } vect [ 0 ] = xstrdup ( np ) ; sink ( 1 , vect ) ; if ( setimes ) { setimes = 0 ; if ( utimes ( vect [ 0 ] , tv ) < 0 ) run_err ( "%s:<S2SV_blank>set<S2SV_blank>times:<S2SV_blank>%s" , vect [ 0 ] , strerror ( errno ) ) ; } if ( mod_flag ) ( void ) chmod ( vect [ 0 ] , mode ) ; free ( vect [ 0 ] ) ; continue ; } omode = mode ; mode |= S_IWUSR ; if ( ( ofd = open ( np , O_WRONLY | O_CREAT , mode ) ) < 0 ) { bad : run_err ( "%s:<S2SV_blank>%s" , np , strerror ( errno ) ) ; continue ; } ( void ) atomicio ( vwrite , remout , "" , 1 ) ; if ( ( bp = allocbuf ( & buffer , ofd , COPY_BUFLEN ) ) == NULL ) { ( void ) close ( ofd ) ; continue ; } cp = bp -> buf ; wrerr = NO ; statbytes = 0 ; if ( showprogress ) start_progress_meter ( curfile , size , & statbytes ) ; set_nonblock ( remin ) ; for ( count = i = 0 ; i < size ; i += bp -> cnt ) { amt = bp -> cnt ; if ( i + amt > size ) amt = size - i ; count += amt ; do { j = atomicio6 ( read , remin , cp , amt , scpio , & statbytes ) ; if ( j == 0 ) { run_err ( "%s" , j != EPIPE ? strerror ( errno ) : "dropped<S2SV_blank>connection" ) ; exit ( 1 ) ; } amt -= j ; cp += j ; } while ( amt > 0 ) ; if ( count == bp -> cnt ) { if ( wrerr == NO ) { if ( atomicio ( vwrite , ofd , bp -> buf , count ) != count ) { wrerr = YES ; wrerrno = errno ; } } count = 0 ; cp = bp -> buf ; } } unset_nonblock ( remin ) ; if ( count != 0 && wrerr == NO && atomicio ( vwrite , ofd , bp -> buf , count ) != count ) { wrerr = YES ; wrerrno = errno ; } if ( wrerr == NO && ( ! exists || S_ISREG ( stb . st_mode ) ) && ftruncate ( ofd , size ) != 0 ) { run_err ( "%s:<S2SV_blank>truncate:<S2SV_blank>%s" , np , strerror ( errno ) ) ; wrerr = DISPLAYED ; } if ( pflag ) { if ( exists || omode != mode ) # ifdef HAVE_FCHMOD if ( fchmod ( ofd , omode ) ) { # else if ( chmod ( np , omode ) ) { # endif run_err ( "%s:<S2SV_blank>set<S2SV_blank>mode:<S2SV_blank>%s" , np , strerror ( errno ) ) ; wrerr = DISPLAYED ; } } else { if ( ! exists && omode != mode ) # ifdef HAVE_FCHMOD if ( fchmod ( ofd , omode & ~ mask ) ) { # else if ( chmod ( np , omode & ~ mask ) ) { # endif run_err ( "%s:<S2SV_blank>set<S2SV_blank>mode:<S2SV_blank>%s" , np , strerror ( errno ) ) ; wrerr = DISPLAYED ; } } if ( close ( ofd ) == - 1 ) { wrerr = YES ; wrerrno = errno ; } ( void ) response ( ) ; if ( showprogress ) stop_progress_meter ( ) ; if ( setimes && wrerr == NO ) { setimes = 0 ; if ( utimes ( np , tv ) < 0 ) { run_err ( "%s:<S2SV_blank>set<S2SV_blank>times:<S2SV_blank>%s" , np , strerror ( errno ) ) ; wrerr = DISPLAYED ; } } switch ( wrerr ) { case YES : run_err ( "%s:<S2SV_blank>%s" , np , strerror ( wrerrno ) ) ; break ; case NO : ( void ) atomicio ( vwrite , remout , "" , 1 ) ; break ; case DISPLAYED : break ; } } screwup : run_err ( "protocol<S2SV_blank>error:<S2SV_blank>%s" , why ) ; exit ( 1 ) ; }
CWE-190 static void Process_ipfix_template_add ( exporter_ipfix_domain_t * exporter , void * DataPtr , uint32_t size_left , FlowSource_t * fs ) { input_translation_t * translation_table ; ipfix_template_record_t * ipfix_template_record ; ipfix_template_elements_std_t * NextElement ; int i ; while ( size_left ) { uint32_t table_id , count , size_required ; uint32_t num_extensions = 0 ; <S2SV_StartBug> if ( size_left && size_left < 4 ) { <S2SV_EndBug> LogError ( "Process_ipfix<S2SV_blank>[%u]<S2SV_blank>Template<S2SV_blank>size<S2SV_blank>error<S2SV_blank>at<S2SV_blank>%s<S2SV_blank>line<S2SV_blank>%u" , exporter -> info . id , __FILE__ , __LINE__ , strerror ( errno ) ) ; size_left = 0 ; continue ; } ipfix_template_record = ( ipfix_template_record_t * ) DataPtr ; size_left -= 4 ; table_id = ntohs ( ipfix_template_record -> TemplateID ) ; count = ntohs ( ipfix_template_record -> FieldCount ) ; dbg_printf ( "\\n[%u]<S2SV_blank>Template<S2SV_blank>ID:<S2SV_blank>%u\\n" , exporter -> info . id , table_id ) ; dbg_printf ( "FieldCount:<S2SV_blank>%u<S2SV_blank>buffersize:<S2SV_blank>%u\\n" , count , size_left ) ; memset ( ( void * ) cache . common_extensions , 0 , ( Max_num_extensions + 1 ) * sizeof ( uint32_t ) ) ; memset ( ( void * ) cache . lookup_info , 0 , 65536 * sizeof ( struct element_param_s ) ) ; for ( i = 1 ; ipfix_element_map [ i ] . id != 0 ; i ++ ) { uint32_t Type = ipfix_element_map [ i ] . id ; if ( ipfix_element_map [ i ] . id == ipfix_element_map [ i - 1 ] . id ) continue ; cache . lookup_info [ Type ] . index = i ; } cache . input_order = calloc ( count , sizeof ( struct order_s ) ) ; if ( ! cache . input_order ) { LogError ( "Process_ipfix:<S2SV_blank>Panic!<S2SV_blank>malloc():<S2SV_blank>%s<S2SV_blank>line<S2SV_blank>%d:<S2SV_blank>%s" , __FILE__ , __LINE__ , strerror ( errno ) ) ; size_left = 0 ; continue ; } cache . input_count = count ; size_required = 4 * count ; if ( size_left < size_required ) { LogError ( "Process_ipfix:<S2SV_blank>[%u]<S2SV_blank>Not<S2SV_blank>enough<S2SV_blank>data<S2SV_blank>for<S2SV_blank>template<S2SV_blank>elements!<S2SV_blank>required:<S2SV_blank>%i,<S2SV_blank>left:<S2SV_blank>%u" , exporter -> info . id , size_required , size_left ) ; dbg_printf ( "ERROR:<S2SV_blank>Not<S2SV_blank>enough<S2SV_blank>data<S2SV_blank>for<S2SV_blank>template<S2SV_blank>elements!<S2SV_blank>required:<S2SV_blank>%i,<S2SV_blank>left:<S2SV_blank>%u" , size_required , size_left ) ; return ; } NextElement = ( ipfix_template_elements_std_t * ) ipfix_template_record -> elements ; for ( i = 0 ; i < count ; i ++ ) { uint16_t Type , Length ; uint32_t ext_id ; int Enterprise ; Type = ntohs ( NextElement -> Type ) ; Length = ntohs ( NextElement -> Length ) ; Enterprise = Type & 0x8000 ? 1 : 0 ; Type = Type & 0x7FFF ; ext_id = MapElement ( Type , Length , i ) ; if ( ext_id && extension_descriptor [ ext_id ] . enabled ) { if ( cache . common_extensions [ ext_id ] == 0 ) { cache . common_extensions [ ext_id ] = 1 ; num_extensions ++ ; } } if ( Enterprise ) { ipfix_template_elements_e_t * e = ( ipfix_template_elements_e_t * ) NextElement ; size_required += 4 ; if ( size_left < size_required ) { LogError ( "Process_ipfix:<S2SV_blank>[%u]<S2SV_blank>Not<S2SV_blank>enough<S2SV_blank>data<S2SV_blank>for<S2SV_blank>template<S2SV_blank>elements!<S2SV_blank>required:<S2SV_blank>%i,<S2SV_blank>left:<S2SV_blank>%u" , exporter -> info . id , size_required , size_left ) ; dbg_printf ( "ERROR:<S2SV_blank>Not<S2SV_blank>enough<S2SV_blank>data<S2SV_blank>for<S2SV_blank>template<S2SV_blank>elements!<S2SV_blank>required:<S2SV_blank>%i,<S2SV_blank>left:<S2SV_blank>%u" , size_required , size_left ) ; return ; } if ( ntohl ( e -> EnterpriseNumber ) == IPFIX_ReverseInformationElement ) { dbg_printf ( "<S2SV_blank>[%i]<S2SV_blank>Enterprise:<S2SV_blank>1,<S2SV_blank>Type:<S2SV_blank>%u,<S2SV_blank>Length<S2SV_blank>%u<S2SV_blank>Reverse<S2SV_blank>Information<S2SV_blank>Element:<S2SV_blank>%u\\n" , i , Type , Length , ntohl ( e -> EnterpriseNumber ) ) ; } else { dbg_printf ( "<S2SV_blank>[%i]<S2SV_blank>Enterprise:<S2SV_blank>1,<S2SV_blank>Type:<S2SV_blank>%u,<S2SV_blank>Length<S2SV_blank>%u<S2SV_blank>EnterpriseNumber:<S2SV_blank>%u\\n" , i , Type , Length , ntohl ( e -> EnterpriseNumber ) ) ; } e ++ ; NextElement = ( ipfix_template_elements_std_t * ) e ; } else { dbg_printf ( "<S2SV_blank>[%i]<S2SV_blank>Enterprise:<S2SV_blank>0,<S2SV_blank>Type:<S2SV_blank>%u,<S2SV_blank>Length<S2SV_blank>%u\\n" , i , Type , Length ) ; NextElement ++ ; } } dbg_printf ( "Processed:<S2SV_blank>%u\\n" , size_required ) ; if ( compact_input_order ( ) ) { if ( extension_descriptor [ EX_ROUTER_IP_v4 ] . enabled ) { if ( cache . common_extensions [ EX_ROUTER_IP_v4 ] == 0 ) { cache . common_extensions [ EX_ROUTER_IP_v4 ] = 1 ; num_extensions ++ ; } dbg_printf ( "Add<S2SV_blank>sending<S2SV_blank>router<S2SV_blank>IP<S2SV_blank>address<S2SV_blank>(%s)<S2SV_blank>=><S2SV_blank>Extension:<S2SV_blank>%u\\n" , fs -> sa_family == PF_INET6 ? "ipv6" : "ipv4" , EX_ROUTER_IP_v4 ) ; } extension_descriptor [ EX_ROUTER_ID ] . enabled = 0 ; if ( extension_descriptor [ EX_RECEIVED ] . enabled ) { if ( cache . common_extensions [ EX_RECEIVED ] == 0 ) { cache . common_extensions [ EX_RECEIVED ] = 1 ; num_extensions ++ ; } dbg_printf ( "Force<S2SV_blank>add<S2SV_blank>packet<S2SV_blank>received<S2SV_blank>time,<S2SV_blank>Extension:<S2SV_blank>%u\\n" , EX_RECEIVED ) ; } # ifdef DEVEL { int i ; for ( i = 4 ; extension_descriptor [ i ] . id ; i ++ ) { if ( cache . common_extensions [ i ] ) { printf ( "Enabled<S2SV_blank>extension:<S2SV_blank>%i\\n" , i ) ; } } } # endif translation_table = setup_translation_table ( exporter , table_id ) ; if ( translation_table -> extension_map_changed ) { dbg_printf ( "Translation<S2SV_blank>Table<S2SV_blank>changed!<S2SV_blank>Add<S2SV_blank>extension<S2SV_blank>map<S2SV_blank>ID:<S2SV_blank>%i\\n" , translation_table -> extension_info . map -> map_id ) ; AddExtensionMap ( fs , translation_table -> extension_info . map ) ; translation_table -> extension_map_changed = 0 ; dbg_printf ( "Translation<S2SV_blank>Table<S2SV_blank>added!<S2SV_blank>map<S2SV_blank>ID:<S2SV_blank>%i\\n" , translation_table -> extension_info . map -> map_id ) ; } if ( ! reorder_sequencer ( translation_table ) ) { LogError ( "Process_ipfix:<S2SV_blank>[%u]<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>reorder<S2SV_blank>sequencer.<S2SV_blank>Remove<S2SV_blank>table<S2SV_blank>id:<S2SV_blank>%u" , exporter -> info . id , table_id ) ; remove_translation_table ( fs , exporter , table_id ) ; } } else { dbg_printf ( "Template<S2SV_blank>does<S2SV_blank>not<S2SV_blank>contain<S2SV_blank>any<S2SV_blank>common<S2SV_blank>fields<S2SV_blank>-<S2SV_blank>skip\\n" ) ; } size_left -= size_required ; DataPtr = DataPtr + size_required + 4 ; if ( size_left < 4 ) { dbg_printf ( "Skip<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>padding\\n" , size_left ) ; size_left = 0 ; } free ( cache . input_order ) ; cache . input_order = NULL ; } }
CWE-190 static void Process_ipfix_template_withdraw ( exporter_ipfix_domain_t * exporter , void * DataPtr , uint32_t size_left , FlowSource_t * fs ) { ipfix_template_record_t * ipfix_template_record ; while ( size_left ) { <S2SV_StartBug> uint32_t id ; <S2SV_EndBug> ipfix_template_record = ( ipfix_template_record_t * ) DataPtr ; size_left -= 4 ; id = ntohs ( ipfix_template_record -> TemplateID ) ; if ( id == IPFIX_TEMPLATE_FLOWSET_ID ) { remove_all_translation_tables ( exporter ) ; ReInitExtensionMapList ( fs ) ; } else { remove_translation_table ( fs , exporter , id ) ; } DataPtr = DataPtr + 4 ; if ( size_left < 4 ) { dbg_printf ( "Skip<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>padding\\n" , size_left ) ; size_left = 0 ; } } }
CWE-415 void gdImageGifCtx ( gdImagePtr im , gdIOCtxPtr out ) { <S2SV_StartBug> gdImagePtr pim = 0 , tim = im ; <S2SV_EndBug> int interlace , BitsPerPixel ; interlace = im -> interlace ; if ( im -> trueColor ) { <S2SV_StartBug> pim = gdImageCreatePaletteFromTrueColor ( im , 1 , 256 ) ; <S2SV_EndBug> if ( ! pim ) { return ; } tim = pim ; } BitsPerPixel = colorstobpp ( tim -> colorsTotal ) ; GIFEncode ( out , tim -> sx , tim -> sy , tim -> interlace , 0 , tim -> transparent , BitsPerPixel , tim -> red , tim -> green , tim -> blue , tim ) ; if ( pim ) { gdImageDestroy ( pim ) ; } <S2SV_StartBug> } <S2SV_EndBug>
CWE-415 void * gdImageGifPtr ( gdImagePtr im , int * size ) { void * rv ; gdIOCtx * out = gdNewDynamicCtx ( 2048 , NULL ) ; <S2SV_StartBug> gdImageGifCtx ( im , out ) ; <S2SV_EndBug> <S2SV_StartBug> rv = gdDPExtractData ( out , size ) ; <S2SV_EndBug> out -> gd_free ( out ) ; return rv ; }
CWE-415 void gdImageWBMPCtx ( gdImagePtr image , int fg , gdIOCtx * out ) { <S2SV_StartBug> int x , y , pos ; <S2SV_EndBug> Wbmp * wbmp ; if ( ( wbmp = createwbmp ( gdImageSX ( image ) , gdImageSY ( image ) , WBMP_WHITE ) ) == NULL ) { gd_error ( "Could<S2SV_blank>not<S2SV_blank>create<S2SV_blank>WBMP" ) ; return ; } pos = 0 ; for ( y = 0 ; y < gdImageSY ( image ) ; y ++ ) { for ( x = 0 ; x < gdImageSX ( image ) ; x ++ ) { <S2SV_StartBug> if ( gdImageGetPixel ( image , x , y ) == fg ) { <S2SV_EndBug> wbmp -> bitmap [ pos ] = WBMP_BLACK ; } pos ++ ; } } if ( writewbmp ( wbmp , & gd_putout , out ) ) { gd_error ( "Could<S2SV_blank>not<S2SV_blank>save<S2SV_blank>WBMP" ) ; } freewbmp ( wbmp ) ; }
CWE-415 void * gdImageWBMPPtr ( gdImagePtr im , int * size , int fg ) { void * rv ; gdIOCtx * out = gdNewDynamicCtx ( 2048 , NULL ) ; <S2SV_StartBug> gdImageWBMPCtx ( im , fg , out ) ; <S2SV_EndBug> <S2SV_StartBug> rv = gdDPExtractData ( out , size ) ; <S2SV_EndBug> out -> gd_free ( out ) ; return rv ; }
CWE-20 int main ( int argc , char * * argv ) { mode_t old_umask ; <S2SV_StartBug> cleanup_free char * base_path = NULL ; <S2SV_EndBug> int clone_flags ; char * old_cwd = NULL ; pid_t pid ; int event_fd = - 1 ; int child_wait_fd = - 1 ; int setup_finished_pipe [ ] = { - 1 , - 1 } ; const char * new_cwd ; uid_t ns_uid ; gid_t ns_gid ; struct stat sbuf ; uint64_t val ; int res UNUSED ; cleanup_free char * seccomp_data = NULL ; size_t seccomp_len ; struct sock_fprog seccomp_prog ; cleanup_free char * args_data = NULL ; if ( argc == 2 && ( strcmp ( argv [ 1 ] , "--version" ) == 0 ) ) print_version_and_exit ( ) ; real_uid = getuid ( ) ; real_gid = getgid ( ) ; acquire_privs ( ) ; if ( prctl ( PR_SET_NO_NEW_PRIVS , 1 , 0 , 0 , 0 ) < 0 ) die_with_error ( "prctl(PR_SET_NO_NEW_CAPS)<S2SV_blank>failed" ) ; read_overflowids ( ) ; argv0 = argv [ 0 ] ; if ( isatty ( 1 ) ) host_tty_dev = ttyname ( 1 ) ; argv ++ ; argc -- ; if ( argc == 0 ) usage ( EXIT_FAILURE , stderr ) ; parse_args ( & argc , ( const char * * * ) & argv ) ; args_data = opt_args_data ; opt_args_data = NULL ; if ( ( requested_caps [ 0 ] || requested_caps [ 1 ] ) && is_privileged ) die ( "--cap-add<S2SV_blank>in<S2SV_blank>setuid<S2SV_blank>mode<S2SV_blank>can<S2SV_blank>be<S2SV_blank>used<S2SV_blank>only<S2SV_blank>by<S2SV_blank>root" ) ; if ( opt_userns_block_fd != - 1 && ! opt_unshare_user ) die ( "--userns-block-fd<S2SV_blank>requires<S2SV_blank>--unshare-user" ) ; if ( opt_userns_block_fd != - 1 && opt_info_fd == - 1 ) die ( "--userns-block-fd<S2SV_blank>requires<S2SV_blank>--info-fd" ) ; if ( ! is_privileged && getuid ( ) != 0 ) opt_unshare_user = TRUE ; # ifdef ENABLE_REQUIRE_USERNS if ( is_privileged && getuid ( ) != 0 ) opt_unshare_user = TRUE ; # endif if ( opt_unshare_user_try && stat ( "/proc/self/ns/user" , & sbuf ) == 0 ) { bool disabled = FALSE ; if ( stat ( "/sys/module/user_namespace/parameters/enable" , & sbuf ) == 0 ) { cleanup_free char * enable = NULL ; enable = load_file_at ( AT_FDCWD , "/sys/module/user_namespace/parameters/enable" ) ; if ( enable != NULL && enable [ 0 ] == 'N' ) disabled = TRUE ; } if ( stat ( "/proc/sys/user/max_user_namespaces" , & sbuf ) == 0 ) { cleanup_free char * max_user_ns = NULL ; max_user_ns = load_file_at ( AT_FDCWD , "/proc/sys/user/max_user_namespaces" ) ; if ( max_user_ns != NULL && strcmp ( max_user_ns , "0\\n" ) == 0 ) disabled = TRUE ; } if ( ! disabled ) opt_unshare_user = TRUE ; } if ( argc == 0 ) usage ( EXIT_FAILURE , stderr ) ; __debug__ ( ( "Creating<S2SV_blank>root<S2SV_blank>mount<S2SV_blank>point\\n" ) ) ; if ( opt_sandbox_uid == - 1 ) opt_sandbox_uid = real_uid ; if ( opt_sandbox_gid == - 1 ) opt_sandbox_gid = real_gid ; if ( ! opt_unshare_user && opt_sandbox_uid != real_uid ) die ( "Specifying<S2SV_blank>--uid<S2SV_blank>requires<S2SV_blank>--unshare-user" ) ; if ( ! opt_unshare_user && opt_sandbox_gid != real_gid ) die ( "Specifying<S2SV_blank>--gid<S2SV_blank>requires<S2SV_blank>--unshare-user" ) ; if ( ! opt_unshare_uts && opt_sandbox_hostname != NULL ) die ( "Specifying<S2SV_blank>--hostname<S2SV_blank>requires<S2SV_blank>--unshare-uts" ) ; if ( opt_as_pid_1 && ! opt_unshare_pid ) die ( "Specifying<S2SV_blank>--as-pid-1<S2SV_blank>requires<S2SV_blank>--unshare-pid" ) ; if ( opt_as_pid_1 && lock_files != NULL ) die ( "Specifying<S2SV_blank>--as-pid-1<S2SV_blank>and<S2SV_blank>--lock-file<S2SV_blank>is<S2SV_blank>not<S2SV_blank>permitted" ) ; proc_fd = open ( "/proc" , O_PATH ) ; if ( proc_fd == - 1 ) die_with_error ( "Can\'t<S2SV_blank>open<S2SV_blank>/proc" ) ; <S2SV_StartBug> base_path = xasprintf ( "/run/user/%d/.bubblewrap" , real_uid ) ; <S2SV_EndBug> if ( ensure_dir ( base_path , 0755 ) ) { free ( base_path ) ; base_path = xasprintf ( "/tmp/.bubblewrap-%d" , real_uid ) ; if ( ensure_dir ( base_path , 0755 ) ) die_with_error ( "Creating<S2SV_blank>root<S2SV_blank>mountpoint<S2SV_blank>failed" ) ; } __debug__ ( ( "creating<S2SV_blank>new<S2SV_blank>namespace\\n" ) ) ; if ( opt_unshare_pid && ! opt_as_pid_1 ) { event_fd = eventfd ( 0 , EFD_CLOEXEC | EFD_NONBLOCK ) ; if ( event_fd == - 1 ) die_with_error ( "eventfd()" ) ; } block_sigchild ( ) ; clone_flags = SIGCHLD | CLONE_NEWNS ; if ( opt_unshare_user ) clone_flags |= CLONE_NEWUSER ; if ( opt_unshare_pid ) clone_flags |= CLONE_NEWPID ; if ( opt_unshare_net ) clone_flags |= CLONE_NEWNET ; if ( opt_unshare_ipc ) clone_flags |= CLONE_NEWIPC ; if ( opt_unshare_uts ) clone_flags |= CLONE_NEWUTS ; if ( opt_unshare_cgroup ) { if ( stat ( "/proc/self/ns/cgroup" , & sbuf ) ) { if ( errno == ENOENT ) die ( "Cannot<S2SV_blank>create<S2SV_blank>new<S2SV_blank>cgroup<S2SV_blank>namespace<S2SV_blank>because<S2SV_blank>the<S2SV_blank>kernel<S2SV_blank>does<S2SV_blank>not<S2SV_blank>support<S2SV_blank>it" ) ; else die_with_error ( "stat<S2SV_blank>on<S2SV_blank>/proc/self/ns/cgroup<S2SV_blank>failed" ) ; } clone_flags |= CLONE_NEWCGROUP ; } if ( opt_unshare_cgroup_try ) if ( ! stat ( "/proc/self/ns/cgroup" , & sbuf ) ) clone_flags |= CLONE_NEWCGROUP ; child_wait_fd = eventfd ( 0 , EFD_CLOEXEC ) ; if ( child_wait_fd == - 1 ) die_with_error ( "eventfd()" ) ; if ( opt_json_status_fd != - 1 ) { int ret ; ret = pipe2 ( setup_finished_pipe , O_CLOEXEC ) ; if ( ret == - 1 ) die_with_error ( "pipe2()" ) ; } pid = raw_clone ( clone_flags , NULL ) ; if ( pid == - 1 ) { if ( opt_unshare_user ) { if ( errno == EINVAL ) die ( "Creating<S2SV_blank>new<S2SV_blank>namespace<S2SV_blank>failed,<S2SV_blank>likely<S2SV_blank>because<S2SV_blank>the<S2SV_blank>kernel<S2SV_blank>does<S2SV_blank>not<S2SV_blank>support<S2SV_blank>user<S2SV_blank>namespaces.<S2SV_blank><S2SV_blank>bwrap<S2SV_blank>must<S2SV_blank>be<S2SV_blank>installed<S2SV_blank>setuid<S2SV_blank>on<S2SV_blank>such<S2SV_blank>systems." ) ; else if ( errno == EPERM && ! is_privileged ) die ( "No<S2SV_blank>permissions<S2SV_blank>to<S2SV_blank>creating<S2SV_blank>new<S2SV_blank>namespace,<S2SV_blank>likely<S2SV_blank>because<S2SV_blank>the<S2SV_blank>kernel<S2SV_blank>does<S2SV_blank>not<S2SV_blank>allow<S2SV_blank>non-privileged<S2SV_blank>user<S2SV_blank>namespaces.<S2SV_blank>On<S2SV_blank>e.g.<S2SV_blank>debian<S2SV_blank>this<S2SV_blank>can<S2SV_blank>be<S2SV_blank>enabled<S2SV_blank>with<S2SV_blank>\'sysctl<S2SV_blank>kernel.unprivileged_userns_clone=1\'." ) ; } die_with_error ( "Creating<S2SV_blank>new<S2SV_blank>namespace<S2SV_blank>failed" ) ; } ns_uid = opt_sandbox_uid ; ns_gid = opt_sandbox_gid ; if ( pid != 0 ) { if ( is_privileged && opt_unshare_user && opt_userns_block_fd == - 1 ) { write_uid_gid_map ( ns_uid , real_uid , ns_gid , real_gid , pid , TRUE , opt_needs_devpts ) ; } drop_privs ( FALSE ) ; handle_die_with_parent ( ) ; if ( opt_info_fd != - 1 ) { cleanup_free char * output = xasprintf ( "{\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>\\"child-pid\\":<S2SV_blank>%i\\n}\\n" , pid ) ; dump_info ( opt_info_fd , output , TRUE ) ; close ( opt_info_fd ) ; } if ( opt_json_status_fd != - 1 ) { cleanup_free char * output = xasprintf ( "{<S2SV_blank>\\"child-pid\\":<S2SV_blank>%i<S2SV_blank>}\\n" , pid ) ; dump_info ( opt_json_status_fd , output , TRUE ) ; } if ( opt_userns_block_fd != - 1 ) { char b [ 1 ] ; ( void ) TEMP_FAILURE_RETRY ( read ( opt_userns_block_fd , b , 1 ) ) ; close ( opt_userns_block_fd ) ; } val = 1 ; res = write ( child_wait_fd , & val , 8 ) ; close ( child_wait_fd ) ; return monitor_child ( event_fd , pid , setup_finished_pipe [ 0 ] ) ; } if ( opt_info_fd != - 1 ) close ( opt_info_fd ) ; if ( opt_json_status_fd != - 1 ) close ( opt_json_status_fd ) ; res = read ( child_wait_fd , & val , 8 ) ; close ( child_wait_fd ) ; switch_to_user_with_privs ( ) ; if ( opt_unshare_net ) loopback_setup ( ) ; ns_uid = opt_sandbox_uid ; ns_gid = opt_sandbox_gid ; if ( ! is_privileged && opt_unshare_user && opt_userns_block_fd == - 1 ) { if ( opt_needs_devpts ) { ns_uid = 0 ; ns_gid = 0 ; } write_uid_gid_map ( ns_uid , real_uid , ns_gid , real_gid , - 1 , TRUE , FALSE ) ; } old_umask = umask ( 0 ) ; resolve_symlinks_in_ops ( ) ; if ( mount ( NULL , "/" , NULL , MS_SLAVE | MS_REC , NULL ) < 0 ) die_with_error ( "Failed<S2SV_blank>to<S2SV_blank>make<S2SV_blank>/<S2SV_blank>slave" ) ; if ( mount ( "tmpfs" , base_path , "tmpfs" , MS_NODEV | MS_NOSUID , NULL ) != 0 ) die_with_error ( "Failed<S2SV_blank>to<S2SV_blank>mount<S2SV_blank>tmpfs" ) ; old_cwd = get_current_dir_name ( ) ; if ( chdir ( base_path ) != 0 ) die_with_error ( "chdir<S2SV_blank>base_path" ) ; if ( mkdir ( "newroot" , 0755 ) ) die_with_error ( "Creating<S2SV_blank>newroot<S2SV_blank>failed" ) ; if ( mount ( "newroot" , "newroot" , NULL , MS_MGC_VAL | MS_BIND | MS_REC , NULL ) < 0 ) die_with_error ( "setting<S2SV_blank>up<S2SV_blank>newroot<S2SV_blank>bind" ) ; if ( mkdir ( "oldroot" , 0755 ) ) die_with_error ( "Creating<S2SV_blank>oldroot<S2SV_blank>failed" ) ; if ( pivot_root ( base_path , "oldroot" ) ) die_with_error ( "pivot_root" ) ; if ( chdir ( "/" ) != 0 ) die_with_error ( "chdir<S2SV_blank>/<S2SV_blank>(base<S2SV_blank>path)" ) ; if ( is_privileged ) { pid_t child ; int privsep_sockets [ 2 ] ; if ( socketpair ( AF_UNIX , SOCK_SEQPACKET | SOCK_CLOEXEC , 0 , privsep_sockets ) != 0 ) die_with_error ( "Can\'t<S2SV_blank>create<S2SV_blank>privsep<S2SV_blank>socket" ) ; child = fork ( ) ; if ( child == - 1 ) die_with_error ( "Can\'t<S2SV_blank>fork<S2SV_blank>unprivileged<S2SV_blank>helper" ) ; if ( child == 0 ) { drop_privs ( FALSE ) ; close ( privsep_sockets [ 0 ] ) ; setup_newroot ( opt_unshare_pid , privsep_sockets [ 1 ] ) ; exit ( 0 ) ; } else { int status ; uint32_t buffer [ 2048 ] ; uint32_t op , flags ; const char * arg1 , * arg2 ; cleanup_fd int unpriv_socket = - 1 ; unpriv_socket = privsep_sockets [ 0 ] ; close ( privsep_sockets [ 1 ] ) ; do { op = read_priv_sec_op ( unpriv_socket , buffer , sizeof ( buffer ) , & flags , & arg1 , & arg2 ) ; privileged_op ( - 1 , op , flags , arg1 , arg2 ) ; if ( write ( unpriv_socket , buffer , 1 ) != 1 ) die ( "Can\'t<S2SV_blank>write<S2SV_blank>to<S2SV_blank>op_socket" ) ; } while ( op != PRIV_SEP_OP_DONE ) ; waitpid ( child , & status , 0 ) ; } } else { setup_newroot ( opt_unshare_pid , - 1 ) ; } close_ops_fd ( ) ; if ( mount ( "oldroot" , "oldroot" , NULL , MS_REC | MS_PRIVATE , NULL ) != 0 ) die_with_error ( "Failed<S2SV_blank>to<S2SV_blank>make<S2SV_blank>old<S2SV_blank>root<S2SV_blank>rprivate" ) ; if ( umount2 ( "oldroot" , MNT_DETACH ) ) die_with_error ( "unmount<S2SV_blank>old<S2SV_blank>root" ) ; { cleanup_fd int oldrootfd = open ( "/" , O_DIRECTORY | O_RDONLY ) ; if ( oldrootfd < 0 ) die_with_error ( "can\'t<S2SV_blank>open<S2SV_blank>/" ) ; if ( chdir ( "/newroot" ) != 0 ) die_with_error ( "chdir<S2SV_blank>/newroot" ) ; if ( pivot_root ( "." , "." ) != 0 ) die_with_error ( "pivot_root(/newroot)" ) ; if ( fchdir ( oldrootfd ) < 0 ) die_with_error ( "fchdir<S2SV_blank>to<S2SV_blank>oldroot" ) ; if ( umount2 ( "." , MNT_DETACH ) < 0 ) die_with_error ( "umount<S2SV_blank>old<S2SV_blank>root" ) ; if ( chdir ( "/" ) != 0 ) die_with_error ( "chdir<S2SV_blank>/" ) ; } if ( opt_unshare_user && ( ns_uid != opt_sandbox_uid || ns_gid != opt_sandbox_gid ) && opt_userns_block_fd == - 1 ) { if ( unshare ( CLONE_NEWUSER ) ) die_with_error ( "unshare<S2SV_blank>user<S2SV_blank>ns" ) ; write_uid_gid_map ( opt_sandbox_uid , ns_uid , opt_sandbox_gid , ns_gid , - 1 , FALSE , FALSE ) ; } drop_privs ( ! is_privileged ) ; if ( opt_block_fd != - 1 ) { char b [ 1 ] ; ( void ) TEMP_FAILURE_RETRY ( read ( opt_block_fd , b , 1 ) ) ; close ( opt_block_fd ) ; } if ( opt_seccomp_fd != - 1 ) { seccomp_data = load_file_data ( opt_seccomp_fd , & seccomp_len ) ; if ( seccomp_data == NULL ) die_with_error ( "Can\'t<S2SV_blank>read<S2SV_blank>seccomp<S2SV_blank>data" ) ; if ( seccomp_len % 8 != 0 ) die ( "Invalid<S2SV_blank>seccomp<S2SV_blank>data,<S2SV_blank>must<S2SV_blank>be<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>8" ) ; seccomp_prog . len = seccomp_len / 8 ; seccomp_prog . filter = ( struct sock_filter * ) seccomp_data ; close ( opt_seccomp_fd ) ; } umask ( old_umask ) ; new_cwd = "/" ; if ( opt_chdir_path ) { if ( chdir ( opt_chdir_path ) ) die_with_error ( "Can\'t<S2SV_blank>chdir<S2SV_blank>to<S2SV_blank>%s" , opt_chdir_path ) ; new_cwd = opt_chdir_path ; } else if ( chdir ( old_cwd ) == 0 ) { new_cwd = old_cwd ; } else { const char * home = getenv ( "HOME" ) ; if ( home != NULL && chdir ( home ) == 0 ) new_cwd = home ; } xsetenv ( "PWD" , new_cwd , 1 ) ; free ( old_cwd ) ; if ( opt_new_session && setsid ( ) == ( pid_t ) - 1 ) die_with_error ( "setsid" ) ; if ( label_exec ( opt_exec_label ) == - 1 ) die_with_error ( "label_exec<S2SV_blank>%s" , argv [ 0 ] ) ; __debug__ ( ( "forking<S2SV_blank>for<S2SV_blank>child\\n" ) ) ; if ( ! opt_as_pid_1 && ( opt_unshare_pid || lock_files != NULL || opt_sync_fd != - 1 ) ) { pid = fork ( ) ; if ( pid == - 1 ) die_with_error ( "Can\'t<S2SV_blank>fork<S2SV_blank>for<S2SV_blank>pid<S2SV_blank>1" ) ; if ( pid != 0 ) { drop_all_caps ( FALSE ) ; { int dont_close [ 3 ] ; int j = 0 ; if ( event_fd != - 1 ) dont_close [ j ++ ] = event_fd ; if ( opt_sync_fd != - 1 ) dont_close [ j ++ ] = opt_sync_fd ; dont_close [ j ++ ] = - 1 ; fdwalk ( proc_fd , close_extra_fds , dont_close ) ; } return do_init ( event_fd , pid , seccomp_data != NULL ? & seccomp_prog : NULL ) ; } } __debug__ ( ( "launch<S2SV_blank>executable<S2SV_blank>%s\\n" , argv [ 0 ] ) ) ; if ( proc_fd != - 1 ) close ( proc_fd ) ; if ( ! opt_as_pid_1 ) { if ( opt_sync_fd != - 1 ) close ( opt_sync_fd ) ; } unblock_sigchild ( ) ; handle_die_with_parent ( ) ; if ( ! is_privileged ) set_ambient_capabilities ( ) ; if ( seccomp_data != NULL && prctl ( PR_SET_SECCOMP , SECCOMP_MODE_FILTER , & seccomp_prog ) != 0 ) die_with_error ( "prctl(PR_SET_SECCOMP)" ) ; if ( setup_finished_pipe [ 1 ] != - 1 ) { char data = 0 ; res = write_to_fd ( setup_finished_pipe [ 1 ] , & data , 1 ) ; } if ( execvp ( argv [ 0 ] , argv ) == - 1 ) { if ( setup_finished_pipe [ 1 ] != - 1 ) { int saved_errno = errno ; char data = 0 ; res = write_to_fd ( setup_finished_pipe [ 1 ] , & data , 1 ) ; errno = saved_errno ; } die_with_error ( "execvp<S2SV_blank>%s" , argv [ 0 ] ) ; } return 0 ; }
CWE-78 static char * __filterQuotedShell ( const char * arg ) { r_return_val_if_fail ( arg , NULL ) ; char * a = malloc ( strlen ( arg ) + 1 ) ; if ( ! a ) { return NULL ; } char * b = a ; while ( * arg ) { switch ( * arg ) { case '<S2SV_blank>' : case '=' : <S2SV_StartBug> case '\\r' : <S2SV_EndBug> case '\\n' : break ; default : * b ++ = * arg ; break ; } arg ++ ; } * b = 0 ; return a ; }
CWE-78 static char * __filterShell ( const char * arg ) { r_return_val_if_fail ( arg , NULL ) ; char * a = malloc ( strlen ( arg ) + 1 ) ; if ( ! a ) { return NULL ; } char * b = a ; while ( * arg ) { <S2SV_StartBug> switch ( * arg ) { <S2SV_EndBug> case '@' : case '`' : case '|' : case ';' : <S2SV_StartBug> case '\\n' : <S2SV_EndBug> break ; default : <S2SV_StartBug> * b ++ = * arg ; <S2SV_EndBug> break ; } arg ++ ; } * b = 0 ; return a ; }
CWE-78 static int bin_symbols ( RCore * r , int mode , ut64 laddr , int va , ut64 at , const char * name , bool exponly , const char * args ) { RBinInfo * info = r_bin_get_info ( r -> bin ) ; RList * entries = r_bin_get_entries ( r -> bin ) ; RBinSymbol * symbol ; RBinAddr * entry ; RListIter * iter ; bool firstexp = true ; bool printHere = false ; int i = 0 , lastfs = 's' ; bool bin_demangle = r_config_get_i ( r -> config , "bin.demangle" ) ; if ( ! info ) { return 0 ; } if ( args && * args == '.' ) { printHere = true ; } bool is_arm = info && info -> arch && ! strncmp ( info -> arch , "arm" , 3 ) ; const char * lang = bin_demangle ? r_config_get ( r -> config , "bin.lang" ) : NULL ; RList * symbols = r_bin_get_symbols ( r -> bin ) ; r_spaces_push ( & r -> anal -> meta_spaces , "bin" ) ; if ( IS_MODE_JSON ( mode ) && ! printHere ) { r_cons_printf ( "[" ) ; } else if ( IS_MODE_SET ( mode ) ) { r_flag_space_set ( r -> flags , R_FLAGS_FS_SYMBOLS ) ; } else if ( ! at && exponly ) { if ( IS_MODE_RAD ( mode ) ) { r_cons_printf ( "fs<S2SV_blank>exports\\n" ) ; } else if ( IS_MODE_NORMAL ( mode ) ) { r_cons_printf ( printHere ? "" : "[Exports]\\n" ) ; } } else if ( ! at && ! exponly ) { if ( IS_MODE_RAD ( mode ) ) { r_cons_printf ( "fs<S2SV_blank>symbols\\n" ) ; } else if ( IS_MODE_NORMAL ( mode ) ) { r_cons_printf ( printHere ? "" : "[Symbols]\\n" ) ; } } if ( IS_MODE_NORMAL ( mode ) ) { r_cons_printf ( "Num<S2SV_blank>Paddr<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Vaddr<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Bind<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Type<S2SV_blank>Size<S2SV_blank>Name\\n" ) ; } size_t count = 0 ; r_list_foreach ( symbols , iter , symbol ) { if ( ! symbol -> name ) { continue ; } char * r_symbol_name = r_str_escape_utf8 ( symbol -> name , false , true ) ; ut64 addr = compute_addr ( r -> bin , symbol -> paddr , symbol -> vaddr , va ) ; int len = symbol -> size ? symbol -> size : 32 ; SymName sn = { 0 } ; if ( exponly && ! isAnExport ( symbol ) ) { free ( r_symbol_name ) ; continue ; } if ( name && strcmp ( r_symbol_name , name ) ) { free ( r_symbol_name ) ; continue ; } if ( at && ( ! symbol -> size || ! is_in_range ( at , addr , symbol -> size ) ) ) { free ( r_symbol_name ) ; continue ; } if ( ( printHere && ! is_in_range ( r -> offset , symbol -> paddr , len ) ) && ( printHere && ! is_in_range ( r -> offset , addr , len ) ) ) { free ( r_symbol_name ) ; continue ; } count ++ ; snInit ( r , & sn , symbol , lang ) ; if ( IS_MODE_SET ( mode ) && ( is_section_symbol ( symbol ) || is_file_symbol ( symbol ) ) ) { } else if ( IS_MODE_SET ( mode ) && is_special_symbol ( symbol ) ) { if ( is_arm ) { handle_arm_special_symbol ( r , symbol , va ) ; } } else if ( IS_MODE_SET ( mode ) ) { if ( is_arm ) { handle_arm_symbol ( r , symbol , info , va ) ; } select_flag_space ( r , symbol ) ; if ( sn . classname ) { RFlagItem * fi = r_flag_get ( r -> flags , sn . methflag ) ; if ( r -> bin -> prefix ) { char * prname = r_str_newf ( "%s.%s" , r -> bin -> prefix , sn . methflag ) ; r_name_filter ( sn . methflag , - 1 ) ; free ( sn . methflag ) ; sn . methflag = prname ; } if ( fi ) { r_flag_item_set_realname ( fi , sn . methname ) ; if ( ( fi -> offset - r -> flags -> base ) == addr ) { r_flag_unset ( r -> flags , fi ) ; } } else { fi = r_flag_set ( r -> flags , sn . methflag , addr , symbol -> size ) ; char * comment = fi -> comment ? strdup ( fi -> comment ) : NULL ; if ( comment ) { r_flag_item_set_comment ( fi , comment ) ; R_FREE ( comment ) ; } } } else { const char * n = sn . demname ? sn . demname : sn . name ; const char * fn = sn . demflag ? sn . demflag : sn . nameflag ; char * fnp = ( r -> bin -> prefix ) ? r_str_newf ( "%s.%s" , r -> bin -> prefix , fn ) : strdup ( fn ) ; RFlagItem * fi = r_flag_set ( r -> flags , fnp , addr , symbol -> size ) ; if ( fi ) { r_flag_item_set_realname ( fi , n ) ; fi -> demangled = ( bool ) ( size_t ) sn . demname ; } else { if ( fn ) { eprintf ( "[Warning]<S2SV_blank>Can\'t<S2SV_blank>find<S2SV_blank>flag<S2SV_blank>(%s)\\n" , fn ) ; } } free ( fnp ) ; } if ( sn . demname ) { r_meta_add ( r -> anal , R_META_TYPE_COMMENT , addr , symbol -> size , sn . demname ) ; } r_flag_space_pop ( r -> flags ) ; } else if ( IS_MODE_JSON ( mode ) ) { char * str = r_str_escape_utf8_for_json ( r_symbol_name , - 1 ) ; r_cons_printf ( "%s{\\"name\\":\\"%s\\"," "\\"demname\\":\\"%s\\"," "\\"flagname\\":\\"%s\\"," "\\"ordinal\\":%d," "\\"bind\\":\\"%s\\"," "\\"size\\":%d," "\\"type\\":\\"%s\\"," "\\"vaddr\\":%" PFMT64d "," "\\"paddr\\":%" PFMT64d "}" , ( ( exponly && firstexp ) || printHere ) ? "" : ( iter -> p ? "," : "" ) , str , sn . demname ? sn . demname : "" , sn . nameflag , symbol -> ordinal , symbol -> bind , ( int ) symbol -> size , symbol -> type , ( ut64 ) addr , ( ut64 ) symbol -> paddr ) ; free ( str ) ; } else if ( IS_MODE_SIMPLE ( mode ) ) { const char * name = sn . demname ? sn . demname : r_symbol_name ; r_cons_printf ( "0x%08" PFMT64x "<S2SV_blank>%d<S2SV_blank>%s\\n" , addr , ( int ) symbol -> size , name ) ; } else if ( IS_MODE_SIMPLEST ( mode ) ) { const char * name = sn . demname ? sn . demname : r_symbol_name ; r_cons_printf ( "%s\\n" , name ) ; } else if ( IS_MODE_RAD ( mode ) ) { if ( is_special_symbol ( symbol ) ) { goto next ; } RBinFile * binfile ; RBinPlugin * plugin ; const char * name = sn . demname ? sn . demname : r_symbol_name ; if ( ! name ) { goto next ; } if ( ! strncmp ( name , "imp." , 4 ) ) { if ( lastfs != 'i' ) { r_cons_printf ( "fs<S2SV_blank>imports\\n" ) ; } lastfs = 'i' ; } else { if ( lastfs != 's' ) { const char * fs = exponly ? "exports" : "symbols" ; r_cons_printf ( "fs<S2SV_blank>%s\\n" , fs ) ; } lastfs = 's' ; } if ( r -> bin -> prefix || * name ) { char * flagname = construct_symbol_flagname ( "sym" , name , MAXFLAG_LEN_DEFAULT ) ; if ( ! flagname ) { goto next ; } r_cons_printf ( "\\"f<S2SV_blank>%s%s%s<S2SV_blank>%u<S2SV_blank>0x%08" PFMT64x "\\"\\n" , r -> bin -> prefix ? r -> bin -> prefix : "" , r -> bin -> prefix ? "." : "" , flagname , symbol -> size , addr ) ; free ( flagname ) ; } binfile = r_bin_cur ( r -> bin ) ; plugin = r_bin_file_cur_plugin ( binfile ) ; if ( plugin && plugin -> name ) { if ( r_str_startswith ( plugin -> name , "pe" ) ) { char * module = strdup ( r_symbol_name ) ; char * p = strstr ( module , ".dll_" ) ; if ( p && strstr ( module , "imp." ) ) { char * symname = __filterShell ( p + 5 ) ; char * m = __filterShell ( module ) ; * p = 0 ; if ( r -> bin -> prefix ) { <S2SV_StartBug> r_cons_printf ( "k<S2SV_blank>bin/pe/%s/%d=%s.%s\\n" , <S2SV_EndBug> module , symbol -> ordinal , r -> bin -> prefix , symname ) ; } else { <S2SV_StartBug> r_cons_printf ( "k<S2SV_blank>bin/pe/%s/%d=%s\\n" , <S2SV_EndBug> module , symbol -> ordinal , symname ) ; } free ( symname ) ; free ( m ) ; } free ( module ) ; } } } else { const char * bind = symbol -> bind ? symbol -> bind : "NONE" ; const char * type = symbol -> type ? symbol -> type : "NONE" ; const char * name = r_str_get ( sn . demname ? sn . demname : r_symbol_name ) ; r_cons_printf ( "%03u" , symbol -> ordinal ) ; if ( symbol -> paddr == UT64_MAX ) { r_cons_printf ( "<S2SV_blank>----------" ) ; } else { r_cons_printf ( "<S2SV_blank>0x%08" PFMT64x , symbol -> paddr ) ; } r_cons_printf ( "<S2SV_blank>0x%08" PFMT64x "<S2SV_blank>%6s<S2SV_blank>%6s<S2SV_blank>%4d%s%s\\n" , addr , bind , type , symbol -> size , * name ? "<S2SV_blank>" : "" , name ) ; } next : snFini ( & sn ) ; i ++ ; free ( r_symbol_name ) ; if ( exponly && firstexp ) { firstexp = false ; } if ( printHere ) { break ; } } if ( count == 0 && IS_MODE_JSON ( mode ) ) { r_cons_printf ( "{}" ) ; } if ( is_arm ) { r_list_foreach ( entries , iter , entry ) { if ( IS_MODE_SET ( mode ) ) { handle_arm_entry ( r , entry , info , va ) ; } } } if ( IS_MODE_JSON ( mode ) && ! printHere ) { r_cons_printf ( "]" ) ; } r_spaces_pop ( & r -> anal -> meta_spaces ) ; return true ; }
CWE-78 static int r_core_cmd_subst_i ( RCore * core , char * cmd , char * colon , bool * tmpseek ) { RList * tmpenvs = r_list_newf ( tmpenvs_free ) ; const char * quotestr = "`" ; const char * tick = NULL ; char * ptr , * ptr2 , * str ; char * arroba = NULL ; char * grep = NULL ; RIODesc * tmpdesc = NULL ; int pamode = ! core -> io -> va ; int i , ret = 0 , pipefd ; bool usemyblock = false ; int scr_html = - 1 ; int scr_color = - 1 ; bool eos = false ; bool haveQuote = false ; bool oldfixedarch = core -> fixedarch ; bool oldfixedbits = core -> fixedbits ; bool cmd_tmpseek = false ; ut64 tmpbsz = core -> blocksize ; int cmd_ignbithints = - 1 ; if ( ! cmd ) { r_list_free ( tmpenvs ) ; return 0 ; } cmd = r_str_trim_head_tail ( cmd ) ; char * $0 = strstr ( cmd , "$(" ) ; if ( $0 ) { char * $1 = strchr ( $0 + 2 , ')' ) ; if ( $1 ) { * $0 = '`' ; * $1 = '`' ; memmove ( $0 + 1 , $0 + 2 , strlen ( $0 + 2 ) + 1 ) ; } else { eprintf ( "Unterminated<S2SV_blank>$()<S2SV_blank>block\\n" ) ; } } switch ( * cmd ) { case '.' : if ( cmd [ 1 ] == \'"\' ) { r_list_free ( tmpenvs ) ; return r_cmd_call ( core -> rcmd , cmd ) ; } break ; case \'"\' : for ( ; * cmd ; ) { int pipefd = - 1 ; ut64 oseek = UT64_MAX ; char * line , * p ; haveQuote = * cmd == \'"\' ; if ( haveQuote ) { cmd ++ ; p = * cmd ? find_eoq ( cmd ) : NULL ; if ( ! p || ! * p ) { eprintf ( "Missing<S2SV_blank>\\"<S2SV_blank>in<S2SV_blank>(%s)." , cmd ) ; r_list_free ( tmpenvs ) ; return false ; } * p ++ = 0 ; if ( ! * p ) { eos = true ; } } else { char * sc = strchr ( cmd , ';' ) ; if ( sc ) { * sc = 0 ; } r_core_cmd0 ( core , cmd ) ; if ( ! sc ) { break ; } cmd = sc + 1 ; continue ; } <S2SV_StartBug> if ( * p ) { <S2SV_EndBug> if ( p [ 0 ] == '@' ) { p -- ; } while ( p [ 1 ] == ';' || IS_WHITESPACE ( p [ 1 ] ) ) { p ++ ; } if ( p [ 1 ] == '@' || ( p [ 1 ] && p [ 2 ] == '@' ) ) { char * q = strchr ( p + 1 , \'"\' ) ; if ( q ) { <S2SV_StartBug> * q = 0 ; <S2SV_EndBug> } haveQuote = q != NULL ; oseek = core -> offset ; r_core_seek ( core , r_num_math ( core -> num , p + 2 ) , 1 ) ; if ( q ) { * p = \'"\' ; p = q ; } else { p = strchr ( p + 1 , ';' ) ; } } if ( p && * p && p [ 1 ] == '>' ) { str = p + 2 ; while ( * str == '>' ) { str ++ ; } str = ( char * ) r_str_trim_ro ( str ) ; r_cons_flush ( ) ; const bool append = p [ 2 ] == '>' ; pipefd = r_cons_pipe_open ( str , 1 , append ) ; } } line = strdup ( cmd ) ; line = r_str_replace ( line , "\\\\\\"" , "\\"" , true ) ; if ( p && * p && p [ 1 ] == '|' ) { str = p + 2 ; while ( IS_WHITESPACE ( * str ) ) { str ++ ; } r_core_cmd_pipe ( core , cmd , str ) ; } else { r_cmd_call ( core -> rcmd , line ) ; } free ( line ) ; if ( oseek != UT64_MAX ) { r_core_seek ( core , oseek , 1 ) ; } if ( pipefd != - 1 ) { r_cons_flush ( ) ; r_cons_pipe_close ( pipefd ) ; } if ( ! p ) { break ; } if ( eos ) { break ; } if ( haveQuote ) { if ( * p == ';' ) { cmd = p + 1 ; } else { if ( * p == \'"\' ) { <S2SV_StartBug> cmd = p + 1 ; <S2SV_EndBug> } else { <S2SV_StartBug> * p = \'"\' ; <S2SV_EndBug> cmd = p ; } } } else { cmd = p + 1 ; } } r_list_free ( tmpenvs ) ; return true ; case '(' : if ( cmd [ 1 ] != '*' && ! strstr ( cmd , ")()" ) ) { r_list_free ( tmpenvs ) ; return r_cmd_call ( core -> rcmd , cmd ) ; } break ; case '?' : if ( cmd [ 1 ] == '>' ) { r_core_cmd_help ( core , help_msg_greater_sign ) ; r_list_free ( tmpenvs ) ; return true ; } } if ( * cmd != '#' ) { ptr = ( char * ) r_str_firstbut ( cmd , '#' , "`\\"" ) ; if ( ptr && ( ptr [ 1 ] == '<S2SV_blank>' || ptr [ 1 ] == '\\t' ) ) { * ptr = '\\0' ; } } if ( * cmd != '#' ) { ptr = ( char * ) r_str_lastbut ( cmd , ';' , quotestr ) ; if ( colon && ptr ) { int ret ; * ptr = '\\0' ; if ( r_core_cmd_subst ( core , cmd ) == - 1 ) { r_list_free ( tmpenvs ) ; return - 1 ; } cmd = ptr + 1 ; ret = r_core_cmd_subst ( core , cmd ) ; * ptr = ';' ; r_list_free ( tmpenvs ) ; return ret ; } } ptr = ( char * ) r_str_lastbut ( cmd , '|' , quotestr ) ; if ( ptr ) { if ( ptr > cmd ) { char * ch = ptr - 1 ; if ( * ch == '\\\\' ) { memmove ( ch , ptr , strlen ( ptr ) + 1 ) ; goto escape_pipe ; } } char * ptr2 = strchr ( cmd , '`' ) ; if ( ! ptr2 || ( ptr2 && ptr2 > ptr ) ) { if ( ! tick || ( tick && tick > ptr ) ) { * ptr = '\\0' ; cmd = r_str_trim_nc ( cmd ) ; if ( ! strcmp ( ptr + 1 , "?" ) ) { r_core_cmd_help ( core , help_msg_vertical_bar ) ; r_list_free ( tmpenvs ) ; return ret ; } else if ( ! strncmp ( ptr + 1 , "H" , 1 ) ) { scr_html = r_config_get_i ( core -> config , "scr.html" ) ; r_config_set_i ( core -> config , "scr.html" , true ) ; } else if ( ! strcmp ( ptr + 1 , "T" ) ) { scr_color = r_config_get_i ( core -> config , "scr.color" ) ; r_config_set_i ( core -> config , "scr.color" , COLOR_MODE_DISABLED ) ; core -> cons -> use_tts = true ; } else if ( ! strcmp ( ptr + 1 , "." ) ) { ret = * cmd ? r_core_cmdf ( core , ".%s" , cmd ) : 0 ; r_list_free ( tmpenvs ) ; return ret ; } else if ( ptr [ 1 ] ) { int value = core -> num -> value ; if ( * cmd ) { r_core_cmd_pipe ( core , cmd , ptr + 1 ) ; } else { char * res = r_io_system ( core -> io , ptr + 1 ) ; if ( res ) { r_cons_printf ( "%s\\n" , res ) ; free ( res ) ; } } core -> num -> value = value ; r_list_free ( tmpenvs ) ; return 0 ; } else { scr_html = r_config_get_i ( core -> config , "scr.html" ) ; r_config_set_i ( core -> config , "scr.html" , 0 ) ; scr_color = r_config_get_i ( core -> config , "scr.color" ) ; r_config_set_i ( core -> config , "scr.color" , COLOR_MODE_DISABLED ) ; } } } } escape_pipe : ptr = ( char * ) r_str_lastbut ( cmd , '&' , quotestr ) ; while ( ptr && * ptr && ptr [ 1 ] == '&' ) { * ptr = '\\0' ; ret = r_cmd_call ( core -> rcmd , cmd ) ; if ( ret == - 1 ) { eprintf ( "command<S2SV_blank>error(%s)\\n" , cmd ) ; if ( scr_html != - 1 ) { r_config_set_i ( core -> config , "scr.html" , scr_html ) ; } if ( scr_color != - 1 ) { r_config_set_i ( core -> config , "scr.color" , scr_color ) ; } r_list_free ( tmpenvs ) ; return ret ; } for ( cmd = ptr + 2 ; cmd && * cmd == '<S2SV_blank>' ; cmd ++ ) { ; } ptr = strchr ( cmd , '&' ) ; } R_FREE ( core -> oobi ) ; ptr = strstr ( cmd , "?*" ) ; if ( ptr && ( ptr == cmd || ptr [ - 1 ] != '~' ) ) { ptr [ 0 ] = 0 ; if ( * cmd != '#' ) { int detail = 0 ; if ( cmd < ptr && ptr [ - 1 ] == '?' ) { detail ++ ; if ( cmd < ptr - 1 && ptr [ - 2 ] == '?' ) { detail ++ ; } } r_cons_break_push ( NULL , NULL ) ; recursive_help ( core , detail , cmd ) ; r_cons_break_pop ( ) ; r_cons_grep_parsecmd ( ptr + 2 , "`" ) ; if ( scr_html != - 1 ) { r_config_set_i ( core -> config , "scr.html" , scr_html ) ; } if ( scr_color != - 1 ) { r_config_set_i ( core -> config , "scr.color" , scr_color ) ; } r_list_free ( tmpenvs ) ; return 0 ; } } # if 0 ptr = strchr ( cmd , '<' ) ; if ( ptr ) { ptr [ 0 ] = '\\0' ; if ( r_cons_singleton ( ) -> is_interactive ) { if ( ptr [ 1 ] == '<' ) { for ( str = ptr + 2 ; str [ 0 ] == '<S2SV_blank>' ; str ++ ) { } eprintf ( "==><S2SV_blank>Reading<S2SV_blank>from<S2SV_blank>stdin<S2SV_blank>until<S2SV_blank>\'%s\'\\n" , str ) ; free ( core -> oobi ) ; core -> oobi = malloc ( 1 ) ; if ( core -> oobi ) { core -> oobi [ 0 ] = '\\0' ; } core -> oobi_len = 0 ; for ( ; ; ) { char buf [ 1024 ] ; int ret ; write ( 1 , "><S2SV_blank>" , 2 ) ; fgets ( buf , sizeof ( buf ) - 1 , stdin ) ; if ( feof ( stdin ) ) { break ; } if ( * buf ) buf [ strlen ( buf ) - 1 ] = '\\0' ; ret = strlen ( buf ) ; core -> oobi_len += ret ; core -> oobi = realloc ( core -> oobi , core -> oobi_len + 1 ) ; if ( core -> oobi ) { if ( ! strcmp ( buf , str ) ) { break ; } strcat ( ( char * ) core -> oobi , buf ) ; } } } else { for ( str = ptr + 1 ; * str == '<S2SV_blank>' ; str ++ ) { } if ( ! * str ) { goto next ; } eprintf ( "Slurping<S2SV_blank>file<S2SV_blank>\'%s\'\\n" , str ) ; free ( core -> oobi ) ; core -> oobi = ( ut8 * ) r_file_slurp ( str , & core -> oobi_len ) ; if ( ! core -> oobi ) { eprintf ( "cannot<S2SV_blank>open<S2SV_blank>file\\n" ) ; } else if ( ptr == cmd ) { return r_core_cmd_buffer ( core , ( const char * ) core -> oobi ) ; } } } else { eprintf ( "Cannot<S2SV_blank>slurp<S2SV_blank>with<S2SV_blank><<<S2SV_blank>in<S2SV_blank>non-interactive<S2SV_blank>mode\\n" ) ; r_list_free ( tmpenvs ) ; return 0 ; } } next : # endif ptr = ( char * ) r_str_firstbut ( cmd , '>' , "\\"" ) ; if ( ptr ) { if ( ptr > cmd ) { char * ch = ptr - 1 ; if ( * ch == '\\\\' ) { memmove ( ch , ptr , strlen ( ptr ) + 1 ) ; goto escape_redir ; } } if ( ptr [ 0 ] && ptr [ 1 ] == '?' ) { r_core_cmd_help ( core , help_msg_greater_sign ) ; r_list_free ( tmpenvs ) ; return true ; } int fdn = 1 ; int pipecolor = r_config_get_i ( core -> config , "scr.color.pipe" ) ; int use_editor = false ; int ocolor = r_config_get_i ( core -> config , "scr.color" ) ; * ptr = '\\0' ; str = r_str_trim_head_tail ( ptr + 1 + ( ptr [ 1 ] == '>' ) ) ; if ( ! * str ) { eprintf ( "No<S2SV_blank>output?\\n" ) ; goto next2 ; } if ( ptr > ( cmd + 1 ) && IS_WHITECHAR ( ptr [ - 2 ] ) ) { char * fdnum = ptr - 1 ; if ( * fdnum == 'H' ) { scr_html = r_config_get_i ( core -> config , "scr.html" ) ; r_config_set_i ( core -> config , "scr.html" , true ) ; pipecolor = true ; * fdnum = 0 ; } else { if ( IS_DIGIT ( * fdnum ) ) { fdn = * fdnum - '0' ; } * fdnum = 0 ; } } r_cons_set_interactive ( false ) ; if ( ! strcmp ( str , "-" ) ) { use_editor = true ; str = r_file_temp ( "dumpedit" ) ; r_config_set_i ( core -> config , "scr.color" , COLOR_MODE_DISABLED ) ; } const bool appendResult = ( ptr [ 1 ] == '>' ) ; if ( * str == '$' ) { char * o = r_core_cmd_str ( core , cmd ) ; if ( appendResult ) { char * oldText = r_cmd_alias_get ( core -> rcmd , str , 1 ) ; if ( oldText ) { char * two = r_str_newf ( "%s%s" , oldText , o ) ; if ( two ) { r_cmd_alias_set ( core -> rcmd , str , two , 1 ) ; free ( two ) ; } } else { char * n = r_str_newf ( "$%s" , o ) ; r_cmd_alias_set ( core -> rcmd , str , n , 1 ) ; free ( n ) ; } } else { char * n = r_str_newf ( "$%s" , o ) ; r_cmd_alias_set ( core -> rcmd , str , n , 1 ) ; free ( n ) ; } ret = 0 ; free ( o ) ; } else if ( fdn > 0 ) { pipefd = r_cons_pipe_open ( str , fdn , appendResult ) ; if ( pipefd != - 1 ) { if ( ! pipecolor ) { r_config_set_i ( core -> config , "scr.color" , COLOR_MODE_DISABLED ) ; } ret = r_core_cmd_subst ( core , cmd ) ; r_cons_flush ( ) ; r_cons_pipe_close ( pipefd ) ; } } r_cons_set_last_interactive ( ) ; if ( ! pipecolor ) { r_config_set_i ( core -> config , "scr.color" , ocolor ) ; } if ( use_editor ) { const char * editor = r_config_get ( core -> config , "cfg.editor" ) ; if ( editor && * editor ) { r_sys_cmdf ( "%s<S2SV_blank>\'%s\'" , editor , str ) ; r_file_rm ( str ) ; } else { eprintf ( "No<S2SV_blank>cfg.editor<S2SV_blank>configured\\n" ) ; } r_config_set_i ( core -> config , "scr.color" , ocolor ) ; free ( str ) ; } if ( scr_html != - 1 ) { r_config_set_i ( core -> config , "scr.html" , scr_html ) ; } if ( scr_color != - 1 ) { r_config_set_i ( core -> config , "scr.color" , scr_color ) ; } core -> cons -> use_tts = false ; r_list_free ( tmpenvs ) ; return ret ; } escape_redir : next2 : ptr = strchr ( cmd , '`' ) ; if ( ptr ) { if ( ptr > cmd ) { char * ch = ptr - 1 ; if ( * ch == '\\\\' ) { memmove ( ch , ptr , strlen ( ptr ) + 1 ) ; goto escape_backtick ; } } bool empty = false ; int oneline = 1 ; if ( ptr [ 1 ] == '`' ) { memmove ( ptr , ptr + 1 , strlen ( ptr ) ) ; oneline = 0 ; empty = true ; } ptr2 = strchr ( ptr + 1 , '`' ) ; if ( empty ) { } else if ( ! ptr2 ) { eprintf ( "parse:<S2SV_blank>Missing<S2SV_blank>backtick<S2SV_blank>in<S2SV_blank>expression.\\n" ) ; goto fail ; } else { int value = core -> num -> value ; * ptr = '\\0' ; * ptr2 = '\\0' ; if ( ptr [ 1 ] == '!' ) { str = r_core_cmd_str_pipe ( core , ptr + 1 ) ; } else { int ocolor = r_config_get_i ( core -> config , "scr.color" ) ; r_config_set_i ( core -> config , "scr.color" , 0 ) ; core -> cmd_in_backticks = true ; str = r_core_cmd_str ( core , ptr + 1 ) ; core -> cmd_in_backticks = false ; r_config_set_i ( core -> config , "scr.color" , ocolor ) ; } if ( ! str ) { goto fail ; } if ( * str == '|' || * str == '*' ) { eprintf ( "r_core_cmd_subst_i:<S2SV_blank>invalid<S2SV_blank>backticked<S2SV_blank>command\\n" ) ; free ( str ) ; goto fail ; } if ( oneline && str ) { for ( i = 0 ; str [ i ] ; i ++ ) { if ( str [ i ] == '\\n' ) { str [ i ] = '<S2SV_blank>' ; } } } str = r_str_append ( str , ptr2 + 1 ) ; cmd = r_str_append ( strdup ( cmd ) , str ) ; core -> num -> value = value ; ret = r_core_cmd_subst ( core , cmd ) ; free ( cmd ) ; if ( scr_html != - 1 ) { r_config_set_i ( core -> config , "scr.html" , scr_html ) ; } free ( str ) ; r_list_free ( tmpenvs ) ; return ret ; } } escape_backtick : if ( * cmd != \'"\' && * cmd ) { const char * s = strstr ( cmd , "~?" ) ; if ( s ) { bool showHelp = false ; if ( cmd == s ) { showHelp = true ; } else { if ( ! strcmp ( s , "~??" ) ) { showHelp = true ; } } if ( showHelp ) { r_cons_grep_help ( ) ; r_list_free ( tmpenvs ) ; return true ; } } } if ( * cmd != '.' ) { grep = r_cons_grep_strip ( cmd , quotestr ) ; } if ( * cmd != \'"\' ) { ptr = strchr ( cmd , '@' ) ; if ( ptr == cmd + 1 && * cmd == '?' ) { ptr = NULL ; } } else { ptr = NULL ; } cmd_tmpseek = core -> tmpseek = ptr ? true : false ; int rc = 0 ; if ( ptr ) { char * f , * ptr2 = strchr ( ptr + 1 , '!' ) ; ut64 addr = core -> offset ; bool addr_is_set = false ; char * tmpbits = NULL ; const char * offstr = NULL ; bool is_bits_set = false ; bool is_arch_set = false ; char * tmpeval = NULL ; char * tmpasm = NULL ; bool flgspc_changed = false ; int tmpfd = - 1 ; int sz , len ; ut8 * buf ; * ptr ++ = '\\0' ; repeat_arroba : arroba = ( ptr [ 0 ] && ptr [ 1 ] && ptr [ 2 ] ) ? strchr ( ptr + 2 , '@' ) : NULL ; if ( arroba ) { * arroba = 0 ; } for ( ; * ptr == '<S2SV_blank>' ; ptr ++ ) { } if ( * ptr && ptr [ 1 ] == ':' ) { } else { ptr -- ; } ptr = r_str_trim_tail ( ptr ) ; if ( ptr [ 1 ] == '?' ) { r_core_cmd_help ( core , help_msg_at ) ; } else if ( ptr [ 1 ] == '%' ) { char * k = strdup ( ptr + 2 ) ; char * v = strchr ( k , '=' ) ; if ( v ) { * v ++ = 0 ; r_sys_setenv ( k , v ) ; r_list_append ( tmpenvs , k ) ; } else { free ( k ) ; } } else if ( ptr [ 1 ] == '.' ) { if ( ptr [ 2 ] == '.' ) { if ( ptr [ 3 ] == '.' ) { ut64 addr = r_num_tail ( core -> num , core -> offset , ptr + 4 ) ; r_core_block_size ( core , R_ABS ( ( st64 ) addr - ( st64 ) core -> offset ) ) ; goto fuji ; } else { addr = r_num_tail ( core -> num , core -> offset , ptr + 3 ) ; r_core_seek ( core , addr , 1 ) ; cmd_tmpseek = core -> tmpseek = true ; goto fuji ; } } else { eprintf ( "TODO:<S2SV_blank>what<S2SV_blank>do<S2SV_blank>you<S2SV_blank>expect<S2SV_blank>for<S2SV_blank>@.<S2SV_blank>import<S2SV_blank>offset<S2SV_blank>from<S2SV_blank>file<S2SV_blank>maybe?\\n" ) ; } } else if ( ptr [ 0 ] && ptr [ 1 ] == ':' && ptr [ 2 ] ) { switch ( ptr [ 0 ] ) { case 'F' : flgspc_changed = r_flag_space_push ( core -> flags , ptr + 2 ) ; break ; case 'B' : { int index = ( int ) r_num_math ( core -> num , ptr + 2 ) ; RAnalBlock * bb = r_anal_bb_from_offset ( core -> anal , core -> offset ) ; if ( bb ) { if ( index < 0 ) { index = bb -> ninstr + index ; } if ( index >= 0 && index < bb -> ninstr ) { ut16 inst_off = r_anal_bb_offset_inst ( bb , index ) ; r_core_seek ( core , bb -> addr + inst_off , 1 ) ; cmd_tmpseek = core -> tmpseek = true ; } else { eprintf ( "The<S2SV_blank>current<S2SV_blank>basic<S2SV_blank>block<S2SV_blank>has<S2SV_blank>%d<S2SV_blank>instructions\\n" , bb -> ninstr ) ; } } else { eprintf ( "Can\'t<S2SV_blank>find<S2SV_blank>a<S2SV_blank>basic<S2SV_blank>block<S2SV_blank>for<S2SV_blank>0x%08" PFMT64x "\\n" , core -> offset ) ; } break ; } break ; case 'f' : f = r_file_slurp ( ptr + 2 , & sz ) ; if ( f ) { { RBuffer * b = r_buf_new_with_bytes ( ( const ut8 * ) f , sz ) ; RIODesc * d = r_io_open_buffer ( core -> io , b , R_PERM_RWX , 0 ) ; if ( d ) { if ( tmpdesc ) { r_io_desc_close ( tmpdesc ) ; } tmpdesc = d ; if ( pamode ) { r_config_set_i ( core -> config , "io.va" , 1 ) ; } r_io_map_new ( core -> io , d -> fd , d -> perm , 0 , core -> offset , r_buf_size ( b ) ) ; } } # if 0 buf = malloc ( sz ) ; if ( buf ) { free ( core -> block ) ; core -> block = buf ; core -> blocksize = sz ; memcpy ( core -> block , f , sz ) ; usemyblock = true ; } else { eprintf ( "cannot<S2SV_blank>alloc<S2SV_blank>%d" , sz ) ; } free ( f ) ; # endif } else { eprintf ( "cannot<S2SV_blank>open<S2SV_blank>\'%s\'\\n" , ptr + 3 ) ; } break ; case 'r' : if ( ptr [ 1 ] == ':' ) { ut64 regval ; char * mander = strdup ( ptr + 2 ) ; char * sep = findSeparator ( mander ) ; if ( sep ) { char ch = * sep ; * sep = 0 ; regval = r_debug_reg_get ( core -> dbg , mander ) ; * sep = ch ; char * numexpr = r_str_newf ( "0x%" PFMT64x "%s" , regval , sep ) ; regval = r_num_math ( core -> num , numexpr ) ; free ( numexpr ) ; } else { regval = r_debug_reg_get ( core -> dbg , ptr + 2 ) ; } r_core_seek ( core , regval , 1 ) ; cmd_tmpseek = core -> tmpseek = true ; free ( mander ) ; } break ; case 'b' : is_bits_set = set_tmp_bits ( core , r_num_math ( core -> num , ptr + 2 ) , & tmpbits ) ; cmd_ignbithints = r_config_get_i ( core -> config , "anal.ignbithints" ) ; r_config_set_i ( core -> config , "anal.ignbithints" , 1 ) ; break ; case 'i' : { ut64 addr = r_num_math ( core -> num , ptr + 2 ) ; if ( addr ) { r_core_cmdf ( core , "so<S2SV_blank>%s" , ptr + 2 ) ; cmd_tmpseek = core -> tmpseek = true ; } } break ; case 'e' : { char * cmd = parse_tmp_evals ( core , ptr + 2 ) ; if ( ! tmpeval ) { tmpeval = cmd ; } else { tmpeval = r_str_prepend ( tmpeval , cmd ) ; free ( cmd ) ; } } break ; case 'x' : if ( ptr [ 1 ] == ':' ) { buf = malloc ( strlen ( ptr + 2 ) + 1 ) ; if ( buf ) { len = r_hex_str2bin ( ptr + 2 , buf ) ; r_core_block_size ( core , R_ABS ( len ) ) ; if ( len > 0 ) { RBuffer * b = r_buf_new_with_bytes ( buf , len ) ; RIODesc * d = r_io_open_buffer ( core -> io , b , R_PERM_RWX , 0 ) ; if ( d ) { if ( tmpdesc ) { r_io_desc_close ( tmpdesc ) ; } tmpdesc = d ; if ( pamode ) { r_config_set_i ( core -> config , "io.va" , 1 ) ; } r_io_map_new ( core -> io , d -> fd , d -> perm , 0 , core -> offset , r_buf_size ( b ) ) ; r_core_block_size ( core , len ) ; r_core_block_read ( core ) ; } } else { eprintf ( "Error:<S2SV_blank>Invalid<S2SV_blank>hexpairs<S2SV_blank>for<S2SV_blank>@x:\\n" ) ; } free ( buf ) ; } else { eprintf ( "cannot<S2SV_blank>allocate\\n" ) ; } } else { eprintf ( "Invalid<S2SV_blank>@x:<S2SV_blank>syntax\\n" ) ; } break ; case 'k' : { char * out = sdb_querys ( core -> sdb , NULL , 0 , ptr + ( ( ptr [ 1 ] ) ? 2 : 1 ) ) ; if ( out ) { r_core_seek ( core , r_num_math ( core -> num , out ) , 1 ) ; free ( out ) ; usemyblock = true ; } } break ; case 'o' : if ( ptr [ 1 ] == ':' ) { tmpfd = core -> io -> desc ? core -> io -> desc -> fd : - 1 ; r_io_use_fd ( core -> io , atoi ( ptr + 2 ) ) ; } break ; case 'a' : if ( ptr [ 1 ] == ':' ) { char * q = strchr ( ptr + 2 , ':' ) ; if ( q ) { * q ++ = 0 ; int bits = r_num_math ( core -> num , q ) ; is_bits_set = set_tmp_bits ( core , bits , & tmpbits ) ; } is_arch_set = set_tmp_arch ( core , ptr + 2 , & tmpasm ) ; } else { eprintf ( "Usage:<S2SV_blank>pd<S2SV_blank>10<S2SV_blank>@a:arm:32\\n" ) ; } break ; case 's' : { len = strlen ( ptr + 2 ) ; r_core_block_size ( core , len ) ; const ut8 * buf = ( const ut8 * ) r_str_trim_ro ( ptr + 2 ) ; if ( len > 0 ) { RBuffer * b = r_buf_new_with_bytes ( buf , len ) ; RIODesc * d = r_io_open_buffer ( core -> io , b , R_PERM_RWX , 0 ) ; if ( ! core -> io -> va ) { r_config_set_i ( core -> config , "io.va" , 1 ) ; } if ( d ) { if ( tmpdesc ) { r_io_desc_close ( tmpdesc ) ; } tmpdesc = d ; if ( pamode ) { r_config_set_i ( core -> config , "io.va" , 1 ) ; } r_io_map_new ( core -> io , d -> fd , d -> perm , 0 , core -> offset , r_buf_size ( b ) ) ; r_core_block_size ( core , len ) ; } } } break ; default : goto ignore ; } * ptr = '@' ; char * trim = ptr - 2 ; while ( trim > cmd ) { if ( ! IS_WHITESPACE ( * trim ) ) { break ; } * trim = 0 ; trim -- ; } goto next_arroba ; } ignore : ptr = r_str_trim_head ( ptr + 1 ) - 1 ; cmd = r_str_trim_nc ( cmd ) ; if ( ptr2 ) { if ( strlen ( ptr + 1 ) == 13 && strlen ( ptr2 + 1 ) == 6 && ! memcmp ( ptr + 1 , "0x" , 2 ) && ! memcmp ( ptr2 + 1 , "0x" , 2 ) ) { } else if ( strlen ( ptr + 1 ) == 9 && strlen ( ptr2 + 1 ) == 4 ) { } else { * ptr2 = '\\0' ; if ( ! ptr2 [ 1 ] ) { goto fail ; } r_core_block_size ( core , r_num_math ( core -> num , ptr2 + 1 ) ) ; } } offstr = r_str_trim_head ( ptr + 1 ) ; addr = r_num_math ( core -> num , offstr ) ; addr_is_set = true ; if ( isalpha ( ( ut8 ) ptr [ 1 ] ) && ! addr ) { if ( ! r_flag_get ( core -> flags , ptr + 1 ) ) { eprintf ( "Invalid<S2SV_blank>address<S2SV_blank>(%s)\\n" , ptr + 1 ) ; goto fail ; } } else { char ch = * offstr ; if ( ch == '-' || ch == '+' ) { addr = core -> offset + addr ; } } if ( addr ) { RIODesc * d = tmpdesc ; if ( d ) { r_io_map_new ( core -> io , d -> fd , d -> perm , 0 , addr , r_io_desc_size ( d ) ) ; } } next_arroba : if ( arroba ) { ptr = arroba + 1 ; * arroba = '@' ; arroba = NULL ; goto repeat_arroba ; } core -> fixedblock = ! ! tmpdesc ; if ( core -> fixedblock ) { r_core_block_read ( core ) ; } if ( ptr [ 1 ] == '@' ) { if ( ptr [ 2 ] == '@' ) { char * rule = ptr + 3 ; while ( * rule && * rule == '<S2SV_blank>' ) { rule ++ ; } ret = r_core_cmd_foreach3 ( core , cmd , rule ) ; } else { ret = r_core_cmd_foreach ( core , cmd , ptr + 2 ) ; } } else { bool tmpseek = false ; const char * fromvars [ ] = { "anal.from" , "diff.from" , "graph.from" , "io.buffer.from" , "lines.from" , "search.from" , "zoom.from" , NULL } ; const char * tovars [ ] = { "anal.to" , "diff.to" , "graph.to" , "io.buffer.to" , "lines.to" , "search.to" , "zoom.to" , NULL } ; ut64 curfrom [ R_ARRAY_SIZE ( fromvars ) - 1 ] , curto [ R_ARRAY_SIZE ( tovars ) - 1 ] ; if ( ptr [ 1 ] == '(' ) { char * range = ptr + 3 ; char * p = strchr ( range , '<S2SV_blank>' ) ; if ( ! p ) { eprintf ( "Usage:<S2SV_blank>/<S2SV_blank>ABCD<S2SV_blank>@..0x1000<S2SV_blank>0x3000\\n" ) ; free ( tmpeval ) ; free ( tmpasm ) ; free ( tmpbits ) ; goto fail ; } * p = '\\x00' ; ut64 from = r_num_math ( core -> num , range ) ; ut64 to = r_num_math ( core -> num , p + 1 ) ; for ( i = 0 ; fromvars [ i ] ; i ++ ) { curfrom [ i ] = r_config_get_i ( core -> config , fromvars [ i ] ) ; } for ( i = 0 ; tovars [ i ] ; i ++ ) { curto [ i ] = r_config_get_i ( core -> config , tovars [ i ] ) ; } for ( i = 0 ; fromvars [ i ] ; i ++ ) { r_config_set_i ( core -> config , fromvars [ i ] , from ) ; } for ( i = 0 ; tovars [ i ] ; i ++ ) { r_config_set_i ( core -> config , tovars [ i ] , to ) ; } tmpseek = true ; } if ( usemyblock ) { if ( addr_is_set ) { core -> offset = addr ; } ret = r_cmd_call ( core -> rcmd , r_str_trim_head ( cmd ) ) ; } else { if ( addr_is_set ) { if ( ptr [ 1 ] ) { r_core_seek ( core , addr , 1 ) ; r_core_block_read ( core ) ; } } ret = r_cmd_call ( core -> rcmd , r_str_trim_head ( cmd ) ) ; } if ( tmpseek ) { for ( i = 0 ; fromvars [ i ] ; i ++ ) { r_config_set_i ( core -> config , fromvars [ i ] , curfrom [ i ] ) ; } for ( i = 0 ; tovars [ i ] ; i ++ ) { r_config_set_i ( core -> config , tovars [ i ] , curto [ i ] ) ; } } } if ( ptr2 ) { * ptr2 = '!' ; r_core_block_size ( core , tmpbsz ) ; } if ( is_arch_set ) { core -> fixedarch = oldfixedarch ; r_config_set ( core -> config , "asm.arch" , tmpasm ) ; R_FREE ( tmpasm ) ; } if ( tmpfd != - 1 ) { r_io_use_fd ( core -> io , tmpfd ) ; } if ( tmpdesc ) { if ( pamode ) { r_config_set_i ( core -> config , "io.va" , 0 ) ; } r_io_desc_close ( tmpdesc ) ; tmpdesc = NULL ; } if ( is_bits_set ) { r_config_set ( core -> config , "asm.bits" , tmpbits ) ; core -> fixedbits = oldfixedbits ; } if ( tmpbsz != core -> blocksize ) { r_core_block_size ( core , tmpbsz ) ; } if ( tmpeval ) { r_core_cmd0 ( core , tmpeval ) ; R_FREE ( tmpeval ) ; } if ( flgspc_changed ) { r_flag_space_pop ( core -> flags ) ; } * ptr = '@' ; rc = ret ; goto beach ; } fuji : rc = cmd ? r_cmd_call ( core -> rcmd , r_str_trim_head ( cmd ) ) : false ; beach : r_cons_grep_process ( grep ) ; if ( scr_html != - 1 ) { r_cons_flush ( ) ; r_config_set_i ( core -> config , "scr.html" , scr_html ) ; } if ( scr_color != - 1 ) { r_config_set_i ( core -> config , "scr.color" , scr_color ) ; } r_list_free ( tmpenvs ) ; if ( tmpdesc ) { r_io_desc_close ( tmpdesc ) ; tmpdesc = NULL ; } core -> fixedarch = oldfixedarch ; core -> fixedbits = oldfixedbits ; if ( tmpseek ) { * tmpseek = cmd_tmpseek ; } if ( cmd_ignbithints != - 1 ) { r_config_set_i ( core -> config , "anal.ignbithints" , cmd_ignbithints ) ; } return rc ; fail : rc = - 1 ; goto beach ; }
CWE-119 RD_BOOL <S2SV_StartBug> ber_parse_header ( STREAM s , int tagval , int * length ) <S2SV_EndBug> { int tag , len ; if ( tagval > 0xff ) { in_uint16_be ( s , tag ) ; } else { in_uint8 ( s , tag ) ; } if ( tag != tagval ) { logger ( Core , Error , "ber_parse_header(),<S2SV_blank>expected<S2SV_blank>tag<S2SV_blank>%d,<S2SV_blank>got<S2SV_blank>%d" , tagval , tag ) ; return False ; } in_uint8 ( s , len ) ; if ( len & 0x80 ) { len &= ~ 0x80 ; * length = 0 ; while ( len -- ) next_be ( s , * length ) ; } else * length = len ; return s_check ( s ) ; }
CWE-119 static int process_plane ( uint8 * in , int width , int height , uint8 * out , int size ) { UNUSED ( size ) ; int indexw ; int indexh ; int code ; int collen ; int replen ; int color ; int x ; int revcode ; uint8 * last_line ; uint8 * this_line ; uint8 * org_in ; uint8 * org_out ; org_in = in ; org_out = out ; last_line = 0 ; indexh = 0 ; while ( indexh < height ) { out = ( org_out + width * height * 4 ) - ( ( indexh + 1 ) * width * 4 ) ; color = 0 ; this_line = out ; indexw = 0 ; if ( last_line == 0 ) { while ( indexw < width ) { code = CVAL ( in ) ; replen = code & 0xf ; collen = ( code >> 4 ) & 0xf ; revcode = ( replen << 4 ) | collen ; if ( ( revcode <= 47 ) && ( revcode >= 16 ) ) { replen = revcode ; collen = 0 ; } <S2SV_StartBug> while ( collen > 0 ) <S2SV_EndBug> { color = CVAL ( in ) ; * out = color ; out += 4 ; indexw ++ ; collen -- ; } <S2SV_StartBug> while ( replen > 0 ) <S2SV_EndBug> { * out = color ; out += 4 ; indexw ++ ; replen -- ; } } } else { while ( indexw < width ) { code = CVAL ( in ) ; replen = code & 0xf ; collen = ( code >> 4 ) & 0xf ; revcode = ( replen << 4 ) | collen ; if ( ( revcode <= 47 ) && ( revcode >= 16 ) ) { replen = revcode ; collen = 0 ; } <S2SV_StartBug> while ( collen > 0 ) <S2SV_EndBug> { x = CVAL ( in ) ; if ( x & 1 ) { x = x >> 1 ; x = x + 1 ; color = - x ; } else { x = x >> 1 ; color = x ; } x = last_line [ indexw * 4 ] + color ; * out = x ; out += 4 ; indexw ++ ; collen -- ; } <S2SV_StartBug> while ( replen > 0 ) <S2SV_EndBug> { x = last_line [ indexw * 4 ] + color ; * out = x ; out += 4 ; indexw ++ ; replen -- ; } } } indexh ++ ; last_line = this_line ; } return ( int ) ( in - org_in ) ; }
CWE-119 static void cliprdr_process ( STREAM s ) { uint16 type , status ; uint32 length , format ; uint8 * data ; <S2SV_StartBug> in_uint16_le ( s , type ) ; <S2SV_EndBug> in_uint16_le ( s , status ) ; in_uint32_le ( s , length ) ; data = s -> p ; logger ( Clipboard , Debug , "cliprdr_process(),<S2SV_blank>type=%d,<S2SV_blank>status=%d,<S2SV_blank>length=%d" , type , status , length ) ; <S2SV_StartBug> if ( status == CLIPRDR_ERROR ) <S2SV_EndBug> { switch ( type ) { case CLIPRDR_FORMAT_ACK : cliprdr_send_native_format_announce ( last_formats , last_formats_length ) ; break ; case CLIPRDR_DATA_RESPONSE : ui_clip_request_failed ( ) ; break ; default : logger ( Clipboard , Warning , "cliprdr_process(),<S2SV_blank>unhandled<S2SV_blank>error<S2SV_blank>(type=%d)" , type ) ; } return ; } switch ( type ) { case CLIPRDR_CONNECT : ui_clip_sync ( ) ; break ; case CLIPRDR_FORMAT_ANNOUNCE : ui_clip_format_announce ( data , length ) ; cliprdr_send_packet ( CLIPRDR_FORMAT_ACK , CLIPRDR_RESPONSE , NULL , 0 ) ; return ; case CLIPRDR_FORMAT_ACK : break ; case CLIPRDR_DATA_REQUEST : in_uint32_le ( s , format ) ; ui_clip_request_data ( format ) ; break ; case CLIPRDR_DATA_RESPONSE : ui_clip_handle_data ( data , length ) ; break ; case 7 : break ; default : logger ( Clipboard , Warning , "cliprdr_process(),<S2SV_blank>unhandled<S2SV_blank>packet<S2SV_blank>type<S2SV_blank>%d" , type ) ; } }
CWE-119 RD_BOOL cssp_read_tsrequest ( STREAM token , STREAM pubkey ) { STREAM s ; int length ; int tagval ; <S2SV_StartBug> s = tcp_recv ( NULL , 4 ) ; <S2SV_EndBug> if ( s == NULL ) return False ; if ( s -> p [ 0 ] != ( BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED ) ) { logger ( Protocol , Error , "cssp_read_tsrequest(),<S2SV_blank>expected<S2SV_blank>BER_TAG_SEQUENCE|BER_TAG_CONSTRUCTED,<S2SV_blank>got<S2SV_blank>%x" , s -> p [ 0 ] ) ; return False ; } if ( s -> p [ 1 ] < 0x80 ) length = s -> p [ 1 ] - 2 ; else if ( s -> p [ 1 ] == 0x81 ) length = s -> p [ 2 ] - 1 ; else if ( s -> p [ 1 ] == 0x82 ) length = ( s -> p [ 2 ] << 8 ) | s -> p [ 3 ] ; else return False ; s = tcp_recv ( s , length ) ; <S2SV_StartBug> if ( ! ber_in_header ( s , & tagval , & length ) || <S2SV_EndBug> tagval != ( BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED ) ) return False ; if ( ! ber_in_header ( s , & tagval , & length ) || tagval != ( BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 0 ) ) return False ; <S2SV_StartBug> in_uint8s ( s , length ) ; <S2SV_EndBug> if ( token ) { if ( ! ber_in_header ( s , & tagval , & length ) || tagval != ( BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 1 ) ) return False ; if ( ! ber_in_header ( s , & tagval , & length ) || tagval != ( BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED ) ) return False ; if ( ! ber_in_header ( s , & tagval , & length ) || tagval != ( BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED ) ) return False ; if ( ! ber_in_header ( s , & tagval , & length ) || tagval != ( BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 0 ) ) return False ; if ( ! ber_in_header ( s , & tagval , & length ) || tagval != BER_TAG_OCTET_STRING ) return False ; <S2SV_StartBug> token -> end = token -> p = token -> data ; <S2SV_EndBug> out_uint8p ( token , s -> p , length ) ; s_mark_end ( token ) ; } if ( pubkey ) { if ( ! ber_in_header ( s , & tagval , & length ) || tagval != ( BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 3 ) ) return False ; if ( ! ber_in_header ( s , & tagval , & length ) || tagval != BER_TAG_OCTET_STRING ) return False ; pubkey -> data = pubkey -> p = s -> p ; pubkey -> end = pubkey -> data + length ; pubkey -> size = length ; } return True ; }
CWE-119 static void lspci_process ( STREAM s ) { unsigned int pkglen ; static char * rest = NULL ; <S2SV_StartBug> char * buf ; <S2SV_EndBug> pkglen = s -> end - s -> p ; buf = xmalloc ( pkglen + 1 ) ; STRNCPY ( buf , ( char * ) s -> p , pkglen + 1 ) ; str_handle_lines ( buf , & rest , lspci_process_line , NULL ) ; xfree ( buf ) ; }
CWE-119 static RD_BOOL mcs_parse_domain_params ( STREAM s ) { <S2SV_StartBug> int length ; <S2SV_EndBug> <S2SV_StartBug> ber_parse_header ( s , MCS_TAG_DOMAIN_PARAMS , & length ) ; <S2SV_EndBug> in_uint8s ( s , length ) ; return s_check ( s ) ; }
CWE-119 static RD_BOOL mcs_recv_connect_response ( STREAM mcs_data ) { UNUSED ( mcs_data ) ; uint8 result ; <S2SV_StartBug> int length ; <S2SV_EndBug> <S2SV_StartBug> STREAM s ; <S2SV_EndBug> RD_BOOL is_fastpath ; uint8 fastpath_hdr ; logger ( Protocol , Debug , "%s()" , __func__ ) ; s = iso_recv ( & is_fastpath , & fastpath_hdr ) ; if ( s == NULL ) return False ; <S2SV_StartBug> ber_parse_header ( s , MCS_CONNECT_RESPONSE , & length ) ; <S2SV_EndBug> ber_parse_header ( s , BER_TAG_RESULT , & length ) ; in_uint8 ( s , result ) ; if ( result != 0 ) { logger ( Protocol , Error , "mcs_recv_connect_response(),<S2SV_blank>result=%d" , result ) ; return False ; } ber_parse_header ( s , BER_TAG_INTEGER , & length ) ; in_uint8s ( s , length ) ; <S2SV_StartBug> mcs_parse_domain_params ( s ) ; <S2SV_EndBug> ber_parse_header ( s , BER_TAG_OCTET_STRING , & length ) ; sec_process_mcs_data ( s ) ; return s_check_end ( s ) ; }
CWE-119 static void process_secondary_order ( STREAM s ) { uint16 length ; uint16 flags ; uint8 type ; uint8 * next_order ; <S2SV_StartBug> in_uint16_le ( s , length ) ; <S2SV_EndBug> in_uint16_le ( s , flags ) ; <S2SV_StartBug> in_uint8 ( s , type ) ; <S2SV_EndBug> next_order = s -> p + ( sint16 ) length + 7 ; switch ( type ) { case RDP_ORDER_RAW_BMPCACHE : process_raw_bmpcache ( s ) ; break ; case RDP_ORDER_COLCACHE : process_colcache ( s ) ; break ; case RDP_ORDER_BMPCACHE : process_bmpcache ( s ) ; break ; case RDP_ORDER_FONTCACHE : process_fontcache ( s ) ; break ; case RDP_ORDER_RAW_BMPCACHE2 : process_bmpcache2 ( s , flags , False ) ; break ; case RDP_ORDER_BMPCACHE2 : process_bmpcache2 ( s , flags , True ) ; break ; case RDP_ORDER_BRUSHCACHE : process_brushcache ( s , flags ) ; break ; default : logger ( Graphics , Warning , "process_secondary_order(),<S2SV_blank>unhandled<S2SV_blank>secondary<S2SV_blank>order<S2SV_blank>%d" , type ) ; } s -> p = next_order ; }
CWE-416 void comps_mrtree_unite ( COMPS_MRTree * rt1 , COMPS_MRTree * rt2 ) { COMPS_HSList * tmplist , * tmp_subnodes ; COMPS_HSListItem * it , * it2 ; struct Pair { COMPS_HSList * subnodes ; char * key ; <S2SV_StartBug> char added ; <S2SV_EndBug> } * pair , * parent_pair ; pair = malloc ( sizeof ( struct Pair ) ) ; pair -> subnodes = rt2 -> subnodes ; pair -> key = NULL ; tmplist = comps_hslist_create ( ) ; comps_hslist_init ( tmplist , NULL , NULL , & free ) ; comps_hslist_append ( tmplist , pair , 0 ) ; while ( tmplist -> first != NULL ) { it = tmplist -> first ; comps_hslist_remove ( tmplist , tmplist -> first ) ; tmp_subnodes = ( ( struct Pair * ) it -> data ) -> subnodes ; parent_pair = ( struct Pair * ) it -> data ; free ( it ) ; <S2SV_StartBug> pair -> added = 0 ; <S2SV_EndBug> for ( it = tmp_subnodes -> first ; it != NULL ; it = it -> next ) { pair = malloc ( sizeof ( struct Pair ) ) ; pair -> subnodes = ( ( COMPS_MRTreeData * ) it -> data ) -> subnodes ; if ( parent_pair -> key != NULL ) { pair -> key = malloc ( sizeof ( char ) * ( strlen ( ( ( COMPS_MRTreeData * ) it -> data ) -> key ) + strlen ( parent_pair -> key ) + 1 ) ) ; memcpy ( pair -> key , parent_pair -> key , sizeof ( char ) * strlen ( parent_pair -> key ) ) ; memcpy ( pair -> key + strlen ( parent_pair -> key ) , ( ( COMPS_MRTreeData * ) it -> data ) -> key , sizeof ( char ) * ( strlen ( ( ( COMPS_MRTreeData * ) it -> data ) -> key ) + 1 ) ) ; } else { pair -> key = malloc ( sizeof ( char ) * ( strlen ( ( ( COMPS_MRTreeData * ) it -> data ) -> key ) + 1 ) ) ; memcpy ( pair -> key , ( ( COMPS_MRTreeData * ) it -> data ) -> key , sizeof ( char ) * ( strlen ( ( ( COMPS_MRTreeData * ) it -> data ) -> key ) + 1 ) ) ; } if ( ( ( COMPS_MRTreeData * ) it -> data ) -> data -> first != NULL ) { for ( it2 = ( ( COMPS_MRTreeData * ) it -> data ) -> data -> first ; it2 != NULL ; it2 = it2 -> next ) { comps_mrtree_set ( rt1 , pair -> key , it2 -> data ) ; } if ( ( ( COMPS_MRTreeData * ) it -> data ) -> subnodes -> first ) { comps_hslist_append ( tmplist , pair , 0 ) ; } else { free ( pair -> key ) ; free ( pair ) ; } } else { if ( ( ( COMPS_MRTreeData * ) it -> data ) -> subnodes -> first ) { comps_hslist_append ( tmplist , pair , 0 ) ; } else { free ( pair -> key ) ; free ( pair ) ; } } } free ( parent_pair -> key ) ; free ( parent_pair ) ; } comps_hslist_destroy ( & tmplist ) ; }
CWE-416 void comps_objmrtree_unite ( COMPS_ObjMRTree * rt1 , COMPS_ObjMRTree * rt2 ) { COMPS_HSList * tmplist , * tmp_subnodes ; COMPS_HSListItem * it ; COMPS_ObjListIt * it2 ; struct Pair { COMPS_HSList * subnodes ; char * key ; <S2SV_StartBug> char added ; <S2SV_EndBug> } * pair , * parent_pair ; pair = malloc ( sizeof ( struct Pair ) ) ; pair -> subnodes = rt2 -> subnodes ; pair -> key = NULL ; tmplist = comps_hslist_create ( ) ; comps_hslist_init ( tmplist , NULL , NULL , & free ) ; comps_hslist_append ( tmplist , pair , 0 ) ; while ( tmplist -> first != NULL ) { it = tmplist -> first ; comps_hslist_remove ( tmplist , tmplist -> first ) ; tmp_subnodes = ( ( struct Pair * ) it -> data ) -> subnodes ; parent_pair = ( struct Pair * ) it -> data ; free ( it ) ; <S2SV_StartBug> pair -> added = 0 ; <S2SV_EndBug> for ( it = tmp_subnodes -> first ; it != NULL ; it = it -> next ) { pair = malloc ( sizeof ( struct Pair ) ) ; pair -> subnodes = ( ( COMPS_ObjMRTreeData * ) it -> data ) -> subnodes ; if ( parent_pair -> key != NULL ) { pair -> key = malloc ( sizeof ( char ) * ( strlen ( ( ( COMPS_ObjMRTreeData * ) it -> data ) -> key ) + strlen ( parent_pair -> key ) + 1 ) ) ; memcpy ( pair -> key , parent_pair -> key , sizeof ( char ) * strlen ( parent_pair -> key ) ) ; memcpy ( pair -> key + strlen ( parent_pair -> key ) , ( ( COMPS_ObjMRTreeData * ) it -> data ) -> key , sizeof ( char ) * ( strlen ( ( ( COMPS_ObjMRTreeData * ) it -> data ) -> key ) + 1 ) ) ; } else { pair -> key = malloc ( sizeof ( char ) * ( strlen ( ( ( COMPS_ObjMRTreeData * ) it -> data ) -> key ) + 1 ) ) ; memcpy ( pair -> key , ( ( COMPS_ObjMRTreeData * ) it -> data ) -> key , sizeof ( char ) * ( strlen ( ( ( COMPS_ObjMRTreeData * ) it -> data ) -> key ) + 1 ) ) ; } if ( ( ( COMPS_ObjMRTreeData * ) it -> data ) -> data -> first != NULL ) { for ( it2 = ( ( COMPS_ObjMRTreeData * ) it -> data ) -> data -> first ; it2 != NULL ; it2 = it2 -> next ) { comps_objmrtree_set ( rt1 , pair -> key , it2 -> comps_obj ) ; } if ( ( ( COMPS_ObjMRTreeData * ) it -> data ) -> subnodes -> first ) { comps_hslist_append ( tmplist , pair , 0 ) ; } else { free ( pair -> key ) ; free ( pair ) ; } } else { if ( ( ( COMPS_ObjMRTreeData * ) it -> data ) -> subnodes -> first ) { comps_hslist_append ( tmplist , pair , 0 ) ; } else { free ( pair -> key ) ; free ( pair ) ; } } } free ( parent_pair -> key ) ; free ( parent_pair ) ; } comps_hslist_destroy ( & tmplist ) ; }
CWE-416 void comps_objrtree_unite ( COMPS_ObjRTree * rt1 , COMPS_ObjRTree * rt2 ) { COMPS_HSList * tmplist , * tmp_subnodes ; COMPS_HSListItem * it ; struct Pair { COMPS_HSList * subnodes ; char * key ; <S2SV_StartBug> char added ; <S2SV_EndBug> } * pair , * parent_pair ; pair = malloc ( sizeof ( struct Pair ) ) ; pair -> subnodes = rt2 -> subnodes ; pair -> key = NULL ; tmplist = comps_hslist_create ( ) ; comps_hslist_init ( tmplist , NULL , NULL , & free ) ; comps_hslist_append ( tmplist , pair , 0 ) ; while ( tmplist -> first != NULL ) { it = tmplist -> first ; comps_hslist_remove ( tmplist , tmplist -> first ) ; tmp_subnodes = ( ( struct Pair * ) it -> data ) -> subnodes ; parent_pair = ( struct Pair * ) it -> data ; free ( it ) ; for ( it = tmp_subnodes -> first ; it != NULL ; it = it -> next ) { pair = malloc ( sizeof ( struct Pair ) ) ; pair -> subnodes = ( ( COMPS_ObjRTreeData * ) it -> data ) -> subnodes ; if ( parent_pair -> key != NULL ) { pair -> key = malloc ( sizeof ( char ) * ( strlen ( ( ( COMPS_ObjRTreeData * ) it -> data ) -> key ) + strlen ( parent_pair -> key ) + 1 ) ) ; memcpy ( pair -> key , parent_pair -> key , sizeof ( char ) * strlen ( parent_pair -> key ) ) ; memcpy ( pair -> key + strlen ( parent_pair -> key ) , ( ( COMPS_ObjRTreeData * ) it -> data ) -> key , sizeof ( char ) * ( strlen ( ( ( COMPS_ObjRTreeData * ) it -> data ) -> key ) + 1 ) ) ; } else { pair -> key = malloc ( sizeof ( char ) * ( strlen ( ( ( COMPS_ObjRTreeData * ) it -> data ) -> key ) + 1 ) ) ; memcpy ( pair -> key , ( ( COMPS_ObjRTreeData * ) it -> data ) -> key , sizeof ( char ) * ( strlen ( ( ( COMPS_ObjRTreeData * ) it -> data ) -> key ) + 1 ) ) ; } if ( ( ( COMPS_ObjRTreeData * ) it -> data ) -> data != NULL ) { comps_objrtree_set ( rt1 , pair -> key , ( ( ( COMPS_ObjRTreeData * ) it -> data ) -> data ) ) ; } if ( ( ( COMPS_ObjRTreeData * ) it -> data ) -> subnodes -> first ) { comps_hslist_append ( tmplist , pair , 0 ) ; } else { free ( pair -> key ) ; free ( pair ) ; } } free ( parent_pair -> key ) ; free ( parent_pair ) ; } comps_hslist_destroy ( & tmplist ) ; }
CWE-416 void comps_rtree_unite ( COMPS_RTree * rt1 , COMPS_RTree * rt2 ) { COMPS_HSList * tmplist , * tmp_subnodes ; COMPS_HSListItem * it ; struct Pair { COMPS_HSList * subnodes ; char * key ; <S2SV_StartBug> char added ; <S2SV_EndBug> } * pair , * parent_pair ; pair = malloc ( sizeof ( struct Pair ) ) ; pair -> subnodes = rt2 -> subnodes ; pair -> key = NULL ; tmplist = comps_hslist_create ( ) ; comps_hslist_init ( tmplist , NULL , NULL , & free ) ; comps_hslist_append ( tmplist , pair , 0 ) ; while ( tmplist -> first != NULL ) { it = tmplist -> first ; comps_hslist_remove ( tmplist , tmplist -> first ) ; tmp_subnodes = ( ( struct Pair * ) it -> data ) -> subnodes ; parent_pair = ( struct Pair * ) it -> data ; free ( it ) ; for ( it = tmp_subnodes -> first ; it != NULL ; it = it -> next ) { pair = malloc ( sizeof ( struct Pair ) ) ; pair -> subnodes = ( ( COMPS_RTreeData * ) it -> data ) -> subnodes ; if ( parent_pair -> key != NULL ) { pair -> key = malloc ( sizeof ( char ) * ( strlen ( ( ( COMPS_RTreeData * ) it -> data ) -> key ) + strlen ( parent_pair -> key ) + 1 ) ) ; memcpy ( pair -> key , parent_pair -> key , sizeof ( char ) * strlen ( parent_pair -> key ) ) ; memcpy ( pair -> key + strlen ( parent_pair -> key ) , ( ( COMPS_RTreeData * ) it -> data ) -> key , sizeof ( char ) * ( strlen ( ( ( COMPS_RTreeData * ) it -> data ) -> key ) + 1 ) ) ; } else { pair -> key = malloc ( sizeof ( char ) * ( strlen ( ( ( COMPS_RTreeData * ) it -> data ) -> key ) + 1 ) ) ; memcpy ( pair -> key , ( ( COMPS_RTreeData * ) it -> data ) -> key , sizeof ( char ) * ( strlen ( ( ( COMPS_RTreeData * ) it -> data ) -> key ) + 1 ) ) ; } if ( ( ( COMPS_RTreeData * ) it -> data ) -> data != NULL ) { comps_rtree_set ( rt1 , pair -> key , rt2 -> data_cloner ( ( ( COMPS_RTreeData * ) it -> data ) -> data ) ) ; } if ( ( ( COMPS_RTreeData * ) it -> data ) -> subnodes -> first ) { comps_hslist_append ( tmplist , pair , 0 ) ; } else { free ( pair -> key ) ; free ( pair ) ; } } free ( parent_pair -> key ) ; free ( parent_pair ) ; } comps_hslist_destroy ( & tmplist ) ; }
CWE-190 uint8_t hfs_cat_traverse ( HFS_INFO * hfs , TSK_HFS_BTREE_CB a_cb , void * ptr ) { TSK_FS_INFO * fs = & ( hfs -> fs_info ) ; uint32_t cur_node ; char * node ; uint16_t nodesize ; uint8_t is_done = 0 ; tsk_error_reset ( ) ; nodesize = tsk_getu16 ( fs -> endian , hfs -> catalog_header . nodesize ) ; if ( ( node = ( char * ) tsk_malloc ( nodesize ) ) == NULL ) return 1 ; cur_node = tsk_getu32 ( fs -> endian , hfs -> catalog_header . rootNode ) ; if ( cur_node == 0 ) { if ( tsk_verbose ) tsk_fprintf ( stderr , "hfs_cat_traverse:<S2SV_blank>" "empty<S2SV_blank>extents<S2SV_blank>btree\\n" ) ; free ( node ) ; return 1 ; } if ( tsk_verbose ) tsk_fprintf ( stderr , "hfs_cat_traverse:<S2SV_blank>starting<S2SV_blank>at<S2SV_blank>" "root<S2SV_blank>node<S2SV_blank>%" PRIu32 ";<S2SV_blank>nodesize<S2SV_blank>=<S2SV_blank>%" PRIu16 "\\n" , cur_node , nodesize ) ; is_done = 0 ; while ( is_done == 0 ) { TSK_OFF_T cur_off ; uint16_t num_rec ; ssize_t cnt ; hfs_btree_node * node_desc ; if ( cur_node > tsk_getu32 ( fs -> endian , hfs -> catalog_header . totalNodes ) ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( "hfs_cat_traverse:<S2SV_blank>Node<S2SV_blank>%d<S2SV_blank>too<S2SV_blank>large<S2SV_blank>for<S2SV_blank>file" , cur_node ) ; free ( node ) ; return 1 ; } cur_off = cur_node * nodesize ; cnt = tsk_fs_attr_read ( hfs -> catalog_attr , cur_off , node , nodesize , 0 ) ; if ( cnt != nodesize ) { if ( cnt >= 0 ) { tsk_error_reset ( ) ; tsk_error_set_errno ( TSK_ERR_FS_READ ) ; } tsk_error_set_errstr2 ( "hfs_cat_traverse:<S2SV_blank>Error<S2SV_blank>reading<S2SV_blank>node<S2SV_blank>%d<S2SV_blank>at<S2SV_blank>offset<S2SV_blank>%" PRIuOFF , cur_node , cur_off ) ; free ( node ) ; return 1 ; } if ( nodesize < sizeof ( hfs_btree_node ) ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( "hfs_cat_traverse:<S2SV_blank>Node<S2SV_blank>size<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small<S2SV_blank>to<S2SV_blank>be<S2SV_blank>valid" , nodesize ) ; free ( node ) ; return 1 ; } node_desc = ( hfs_btree_node * ) node ; num_rec = tsk_getu16 ( fs -> endian , node_desc -> num_rec ) ; if ( tsk_verbose ) tsk_fprintf ( stderr , "hfs_cat_traverse:<S2SV_blank>node<S2SV_blank>%" PRIu32 "<S2SV_blank>@<S2SV_blank>%" PRIu64 "<S2SV_blank>has<S2SV_blank>%" PRIu16 "<S2SV_blank>records\\n" , cur_node , cur_off , num_rec ) ; if ( num_rec == 0 ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( "hfs_cat_traverse:<S2SV_blank>zero<S2SV_blank>records<S2SV_blank>in<S2SV_blank>node<S2SV_blank>%" PRIu32 , cur_node ) ; free ( node ) ; return 1 ; } if ( node_desc -> type == HFS_BT_NODE_TYPE_IDX ) { uint32_t next_node = 0 ; int rec ; for ( rec = 0 ; rec < num_rec ; ++ rec ) { size_t rec_off ; hfs_btree_key_cat * key ; uint8_t retval ; <S2SV_StartBug> uint16_t keylen ; <S2SV_EndBug> rec_off = tsk_getu16 ( fs -> endian , & node [ nodesize - ( rec + 1 ) * 2 ] ) ; if ( rec_off > nodesize ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( "hfs_cat_traverse:<S2SV_blank>offset<S2SV_blank>of<S2SV_blank>record<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>index<S2SV_blank>node<S2SV_blank>%d<S2SV_blank>too<S2SV_blank>large<S2SV_blank>(%d<S2SV_blank>vs<S2SV_blank>%" PRIu16 ")" , rec , cur_node , ( int ) rec_off , nodesize ) ; free ( node ) ; return 1 ; } key = ( hfs_btree_key_cat * ) & node [ rec_off ] ; keylen = 2 + tsk_getu16 ( hfs -> fs_info . endian , key -> key_len ) ; if ( ( keylen ) > nodesize ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( "hfs_cat_traverse:<S2SV_blank>length<S2SV_blank>of<S2SV_blank>key<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>index<S2SV_blank>node<S2SV_blank>%d<S2SV_blank>too<S2SV_blank>large<S2SV_blank>(%d<S2SV_blank>vs<S2SV_blank>%" PRIu16 ")" , rec , cur_node , keylen , nodesize ) ; free ( node ) ; return 1 ; } retval = a_cb ( hfs , HFS_BT_NODE_TYPE_IDX , key , cur_off + rec_off , ptr ) ; if ( retval == HFS_BTREE_CB_ERR ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr2 ( "hfs_cat_traverse:<S2SV_blank>Callback<S2SV_blank>returned<S2SV_blank>error" ) ; free ( node ) ; return 1 ; } else if ( ( retval == HFS_BTREE_CB_IDX_LT ) || ( next_node == 0 ) ) { hfs_btree_index_record * idx_rec ; int keylen = 2 + hfs_get_idxkeylen ( hfs , tsk_getu16 ( fs -> endian , key -> key_len ) , & ( hfs -> catalog_header ) ) ; if ( rec_off + keylen > nodesize ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( "hfs_cat_traverse:<S2SV_blank>offset<S2SV_blank>of<S2SV_blank>record<S2SV_blank>and<S2SV_blank>keylength<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>index<S2SV_blank>node<S2SV_blank>%d<S2SV_blank>too<S2SV_blank>large<S2SV_blank>(%d<S2SV_blank>vs<S2SV_blank>%" PRIu16 ")" , rec , cur_node , ( int ) rec_off + keylen , nodesize ) ; free ( node ) ; return 1 ; } idx_rec = ( hfs_btree_index_record * ) & node [ rec_off + keylen ] ; next_node = tsk_getu32 ( fs -> endian , idx_rec -> childNode ) ; } if ( retval == HFS_BTREE_CB_IDX_EQGT ) { break ; } } if ( next_node == 0 ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( "hfs_cat_traverse:<S2SV_blank>did<S2SV_blank>not<S2SV_blank>find<S2SV_blank>any<S2SV_blank>keys<S2SV_blank>in<S2SV_blank>index<S2SV_blank>node<S2SV_blank>%d" , cur_node ) ; is_done = 1 ; break ; } if ( next_node == cur_node ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( "hfs_cat_traverse:<S2SV_blank>node<S2SV_blank>%d<S2SV_blank>references<S2SV_blank>itself<S2SV_blank>as<S2SV_blank>next<S2SV_blank>node" , cur_node ) ; is_done = 1 ; break ; } cur_node = next_node ; } else if ( node_desc -> type == HFS_BT_NODE_TYPE_LEAF ) { int rec ; for ( rec = 0 ; rec < num_rec ; ++ rec ) { size_t rec_off ; hfs_btree_key_cat * key ; uint8_t retval ; <S2SV_StartBug> uint16_t keylen ; <S2SV_EndBug> rec_off = tsk_getu16 ( fs -> endian , & node [ nodesize - ( rec + 1 ) * 2 ] ) ; if ( rec_off > nodesize ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( "hfs_cat_traverse:<S2SV_blank>offset<S2SV_blank>of<S2SV_blank>record<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>leaf<S2SV_blank>node<S2SV_blank>%d<S2SV_blank>too<S2SV_blank>large<S2SV_blank>(%d<S2SV_blank>vs<S2SV_blank>%" PRIu16 ")" , rec , cur_node , ( int ) rec_off , nodesize ) ; free ( node ) ; return 1 ; } key = ( hfs_btree_key_cat * ) & node [ rec_off ] ; keylen = 2 + tsk_getu16 ( hfs -> fs_info . endian , key -> key_len ) ; if ( ( keylen ) > nodesize ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( "hfs_cat_traverse:<S2SV_blank>length<S2SV_blank>of<S2SV_blank>key<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>leaf<S2SV_blank>node<S2SV_blank>%d<S2SV_blank>too<S2SV_blank>large<S2SV_blank>(%d<S2SV_blank>vs<S2SV_blank>%" PRIu16 ")" , rec , cur_node , keylen , nodesize ) ; free ( node ) ; return 1 ; } retval = a_cb ( hfs , HFS_BT_NODE_TYPE_LEAF , key , cur_off + rec_off , ptr ) ; if ( retval == HFS_BTREE_CB_LEAF_STOP ) { is_done = 1 ; break ; } else if ( retval == HFS_BTREE_CB_ERR ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr2 ( "hfs_cat_traverse:<S2SV_blank>Callback<S2SV_blank>returned<S2SV_blank>error" ) ; free ( node ) ; return 1 ; } } if ( is_done == 0 ) { cur_node = tsk_getu32 ( fs -> endian , node_desc -> flink ) ; if ( cur_node == 0 ) { is_done = 1 ; } if ( tsk_verbose ) tsk_fprintf ( stderr , "hfs_cat_traverse:<S2SV_blank>moving<S2SV_blank>forward<S2SV_blank>to<S2SV_blank>next<S2SV_blank>leaf" ) ; } } else { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( "hfs_cat_traverse:<S2SV_blank>btree<S2SV_blank>node<S2SV_blank>%" PRIu32 "<S2SV_blank>(%" PRIu64 ")<S2SV_blank>is<S2SV_blank>neither<S2SV_blank>index<S2SV_blank>nor<S2SV_blank>leaf<S2SV_blank>(%" PRIu8 ")" , cur_node , cur_off , node_desc -> type ) ; free ( node ) ; return 1 ; } } free ( node ) ; return 0 ; }
CWE-125 int modbus_reply ( modbus_t * ctx , const uint8_t * req , int req_length , modbus_mapping_t * mb_mapping ) { int offset ; int slave ; int function ; uint16_t address ; uint8_t rsp [ MAX_MESSAGE_LENGTH ] ; int rsp_length = 0 ; sft_t sft ; if ( ctx == NULL ) { errno = EINVAL ; return - 1 ; } offset = ctx -> backend -> header_length ; slave = req [ offset - 1 ] ; function = req [ offset ] ; address = ( req [ offset + 1 ] << 8 ) + req [ offset + 2 ] ; sft . slave = slave ; sft . function = function ; sft . t_id = ctx -> backend -> prepare_response_tid ( req , & req_length ) ; switch ( function ) { case MODBUS_FC_READ_COILS : case MODBUS_FC_READ_DISCRETE_INPUTS : { unsigned int is_input = ( function == MODBUS_FC_READ_DISCRETE_INPUTS ) ; int start_bits = is_input ? mb_mapping -> start_input_bits : mb_mapping -> start_bits ; int nb_bits = is_input ? mb_mapping -> nb_input_bits : mb_mapping -> nb_bits ; uint8_t * tab_bits = is_input ? mb_mapping -> tab_input_bits : mb_mapping -> tab_bits ; const char * const name = is_input ? "read_input_bits" : "read_bits" ; int nb = ( req [ offset + 3 ] << 8 ) + req [ offset + 4 ] ; int mapping_address = address - start_bits ; if ( nb < 1 || MODBUS_MAX_READ_BITS < nb ) { rsp_length = response_exception ( ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE , rsp , TRUE , "Illegal<S2SV_blank>nb<S2SV_blank>of<S2SV_blank>values<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>%s<S2SV_blank>(max<S2SV_blank>%d)\\n" , nb , name , MODBUS_MAX_READ_BITS ) ; } else if ( mapping_address < 0 || ( mapping_address + nb ) > nb_bits ) { rsp_length = response_exception ( ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS , rsp , FALSE , "Illegal<S2SV_blank>data<S2SV_blank>address<S2SV_blank>0x%0X<S2SV_blank>in<S2SV_blank>%s\\n" , mapping_address < 0 ? address : address + nb , name ) ; } else { rsp_length = ctx -> backend -> build_response_basis ( & sft , rsp ) ; rsp [ rsp_length ++ ] = ( nb / 8 ) + ( ( nb % 8 ) ? 1 : 0 ) ; rsp_length = response_io_status ( tab_bits , mapping_address , nb , rsp , rsp_length ) ; } } break ; case MODBUS_FC_READ_HOLDING_REGISTERS : case MODBUS_FC_READ_INPUT_REGISTERS : { unsigned int is_input = ( function == MODBUS_FC_READ_INPUT_REGISTERS ) ; int start_registers = is_input ? mb_mapping -> start_input_registers : mb_mapping -> start_registers ; int nb_registers = is_input ? mb_mapping -> nb_input_registers : mb_mapping -> nb_registers ; uint16_t * tab_registers = is_input ? mb_mapping -> tab_input_registers : mb_mapping -> tab_registers ; const char * const name = is_input ? "read_input_registers" : "read_registers" ; int nb = ( req [ offset + 3 ] << 8 ) + req [ offset + 4 ] ; int mapping_address = address - start_registers ; if ( nb < 1 || MODBUS_MAX_READ_REGISTERS < nb ) { rsp_length = response_exception ( ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE , rsp , TRUE , "Illegal<S2SV_blank>nb<S2SV_blank>of<S2SV_blank>values<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>%s<S2SV_blank>(max<S2SV_blank>%d)\\n" , nb , name , MODBUS_MAX_READ_REGISTERS ) ; } else if ( mapping_address < 0 || ( mapping_address + nb ) > nb_registers ) { rsp_length = response_exception ( ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS , rsp , FALSE , "Illegal<S2SV_blank>data<S2SV_blank>address<S2SV_blank>0x%0X<S2SV_blank>in<S2SV_blank>%s\\n" , mapping_address < 0 ? address : address + nb , name ) ; } else { int i ; rsp_length = ctx -> backend -> build_response_basis ( & sft , rsp ) ; rsp [ rsp_length ++ ] = nb << 1 ; for ( i = mapping_address ; i < mapping_address + nb ; i ++ ) { rsp [ rsp_length ++ ] = tab_registers [ i ] >> 8 ; rsp [ rsp_length ++ ] = tab_registers [ i ] & 0xFF ; } } } break ; case MODBUS_FC_WRITE_SINGLE_COIL : { int mapping_address = address - mb_mapping -> start_bits ; if ( mapping_address < 0 || mapping_address >= mb_mapping -> nb_bits ) { rsp_length = response_exception ( ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS , rsp , FALSE , "Illegal<S2SV_blank>data<S2SV_blank>address<S2SV_blank>0x%0X<S2SV_blank>in<S2SV_blank>write_bit\\n" , address ) ; } else { int data = ( req [ offset + 3 ] << 8 ) + req [ offset + 4 ] ; if ( data == 0xFF00 || data == 0x0 ) { mb_mapping -> tab_bits [ mapping_address ] = data ? ON : OFF ; memcpy ( rsp , req , req_length ) ; rsp_length = req_length ; } else { rsp_length = response_exception ( ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE , rsp , FALSE , "Illegal<S2SV_blank>data<S2SV_blank>value<S2SV_blank>0x%0X<S2SV_blank>in<S2SV_blank>write_bit<S2SV_blank>request<S2SV_blank>at<S2SV_blank>address<S2SV_blank>%0X\\n" , data , address ) ; } } } break ; case MODBUS_FC_WRITE_SINGLE_REGISTER : { int mapping_address = address - mb_mapping -> start_registers ; if ( mapping_address < 0 || mapping_address >= mb_mapping -> nb_registers ) { rsp_length = response_exception ( ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS , rsp , FALSE , "Illegal<S2SV_blank>data<S2SV_blank>address<S2SV_blank>0x%0X<S2SV_blank>in<S2SV_blank>write_register\\n" , address ) ; } else { int data = ( req [ offset + 3 ] << 8 ) + req [ offset + 4 ] ; mb_mapping -> tab_registers [ mapping_address ] = data ; memcpy ( rsp , req , req_length ) ; rsp_length = req_length ; } } break ; case MODBUS_FC_WRITE_MULTIPLE_COILS : { int nb = ( req [ offset + 3 ] << 8 ) + req [ offset + 4 ] ; <S2SV_StartBug> int mapping_address = address - mb_mapping -> start_bits ; <S2SV_EndBug> <S2SV_StartBug> if ( nb < 1 || MODBUS_MAX_WRITE_BITS < nb ) { <S2SV_EndBug> rsp_length = response_exception ( ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE , rsp , TRUE , "Illegal<S2SV_blank>number<S2SV_blank>of<S2SV_blank>values<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>write_bits<S2SV_blank>(max<S2SV_blank>%d)\\n" , nb , MODBUS_MAX_WRITE_BITS ) ; } else if ( mapping_address < 0 || ( mapping_address + nb ) > mb_mapping -> nb_bits ) { rsp_length = response_exception ( ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS , rsp , FALSE , "Illegal<S2SV_blank>data<S2SV_blank>address<S2SV_blank>0x%0X<S2SV_blank>in<S2SV_blank>write_bits\\n" , mapping_address < 0 ? address : address + nb ) ; } else { modbus_set_bits_from_bytes ( mb_mapping -> tab_bits , mapping_address , nb , & req [ offset + 6 ] ) ; rsp_length = ctx -> backend -> build_response_basis ( & sft , rsp ) ; memcpy ( rsp + rsp_length , req + rsp_length , 4 ) ; rsp_length += 4 ; } } break ; case MODBUS_FC_WRITE_MULTIPLE_REGISTERS : { <S2SV_StartBug> int nb = ( req [ offset + 3 ] << 8 ) + req [ offset + 4 ] ; <S2SV_EndBug> int mapping_address = address - mb_mapping -> start_registers ; <S2SV_StartBug> if ( nb < 1 || MODBUS_MAX_WRITE_REGISTERS < nb ) { <S2SV_EndBug> rsp_length = response_exception ( ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE , rsp , TRUE , "Illegal<S2SV_blank>number<S2SV_blank>of<S2SV_blank>values<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>write_registers<S2SV_blank>(max<S2SV_blank>%d)\\n" , nb , MODBUS_MAX_WRITE_REGISTERS ) ; } else if ( mapping_address < 0 || ( mapping_address + nb ) > mb_mapping -> nb_registers ) { rsp_length = response_exception ( ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS , rsp , FALSE , "Illegal<S2SV_blank>data<S2SV_blank>address<S2SV_blank>0x%0X<S2SV_blank>in<S2SV_blank>write_registers\\n" , mapping_address < 0 ? address : address + nb ) ; } else { int i , j ; for ( i = mapping_address , j = 6 ; i < mapping_address + nb ; i ++ , j += 2 ) { mb_mapping -> tab_registers [ i ] = ( req [ offset + j ] << 8 ) + req [ offset + j + 1 ] ; } rsp_length = ctx -> backend -> build_response_basis ( & sft , rsp ) ; memcpy ( rsp + rsp_length , req + rsp_length , 4 ) ; rsp_length += 4 ; } } break ; case MODBUS_FC_REPORT_SLAVE_ID : { int str_len ; int byte_count_pos ; rsp_length = ctx -> backend -> build_response_basis ( & sft , rsp ) ; byte_count_pos = rsp_length ++ ; rsp [ rsp_length ++ ] = _REPORT_SLAVE_ID ; rsp [ rsp_length ++ ] = 0xFF ; str_len = 3 + strlen ( LIBMODBUS_VERSION_STRING ) ; memcpy ( rsp + rsp_length , "LMB" LIBMODBUS_VERSION_STRING , str_len ) ; rsp_length += str_len ; rsp [ byte_count_pos ] = rsp_length - byte_count_pos - 1 ; } break ; case MODBUS_FC_READ_EXCEPTION_STATUS : if ( ctx -> debug ) { fprintf ( stderr , "FIXME<S2SV_blank>Not<S2SV_blank>implemented\\n" ) ; } errno = ENOPROTOOPT ; return - 1 ; break ; case MODBUS_FC_MASK_WRITE_REGISTER : { int mapping_address = address - mb_mapping -> start_registers ; if ( mapping_address < 0 || mapping_address >= mb_mapping -> nb_registers ) { rsp_length = response_exception ( ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS , rsp , FALSE , "Illegal<S2SV_blank>data<S2SV_blank>address<S2SV_blank>0x%0X<S2SV_blank>in<S2SV_blank>write_register\\n" , address ) ; } else { uint16_t data = mb_mapping -> tab_registers [ mapping_address ] ; uint16_t and = ( req [ offset + 3 ] << 8 ) + req [ offset + 4 ] ; uint16_t or = ( req [ offset + 5 ] << 8 ) + req [ offset + 6 ] ; data = ( data & and ) | ( or & ( ~ and ) ) ; mb_mapping -> tab_registers [ mapping_address ] = data ; memcpy ( rsp , req , req_length ) ; rsp_length = req_length ; } } break ; case MODBUS_FC_WRITE_AND_READ_REGISTERS : { int nb = ( req [ offset + 3 ] << 8 ) + req [ offset + 4 ] ; uint16_t address_write = ( req [ offset + 5 ] << 8 ) + req [ offset + 6 ] ; int nb_write = ( req [ offset + 7 ] << 8 ) + req [ offset + 8 ] ; int nb_write_bytes = req [ offset + 9 ] ; int mapping_address = address - mb_mapping -> start_registers ; int mapping_address_write = address_write - mb_mapping -> start_registers ; if ( nb_write < 1 || MODBUS_MAX_WR_WRITE_REGISTERS < nb_write || nb < 1 || MODBUS_MAX_WR_READ_REGISTERS < nb || nb_write_bytes != nb_write * 2 ) { rsp_length = response_exception ( ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE , rsp , TRUE , "Illegal<S2SV_blank>nb<S2SV_blank>of<S2SV_blank>values<S2SV_blank>(W%d,<S2SV_blank>R%d)<S2SV_blank>in<S2SV_blank>write_and_read_registers<S2SV_blank>(max<S2SV_blank>W%d,<S2SV_blank>R%d)\\n" , nb_write , nb , MODBUS_MAX_WR_WRITE_REGISTERS , MODBUS_MAX_WR_READ_REGISTERS ) ; } else if ( mapping_address < 0 || ( mapping_address + nb ) > mb_mapping -> nb_registers || mapping_address < 0 || ( mapping_address_write + nb_write ) > mb_mapping -> nb_registers ) { rsp_length = response_exception ( ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS , rsp , FALSE , "Illegal<S2SV_blank>data<S2SV_blank>read<S2SV_blank>address<S2SV_blank>0x%0X<S2SV_blank>or<S2SV_blank>write<S2SV_blank>address<S2SV_blank>0x%0X<S2SV_blank>write_and_read_registers\\n" , mapping_address < 0 ? address : address + nb , mapping_address_write < 0 ? address_write : address_write + nb_write ) ; } else { int i , j ; rsp_length = ctx -> backend -> build_response_basis ( & sft , rsp ) ; rsp [ rsp_length ++ ] = nb << 1 ; for ( i = mapping_address_write , j = 10 ; i < mapping_address_write + nb_write ; i ++ , j += 2 ) { mb_mapping -> tab_registers [ i ] = ( req [ offset + j ] << 8 ) + req [ offset + j + 1 ] ; } for ( i = mapping_address ; i < mapping_address + nb ; i ++ ) { rsp [ rsp_length ++ ] = mb_mapping -> tab_registers [ i ] >> 8 ; rsp [ rsp_length ++ ] = mb_mapping -> tab_registers [ i ] & 0xFF ; } } } break ; default : rsp_length = response_exception ( ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_FUNCTION , rsp , TRUE , "Unknown<S2SV_blank>Modbus<S2SV_blank>function<S2SV_blank>code:<S2SV_blank>0x%0X\\n" , function ) ; break ; } return ( ctx -> backend -> backend_type == _MODBUS_BACKEND_TYPE_RTU && slave == MODBUS_BROADCAST_ADDRESS ) ? 0 : send_msg ( ctx , rsp , rsp_length ) ; }
CWE-255 int vt_reset_keyboard ( int fd ) { <S2SV_StartBug> int kb ; <S2SV_EndBug> <S2SV_StartBug> kb = vt_default_utf8 ( ) != 0 ? K_UNICODE : K_XLATE ; <S2SV_EndBug> if ( ioctl ( fd , KDSKBMODE , kb ) < 0 ) return - errno ; return 0 ; }
CWE-255 static int find_source_vc ( char * * ret_path , unsigned * ret_idx ) { _cleanup_free_ char * path = NULL ; int r , err = 0 ; unsigned i ; path = new ( char , sizeof ( "/dev/tty63" ) ) ; if ( ! path ) return log_oom ( ) ; for ( i = 1 ; i <= 63 ; i ++ ) { _cleanup_close_ int fd = - 1 ; r = verify_vc_allocation ( i ) ; if ( r < 0 ) { if ( ! err ) err = - r ; continue ; } sprintf ( path , "/dev/tty%u" , i ) ; fd = open_terminal ( path , O_RDWR | O_CLOEXEC | O_NOCTTY ) ; if ( fd < 0 ) { if ( ! err ) err = - fd ; continue ; } <S2SV_StartBug> r = verify_vc_kbmode ( fd ) ; <S2SV_EndBug> if ( r < 0 ) { if ( ! err ) err = - r ; continue ; } * ret_idx = i ; * ret_path = TAKE_PTR ( path ) ; return TAKE_FD ( fd ) ; } return log_error_errno ( err , "No<S2SV_blank>usable<S2SV_blank>source<S2SV_blank>console<S2SV_blank>found:<S2SV_blank>%m" ) ; }
CWE-255 static void setup_remaining_vcs ( int src_fd , unsigned src_idx , bool utf8 ) { struct console_font_op cfo = { . op = KD_FONT_OP_GET , . width = UINT_MAX , . height = UINT_MAX , . charcount = UINT_MAX , } ; struct unimapinit adv = { } ; struct unimapdesc unimapd ; _cleanup_free_ struct unipair * unipairs = NULL ; _cleanup_free_ void * fontbuf = NULL ; unsigned i ; int r ; unipairs = new ( struct unipair , USHRT_MAX ) ; if ( ! unipairs ) { log_oom ( ) ; return ; } r = ioctl ( src_fd , KDFONTOP , & cfo ) ; if ( r < 0 ) log_warning_errno ( errno , "KD_FONT_OP_GET<S2SV_blank>failed<S2SV_blank>while<S2SV_blank>trying<S2SV_blank>to<S2SV_blank>get<S2SV_blank>the<S2SV_blank>font<S2SV_blank>metadata:<S2SV_blank>%m" ) ; else { if ( cfo . width > 32 || cfo . height > 32 || cfo . charcount > 512 ) log_warning ( "Invalid<S2SV_blank>font<S2SV_blank>metadata<S2SV_blank>-<S2SV_blank>width:<S2SV_blank>%u<S2SV_blank>(max<S2SV_blank>32),<S2SV_blank>height:<S2SV_blank>%u<S2SV_blank>(max<S2SV_blank>32),<S2SV_blank>count:<S2SV_blank>%u<S2SV_blank>(max<S2SV_blank>512)" , cfo . width , cfo . height , cfo . charcount ) ; else { fontbuf = malloc_multiply ( ( cfo . width + 7 ) / 8 * 32 , cfo . charcount ) ; if ( ! fontbuf ) { log_oom ( ) ; return ; } cfo . data = fontbuf ; r = ioctl ( src_fd , KDFONTOP , & cfo ) ; if ( r < 0 ) log_warning_errno ( errno , "KD_FONT_OP_GET<S2SV_blank>failed<S2SV_blank>while<S2SV_blank>trying<S2SV_blank>to<S2SV_blank>read<S2SV_blank>the<S2SV_blank>font<S2SV_blank>data:<S2SV_blank>%m" ) ; else { unimapd . entries = unipairs ; unimapd . entry_ct = USHRT_MAX ; r = ioctl ( src_fd , GIO_UNIMAP , & unimapd ) ; if ( r < 0 ) log_warning_errno ( errno , "GIO_UNIMAP<S2SV_blank>failed<S2SV_blank>while<S2SV_blank>trying<S2SV_blank>to<S2SV_blank>read<S2SV_blank>unicode<S2SV_blank>mappings:<S2SV_blank>%m" ) ; else cfo . op = KD_FONT_OP_SET ; } } } if ( cfo . op != KD_FONT_OP_SET ) log_warning ( "Fonts<S2SV_blank>will<S2SV_blank>not<S2SV_blank>be<S2SV_blank>copied<S2SV_blank>to<S2SV_blank>remaining<S2SV_blank>consoles" ) ; for ( i = 1 ; i <= 63 ; i ++ ) { char ttyname [ sizeof ( "/dev/tty63" ) ] ; _cleanup_close_ int fd_d = - 1 ; if ( i == src_idx || verify_vc_allocation ( i ) < 0 ) continue ; xsprintf ( ttyname , "/dev/tty%u" , i ) ; fd_d = open_terminal ( ttyname , O_RDWR | O_CLOEXEC | O_NOCTTY ) ; if ( fd_d < 0 ) { log_warning_errno ( fd_d , "Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>tty%u,<S2SV_blank>fonts<S2SV_blank>will<S2SV_blank>not<S2SV_blank>be<S2SV_blank>copied:<S2SV_blank>%m" , i ) ; continue ; } <S2SV_StartBug> if ( verify_vc_kbmode ( fd_d ) < 0 ) <S2SV_EndBug> continue ; toggle_utf8 ( ttyname , fd_d , utf8 ) ; if ( cfo . op != KD_FONT_OP_SET ) continue ; r = ioctl ( fd_d , KDFONTOP , & cfo ) ; if ( r < 0 ) { int last_errno , mode ; last_errno = errno ; if ( ioctl ( fd_d , KDGETMODE , & mode ) >= 0 && mode != KD_TEXT ) log_debug ( "KD_FONT_OP_SET<S2SV_blank>skipped:<S2SV_blank>tty%u<S2SV_blank>is<S2SV_blank>not<S2SV_blank>in<S2SV_blank>text<S2SV_blank>mode" , i ) ; else log_warning_errno ( last_errno , "KD_FONT_OP_SET<S2SV_blank>failed,<S2SV_blank>fonts<S2SV_blank>will<S2SV_blank>not<S2SV_blank>be<S2SV_blank>copied<S2SV_blank>to<S2SV_blank>tty%u:<S2SV_blank>%m" , i ) ; continue ; } r = ioctl ( fd_d , PIO_UNIMAPCLR , & adv ) ; if ( r < 0 ) { log_warning_errno ( errno , "PIO_UNIMAPCLR<S2SV_blank>failed,<S2SV_blank>unimaps<S2SV_blank>might<S2SV_blank>be<S2SV_blank>incorrect<S2SV_blank>for<S2SV_blank>tty%u:<S2SV_blank>%m" , i ) ; continue ; } r = ioctl ( fd_d , PIO_UNIMAP , & unimapd ) ; if ( r < 0 ) { log_warning_errno ( errno , "PIO_UNIMAP<S2SV_blank>failed,<S2SV_blank>unimaps<S2SV_blank>might<S2SV_blank>be<S2SV_blank>incorrect<S2SV_blank>for<S2SV_blank>tty%u:<S2SV_blank>%m" , i ) ; continue ; } log_debug ( "Font<S2SV_blank>and<S2SV_blank>unimap<S2SV_blank>successfully<S2SV_blank>copied<S2SV_blank>to<S2SV_blank>%s" , ttyname ) ; } }
CWE-255 static int toggle_utf8 ( const char * name , int fd , bool utf8 ) { int r ; struct termios tc = { } ; <S2SV_StartBug> assert ( name ) ; <S2SV_EndBug> r = ioctl ( fd , KDSKBMODE , utf8 ? K_UNICODE : K_XLATE ) ; if ( r < 0 ) return log_warning_errno ( errno , "Failed<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>UTF-8<S2SV_blank>kbdmode<S2SV_blank>on<S2SV_blank>%s:<S2SV_blank>%m" , enable_disable ( utf8 ) , name ) ; r = loop_write ( fd , utf8 ? "\\033%G" : "\\033%@" , 3 , false ) ; if ( r < 0 ) return log_warning_errno ( r , "Failed<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>UTF-8<S2SV_blank>term<S2SV_blank>processing<S2SV_blank>on<S2SV_blank>%s:<S2SV_blank>%m" , enable_disable ( utf8 ) , name ) ; r = tcgetattr ( fd , & tc ) ; if ( r >= 0 ) { SET_FLAG ( tc . c_iflag , IUTF8 , utf8 ) ; r = tcsetattr ( fd , TCSANOW , & tc ) ; } if ( r < 0 ) return log_warning_errno ( errno , "Failed<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>iutf8<S2SV_blank>flag<S2SV_blank>on<S2SV_blank>%s:<S2SV_blank>%m" , enable_disable ( utf8 ) , name ) ; log_debug ( "UTF-8<S2SV_blank>kbdmode<S2SV_blank>%sd<S2SV_blank>on<S2SV_blank>%s" , enable_disable ( utf8 ) , name ) ; return 0 ; }
CWE-255 static int verify_source_vc ( char * * ret_path , const char * src_vc ) { _cleanup_close_ int fd = - 1 ; char * path ; int r ; fd = open_terminal ( src_vc , O_RDWR | O_CLOEXEC | O_NOCTTY ) ; if ( fd < 0 ) return log_error_errno ( fd , "Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s:<S2SV_blank>%m" , src_vc ) ; r = verify_vc_device ( fd ) ; if ( r < 0 ) return log_error_errno ( r , "Device<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>virtual<S2SV_blank>console:<S2SV_blank>%m" , src_vc ) ; r = verify_vc_allocation_byfd ( fd ) ; if ( r < 0 ) return log_error_errno ( r , "Virtual<S2SV_blank>console<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>allocated:<S2SV_blank>%m" , src_vc ) ; <S2SV_StartBug> r = verify_vc_kbmode ( fd ) ; <S2SV_EndBug> if ( r < 0 ) return log_error_errno ( r , "Virtual<S2SV_blank>console<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>in<S2SV_blank>K_XLATE<S2SV_blank>or<S2SV_blank>K_UNICODE:<S2SV_blank>%m" , src_vc ) ; path = strdup ( src_vc ) ; if ( ! path ) return log_oom ( ) ; * ret_path = path ; return TAKE_FD ( fd ) ; }
CWE-918 static int daemon_msg_open_req ( uint8 ver , struct daemon_slpars * pars , uint32 plen , char * source , size_t sourcelen ) { char errbuf [ PCAP_ERRBUF_SIZE ] ; char errmsgbuf [ PCAP_ERRBUF_SIZE ] ; pcap_t * fp ; int nread ; char sendbuf [ RPCAP_NETBUF_SIZE ] ; int sendbufidx = 0 ; struct rpcap_openreply * openreply ; if ( plen > sourcelen - 1 ) { pcap_snprintf ( errmsgbuf , PCAP_ERRBUF_SIZE , "Source<S2SV_blank>string<S2SV_blank>too<S2SV_blank>long" ) ; goto error ; } nread = sock_recv ( pars -> sockctrl , source , plen , SOCK_RECEIVEALL_YES | SOCK_EOF_IS_ERROR , errbuf , PCAP_ERRBUF_SIZE ) ; if ( nread == - 1 ) { rpcapd_log ( LOGPRIO_ERROR , "Read<S2SV_blank>from<S2SV_blank>client<S2SV_blank>failed:<S2SV_blank>%s" , errbuf ) ; return - 1 ; } source [ nread ] = '\\0' ; plen -= nread ; <S2SV_StartBug> if ( ( fp = pcap_open_live ( source , <S2SV_EndBug> 1500 , 0 , 1000 , errmsgbuf ) ) == NULL ) goto error ; if ( sock_bufferize ( NULL , sizeof ( struct rpcap_header ) , NULL , & sendbufidx , RPCAP_NETBUF_SIZE , SOCKBUF_CHECKONLY , errmsgbuf , PCAP_ERRBUF_SIZE ) == - 1 ) goto error ; rpcap_createhdr ( ( struct rpcap_header * ) sendbuf , ver , RPCAP_MSG_OPEN_REPLY , 0 , sizeof ( struct rpcap_openreply ) ) ; openreply = ( struct rpcap_openreply * ) & sendbuf [ sendbufidx ] ; if ( sock_bufferize ( NULL , sizeof ( struct rpcap_openreply ) , NULL , & sendbufidx , RPCAP_NETBUF_SIZE , SOCKBUF_CHECKONLY , errmsgbuf , PCAP_ERRBUF_SIZE ) == - 1 ) goto error ; memset ( openreply , 0 , sizeof ( struct rpcap_openreply ) ) ; openreply -> linktype = htonl ( pcap_datalink ( fp ) ) ; openreply -> tzoff = 0 ; pcap_close ( fp ) ; if ( sock_send ( pars -> sockctrl , sendbuf , sendbufidx , errbuf , PCAP_ERRBUF_SIZE ) == - 1 ) { rpcapd_log ( LOGPRIO_ERROR , "Send<S2SV_blank>to<S2SV_blank>client<S2SV_blank>failed:<S2SV_blank>%s" , errbuf ) ; return - 1 ; } return 0 ; error : if ( rpcap_senderror ( pars -> sockctrl , ver , PCAP_ERR_OPEN , errmsgbuf , errbuf ) == - 1 ) { rpcapd_log ( LOGPRIO_ERROR , "Send<S2SV_blank>to<S2SV_blank>client<S2SV_blank>failed:<S2SV_blank>%s" , errbuf ) ; return - 1 ; } if ( rpcapd_discard ( pars -> sockctrl , plen ) == - 1 ) { return - 1 ; } return 0 ; }
CWE-476 static int daemon_AuthUserPwd ( char * username , char * password , char * errbuf ) { # ifdef _WIN32 HANDLE Token ; if ( LogonUser ( username , "." , password , LOGON32_LOGON_NETWORK , LOGON32_PROVIDER_DEFAULT , & Token ) == 0 ) { pcap_fmt_errmsg_for_win32_err ( errbuf , PCAP_ERRBUF_SIZE , GetLastError ( ) , "LogonUser()<S2SV_blank>failed" ) ; return - 1 ; } if ( ImpersonateLoggedOnUser ( Token ) == 0 ) { pcap_fmt_errmsg_for_win32_err ( errbuf , PCAP_ERRBUF_SIZE , GetLastError ( ) , "ImpersonateLoggedOnUser()<S2SV_blank>failed" ) ; CloseHandle ( Token ) ; return - 1 ; } CloseHandle ( Token ) ; return 0 ; # else struct passwd * user ; char * user_password ; # ifdef HAVE_GETSPNAM struct spwd * usersp ; <S2SV_StartBug> # endif <S2SV_EndBug> if ( ( user = getpwnam ( username ) ) == NULL ) { pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , "Authentication<S2SV_blank>failed:<S2SV_blank>user<S2SV_blank>name<S2SV_blank>or<S2SV_blank>password<S2SV_blank>incorrect" ) ; return - 1 ; } # ifdef HAVE_GETSPNAM if ( ( usersp = getspnam ( username ) ) == NULL ) { pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , "Authentication<S2SV_blank>failed:<S2SV_blank>user<S2SV_blank>name<S2SV_blank>or<S2SV_blank>password<S2SV_blank>incorrect" ) ; return - 1 ; } user_password = usersp -> sp_pwdp ; # else user_password = user -> pw_passwd ; # endif <S2SV_StartBug> if ( strcmp ( user_password , ( char * ) crypt ( password , user_password ) ) != 0 ) <S2SV_EndBug> { pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , "Authentication<S2SV_blank>failed:<S2SV_blank>user<S2SV_blank>name<S2SV_blank>or<S2SV_blank>password<S2SV_blank>incorrect" ) ; return - 1 ; } if ( setuid ( user -> pw_uid ) ) { pcap_fmt_errmsg_for_errno ( errbuf , PCAP_ERRBUF_SIZE , errno , "setuid" ) ; return - 1 ; } return 0 ; # endif }
CWE-345 static int daemon_AuthUserPwd ( char * username , char * password , char * errbuf ) { # ifdef _WIN32 <S2SV_StartBug> HANDLE Token ; <S2SV_EndBug> <S2SV_StartBug> if ( LogonUser ( username , "." , password , LOGON32_LOGON_NETWORK , LOGON32_PROVIDER_DEFAULT , & Token ) == 0 ) <S2SV_EndBug> { <S2SV_StartBug> pcap_fmt_errmsg_for_win32_err ( errbuf , PCAP_ERRBUF_SIZE , <S2SV_EndBug> <S2SV_StartBug> GetLastError ( ) , "LogonUser()<S2SV_blank>failed" ) ; <S2SV_EndBug> return - 1 ; } <S2SV_StartBug> if ( ImpersonateLoggedOnUser ( Token ) == 0 ) <S2SV_EndBug> { pcap_fmt_errmsg_for_win32_err ( errbuf , PCAP_ERRBUF_SIZE , GetLastError ( ) , "ImpersonateLoggedOnUser()<S2SV_blank>failed" ) ; CloseHandle ( Token ) ; <S2SV_StartBug> return - 1 ; <S2SV_EndBug> } CloseHandle ( Token ) ; return 0 ; <S2SV_StartBug> # else <S2SV_EndBug> struct passwd * user ; char * user_password ; # ifdef HAVE_GETSPNAM struct spwd * usersp ; # endif char * crypt_password ; if ( ( user = getpwnam ( username ) ) == NULL ) { <S2SV_StartBug> pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , "Authentication<S2SV_blank>failed:<S2SV_blank>user<S2SV_blank>name<S2SV_blank>or<S2SV_blank>password<S2SV_blank>incorrect" ) ; <S2SV_EndBug> return - 1 ; } # ifdef HAVE_GETSPNAM if ( ( usersp = getspnam ( username ) ) == NULL ) { <S2SV_StartBug> pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , "Authentication<S2SV_blank>failed:<S2SV_blank>user<S2SV_blank>name<S2SV_blank>or<S2SV_blank>password<S2SV_blank>incorrect" ) ; <S2SV_EndBug> return - 1 ; } user_password = usersp -> sp_pwdp ; # else user_password = user -> pw_passwd ; # endif <S2SV_StartBug> crypt_password = crypt ( password , user_password ) ; <S2SV_EndBug> if ( crypt_password == NULL ) { <S2SV_StartBug> pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , "Authentication<S2SV_blank>failed" ) ; <S2SV_EndBug> return - 1 ; } if ( strcmp ( user_password , crypt_password ) != 0 ) { <S2SV_StartBug> pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , "Authentication<S2SV_blank>failed:<S2SV_blank>user<S2SV_blank>name<S2SV_blank>or<S2SV_blank>password<S2SV_blank>incorrect" ) ; <S2SV_EndBug> return - 1 ; } if ( setuid ( user -> pw_uid ) ) { <S2SV_StartBug> pcap_fmt_errmsg_for_errno ( errbuf , PCAP_ERRBUF_SIZE , <S2SV_EndBug> <S2SV_StartBug> errno , "setuid" ) ; <S2SV_EndBug> <S2SV_StartBug> return - 1 ; <S2SV_EndBug> } return 0 ; # endif }
CWE-20 static int daemon_msg_findallif_req ( uint8 ver , struct daemon_slpars * pars , uint32 plen ) { char errbuf [ PCAP_ERRBUF_SIZE ] ; char errmsgbuf [ PCAP_ERRBUF_SIZE ] ; char sendbuf [ RPCAP_NETBUF_SIZE ] ; int sendbufidx = 0 ; pcap_if_t * alldevs = NULL ; pcap_if_t * d ; struct pcap_addr * address ; struct rpcap_findalldevs_if * findalldevs_if ; <S2SV_StartBug> uint16 nif = 0 ; <S2SV_EndBug> if ( rpcapd_discard ( pars -> sockctrl , plen ) == - 1 ) { return - 1 ; } if ( pcap_findalldevs ( & alldevs , errmsgbuf ) == - 1 ) goto error ; if ( alldevs == NULL ) { if ( rpcap_senderror ( pars -> sockctrl , ver , PCAP_ERR_NOREMOTEIF , "No<S2SV_blank>interfaces<S2SV_blank>found!<S2SV_blank>Make<S2SV_blank>sure<S2SV_blank>libpcap/WinPcap<S2SV_blank>is<S2SV_blank>properly<S2SV_blank>installed" "<S2SV_blank>and<S2SV_blank>you<S2SV_blank>have<S2SV_blank>the<S2SV_blank>right<S2SV_blank>to<S2SV_blank>access<S2SV_blank>to<S2SV_blank>the<S2SV_blank>remote<S2SV_blank>device." , errbuf ) == - 1 ) { rpcapd_log ( LOGPRIO_ERROR , "Send<S2SV_blank>to<S2SV_blank>client<S2SV_blank>failed:<S2SV_blank>%s" , errbuf ) ; return - 1 ; } return 0 ; } <S2SV_StartBug> for ( d = alldevs ; d != NULL ; d = d -> next ) <S2SV_EndBug> { nif ++ ; if ( d -> description ) <S2SV_StartBug> plen += strlen ( d -> description ) ; <S2SV_EndBug> if ( d -> name ) <S2SV_StartBug> plen += strlen ( d -> name ) ; <S2SV_EndBug> <S2SV_StartBug> plen += sizeof ( struct rpcap_findalldevs_if ) ; <S2SV_EndBug> for ( address = d -> addresses ; address != NULL ; address = address -> next ) { switch ( address -> addr -> sa_family ) { case AF_INET : # ifdef AF_INET6 case AF_INET6 : # endif <S2SV_StartBug> plen += ( sizeof ( struct rpcap_sockaddr ) * 4 ) ; <S2SV_EndBug> break ; default : break ; } } } if ( sock_bufferize ( NULL , sizeof ( struct rpcap_header ) , NULL , & sendbufidx , RPCAP_NETBUF_SIZE , SOCKBUF_CHECKONLY , errmsgbuf , PCAP_ERRBUF_SIZE ) == - 1 ) goto error ; rpcap_createhdr ( ( struct rpcap_header * ) sendbuf , ver , <S2SV_StartBug> RPCAP_MSG_FINDALLIF_REPLY , nif , plen ) ; <S2SV_EndBug> for ( d = alldevs ; d != NULL ; d = d -> next ) { uint16 lname , ldescr ; findalldevs_if = ( struct rpcap_findalldevs_if * ) & sendbuf [ sendbufidx ] ; if ( sock_bufferize ( NULL , sizeof ( struct rpcap_findalldevs_if ) , NULL , & sendbufidx , RPCAP_NETBUF_SIZE , SOCKBUF_CHECKONLY , errmsgbuf , PCAP_ERRBUF_SIZE ) == - 1 ) goto error ; memset ( findalldevs_if , 0 , sizeof ( struct rpcap_findalldevs_if ) ) ; if ( d -> description ) ldescr = ( short ) strlen ( d -> description ) ; else ldescr = 0 ; if ( d -> name ) lname = ( short ) strlen ( d -> name ) ; else lname = 0 ; findalldevs_if -> desclen = htons ( ldescr ) ; findalldevs_if -> namelen = htons ( lname ) ; findalldevs_if -> flags = htonl ( d -> flags ) ; for ( address = d -> addresses ; address != NULL ; address = address -> next ) { switch ( address -> addr -> sa_family ) { case AF_INET : # ifdef AF_INET6 case AF_INET6 : # endif findalldevs_if -> naddr ++ ; break ; default : break ; } } findalldevs_if -> naddr = htons ( findalldevs_if -> naddr ) ; if ( sock_bufferize ( d -> name , lname , sendbuf , & sendbufidx , RPCAP_NETBUF_SIZE , SOCKBUF_BUFFERIZE , errmsgbuf , PCAP_ERRBUF_SIZE ) == - 1 ) goto error ; if ( sock_bufferize ( d -> description , ldescr , sendbuf , & sendbufidx , RPCAP_NETBUF_SIZE , SOCKBUF_BUFFERIZE , errmsgbuf , PCAP_ERRBUF_SIZE ) == - 1 ) goto error ; for ( address = d -> addresses ; address != NULL ; address = address -> next ) { struct rpcap_sockaddr * sockaddr ; switch ( address -> addr -> sa_family ) { case AF_INET : # ifdef AF_INET6 case AF_INET6 : # endif sockaddr = ( struct rpcap_sockaddr * ) & sendbuf [ sendbufidx ] ; if ( sock_bufferize ( NULL , sizeof ( struct rpcap_sockaddr ) , NULL , & sendbufidx , RPCAP_NETBUF_SIZE , SOCKBUF_CHECKONLY , errmsgbuf , PCAP_ERRBUF_SIZE ) == - 1 ) goto error ; daemon_seraddr ( ( struct sockaddr_storage * ) address -> addr , sockaddr ) ; sockaddr = ( struct rpcap_sockaddr * ) & sendbuf [ sendbufidx ] ; if ( sock_bufferize ( NULL , sizeof ( struct rpcap_sockaddr ) , NULL , & sendbufidx , RPCAP_NETBUF_SIZE , SOCKBUF_CHECKONLY , errmsgbuf , PCAP_ERRBUF_SIZE ) == - 1 ) goto error ; daemon_seraddr ( ( struct sockaddr_storage * ) address -> netmask , sockaddr ) ; sockaddr = ( struct rpcap_sockaddr * ) & sendbuf [ sendbufidx ] ; if ( sock_bufferize ( NULL , sizeof ( struct rpcap_sockaddr ) , NULL , & sendbufidx , RPCAP_NETBUF_SIZE , SOCKBUF_CHECKONLY , errmsgbuf , PCAP_ERRBUF_SIZE ) == - 1 ) goto error ; daemon_seraddr ( ( struct sockaddr_storage * ) address -> broadaddr , sockaddr ) ; sockaddr = ( struct rpcap_sockaddr * ) & sendbuf [ sendbufidx ] ; if ( sock_bufferize ( NULL , sizeof ( struct rpcap_sockaddr ) , NULL , & sendbufidx , RPCAP_NETBUF_SIZE , SOCKBUF_CHECKONLY , errmsgbuf , PCAP_ERRBUF_SIZE ) == - 1 ) goto error ; daemon_seraddr ( ( struct sockaddr_storage * ) address -> dstaddr , sockaddr ) ; break ; default : break ; } } } pcap_freealldevs ( alldevs ) ; if ( sock_send ( pars -> sockctrl , sendbuf , sendbufidx , errbuf , PCAP_ERRBUF_SIZE ) == - 1 ) { rpcapd_log ( LOGPRIO_ERROR , "Send<S2SV_blank>to<S2SV_blank>client<S2SV_blank>failed:<S2SV_blank>%s" , errbuf ) ; return - 1 ; } return 0 ; error : if ( alldevs ) pcap_freealldevs ( alldevs ) ; if ( rpcap_senderror ( pars -> sockctrl , ver , PCAP_ERR_FINDALLIF , errmsgbuf , errbuf ) == - 1 ) { rpcapd_log ( LOGPRIO_ERROR , "Send<S2SV_blank>to<S2SV_blank>client<S2SV_blank>failed:<S2SV_blank>%s" , errbuf ) ; return - 1 ; } return 0 ; }
CWE-20 pcap_t * pcap_ng_check_header ( const uint8_t * magic , FILE * fp , u_int precision , char * errbuf , int * err ) { bpf_u_int32 magic_int ; size_t amt_read ; bpf_u_int32 total_length ; bpf_u_int32 byte_order_magic ; struct block_header * bhdrp ; struct section_header_block * shbp ; pcap_t * p ; int swapped = 0 ; struct pcap_ng_sf * ps ; int status ; struct block_cursor cursor ; struct interface_description_block * idbp ; * err = 0 ; memcpy ( & magic_int , magic , sizeof ( magic_int ) ) ; if ( magic_int != BT_SHB ) { return ( NULL ) ; } amt_read = fread ( & total_length , 1 , sizeof ( total_length ) , fp ) ; if ( amt_read < sizeof ( total_length ) ) { if ( ferror ( fp ) ) { pcap_fmt_errmsg_for_errno ( errbuf , PCAP_ERRBUF_SIZE , errno , "error<S2SV_blank>reading<S2SV_blank>dump<S2SV_blank>file" ) ; * err = 1 ; return ( NULL ) ; } return ( NULL ) ; } amt_read = fread ( & byte_order_magic , 1 , sizeof ( byte_order_magic ) , fp ) ; if ( amt_read < sizeof ( byte_order_magic ) ) { if ( ferror ( fp ) ) { pcap_fmt_errmsg_for_errno ( errbuf , PCAP_ERRBUF_SIZE , errno , "error<S2SV_blank>reading<S2SV_blank>dump<S2SV_blank>file" ) ; * err = 1 ; return ( NULL ) ; } return ( NULL ) ; } if ( byte_order_magic != BYTE_ORDER_MAGIC ) { byte_order_magic = SWAPLONG ( byte_order_magic ) ; if ( byte_order_magic != BYTE_ORDER_MAGIC ) { return ( NULL ) ; } swapped = 1 ; total_length = SWAPLONG ( total_length ) ; } <S2SV_StartBug> if ( total_length < sizeof ( * bhdrp ) + sizeof ( * shbp ) + sizeof ( struct block_trailer ) ) { <S2SV_EndBug> pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , <S2SV_StartBug> "Section<S2SV_blank>Header<S2SV_blank>Block<S2SV_blank>in<S2SV_blank>pcapng<S2SV_blank>dump<S2SV_blank>file<S2SV_blank>has<S2SV_blank>a<S2SV_blank>length<S2SV_blank>of<S2SV_blank>%u<S2SV_blank><<S2SV_blank>%" PRIsize , <S2SV_EndBug> total_length , <S2SV_StartBug> sizeof ( * bhdrp ) + sizeof ( * shbp ) + sizeof ( struct block_trailer ) ) ; <S2SV_EndBug> * err = 1 ; return ( NULL ) ; } if ( total_length > INITIAL_MAX_BLOCKSIZE ) { pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , "pcapng<S2SV_blank>block<S2SV_blank>size<S2SV_blank>%u<S2SV_blank>><S2SV_blank>maximum<S2SV_blank>%u" , total_length , INITIAL_MAX_BLOCKSIZE ) ; * err = 1 ; return ( NULL ) ; } p = pcap_open_offline_common ( errbuf , sizeof ( struct pcap_ng_sf ) ) ; if ( p == NULL ) { * err = 1 ; return ( NULL ) ; } p -> swapped = swapped ; ps = p -> priv ; switch ( precision ) { case PCAP_TSTAMP_PRECISION_MICRO : ps -> user_tsresol = 1000000 ; break ; case PCAP_TSTAMP_PRECISION_NANO : ps -> user_tsresol = 1000000000 ; break ; default : pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , "unknown<S2SV_blank>time<S2SV_blank>stamp<S2SV_blank>resolution<S2SV_blank>%u" , precision ) ; free ( p ) ; * err = 1 ; return ( NULL ) ; } p -> opt . tstamp_precision = precision ; p -> bufsize = 2048 ; if ( p -> bufsize < total_length ) p -> bufsize = total_length ; p -> buffer = malloc ( p -> bufsize ) ; if ( p -> buffer == NULL ) { pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , "out<S2SV_blank>of<S2SV_blank>memory" ) ; free ( p ) ; * err = 1 ; return ( NULL ) ; } ps -> max_blocksize = INITIAL_MAX_BLOCKSIZE ; bhdrp = ( struct block_header * ) p -> buffer ; shbp = ( struct section_header_block * ) ( ( u_char * ) p -> buffer + sizeof ( struct block_header ) ) ; bhdrp -> block_type = magic_int ; bhdrp -> total_length = total_length ; shbp -> byte_order_magic = byte_order_magic ; if ( read_bytes ( fp , ( u_char * ) p -> buffer + ( sizeof ( magic_int ) + sizeof ( total_length ) + sizeof ( byte_order_magic ) ) , total_length - ( sizeof ( magic_int ) + sizeof ( total_length ) + sizeof ( byte_order_magic ) ) , 1 , errbuf ) == - 1 ) goto fail ; if ( p -> swapped ) { shbp -> major_version = SWAPSHORT ( shbp -> major_version ) ; shbp -> minor_version = SWAPSHORT ( shbp -> minor_version ) ; } if ( ! ( shbp -> major_version == PCAP_NG_VERSION_MAJOR && shbp -> minor_version == PCAP_NG_VERSION_MINOR ) ) { pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , "unsupported<S2SV_blank>pcapng<S2SV_blank>savefile<S2SV_blank>version<S2SV_blank>%u.%u" , shbp -> major_version , shbp -> minor_version ) ; goto fail ; } p -> version_major = shbp -> major_version ; p -> version_minor = shbp -> minor_version ; p -> opt . tstamp_precision = precision ; for ( ; ; ) { status = read_block ( fp , p , & cursor , errbuf ) ; if ( status == 0 ) { pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , "the<S2SV_blank>capture<S2SV_blank>file<S2SV_blank>has<S2SV_blank>no<S2SV_blank>Interface<S2SV_blank>Description<S2SV_blank>Blocks" ) ; goto fail ; } if ( status == - 1 ) goto fail ; switch ( cursor . block_type ) { case BT_IDB : idbp = get_from_block_data ( & cursor , sizeof ( * idbp ) , errbuf ) ; if ( idbp == NULL ) goto fail ; if ( p -> swapped ) { idbp -> linktype = SWAPSHORT ( idbp -> linktype ) ; idbp -> snaplen = SWAPLONG ( idbp -> snaplen ) ; } if ( ! add_interface ( p , & cursor , errbuf ) ) goto fail ; goto done ; case BT_EPB : case BT_SPB : case BT_PB : pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , "the<S2SV_blank>capture<S2SV_blank>file<S2SV_blank>has<S2SV_blank>a<S2SV_blank>packet<S2SV_blank>block<S2SV_blank>before<S2SV_blank>any<S2SV_blank>Interface<S2SV_blank>Description<S2SV_blank>Blocks" ) ; goto fail ; default : break ; } } done : p -> tzoff = 0 ; p -> linktype = linktype_to_dlt ( idbp -> linktype ) ; p -> snapshot = pcap_adjust_snapshot ( p -> linktype , idbp -> snaplen ) ; p -> linktype_ext = 0 ; if ( MAX_BLOCKSIZE_FOR_SNAPLEN ( max_snaplen_for_dlt ( p -> linktype ) ) > ps -> max_blocksize ) ps -> max_blocksize = MAX_BLOCKSIZE_FOR_SNAPLEN ( max_snaplen_for_dlt ( p -> linktype ) ) ; p -> next_packet_op = pcap_ng_next_packet ; p -> cleanup_op = pcap_ng_cleanup ; return ( p ) ; fail : free ( ps -> ifaces ) ; free ( p -> buffer ) ; free ( p ) ; * err = 1 ; return ( NULL ) ; }
CWE-20 static int read_bytes ( FILE * fp , void * buf , size_t bytes_to_read , int fail_on_eof , char * errbuf ) { size_t amt_read ; amt_read = fread ( buf , 1 , bytes_to_read , fp ) ; if ( amt_read != bytes_to_read ) { if ( ferror ( fp ) ) { pcap_fmt_errmsg_for_errno ( errbuf , PCAP_ERRBUF_SIZE , errno , "error<S2SV_blank>reading<S2SV_blank>dump<S2SV_blank>file" ) ; } else { if ( amt_read == 0 && ! fail_on_eof ) return ( 0 ) ; pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , <S2SV_StartBug> "truncated<S2SV_blank>dump<S2SV_blank>file;<S2SV_blank>tried<S2SV_blank>to<S2SV_blank>read<S2SV_blank>%" PRIsize "<S2SV_blank>bytes,<S2SV_blank>only<S2SV_blank>got<S2SV_blank>%" PRIsize , <S2SV_EndBug> bytes_to_read , amt_read ) ; } return ( - 1 ) ; } return ( 1 ) ; }
CWE-20 pcap_t * pcap_ng_check_header ( const uint8_t * magic , FILE * fp , u_int precision , char * errbuf , int * err ) { bpf_u_int32 magic_int ; size_t amt_read ; bpf_u_int32 total_length ; bpf_u_int32 byte_order_magic ; struct block_header * bhdrp ; struct section_header_block * shbp ; pcap_t * p ; int swapped = 0 ; struct pcap_ng_sf * ps ; int status ; struct block_cursor cursor ; struct interface_description_block * idbp ; * err = 0 ; memcpy ( & magic_int , magic , sizeof ( magic_int ) ) ; if ( magic_int != BT_SHB ) { return ( NULL ) ; } amt_read = fread ( & total_length , 1 , sizeof ( total_length ) , fp ) ; if ( amt_read < sizeof ( total_length ) ) { if ( ferror ( fp ) ) { pcap_fmt_errmsg_for_errno ( errbuf , PCAP_ERRBUF_SIZE , errno , "error<S2SV_blank>reading<S2SV_blank>dump<S2SV_blank>file" ) ; * err = 1 ; return ( NULL ) ; } return ( NULL ) ; } amt_read = fread ( & byte_order_magic , 1 , sizeof ( byte_order_magic ) , fp ) ; if ( amt_read < sizeof ( byte_order_magic ) ) { if ( ferror ( fp ) ) { pcap_fmt_errmsg_for_errno ( errbuf , PCAP_ERRBUF_SIZE , errno , "error<S2SV_blank>reading<S2SV_blank>dump<S2SV_blank>file" ) ; * err = 1 ; return ( NULL ) ; } return ( NULL ) ; } if ( byte_order_magic != BYTE_ORDER_MAGIC ) { byte_order_magic = SWAPLONG ( byte_order_magic ) ; if ( byte_order_magic != BYTE_ORDER_MAGIC ) { return ( NULL ) ; } swapped = 1 ; total_length = SWAPLONG ( total_length ) ; } if ( total_length < sizeof ( * bhdrp ) + sizeof ( * shbp ) + sizeof ( struct block_trailer ) || ( total_length > BT_SHB_INSANE_MAX ) ) { pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , <S2SV_StartBug> "Section<S2SV_blank>Header<S2SV_blank>Block<S2SV_blank>in<S2SV_blank>pcapng<S2SV_blank>dump<S2SV_blank>file<S2SV_blank>has<S2SV_blank>invalid<S2SV_blank>length<S2SV_blank>%" PRIsize "<S2SV_blank><<S2SV_blank>_%lu_<S2SV_blank><<S2SV_blank>%lu<S2SV_blank>(BT_SHB_INSANE_MAX)" , <S2SV_EndBug> sizeof ( * bhdrp ) + sizeof ( * shbp ) + sizeof ( struct block_trailer ) , total_length , BT_SHB_INSANE_MAX ) ; * err = 1 ; return ( NULL ) ; } p = pcap_open_offline_common ( errbuf , sizeof ( struct pcap_ng_sf ) ) ; if ( p == NULL ) { * err = 1 ; return ( NULL ) ; } p -> swapped = swapped ; ps = p -> priv ; switch ( precision ) { case PCAP_TSTAMP_PRECISION_MICRO : ps -> user_tsresol = 1000000 ; break ; case PCAP_TSTAMP_PRECISION_NANO : ps -> user_tsresol = 1000000000 ; break ; default : pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , "unknown<S2SV_blank>time<S2SV_blank>stamp<S2SV_blank>resolution<S2SV_blank>%u" , precision ) ; free ( p ) ; * err = 1 ; return ( NULL ) ; } p -> opt . tstamp_precision = precision ; p -> bufsize = 2048 ; if ( p -> bufsize < total_length ) p -> bufsize = total_length ; p -> buffer = malloc ( p -> bufsize ) ; if ( p -> buffer == NULL ) { pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , "out<S2SV_blank>of<S2SV_blank>memory" ) ; free ( p ) ; * err = 1 ; return ( NULL ) ; } ps -> max_blocksize = INITIAL_MAX_BLOCKSIZE ; bhdrp = ( struct block_header * ) p -> buffer ; shbp = ( struct section_header_block * ) ( ( u_char * ) p -> buffer + sizeof ( struct block_header ) ) ; bhdrp -> block_type = magic_int ; bhdrp -> total_length = total_length ; shbp -> byte_order_magic = byte_order_magic ; if ( read_bytes ( fp , ( u_char * ) p -> buffer + ( sizeof ( magic_int ) + sizeof ( total_length ) + sizeof ( byte_order_magic ) ) , total_length - ( sizeof ( magic_int ) + sizeof ( total_length ) + sizeof ( byte_order_magic ) ) , 1 , errbuf ) == - 1 ) goto fail ; if ( p -> swapped ) { shbp -> major_version = SWAPSHORT ( shbp -> major_version ) ; shbp -> minor_version = SWAPSHORT ( shbp -> minor_version ) ; } if ( ! ( shbp -> major_version == PCAP_NG_VERSION_MAJOR && shbp -> minor_version == PCAP_NG_VERSION_MINOR ) ) { pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , "unsupported<S2SV_blank>pcapng<S2SV_blank>savefile<S2SV_blank>version<S2SV_blank>%u.%u" , shbp -> major_version , shbp -> minor_version ) ; goto fail ; } p -> version_major = shbp -> major_version ; p -> version_minor = shbp -> minor_version ; p -> opt . tstamp_precision = precision ; for ( ; ; ) { status = read_block ( fp , p , & cursor , errbuf ) ; if ( status == 0 ) { pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , "the<S2SV_blank>capture<S2SV_blank>file<S2SV_blank>has<S2SV_blank>no<S2SV_blank>Interface<S2SV_blank>Description<S2SV_blank>Blocks" ) ; goto fail ; } if ( status == - 1 ) goto fail ; switch ( cursor . block_type ) { case BT_IDB : idbp = get_from_block_data ( & cursor , sizeof ( * idbp ) , errbuf ) ; if ( idbp == NULL ) goto fail ; if ( p -> swapped ) { idbp -> linktype = SWAPSHORT ( idbp -> linktype ) ; idbp -> snaplen = SWAPLONG ( idbp -> snaplen ) ; } if ( ! add_interface ( p , & cursor , errbuf ) ) goto fail ; goto done ; case BT_EPB : case BT_SPB : case BT_PB : pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , "the<S2SV_blank>capture<S2SV_blank>file<S2SV_blank>has<S2SV_blank>a<S2SV_blank>packet<S2SV_blank>block<S2SV_blank>before<S2SV_blank>any<S2SV_blank>Interface<S2SV_blank>Description<S2SV_blank>Blocks" ) ; goto fail ; default : break ; } } done : p -> tzoff = 0 ; p -> linktype = linktype_to_dlt ( idbp -> linktype ) ; p -> snapshot = pcap_adjust_snapshot ( p -> linktype , idbp -> snaplen ) ; p -> linktype_ext = 0 ; if ( MAX_BLOCKSIZE_FOR_SNAPLEN ( max_snaplen_for_dlt ( p -> linktype ) ) > ps -> max_blocksize ) ps -> max_blocksize = MAX_BLOCKSIZE_FOR_SNAPLEN ( max_snaplen_for_dlt ( p -> linktype ) ) ; p -> next_packet_op = pcap_ng_next_packet ; p -> cleanup_op = pcap_ng_cleanup ; return ( p ) ; fail : free ( ps -> ifaces ) ; free ( p -> buffer ) ; free ( p ) ; * err = 1 ; return ( NULL ) ; }
CWE-20 void lmp_print ( netdissect_options * ndo , register const u_char * pptr , register u_int len ) { const struct lmp_common_header * lmp_com_header ; const struct lmp_object_header * lmp_obj_header ; const u_char * tptr , * obj_tptr ; u_int tlen , lmp_obj_len , lmp_obj_ctype , obj_tlen ; int hexdump , ret ; u_int offset ; u_int link_type ; union { float f ; uint32_t i ; } bw ; tptr = pptr ; lmp_com_header = ( const struct lmp_common_header * ) pptr ; ND_TCHECK ( * lmp_com_header ) ; if ( LMP_EXTRACT_VERSION ( lmp_com_header -> version_res [ 0 ] ) != LMP_VERSION ) { ND_PRINT ( ( ndo , "LMP<S2SV_blank>version<S2SV_blank>%u<S2SV_blank>packet<S2SV_blank>not<S2SV_blank>supported" , LMP_EXTRACT_VERSION ( lmp_com_header -> version_res [ 0 ] ) ) ) ; return ; } if ( ndo -> ndo_vflag < 1 ) { ND_PRINT ( ( ndo , "LMPv%u<S2SV_blank>%s<S2SV_blank>Message,<S2SV_blank>length:<S2SV_blank>%u" , LMP_EXTRACT_VERSION ( lmp_com_header -> version_res [ 0 ] ) , tok2str ( lmp_msg_type_values , "unknown<S2SV_blank>(%u)" , lmp_com_header -> msg_type ) , len ) ) ; return ; } tlen = EXTRACT_16BITS ( lmp_com_header -> length ) ; ND_PRINT ( ( ndo , "\\n\\tLMPv%u,<S2SV_blank>msg-type:<S2SV_blank>%s,<S2SV_blank>Flags:<S2SV_blank>[%s],<S2SV_blank>length:<S2SV_blank>%u" , LMP_EXTRACT_VERSION ( lmp_com_header -> version_res [ 0 ] ) , tok2str ( lmp_msg_type_values , "unknown,<S2SV_blank>type:<S2SV_blank>%u" , lmp_com_header -> msg_type ) , bittok2str ( lmp_header_flag_values , "none" , lmp_com_header -> flags ) , tlen ) ) ; if ( tlen < sizeof ( const struct lmp_common_header ) ) { ND_PRINT ( ( ndo , "<S2SV_blank>(too<S2SV_blank>short)" ) ) ; return ; } if ( tlen > len ) { ND_PRINT ( ( ndo , "<S2SV_blank>(too<S2SV_blank>long)" ) ) ; tlen = len ; } tptr += sizeof ( const struct lmp_common_header ) ; tlen -= sizeof ( const struct lmp_common_header ) ; while ( tlen > 0 ) { ND_TCHECK2 ( * tptr , sizeof ( struct lmp_object_header ) ) ; lmp_obj_header = ( const struct lmp_object_header * ) tptr ; lmp_obj_len = EXTRACT_16BITS ( lmp_obj_header -> length ) ; lmp_obj_ctype = ( lmp_obj_header -> ctype ) & 0x7f ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Object<S2SV_blank>(%u),<S2SV_blank>Class-Type:<S2SV_blank>%s<S2SV_blank>(%u)<S2SV_blank>Flags:<S2SV_blank>[%snegotiable],<S2SV_blank>length:<S2SV_blank>%u" , tok2str ( lmp_obj_values , "Unknown" , lmp_obj_header -> class_num ) , lmp_obj_header -> class_num , tok2str ( lmp_ctype_values , "Unknown" , ( ( lmp_obj_header -> class_num ) << 8 ) + lmp_obj_ctype ) , lmp_obj_ctype , ( lmp_obj_header -> ctype ) & 0x80 ? "" : "non-" , lmp_obj_len ) ) ; if ( lmp_obj_len < 4 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(too<S2SV_blank>short)" ) ) ; return ; } if ( ( lmp_obj_len % 4 ) != 0 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>a<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>4)" ) ) ; return ; } obj_tptr = tptr + sizeof ( struct lmp_object_header ) ; obj_tlen = lmp_obj_len - sizeof ( struct lmp_object_header ) ; ND_TCHECK2 ( * tptr , lmp_obj_len ) ; hexdump = FALSE ; switch ( lmp_obj_header -> class_num ) { case LMP_OBJ_CC_ID : switch ( lmp_obj_ctype ) { case LMP_CTYPE_LOC : case LMP_CTYPE_RMT : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Control<S2SV_blank>Channel<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)" , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_LINK_ID : case LMP_OBJ_INTERFACE_ID : switch ( lmp_obj_ctype ) { case LMP_CTYPE_IPV4_LOC : case LMP_CTYPE_IPV4_RMT : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>IPv4<S2SV_blank>Link<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)" , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; case LMP_CTYPE_IPV6_LOC : case LMP_CTYPE_IPV6_RMT : if ( obj_tlen != 16 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>IPv6<S2SV_blank>Link<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)" , ip6addr_string ( ndo , obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; case LMP_CTYPE_UNMD_LOC : case LMP_CTYPE_UNMD_RMT : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Link<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)" , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_MESSAGE_ID : switch ( lmp_obj_ctype ) { case LMP_CTYPE_1 : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Message<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)" , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; case LMP_CTYPE_2 : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Message<S2SV_blank>ID<S2SV_blank>Ack:<S2SV_blank>%u<S2SV_blank>(0x%08x)" , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_NODE_ID : switch ( lmp_obj_ctype ) { case LMP_CTYPE_LOC : case LMP_CTYPE_RMT : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Node<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)" , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_CONFIG : switch ( lmp_obj_ctype ) { case LMP_CTYPE_HELLO_CONFIG : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Hello<S2SV_blank>Interval:<S2SV_blank>%u\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Hello<S2SV_blank>Dead<S2SV_blank>Interval:<S2SV_blank>%u" , EXTRACT_16BITS ( obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_HELLO : switch ( lmp_obj_ctype ) { case LMP_CTYPE_HELLO : if ( obj_tlen != 8 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Tx<S2SV_blank>Seq:<S2SV_blank>%u,<S2SV_blank>Rx<S2SV_blank>Seq:<S2SV_blank>%u" , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr + 4 ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_TE_LINK : switch ( lmp_obj_ctype ) { case LMP_CTYPE_IPV4 : if ( obj_tlen != 12 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[%s]" , bittok2str ( lmp_obj_te_link_flag_values , "none" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Link-ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)" "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Remote<S2SV_blank>Link-ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)" , ipaddr_string ( ndo , obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , ipaddr_string ( ndo , obj_tptr + 8 ) , EXTRACT_32BITS ( obj_tptr + 8 ) ) ) ; break ; case LMP_CTYPE_IPV6 : if ( obj_tlen != 36 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[%s]" , bittok2str ( lmp_obj_te_link_flag_values , "none" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Link-ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)" "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Remote<S2SV_blank>Link-ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)" , ip6addr_string ( ndo , obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , ip6addr_string ( ndo , obj_tptr + 20 ) , EXTRACT_32BITS ( obj_tptr + 20 ) ) ) ; break ; case LMP_CTYPE_UNMD : if ( obj_tlen != 12 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[%s]" , bittok2str ( lmp_obj_te_link_flag_values , "none" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Link-ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)" "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Remote<S2SV_blank>Link-ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)" , EXTRACT_32BITS ( obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 8 ) , EXTRACT_32BITS ( obj_tptr + 8 ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_DATA_LINK : switch ( lmp_obj_ctype ) { case LMP_CTYPE_IPV4 : if ( obj_tlen < 12 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[%s]" , bittok2str ( lmp_obj_data_link_flag_values , "none" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)" "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Remote<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)" , ipaddr_string ( ndo , obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , ipaddr_string ( ndo , obj_tptr + 8 ) , EXTRACT_32BITS ( obj_tptr + 8 ) ) ) ; ret = lmp_print_data_link_subobjs ( ndo , obj_tptr , obj_tlen - 12 , 12 ) ; if ( ret == - 1 ) goto trunc ; if ( ret == TRUE ) hexdump = TRUE ; break ; case LMP_CTYPE_IPV6 : if ( obj_tlen < 36 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[%s]" , bittok2str ( lmp_obj_data_link_flag_values , "none" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)" "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Remote<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)" , ip6addr_string ( ndo , obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , ip6addr_string ( ndo , obj_tptr + 20 ) , EXTRACT_32BITS ( obj_tptr + 20 ) ) ) ; ret = lmp_print_data_link_subobjs ( ndo , obj_tptr , obj_tlen - 36 , 36 ) ; if ( ret == - 1 ) goto trunc ; if ( ret == TRUE ) hexdump = TRUE ; break ; case LMP_CTYPE_UNMD : if ( obj_tlen < 12 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[%s]" , bittok2str ( lmp_obj_data_link_flag_values , "none" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)" "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Remote<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)" , EXTRACT_32BITS ( obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 8 ) , EXTRACT_32BITS ( obj_tptr + 8 ) ) ) ; ret = lmp_print_data_link_subobjs ( ndo , obj_tptr , obj_tlen - 12 , 12 ) ; if ( ret == - 1 ) goto trunc ; if ( ret == TRUE ) hexdump = TRUE ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_VERIFY_BEGIN : switch ( lmp_obj_ctype ) { case LMP_CTYPE_1 : if ( obj_tlen != 20 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>%s" , bittok2str ( lmp_obj_begin_verify_flag_values , "none" , EXTRACT_16BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Verify<S2SV_blank>Interval:<S2SV_blank>%u" , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Data<S2SV_blank>links:<S2SV_blank>%u" , EXTRACT_32BITS ( obj_tptr + 4 ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Encoding<S2SV_blank>type:<S2SV_blank>%s" , tok2str ( gmpls_encoding_values , "Unknown" , * ( obj_tptr + 8 ) ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Verify<S2SV_blank>Transport<S2SV_blank>Mechanism:<S2SV_blank>%u<S2SV_blank>(0x%x)%s" , EXTRACT_16BITS ( obj_tptr + 10 ) , EXTRACT_16BITS ( obj_tptr + 10 ) , EXTRACT_16BITS ( obj_tptr + 10 ) & 8000 ? "<S2SV_blank>(Payload<S2SV_blank>test<S2SV_blank>messages<S2SV_blank>capable)" : "" ) ) ; bw . i = EXTRACT_32BITS ( obj_tptr + 12 ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Transmission<S2SV_blank>Rate:<S2SV_blank>%.3f<S2SV_blank>Mbps" , bw . f * 8 / 1000000 ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Wavelength:<S2SV_blank>%u" , EXTRACT_32BITS ( obj_tptr + 16 ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_VERIFY_BEGIN_ACK : switch ( lmp_obj_ctype ) { case LMP_CTYPE_1 : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Verify<S2SV_blank>Dead<S2SV_blank>Interval:<S2SV_blank>%u" "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Verify<S2SV_blank>Transport<S2SV_blank>Response:<S2SV_blank>%u" , EXTRACT_16BITS ( obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_VERIFY_ID : switch ( lmp_obj_ctype ) { case LMP_CTYPE_1 : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Verify<S2SV_blank>ID:<S2SV_blank>%u" , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_CHANNEL_STATUS : switch ( lmp_obj_ctype ) { case LMP_CTYPE_IPV4 : offset = 0 ; while ( offset + 8 <= obj_tlen ) { ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)" , ipaddr_string ( ndo , obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Active:<S2SV_blank>%s<S2SV_blank>(%u)" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 31 ) ? "Allocated" : "Non-allocated" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 31 ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Direction:<S2SV_blank>%s<S2SV_blank>(%u)" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 30 ) & 0x1 ? "Transmit" : "Receive" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 30 ) & 0x1 ) ) ; ND_PRINT ( ( ndo , "\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Channel<S2SV_blank>Status:<S2SV_blank>%s<S2SV_blank>(%u)" , tok2str ( lmp_obj_channel_status_values , "Unknown" , EXTRACT_32BITS ( obj_tptr + offset + 4 ) & 0x3FFFFFF ) , EXTRACT_32BITS ( obj_tptr + offset + 4 ) & 0x3FFFFFF ) ) ; offset += 8 ; } break ; case LMP_CTYPE_IPV6 : offset = 0 ; while ( offset + 20 <= obj_tlen ) { ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)" , ip6addr_string ( ndo , obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Active:<S2SV_blank>%s<S2SV_blank>(%u)" , ( EXTRACT_32BITS ( obj_tptr + offset + 16 ) >> 31 ) ? "Allocated" : "Non-allocated" , ( EXTRACT_32BITS ( obj_tptr + offset + 16 ) >> 31 ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Direction:<S2SV_blank>%s<S2SV_blank>(%u)" , ( EXTRACT_32BITS ( obj_tptr + offset + 16 ) >> 30 ) & 0x1 ? "Transmit" : "Receive" , ( EXTRACT_32BITS ( obj_tptr + offset + 16 ) >> 30 ) & 0x1 ) ) ; ND_PRINT ( ( ndo , "\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Channel<S2SV_blank>Status:<S2SV_blank>%s<S2SV_blank>(%u)" , tok2str ( lmp_obj_channel_status_values , "Unknown" , EXTRACT_32BITS ( obj_tptr + offset + 16 ) & 0x3FFFFFF ) , EXTRACT_32BITS ( obj_tptr + offset + 16 ) & 0x3FFFFFF ) ) ; offset += 20 ; } break ; case LMP_CTYPE_UNMD : offset = 0 ; while ( offset + 8 <= obj_tlen ) { ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)" , EXTRACT_32BITS ( obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Active:<S2SV_blank>%s<S2SV_blank>(%u)" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 31 ) ? "Allocated" : "Non-allocated" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 31 ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Direction:<S2SV_blank>%s<S2SV_blank>(%u)" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 30 ) & 0x1 ? "Transmit" : "Receive" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 30 ) & 0x1 ) ) ; ND_PRINT ( ( ndo , "\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Channel<S2SV_blank>Status:<S2SV_blank>%s<S2SV_blank>(%u)" , tok2str ( lmp_obj_channel_status_values , "Unknown" , EXTRACT_32BITS ( obj_tptr + offset + 4 ) & 0x3FFFFFF ) , EXTRACT_32BITS ( obj_tptr + offset + 4 ) & 0x3FFFFFF ) ) ; offset += 8 ; } break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_CHANNEL_STATUS_REQ : switch ( lmp_obj_ctype ) { case LMP_CTYPE_IPV4 : offset = 0 ; while ( offset + 4 <= obj_tlen ) { ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)" , ipaddr_string ( ndo , obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; offset += 4 ; } break ; case LMP_CTYPE_IPV6 : offset = 0 ; while ( offset + 16 <= obj_tlen ) { ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)" , ip6addr_string ( ndo , obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; offset += 16 ; } break ; case LMP_CTYPE_UNMD : offset = 0 ; while ( offset + 4 <= obj_tlen ) { ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)" , EXTRACT_32BITS ( obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; offset += 4 ; } break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_ERROR_CODE : switch ( lmp_obj_ctype ) { case LMP_CTYPE_BEGIN_VERIFY_ERROR : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Error<S2SV_blank>Code:<S2SV_blank>%s" , bittok2str ( lmp_obj_begin_verify_error_values , "none" , EXTRACT_32BITS ( obj_tptr ) ) ) ) ; break ; case LMP_CTYPE_LINK_SUMMARY_ERROR : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Error<S2SV_blank>Code:<S2SV_blank>%s" , bittok2str ( lmp_obj_link_summary_error_values , "none" , EXTRACT_32BITS ( obj_tptr ) ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_SERVICE_CONFIG : switch ( lmp_obj_ctype ) { case LMP_CTYPE_SERVICE_CONFIG_SP : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank>Flags:<S2SV_blank>%s" , bittok2str ( lmp_obj_service_config_sp_flag_values , "none" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>UNI<S2SV_blank>Version:<S2SV_blank>%u" , EXTRACT_8BITS ( obj_tptr + 1 ) ) ) ; break ; case LMP_CTYPE_SERVICE_CONFIG_CPSA : if ( obj_tlen != 16 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } link_type = EXTRACT_8BITS ( obj_tptr ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank>Link<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u)" , tok2str ( lmp_sd_service_config_cpsa_link_type_values , "Unknown" , link_type ) , link_type ) ) ; switch ( link_type ) { case LMP_SD_SERVICE_CONFIG_CPSA_LINK_TYPE_SDH : ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank>Signal<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u)" , tok2str ( lmp_sd_service_config_cpsa_signal_type_sdh_values , "Unknown" , EXTRACT_8BITS ( obj_tptr + 1 ) ) , EXTRACT_8BITS ( obj_tptr + 1 ) ) ) ; break ; case LMP_SD_SERVICE_CONFIG_CPSA_LINK_TYPE_SONET : ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank>Signal<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u)" , tok2str ( lmp_sd_service_config_cpsa_signal_type_sonet_values , "Unknown" , EXTRACT_8BITS ( obj_tptr + 1 ) ) , EXTRACT_8BITS ( obj_tptr + 1 ) ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank>Transparency:<S2SV_blank>%s" , bittok2str ( lmp_obj_service_config_cpsa_tp_flag_values , "none" , EXTRACT_8BITS ( obj_tptr + 2 ) ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank>Contiguous<S2SV_blank>Concatenation<S2SV_blank>Types:<S2SV_blank>%s" , bittok2str ( lmp_obj_service_config_cpsa_cct_flag_values , "none" , EXTRACT_8BITS ( obj_tptr + 3 ) ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank>Minimum<S2SV_blank>NCC:<S2SV_blank>%u" , EXTRACT_16BITS ( obj_tptr + 4 ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank>Maximum<S2SV_blank>NCC:<S2SV_blank>%u" , EXTRACT_16BITS ( obj_tptr + 6 ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank>Minimum<S2SV_blank>NVC:%u" , EXTRACT_16BITS ( obj_tptr + 8 ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank>Maximum<S2SV_blank>NVC:%u" , EXTRACT_16BITS ( obj_tptr + 10 ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)" , ipaddr_string ( ndo , obj_tptr + 12 ) , EXTRACT_32BITS ( obj_tptr + 12 ) ) ) ; break ; case LMP_CTYPE_SERVICE_CONFIG_TRANSPARENCY_TCM : if ( obj_tlen != 8 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank>Transparency<S2SV_blank>Flags:<S2SV_blank>%s" , bittok2str ( lmp_obj_service_config_nsa_transparency_flag_values , "none" , EXTRACT_32BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank>TCM<S2SV_blank>Monitoring<S2SV_blank>Flags:<S2SV_blank>%s" , bittok2str ( lmp_obj_service_config_nsa_tcm_flag_values , "none" , EXTRACT_8BITS ( obj_tptr + 7 ) ) ) ) ; break ; case LMP_CTYPE_SERVICE_CONFIG_NETWORK_DIVERSITY : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank>Diversity:<S2SV_blank>Flags:<S2SV_blank>%s" , bittok2str ( lmp_obj_service_config_nsa_network_diversity_flag_values , "none" , EXTRACT_8BITS ( obj_tptr + 3 ) ) ) ) ; break ; default : hexdump = TRUE ; } break ; default : if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , obj_tptr , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , obj_tlen ) ; break ; } if ( ndo -> ndo_vflag > 1 || hexdump == TRUE ) print_unknown_data ( ndo , tptr + sizeof ( struct lmp_object_header ) , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , lmp_obj_len - sizeof ( struct lmp_object_header ) ) ; tptr += lmp_obj_len ; tlen -= lmp_obj_len ; } return ; trunc : <S2SV_StartBug> ND_PRINT ( ( ndo , "\\n\\t\\t<S2SV_blank>packet<S2SV_blank>exceeded<S2SV_blank>snapshot" ) ) ; <S2SV_EndBug> }
CWE-20 static int lmp_print_data_link_subobjs ( netdissect_options * ndo , const u_char * obj_tptr , int total_subobj_len , int offset ) { int hexdump = FALSE ; int subobj_type , subobj_len ; union { float f ; uint32_t i ; } bw ; while ( total_subobj_len > 0 && hexdump == FALSE ) { <S2SV_StartBug> subobj_type = EXTRACT_8BITS ( obj_tptr + offset ) ; <S2SV_EndBug> subobj_len = EXTRACT_8BITS ( obj_tptr + offset + 1 ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Subobject,<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>Length:<S2SV_blank>%u" , tok2str ( lmp_data_link_subobj , "Unknown" , subobj_type ) , subobj_type , subobj_len ) ) ; if ( subobj_len < 4 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(too<S2SV_blank>short)" ) ) ; break ; } if ( ( subobj_len % 4 ) != 0 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>a<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>4)" ) ) ; break ; } if ( total_subobj_len < subobj_len ) { ND_PRINT ( ( ndo , "<S2SV_blank>(goes<S2SV_blank>past<S2SV_blank>the<S2SV_blank>end<S2SV_blank>of<S2SV_blank>the<S2SV_blank>object)" ) ) ; break ; } switch ( subobj_type ) { case INT_SWITCHING_TYPE_SUBOBJ : <S2SV_StartBug> ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Switching<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u)" , <S2SV_EndBug> tok2str ( gmpls_switch_cap_values , "Unknown" , EXTRACT_8BITS ( obj_tptr + offset + 2 ) ) , <S2SV_StartBug> EXTRACT_8BITS ( obj_tptr + offset + 2 ) ) ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Encoding<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u)" , tok2str ( gmpls_encoding_values , "Unknown" , EXTRACT_8BITS ( obj_tptr + offset + 3 ) ) , EXTRACT_8BITS ( obj_tptr + offset + 3 ) ) ) ; ND_TCHECK_32BITS ( obj_tptr + offset + 4 ) ; bw . i = EXTRACT_32BITS ( obj_tptr + offset + 4 ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Min<S2SV_blank>Reservable<S2SV_blank>Bandwidth:<S2SV_blank>%.3f<S2SV_blank>Mbps" , bw . f * 8 / 1000000 ) ) ; <S2SV_StartBug> bw . i = EXTRACT_32BITS ( obj_tptr + offset + 8 ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Max<S2SV_blank>Reservable<S2SV_blank>Bandwidth:<S2SV_blank>%.3f<S2SV_blank>Mbps" , bw . f * 8 / 1000000 ) ) ; break ; case WAVELENGTH_SUBOBJ : <S2SV_StartBug> ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Wavelength:<S2SV_blank>%u" , <S2SV_EndBug> EXTRACT_32BITS ( obj_tptr + offset + 4 ) ) ) ; break ; default : hexdump = TRUE ; break ; } total_subobj_len -= subobj_len ; offset += subobj_len ; } return ( hexdump ) ; trunc : return - 1 ; }
CWE-125 static void babel_print_v2 ( netdissect_options * ndo , const u_char * cp , u_int length ) { u_int i ; u_short bodylen ; u_char v4_prefix [ 16 ] = { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0xFF , 0xFF , 0 , 0 , 0 , 0 } ; u_char v6_prefix [ 16 ] = { 0 } ; ND_TCHECK2 ( * cp , 4 ) ; if ( length < 4 ) goto invalid ; bodylen = EXTRACT_16BITS ( cp + 2 ) ; ND_PRINT ( ( ndo , "<S2SV_blank>(%u)" , bodylen ) ) ; i = 0 ; while ( i < bodylen ) { const u_char * message ; u_int type , len ; message = cp + 4 + i ; ND_TCHECK2 ( * message , 1 ) ; if ( ( type = message [ 0 ] ) == MESSAGE_PAD1 ) { ND_PRINT ( ( ndo , ndo -> ndo_vflag ? "\\n\\tPad<S2SV_blank>1" : "<S2SV_blank>pad1" ) ) ; i += 1 ; continue ; } ND_TCHECK2 ( * message , 2 ) ; ICHECK ( i , 2 ) ; len = message [ 1 ] ; ND_TCHECK2 ( * message , 2 + len ) ; ICHECK ( i , 2 + len ) ; switch ( type ) { case MESSAGE_PADN : { if ( ! ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "<S2SV_blank>padN" ) ) ; else ND_PRINT ( ( ndo , "\\n\\tPad<S2SV_blank>%d" , len + 2 ) ) ; } break ; case MESSAGE_ACK_REQ : { u_short nonce , interval ; if ( ! ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "<S2SV_blank>ack-req" ) ) ; else { ND_PRINT ( ( ndo , "\\n\\tAcknowledgment<S2SV_blank>Request<S2SV_blank>" ) ) ; if ( len < 6 ) goto invalid ; nonce = EXTRACT_16BITS ( message + 4 ) ; interval = EXTRACT_16BITS ( message + 6 ) ; ND_PRINT ( ( ndo , "%04x<S2SV_blank>%s" , nonce , format_interval ( interval ) ) ) ; } } break ; case MESSAGE_ACK : { u_short nonce ; if ( ! ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "<S2SV_blank>ack" ) ) ; else { ND_PRINT ( ( ndo , "\\n\\tAcknowledgment<S2SV_blank>" ) ) ; if ( len < 2 ) goto invalid ; nonce = EXTRACT_16BITS ( message + 2 ) ; ND_PRINT ( ( ndo , "%04x" , nonce ) ) ; } } break ; case MESSAGE_HELLO : { u_short seqno , interval ; if ( ! ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "<S2SV_blank>hello" ) ) ; else { ND_PRINT ( ( ndo , "\\n\\tHello<S2SV_blank>" ) ) ; if ( len < 6 ) goto invalid ; seqno = EXTRACT_16BITS ( message + 4 ) ; interval = EXTRACT_16BITS ( message + 6 ) ; ND_PRINT ( ( ndo , "seqno<S2SV_blank>%u<S2SV_blank>interval<S2SV_blank>%s" , seqno , format_interval ( interval ) ) ) ; if ( len > 6 ) subtlvs_print ( ndo , message + 8 , message + 2 + len , type ) ; } } break ; case MESSAGE_IHU : { unsigned short txcost , interval ; if ( ! ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "<S2SV_blank>ihu" ) ) ; else { u_char address [ 16 ] ; int rc ; ND_PRINT ( ( ndo , "\\n\\tIHU<S2SV_blank>" ) ) ; if ( len < 6 ) goto invalid ; txcost = EXTRACT_16BITS ( message + 4 ) ; interval = EXTRACT_16BITS ( message + 6 ) ; rc = network_address ( message [ 2 ] , message + 8 , len - 6 , address ) ; if ( rc < 0 ) { ND_PRINT ( ( ndo , "%s" , tstr ) ) ; break ; } ND_PRINT ( ( ndo , "%s<S2SV_blank>txcost<S2SV_blank>%u<S2SV_blank>interval<S2SV_blank>%s" , format_address ( ndo , address ) , txcost , format_interval ( interval ) ) ) ; if ( ( u_int ) rc < len - 6 ) subtlvs_print ( ndo , message + 8 + rc , message + 2 + len , type ) ; } } break ; case MESSAGE_ROUTER_ID : { if ( ! ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "<S2SV_blank>router-id" ) ) ; else { ND_PRINT ( ( ndo , "\\n\\tRouter<S2SV_blank>Id" ) ) ; if ( len < 10 ) goto invalid ; ND_PRINT ( ( ndo , "<S2SV_blank>%s" , format_id ( message + 4 ) ) ) ; } } break ; case MESSAGE_NH : { if ( ! ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "<S2SV_blank>nh" ) ) ; else { int rc ; u_char nh [ 16 ] ; ND_PRINT ( ( ndo , "\\n\\tNext<S2SV_blank>Hop" ) ) ; if ( len < 2 ) goto invalid ; rc = network_address ( message [ 2 ] , message + 4 , len - 2 , nh ) ; if ( rc < 0 ) goto invalid ; ND_PRINT ( ( ndo , "<S2SV_blank>%s" , format_address ( ndo , nh ) ) ) ; } } break ; case MESSAGE_UPDATE : { if ( ! ndo -> ndo_vflag ) { ND_PRINT ( ( ndo , "<S2SV_blank>update" ) ) ; <S2SV_StartBug> if ( len < 1 ) <S2SV_EndBug> ND_PRINT ( ( ndo , "/truncated" ) ) ; else ND_PRINT ( ( ndo , "%s%s%s" , ( message [ 3 ] & 0x80 ) ? "/prefix" : "" , ( message [ 3 ] & 0x40 ) ? "/id" : "" , ( message [ 3 ] & 0x3f ) ? "/unknown" : "" ) ) ; } else { u_short interval , seqno , metric ; u_char plen ; int rc ; u_char prefix [ 16 ] ; ND_PRINT ( ( ndo , "\\n\\tUpdate" ) ) ; if ( len < 10 ) goto invalid ; plen = message [ 4 ] + ( message [ 2 ] == 1 ? 96 : 0 ) ; rc = network_prefix ( message [ 2 ] , message [ 4 ] , message [ 5 ] , message + 12 , message [ 2 ] == 1 ? v4_prefix : v6_prefix , len - 10 , prefix ) ; if ( rc < 0 ) goto invalid ; interval = EXTRACT_16BITS ( message + 6 ) ; seqno = EXTRACT_16BITS ( message + 8 ) ; metric = EXTRACT_16BITS ( message + 10 ) ; ND_PRINT ( ( ndo , "%s%s%s<S2SV_blank>%s<S2SV_blank>metric<S2SV_blank>%u<S2SV_blank>seqno<S2SV_blank>%u<S2SV_blank>interval<S2SV_blank>%s" , ( message [ 3 ] & 0x80 ) ? "/prefix" : "" , ( message [ 3 ] & 0x40 ) ? "/id" : "" , ( message [ 3 ] & 0x3f ) ? "/unknown" : "" , format_prefix ( ndo , prefix , plen ) , metric , seqno , format_interval_update ( interval ) ) ) ; if ( message [ 3 ] & 0x80 ) { if ( message [ 2 ] == 1 ) memcpy ( v4_prefix , prefix , 16 ) ; else memcpy ( v6_prefix , prefix , 16 ) ; } if ( ( u_int ) rc < len - 10 ) subtlvs_print ( ndo , message + 12 + rc , message + 2 + len , type ) ; } } break ; case MESSAGE_REQUEST : { if ( ! ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "<S2SV_blank>request" ) ) ; else { int rc ; u_char prefix [ 16 ] , plen ; ND_PRINT ( ( ndo , "\\n\\tRequest<S2SV_blank>" ) ) ; if ( len < 2 ) goto invalid ; plen = message [ 3 ] + ( message [ 2 ] == 1 ? 96 : 0 ) ; rc = network_prefix ( message [ 2 ] , message [ 3 ] , 0 , message + 4 , NULL , len - 2 , prefix ) ; if ( rc < 0 ) goto invalid ; ND_PRINT ( ( ndo , "for<S2SV_blank>%s" , message [ 2 ] == 0 ? "any" : format_prefix ( ndo , prefix , plen ) ) ) ; } } break ; case MESSAGE_MH_REQUEST : { if ( ! ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "<S2SV_blank>mh-request" ) ) ; else { int rc ; u_short seqno ; u_char prefix [ 16 ] , plen ; ND_PRINT ( ( ndo , "\\n\\tMH-Request<S2SV_blank>" ) ) ; if ( len < 14 ) goto invalid ; seqno = EXTRACT_16BITS ( message + 4 ) ; rc = network_prefix ( message [ 2 ] , message [ 3 ] , 0 , message + 16 , NULL , len - 14 , prefix ) ; if ( rc < 0 ) goto invalid ; plen = message [ 3 ] + ( message [ 2 ] == 1 ? 96 : 0 ) ; ND_PRINT ( ( ndo , "(%u<S2SV_blank>hops)<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>seqno<S2SV_blank>%u<S2SV_blank>id<S2SV_blank>%s" , message [ 6 ] , format_prefix ( ndo , prefix , plen ) , seqno , format_id ( message + 8 ) ) ) ; } } break ; case MESSAGE_TSPC : if ( ! ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "<S2SV_blank>tspc" ) ) ; else { ND_PRINT ( ( ndo , "\\n\\tTS/PC<S2SV_blank>" ) ) ; if ( len < 6 ) goto invalid ; ND_PRINT ( ( ndo , "timestamp<S2SV_blank>%u<S2SV_blank>packetcounter<S2SV_blank>%u" , EXTRACT_32BITS ( message + 4 ) , EXTRACT_16BITS ( message + 2 ) ) ) ; } break ; case MESSAGE_HMAC : { if ( ! ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "<S2SV_blank>hmac" ) ) ; else { unsigned j ; ND_PRINT ( ( ndo , "\\n\\tHMAC<S2SV_blank>" ) ) ; if ( len < 18 ) goto invalid ; ND_PRINT ( ( ndo , "key-id<S2SV_blank>%u<S2SV_blank>digest-%u<S2SV_blank>" , EXTRACT_16BITS ( message + 2 ) , len - 2 ) ) ; for ( j = 0 ; j < len - 2 ; j ++ ) ND_PRINT ( ( ndo , "%02X" , message [ 4 + j ] ) ) ; } } break ; case MESSAGE_UPDATE_SRC_SPECIFIC : { if ( ! ndo -> ndo_vflag ) { ND_PRINT ( ( ndo , "<S2SV_blank>ss-update" ) ) ; } else { u_char prefix [ 16 ] , src_prefix [ 16 ] ; u_short interval , seqno , metric ; u_char ae , plen , src_plen , omitted ; int rc ; int parsed_len = 10 ; ND_PRINT ( ( ndo , "\\n\\tSS-Update" ) ) ; if ( len < 10 ) goto invalid ; ae = message [ 2 ] ; src_plen = message [ 3 ] ; plen = message [ 4 ] ; omitted = message [ 5 ] ; interval = EXTRACT_16BITS ( message + 6 ) ; seqno = EXTRACT_16BITS ( message + 8 ) ; metric = EXTRACT_16BITS ( message + 10 ) ; rc = network_prefix ( ae , plen , omitted , message + 2 + parsed_len , ae == 1 ? v4_prefix : v6_prefix , len - parsed_len , prefix ) ; if ( rc < 0 ) goto invalid ; if ( ae == 1 ) plen += 96 ; parsed_len += rc ; rc = network_prefix ( ae , src_plen , 0 , message + 2 + parsed_len , NULL , len - parsed_len , src_prefix ) ; if ( rc < 0 ) goto invalid ; if ( ae == 1 ) src_plen += 96 ; parsed_len += rc ; ND_PRINT ( ( ndo , "<S2SV_blank>%s<S2SV_blank>from" , format_prefix ( ndo , prefix , plen ) ) ) ; ND_PRINT ( ( ndo , "<S2SV_blank>%s<S2SV_blank>metric<S2SV_blank>%u<S2SV_blank>seqno<S2SV_blank>%u<S2SV_blank>interval<S2SV_blank>%s" , format_prefix ( ndo , src_prefix , src_plen ) , metric , seqno , format_interval_update ( interval ) ) ) ; if ( ( u_int ) parsed_len < len ) subtlvs_print ( ndo , message + 2 + parsed_len , message + 2 + len , type ) ; } } break ; case MESSAGE_REQUEST_SRC_SPECIFIC : { if ( ! ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "<S2SV_blank>ss-request" ) ) ; else { int rc , parsed_len = 3 ; u_char ae , plen , src_plen , prefix [ 16 ] , src_prefix [ 16 ] ; ND_PRINT ( ( ndo , "\\n\\tSS-Request<S2SV_blank>" ) ) ; if ( len < 3 ) goto invalid ; ae = message [ 2 ] ; plen = message [ 3 ] ; src_plen = message [ 4 ] ; rc = network_prefix ( ae , plen , 0 , message + 2 + parsed_len , NULL , len - parsed_len , prefix ) ; if ( rc < 0 ) goto invalid ; if ( ae == 1 ) plen += 96 ; parsed_len += rc ; rc = network_prefix ( ae , src_plen , 0 , message + 2 + parsed_len , NULL , len - parsed_len , src_prefix ) ; if ( rc < 0 ) goto invalid ; if ( ae == 1 ) src_plen += 96 ; parsed_len += rc ; if ( ae == 0 ) { ND_PRINT ( ( ndo , "for<S2SV_blank>any" ) ) ; } else { ND_PRINT ( ( ndo , "for<S2SV_blank>(%s,<S2SV_blank>" , format_prefix ( ndo , prefix , plen ) ) ) ; ND_PRINT ( ( ndo , "%s)" , format_prefix ( ndo , src_prefix , src_plen ) ) ) ; } } } break ; case MESSAGE_MH_REQUEST_SRC_SPECIFIC : { if ( ! ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "<S2SV_blank>ss-mh-request" ) ) ; else { int rc , parsed_len = 14 ; u_short seqno ; u_char ae , plen , src_plen , prefix [ 16 ] , src_prefix [ 16 ] , hopc ; const u_char * router_id = NULL ; ND_PRINT ( ( ndo , "\\n\\tSS-MH-Request<S2SV_blank>" ) ) ; if ( len < 14 ) goto invalid ; ae = message [ 2 ] ; plen = message [ 3 ] ; seqno = EXTRACT_16BITS ( message + 4 ) ; hopc = message [ 6 ] ; src_plen = message [ 7 ] ; router_id = message + 8 ; rc = network_prefix ( ae , plen , 0 , message + 2 + parsed_len , NULL , len - parsed_len , prefix ) ; if ( rc < 0 ) goto invalid ; if ( ae == 1 ) plen += 96 ; parsed_len += rc ; rc = network_prefix ( ae , src_plen , 0 , message + 2 + parsed_len , NULL , len - parsed_len , src_prefix ) ; if ( rc < 0 ) goto invalid ; if ( ae == 1 ) src_plen += 96 ; ND_PRINT ( ( ndo , "(%u<S2SV_blank>hops)<S2SV_blank>for<S2SV_blank>(%s,<S2SV_blank>" , hopc , format_prefix ( ndo , prefix , plen ) ) ) ; ND_PRINT ( ( ndo , "%s)<S2SV_blank>seqno<S2SV_blank>%u<S2SV_blank>id<S2SV_blank>%s" , format_prefix ( ndo , src_prefix , src_plen ) , seqno , format_id ( router_id ) ) ) ; } } break ; default : if ( ! ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "<S2SV_blank>unknown" ) ) ; else ND_PRINT ( ( ndo , "\\n\\tUnknown<S2SV_blank>message<S2SV_blank>type<S2SV_blank>%d" , type ) ) ; } i += len + 2 ; } return ; trunc : ND_PRINT ( ( ndo , "<S2SV_blank>%s" , tstr ) ) ; return ; invalid : ND_PRINT ( ( ndo , "%s" , istr ) ) ; return ; }
CWE-125 static int bgp_attr_print ( netdissect_options * ndo , u_int atype , const u_char * pptr , u_int len ) { int i ; uint16_t af ; uint8_t safi , snpa , nhlen ; union { float f ; uint32_t i ; } bw ; int advance ; u_int tlen ; const u_char * tptr ; char buf [ MAXHOSTNAMELEN + 100 ] ; int as_size ; tptr = pptr ; tlen = len ; switch ( atype ) { case BGPTYPE_ORIGIN : if ( len != 1 ) ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; else { ND_TCHECK ( * tptr ) ; ND_PRINT ( ( ndo , "%s" , tok2str ( bgp_origin_values , "Unknown<S2SV_blank>Origin<S2SV_blank>Typecode" , tptr [ 0 ] ) ) ) ; } break ; case BGPTYPE_AS4_PATH : case BGPTYPE_AS_PATH : if ( len % 2 ) { ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; break ; } if ( ! len ) { ND_PRINT ( ( ndo , "empty" ) ) ; break ; } as_size = bgp_attr_get_as_size ( ndo , atype , pptr , len ) ; while ( tptr < pptr + len ) { ND_TCHECK ( tptr [ 0 ] ) ; ND_PRINT ( ( ndo , "%s" , tok2str ( bgp_as_path_segment_open_values , "?" , tptr [ 0 ] ) ) ) ; ND_TCHECK ( tptr [ 1 ] ) ; for ( i = 0 ; i < tptr [ 1 ] * as_size ; i += as_size ) { ND_TCHECK2 ( tptr [ 2 + i ] , as_size ) ; ND_PRINT ( ( ndo , "%s<S2SV_blank>" , as_printf ( ndo , astostr , sizeof ( astostr ) , as_size == 2 ? EXTRACT_16BITS ( & tptr [ 2 + i ] ) : EXTRACT_32BITS ( & tptr [ 2 + i ] ) ) ) ) ; } ND_TCHECK ( tptr [ 0 ] ) ; ND_PRINT ( ( ndo , "%s" , tok2str ( bgp_as_path_segment_close_values , "?" , tptr [ 0 ] ) ) ) ; ND_TCHECK ( tptr [ 1 ] ) ; tptr += 2 + tptr [ 1 ] * as_size ; } break ; case BGPTYPE_NEXT_HOP : if ( len != 4 ) ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; else { ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , "%s" , ipaddr_string ( ndo , tptr ) ) ) ; } break ; case BGPTYPE_MULTI_EXIT_DISC : case BGPTYPE_LOCAL_PREF : if ( len != 4 ) ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; else { ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , "%u" , EXTRACT_32BITS ( tptr ) ) ) ; } break ; case BGPTYPE_ATOMIC_AGGREGATE : if ( len != 0 ) ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; break ; case BGPTYPE_AGGREGATOR : if ( len != 6 && len != 8 ) { ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; break ; } ND_TCHECK2 ( tptr [ 0 ] , len ) ; if ( len == 6 ) { ND_PRINT ( ( ndo , "<S2SV_blank>AS<S2SV_blank>#%s,<S2SV_blank>origin<S2SV_blank>%s" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_16BITS ( tptr ) ) , ipaddr_string ( ndo , tptr + 2 ) ) ) ; } else { ND_PRINT ( ( ndo , "<S2SV_blank>AS<S2SV_blank>#%s,<S2SV_blank>origin<S2SV_blank>%s" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr ) ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; } break ; case BGPTYPE_AGGREGATOR4 : if ( len != 8 ) { ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; break ; } ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , "<S2SV_blank>AS<S2SV_blank>#%s,<S2SV_blank>origin<S2SV_blank>%s" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr ) ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; break ; case BGPTYPE_COMMUNITIES : if ( len % 4 ) { ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; break ; } while ( tlen > 0 ) { uint32_t comm ; ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; comm = EXTRACT_32BITS ( tptr ) ; switch ( comm ) { case BGP_COMMUNITY_NO_EXPORT : ND_PRINT ( ( ndo , "<S2SV_blank>NO_EXPORT" ) ) ; break ; case BGP_COMMUNITY_NO_ADVERT : ND_PRINT ( ( ndo , "<S2SV_blank>NO_ADVERTISE" ) ) ; break ; case BGP_COMMUNITY_NO_EXPORT_SUBCONFED : ND_PRINT ( ( ndo , "<S2SV_blank>NO_EXPORT_SUBCONFED" ) ) ; break ; default : ND_PRINT ( ( ndo , "%u:%u%s" , ( comm >> 16 ) & 0xffff , comm & 0xffff , ( tlen > 4 ) ? ",<S2SV_blank>" : "" ) ) ; break ; } tlen -= 4 ; tptr += 4 ; } break ; case BGPTYPE_ORIGINATOR_ID : if ( len != 4 ) { ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; break ; } ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , "%s" , ipaddr_string ( ndo , tptr ) ) ) ; break ; case BGPTYPE_CLUSTER_LIST : if ( len % 4 ) { ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; break ; } while ( tlen > 0 ) { ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , "%s%s" , ipaddr_string ( ndo , tptr ) , ( tlen > 4 ) ? ",<S2SV_blank>" : "" ) ) ; tlen -= 4 ; tptr += 4 ; } break ; case BGPTYPE_MP_REACH_NLRI : ND_TCHECK2 ( tptr [ 0 ] , 3 ) ; af = EXTRACT_16BITS ( tptr ) ; safi = tptr [ 2 ] ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>AFI:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>%sSAFI:<S2SV_blank>%s<S2SV_blank>(%u)" , tok2str ( af_values , "Unknown<S2SV_blank>AFI" , af ) , af , ( safi > 128 ) ? "vendor<S2SV_blank>specific<S2SV_blank>" : "" , tok2str ( bgp_safi_values , "Unknown<S2SV_blank>SAFI" , safi ) , safi ) ) ; switch ( af << 8 | safi ) { case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_RT_ROUTING_INFO ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET << 8 | SAFNUM_MDT ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : break ; default : ND_TCHECK2 ( tptr [ 0 ] , tlen ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>no<S2SV_blank>AFI<S2SV_blank>%u<S2SV_blank>/<S2SV_blank>SAFI<S2SV_blank>%u<S2SV_blank>decoder" , af , safi ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , tlen ) ; goto done ; break ; } tptr += 3 ; ND_TCHECK ( tptr [ 0 ] ) ; nhlen = tptr [ 0 ] ; tlen = nhlen ; tptr ++ ; if ( tlen ) { int nnh = 0 ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>nexthop:<S2SV_blank>" ) ) ; while ( tlen > 0 ) { if ( nnh ++ > 0 ) { ND_PRINT ( ( ndo , ",<S2SV_blank>" ) ) ; } switch ( af << 8 | safi ) { case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_RT_ROUTING_INFO ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET << 8 | SAFNUM_MDT ) : if ( tlen < ( int ) sizeof ( struct in_addr ) ) { ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in_addr ) ) ; ND_PRINT ( ( ndo , "%s" , ipaddr_string ( ndo , tptr ) ) ) ; tlen -= sizeof ( struct in_addr ) ; tptr += sizeof ( struct in_addr ) ; } break ; case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < ( int ) ( sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ) { ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ; ND_PRINT ( ( ndo , "RD:<S2SV_blank>%s,<S2SV_blank>%s" , bgp_vpn_rd_print ( ndo , tptr ) , ipaddr_string ( ndo , tptr + BGP_VPN_RD_LEN ) ) ) ; tlen -= ( sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ; tptr += ( sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ; } break ; case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : if ( tlen < ( int ) sizeof ( struct in6_addr ) ) { ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in6_addr ) ) ; ND_PRINT ( ( ndo , "%s" , ip6addr_string ( ndo , tptr ) ) ) ; tlen -= sizeof ( struct in6_addr ) ; tptr += sizeof ( struct in6_addr ) ; } break ; case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < ( int ) ( sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ) { ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ; ND_PRINT ( ( ndo , "RD:<S2SV_blank>%s,<S2SV_blank>%s" , bgp_vpn_rd_print ( ndo , tptr ) , ip6addr_string ( ndo , tptr + BGP_VPN_RD_LEN ) ) ) ; tlen -= ( sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ; tptr += ( sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ; } break ; case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < ( int ) sizeof ( struct in_addr ) ) { ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in_addr ) ) ; ND_PRINT ( ( ndo , "%s" , ipaddr_string ( ndo , tptr ) ) ) ; tlen -= ( sizeof ( struct in_addr ) ) ; tptr += ( sizeof ( struct in_addr ) ) ; } break ; case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : ND_TCHECK2 ( tptr [ 0 ] , tlen ) ; ND_PRINT ( ( ndo , "%s" , isonsap_string ( ndo , tptr , tlen ) ) ) ; tptr += tlen ; tlen = 0 ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < BGP_VPN_RD_LEN + 1 ) { ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , tlen ) ; ND_PRINT ( ( ndo , "RD:<S2SV_blank>%s,<S2SV_blank>%s" , bgp_vpn_rd_print ( ndo , tptr ) , isonsap_string ( ndo , tptr + BGP_VPN_RD_LEN , tlen - BGP_VPN_RD_LEN ) ) ) ; <S2SV_StartBug> if ( EXTRACT_32BITS ( tptr + BGP_VPN_RD_LEN ) == 0x47000601 ) <S2SV_EndBug> ND_PRINT ( ( ndo , "<S2SV_blank>=<S2SV_blank>%s" , ipaddr_string ( ndo , tptr + BGP_VPN_RD_LEN + 4 ) ) ) ; <S2SV_StartBug> else if ( EXTRACT_24BITS ( tptr + BGP_VPN_RD_LEN ) == 0x350000 ) <S2SV_EndBug> ND_PRINT ( ( ndo , "<S2SV_blank>=<S2SV_blank>%s" , ip6addr_string ( ndo , tptr + BGP_VPN_RD_LEN + 3 ) ) ) ; tptr += tlen ; tlen = 0 ; } break ; default : ND_TCHECK2 ( tptr [ 0 ] , tlen ) ; ND_PRINT ( ( ndo , "no<S2SV_blank>AFI<S2SV_blank>%u/SAFI<S2SV_blank>%u<S2SV_blank>decoder" , af , safi ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , tlen ) ; tptr += tlen ; tlen = 0 ; goto done ; break ; } } } ND_PRINT ( ( ndo , ",<S2SV_blank>nh-length:<S2SV_blank>%u" , nhlen ) ) ; tptr += tlen ; ND_TCHECK ( tptr [ 0 ] ) ; snpa = tptr [ 0 ] ; tptr ++ ; if ( snpa ) { ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%u<S2SV_blank>SNPA" , snpa ) ) ; for ( ; snpa > 0 ; snpa -- ) { ND_TCHECK ( tptr [ 0 ] ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%d<S2SV_blank>bytes" , tptr [ 0 ] ) ) ; tptr += tptr [ 0 ] + 1 ; } } else { ND_PRINT ( ( ndo , ",<S2SV_blank>no<S2SV_blank>SNPA" ) ) ; } while ( tptr < pptr + len ) { switch ( af << 8 | safi ) { case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix4 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_RT_ROUTING_INFO ) : advance = decode_rt_routing_info ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST_VPN ) : advance = decode_multicast_vpn ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_MDT ) : advance = decode_mdt_vpn_nlri ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix6 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_l2 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; default : ND_TCHECK2 ( * tptr , tlen ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>no<S2SV_blank>AFI<S2SV_blank>%u<S2SV_blank>/<S2SV_blank>SAFI<S2SV_blank>%u<S2SV_blank>decoder" , af , safi ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , tlen ) ; advance = 0 ; tptr = pptr + len ; break ; } if ( advance < 0 ) break ; tptr += advance ; } done : break ; case BGPTYPE_MP_UNREACH_NLRI : ND_TCHECK2 ( tptr [ 0 ] , BGP_MP_NLRI_MINSIZE ) ; af = EXTRACT_16BITS ( tptr ) ; safi = tptr [ 2 ] ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>AFI:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>%sSAFI:<S2SV_blank>%s<S2SV_blank>(%u)" , tok2str ( af_values , "Unknown<S2SV_blank>AFI" , af ) , af , ( safi > 128 ) ? "vendor<S2SV_blank>specific<S2SV_blank>" : "" , tok2str ( bgp_safi_values , "Unknown<S2SV_blank>SAFI" , safi ) , safi ) ) ; if ( len == BGP_MP_NLRI_MINSIZE ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>End-of-Rib<S2SV_blank>Marker<S2SV_blank>(empty<S2SV_blank>NLRI)" ) ) ; tptr += 3 ; while ( tptr < pptr + len ) { switch ( af << 8 | safi ) { case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix4 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix6 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_l2 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_MDT ) : advance = decode_mdt_vpn_nlri ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST_VPN ) : advance = decode_multicast_vpn ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; default : ND_TCHECK2 ( * ( tptr - 3 ) , tlen ) ; ND_PRINT ( ( ndo , "no<S2SV_blank>AFI<S2SV_blank>%u<S2SV_blank>/<S2SV_blank>SAFI<S2SV_blank>%u<S2SV_blank>decoder" , af , safi ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr - 3 , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , tlen ) ; advance = 0 ; tptr = pptr + len ; break ; } if ( advance < 0 ) break ; tptr += advance ; } break ; case BGPTYPE_EXTD_COMMUNITIES : if ( len % 8 ) { ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; break ; } while ( tlen > 0 ) { uint16_t extd_comm ; ND_TCHECK2 ( tptr [ 0 ] , 2 ) ; extd_comm = EXTRACT_16BITS ( tptr ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>(0x%04x),<S2SV_blank>Flags<S2SV_blank>[%s]" , tok2str ( bgp_extd_comm_subtype_values , "unknown<S2SV_blank>extd<S2SV_blank>community<S2SV_blank>typecode" , extd_comm ) , extd_comm , bittok2str ( bgp_extd_comm_flag_values , "none" , extd_comm ) ) ) ; ND_TCHECK2 ( * ( tptr + 2 ) , 6 ) ; switch ( extd_comm ) { case BGP_EXT_COM_RT_0 : case BGP_EXT_COM_RO_0 : case BGP_EXT_COM_L2VPN_RT_0 : ND_PRINT ( ( ndo , ":<S2SV_blank>%u:%u<S2SV_blank>(=<S2SV_blank>%s)" , EXTRACT_16BITS ( tptr + 2 ) , EXTRACT_32BITS ( tptr + 4 ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; break ; case BGP_EXT_COM_RT_1 : case BGP_EXT_COM_RO_1 : case BGP_EXT_COM_L2VPN_RT_1 : case BGP_EXT_COM_VRF_RT_IMP : ND_PRINT ( ( ndo , ":<S2SV_blank>%s:%u" , ipaddr_string ( ndo , tptr + 2 ) , EXTRACT_16BITS ( tptr + 6 ) ) ) ; break ; case BGP_EXT_COM_RT_2 : case BGP_EXT_COM_RO_2 : ND_PRINT ( ( ndo , ":<S2SV_blank>%s:%u" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr + 2 ) ) , EXTRACT_16BITS ( tptr + 6 ) ) ) ; break ; case BGP_EXT_COM_LINKBAND : bw . i = EXTRACT_32BITS ( tptr + 2 ) ; ND_PRINT ( ( ndo , ":<S2SV_blank>bandwidth:<S2SV_blank>%.3f<S2SV_blank>Mbps" , bw . f * 8 / 1000000 ) ) ; break ; case BGP_EXT_COM_VPN_ORIGIN : case BGP_EXT_COM_VPN_ORIGIN2 : case BGP_EXT_COM_VPN_ORIGIN3 : case BGP_EXT_COM_VPN_ORIGIN4 : case BGP_EXT_COM_OSPF_RID : case BGP_EXT_COM_OSPF_RID2 : ND_PRINT ( ( ndo , "%s" , ipaddr_string ( ndo , tptr + 2 ) ) ) ; break ; case BGP_EXT_COM_OSPF_RTYPE : case BGP_EXT_COM_OSPF_RTYPE2 : ND_PRINT ( ( ndo , ":<S2SV_blank>area:%s,<S2SV_blank>router-type:%s,<S2SV_blank>metric-type:%s%s" , ipaddr_string ( ndo , tptr + 2 ) , tok2str ( bgp_extd_comm_ospf_rtype_values , "unknown<S2SV_blank>(0x%02x)" , * ( tptr + 6 ) ) , ( * ( tptr + 7 ) & BGP_OSPF_RTYPE_METRIC_TYPE ) ? "E2" : "" , ( ( * ( tptr + 6 ) == BGP_OSPF_RTYPE_EXT ) || ( * ( tptr + 6 ) == BGP_OSPF_RTYPE_NSSA ) ) ? "E1" : "" ) ) ; break ; case BGP_EXT_COM_L2INFO : ND_PRINT ( ( ndo , ":<S2SV_blank>%s<S2SV_blank>Control<S2SV_blank>Flags<S2SV_blank>[0x%02x]:MTU<S2SV_blank>%u" , tok2str ( l2vpn_encaps_values , "unknown<S2SV_blank>encaps" , * ( tptr + 2 ) ) , * ( tptr + 3 ) , EXTRACT_16BITS ( tptr + 4 ) ) ) ; break ; case BGP_EXT_COM_SOURCE_AS : ND_PRINT ( ( ndo , ":<S2SV_blank>AS<S2SV_blank>%u" , EXTRACT_16BITS ( tptr + 2 ) ) ) ; break ; default : ND_TCHECK2 ( * tptr , 8 ) ; print_unknown_data ( ndo , tptr , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , 8 ) ; break ; } tlen -= 8 ; tptr += 8 ; } break ; case BGPTYPE_PMSI_TUNNEL : { uint8_t tunnel_type , flags ; ND_TCHECK2 ( tptr [ 0 ] , 5 ) ; tunnel_type = * ( tptr + 1 ) ; flags = * tptr ; tlen = len ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Tunnel-type<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>Flags<S2SV_blank>[%s],<S2SV_blank>MPLS<S2SV_blank>Label<S2SV_blank>%u" , tok2str ( bgp_pmsi_tunnel_values , "Unknown" , tunnel_type ) , tunnel_type , bittok2str ( bgp_pmsi_flag_values , "none" , flags ) , EXTRACT_24BITS ( tptr + 2 ) >> 4 ) ) ; tptr += 5 ; tlen -= 5 ; switch ( tunnel_type ) { case BGP_PMSI_TUNNEL_PIM_SM : case BGP_PMSI_TUNNEL_PIM_BIDIR : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Sender<S2SV_blank>%s,<S2SV_blank>P-Group<S2SV_blank>%s" , ipaddr_string ( ndo , tptr ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; break ; case BGP_PMSI_TUNNEL_PIM_SSM : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Root-Node<S2SV_blank>%s,<S2SV_blank>P-Group<S2SV_blank>%s" , ipaddr_string ( ndo , tptr ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; break ; case BGP_PMSI_TUNNEL_INGRESS : ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Tunnel-Endpoint<S2SV_blank>%s" , ipaddr_string ( ndo , tptr ) ) ) ; break ; case BGP_PMSI_TUNNEL_LDP_P2MP : case BGP_PMSI_TUNNEL_LDP_MP2MP : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Root-Node<S2SV_blank>%s,<S2SV_blank>LSP-ID<S2SV_blank>0x%08x" , ipaddr_string ( ndo , tptr ) , EXTRACT_32BITS ( tptr + 4 ) ) ) ; break ; case BGP_PMSI_TUNNEL_RSVP_P2MP : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Extended-Tunnel-ID<S2SV_blank>%s,<S2SV_blank>P2MP-ID<S2SV_blank>0x%08x" , ipaddr_string ( ndo , tptr ) , EXTRACT_32BITS ( tptr + 4 ) ) ) ; break ; default : if ( ndo -> ndo_vflag <= 1 ) { print_unknown_data ( ndo , tptr , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , tlen ) ; } } break ; } case BGPTYPE_AIGP : { uint8_t type ; uint16_t length ; tlen = len ; while ( tlen >= 3 ) { ND_TCHECK2 ( tptr [ 0 ] , 3 ) ; type = * tptr ; length = EXTRACT_16BITS ( tptr + 1 ) ; tptr += 3 ; tlen -= 3 ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>TLV<S2SV_blank>(%u),<S2SV_blank>length<S2SV_blank>%u" , tok2str ( bgp_aigp_values , "Unknown" , type ) , type , length ) ) ; if ( length < 3 ) goto trunc ; length -= 3 ; ND_TCHECK2 ( tptr [ 3 ] , length ) ; switch ( type ) { case BGP_AIGP_TLV : if ( length < 8 ) goto trunc ; ND_PRINT ( ( ndo , ",<S2SV_blank>metric<S2SV_blank>%" PRIu64 , EXTRACT_64BITS ( tptr ) ) ) ; break ; default : if ( ndo -> ndo_vflag <= 1 ) { print_unknown_data ( ndo , tptr , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , length ) ; } } tptr += length ; tlen -= length ; } break ; } case BGPTYPE_ATTR_SET : ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; if ( len < 4 ) goto trunc ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Origin<S2SV_blank>AS:<S2SV_blank>%s" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr ) ) ) ) ; tptr += 4 ; len -= 4 ; while ( len ) { u_int aflags , alenlen , alen ; ND_TCHECK2 ( tptr [ 0 ] , 2 ) ; if ( len < 2 ) goto trunc ; aflags = * tptr ; atype = * ( tptr + 1 ) ; tptr += 2 ; len -= 2 ; alenlen = bgp_attr_lenlen ( aflags , tptr ) ; ND_TCHECK2 ( tptr [ 0 ] , alenlen ) ; if ( len < alenlen ) goto trunc ; alen = bgp_attr_len ( aflags , tptr ) ; tptr += alenlen ; len -= alenlen ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>length:<S2SV_blank>%u" , tok2str ( bgp_attr_values , "Unknown<S2SV_blank>Attribute" , atype ) , atype , alen ) ) ; if ( aflags ) { ND_PRINT ( ( ndo , ",<S2SV_blank>Flags<S2SV_blank>[%s%s%s%s" , aflags & 0x80 ? "O" : "" , aflags & 0x40 ? "T" : "" , aflags & 0x20 ? "P" : "" , aflags & 0x10 ? "E" : "" ) ) ; if ( aflags & 0xf ) ND_PRINT ( ( ndo , "+%x" , aflags & 0xf ) ) ; ND_PRINT ( ( ndo , "]:<S2SV_blank>" ) ) ; } if ( ! bgp_attr_print ( ndo , atype , tptr , alen ) ) return 0 ; tptr += alen ; len -= alen ; } break ; case BGPTYPE_LARGE_COMMUNITY : if ( len == 0 || len % 12 ) { ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" ) ) ; while ( len > 0 ) { ND_TCHECK2 ( * tptr , 12 ) ; ND_PRINT ( ( ndo , "%u:%u:%u%s" , EXTRACT_32BITS ( tptr ) , EXTRACT_32BITS ( tptr + 4 ) , EXTRACT_32BITS ( tptr + 8 ) , ( len > 12 ) ? ",<S2SV_blank>" : "" ) ) ; tptr += 12 ; len -= 12 ; } break ; default : ND_TCHECK2 ( * pptr , len ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>no<S2SV_blank>Attribute<S2SV_blank>%u<S2SV_blank>decoder" , atype ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , pptr , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , len ) ; break ; } if ( ndo -> ndo_vflag > 1 && len ) { ND_TCHECK2 ( * pptr , len ) ; print_unknown_data ( ndo , pptr , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , len ) ; } return 1 ; trunc : return 0 ; }
CWE-125 void icmp_print ( netdissect_options * ndo , const u_char * bp , u_int plen , const u_char * bp2 , int fragmented ) { char * cp ; const struct icmp * dp ; const struct icmp_ext_t * ext_dp ; const struct ip * ip ; const char * str , * fmt ; const struct ip * oip ; const struct udphdr * ouh ; const uint8_t * obj_tptr ; uint32_t raw_label ; const u_char * snapend_save ; const struct icmp_mpls_ext_object_header_t * icmp_mpls_ext_object_header ; u_int hlen , dport , mtu , obj_tlen , obj_class_num , obj_ctype ; char buf [ MAXHOSTNAMELEN + 100 ] ; struct cksum_vec vec [ 1 ] ; dp = ( const struct icmp * ) bp ; ext_dp = ( const struct icmp_ext_t * ) bp ; ip = ( const struct ip * ) bp2 ; str = buf ; ND_TCHECK ( dp -> icmp_code ) ; switch ( dp -> icmp_type ) { case ICMP_ECHO : case ICMP_ECHOREPLY : ND_TCHECK ( dp -> icmp_seq ) ; ( void ) snprintf ( buf , sizeof ( buf ) , "echo<S2SV_blank>%s,<S2SV_blank>id<S2SV_blank>%u,<S2SV_blank>seq<S2SV_blank>%u" , dp -> icmp_type == ICMP_ECHO ? "request" : "reply" , EXTRACT_16BITS ( & dp -> icmp_id ) , EXTRACT_16BITS ( & dp -> icmp_seq ) ) ; break ; case ICMP_UNREACH : ND_TCHECK ( dp -> icmp_ip . ip_dst ) ; switch ( dp -> icmp_code ) { case ICMP_UNREACH_PROTOCOL : ND_TCHECK ( dp -> icmp_ip . ip_p ) ; ( void ) snprintf ( buf , sizeof ( buf ) , "%s<S2SV_blank>protocol<S2SV_blank>%d<S2SV_blank>unreachable" , ipaddr_string ( ndo , & dp -> icmp_ip . ip_dst ) , dp -> icmp_ip . ip_p ) ; break ; case ICMP_UNREACH_PORT : ND_TCHECK ( dp -> icmp_ip . ip_p ) ; oip = & dp -> icmp_ip ; hlen = IP_HL ( oip ) * 4 ; ouh = ( const struct udphdr * ) ( ( ( const u_char * ) oip ) + hlen ) ; ND_TCHECK ( ouh -> uh_dport ) ; dport = EXTRACT_16BITS ( & ouh -> uh_dport ) ; switch ( oip -> ip_p ) { case IPPROTO_TCP : ( void ) snprintf ( buf , sizeof ( buf ) , "%s<S2SV_blank>tcp<S2SV_blank>port<S2SV_blank>%s<S2SV_blank>unreachable" , ipaddr_string ( ndo , & oip -> ip_dst ) , tcpport_string ( ndo , dport ) ) ; break ; case IPPROTO_UDP : ( void ) snprintf ( buf , sizeof ( buf ) , "%s<S2SV_blank>udp<S2SV_blank>port<S2SV_blank>%s<S2SV_blank>unreachable" , ipaddr_string ( ndo , & oip -> ip_dst ) , udpport_string ( ndo , dport ) ) ; break ; default : ( void ) snprintf ( buf , sizeof ( buf ) , "%s<S2SV_blank>protocol<S2SV_blank>%u<S2SV_blank>port<S2SV_blank>%u<S2SV_blank>unreachable" , ipaddr_string ( ndo , & oip -> ip_dst ) , oip -> ip_p , dport ) ; break ; } break ; case ICMP_UNREACH_NEEDFRAG : { register const struct mtu_discovery * mp ; mp = ( const struct mtu_discovery * ) ( const u_char * ) & dp -> icmp_void ; mtu = EXTRACT_16BITS ( & mp -> nexthopmtu ) ; if ( mtu ) { ( void ) snprintf ( buf , sizeof ( buf ) , "%s<S2SV_blank>unreachable<S2SV_blank>-<S2SV_blank>need<S2SV_blank>to<S2SV_blank>frag<S2SV_blank>(mtu<S2SV_blank>%d)" , ipaddr_string ( ndo , & dp -> icmp_ip . ip_dst ) , mtu ) ; } else { ( void ) snprintf ( buf , sizeof ( buf ) , "%s<S2SV_blank>unreachable<S2SV_blank>-<S2SV_blank>need<S2SV_blank>to<S2SV_blank>frag" , ipaddr_string ( ndo , & dp -> icmp_ip . ip_dst ) ) ; } } break ; default : fmt = tok2str ( unreach2str , "#%d<S2SV_blank>%%s<S2SV_blank>unreachable" , dp -> icmp_code ) ; ( void ) snprintf ( buf , sizeof ( buf ) , fmt , ipaddr_string ( ndo , & dp -> icmp_ip . ip_dst ) ) ; break ; } break ; case ICMP_REDIRECT : ND_TCHECK ( dp -> icmp_ip . ip_dst ) ; fmt = tok2str ( type2str , "redirect-#%d<S2SV_blank>%%s<S2SV_blank>to<S2SV_blank>net<S2SV_blank>%%s" , dp -> icmp_code ) ; ( void ) snprintf ( buf , sizeof ( buf ) , fmt , ipaddr_string ( ndo , & dp -> icmp_ip . ip_dst ) , ipaddr_string ( ndo , & dp -> icmp_gwaddr ) ) ; break ; case ICMP_ROUTERADVERT : { register const struct ih_rdiscovery * ihp ; register const struct id_rdiscovery * idp ; u_int lifetime , num , size ; ( void ) snprintf ( buf , sizeof ( buf ) , "router<S2SV_blank>advertisement" ) ; cp = buf + strlen ( buf ) ; ihp = ( const struct ih_rdiscovery * ) & dp -> icmp_void ; ND_TCHECK ( * ihp ) ; ( void ) strncpy ( cp , "<S2SV_blank>lifetime<S2SV_blank>" , sizeof ( buf ) - ( cp - buf ) ) ; cp = buf + strlen ( buf ) ; lifetime = EXTRACT_16BITS ( & ihp -> ird_lifetime ) ; if ( lifetime < 60 ) { ( void ) snprintf ( cp , sizeof ( buf ) - ( cp - buf ) , "%u" , lifetime ) ; } else if ( lifetime < 60 * 60 ) { ( void ) snprintf ( cp , sizeof ( buf ) - ( cp - buf ) , "%u:%02u" , lifetime / 60 , lifetime % 60 ) ; } else { ( void ) snprintf ( cp , sizeof ( buf ) - ( cp - buf ) , "%u:%02u:%02u" , lifetime / 3600 , ( lifetime % 3600 ) / 60 , lifetime % 60 ) ; } cp = buf + strlen ( buf ) ; num = ihp -> ird_addrnum ; ( void ) snprintf ( cp , sizeof ( buf ) - ( cp - buf ) , "<S2SV_blank>%d:" , num ) ; cp = buf + strlen ( buf ) ; size = ihp -> ird_addrsiz ; if ( size != 2 ) { ( void ) snprintf ( cp , sizeof ( buf ) - ( cp - buf ) , "<S2SV_blank>[size<S2SV_blank>%d]" , size ) ; break ; } idp = ( const struct id_rdiscovery * ) & dp -> icmp_data ; while ( num -- > 0 ) { ND_TCHECK ( * idp ) ; ( void ) snprintf ( cp , sizeof ( buf ) - ( cp - buf ) , "<S2SV_blank>{%s<S2SV_blank>%u}" , ipaddr_string ( ndo , & idp -> ird_addr ) , EXTRACT_32BITS ( & idp -> ird_pref ) ) ; cp = buf + strlen ( buf ) ; ++ idp ; } } break ; case ICMP_TIMXCEED : ND_TCHECK ( dp -> icmp_ip . ip_dst ) ; switch ( dp -> icmp_code ) { case ICMP_TIMXCEED_INTRANS : str = "time<S2SV_blank>exceeded<S2SV_blank>in-transit" ; break ; case ICMP_TIMXCEED_REASS : str = "ip<S2SV_blank>reassembly<S2SV_blank>time<S2SV_blank>exceeded" ; break ; default : ( void ) snprintf ( buf , sizeof ( buf ) , "time<S2SV_blank>exceeded-#%u" , dp -> icmp_code ) ; break ; } break ; case ICMP_PARAMPROB : if ( dp -> icmp_code ) ( void ) snprintf ( buf , sizeof ( buf ) , "parameter<S2SV_blank>problem<S2SV_blank>-<S2SV_blank>code<S2SV_blank>%u" , dp -> icmp_code ) ; else { ND_TCHECK ( dp -> icmp_pptr ) ; ( void ) snprintf ( buf , sizeof ( buf ) , "parameter<S2SV_blank>problem<S2SV_blank>-<S2SV_blank>octet<S2SV_blank>%u" , dp -> icmp_pptr ) ; } break ; case ICMP_MASKREPLY : ND_TCHECK ( dp -> icmp_mask ) ; ( void ) snprintf ( buf , sizeof ( buf ) , "address<S2SV_blank>mask<S2SV_blank>is<S2SV_blank>0x%08x" , EXTRACT_32BITS ( & dp -> icmp_mask ) ) ; break ; case ICMP_TSTAMP : ND_TCHECK ( dp -> icmp_seq ) ; ( void ) snprintf ( buf , sizeof ( buf ) , "time<S2SV_blank>stamp<S2SV_blank>query<S2SV_blank>id<S2SV_blank>%u<S2SV_blank>seq<S2SV_blank>%u" , EXTRACT_16BITS ( & dp -> icmp_id ) , EXTRACT_16BITS ( & dp -> icmp_seq ) ) ; break ; case ICMP_TSTAMPREPLY : ND_TCHECK ( dp -> icmp_ttime ) ; ( void ) snprintf ( buf , sizeof ( buf ) , "time<S2SV_blank>stamp<S2SV_blank>reply<S2SV_blank>id<S2SV_blank>%u<S2SV_blank>seq<S2SV_blank>%u:<S2SV_blank>org<S2SV_blank>%s" , EXTRACT_16BITS ( & dp -> icmp_id ) , EXTRACT_16BITS ( & dp -> icmp_seq ) , icmp_tstamp_print ( EXTRACT_32BITS ( & dp -> icmp_otime ) ) ) ; ( void ) snprintf ( buf + strlen ( buf ) , sizeof ( buf ) - strlen ( buf ) , ",<S2SV_blank>recv<S2SV_blank>%s" , icmp_tstamp_print ( EXTRACT_32BITS ( & dp -> icmp_rtime ) ) ) ; ( void ) snprintf ( buf + strlen ( buf ) , sizeof ( buf ) - strlen ( buf ) , ",<S2SV_blank>xmit<S2SV_blank>%s" , icmp_tstamp_print ( EXTRACT_32BITS ( & dp -> icmp_ttime ) ) ) ; break ; default : str = tok2str ( icmp2str , "type-#%d" , dp -> icmp_type ) ; break ; } ND_PRINT ( ( ndo , "ICMP<S2SV_blank>%s,<S2SV_blank>length<S2SV_blank>%u" , str , plen ) ) ; if ( ndo -> ndo_vflag && ! fragmented ) { if ( ND_TTEST2 ( * bp , plen ) ) { uint16_t sum ; vec [ 0 ] . ptr = ( const uint8_t * ) ( const void * ) dp ; vec [ 0 ] . len = plen ; sum = in_cksum ( vec , 1 ) ; <S2SV_StartBug> if ( sum != 0 ) { <S2SV_EndBug> uint16_t icmp_sum = EXTRACT_16BITS ( & dp -> icmp_cksum ) ; ND_PRINT ( ( ndo , "<S2SV_blank>(wrong<S2SV_blank>icmp<S2SV_blank>cksum<S2SV_blank>%x<S2SV_blank>(->%x)!)" , icmp_sum , in_cksum_shouldbe ( icmp_sum , sum ) ) ) ; } } } if ( ndo -> ndo_vflag >= 1 && ICMP_ERRTYPE ( dp -> icmp_type ) ) { bp += 8 ; ND_PRINT ( ( ndo , "\\n\\t" ) ) ; ip = ( const struct ip * ) bp ; ndo -> ndo_snaplen = ndo -> ndo_snapend - bp ; snapend_save = ndo -> ndo_snapend ; ND_TCHECK_16BITS ( & ip -> ip_len ) ; ip_print ( ndo , bp , EXTRACT_16BITS ( & ip -> ip_len ) ) ; ndo -> ndo_snapend = snapend_save ; } if ( ndo -> ndo_vflag >= 1 && plen > ICMP_EXTD_MINLEN && ICMP_MPLS_EXT_TYPE ( dp -> icmp_type ) ) { ND_TCHECK ( * ext_dp ) ; if ( ! ext_dp -> icmp_length && ND_TTEST2 ( ext_dp -> icmp_ext_version_res , plen - ICMP_EXTD_MINLEN ) ) { vec [ 0 ] . ptr = ( const uint8_t * ) ( const void * ) & ext_dp -> icmp_ext_version_res ; vec [ 0 ] . len = plen - ICMP_EXTD_MINLEN ; if ( in_cksum ( vec , 1 ) ) { return ; } } ND_PRINT ( ( ndo , "\\n\\tMPLS<S2SV_blank>extension<S2SV_blank>v%u" , ICMP_MPLS_EXT_EXTRACT_VERSION ( * ( ext_dp -> icmp_ext_version_res ) ) ) ) ; if ( ICMP_MPLS_EXT_EXTRACT_VERSION ( * ( ext_dp -> icmp_ext_version_res ) ) != ICMP_MPLS_EXT_VERSION ) { ND_PRINT ( ( ndo , "<S2SV_blank>packet<S2SV_blank>not<S2SV_blank>supported" ) ) ; return ; } hlen = plen - ICMP_EXTD_MINLEN ; if ( ND_TTEST2 ( ext_dp -> icmp_ext_version_res , hlen ) ) { vec [ 0 ] . ptr = ( const uint8_t * ) ( const void * ) & ext_dp -> icmp_ext_version_res ; vec [ 0 ] . len = hlen ; ND_PRINT ( ( ndo , ",<S2SV_blank>checksum<S2SV_blank>0x%04x<S2SV_blank>(%scorrect),<S2SV_blank>length<S2SV_blank>%u" , EXTRACT_16BITS ( ext_dp -> icmp_ext_checksum ) , in_cksum ( vec , 1 ) ? "in" : "" , hlen ) ) ; } hlen -= 4 ; obj_tptr = ( const uint8_t * ) ext_dp -> icmp_ext_data ; while ( hlen > sizeof ( struct icmp_mpls_ext_object_header_t ) ) { icmp_mpls_ext_object_header = ( const struct icmp_mpls_ext_object_header_t * ) obj_tptr ; ND_TCHECK ( * icmp_mpls_ext_object_header ) ; obj_tlen = EXTRACT_16BITS ( icmp_mpls_ext_object_header -> length ) ; obj_class_num = icmp_mpls_ext_object_header -> class_num ; obj_ctype = icmp_mpls_ext_object_header -> ctype ; obj_tptr += sizeof ( struct icmp_mpls_ext_object_header_t ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Object<S2SV_blank>(%u),<S2SV_blank>Class-Type:<S2SV_blank>%u,<S2SV_blank>length<S2SV_blank>%u" , tok2str ( icmp_mpls_ext_obj_values , "unknown" , obj_class_num ) , obj_class_num , obj_ctype , obj_tlen ) ) ; hlen -= sizeof ( struct icmp_mpls_ext_object_header_t ) ; if ( ( obj_class_num == 0 ) || ( obj_tlen < sizeof ( struct icmp_mpls_ext_object_header_t ) ) ) { return ; } obj_tlen -= sizeof ( struct icmp_mpls_ext_object_header_t ) ; switch ( obj_class_num ) { case 1 : switch ( obj_ctype ) { case 1 : ND_TCHECK2 ( * obj_tptr , 4 ) ; raw_label = EXTRACT_32BITS ( obj_tptr ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>label<S2SV_blank>%u,<S2SV_blank>exp<S2SV_blank>%u" , MPLS_LABEL ( raw_label ) , MPLS_EXP ( raw_label ) ) ) ; if ( MPLS_STACK ( raw_label ) ) ND_PRINT ( ( ndo , ",<S2SV_blank>[S]" ) ) ; ND_PRINT ( ( ndo , ",<S2SV_blank>ttl<S2SV_blank>%u" , MPLS_TTL ( raw_label ) ) ) ; break ; default : print_unknown_data ( ndo , obj_tptr , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , obj_tlen ) ; } break ; case 2 : default : print_unknown_data ( ndo , obj_tptr , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , obj_tlen ) ; break ; } if ( hlen < obj_tlen ) break ; hlen -= obj_tlen ; obj_tptr += obj_tlen ; } } return ; trunc : ND_PRINT ( ( ndo , "[|icmp]" ) ) ; }
CWE-125 static int dccp_print_option ( netdissect_options * ndo , const u_char * option , u_int hlen ) { uint8_t optlen , i ; ND_TCHECK ( * option ) ; if ( * option >= 32 ) { ND_TCHECK ( * ( option + 1 ) ) ; optlen = * ( option + 1 ) ; if ( optlen < 2 ) { if ( * option >= 128 ) ND_PRINT ( ( ndo , "CCID<S2SV_blank>option<S2SV_blank>%u<S2SV_blank>optlen<S2SV_blank>too<S2SV_blank>short" , * option ) ) ; else ND_PRINT ( ( ndo , "%s<S2SV_blank>optlen<S2SV_blank>too<S2SV_blank>short" , tok2str ( dccp_option_values , "Option<S2SV_blank>%u" , * option ) ) ) ; return 0 ; } } else optlen = 1 ; if ( hlen < optlen ) { if ( * option >= 128 ) ND_PRINT ( ( ndo , "CCID<S2SV_blank>option<S2SV_blank>%u<S2SV_blank>optlen<S2SV_blank>goes<S2SV_blank>past<S2SV_blank>header<S2SV_blank>length" , * option ) ) ; else ND_PRINT ( ( ndo , "%s<S2SV_blank>optlen<S2SV_blank>goes<S2SV_blank>past<S2SV_blank>header<S2SV_blank>length" , tok2str ( dccp_option_values , "Option<S2SV_blank>%u" , * option ) ) ) ; return 0 ; } ND_TCHECK2 ( * option , optlen ) ; if ( * option >= 128 ) { ND_PRINT ( ( ndo , "CCID<S2SV_blank>option<S2SV_blank>%d" , * option ) ) ; switch ( optlen ) { case 4 : ND_PRINT ( ( ndo , "<S2SV_blank>%u" , EXTRACT_16BITS ( option + 2 ) ) ) ; break ; case 6 : ND_PRINT ( ( ndo , "<S2SV_blank>%u" , EXTRACT_32BITS ( option + 2 ) ) ) ; break ; default : break ; } } else { ND_PRINT ( ( ndo , "%s" , tok2str ( dccp_option_values , "Option<S2SV_blank>%u" , * option ) ) ) ; switch ( * option ) { case 32 : case 33 : case 34 : case 35 : if ( optlen < 3 ) { ND_PRINT ( ( ndo , "<S2SV_blank>optlen<S2SV_blank>too<S2SV_blank>short" ) ) ; return optlen ; } if ( * ( option + 2 ) < 10 ) { ND_PRINT ( ( ndo , "<S2SV_blank>%s" , dccp_feature_nums [ * ( option + 2 ) ] ) ) ; for ( i = 0 ; i < optlen - 3 ; i ++ ) ND_PRINT ( ( ndo , "<S2SV_blank>%d" , * ( option + 3 + i ) ) ) ; } break ; case 36 : if ( optlen > 2 ) { ND_PRINT ( ( ndo , "<S2SV_blank>0x" ) ) ; for ( i = 0 ; i < optlen - 2 ; i ++ ) ND_PRINT ( ( ndo , "%02x" , * ( option + 2 + i ) ) ) ; } break ; case 37 : for ( i = 0 ; i < optlen - 2 ; i ++ ) ND_PRINT ( ( ndo , "<S2SV_blank>%d" , * ( option + 2 + i ) ) ) ; break ; case 38 : if ( optlen > 2 ) { ND_PRINT ( ( ndo , "<S2SV_blank>0x" ) ) ; for ( i = 0 ; i < optlen - 2 ; i ++ ) ND_PRINT ( ( ndo , "%02x" , * ( option + 2 + i ) ) ) ; } break ; case 39 : if ( optlen > 2 ) { ND_PRINT ( ( ndo , "<S2SV_blank>0x" ) ) ; for ( i = 0 ; i < optlen - 2 ; i ++ ) ND_PRINT ( ( ndo , "%02x" , * ( option + 2 + i ) ) ) ; } break ; case 40 : if ( optlen > 2 ) { ND_PRINT ( ( ndo , "<S2SV_blank>0x" ) ) ; for ( i = 0 ; i < optlen - 2 ; i ++ ) ND_PRINT ( ( ndo , "%02x" , * ( option + 2 + i ) ) ) ; } break ; case 41 : <S2SV_StartBug> if ( optlen == 4 ) <S2SV_EndBug> ND_PRINT ( ( ndo , "<S2SV_blank>%u" , EXTRACT_32BITS ( option + 2 ) ) ) ; else <S2SV_StartBug> ND_PRINT ( ( ndo , "<S2SV_blank>optlen<S2SV_blank>!=<S2SV_blank>4" ) ) ; <S2SV_EndBug> break ; case 42 : <S2SV_StartBug> if ( optlen == 4 ) <S2SV_EndBug> <S2SV_StartBug> ND_PRINT ( ( ndo , "<S2SV_blank>%u" , EXTRACT_32BITS ( option + 2 ) ) ) ; <S2SV_EndBug> else <S2SV_StartBug> ND_PRINT ( ( ndo , "<S2SV_blank>optlen<S2SV_blank>!=<S2SV_blank>4" ) ) ; <S2SV_EndBug> break ; case 43 : if ( optlen == 6 ) ND_PRINT ( ( ndo , "<S2SV_blank>%u" , EXTRACT_32BITS ( option + 2 ) ) ) ; else if ( optlen == 4 ) ND_PRINT ( ( ndo , "<S2SV_blank>%u" , EXTRACT_16BITS ( option + 2 ) ) ) ; else ND_PRINT ( ( ndo , "<S2SV_blank>optlen<S2SV_blank>!=<S2SV_blank>4<S2SV_blank>or<S2SV_blank>6" ) ) ; break ; case 44 : if ( optlen > 2 ) { ND_PRINT ( ( ndo , "<S2SV_blank>" ) ) ; for ( i = 0 ; i < optlen - 2 ; i ++ ) ND_PRINT ( ( ndo , "%02x" , * ( option + 2 + i ) ) ) ; } break ; } } return optlen ; trunc : ND_PRINT ( ( ndo , "%s" , tstr ) ) ; return 0 ; }
CWE-674 const u_char * smb_fdata ( netdissect_options * ndo , const u_char * buf , const char * fmt , const u_char * maxbuf , int unicodestr ) { static int depth = 0 ; char s [ 128 ] ; char * p ; while ( * fmt ) { switch ( * fmt ) { case '*' : fmt ++ ; while ( buf < maxbuf ) { const u_char * buf2 ; depth ++ ; <S2SV_StartBug> buf2 = smb_fdata ( ndo , buf , fmt , maxbuf , unicodestr ) ; <S2SV_EndBug> depth -- ; if ( buf2 == NULL ) return ( NULL ) ; if ( buf2 == buf ) return ( buf ) ; buf = buf2 ; } return ( buf ) ; case '|' : fmt ++ ; if ( buf >= maxbuf ) return ( buf ) ; break ; case '%' : fmt ++ ; buf = maxbuf ; break ; case '#' : fmt ++ ; return ( buf ) ; break ; case '[' : fmt ++ ; if ( buf >= maxbuf ) return ( buf ) ; memset ( s , 0 , sizeof ( s ) ) ; p = strchr ( fmt , ']' ) ; if ( ( size_t ) ( p - fmt + 1 ) > sizeof ( s ) ) { return ( buf ) ; } strncpy ( s , fmt , p - fmt ) ; s [ p - fmt ] = '\\0' ; fmt = p + 1 ; buf = smb_fdata1 ( ndo , buf , s , maxbuf , unicodestr ) ; if ( buf == NULL ) return ( NULL ) ; break ; default : ND_PRINT ( ( ndo , "%c" , * fmt ) ) ; fmt ++ ; break ; } } if ( ! depth && buf < maxbuf ) { size_t len = PTR_DIFF ( maxbuf , buf ) ; ND_PRINT ( ( ndo , "Data:<S2SV_blank>(%lu<S2SV_blank>bytes)\\n" , ( unsigned long ) len ) ) ; smb_print_data ( ndo , buf , len ) ; return ( buf + len ) ; } return ( buf ) ; }
CWE-125 static const u_char * ikev1_n_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi0 _U_ , uint32_t proto0 _U_ , int depth _U_ ) { const struct ikev1_pl_n * p ; struct ikev1_pl_n n ; const u_char * cp ; const u_char * ep2 ; uint32_t doi ; uint32_t proto ; static const char * notify_error_str [ ] = { NULL , "INVALID-PAYLOAD-TYPE" , "DOI-NOT-SUPPORTED" , "SITUATION-NOT-SUPPORTED" , "INVALID-COOKIE" , "INVALID-MAJOR-VERSION" , "INVALID-MINOR-VERSION" , "INVALID-EXCHANGE-TYPE" , "INVALID-FLAGS" , "INVALID-MESSAGE-ID" , "INVALID-PROTOCOL-ID" , "INVALID-SPI" , "INVALID-TRANSFORM-ID" , "ATTRIBUTES-NOT-SUPPORTED" , "NO-PROPOSAL-CHOSEN" , "BAD-PROPOSAL-SYNTAX" , "PAYLOAD-MALFORMED" , "INVALID-KEY-INFORMATION" , "INVALID-ID-INFORMATION" , "INVALID-CERT-ENCODING" , "INVALID-CERTIFICATE" , "CERT-TYPE-UNSUPPORTED" , "INVALID-CERT-AUTHORITY" , "INVALID-HASH-INFORMATION" , "AUTHENTICATION-FAILED" , "INVALID-SIGNATURE" , "ADDRESS-NOTIFICATION" , "NOTIFY-SA-LIFETIME" , "CERTIFICATE-UNAVAILABLE" , "UNSUPPORTED-EXCHANGE-TYPE" , "UNEQUAL-PAYLOAD-LENGTHS" , } ; static const char * ipsec_notify_error_str [ ] = { "RESERVED" , } ; static const char * notify_status_str [ ] = { "CONNECTED" , } ; static const char * ipsec_notify_status_str [ ] = { "RESPONDER-LIFETIME" , "REPLAY-STATUS" , "INITIAL-CONTACT" , } ; # define NOTIFY_ERROR_STR ( x ) STR_OR_ID ( ( x ) , notify_error_str ) # define IPSEC_NOTIFY_ERROR_STR ( x ) STR_OR_ID ( ( u_int ) ( ( x ) - 8192 ) , ipsec_notify_error_str ) # define NOTIFY_STATUS_STR ( x ) STR_OR_ID ( ( u_int ) ( ( x ) - 16384 ) , notify_status_str ) # define IPSEC_NOTIFY_STATUS_STR ( x ) STR_OR_ID ( ( u_int ) ( ( x ) - 24576 ) , ipsec_notify_status_str ) ND_PRINT ( ( ndo , "%s:" , NPSTR ( ISAKMP_NPTYPE_N ) ) ) ; p = ( const struct ikev1_pl_n * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & n , ext , sizeof ( n ) ) ; doi = ntohl ( n . doi ) ; proto = n . prot_id ; if ( doi != 1 ) { ND_PRINT ( ( ndo , "<S2SV_blank>doi=%d" , doi ) ) ; ND_PRINT ( ( ndo , "<S2SV_blank>proto=%d" , proto ) ) ; if ( ntohs ( n . type ) < 8192 ) ND_PRINT ( ( ndo , "<S2SV_blank>type=%s" , NOTIFY_ERROR_STR ( ntohs ( n . type ) ) ) ) ; else if ( ntohs ( n . type ) < 16384 ) ND_PRINT ( ( ndo , "<S2SV_blank>type=%s" , numstr ( ntohs ( n . type ) ) ) ) ; else if ( ntohs ( n . type ) < 24576 ) ND_PRINT ( ( ndo , "<S2SV_blank>type=%s" , NOTIFY_STATUS_STR ( ntohs ( n . type ) ) ) ) ; else ND_PRINT ( ( ndo , "<S2SV_blank>type=%s" , numstr ( ntohs ( n . type ) ) ) ) ; if ( n . spi_size ) { ND_PRINT ( ( ndo , "<S2SV_blank>spi=" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( p + 1 ) , n . spi_size ) ) goto trunc ; } return ( const u_char * ) ( p + 1 ) + n . spi_size ; } ND_PRINT ( ( ndo , "<S2SV_blank>doi=ipsec" ) ) ; ND_PRINT ( ( ndo , "<S2SV_blank>proto=%s" , PROTOIDSTR ( proto ) ) ) ; if ( ntohs ( n . type ) < 8192 ) ND_PRINT ( ( ndo , "<S2SV_blank>type=%s" , NOTIFY_ERROR_STR ( ntohs ( n . type ) ) ) ) ; else if ( ntohs ( n . type ) < 16384 ) ND_PRINT ( ( ndo , "<S2SV_blank>type=%s" , IPSEC_NOTIFY_ERROR_STR ( ntohs ( n . type ) ) ) ) ; else if ( ntohs ( n . type ) < 24576 ) ND_PRINT ( ( ndo , "<S2SV_blank>type=%s" , NOTIFY_STATUS_STR ( ntohs ( n . type ) ) ) ) ; else if ( ntohs ( n . type ) < 32768 ) ND_PRINT ( ( ndo , "<S2SV_blank>type=%s" , IPSEC_NOTIFY_STATUS_STR ( ntohs ( n . type ) ) ) ) ; else ND_PRINT ( ( ndo , "<S2SV_blank>type=%s" , numstr ( ntohs ( n . type ) ) ) ) ; if ( n . spi_size ) { ND_PRINT ( ( ndo , "<S2SV_blank>spi=" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( p + 1 ) , n . spi_size ) ) goto trunc ; } cp = ( const u_char * ) ( p + 1 ) + n . spi_size ; ep2 = ( const u_char * ) p + item_len ; if ( cp < ep ) { switch ( ntohs ( n . type ) ) { case IPSECDOI_NTYPE_RESPONDER_LIFETIME : { const struct attrmap * map = oakley_t_map ; size_t nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; ND_PRINT ( ( ndo , "<S2SV_blank>attrs=(" ) ) ; while ( cp < ep && cp < ep2 ) { cp = ikev1_attrmap_print ( ndo , cp , ep2 , map , nmap ) ; if ( cp == NULL ) { ND_PRINT ( ( ndo , ")" ) ) ; goto trunc ; } } ND_PRINT ( ( ndo , ")" ) ) ; break ; } case IPSECDOI_NTYPE_REPLAY_STATUS : ND_PRINT ( ( ndo , "<S2SV_blank>status=(" ) ) ; <S2SV_StartBug> ND_PRINT ( ( ndo , "replay<S2SV_blank>detection<S2SV_blank>%sabled" , <S2SV_EndBug> EXTRACT_32BITS ( cp ) ? "en" : "dis" ) ) ; ND_PRINT ( ( ndo , ")" ) ) ; break ; default : if ( ndo -> ndo_vflag > 3 ) { ND_PRINT ( ( ndo , "<S2SV_blank>data=(" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( cp ) , ep - cp ) ) goto trunc ; ND_PRINT ( ( ndo , ")" ) ) ; } else { if ( ! ike_show_somedata ( ndo , cp , ep ) ) goto trunc ; } break ; } } return ( const u_char * ) ext + item_len ; trunc : ND_PRINT ( ( ndo , "<S2SV_blank>[|%s]" , NPSTR ( ISAKMP_NPTYPE_N ) ) ) ; return NULL ; }
CWE-125 void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , "unknown<S2SV_blank>type<S2SV_blank>(%u)" , type ) ; ND_PRINT ( ( ndo , "VRRPv%u,<S2SV_blank>%s" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , ",<S2SV_blank>(ttl<S2SV_blank>%u)" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , ",<S2SV_blank>vrid<S2SV_blank>%u,<S2SV_blank>prio<S2SV_blank>%u" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , ",<S2SV_blank>authtype<S2SV_blank>%s" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , ",<S2SV_blank>intvl<S2SV_blank>%us,<S2SV_blank>length<S2SV_blank>%u" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , ",<S2SV_blank>intvl<S2SV_blank>%ucs,<S2SV_blank>length<S2SV_blank>%u" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 && ND_TTEST2 ( bp [ 0 ] , len ) ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; <S2SV_StartBug> if ( in_cksum ( vec , 1 ) ) <S2SV_EndBug> ND_PRINT ( ( ndo , ",<S2SV_blank>(bad<S2SV_blank>vrrp<S2SV_blank>cksum<S2SV_blank>%x)" , <S2SV_StartBug> EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; <S2SV_EndBug> } if ( version == 3 && ND_TTEST2 ( bp [ 0 ] , len ) ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , ",<S2SV_blank>(bad<S2SV_blank>vrrp<S2SV_blank>cksum<S2SV_blank>%x)" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } ND_PRINT ( ( ndo , ",<S2SV_blank>addrs" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , "(%d)" , naddrs ) ) ; ND_PRINT ( ( ndo , ":" ) ) ; c = '<S2SV_blank>' ; bp += 8 ; for ( i = 0 ; i < naddrs ; i ++ ) { ND_TCHECK ( bp [ 3 ] ) ; ND_PRINT ( ( ndo , "%c%s" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { ND_TCHECK ( bp [ 7 ] ) ; ND_PRINT ( ( ndo , "<S2SV_blank>auth<S2SV_blank>\\"" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , "\\"" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , "\\"" ) ) ; } } return ; trunc : ND_PRINT ( ( ndo , "[|vrrp]" ) ) ; }
CWE-125 static u_int ieee802_11_print ( netdissect_options * ndo , const u_char * p , u_int length , u_int orig_caplen , int pad , u_int fcslen ) { uint16_t fc ; u_int caplen , hdrlen , meshdrlen ; struct lladdr_info src , dst ; int llc_hdrlen ; caplen = orig_caplen ; if ( length < fcslen ) { ND_PRINT ( ( ndo , "%s" , tstr ) ) ; return caplen ; } length -= fcslen ; if ( caplen > length ) { fcslen = caplen - length ; caplen -= fcslen ; ndo -> ndo_snapend -= fcslen ; } if ( caplen < IEEE802_11_FC_LEN ) { ND_PRINT ( ( ndo , "%s" , tstr ) ) ; return orig_caplen ; } fc = EXTRACT_LE_16BITS ( p ) ; hdrlen = extract_header_length ( ndo , fc ) ; if ( hdrlen == 0 ) { return ( 0 ) ; } if ( pad ) hdrlen = roundup2 ( hdrlen , 4 ) ; if ( ndo -> ndo_Hflag && FC_TYPE ( fc ) == T_DATA && DATA_FRAME_IS_QOS ( FC_SUBTYPE ( fc ) ) ) { <S2SV_StartBug> meshdrlen = extract_mesh_header_length ( p + hdrlen ) ; <S2SV_EndBug> hdrlen += meshdrlen ; } else meshdrlen = 0 ; if ( caplen < hdrlen ) { ND_PRINT ( ( ndo , "%s" , tstr ) ) ; return hdrlen ; } if ( ndo -> ndo_eflag ) ieee_802_11_hdr_print ( ndo , fc , p , hdrlen , meshdrlen ) ; length -= hdrlen ; caplen -= hdrlen ; p += hdrlen ; src . addr_string = etheraddr_string ; dst . addr_string = etheraddr_string ; switch ( FC_TYPE ( fc ) ) { case T_MGMT : get_mgmt_src_dst_mac ( p - hdrlen , & src . addr , & dst . addr ) ; if ( ! mgmt_body_print ( ndo , fc , src . addr , p , length ) ) { ND_PRINT ( ( ndo , "%s" , tstr ) ) ; return hdrlen ; } break ; case T_CTRL : if ( ! ctrl_body_print ( ndo , fc , p - hdrlen ) ) { ND_PRINT ( ( ndo , "%s" , tstr ) ) ; return hdrlen ; } break ; case T_DATA : if ( DATA_FRAME_IS_NULL ( FC_SUBTYPE ( fc ) ) ) return hdrlen ; if ( FC_PROTECTED ( fc ) ) { ND_PRINT ( ( ndo , "Data" ) ) ; if ( ! wep_print ( ndo , p ) ) { ND_PRINT ( ( ndo , "%s" , tstr ) ) ; return hdrlen ; } } else { get_data_src_dst_mac ( fc , p - hdrlen , & src . addr , & dst . addr ) ; llc_hdrlen = llc_print ( ndo , p , length , caplen , & src , & dst ) ; if ( llc_hdrlen < 0 ) { if ( ! ndo -> ndo_suppress_default_print ) ND_DEFAULTPRINT ( p , caplen ) ; llc_hdrlen = - llc_hdrlen ; } hdrlen += llc_hdrlen ; } break ; default : break ; } return hdrlen ; }
CWE-125 static int print_prefix ( netdissect_options * ndo , const u_char * prefix , u_int max_length ) { int plenbytes ; char buf [ sizeof ( "xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx::/128" ) ] ; if ( prefix [ 0 ] >= 96 && max_length >= IPV4_MAPPED_HEADING_LEN + 1 && is_ipv4_mapped_address ( & prefix [ 1 ] ) ) { struct in_addr addr ; u_int plen ; plen = prefix [ 0 ] - 96 ; if ( 32 < plen ) return - 1 ; max_length -= 1 ; memset ( & addr , 0 , sizeof ( addr ) ) ; plenbytes = ( plen + 7 ) / 8 ; if ( max_length < ( u_int ) plenbytes + IPV4_MAPPED_HEADING_LEN ) return - 3 ; memcpy ( & addr , & prefix [ 1 + IPV4_MAPPED_HEADING_LEN ] , plenbytes ) ; if ( plen % 8 ) { ( ( u_char * ) & addr ) [ plenbytes - 1 ] &= ( ( 0xff00 >> ( plen % 8 ) ) & 0xff ) ; } snprintf ( buf , sizeof ( buf ) , "%s/%d" , ipaddr_string ( ndo , & addr ) , plen ) ; plenbytes += 1 + IPV4_MAPPED_HEADING_LEN ; } else { plenbytes = decode_prefix6 ( ndo , prefix , max_length , buf , sizeof ( buf ) ) ; <S2SV_StartBug> } <S2SV_EndBug> ND_PRINT ( ( ndo , "%s" , buf ) ) ; return plenbytes ; }
CWE-125 static void bgp_capabilities_print ( netdissect_options * ndo , const u_char * opt , int caps_len ) { int cap_type , cap_len , tcap_len , cap_offset ; int i = 0 ; while ( i < caps_len ) { ND_TCHECK2 ( opt [ i ] , BGP_CAP_HEADER_SIZE ) ; cap_type = opt [ i ] ; cap_len = opt [ i + 1 ] ; tcap_len = cap_len ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>length:<S2SV_blank>%u" , tok2str ( bgp_capcode_values , "Unknown" , cap_type ) , cap_type , cap_len ) ) ; ND_TCHECK2 ( opt [ i + 2 ] , cap_len ) ; switch ( cap_type ) { case BGP_CAPCODE_MP : ND_PRINT ( ( ndo , "\\n\\t\\tAFI<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>SAFI<S2SV_blank>%s<S2SV_blank>(%u)" , tok2str ( af_values , "Unknown" , EXTRACT_16BITS ( opt + i + 2 ) ) , EXTRACT_16BITS ( opt + i + 2 ) , tok2str ( bgp_safi_values , "Unknown" , opt [ i + 5 ] ) , opt [ i + 5 ] ) ) ; break ; <S2SV_StartBug> case BGP_CAPCODE_RESTART : <S2SV_EndBug> ND_PRINT ( ( ndo , "\\n\\t\\tRestart<S2SV_blank>Flags:<S2SV_blank>[%s],<S2SV_blank>Restart<S2SV_blank>Time<S2SV_blank>%us" , ( ( opt [ i + 2 ] ) & 0x80 ) ? "R" : "none" , EXTRACT_16BITS ( opt + i + 2 ) & 0xfff ) ) ; tcap_len -= 2 ; cap_offset = 4 ; while ( tcap_len >= 4 ) { ND_PRINT ( ( ndo , "\\n\\t\\t<S2SV_blank><S2SV_blank>AFI<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>SAFI<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>Forwarding<S2SV_blank>state<S2SV_blank>preserved:<S2SV_blank>%s" , tok2str ( af_values , "Unknown" , EXTRACT_16BITS ( opt + i + cap_offset ) ) , EXTRACT_16BITS ( opt + i + cap_offset ) , tok2str ( bgp_safi_values , "Unknown" , opt [ i + cap_offset + 2 ] ) , opt [ i + cap_offset + 2 ] , ( ( opt [ i + cap_offset + 3 ] ) & 0x80 ) ? "yes" : "no" ) ) ; tcap_len -= 4 ; cap_offset += 4 ; } break ; case BGP_CAPCODE_RR : case BGP_CAPCODE_RR_CISCO : break ; case BGP_CAPCODE_AS_NEW : if ( cap_len == 4 ) { ND_PRINT ( ( ndo , "\\n\\t\\t<S2SV_blank>4<S2SV_blank>Byte<S2SV_blank>AS<S2SV_blank>%s" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( opt + i + 2 ) ) ) ) ; } break ; case BGP_CAPCODE_ADD_PATH : cap_offset = 2 ; if ( tcap_len == 0 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(bogus)" ) ) ; break ; } while ( tcap_len > 0 ) { if ( tcap_len < 4 ) { ND_PRINT ( ( ndo , "\\n\\t\\t(invalid)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t\\tAFI<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>SAFI<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>Send/Receive:<S2SV_blank>%s" , tok2str ( af_values , "Unknown" , EXTRACT_16BITS ( opt + i + cap_offset ) ) , EXTRACT_16BITS ( opt + i + cap_offset ) , tok2str ( bgp_safi_values , "Unknown" , opt [ i + cap_offset + 2 ] ) , opt [ i + cap_offset + 2 ] , tok2str ( bgp_add_path_recvsend , "Bogus<S2SV_blank>(0x%02x)" , opt [ i + cap_offset + 3 ] ) ) ) ; tcap_len -= 4 ; cap_offset += 4 ; } break ; default : ND_PRINT ( ( ndo , "\\n\\t\\tno<S2SV_blank>decoder<S2SV_blank>for<S2SV_blank>Capability<S2SV_blank>%u" , cap_type ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , & opt [ i + 2 ] , "\\n\\t\\t" , cap_len ) ; break ; } if ( ndo -> ndo_vflag > 1 && cap_len > 0 ) { print_unknown_data ( ndo , & opt [ i + 2 ] , "\\n\\t\\t" , cap_len ) ; } i += BGP_CAP_HEADER_SIZE + cap_len ; } return ; trunc : ND_PRINT ( ( ndo , "[|BGP]" ) ) ; }
CWE-125 static void print_trans ( netdissect_options * ndo , const u_char * words , const u_char * data1 , const u_char * buf , const u_char * maxbuf ) { u_int bcc ; const char * f1 , * f2 , * f3 , * f4 ; const u_char * data , * param ; const u_char * w = words + 1 ; int datalen , paramlen ; if ( request ) { ND_TCHECK2 ( w [ 12 * 2 ] , 2 ) ; paramlen = EXTRACT_LE_16BITS ( w + 9 * 2 ) ; param = buf + EXTRACT_LE_16BITS ( w + 10 * 2 ) ; datalen = EXTRACT_LE_16BITS ( w + 11 * 2 ) ; data = buf + EXTRACT_LE_16BITS ( w + 12 * 2 ) ; f1 = "TotParamCnt=[d]<S2SV_blank>\\nTotDataCnt=[d]<S2SV_blank>\\nMaxParmCnt=[d]<S2SV_blank>\\nMaxDataCnt=[d]\\nMaxSCnt=[d]<S2SV_blank>\\nTransFlags=[w]<S2SV_blank>\\nRes1=[w]<S2SV_blank>\\nRes2=[w]<S2SV_blank>\\nRes3=[w]\\nParamCnt=[d]<S2SV_blank>\\nParamOff=[d]<S2SV_blank>\\nDataCnt=[d]<S2SV_blank>\\nDataOff=[d]<S2SV_blank>\\nSUCnt=[d]\\n" ; f2 = "|Name=[S]\\n" ; f3 = "|Param<S2SV_blank>" ; f4 = "|Data<S2SV_blank>" ; } else { ND_TCHECK2 ( w [ 7 * 2 ] , 2 ) ; paramlen = EXTRACT_LE_16BITS ( w + 3 * 2 ) ; param = buf + EXTRACT_LE_16BITS ( w + 4 * 2 ) ; datalen = EXTRACT_LE_16BITS ( w + 6 * 2 ) ; data = buf + EXTRACT_LE_16BITS ( w + 7 * 2 ) ; f1 = "TotParamCnt=[d]<S2SV_blank>\\nTotDataCnt=[d]<S2SV_blank>\\nRes1=[d]\\nParamCnt=[d]<S2SV_blank>\\nParamOff=[d]<S2SV_blank>\\nRes2=[d]<S2SV_blank>\\nDataCnt=[d]<S2SV_blank>\\nDataOff=[d]<S2SV_blank>\\nRes3=[d]\\nLsetup=[d]\\n" ; f2 = "|Unknown<S2SV_blank>" ; f3 = "|Param<S2SV_blank>" ; f4 = "|Data<S2SV_blank>" ; } smb_fdata ( ndo , words + 1 , f1 , min ( words + 1 + 2 * words [ 0 ] , maxbuf ) , unicodestr ) ; ND_TCHECK2 ( * data1 , 2 ) ; bcc = EXTRACT_LE_16BITS ( data1 ) ; ND_PRINT ( ( ndo , "smb_bcc=%u\\n" , bcc ) ) ; if ( bcc > 0 ) { smb_fdata ( ndo , data1 + 2 , f2 , maxbuf - ( paramlen + datalen ) , unicodestr ) ; <S2SV_StartBug> if ( strcmp ( ( const char * ) ( data1 + 2 ) , "\\\\MAILSLOT\\\\BROWSE" ) == 0 ) { <S2SV_EndBug> print_browse ( ndo , param , paramlen , data , datalen ) ; return ; } <S2SV_StartBug> if ( strcmp ( ( const char * ) ( data1 + 2 ) , "\\\\PIPE\\\\LANMAN" ) == 0 ) { <S2SV_EndBug> print_ipc ( ndo , param , paramlen , data , datalen ) ; return ; } <S2SV_StartBug> if ( paramlen ) <S2SV_EndBug> smb_fdata ( ndo , param , f3 , min ( param + paramlen , maxbuf ) , unicodestr ) ; if ( datalen ) smb_fdata ( ndo , data , f4 , min ( data + datalen , maxbuf ) , unicodestr ) ; } return ; trunc : ND_PRINT ( ( ndo , "%s" , tstr ) ) ; }
CWE-120 static char * get_next_file ( FILE * VFile , char * ptr ) { <S2SV_StartBug> char * ret ; <S2SV_EndBug> ret = fgets ( ptr , PATH_MAX , VFile ) ; if ( ! ret ) return NULL ; <S2SV_StartBug> if ( ptr [ strlen ( ptr ) - 1 ] == '\\n' ) <S2SV_EndBug> <S2SV_StartBug> ptr [ strlen ( ptr ) - 1 ] = '\\0' ; <S2SV_EndBug> return ret ; }
CWE-125 u_int mfr_print ( netdissect_options * ndo , register const u_char * p , u_int length ) { u_int tlen , idx , hdr_len = 0 ; uint16_t sequence_num ; uint8_t ie_type , ie_len ; const uint8_t * tptr ; ND_TCHECK2 ( * p , 4 ) ; if ( ( p [ 0 ] & MFR_BEC_MASK ) == MFR_CTRL_FRAME && p [ 1 ] == 0 ) { ND_PRINT ( ( ndo , "FRF.16<S2SV_blank>Control,<S2SV_blank>Flags<S2SV_blank>[%s],<S2SV_blank>%s,<S2SV_blank>length<S2SV_blank>%u" , bittok2str ( frf_flag_values , "none" , ( p [ 0 ] & MFR_BEC_MASK ) ) , tok2str ( mfr_ctrl_msg_values , "Unknown<S2SV_blank>Message<S2SV_blank>(0x%02x)" , p [ 2 ] ) , length ) ) ; tptr = p + 3 ; tlen = length - 3 ; hdr_len = 3 ; if ( ! ndo -> ndo_vflag ) return hdr_len ; while ( tlen > sizeof ( struct ie_tlv_header_t ) ) { ND_TCHECK2 ( * tptr , sizeof ( struct ie_tlv_header_t ) ) ; ie_type = tptr [ 0 ] ; ie_len = tptr [ 1 ] ; ND_PRINT ( ( ndo , "\\n\\tIE<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>length<S2SV_blank>%u:<S2SV_blank>" , tok2str ( mfr_ctrl_ie_values , "Unknown" , ie_type ) , ie_type , ie_len ) ) ; if ( ie_type == 0 || ie_len <= sizeof ( struct ie_tlv_header_t ) ) return hdr_len ; ND_TCHECK2 ( * tptr , ie_len ) ; tptr += sizeof ( struct ie_tlv_header_t ) ; ie_len -= sizeof ( struct ie_tlv_header_t ) ; tlen -= sizeof ( struct ie_tlv_header_t ) ; switch ( ie_type ) { <S2SV_StartBug> case MFR_CTRL_IE_MAGIC_NUM : <S2SV_EndBug> ND_PRINT ( ( ndo , "0x%08x" , EXTRACT_32BITS ( tptr ) ) ) ; break ; case MFR_CTRL_IE_BUNDLE_ID : case MFR_CTRL_IE_LINK_ID : for ( idx = 0 ; idx < ie_len && idx < MFR_ID_STRING_MAXLEN ; idx ++ ) { if ( * ( tptr + idx ) != 0 ) safeputchar ( ndo , * ( tptr + idx ) ) ; else break ; } break ; case MFR_CTRL_IE_TIMESTAMP : if ( ie_len == sizeof ( struct timeval ) ) { ts_print ( ndo , ( const struct timeval * ) tptr ) ; break ; } case MFR_CTRL_IE_VENDOR_EXT : case MFR_CTRL_IE_CAUSE : default : if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr , "\\n\\t<S2SV_blank><S2SV_blank>" , ie_len ) ; break ; } if ( ndo -> ndo_vflag > 1 ) print_unknown_data ( ndo , tptr , "\\n\\t<S2SV_blank><S2SV_blank>" , ie_len ) ; tlen -= ie_len ; tptr += ie_len ; } return hdr_len ; } sequence_num = ( p [ 0 ] & 0x1e ) << 7 | p [ 1 ] ; if ( ( p [ 0 ] & MFR_BEC_MASK ) == MFR_FRAG_FRAME || ( p [ 0 ] & MFR_BEC_MASK ) == MFR_B_BIT ) { ND_PRINT ( ( ndo , "FRF.16<S2SV_blank>Frag,<S2SV_blank>seq<S2SV_blank>%u,<S2SV_blank>Flags<S2SV_blank>[%s],<S2SV_blank>" , sequence_num , bittok2str ( frf_flag_values , "none" , ( p [ 0 ] & MFR_BEC_MASK ) ) ) ) ; hdr_len = 2 ; fr_print ( ndo , p + hdr_len , length - hdr_len ) ; return hdr_len ; } ND_PRINT ( ( ndo , "FRF.16<S2SV_blank>Frag,<S2SV_blank>seq<S2SV_blank>%u,<S2SV_blank>Flags<S2SV_blank>[%s]" , sequence_num , bittok2str ( frf_flag_values , "none" , ( p [ 0 ] & MFR_BEC_MASK ) ) ) ) ; print_unknown_data ( ndo , p , "\\n\\t" , length ) ; return hdr_len ; trunc : ND_PRINT ( ( ndo , "[|mfr]" ) ) ; return length ; }
CWE-125 static u_int ldp_pdu_print ( netdissect_options * ndo , register const u_char * pptr ) { const struct ldp_common_header * ldp_com_header ; const struct ldp_msg_header * ldp_msg_header ; const u_char * tptr , * msg_tptr ; u_short tlen ; u_short pdu_len , msg_len , msg_type , msg_tlen ; int hexdump , processed ; ldp_com_header = ( const struct ldp_common_header * ) pptr ; ND_TCHECK ( * ldp_com_header ) ; if ( EXTRACT_16BITS ( & ldp_com_header -> version ) != LDP_VERSION ) { ND_PRINT ( ( ndo , "%sLDP<S2SV_blank>version<S2SV_blank>%u<S2SV_blank>packet<S2SV_blank>not<S2SV_blank>supported" , ( ndo -> ndo_vflag < 1 ) ? "" : "\\n\\t" , EXTRACT_16BITS ( & ldp_com_header -> version ) ) ) ; return 0 ; } pdu_len = EXTRACT_16BITS ( & ldp_com_header -> pdu_length ) ; if ( pdu_len < sizeof ( const struct ldp_common_header ) - 4 ) { ND_PRINT ( ( ndo , "%sLDP,<S2SV_blank>pdu-length:<S2SV_blank>%u<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)" , ( ndo -> ndo_vflag < 1 ) ? "" : "\\n\\t" , pdu_len , ( u_int ) ( sizeof ( const struct ldp_common_header ) - 4 ) ) ) ; return 0 ; } ND_PRINT ( ( ndo , "%sLDP,<S2SV_blank>Label-Space-ID:<S2SV_blank>%s:%u,<S2SV_blank>pdu-length:<S2SV_blank>%u" , ( ndo -> ndo_vflag < 1 ) ? "" : "\\n\\t" , ipaddr_string ( ndo , & ldp_com_header -> lsr_id ) , EXTRACT_16BITS ( & ldp_com_header -> label_space ) , pdu_len ) ) ; if ( ndo -> ndo_vflag < 1 ) return 0 ; tptr = pptr + sizeof ( const struct ldp_common_header ) ; tlen = pdu_len - ( sizeof ( const struct ldp_common_header ) - 4 ) ; while ( tlen > 0 ) { ND_TCHECK2 ( * tptr , sizeof ( struct ldp_msg_header ) ) ; ldp_msg_header = ( const struct ldp_msg_header * ) tptr ; msg_len = EXTRACT_16BITS ( ldp_msg_header -> length ) ; msg_type = LDP_MASK_MSG_TYPE ( EXTRACT_16BITS ( ldp_msg_header -> type ) ) ; if ( msg_len < sizeof ( struct ldp_msg_header ) - 4 ) { ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Message<S2SV_blank>(0x%04x),<S2SV_blank>length:<S2SV_blank>%u<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)" , tok2str ( ldp_msg_values , "Unknown" , msg_type ) , msg_type , msg_len , ( u_int ) ( sizeof ( struct ldp_msg_header ) - 4 ) ) ) ; return 0 ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Message<S2SV_blank>(0x%04x),<S2SV_blank>length:<S2SV_blank>%u,<S2SV_blank>Message<S2SV_blank>ID:<S2SV_blank>0x%08x,<S2SV_blank>Flags:<S2SV_blank>[%s<S2SV_blank>if<S2SV_blank>unknown]" , tok2str ( ldp_msg_values , "Unknown" , msg_type ) , msg_type , msg_len , EXTRACT_32BITS ( & ldp_msg_header -> id ) , LDP_MASK_U_BIT ( EXTRACT_16BITS ( & ldp_msg_header -> type ) ) ? "continue<S2SV_blank>processing" : "ignore" ) ) ; msg_tptr = tptr + sizeof ( struct ldp_msg_header ) ; msg_tlen = msg_len - ( sizeof ( struct ldp_msg_header ) - 4 ) ; ND_TCHECK2 ( * tptr , msg_len ) ; hexdump = FALSE ; switch ( msg_type ) { case LDP_MSG_NOTIF : case LDP_MSG_HELLO : case LDP_MSG_INIT : case LDP_MSG_KEEPALIVE : case LDP_MSG_ADDRESS : case LDP_MSG_LABEL_MAPPING : case LDP_MSG_ADDRESS_WITHDRAW : case LDP_MSG_LABEL_WITHDRAW : while ( msg_tlen >= 4 ) { processed = ldp_tlv_print ( ndo , msg_tptr , msg_tlen ) ; if ( processed == 0 ) break ; msg_tlen -= processed ; msg_tptr += processed ; } break ; case LDP_MSG_LABEL_REQUEST : case LDP_MSG_LABEL_RELEASE : case LDP_MSG_LABEL_ABORT_REQUEST : default : if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , msg_tptr , "\\n\\t<S2SV_blank><S2SV_blank>" , msg_tlen ) ; break ; } if ( ndo -> ndo_vflag > 1 || hexdump == TRUE ) print_unknown_data ( ndo , tptr + sizeof ( struct ldp_msg_header ) , "\\n\\t<S2SV_blank><S2SV_blank>" , msg_len ) ; tptr += msg_len + 4 ; tlen -= msg_len + 4 ; } return pdu_len + 4 ; trunc : <S2SV_StartBug> ND_PRINT ( ( ndo , "\\n\\t\\t<S2SV_blank>packet<S2SV_blank>exceeded<S2SV_blank>snapshot" ) ) ; <S2SV_EndBug> return 0 ; }
CWE-125 static int ldp_tlv_print ( netdissect_options * ndo , register const u_char * tptr , u_short msg_tlen ) { struct ldp_tlv_header { uint8_t type [ 2 ] ; uint8_t length [ 2 ] ; } ; const struct ldp_tlv_header * ldp_tlv_header ; u_short tlv_type , tlv_len , tlv_tlen , af , ft_flags ; u_char fec_type ; u_int ui , vc_info_len , vc_info_tlv_type , vc_info_tlv_len , idx ; char buf [ 100 ] ; int i ; ldp_tlv_header = ( const struct ldp_tlv_header * ) tptr ; ND_TCHECK ( * ldp_tlv_header ) ; tlv_len = EXTRACT_16BITS ( ldp_tlv_header -> length ) ; if ( tlv_len + 4 > msg_tlen ) { ND_PRINT ( ( ndo , "\\n\\t\\t<S2SV_blank>TLV<S2SV_blank>contents<S2SV_blank>go<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>message" ) ) ; return 0 ; } tlv_tlen = tlv_len ; tlv_type = LDP_MASK_TLV_TYPE ( EXTRACT_16BITS ( ldp_tlv_header -> type ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>TLV<S2SV_blank>(0x%04x),<S2SV_blank>length:<S2SV_blank>%u,<S2SV_blank>Flags:<S2SV_blank>[%s<S2SV_blank>and<S2SV_blank>%s<S2SV_blank>forward<S2SV_blank>if<S2SV_blank>unknown]" , tok2str ( ldp_tlv_values , "Unknown" , tlv_type ) , tlv_type , tlv_len , LDP_MASK_U_BIT ( EXTRACT_16BITS ( & ldp_tlv_header -> type ) ) ? "continue<S2SV_blank>processing" : "ignore" , LDP_MASK_F_BIT ( EXTRACT_16BITS ( & ldp_tlv_header -> type ) ) ? "do" : "don\'t" ) ) ; tptr += sizeof ( struct ldp_tlv_header ) ; switch ( tlv_type ) { case LDP_TLV_COMMON_HELLO : TLV_TCHECK ( 4 ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Hold<S2SV_blank>Time:<S2SV_blank>%us,<S2SV_blank>Flags:<S2SV_blank>[%s<S2SV_blank>Hello%s]" , EXTRACT_16BITS ( tptr ) , ( EXTRACT_16BITS ( tptr + 2 ) & 0x8000 ) ? "Targeted" : "Link" , ( EXTRACT_16BITS ( tptr + 2 ) & 0x4000 ) ? ",<S2SV_blank>Request<S2SV_blank>for<S2SV_blank>targeted<S2SV_blank>Hellos" : "" ) ) ; break ; case LDP_TLV_IPV4_TRANSPORT_ADDR : TLV_TCHECK ( 4 ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>IPv4<S2SV_blank>Transport<S2SV_blank>Address:<S2SV_blank>%s" , ipaddr_string ( ndo , tptr ) ) ) ; break ; case LDP_TLV_IPV6_TRANSPORT_ADDR : TLV_TCHECK ( 16 ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>IPv6<S2SV_blank>Transport<S2SV_blank>Address:<S2SV_blank>%s" , ip6addr_string ( ndo , tptr ) ) ) ; break ; case LDP_TLV_CONFIG_SEQ_NUMBER : TLV_TCHECK ( 4 ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Sequence<S2SV_blank>Number:<S2SV_blank>%u" , EXTRACT_32BITS ( tptr ) ) ) ; break ; case LDP_TLV_ADDRESS_LIST : TLV_TCHECK ( LDP_TLV_ADDRESS_LIST_AFNUM_LEN ) ; af = EXTRACT_16BITS ( tptr ) ; tptr += LDP_TLV_ADDRESS_LIST_AFNUM_LEN ; tlv_tlen -= LDP_TLV_ADDRESS_LIST_AFNUM_LEN ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Address<S2SV_blank>Family:<S2SV_blank>%s,<S2SV_blank>addresses" , tok2str ( af_values , "Unknown<S2SV_blank>(%u)" , af ) ) ) ; switch ( af ) { case AFNUM_INET : while ( tlv_tlen >= sizeof ( struct in_addr ) ) { ND_TCHECK2 ( * tptr , sizeof ( struct in_addr ) ) ; ND_PRINT ( ( ndo , "<S2SV_blank>%s" , ipaddr_string ( ndo , tptr ) ) ) ; tlv_tlen -= sizeof ( struct in_addr ) ; tptr += sizeof ( struct in_addr ) ; } break ; case AFNUM_INET6 : while ( tlv_tlen >= sizeof ( struct in6_addr ) ) { ND_TCHECK2 ( * tptr , sizeof ( struct in6_addr ) ) ; ND_PRINT ( ( ndo , "<S2SV_blank>%s" , ip6addr_string ( ndo , tptr ) ) ) ; tlv_tlen -= sizeof ( struct in6_addr ) ; tptr += sizeof ( struct in6_addr ) ; } break ; default : break ; } break ; case LDP_TLV_COMMON_SESSION : TLV_TCHECK ( 8 ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Version:<S2SV_blank>%u,<S2SV_blank>Keepalive:<S2SV_blank>%us,<S2SV_blank>Flags:<S2SV_blank>[Downstream<S2SV_blank>%s,<S2SV_blank>Loop<S2SV_blank>Detection<S2SV_blank>%s]" , EXTRACT_16BITS ( tptr ) , EXTRACT_16BITS ( tptr + 2 ) , ( EXTRACT_16BITS ( tptr + 6 ) & 0x8000 ) ? "On<S2SV_blank>Demand" : "Unsolicited" , ( EXTRACT_16BITS ( tptr + 6 ) & 0x4000 ) ? "Enabled" : "Disabled" ) ) ; break ; case LDP_TLV_FEC : TLV_TCHECK ( 1 ) ; fec_type = * tptr ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>FEC<S2SV_blank>(0x%02x)" , tok2str ( ldp_fec_values , "Unknown" , fec_type ) , fec_type ) ) ; tptr += 1 ; tlv_tlen -= 1 ; switch ( fec_type ) { case LDP_FEC_WILDCARD : break ; case LDP_FEC_PREFIX : TLV_TCHECK ( 2 ) ; af = EXTRACT_16BITS ( tptr ) ; tptr += LDP_TLV_ADDRESS_LIST_AFNUM_LEN ; tlv_tlen -= LDP_TLV_ADDRESS_LIST_AFNUM_LEN ; if ( af == AFNUM_INET ) { i = decode_prefix4 ( ndo , tptr , tlv_tlen , buf , sizeof ( buf ) ) ; if ( i == - 2 ) goto trunc ; if ( i == - 3 ) ND_PRINT ( ( ndo , ":<S2SV_blank>IPv4<S2SV_blank>prefix<S2SV_blank>(goes<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>TLV)" ) ) ; else if ( i == - 1 ) ND_PRINT ( ( ndo , ":<S2SV_blank>IPv4<S2SV_blank>prefix<S2SV_blank>(invalid<S2SV_blank>length)" ) ) ; else ND_PRINT ( ( ndo , ":<S2SV_blank>IPv4<S2SV_blank>prefix<S2SV_blank>%s" , buf ) ) ; } else if ( af == AFNUM_INET6 ) { i = decode_prefix6 ( ndo , tptr , tlv_tlen , buf , sizeof ( buf ) ) ; if ( i == - 2 ) goto trunc ; if ( i == - 3 ) ND_PRINT ( ( ndo , ":<S2SV_blank>IPv4<S2SV_blank>prefix<S2SV_blank>(goes<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>TLV)" ) ) ; else if ( i == - 1 ) ND_PRINT ( ( ndo , ":<S2SV_blank>IPv6<S2SV_blank>prefix<S2SV_blank>(invalid<S2SV_blank>length)" ) ) ; else ND_PRINT ( ( ndo , ":<S2SV_blank>IPv6<S2SV_blank>prefix<S2SV_blank>%s" , buf ) ) ; } else ND_PRINT ( ( ndo , ":<S2SV_blank>Address<S2SV_blank>family<S2SV_blank>%u<S2SV_blank>prefix" , af ) ) ; break ; case LDP_FEC_HOSTADDRESS : break ; case LDP_FEC_MARTINI_VC : TLV_TCHECK ( 7 ) ; vc_info_len = * ( tptr + 2 ) ; if ( vc_info_len == 0 ) { ND_PRINT ( ( ndo , ":<S2SV_blank>%s,<S2SV_blank>%scontrol<S2SV_blank>word,<S2SV_blank>group-ID<S2SV_blank>%u,<S2SV_blank>VC-info-length:<S2SV_blank>%u" , tok2str ( mpls_pw_types_values , "Unknown" , EXTRACT_16BITS ( tptr ) & 0x7fff ) , EXTRACT_16BITS ( tptr ) & 0x8000 ? "" : "no<S2SV_blank>" , EXTRACT_32BITS ( tptr + 3 ) , vc_info_len ) ) ; break ; } TLV_TCHECK ( 11 ) ; ND_PRINT ( ( ndo , ":<S2SV_blank>%s,<S2SV_blank>%scontrol<S2SV_blank>word,<S2SV_blank>group-ID<S2SV_blank>%u,<S2SV_blank>VC-ID<S2SV_blank>%u,<S2SV_blank>VC-info-length:<S2SV_blank>%u" , tok2str ( mpls_pw_types_values , "Unknown" , EXTRACT_16BITS ( tptr ) & 0x7fff ) , EXTRACT_16BITS ( tptr ) & 0x8000 ? "" : "no<S2SV_blank>" , EXTRACT_32BITS ( tptr + 3 ) , EXTRACT_32BITS ( tptr + 7 ) , vc_info_len ) ) ; if ( vc_info_len < 4 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(invalid,<S2SV_blank><<S2SV_blank>4" ) ) ; return ( tlv_len + 4 ) ; } vc_info_len -= 4 ; tptr += 11 ; tlv_tlen -= 11 ; TLV_TCHECK ( vc_info_len ) ; while ( vc_info_len > 2 ) { vc_info_tlv_type = * tptr ; vc_info_tlv_len = * ( tptr + 1 ) ; if ( vc_info_tlv_len < 2 ) break ; if ( vc_info_len < vc_info_tlv_len ) break ; ND_PRINT ( ( ndo , "\\n\\t\\tInterface<S2SV_blank>Parameter:<S2SV_blank>%s<S2SV_blank>(0x%02x),<S2SV_blank>len<S2SV_blank>%u" , tok2str ( ldp_fec_martini_ifparm_values , "Unknown" , vc_info_tlv_type ) , vc_info_tlv_type , vc_info_tlv_len ) ) ; switch ( vc_info_tlv_type ) { case LDP_FEC_MARTINI_IFPARM_MTU : ND_PRINT ( ( ndo , ":<S2SV_blank>%u" , EXTRACT_16BITS ( tptr + 2 ) ) ) ; break ; case LDP_FEC_MARTINI_IFPARM_DESC : ND_PRINT ( ( ndo , ":<S2SV_blank>" ) ) ; for ( idx = 2 ; idx < vc_info_tlv_len ; idx ++ ) safeputchar ( ndo , * ( tptr + idx ) ) ; break ; case LDP_FEC_MARTINI_IFPARM_VCCV : ND_PRINT ( ( ndo , "\\n\\t\\t<S2SV_blank><S2SV_blank>Control<S2SV_blank>Channels<S2SV_blank>(0x%02x)<S2SV_blank>=<S2SV_blank>[%s]" , * ( tptr + 2 ) , bittok2str ( ldp_fec_martini_ifparm_vccv_cc_values , "none" , * ( tptr + 2 ) ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t\\t<S2SV_blank><S2SV_blank>CV<S2SV_blank>Types<S2SV_blank>(0x%02x)<S2SV_blank>=<S2SV_blank>[%s]" , * ( tptr + 3 ) , bittok2str ( ldp_fec_martini_ifparm_vccv_cv_values , "none" , * ( tptr + 3 ) ) ) ) ; break ; default : print_unknown_data ( ndo , tptr + 2 , "\\n\\t\\t<S2SV_blank><S2SV_blank>" , vc_info_tlv_len - 2 ) ; break ; } vc_info_len -= vc_info_tlv_len ; tptr += vc_info_tlv_len ; } break ; } break ; case LDP_TLV_GENERIC_LABEL : TLV_TCHECK ( 4 ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Label:<S2SV_blank>%u" , EXTRACT_32BITS ( tptr ) & 0xfffff ) ) ; break ; case LDP_TLV_STATUS : TLV_TCHECK ( 8 ) ; ui = EXTRACT_32BITS ( tptr ) ; tptr += 4 ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Status:<S2SV_blank>0x%02x,<S2SV_blank>Flags:<S2SV_blank>[%s<S2SV_blank>and<S2SV_blank>%s<S2SV_blank>forward]" , ui & 0x3fffffff , ui & 0x80000000 ? "Fatal<S2SV_blank>error" : "Advisory<S2SV_blank>Notification" , ui & 0x40000000 ? "do" : "don\'t" ) ) ; ui = EXTRACT_32BITS ( tptr ) ; tptr += 4 ; if ( ui ) ND_PRINT ( ( ndo , ",<S2SV_blank>causing<S2SV_blank>Message<S2SV_blank>ID:<S2SV_blank>0x%08x" , ui ) ) ; break ; case LDP_TLV_FT_SESSION : <S2SV_StartBug> TLV_TCHECK ( 8 ) ; <S2SV_EndBug> ft_flags = EXTRACT_16BITS ( tptr ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[%sReconnect,<S2SV_blank>%sSave<S2SV_blank>State,<S2SV_blank>%sAll-Label<S2SV_blank>Protection,<S2SV_blank>%s<S2SV_blank>Checkpoint,<S2SV_blank>%sRe-Learn<S2SV_blank>State]" , ft_flags & 0x8000 ? "" : "No<S2SV_blank>" , ft_flags & 0x8 ? "" : "Don\'t<S2SV_blank>" , ft_flags & 0x4 ? "" : "No<S2SV_blank>" , ft_flags & 0x2 ? "Sequence<S2SV_blank>Numbered<S2SV_blank>Label" : "All<S2SV_blank>Labels" , ft_flags & 0x1 ? "" : "Don\'t<S2SV_blank>" ) ) ; tptr += 4 ; ui = EXTRACT_32BITS ( tptr ) ; if ( ui ) ND_PRINT ( ( ndo , ",<S2SV_blank>Reconnect<S2SV_blank>Timeout:<S2SV_blank>%ums" , ui ) ) ; tptr += 4 ; ui = EXTRACT_32BITS ( tptr ) ; if ( ui ) ND_PRINT ( ( ndo , ",<S2SV_blank>Recovery<S2SV_blank>Time:<S2SV_blank>%ums" , ui ) ) ; break ; case LDP_TLV_MTU : TLV_TCHECK ( 2 ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>MTU:<S2SV_blank>%u" , EXTRACT_16BITS ( tptr ) ) ) ; break ; case LDP_TLV_HOP_COUNT : case LDP_TLV_PATH_VECTOR : case LDP_TLV_ATM_LABEL : case LDP_TLV_FR_LABEL : case LDP_TLV_EXTD_STATUS : case LDP_TLV_RETURNED_PDU : case LDP_TLV_RETURNED_MSG : case LDP_TLV_ATM_SESSION_PARM : case LDP_TLV_FR_SESSION_PARM : case LDP_TLV_LABEL_REQUEST_MSG_ID : default : if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , tlv_tlen ) ; break ; } return ( tlv_len + 4 ) ; trunc : <S2SV_StartBug> ND_PRINT ( ( ndo , "\\n\\t\\t<S2SV_blank>packet<S2SV_blank>exceeded<S2SV_blank>snapshot" ) ) ; <S2SV_EndBug> return 0 ; badtlv : ND_PRINT ( ( ndo , "\\n\\t\\t<S2SV_blank>TLV<S2SV_blank>contents<S2SV_blank>go<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>TLV" ) ) ; return ( tlv_len + 4 ) ; }
CWE-674 static int bgp_attr_print ( netdissect_options * ndo , <S2SV_StartBug> u_int atype , const u_char * pptr , u_int len ) <S2SV_EndBug> { int i ; uint16_t af ; uint8_t safi , snpa , nhlen ; union { float f ; uint32_t i ; } bw ; int advance ; u_int tlen ; const u_char * tptr ; char buf [ MAXHOSTNAMELEN + 100 ] ; int as_size ; tptr = pptr ; tlen = len ; switch ( atype ) { case BGPTYPE_ORIGIN : if ( len != 1 ) ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; else { ND_TCHECK ( * tptr ) ; ND_PRINT ( ( ndo , "%s" , tok2str ( bgp_origin_values , "Unknown<S2SV_blank>Origin<S2SV_blank>Typecode" , tptr [ 0 ] ) ) ) ; } break ; case BGPTYPE_AS4_PATH : case BGPTYPE_AS_PATH : if ( len % 2 ) { ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; break ; } if ( ! len ) { ND_PRINT ( ( ndo , "empty" ) ) ; break ; } as_size = bgp_attr_get_as_size ( ndo , atype , pptr , len ) ; while ( tptr < pptr + len ) { ND_TCHECK ( tptr [ 0 ] ) ; ND_PRINT ( ( ndo , "%s" , tok2str ( bgp_as_path_segment_open_values , "?" , tptr [ 0 ] ) ) ) ; ND_TCHECK ( tptr [ 1 ] ) ; for ( i = 0 ; i < tptr [ 1 ] * as_size ; i += as_size ) { ND_TCHECK2 ( tptr [ 2 + i ] , as_size ) ; ND_PRINT ( ( ndo , "%s<S2SV_blank>" , as_printf ( ndo , astostr , sizeof ( astostr ) , as_size == 2 ? EXTRACT_16BITS ( & tptr [ 2 + i ] ) : EXTRACT_32BITS ( & tptr [ 2 + i ] ) ) ) ) ; } ND_TCHECK ( tptr [ 0 ] ) ; ND_PRINT ( ( ndo , "%s" , tok2str ( bgp_as_path_segment_close_values , "?" , tptr [ 0 ] ) ) ) ; ND_TCHECK ( tptr [ 1 ] ) ; tptr += 2 + tptr [ 1 ] * as_size ; } break ; case BGPTYPE_NEXT_HOP : if ( len != 4 ) ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; else { ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , "%s" , ipaddr_string ( ndo , tptr ) ) ) ; } break ; case BGPTYPE_MULTI_EXIT_DISC : case BGPTYPE_LOCAL_PREF : if ( len != 4 ) ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; else { ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , "%u" , EXTRACT_32BITS ( tptr ) ) ) ; } break ; case BGPTYPE_ATOMIC_AGGREGATE : if ( len != 0 ) ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; break ; case BGPTYPE_AGGREGATOR : if ( len != 6 && len != 8 ) { ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; break ; } ND_TCHECK2 ( tptr [ 0 ] , len ) ; if ( len == 6 ) { ND_PRINT ( ( ndo , "<S2SV_blank>AS<S2SV_blank>#%s,<S2SV_blank>origin<S2SV_blank>%s" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_16BITS ( tptr ) ) , ipaddr_string ( ndo , tptr + 2 ) ) ) ; } else { ND_PRINT ( ( ndo , "<S2SV_blank>AS<S2SV_blank>#%s,<S2SV_blank>origin<S2SV_blank>%s" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr ) ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; } break ; case BGPTYPE_AGGREGATOR4 : if ( len != 8 ) { ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; break ; } ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , "<S2SV_blank>AS<S2SV_blank>#%s,<S2SV_blank>origin<S2SV_blank>%s" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr ) ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; break ; case BGPTYPE_COMMUNITIES : if ( len % 4 ) { ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; break ; } while ( tlen > 0 ) { uint32_t comm ; ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; comm = EXTRACT_32BITS ( tptr ) ; switch ( comm ) { case BGP_COMMUNITY_NO_EXPORT : ND_PRINT ( ( ndo , "<S2SV_blank>NO_EXPORT" ) ) ; break ; case BGP_COMMUNITY_NO_ADVERT : ND_PRINT ( ( ndo , "<S2SV_blank>NO_ADVERTISE" ) ) ; break ; case BGP_COMMUNITY_NO_EXPORT_SUBCONFED : ND_PRINT ( ( ndo , "<S2SV_blank>NO_EXPORT_SUBCONFED" ) ) ; break ; default : ND_PRINT ( ( ndo , "%u:%u%s" , ( comm >> 16 ) & 0xffff , comm & 0xffff , ( tlen > 4 ) ? ",<S2SV_blank>" : "" ) ) ; break ; } tlen -= 4 ; tptr += 4 ; } break ; case BGPTYPE_ORIGINATOR_ID : if ( len != 4 ) { ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; break ; } ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , "%s" , ipaddr_string ( ndo , tptr ) ) ) ; break ; case BGPTYPE_CLUSTER_LIST : if ( len % 4 ) { ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; break ; } while ( tlen > 0 ) { ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , "%s%s" , ipaddr_string ( ndo , tptr ) , ( tlen > 4 ) ? ",<S2SV_blank>" : "" ) ) ; tlen -= 4 ; tptr += 4 ; } break ; case BGPTYPE_MP_REACH_NLRI : ND_TCHECK2 ( tptr [ 0 ] , 3 ) ; af = EXTRACT_16BITS ( tptr ) ; safi = tptr [ 2 ] ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>AFI:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>%sSAFI:<S2SV_blank>%s<S2SV_blank>(%u)" , tok2str ( af_values , "Unknown<S2SV_blank>AFI" , af ) , af , ( safi > 128 ) ? "vendor<S2SV_blank>specific<S2SV_blank>" : "" , tok2str ( bgp_safi_values , "Unknown<S2SV_blank>SAFI" , safi ) , safi ) ) ; switch ( af << 8 | safi ) { case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_RT_ROUTING_INFO ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET << 8 | SAFNUM_MDT ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : break ; default : ND_TCHECK2 ( tptr [ 0 ] , tlen ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>no<S2SV_blank>AFI<S2SV_blank>%u<S2SV_blank>/<S2SV_blank>SAFI<S2SV_blank>%u<S2SV_blank>decoder" , af , safi ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , tlen ) ; goto done ; break ; } tptr += 3 ; ND_TCHECK ( tptr [ 0 ] ) ; nhlen = tptr [ 0 ] ; tlen = nhlen ; tptr ++ ; if ( tlen ) { int nnh = 0 ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>nexthop:<S2SV_blank>" ) ) ; while ( tlen > 0 ) { if ( nnh ++ > 0 ) { ND_PRINT ( ( ndo , ",<S2SV_blank>" ) ) ; } switch ( af << 8 | safi ) { case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_RT_ROUTING_INFO ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET << 8 | SAFNUM_MDT ) : if ( tlen < ( int ) sizeof ( struct in_addr ) ) { ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in_addr ) ) ; ND_PRINT ( ( ndo , "%s" , ipaddr_string ( ndo , tptr ) ) ) ; tlen -= sizeof ( struct in_addr ) ; tptr += sizeof ( struct in_addr ) ; } break ; case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < ( int ) ( sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ) { ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ; ND_PRINT ( ( ndo , "RD:<S2SV_blank>%s,<S2SV_blank>%s" , bgp_vpn_rd_print ( ndo , tptr ) , ipaddr_string ( ndo , tptr + BGP_VPN_RD_LEN ) ) ) ; tlen -= ( sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ; tptr += ( sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ; } break ; case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : if ( tlen < ( int ) sizeof ( struct in6_addr ) ) { ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in6_addr ) ) ; ND_PRINT ( ( ndo , "%s" , ip6addr_string ( ndo , tptr ) ) ) ; tlen -= sizeof ( struct in6_addr ) ; tptr += sizeof ( struct in6_addr ) ; } break ; case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < ( int ) ( sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ) { ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ; ND_PRINT ( ( ndo , "RD:<S2SV_blank>%s,<S2SV_blank>%s" , bgp_vpn_rd_print ( ndo , tptr ) , ip6addr_string ( ndo , tptr + BGP_VPN_RD_LEN ) ) ) ; tlen -= ( sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ; tptr += ( sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ; } break ; case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < ( int ) sizeof ( struct in_addr ) ) { ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in_addr ) ) ; ND_PRINT ( ( ndo , "%s" , ipaddr_string ( ndo , tptr ) ) ) ; tlen -= ( sizeof ( struct in_addr ) ) ; tptr += ( sizeof ( struct in_addr ) ) ; } break ; case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : ND_TCHECK2 ( tptr [ 0 ] , tlen ) ; ND_PRINT ( ( ndo , "%s" , isonsap_string ( ndo , tptr , tlen ) ) ) ; tptr += tlen ; tlen = 0 ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < BGP_VPN_RD_LEN + 1 ) { ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , tlen ) ; ND_PRINT ( ( ndo , "RD:<S2SV_blank>%s,<S2SV_blank>%s" , bgp_vpn_rd_print ( ndo , tptr ) , isonsap_string ( ndo , tptr + BGP_VPN_RD_LEN , tlen - BGP_VPN_RD_LEN ) ) ) ; if ( tlen == BGP_VPN_RD_LEN + 4 + sizeof ( struct in_addr ) && EXTRACT_32BITS ( tptr + BGP_VPN_RD_LEN ) == 0x47000601 ) ND_PRINT ( ( ndo , "<S2SV_blank>=<S2SV_blank>%s" , ipaddr_string ( ndo , tptr + BGP_VPN_RD_LEN + 4 ) ) ) ; else if ( tlen == BGP_VPN_RD_LEN + 3 + sizeof ( struct in6_addr ) && EXTRACT_24BITS ( tptr + BGP_VPN_RD_LEN ) == 0x350000 ) ND_PRINT ( ( ndo , "<S2SV_blank>=<S2SV_blank>%s" , ip6addr_string ( ndo , tptr + BGP_VPN_RD_LEN + 3 ) ) ) ; tptr += tlen ; tlen = 0 ; } break ; default : ND_TCHECK2 ( tptr [ 0 ] , tlen ) ; ND_PRINT ( ( ndo , "no<S2SV_blank>AFI<S2SV_blank>%u/SAFI<S2SV_blank>%u<S2SV_blank>decoder" , af , safi ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , tlen ) ; tptr += tlen ; tlen = 0 ; goto done ; break ; } } } ND_PRINT ( ( ndo , ",<S2SV_blank>nh-length:<S2SV_blank>%u" , nhlen ) ) ; tptr += tlen ; ND_TCHECK ( tptr [ 0 ] ) ; snpa = tptr [ 0 ] ; tptr ++ ; if ( snpa ) { ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%u<S2SV_blank>SNPA" , snpa ) ) ; for ( ; snpa > 0 ; snpa -- ) { ND_TCHECK ( tptr [ 0 ] ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%d<S2SV_blank>bytes" , tptr [ 0 ] ) ) ; tptr += tptr [ 0 ] + 1 ; } } else { ND_PRINT ( ( ndo , ",<S2SV_blank>no<S2SV_blank>SNPA" ) ) ; } while ( tptr < pptr + len ) { switch ( af << 8 | safi ) { case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix4 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_RT_ROUTING_INFO ) : advance = decode_rt_routing_info ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST_VPN ) : advance = decode_multicast_vpn ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_MDT ) : advance = decode_mdt_vpn_nlri ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix6 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_l2 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; default : ND_TCHECK2 ( * tptr , tlen ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>no<S2SV_blank>AFI<S2SV_blank>%u<S2SV_blank>/<S2SV_blank>SAFI<S2SV_blank>%u<S2SV_blank>decoder" , af , safi ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , tlen ) ; advance = 0 ; tptr = pptr + len ; break ; } if ( advance < 0 ) break ; tptr += advance ; } done : break ; case BGPTYPE_MP_UNREACH_NLRI : ND_TCHECK2 ( tptr [ 0 ] , BGP_MP_NLRI_MINSIZE ) ; af = EXTRACT_16BITS ( tptr ) ; safi = tptr [ 2 ] ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>AFI:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>%sSAFI:<S2SV_blank>%s<S2SV_blank>(%u)" , tok2str ( af_values , "Unknown<S2SV_blank>AFI" , af ) , af , ( safi > 128 ) ? "vendor<S2SV_blank>specific<S2SV_blank>" : "" , tok2str ( bgp_safi_values , "Unknown<S2SV_blank>SAFI" , safi ) , safi ) ) ; if ( len == BGP_MP_NLRI_MINSIZE ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>End-of-Rib<S2SV_blank>Marker<S2SV_blank>(empty<S2SV_blank>NLRI)" ) ) ; tptr += 3 ; while ( tptr < pptr + len ) { switch ( af << 8 | safi ) { case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix4 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix6 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_l2 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_MDT ) : advance = decode_mdt_vpn_nlri ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST_VPN ) : advance = decode_multicast_vpn ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; default : ND_TCHECK2 ( * ( tptr - 3 ) , tlen ) ; ND_PRINT ( ( ndo , "no<S2SV_blank>AFI<S2SV_blank>%u<S2SV_blank>/<S2SV_blank>SAFI<S2SV_blank>%u<S2SV_blank>decoder" , af , safi ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr - 3 , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , tlen ) ; advance = 0 ; tptr = pptr + len ; break ; } if ( advance < 0 ) break ; tptr += advance ; } break ; case BGPTYPE_EXTD_COMMUNITIES : if ( len % 8 ) { ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; break ; } while ( tlen > 0 ) { uint16_t extd_comm ; ND_TCHECK2 ( tptr [ 0 ] , 2 ) ; extd_comm = EXTRACT_16BITS ( tptr ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>(0x%04x),<S2SV_blank>Flags<S2SV_blank>[%s]" , tok2str ( bgp_extd_comm_subtype_values , "unknown<S2SV_blank>extd<S2SV_blank>community<S2SV_blank>typecode" , extd_comm ) , extd_comm , bittok2str ( bgp_extd_comm_flag_values , "none" , extd_comm ) ) ) ; ND_TCHECK2 ( * ( tptr + 2 ) , 6 ) ; switch ( extd_comm ) { case BGP_EXT_COM_RT_0 : case BGP_EXT_COM_RO_0 : case BGP_EXT_COM_L2VPN_RT_0 : ND_PRINT ( ( ndo , ":<S2SV_blank>%u:%u<S2SV_blank>(=<S2SV_blank>%s)" , EXTRACT_16BITS ( tptr + 2 ) , EXTRACT_32BITS ( tptr + 4 ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; break ; case BGP_EXT_COM_RT_1 : case BGP_EXT_COM_RO_1 : case BGP_EXT_COM_L2VPN_RT_1 : case BGP_EXT_COM_VRF_RT_IMP : ND_PRINT ( ( ndo , ":<S2SV_blank>%s:%u" , ipaddr_string ( ndo , tptr + 2 ) , EXTRACT_16BITS ( tptr + 6 ) ) ) ; break ; case BGP_EXT_COM_RT_2 : case BGP_EXT_COM_RO_2 : ND_PRINT ( ( ndo , ":<S2SV_blank>%s:%u" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr + 2 ) ) , EXTRACT_16BITS ( tptr + 6 ) ) ) ; break ; case BGP_EXT_COM_LINKBAND : bw . i = EXTRACT_32BITS ( tptr + 2 ) ; ND_PRINT ( ( ndo , ":<S2SV_blank>bandwidth:<S2SV_blank>%.3f<S2SV_blank>Mbps" , bw . f * 8 / 1000000 ) ) ; break ; case BGP_EXT_COM_VPN_ORIGIN : case BGP_EXT_COM_VPN_ORIGIN2 : case BGP_EXT_COM_VPN_ORIGIN3 : case BGP_EXT_COM_VPN_ORIGIN4 : case BGP_EXT_COM_OSPF_RID : case BGP_EXT_COM_OSPF_RID2 : ND_PRINT ( ( ndo , "%s" , ipaddr_string ( ndo , tptr + 2 ) ) ) ; break ; case BGP_EXT_COM_OSPF_RTYPE : case BGP_EXT_COM_OSPF_RTYPE2 : ND_PRINT ( ( ndo , ":<S2SV_blank>area:%s,<S2SV_blank>router-type:%s,<S2SV_blank>metric-type:%s%s" , ipaddr_string ( ndo , tptr + 2 ) , tok2str ( bgp_extd_comm_ospf_rtype_values , "unknown<S2SV_blank>(0x%02x)" , * ( tptr + 6 ) ) , ( * ( tptr + 7 ) & BGP_OSPF_RTYPE_METRIC_TYPE ) ? "E2" : "" , ( ( * ( tptr + 6 ) == BGP_OSPF_RTYPE_EXT ) || ( * ( tptr + 6 ) == BGP_OSPF_RTYPE_NSSA ) ) ? "E1" : "" ) ) ; break ; case BGP_EXT_COM_L2INFO : ND_PRINT ( ( ndo , ":<S2SV_blank>%s<S2SV_blank>Control<S2SV_blank>Flags<S2SV_blank>[0x%02x]:MTU<S2SV_blank>%u" , tok2str ( l2vpn_encaps_values , "unknown<S2SV_blank>encaps" , * ( tptr + 2 ) ) , * ( tptr + 3 ) , EXTRACT_16BITS ( tptr + 4 ) ) ) ; break ; case BGP_EXT_COM_SOURCE_AS : ND_PRINT ( ( ndo , ":<S2SV_blank>AS<S2SV_blank>%u" , EXTRACT_16BITS ( tptr + 2 ) ) ) ; break ; default : ND_TCHECK2 ( * tptr , 8 ) ; print_unknown_data ( ndo , tptr , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , 8 ) ; break ; } tlen -= 8 ; tptr += 8 ; } break ; case BGPTYPE_PMSI_TUNNEL : { uint8_t tunnel_type , flags ; ND_TCHECK2 ( tptr [ 0 ] , 5 ) ; tunnel_type = * ( tptr + 1 ) ; flags = * tptr ; tlen = len ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Tunnel-type<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>Flags<S2SV_blank>[%s],<S2SV_blank>MPLS<S2SV_blank>Label<S2SV_blank>%u" , tok2str ( bgp_pmsi_tunnel_values , "Unknown" , tunnel_type ) , tunnel_type , bittok2str ( bgp_pmsi_flag_values , "none" , flags ) , EXTRACT_24BITS ( tptr + 2 ) >> 4 ) ) ; tptr += 5 ; tlen -= 5 ; switch ( tunnel_type ) { case BGP_PMSI_TUNNEL_PIM_SM : case BGP_PMSI_TUNNEL_PIM_BIDIR : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Sender<S2SV_blank>%s,<S2SV_blank>P-Group<S2SV_blank>%s" , ipaddr_string ( ndo , tptr ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; break ; case BGP_PMSI_TUNNEL_PIM_SSM : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Root-Node<S2SV_blank>%s,<S2SV_blank>P-Group<S2SV_blank>%s" , ipaddr_string ( ndo , tptr ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; break ; case BGP_PMSI_TUNNEL_INGRESS : ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Tunnel-Endpoint<S2SV_blank>%s" , ipaddr_string ( ndo , tptr ) ) ) ; break ; case BGP_PMSI_TUNNEL_LDP_P2MP : case BGP_PMSI_TUNNEL_LDP_MP2MP : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Root-Node<S2SV_blank>%s,<S2SV_blank>LSP-ID<S2SV_blank>0x%08x" , ipaddr_string ( ndo , tptr ) , EXTRACT_32BITS ( tptr + 4 ) ) ) ; break ; case BGP_PMSI_TUNNEL_RSVP_P2MP : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Extended-Tunnel-ID<S2SV_blank>%s,<S2SV_blank>P2MP-ID<S2SV_blank>0x%08x" , ipaddr_string ( ndo , tptr ) , EXTRACT_32BITS ( tptr + 4 ) ) ) ; break ; default : if ( ndo -> ndo_vflag <= 1 ) { print_unknown_data ( ndo , tptr , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , tlen ) ; } } break ; } case BGPTYPE_AIGP : { uint8_t type ; uint16_t length ; tlen = len ; while ( tlen >= 3 ) { ND_TCHECK2 ( tptr [ 0 ] , 3 ) ; type = * tptr ; length = EXTRACT_16BITS ( tptr + 1 ) ; tptr += 3 ; tlen -= 3 ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>TLV<S2SV_blank>(%u),<S2SV_blank>length<S2SV_blank>%u" , tok2str ( bgp_aigp_values , "Unknown" , type ) , type , length ) ) ; if ( length < 3 ) goto trunc ; length -= 3 ; ND_TCHECK2 ( tptr [ 3 ] , length ) ; switch ( type ) { case BGP_AIGP_TLV : if ( length < 8 ) goto trunc ; ND_PRINT ( ( ndo , ",<S2SV_blank>metric<S2SV_blank>%" PRIu64 , EXTRACT_64BITS ( tptr ) ) ) ; break ; default : if ( ndo -> ndo_vflag <= 1 ) { print_unknown_data ( ndo , tptr , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , length ) ; } } tptr += length ; tlen -= length ; } break ; } case BGPTYPE_ATTR_SET : ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; if ( len < 4 ) goto trunc ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Origin<S2SV_blank>AS:<S2SV_blank>%s" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr ) ) ) ) ; tptr += 4 ; len -= 4 ; while ( len ) { u_int aflags , alenlen , alen ; ND_TCHECK2 ( tptr [ 0 ] , 2 ) ; if ( len < 2 ) goto trunc ; aflags = * tptr ; atype = * ( tptr + 1 ) ; tptr += 2 ; len -= 2 ; alenlen = bgp_attr_lenlen ( aflags , tptr ) ; ND_TCHECK2 ( tptr [ 0 ] , alenlen ) ; if ( len < alenlen ) goto trunc ; alen = bgp_attr_len ( aflags , tptr ) ; tptr += alenlen ; len -= alenlen ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>length:<S2SV_blank>%u" , tok2str ( bgp_attr_values , "Unknown<S2SV_blank>Attribute" , atype ) , atype , alen ) ) ; if ( aflags ) { ND_PRINT ( ( ndo , ",<S2SV_blank>Flags<S2SV_blank>[%s%s%s%s" , aflags & 0x80 ? "O" : "" , aflags & 0x40 ? "T" : "" , aflags & 0x20 ? "P" : "" , aflags & 0x10 ? "E" : "" ) ) ; if ( aflags & 0xf ) ND_PRINT ( ( ndo , "+%x" , aflags & 0xf ) ) ; ND_PRINT ( ( ndo , "]:<S2SV_blank>" ) ) ; } <S2SV_StartBug> if ( ! bgp_attr_print ( ndo , atype , tptr , alen ) ) <S2SV_EndBug> return 0 ; tptr += alen ; len -= alen ; } break ; case BGPTYPE_LARGE_COMMUNITY : if ( len == 0 || len % 12 ) { ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" ) ) ; while ( len > 0 ) { ND_TCHECK2 ( * tptr , 12 ) ; ND_PRINT ( ( ndo , "%u:%u:%u%s" , EXTRACT_32BITS ( tptr ) , EXTRACT_32BITS ( tptr + 4 ) , EXTRACT_32BITS ( tptr + 8 ) , ( len > 12 ) ? ",<S2SV_blank>" : "" ) ) ; tptr += 12 ; len -= 12 ; } break ; default : ND_TCHECK2 ( * pptr , len ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>no<S2SV_blank>Attribute<S2SV_blank>%u<S2SV_blank>decoder" , atype ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , pptr , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , len ) ; break ; } if ( ndo -> ndo_vflag > 1 && len ) { ND_TCHECK2 ( * pptr , len ) ; print_unknown_data ( ndo , pptr , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , len ) ; } return 1 ; trunc : return 0 ; }
CWE-674 static void bgp_update_print ( netdissect_options * ndo , const u_char * dat , int length ) { struct bgp bgp ; const u_char * p ; int withdrawn_routes_len ; int len ; int i ; ND_TCHECK2 ( dat [ 0 ] , BGP_SIZE ) ; if ( length < BGP_SIZE ) goto trunc ; memcpy ( & bgp , dat , BGP_SIZE ) ; p = dat + BGP_SIZE ; length -= BGP_SIZE ; ND_TCHECK2 ( p [ 0 ] , 2 ) ; if ( length < 2 ) goto trunc ; withdrawn_routes_len = EXTRACT_16BITS ( p ) ; p += 2 ; length -= 2 ; if ( withdrawn_routes_len ) { ND_TCHECK2 ( p [ 0 ] , withdrawn_routes_len ) ; if ( length < withdrawn_routes_len ) goto trunc ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>Withdrawn<S2SV_blank>routes:<S2SV_blank>%d<S2SV_blank>bytes" , withdrawn_routes_len ) ) ; p += withdrawn_routes_len ; length -= withdrawn_routes_len ; } ND_TCHECK2 ( p [ 0 ] , 2 ) ; if ( length < 2 ) goto trunc ; len = EXTRACT_16BITS ( p ) ; p += 2 ; length -= 2 ; if ( withdrawn_routes_len == 0 && len == 0 && length == 0 ) { ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>End-of-Rib<S2SV_blank>Marker<S2SV_blank>(empty<S2SV_blank>NLRI)" ) ) ; return ; } if ( len ) { while ( len ) { int aflags , atype , alenlen , alen ; ND_TCHECK2 ( p [ 0 ] , 2 ) ; if ( len < 2 ) goto trunc ; if ( length < 2 ) goto trunc ; aflags = * p ; atype = * ( p + 1 ) ; p += 2 ; len -= 2 ; length -= 2 ; alenlen = bgp_attr_lenlen ( aflags , p ) ; ND_TCHECK2 ( p [ 0 ] , alenlen ) ; if ( len < alenlen ) goto trunc ; if ( length < alenlen ) goto trunc ; alen = bgp_attr_len ( aflags , p ) ; p += alenlen ; len -= alenlen ; length -= alenlen ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>length:<S2SV_blank>%u" , tok2str ( bgp_attr_values , "Unknown<S2SV_blank>Attribute" , atype ) , atype , alen ) ) ; if ( aflags ) { ND_PRINT ( ( ndo , ",<S2SV_blank>Flags<S2SV_blank>[%s%s%s%s" , aflags & 0x80 ? "O" : "" , aflags & 0x40 ? "T" : "" , aflags & 0x20 ? "P" : "" , aflags & 0x10 ? "E" : "" ) ) ; if ( aflags & 0xf ) ND_PRINT ( ( ndo , "+%x" , aflags & 0xf ) ) ; ND_PRINT ( ( ndo , "]:<S2SV_blank>" ) ) ; } if ( len < alen ) goto trunc ; if ( length < alen ) goto trunc ; <S2SV_StartBug> if ( ! bgp_attr_print ( ndo , atype , p , alen ) ) <S2SV_EndBug> goto trunc ; p += alen ; len -= alen ; length -= alen ; } } if ( length ) { ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>Updated<S2SV_blank>routes:" ) ) ; while ( length ) { char buf [ MAXHOSTNAMELEN + 100 ] ; i = decode_prefix4 ( ndo , p , length , buf , sizeof ( buf ) ) ; if ( i == - 1 ) { ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; break ; } else if ( i == - 2 ) goto trunc ; else if ( i == - 3 ) goto trunc ; else { ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; p += i ; length -= i ; } } } return ; trunc : ND_PRINT ( ( ndo , "%s" , tstr ) ) ; }
CWE-125 static int rsvp_obj_print ( netdissect_options * ndo , const u_char * pptr , u_int plen , const u_char * tptr , const char * ident , u_int tlen , const struct rsvp_common_header * rsvp_com_header ) { const struct rsvp_object_header * rsvp_obj_header ; const u_char * obj_tptr ; union { const struct rsvp_obj_integrity_t * rsvp_obj_integrity ; const struct rsvp_obj_frr_t * rsvp_obj_frr ; } obj_ptr ; u_short rsvp_obj_len , rsvp_obj_ctype , obj_tlen , intserv_serv_tlen ; int hexdump , processed , padbytes , error_code , error_value , i , sigcheck ; union { float f ; uint32_t i ; } bw ; uint8_t namelen ; u_int action , subchannel ; while ( tlen >= sizeof ( struct rsvp_object_header ) ) { ND_TCHECK2 ( * tptr , sizeof ( struct rsvp_object_header ) ) ; rsvp_obj_header = ( const struct rsvp_object_header * ) tptr ; rsvp_obj_len = EXTRACT_16BITS ( rsvp_obj_header -> length ) ; rsvp_obj_ctype = rsvp_obj_header -> ctype ; if ( rsvp_obj_len % 4 ) { ND_PRINT ( ( ndo , "%sERROR:<S2SV_blank>object<S2SV_blank>header<S2SV_blank>size<S2SV_blank>%u<S2SV_blank>not<S2SV_blank>a<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>4" , ident , rsvp_obj_len ) ) ; return - 1 ; } if ( rsvp_obj_len < sizeof ( struct rsvp_object_header ) ) { ND_PRINT ( ( ndo , "%sERROR:<S2SV_blank>object<S2SV_blank>header<S2SV_blank>too<S2SV_blank>short<S2SV_blank>%u<S2SV_blank><<S2SV_blank>%lu" , ident , rsvp_obj_len , ( unsigned long ) sizeof ( const struct rsvp_object_header ) ) ) ; return - 1 ; } ND_PRINT ( ( ndo , "%s%s<S2SV_blank>Object<S2SV_blank>(%u)<S2SV_blank>Flags:<S2SV_blank>[%s" , ident , tok2str ( rsvp_obj_values , "Unknown" , rsvp_obj_header -> class_num ) , rsvp_obj_header -> class_num , ( ( rsvp_obj_header -> class_num ) & 0x80 ) ? "ignore" : "reject" ) ) ; if ( rsvp_obj_header -> class_num > 128 ) ND_PRINT ( ( ndo , "<S2SV_blank>%s" , ( ( rsvp_obj_header -> class_num ) & 0x40 ) ? "and<S2SV_blank>forward" : "silently" ) ) ; ND_PRINT ( ( ndo , "<S2SV_blank>if<S2SV_blank>unknown],<S2SV_blank>Class-Type:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>length:<S2SV_blank>%u" , tok2str ( rsvp_ctype_values , "Unknown" , ( ( rsvp_obj_header -> class_num ) << 8 ) + rsvp_obj_ctype ) , rsvp_obj_ctype , rsvp_obj_len ) ) ; if ( tlen < rsvp_obj_len ) { ND_PRINT ( ( ndo , "%sERROR:<S2SV_blank>object<S2SV_blank>goes<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>objects<S2SV_blank>TLV" , ident ) ) ; return - 1 ; } obj_tptr = tptr + sizeof ( struct rsvp_object_header ) ; obj_tlen = rsvp_obj_len - sizeof ( struct rsvp_object_header ) ; if ( ! ND_TTEST2 ( * tptr , rsvp_obj_len ) ) return - 1 ; hexdump = FALSE ; switch ( rsvp_obj_header -> class_num ) { case RSVP_OBJ_SESSION : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_IPV4 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>IPv4<S2SV_blank>DestAddress:<S2SV_blank>%s,<S2SV_blank>Protocol<S2SV_blank>ID:<S2SV_blank>0x%02x" , ident , ipaddr_string ( ndo , obj_tptr ) , * ( obj_tptr + sizeof ( struct in_addr ) ) ) ) ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[0x%02x],<S2SV_blank>DestPort<S2SV_blank>%u" , ident , * ( obj_tptr + 5 ) , EXTRACT_16BITS ( obj_tptr + 6 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; break ; case RSVP_CTYPE_IPV6 : if ( obj_tlen < 20 ) return - 1 ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>IPv6<S2SV_blank>DestAddress:<S2SV_blank>%s,<S2SV_blank>Protocol<S2SV_blank>ID:<S2SV_blank>0x%02x" , ident , ip6addr_string ( ndo , obj_tptr ) , * ( obj_tptr + sizeof ( struct in6_addr ) ) ) ) ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[0x%02x],<S2SV_blank>DestPort<S2SV_blank>%u" , ident , * ( obj_tptr + sizeof ( struct in6_addr ) + 1 ) , EXTRACT_16BITS ( obj_tptr + sizeof ( struct in6_addr ) + 2 ) ) ) ; obj_tlen -= 20 ; obj_tptr += 20 ; break ; case RSVP_CTYPE_TUNNEL_IPV6 : if ( obj_tlen < 36 ) return - 1 ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>IPv6<S2SV_blank>Tunnel<S2SV_blank>EndPoint:<S2SV_blank>%s,<S2SV_blank>Tunnel<S2SV_blank>ID:<S2SV_blank>0x%04x,<S2SV_blank>Extended<S2SV_blank>Tunnel<S2SV_blank>ID:<S2SV_blank>%s" , ident , ip6addr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 18 ) , ip6addr_string ( ndo , obj_tptr + 20 ) ) ) ; obj_tlen -= 36 ; obj_tptr += 36 ; break ; case RSVP_CTYPE_14 : if ( obj_tlen < 26 ) return - 1 ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>IPv6<S2SV_blank>P2MP<S2SV_blank>LSP<S2SV_blank>ID:<S2SV_blank>0x%08x,<S2SV_blank>Tunnel<S2SV_blank>ID:<S2SV_blank>0x%04x,<S2SV_blank>Extended<S2SV_blank>Tunnel<S2SV_blank>ID:<S2SV_blank>%s" , ident , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) , ip6addr_string ( ndo , obj_tptr + 8 ) ) ) ; obj_tlen -= 26 ; obj_tptr += 26 ; break ; case RSVP_CTYPE_13 : if ( obj_tlen < 12 ) return - 1 ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>IPv4<S2SV_blank>P2MP<S2SV_blank>LSP<S2SV_blank>ID:<S2SV_blank>%s,<S2SV_blank>Tunnel<S2SV_blank>ID:<S2SV_blank>0x%04x,<S2SV_blank>Extended<S2SV_blank>Tunnel<S2SV_blank>ID:<S2SV_blank>%s" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) , ipaddr_string ( ndo , obj_tptr + 8 ) ) ) ; obj_tlen -= 12 ; obj_tptr += 12 ; break ; case RSVP_CTYPE_TUNNEL_IPV4 : case RSVP_CTYPE_UNI_IPV4 : if ( obj_tlen < 12 ) return - 1 ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>IPv4<S2SV_blank>Tunnel<S2SV_blank>EndPoint:<S2SV_blank>%s,<S2SV_blank>Tunnel<S2SV_blank>ID:<S2SV_blank>0x%04x,<S2SV_blank>Extended<S2SV_blank>Tunnel<S2SV_blank>ID:<S2SV_blank>%s" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) , ipaddr_string ( ndo , obj_tptr + 8 ) ) ) ; obj_tlen -= 12 ; obj_tptr += 12 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_CONFIRM : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_IPV4 : if ( obj_tlen < sizeof ( struct in_addr ) ) return - 1 ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>IPv4<S2SV_blank>Receiver<S2SV_blank>Address:<S2SV_blank>%s" , ident , ipaddr_string ( ndo , obj_tptr ) ) ) ; obj_tlen -= sizeof ( struct in_addr ) ; obj_tptr += sizeof ( struct in_addr ) ; break ; case RSVP_CTYPE_IPV6 : if ( obj_tlen < sizeof ( struct in6_addr ) ) return - 1 ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>IPv6<S2SV_blank>Receiver<S2SV_blank>Address:<S2SV_blank>%s" , ident , ip6addr_string ( ndo , obj_tptr ) ) ) ; obj_tlen -= sizeof ( struct in6_addr ) ; obj_tptr += sizeof ( struct in6_addr ) ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_NOTIFY_REQ : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_IPV4 : if ( obj_tlen < sizeof ( struct in_addr ) ) return - 1 ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>IPv4<S2SV_blank>Notify<S2SV_blank>Node<S2SV_blank>Address:<S2SV_blank>%s" , ident , ipaddr_string ( ndo , obj_tptr ) ) ) ; obj_tlen -= sizeof ( struct in_addr ) ; obj_tptr += sizeof ( struct in_addr ) ; break ; case RSVP_CTYPE_IPV6 : if ( obj_tlen < sizeof ( struct in6_addr ) ) return - 1 ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>IPv6<S2SV_blank>Notify<S2SV_blank>Node<S2SV_blank>Address:<S2SV_blank>%s" , ident , ip6addr_string ( ndo , obj_tptr ) ) ) ; obj_tlen -= sizeof ( struct in6_addr ) ; obj_tptr += sizeof ( struct in6_addr ) ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_SUGGESTED_LABEL : case RSVP_OBJ_UPSTREAM_LABEL : case RSVP_OBJ_RECOVERY_LABEL : case RSVP_OBJ_LABEL : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : while ( obj_tlen >= 4 ) { ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>Label:<S2SV_blank>%u" , ident , EXTRACT_32BITS ( obj_tptr ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; } break ; case RSVP_CTYPE_2 : if ( obj_tlen < 4 ) return - 1 ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>Generalized<S2SV_blank>Label:<S2SV_blank>%u" , ident , EXTRACT_32BITS ( obj_tptr ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; break ; case RSVP_CTYPE_3 : if ( obj_tlen < 12 ) return - 1 ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>Waveband<S2SV_blank>ID:<S2SV_blank>%u%s<S2SV_blank><S2SV_blank>Start<S2SV_blank>Label:<S2SV_blank>%u,<S2SV_blank>Stop<S2SV_blank>Label:<S2SV_blank>%u" , ident , EXTRACT_32BITS ( obj_tptr ) , ident , EXTRACT_32BITS ( obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 8 ) ) ) ; obj_tlen -= 12 ; obj_tptr += 12 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_STYLE : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < 4 ) return - 1 ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>Reservation<S2SV_blank>Style:<S2SV_blank>%s,<S2SV_blank>Flags:<S2SV_blank>[0x%02x]" , ident , tok2str ( rsvp_resstyle_values , "Unknown" , EXTRACT_24BITS ( obj_tptr + 1 ) ) , * ( obj_tptr ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_SENDER_TEMPLATE : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_IPV4 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>Source<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>Source<S2SV_blank>Port:<S2SV_blank>%u" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; break ; case RSVP_CTYPE_IPV6 : if ( obj_tlen < 20 ) return - 1 ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>Source<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>Source<S2SV_blank>Port:<S2SV_blank>%u" , ident , ip6addr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 18 ) ) ) ; obj_tlen -= 20 ; obj_tptr += 20 ; break ; case RSVP_CTYPE_13 : if ( obj_tlen < 40 ) return - 1 ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>IPv6<S2SV_blank>Tunnel<S2SV_blank>Sender<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>LSP<S2SV_blank>ID:<S2SV_blank>0x%04x" "%s<S2SV_blank><S2SV_blank>Sub-Group<S2SV_blank>Originator<S2SV_blank>ID:<S2SV_blank>%s,<S2SV_blank>Sub-Group<S2SV_blank>ID:<S2SV_blank>0x%04x" , ident , ip6addr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 18 ) , ident , ip6addr_string ( ndo , obj_tptr + 20 ) , EXTRACT_16BITS ( obj_tptr + 38 ) ) ) ; obj_tlen -= 40 ; obj_tptr += 40 ; break ; case RSVP_CTYPE_TUNNEL_IPV4 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>IPv4<S2SV_blank>Tunnel<S2SV_blank>Sender<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>LSP-ID:<S2SV_blank>0x%04x" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; break ; case RSVP_CTYPE_12 : if ( obj_tlen < 16 ) return - 1 ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>IPv4<S2SV_blank>Tunnel<S2SV_blank>Sender<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>LSP<S2SV_blank>ID:<S2SV_blank>0x%04x" "%s<S2SV_blank><S2SV_blank>Sub-Group<S2SV_blank>Originator<S2SV_blank>ID:<S2SV_blank>%s,<S2SV_blank>Sub-Group<S2SV_blank>ID:<S2SV_blank>0x%04x" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) , ident , ipaddr_string ( ndo , obj_tptr + 8 ) , EXTRACT_16BITS ( obj_tptr + 12 ) ) ) ; obj_tlen -= 16 ; obj_tptr += 16 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_LABEL_REQ : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : while ( obj_tlen >= 4 ) { ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>L3<S2SV_blank>Protocol<S2SV_blank>ID:<S2SV_blank>%s" , ident , tok2str ( ethertype_values , "Unknown<S2SV_blank>Protocol<S2SV_blank>(0x%04x)" , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; } break ; case RSVP_CTYPE_2 : if ( obj_tlen < 12 ) return - 1 ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>L3<S2SV_blank>Protocol<S2SV_blank>ID:<S2SV_blank>%s" , ident , tok2str ( ethertype_values , "Unknown<S2SV_blank>Protocol<S2SV_blank>(0x%04x)" , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ) ; ND_PRINT ( ( ndo , ",%s<S2SV_blank>merge<S2SV_blank>capability" , ( ( * ( obj_tptr + 4 ) ) & 0x80 ) ? "no" : "" ) ) ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>Minimum<S2SV_blank>VPI/VCI:<S2SV_blank>%u/%u" , ident , ( EXTRACT_16BITS ( obj_tptr + 4 ) ) & 0xfff , ( EXTRACT_16BITS ( obj_tptr + 6 ) ) & 0xfff ) ) ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>Maximum<S2SV_blank>VPI/VCI:<S2SV_blank>%u/%u" , ident , ( EXTRACT_16BITS ( obj_tptr + 8 ) ) & 0xfff , ( EXTRACT_16BITS ( obj_tptr + 10 ) ) & 0xfff ) ) ; obj_tlen -= 12 ; obj_tptr += 12 ; break ; case RSVP_CTYPE_3 : if ( obj_tlen < 12 ) return - 1 ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>L3<S2SV_blank>Protocol<S2SV_blank>ID:<S2SV_blank>%s" , ident , tok2str ( ethertype_values , "Unknown<S2SV_blank>Protocol<S2SV_blank>(0x%04x)" , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ) ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>Minimum/Maximum<S2SV_blank>DLCI:<S2SV_blank>%u/%u,<S2SV_blank>%s%s<S2SV_blank>bit<S2SV_blank>DLCI" , ident , ( EXTRACT_32BITS ( obj_tptr + 4 ) ) & 0x7fffff , ( EXTRACT_32BITS ( obj_tptr + 8 ) ) & 0x7fffff , ( ( ( EXTRACT_16BITS ( obj_tptr + 4 ) >> 7 ) & 3 ) == 0 ) ? "10" : "" , ( ( ( EXTRACT_16BITS ( obj_tptr + 4 ) >> 7 ) & 3 ) == 2 ) ? "23" : "" ) ) ; obj_tlen -= 12 ; obj_tptr += 12 ; break ; case RSVP_CTYPE_4 : if ( obj_tlen < 4 ) return - 1 ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>LSP<S2SV_blank>Encoding<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u)" , ident , tok2str ( gmpls_encoding_values , "Unknown" , * obj_tptr ) , * obj_tptr ) ) ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>Switching<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>Payload<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%04x)" , ident , tok2str ( gmpls_switch_cap_values , "Unknown" , * ( obj_tptr + 1 ) ) , * ( obj_tptr + 1 ) , tok2str ( gmpls_payload_values , "Unknown" , EXTRACT_16BITS ( obj_tptr + 2 ) ) , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_RRO : case RSVP_OBJ_ERO : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_IPV4 : while ( obj_tlen >= 4 ) { u_char length ; ND_TCHECK2 ( * obj_tptr , 4 ) ; length = * ( obj_tptr + 1 ) ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>Subobject<S2SV_blank>Type:<S2SV_blank>%s,<S2SV_blank>length<S2SV_blank>%u" , ident , tok2str ( rsvp_obj_xro_values , "Unknown<S2SV_blank>%u" , RSVP_OBJ_XRO_MASK_SUBOBJ ( * obj_tptr ) ) , length ) ) ; if ( length == 0 ) { ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>ERROR:<S2SV_blank>zero<S2SV_blank>length<S2SV_blank>ERO<S2SV_blank>subtype" , ident ) ) ; break ; } switch ( RSVP_OBJ_XRO_MASK_SUBOBJ ( * obj_tptr ) ) { u_char prefix_length ; case RSVP_OBJ_XRO_IPV4 : if ( length != 8 ) { ND_PRINT ( ( ndo , "<S2SV_blank>ERROR:<S2SV_blank>length<S2SV_blank>!=<S2SV_blank>8" ) ) ; goto invalid ; } ND_TCHECK2 ( * obj_tptr , 8 ) ; prefix_length = * ( obj_tptr + 6 ) ; if ( prefix_length != 32 ) { ND_PRINT ( ( ndo , "<S2SV_blank>ERROR:<S2SV_blank>Prefix<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>32" , prefix_length ) ) ; goto invalid ; } ND_PRINT ( ( ndo , ",<S2SV_blank>%s,<S2SV_blank>%s/%u,<S2SV_blank>Flags:<S2SV_blank>[%s]" , RSVP_OBJ_XRO_MASK_LOOSE ( * obj_tptr ) ? "Loose" : "Strict" , ipaddr_string ( ndo , obj_tptr + 2 ) , * ( obj_tptr + 6 ) , bittok2str ( rsvp_obj_rro_flag_values , "none" , * ( obj_tptr + 7 ) ) ) ) ; break ; case RSVP_OBJ_XRO_LABEL : if ( length != 8 ) { ND_PRINT ( ( ndo , "<S2SV_blank>ERROR:<S2SV_blank>length<S2SV_blank>!=<S2SV_blank>8" ) ) ; goto invalid ; } ND_TCHECK2 ( * obj_tptr , 8 ) ; ND_PRINT ( ( ndo , ",<S2SV_blank>Flags:<S2SV_blank>[%s]<S2SV_blank>(%#x),<S2SV_blank>Class-Type:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>%u" , bittok2str ( rsvp_obj_rro_label_flag_values , "none" , * ( obj_tptr + 2 ) ) , * ( obj_tptr + 2 ) , tok2str ( rsvp_ctype_values , "Unknown" , * ( obj_tptr + 3 ) + 256 * RSVP_OBJ_RRO ) , * ( obj_tptr + 3 ) , EXTRACT_32BITS ( obj_tptr + 4 ) ) ) ; } obj_tlen -= * ( obj_tptr + 1 ) ; obj_tptr += * ( obj_tptr + 1 ) ; } break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_HELLO : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : case RSVP_CTYPE_2 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>Source<S2SV_blank>Instance:<S2SV_blank>0x%08x,<S2SV_blank>Destination<S2SV_blank>Instance:<S2SV_blank>0x%08x" , ident , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr + 4 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_RESTART_CAPABILITY : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>Restart<S2SV_blank><S2SV_blank>Time:<S2SV_blank>%ums,<S2SV_blank>Recovery<S2SV_blank>Time:<S2SV_blank>%ums" , ident , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr + 4 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_SESSION_ATTRIBUTE : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_TUNNEL_IPV4 : if ( obj_tlen < 4 ) return - 1 ; namelen = * ( obj_tptr + 3 ) ; if ( obj_tlen < 4 + namelen ) return - 1 ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>Session<S2SV_blank>Name:<S2SV_blank>" , ident ) ) ; for ( i = 0 ; i < namelen ; i ++ ) safeputchar ( ndo , * ( obj_tptr + 4 + i ) ) ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>Setup<S2SV_blank>Priority:<S2SV_blank>%u,<S2SV_blank>Holding<S2SV_blank>Priority:<S2SV_blank>%u,<S2SV_blank>Flags:<S2SV_blank>[%s]<S2SV_blank>(%#x)" , ident , ( int ) * obj_tptr , ( int ) * ( obj_tptr + 1 ) , bittok2str ( rsvp_session_attribute_flag_values , "none" , * ( obj_tptr + 2 ) ) , * ( obj_tptr + 2 ) ) ) ; obj_tlen -= 4 + * ( obj_tptr + 3 ) ; obj_tptr += 4 + * ( obj_tptr + 3 ) ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_GENERALIZED_UNI : switch ( rsvp_obj_ctype ) { int subobj_type , af , subobj_len , total_subobj_len ; case RSVP_CTYPE_1 : if ( obj_tlen < 4 ) return - 1 ; total_subobj_len = obj_tlen ; while ( total_subobj_len > 0 ) { if ( total_subobj_len < 4 ) goto invalid ; subobj_len = EXTRACT_16BITS ( obj_tptr ) ; subobj_type = ( EXTRACT_16BITS ( obj_tptr + 2 ) ) >> 8 ; af = ( EXTRACT_16BITS ( obj_tptr + 2 ) ) & 0x00FF ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>Subobject<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>AF:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>length:<S2SV_blank>%u" , ident , tok2str ( rsvp_obj_generalized_uni_values , "Unknown" , subobj_type ) , subobj_type , tok2str ( af_values , "Unknown" , af ) , af , subobj_len ) ) ; if ( subobj_len < 4 || subobj_len > total_subobj_len ) goto invalid ; switch ( subobj_type ) { case RSVP_GEN_UNI_SUBOBJ_SOURCE_TNA_ADDRESS : case RSVP_GEN_UNI_SUBOBJ_DESTINATION_TNA_ADDRESS : switch ( af ) { case AFNUM_INET : if ( subobj_len < 8 ) return - 1 ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>UNI<S2SV_blank>IPv4<S2SV_blank>TNA<S2SV_blank>address:<S2SV_blank>%s" , ident , ipaddr_string ( ndo , obj_tptr + 4 ) ) ) ; break ; case AFNUM_INET6 : if ( subobj_len < 20 ) return - 1 ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>UNI<S2SV_blank>IPv6<S2SV_blank>TNA<S2SV_blank>address:<S2SV_blank>%s" , ident , ip6addr_string ( ndo , obj_tptr + 4 ) ) ) ; break ; case AFNUM_NSAP : if ( subobj_len ) { hexdump = TRUE ; } break ; } break ; case RSVP_GEN_UNI_SUBOBJ_DIVERSITY : if ( subobj_len ) { hexdump = TRUE ; } break ; case RSVP_GEN_UNI_SUBOBJ_EGRESS_LABEL : if ( subobj_len < 16 ) { return - 1 ; } ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>U-bit:<S2SV_blank>%x,<S2SV_blank>Label<S2SV_blank>type:<S2SV_blank>%u,<S2SV_blank>Logical<S2SV_blank>port<S2SV_blank>id:<S2SV_blank>%u,<S2SV_blank>Label:<S2SV_blank>%u" , ident , ( ( EXTRACT_32BITS ( obj_tptr + 4 ) ) >> 31 ) , ( ( EXTRACT_32BITS ( obj_tptr + 4 ) ) & 0xFF ) , EXTRACT_32BITS ( obj_tptr + 8 ) , EXTRACT_32BITS ( obj_tptr + 12 ) ) ) ; break ; case RSVP_GEN_UNI_SUBOBJ_SERVICE_LEVEL : if ( subobj_len < 8 ) { return - 1 ; } ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Service<S2SV_blank>level:<S2SV_blank>%u" , ident , ( EXTRACT_32BITS ( obj_tptr + 4 ) ) >> 24 ) ) ; break ; default : hexdump = TRUE ; break ; } total_subobj_len -= subobj_len ; obj_tptr += subobj_len ; obj_tlen += subobj_len ; } if ( total_subobj_len ) { hexdump = TRUE ; } break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_RSVP_HOP : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_3 : case RSVP_CTYPE_IPV4 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>Previous/Next<S2SV_blank>Interface:<S2SV_blank>%s,<S2SV_blank>Logical<S2SV_blank>Interface<S2SV_blank>Handle:<S2SV_blank>0x%08x" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_32BITS ( obj_tptr + 4 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; if ( obj_tlen ) hexdump = TRUE ; break ; case RSVP_CTYPE_4 : case RSVP_CTYPE_IPV6 : if ( obj_tlen < 20 ) return - 1 ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>Previous/Next<S2SV_blank>Interface:<S2SV_blank>%s,<S2SV_blank>Logical<S2SV_blank>Interface<S2SV_blank>Handle:<S2SV_blank>0x%08x" , ident , ip6addr_string ( ndo , obj_tptr ) , EXTRACT_32BITS ( obj_tptr + 16 ) ) ) ; obj_tlen -= 20 ; obj_tptr += 20 ; hexdump = TRUE ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_TIME_VALUES : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < 4 ) return - 1 ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>Refresh<S2SV_blank>Period:<S2SV_blank>%ums" , ident , EXTRACT_32BITS ( obj_tptr ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_SENDER_TSPEC : case RSVP_OBJ_ADSPEC : case RSVP_OBJ_FLOWSPEC : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_2 : if ( obj_tlen < 4 ) return - 1 ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>Msg-Version:<S2SV_blank>%u,<S2SV_blank>length:<S2SV_blank>%u" , ident , ( * obj_tptr & 0xf0 ) >> 4 , EXTRACT_16BITS ( obj_tptr + 2 ) << 2 ) ) ; obj_tptr += 4 ; obj_tlen -= 4 ; while ( obj_tlen >= 4 ) { intserv_serv_tlen = EXTRACT_16BITS ( obj_tptr + 2 ) << 2 ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>Service<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>break<S2SV_blank>bit<S2SV_blank>%s<S2SV_blank>set,<S2SV_blank>Service<S2SV_blank>length:<S2SV_blank>%u" , ident , tok2str ( rsvp_intserv_service_type_values , "unknown" , * ( obj_tptr ) ) , * ( obj_tptr ) , ( * ( obj_tptr + 1 ) & 0x80 ) ? "" : "not" , intserv_serv_tlen ) ) ; obj_tptr += 4 ; obj_tlen -= 4 ; while ( intserv_serv_tlen >= 4 ) { processed = rsvp_intserv_print ( ndo , obj_tptr , obj_tlen ) ; if ( processed == 0 ) break ; obj_tlen -= processed ; intserv_serv_tlen -= processed ; obj_tptr += processed ; } } break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_FILTERSPEC : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_IPV4 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>Source<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>Source<S2SV_blank>Port:<S2SV_blank>%u" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; break ; case RSVP_CTYPE_IPV6 : if ( obj_tlen < 20 ) return - 1 ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>Source<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>Source<S2SV_blank>Port:<S2SV_blank>%u" , ident , ip6addr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 18 ) ) ) ; obj_tlen -= 20 ; obj_tptr += 20 ; break ; case RSVP_CTYPE_3 : if ( obj_tlen < 20 ) return - 1 ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>Source<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>Flow<S2SV_blank>Label:<S2SV_blank>%u" , ident , ip6addr_string ( ndo , obj_tptr ) , EXTRACT_24BITS ( obj_tptr + 17 ) ) ) ; obj_tlen -= 20 ; obj_tptr += 20 ; break ; case RSVP_CTYPE_TUNNEL_IPV6 : if ( obj_tlen < 20 ) return - 1 ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>Source<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>LSP-ID:<S2SV_blank>0x%04x" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 18 ) ) ) ; obj_tlen -= 20 ; obj_tptr += 20 ; break ; case RSVP_CTYPE_13 : if ( obj_tlen < 40 ) return - 1 ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>IPv6<S2SV_blank>Tunnel<S2SV_blank>Sender<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>LSP<S2SV_blank>ID:<S2SV_blank>0x%04x" "%s<S2SV_blank><S2SV_blank>Sub-Group<S2SV_blank>Originator<S2SV_blank>ID:<S2SV_blank>%s,<S2SV_blank>Sub-Group<S2SV_blank>ID:<S2SV_blank>0x%04x" , ident , ip6addr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 18 ) , ident , ip6addr_string ( ndo , obj_tptr + 20 ) , EXTRACT_16BITS ( obj_tptr + 38 ) ) ) ; obj_tlen -= 40 ; obj_tptr += 40 ; break ; case RSVP_CTYPE_TUNNEL_IPV4 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>Source<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>LSP-ID:<S2SV_blank>0x%04x" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; break ; case RSVP_CTYPE_12 : if ( obj_tlen < 16 ) return - 1 ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>IPv4<S2SV_blank>Tunnel<S2SV_blank>Sender<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>LSP<S2SV_blank>ID:<S2SV_blank>0x%04x" "%s<S2SV_blank><S2SV_blank>Sub-Group<S2SV_blank>Originator<S2SV_blank>ID:<S2SV_blank>%s,<S2SV_blank>Sub-Group<S2SV_blank>ID:<S2SV_blank>0x%04x" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) , ident , ipaddr_string ( ndo , obj_tptr + 8 ) , EXTRACT_16BITS ( obj_tptr + 12 ) ) ) ; obj_tlen -= 16 ; obj_tptr += 16 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_FASTREROUTE : obj_ptr . rsvp_obj_frr = ( const struct rsvp_obj_frr_t * ) obj_tptr ; switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < sizeof ( struct rsvp_obj_frr_t ) ) return - 1 ; bw . i = EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> bandwidth ) ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>Setup<S2SV_blank>Priority:<S2SV_blank>%u,<S2SV_blank>Holding<S2SV_blank>Priority:<S2SV_blank>%u,<S2SV_blank>Hop-limit:<S2SV_blank>%u,<S2SV_blank>Bandwidth:<S2SV_blank>%.10g<S2SV_blank>Mbps" , ident , ( int ) obj_ptr . rsvp_obj_frr -> setup_prio , ( int ) obj_ptr . rsvp_obj_frr -> hold_prio , ( int ) obj_ptr . rsvp_obj_frr -> hop_limit , bw . f * 8 / 1000000 ) ) ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>Include-any:<S2SV_blank>0x%08x,<S2SV_blank>Exclude-any:<S2SV_blank>0x%08x,<S2SV_blank>Include-all:<S2SV_blank>0x%08x" , ident , EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> include_any ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> exclude_any ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> include_all ) ) ) ; obj_tlen -= sizeof ( struct rsvp_obj_frr_t ) ; obj_tptr += sizeof ( struct rsvp_obj_frr_t ) ; break ; case RSVP_CTYPE_TUNNEL_IPV4 : if ( obj_tlen < 16 ) return - 1 ; bw . i = EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> bandwidth ) ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>Setup<S2SV_blank>Priority:<S2SV_blank>%u,<S2SV_blank>Holding<S2SV_blank>Priority:<S2SV_blank>%u,<S2SV_blank>Hop-limit:<S2SV_blank>%u,<S2SV_blank>Bandwidth:<S2SV_blank>%.10g<S2SV_blank>Mbps" , ident , ( int ) obj_ptr . rsvp_obj_frr -> setup_prio , ( int ) obj_ptr . rsvp_obj_frr -> hold_prio , ( int ) obj_ptr . rsvp_obj_frr -> hop_limit , bw . f * 8 / 1000000 ) ) ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>Include<S2SV_blank>Colors:<S2SV_blank>0x%08x,<S2SV_blank>Exclude<S2SV_blank>Colors:<S2SV_blank>0x%08x" , ident , EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> include_any ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> exclude_any ) ) ) ; obj_tlen -= 16 ; obj_tptr += 16 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_DETOUR : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_TUNNEL_IPV4 : while ( obj_tlen >= 8 ) { ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>PLR-ID:<S2SV_blank>%s,<S2SV_blank>Avoid-Node-ID:<S2SV_blank>%s" , ident , ipaddr_string ( ndo , obj_tptr ) , ipaddr_string ( ndo , obj_tptr + 4 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; } break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_CLASSTYPE : case RSVP_OBJ_CLASSTYPE_OLD : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : <S2SV_StartBug> ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>CT:<S2SV_blank>%u" , <S2SV_EndBug> ident , EXTRACT_32BITS ( obj_tptr ) & 0x7 ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_ERROR_SPEC : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_3 : case RSVP_CTYPE_IPV4 : if ( obj_tlen < 8 ) return - 1 ; error_code = * ( obj_tptr + 5 ) ; error_value = EXTRACT_16BITS ( obj_tptr + 6 ) ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>Error<S2SV_blank>Node<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>Flags:<S2SV_blank>[0x%02x]%s<S2SV_blank><S2SV_blank>Error<S2SV_blank>Code:<S2SV_blank>%s<S2SV_blank>(%u)" , ident , ipaddr_string ( ndo , obj_tptr ) , * ( obj_tptr + 4 ) , ident , tok2str ( rsvp_obj_error_code_values , "unknown" , error_code ) , error_code ) ) ; switch ( error_code ) { case RSVP_OBJ_ERROR_SPEC_CODE_ROUTING : ND_PRINT ( ( ndo , ",<S2SV_blank>Error<S2SV_blank>Value:<S2SV_blank>%s<S2SV_blank>(%u)" , tok2str ( rsvp_obj_error_code_routing_values , "unknown" , error_value ) , error_value ) ) ; break ; case RSVP_OBJ_ERROR_SPEC_CODE_DIFFSERV_TE : case RSVP_OBJ_ERROR_SPEC_CODE_DIFFSERV_TE_OLD : ND_PRINT ( ( ndo , ",<S2SV_blank>Error<S2SV_blank>Value:<S2SV_blank>%s<S2SV_blank>(%u)" , tok2str ( rsvp_obj_error_code_diffserv_te_values , "unknown" , error_value ) , error_value ) ) ; break ; default : ND_PRINT ( ( ndo , ",<S2SV_blank>Unknown<S2SV_blank>Error<S2SV_blank>Value<S2SV_blank>(%u)" , error_value ) ) ; break ; } obj_tlen -= 8 ; obj_tptr += 8 ; break ; case RSVP_CTYPE_4 : case RSVP_CTYPE_IPV6 : if ( obj_tlen < 20 ) return - 1 ; error_code = * ( obj_tptr + 17 ) ; error_value = EXTRACT_16BITS ( obj_tptr + 18 ) ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>Error<S2SV_blank>Node<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>Flags:<S2SV_blank>[0x%02x]%s<S2SV_blank><S2SV_blank>Error<S2SV_blank>Code:<S2SV_blank>%s<S2SV_blank>(%u)" , ident , ip6addr_string ( ndo , obj_tptr ) , * ( obj_tptr + 16 ) , ident , tok2str ( rsvp_obj_error_code_values , "unknown" , error_code ) , error_code ) ) ; switch ( error_code ) { case RSVP_OBJ_ERROR_SPEC_CODE_ROUTING : ND_PRINT ( ( ndo , ",<S2SV_blank>Error<S2SV_blank>Value:<S2SV_blank>%s<S2SV_blank>(%u)" , tok2str ( rsvp_obj_error_code_routing_values , "unknown" , error_value ) , error_value ) ) ; break ; default : break ; } obj_tlen -= 20 ; obj_tptr += 20 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_PROPERTIES : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < 4 ) return - 1 ; padbytes = EXTRACT_16BITS ( obj_tptr + 2 ) ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>TLV<S2SV_blank>count:<S2SV_blank>%u,<S2SV_blank>padding<S2SV_blank>bytes:<S2SV_blank>%u" , ident , EXTRACT_16BITS ( obj_tptr ) , padbytes ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; while ( obj_tlen >= 2 + padbytes ) { ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>TLV<S2SV_blank>(0x%02x),<S2SV_blank>length:<S2SV_blank>%u" , ident , tok2str ( rsvp_obj_prop_tlv_values , "unknown" , * obj_tptr ) , * obj_tptr , * ( obj_tptr + 1 ) ) ) ; if ( obj_tlen < * ( obj_tptr + 1 ) ) return - 1 ; if ( * ( obj_tptr + 1 ) < 2 ) return - 1 ; print_unknown_data ( ndo , obj_tptr + 2 , "\\n\\t\\t" , * ( obj_tptr + 1 ) - 2 ) ; obj_tlen -= * ( obj_tptr + 1 ) ; obj_tptr += * ( obj_tptr + 1 ) ; } break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_MESSAGE_ID : case RSVP_OBJ_MESSAGE_ID_ACK : case RSVP_OBJ_MESSAGE_ID_LIST : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : case RSVP_CTYPE_2 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>Flags<S2SV_blank>[0x%02x],<S2SV_blank>epoch:<S2SV_blank>%u" , ident , * obj_tptr , EXTRACT_24BITS ( obj_tptr + 1 ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; while ( obj_tlen >= 4 ) { ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Message-ID<S2SV_blank>0x%08x<S2SV_blank>(%u)" , ident , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; } break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_INTEGRITY : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < sizeof ( struct rsvp_obj_integrity_t ) ) return - 1 ; obj_ptr . rsvp_obj_integrity = ( const struct rsvp_obj_integrity_t * ) obj_tptr ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>Key-ID<S2SV_blank>0x%04x%08x,<S2SV_blank>Sequence<S2SV_blank>0x%08x%08x,<S2SV_blank>Flags<S2SV_blank>[%s]" , ident , EXTRACT_16BITS ( obj_ptr . rsvp_obj_integrity -> key_id ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_integrity -> key_id + 2 ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_integrity -> sequence ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_integrity -> sequence + 4 ) , bittok2str ( rsvp_obj_integrity_flag_values , "none" , obj_ptr . rsvp_obj_integrity -> flags ) ) ) ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>MD5-sum<S2SV_blank>0x%08x%08x%08x%08x<S2SV_blank>" , ident , EXTRACT_32BITS ( obj_ptr . rsvp_obj_integrity -> digest ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_integrity -> digest + 4 ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_integrity -> digest + 8 ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_integrity -> digest + 12 ) ) ) ; sigcheck = signature_verify ( ndo , pptr , plen , obj_ptr . rsvp_obj_integrity -> digest , rsvp_clear_checksum , rsvp_com_header ) ; ND_PRINT ( ( ndo , "<S2SV_blank>(%s)" , tok2str ( signature_check_values , "Unknown" , sigcheck ) ) ) ; obj_tlen += sizeof ( struct rsvp_obj_integrity_t ) ; obj_tptr += sizeof ( struct rsvp_obj_integrity_t ) ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_ADMIN_STATUS : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < 4 ) return - 1 ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>Flags<S2SV_blank>[%s]" , ident , bittok2str ( rsvp_obj_admin_status_flag_values , "none" , EXTRACT_32BITS ( obj_tptr ) ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_LABEL_SET : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < 4 ) return - 1 ; action = ( EXTRACT_16BITS ( obj_tptr ) >> 8 ) ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>Action:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>Label<S2SV_blank>type:<S2SV_blank>%u" , ident , tok2str ( rsvp_obj_label_set_action_values , "Unknown" , action ) , action , ( ( EXTRACT_32BITS ( obj_tptr ) & 0x7F ) ) ) ) ; switch ( action ) { case LABEL_SET_INCLUSIVE_RANGE : case LABEL_SET_EXCLUSIVE_RANGE : if ( obj_tlen < 12 ) return - 1 ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>Start<S2SV_blank>range:<S2SV_blank>%u,<S2SV_blank>End<S2SV_blank>range:<S2SV_blank>%u" , ident , EXTRACT_32BITS ( obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 8 ) ) ) ; obj_tlen -= 12 ; obj_tptr += 12 ; break ; default : obj_tlen -= 4 ; obj_tptr += 4 ; subchannel = 1 ; while ( obj_tlen >= 4 ) { ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>Subchannel<S2SV_blank>#%u:<S2SV_blank>%u" , ident , subchannel , EXTRACT_32BITS ( obj_tptr ) ) ) ; obj_tptr += 4 ; obj_tlen -= 4 ; subchannel ++ ; } break ; } break ; default : hexdump = TRUE ; } case RSVP_OBJ_S2L : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_IPV4 : if ( obj_tlen < 4 ) return - 1 ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>Sub-LSP<S2SV_blank>destination<S2SV_blank>address:<S2SV_blank>%s" , ident , ipaddr_string ( ndo , obj_tptr ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; break ; case RSVP_CTYPE_IPV6 : if ( obj_tlen < 16 ) return - 1 ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>Sub-LSP<S2SV_blank>destination<S2SV_blank>address:<S2SV_blank>%s" , ident , ip6addr_string ( ndo , obj_tptr ) ) ) ; obj_tlen -= 16 ; obj_tptr += 16 ; break ; default : hexdump = TRUE ; } case RSVP_OBJ_SCOPE : case RSVP_OBJ_POLICY_DATA : case RSVP_OBJ_ACCEPT_LABEL_SET : case RSVP_OBJ_PROTECTION : default : if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , obj_tptr , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , obj_tlen ) ; break ; } if ( ndo -> ndo_vflag > 1 || hexdump == TRUE ) print_unknown_data ( ndo , tptr + sizeof ( struct rsvp_object_header ) , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , rsvp_obj_len - sizeof ( struct rsvp_object_header ) ) ; tptr += rsvp_obj_len ; tlen -= rsvp_obj_len ; } return 0 ; invalid : ND_PRINT ( ( ndo , "%s" , istr ) ) ; return - 1 ; trunc : ND_PRINT ( ( ndo , "\\n\\t\\t" ) ) ; ND_PRINT ( ( ndo , "%s" , tstr ) ) ; return - 1 ; }
CWE-125 static int rx_cache_find ( const struct rx_header * rxh , const struct ip * ip , int sport , int32_t * opcode ) { int i ; struct rx_cache_entry * rxent ; uint32_t clip ; uint32_t sip ; UNALIGNED_MEMCPY ( & clip , & ip -> ip_dst , sizeof ( uint32_t ) ) ; UNALIGNED_MEMCPY ( & sip , & ip -> ip_src , sizeof ( uint32_t ) ) ; i = rx_cache_hint ; do { rxent = & rx_cache [ i ] ; if ( rxent -> callnum == EXTRACT_32BITS ( & rxh -> callNumber ) && rxent -> client . s_addr == clip && rxent -> server . s_addr == sip && <S2SV_StartBug> rxent -> serviceId == EXTRACT_32BITS ( & rxh -> serviceId ) && <S2SV_EndBug> rxent -> dport == sport ) { rx_cache_hint = i ; * opcode = rxent -> opcode ; return ( 1 ) ; } if ( ++ i >= RX_CACHE_SIZE ) i = 0 ; } while ( i != rx_cache_hint ) ; return ( 0 ) ; }
CWE-125 static void rx_cache_insert ( netdissect_options * ndo , const u_char * bp , const struct ip * ip , int dport ) { struct rx_cache_entry * rxent ; const struct rx_header * rxh = ( const struct rx_header * ) bp ; if ( ndo -> ndo_snapend - bp + 1 <= ( int ) ( sizeof ( struct rx_header ) + sizeof ( int32_t ) ) ) return ; rxent = & rx_cache [ rx_cache_next ] ; if ( ++ rx_cache_next >= RX_CACHE_SIZE ) rx_cache_next = 0 ; rxent -> callnum = EXTRACT_32BITS ( & rxh -> callNumber ) ; UNALIGNED_MEMCPY ( & rxent -> client , & ip -> ip_src , sizeof ( uint32_t ) ) ; UNALIGNED_MEMCPY ( & rxent -> server , & ip -> ip_dst , sizeof ( uint32_t ) ) ; rxent -> dport = dport ; <S2SV_StartBug> rxent -> serviceId = EXTRACT_32BITS ( & rxh -> serviceId ) ; <S2SV_EndBug> rxent -> opcode = EXTRACT_32BITS ( bp + sizeof ( struct rx_header ) ) ; }
CWE-125 static void icmp6_nodeinfo_print ( netdissect_options * ndo , u_int icmp6len , const u_char * bp , const u_char * ep ) { const struct icmp6_nodeinfo * ni6 ; const struct icmp6_hdr * dp ; const u_char * cp ; size_t siz , i ; int needcomma ; if ( ep < bp ) return ; dp = ( const struct icmp6_hdr * ) bp ; ni6 = ( const struct icmp6_nodeinfo * ) bp ; siz = ep - bp ; switch ( ni6 -> ni_type ) { case ICMP6_NI_QUERY : if ( siz == sizeof ( * dp ) + 4 ) { ND_PRINT ( ( ndo , "<S2SV_blank>who-are-you<S2SV_blank>request" ) ) ; break ; } ND_PRINT ( ( ndo , "<S2SV_blank>node<S2SV_blank>information<S2SV_blank>query" ) ) ; ND_TCHECK2 ( * dp , sizeof ( * ni6 ) ) ; ni6 = ( const struct icmp6_nodeinfo * ) dp ; ND_PRINT ( ( ndo , "<S2SV_blank>(" ) ) ; switch ( EXTRACT_16BITS ( & ni6 -> ni_qtype ) ) { case NI_QTYPE_NOOP : ND_PRINT ( ( ndo , "noop" ) ) ; break ; case NI_QTYPE_SUPTYPES : ND_PRINT ( ( ndo , "supported<S2SV_blank>qtypes" ) ) ; i = EXTRACT_16BITS ( & ni6 -> ni_flags ) ; if ( i ) ND_PRINT ( ( ndo , "<S2SV_blank>[%s]" , ( i & 0x01 ) ? "C" : "" ) ) ; break ; case NI_QTYPE_FQDN : ND_PRINT ( ( ndo , "DNS<S2SV_blank>name" ) ) ; break ; case NI_QTYPE_NODEADDR : ND_PRINT ( ( ndo , "node<S2SV_blank>addresses" ) ) ; i = ni6 -> ni_flags ; if ( ! i ) break ; ND_PRINT ( ( ndo , "<S2SV_blank>[%s%s%s%s%s%s]" , ( i & NI_NODEADDR_FLAG_ANYCAST ) ? "a" : "" , ( i & NI_NODEADDR_FLAG_GLOBAL ) ? "G" : "" , ( i & NI_NODEADDR_FLAG_SITELOCAL ) ? "S" : "" , ( i & NI_NODEADDR_FLAG_LINKLOCAL ) ? "L" : "" , ( i & NI_NODEADDR_FLAG_COMPAT ) ? "C" : "" , ( i & NI_NODEADDR_FLAG_ALL ) ? "A" : "" ) ) ; break ; default : ND_PRINT ( ( ndo , "unknown" ) ) ; break ; } if ( ni6 -> ni_qtype == NI_QTYPE_NOOP || ni6 -> ni_qtype == NI_QTYPE_SUPTYPES ) { if ( siz != sizeof ( * ni6 ) ) if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ",<S2SV_blank>invalid<S2SV_blank>len" ) ) ; ND_PRINT ( ( ndo , ")" ) ) ; break ; } if ( siz == sizeof ( * ni6 ) ) { ND_PRINT ( ( ndo , ",<S2SV_blank>03<S2SV_blank>draft" ) ) ; ND_PRINT ( ( ndo , ")" ) ) ; break ; } switch ( ni6 -> ni_code ) { case ICMP6_NI_SUBJ_IPV6 : if ( ! ND_TTEST2 ( * dp , sizeof ( * ni6 ) + sizeof ( struct in6_addr ) ) ) break ; if ( siz != sizeof ( * ni6 ) + sizeof ( struct in6_addr ) ) { if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ",<S2SV_blank>invalid<S2SV_blank>subject<S2SV_blank>len" ) ) ; break ; } ND_PRINT ( ( ndo , ",<S2SV_blank>subject=%s" , ip6addr_string ( ndo , ni6 + 1 ) ) ) ; break ; case ICMP6_NI_SUBJ_FQDN : ND_PRINT ( ( ndo , ",<S2SV_blank>subject=DNS<S2SV_blank>name" ) ) ; cp = ( const u_char * ) ( ni6 + 1 ) ; if ( cp [ 0 ] == ep - cp - 1 ) { if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ",<S2SV_blank>03<S2SV_blank>draft" ) ) ; cp ++ ; ND_PRINT ( ( ndo , ",<S2SV_blank>\\"" ) ) ; while ( cp < ep ) { safeputchar ( ndo , * cp ) ; cp ++ ; } ND_PRINT ( ( ndo , "\\"" ) ) ; } else dnsname_print ( ndo , cp , ep ) ; break ; case ICMP6_NI_SUBJ_IPV4 : if ( ! ND_TTEST2 ( * dp , sizeof ( * ni6 ) + sizeof ( struct in_addr ) ) ) break ; if ( siz != sizeof ( * ni6 ) + sizeof ( struct in_addr ) ) { if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ",<S2SV_blank>invalid<S2SV_blank>subject<S2SV_blank>len" ) ) ; break ; } ND_PRINT ( ( ndo , ",<S2SV_blank>subject=%s" , ipaddr_string ( ndo , ni6 + 1 ) ) ) ; break ; default : ND_PRINT ( ( ndo , ",<S2SV_blank>unknown<S2SV_blank>subject" ) ) ; break ; } ND_PRINT ( ( ndo , ")" ) ) ; break ; case ICMP6_NI_REPLY : if ( icmp6len > siz ) { ND_PRINT ( ( ndo , "[|icmp6:<S2SV_blank>node<S2SV_blank>information<S2SV_blank>reply]" ) ) ; break ; } needcomma = 0 ; ND_TCHECK2 ( * dp , sizeof ( * ni6 ) ) ; ni6 = ( const struct icmp6_nodeinfo * ) dp ; ND_PRINT ( ( ndo , "<S2SV_blank>node<S2SV_blank>information<S2SV_blank>reply" ) ) ; ND_PRINT ( ( ndo , "<S2SV_blank>(" ) ) ; switch ( ni6 -> ni_code ) { case ICMP6_NI_SUCCESS : if ( ndo -> ndo_vflag ) { ND_PRINT ( ( ndo , "success" ) ) ; needcomma ++ ; } break ; case ICMP6_NI_REFUSED : ND_PRINT ( ( ndo , "refused" ) ) ; needcomma ++ ; if ( siz != sizeof ( * ni6 ) ) if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ",<S2SV_blank>invalid<S2SV_blank>length" ) ) ; break ; case ICMP6_NI_UNKNOWN : ND_PRINT ( ( ndo , "unknown" ) ) ; needcomma ++ ; if ( siz != sizeof ( * ni6 ) ) if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ",<S2SV_blank>invalid<S2SV_blank>length" ) ) ; break ; } if ( ni6 -> ni_code != ICMP6_NI_SUCCESS ) { ND_PRINT ( ( ndo , ")" ) ) ; break ; } switch ( EXTRACT_16BITS ( & ni6 -> ni_qtype ) ) { case NI_QTYPE_NOOP : if ( needcomma ) ND_PRINT ( ( ndo , ",<S2SV_blank>" ) ) ; ND_PRINT ( ( ndo , "noop" ) ) ; if ( siz != sizeof ( * ni6 ) ) if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ",<S2SV_blank>invalid<S2SV_blank>length" ) ) ; break ; case NI_QTYPE_SUPTYPES : if ( needcomma ) ND_PRINT ( ( ndo , ",<S2SV_blank>" ) ) ; ND_PRINT ( ( ndo , "supported<S2SV_blank>qtypes" ) ) ; i = EXTRACT_16BITS ( & ni6 -> ni_flags ) ; if ( i ) ND_PRINT ( ( ndo , "<S2SV_blank>[%s]" , ( i & 0x01 ) ? "C" : "" ) ) ; break ; case NI_QTYPE_FQDN : if ( needcomma ) ND_PRINT ( ( ndo , ",<S2SV_blank>" ) ) ; ND_PRINT ( ( ndo , "DNS<S2SV_blank>name" ) ) ; cp = ( const u_char * ) ( ni6 + 1 ) + 4 ; ND_TCHECK ( cp [ 0 ] ) ; if ( cp [ 0 ] == ep - cp - 1 ) { if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ",<S2SV_blank>03<S2SV_blank>draft" ) ) ; cp ++ ; ND_PRINT ( ( ndo , ",<S2SV_blank>\\"" ) ) ; while ( cp < ep ) { safeputchar ( ndo , * cp ) ; cp ++ ; } ND_PRINT ( ( ndo , "\\"" ) ) ; } else dnsname_print ( ndo , cp , ep ) ; if ( ( EXTRACT_16BITS ( & ni6 -> ni_flags ) & 0x01 ) != 0 ) ND_PRINT ( ( ndo , "<S2SV_blank>[TTL=%u]" , EXTRACT_32BITS ( ni6 + 1 ) ) ) ; break ; case NI_QTYPE_NODEADDR : if ( needcomma ) ND_PRINT ( ( ndo , ",<S2SV_blank>" ) ) ; ND_PRINT ( ( ndo , "node<S2SV_blank>addresses" ) ) ; i = sizeof ( * ni6 ) ; while ( i < siz ) { if ( i + sizeof ( struct in6_addr ) + sizeof ( int32_t ) > siz ) break ; ND_PRINT ( ( ndo , "<S2SV_blank>%s" , ip6addr_string ( ndo , bp + i ) ) ) ; i += sizeof ( struct in6_addr ) ; ND_PRINT ( ( ndo , "(%d)" , ( int32_t ) EXTRACT_32BITS ( bp + i ) ) ) ; i += sizeof ( int32_t ) ; } i = ni6 -> ni_flags ; if ( ! i ) break ; ND_PRINT ( ( ndo , "<S2SV_blank>[%s%s%s%s%s%s%s]" , ( i & NI_NODEADDR_FLAG_ANYCAST ) ? "a" : "" , ( i & NI_NODEADDR_FLAG_GLOBAL ) ? "G" : "" , ( i & NI_NODEADDR_FLAG_SITELOCAL ) ? "S" : "" , ( i & NI_NODEADDR_FLAG_LINKLOCAL ) ? "L" : "" , ( i & NI_NODEADDR_FLAG_COMPAT ) ? "C" : "" , ( i & NI_NODEADDR_FLAG_ALL ) ? "A" : "" , ( i & NI_NODEADDR_FLAG_TRUNCATE ) ? "T" : "" ) ) ; break ; default : if ( needcomma ) ND_PRINT ( ( ndo , ",<S2SV_blank>" ) ) ; ND_PRINT ( ( ndo , "unknown" ) ) ; break ; } ND_PRINT ( ( ndo , ")" ) ) ; break ; } return ; trunc : <S2SV_StartBug> ND_PRINT ( ( ndo , "[|icmp6]" ) ) ; <S2SV_EndBug> }
CWE-125 static void icmp6_opt_print ( netdissect_options * ndo , const u_char * bp , int resid ) { const struct nd_opt_hdr * op ; const struct nd_opt_prefix_info * opp ; const struct nd_opt_mtu * opm ; const struct nd_opt_rdnss * oprd ; const struct nd_opt_dnssl * opds ; const struct nd_opt_advinterval * opa ; const struct nd_opt_homeagent_info * oph ; const struct nd_opt_route_info * opri ; const u_char * cp , * ep , * domp ; struct in6_addr in6 ; const struct in6_addr * in6p ; size_t l ; u_int i ; # define ECHECK ( var ) if ( ( const u_char * ) & ( var ) > ep - sizeof ( var ) ) return cp = bp ; ep = ndo -> ndo_snapend ; while ( cp < ep ) { op = ( const struct nd_opt_hdr * ) cp ; ECHECK ( op -> nd_opt_len ) ; if ( resid <= 0 ) return ; if ( op -> nd_opt_len == 0 ) goto trunc ; if ( cp + ( op -> nd_opt_len << 3 ) > ep ) goto trunc ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>option<S2SV_blank>(%u),<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>(%u):<S2SV_blank>" , tok2str ( icmp6_opt_values , "unknown" , op -> nd_opt_type ) , op -> nd_opt_type , op -> nd_opt_len << 3 , op -> nd_opt_len ) ) ; switch ( op -> nd_opt_type ) { case ND_OPT_SOURCE_LINKADDR : l = ( op -> nd_opt_len << 3 ) - 2 ; print_lladdr ( ndo , cp + 2 , l ) ; break ; case ND_OPT_TARGET_LINKADDR : l = ( op -> nd_opt_len << 3 ) - 2 ; print_lladdr ( ndo , cp + 2 , l ) ; break ; case ND_OPT_PREFIX_INFORMATION : opp = ( const struct nd_opt_prefix_info * ) op ; ND_TCHECK ( opp -> nd_opt_pi_prefix ) ; ND_PRINT ( ( ndo , "%s/%u%s,<S2SV_blank>Flags<S2SV_blank>[%s],<S2SV_blank>valid<S2SV_blank>time<S2SV_blank>%s" , ip6addr_string ( ndo , & opp -> nd_opt_pi_prefix ) , opp -> nd_opt_pi_prefix_len , ( op -> nd_opt_len != 4 ) ? "badlen" : "" , bittok2str ( icmp6_opt_pi_flag_values , "none" , opp -> nd_opt_pi_flags_reserved ) , get_lifetime ( EXTRACT_32BITS ( & opp -> nd_opt_pi_valid_time ) ) ) ) ; ND_PRINT ( ( ndo , ",<S2SV_blank>pref.<S2SV_blank>time<S2SV_blank>%s" , get_lifetime ( EXTRACT_32BITS ( & opp -> nd_opt_pi_preferred_time ) ) ) ) ; break ; case ND_OPT_REDIRECTED_HEADER : print_unknown_data ( ndo , bp , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , op -> nd_opt_len << 3 ) ; break ; case ND_OPT_MTU : opm = ( const struct nd_opt_mtu * ) op ; ND_TCHECK ( opm -> nd_opt_mtu_mtu ) ; ND_PRINT ( ( ndo , "<S2SV_blank>%u%s" , EXTRACT_32BITS ( & opm -> nd_opt_mtu_mtu ) , ( op -> nd_opt_len != 1 ) ? "bad<S2SV_blank>option<S2SV_blank>length" : "" ) ) ; break ; case ND_OPT_RDNSS : oprd = ( const struct nd_opt_rdnss * ) op ; l = ( op -> nd_opt_len - 1 ) / 2 ; ND_PRINT ( ( ndo , "<S2SV_blank>lifetime<S2SV_blank>%us," , EXTRACT_32BITS ( & oprd -> nd_opt_rdnss_lifetime ) ) ) ; for ( i = 0 ; i < l ; i ++ ) { ND_TCHECK ( oprd -> nd_opt_rdnss_addr [ i ] ) ; ND_PRINT ( ( ndo , "<S2SV_blank>addr:<S2SV_blank>%s" , ip6addr_string ( ndo , & oprd -> nd_opt_rdnss_addr [ i ] ) ) ) ; } break ; case ND_OPT_DNSSL : opds = ( const struct nd_opt_dnssl * ) op ; ND_PRINT ( ( ndo , "<S2SV_blank>lifetime<S2SV_blank>%us,<S2SV_blank>domain(s):" , EXTRACT_32BITS ( & opds -> nd_opt_dnssl_lifetime ) ) ) ; domp = cp + 8 ; while ( domp < cp + ( op -> nd_opt_len << 3 ) && * domp != '\\0' ) { ND_PRINT ( ( ndo , "<S2SV_blank>" ) ) ; if ( ( domp = ns_nprint ( ndo , domp , bp ) ) == NULL ) goto trunc ; } break ; case ND_OPT_ADVINTERVAL : opa = ( const struct nd_opt_advinterval * ) op ; ND_TCHECK ( opa -> nd_opt_adv_interval ) ; ND_PRINT ( ( ndo , "<S2SV_blank>%ums" , EXTRACT_32BITS ( & opa -> nd_opt_adv_interval ) ) ) ; break ; case ND_OPT_HOMEAGENT_INFO : oph = ( const struct nd_opt_homeagent_info * ) op ; ND_TCHECK ( oph -> nd_opt_hai_lifetime ) ; ND_PRINT ( ( ndo , "<S2SV_blank>preference<S2SV_blank>%u,<S2SV_blank>lifetime<S2SV_blank>%u" , EXTRACT_16BITS ( & oph -> nd_opt_hai_preference ) , EXTRACT_16BITS ( & oph -> nd_opt_hai_lifetime ) ) ) ; break ; case ND_OPT_ROUTE_INFO : opri = ( const struct nd_opt_route_info * ) op ; ND_TCHECK ( opri -> nd_opt_rti_lifetime ) ; memset ( & in6 , 0 , sizeof ( in6 ) ) ; in6p = ( const struct in6_addr * ) ( opri + 1 ) ; switch ( op -> nd_opt_len ) { case 1 : break ; case 2 : ND_TCHECK2 ( * in6p , 8 ) ; memcpy ( & in6 , opri + 1 , 8 ) ; break ; case 3 : ND_TCHECK ( * in6p ) ; memcpy ( & in6 , opri + 1 , sizeof ( in6 ) ) ; break ; default : goto trunc ; } ND_PRINT ( ( ndo , "<S2SV_blank>%s/%u" , ip6addr_string ( ndo , & in6 ) , opri -> nd_opt_rti_prefixlen ) ) ; ND_PRINT ( ( ndo , ",<S2SV_blank>pref=%s" , get_rtpref ( opri -> nd_opt_rti_flags ) ) ) ; ND_PRINT ( ( ndo , ",<S2SV_blank>lifetime=%s" , get_lifetime ( EXTRACT_32BITS ( & opri -> nd_opt_rti_lifetime ) ) ) ) ; break ; default : if ( ndo -> ndo_vflag <= 1 ) { print_unknown_data ( ndo , cp + 2 , "\\n\\t<S2SV_blank><S2SV_blank>" , ( op -> nd_opt_len << 3 ) - 2 ) ; return ; } break ; } if ( ndo -> ndo_vflag > 1 ) print_unknown_data ( ndo , cp + 2 , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , ( op -> nd_opt_len << 3 ) - 2 ) ; cp += op -> nd_opt_len << 3 ; resid -= op -> nd_opt_len << 3 ; } return ; trunc : <S2SV_StartBug> ND_PRINT ( ( ndo , "[ndp<S2SV_blank>opt]" ) ) ; <S2SV_EndBug> return ; # undef ECHECK }
CWE-125 void icmp6_print ( netdissect_options * ndo , const u_char * bp , u_int length , const u_char * bp2 , int fragmented ) { const struct icmp6_hdr * dp ; const struct ip6_hdr * ip ; const struct ip6_hdr * oip ; const struct udphdr * ouh ; int dport ; const u_char * ep ; u_int prot ; dp = ( const struct icmp6_hdr * ) bp ; ip = ( const struct ip6_hdr * ) bp2 ; oip = ( const struct ip6_hdr * ) ( dp + 1 ) ; ep = ndo -> ndo_snapend ; ND_TCHECK ( dp -> icmp6_cksum ) ; if ( ndo -> ndo_vflag && ! fragmented ) { uint16_t sum , udp_sum ; if ( ND_TTEST2 ( bp [ 0 ] , length ) ) { udp_sum = EXTRACT_16BITS ( & dp -> icmp6_cksum ) ; sum = icmp6_cksum ( ndo , ip , dp , length ) ; if ( sum != 0 ) ND_PRINT ( ( ndo , "[bad<S2SV_blank>icmp6<S2SV_blank>cksum<S2SV_blank>0x%04x<S2SV_blank>-><S2SV_blank>0x%04x!]<S2SV_blank>" , udp_sum , in_cksum_shouldbe ( udp_sum , sum ) ) ) ; else ND_PRINT ( ( ndo , "[icmp6<S2SV_blank>sum<S2SV_blank>ok]<S2SV_blank>" ) ) ; } } ND_PRINT ( ( ndo , "ICMP6,<S2SV_blank>%s" , tok2str ( icmp6_type_values , "unknown<S2SV_blank>icmp6<S2SV_blank>type<S2SV_blank>(%u)" , dp -> icmp6_type ) ) ) ; if ( ndo -> ndo_vflag && ( dp -> icmp6_type == ND_ROUTER_SOLICIT || dp -> icmp6_type == ND_ROUTER_ADVERT || dp -> icmp6_type == ND_NEIGHBOR_ADVERT || dp -> icmp6_type == ND_NEIGHBOR_SOLICIT || dp -> icmp6_type == ND_REDIRECT || dp -> icmp6_type == ICMP6_HADISCOV_REPLY || dp -> icmp6_type == ICMP6_MOBILEPREFIX_ADVERT ) ) ND_PRINT ( ( ndo , ",<S2SV_blank>length<S2SV_blank>%u" , length ) ) ; switch ( dp -> icmp6_type ) { case ICMP6_DST_UNREACH : ND_TCHECK ( oip -> ip6_dst ) ; ND_PRINT ( ( ndo , ",<S2SV_blank>%s" , tok2str ( icmp6_dst_unreach_code_values , "unknown<S2SV_blank>unreach<S2SV_blank>code<S2SV_blank>(%u)" , dp -> icmp6_code ) ) ) ; switch ( dp -> icmp6_code ) { case ICMP6_DST_UNREACH_NOROUTE : case ICMP6_DST_UNREACH_ADMIN : case ICMP6_DST_UNREACH_ADDR : ND_PRINT ( ( ndo , "<S2SV_blank>%s" , ip6addr_string ( ndo , & oip -> ip6_dst ) ) ) ; break ; case ICMP6_DST_UNREACH_BEYONDSCOPE : ND_PRINT ( ( ndo , "<S2SV_blank>%s,<S2SV_blank>source<S2SV_blank>address<S2SV_blank>%s" , ip6addr_string ( ndo , & oip -> ip6_dst ) , ip6addr_string ( ndo , & oip -> ip6_src ) ) ) ; break ; case ICMP6_DST_UNREACH_NOPORT : if ( ( ouh = get_upperlayer ( ndo , ( const u_char * ) oip , & prot ) ) == NULL ) goto trunc ; dport = EXTRACT_16BITS ( & ouh -> uh_dport ) ; switch ( prot ) { case IPPROTO_TCP : ND_PRINT ( ( ndo , ",<S2SV_blank>%s<S2SV_blank>tcp<S2SV_blank>port<S2SV_blank>%s" , ip6addr_string ( ndo , & oip -> ip6_dst ) , tcpport_string ( ndo , dport ) ) ) ; break ; case IPPROTO_UDP : ND_PRINT ( ( ndo , ",<S2SV_blank>%s<S2SV_blank>udp<S2SV_blank>port<S2SV_blank>%s" , ip6addr_string ( ndo , & oip -> ip6_dst ) , udpport_string ( ndo , dport ) ) ) ; break ; default : ND_PRINT ( ( ndo , ",<S2SV_blank>%s<S2SV_blank>protocol<S2SV_blank>%d<S2SV_blank>port<S2SV_blank>%d<S2SV_blank>unreachable" , ip6addr_string ( ndo , & oip -> ip6_dst ) , oip -> ip6_nxt , dport ) ) ; break ; } break ; default : if ( ndo -> ndo_vflag <= 1 ) { print_unknown_data ( ndo , bp , "\\n\\t" , length ) ; return ; } break ; } break ; case ICMP6_PACKET_TOO_BIG : ND_TCHECK ( dp -> icmp6_mtu ) ; ND_PRINT ( ( ndo , ",<S2SV_blank>mtu<S2SV_blank>%u" , EXTRACT_32BITS ( & dp -> icmp6_mtu ) ) ) ; break ; case ICMP6_TIME_EXCEEDED : ND_TCHECK ( oip -> ip6_dst ) ; switch ( dp -> icmp6_code ) { case ICMP6_TIME_EXCEED_TRANSIT : ND_PRINT ( ( ndo , "<S2SV_blank>for<S2SV_blank>%s" , ip6addr_string ( ndo , & oip -> ip6_dst ) ) ) ; break ; case ICMP6_TIME_EXCEED_REASSEMBLY : ND_PRINT ( ( ndo , "<S2SV_blank>(reassembly)" ) ) ; break ; default : ND_PRINT ( ( ndo , ",<S2SV_blank>unknown<S2SV_blank>code<S2SV_blank>(%u)" , dp -> icmp6_code ) ) ; break ; } break ; case ICMP6_PARAM_PROB : ND_TCHECK ( oip -> ip6_dst ) ; switch ( dp -> icmp6_code ) { case ICMP6_PARAMPROB_HEADER : ND_PRINT ( ( ndo , ",<S2SV_blank>erroneous<S2SV_blank>-<S2SV_blank>octet<S2SV_blank>%u" , EXTRACT_32BITS ( & dp -> icmp6_pptr ) ) ) ; break ; case ICMP6_PARAMPROB_NEXTHEADER : ND_PRINT ( ( ndo , ",<S2SV_blank>next<S2SV_blank>header<S2SV_blank>-<S2SV_blank>octet<S2SV_blank>%u" , EXTRACT_32BITS ( & dp -> icmp6_pptr ) ) ) ; break ; case ICMP6_PARAMPROB_OPTION : ND_PRINT ( ( ndo , ",<S2SV_blank>option<S2SV_blank>-<S2SV_blank>octet<S2SV_blank>%u" , EXTRACT_32BITS ( & dp -> icmp6_pptr ) ) ) ; break ; default : ND_PRINT ( ( ndo , ",<S2SV_blank>code-#%d" , dp -> icmp6_code ) ) ; break ; } break ; case ICMP6_ECHO_REQUEST : case ICMP6_ECHO_REPLY : ND_TCHECK ( dp -> icmp6_seq ) ; ND_PRINT ( ( ndo , ",<S2SV_blank>seq<S2SV_blank>%u" , EXTRACT_16BITS ( & dp -> icmp6_seq ) ) ) ; break ; case ICMP6_MEMBERSHIP_QUERY : if ( length == MLD_MINLEN ) { mld6_print ( ndo , ( const u_char * ) dp ) ; } else if ( length >= MLDV2_MINLEN ) { ND_PRINT ( ( ndo , "<S2SV_blank>v2" ) ) ; mldv2_query_print ( ndo , ( const u_char * ) dp , length ) ; } else { ND_PRINT ( ( ndo , "<S2SV_blank>unknown-version<S2SV_blank>(len<S2SV_blank>%u)<S2SV_blank>" , length ) ) ; } break ; case ICMP6_MEMBERSHIP_REPORT : mld6_print ( ndo , ( const u_char * ) dp ) ; break ; case ICMP6_MEMBERSHIP_REDUCTION : mld6_print ( ndo , ( const u_char * ) dp ) ; break ; case ND_ROUTER_SOLICIT : # define RTSOLLEN 8 if ( ndo -> ndo_vflag ) { icmp6_opt_print ( ndo , ( const u_char * ) dp + RTSOLLEN , length - RTSOLLEN ) ; } break ; case ND_ROUTER_ADVERT : # define RTADVLEN 16 if ( ndo -> ndo_vflag ) { const struct nd_router_advert * p ; p = ( const struct nd_router_advert * ) dp ; ND_TCHECK ( p -> nd_ra_retransmit ) ; ND_PRINT ( ( ndo , "\\n\\thop<S2SV_blank>limit<S2SV_blank>%u,<S2SV_blank>Flags<S2SV_blank>[%s]" ",<S2SV_blank>pref<S2SV_blank>%s,<S2SV_blank>router<S2SV_blank>lifetime<S2SV_blank>%us,<S2SV_blank>reachable<S2SV_blank>time<S2SV_blank>%ums,<S2SV_blank>retrans<S2SV_blank>timer<S2SV_blank>%ums" , ( u_int ) p -> nd_ra_curhoplimit , bittok2str ( icmp6_opt_ra_flag_values , "none" , ( p -> nd_ra_flags_reserved ) ) , get_rtpref ( p -> nd_ra_flags_reserved ) , EXTRACT_16BITS ( & p -> nd_ra_router_lifetime ) , EXTRACT_32BITS ( & p -> nd_ra_reachable ) , EXTRACT_32BITS ( & p -> nd_ra_retransmit ) ) ) ; icmp6_opt_print ( ndo , ( const u_char * ) dp + RTADVLEN , length - RTADVLEN ) ; } break ; case ND_NEIGHBOR_SOLICIT : { const struct nd_neighbor_solicit * p ; p = ( const struct nd_neighbor_solicit * ) dp ; ND_TCHECK ( p -> nd_ns_target ) ; ND_PRINT ( ( ndo , ",<S2SV_blank>who<S2SV_blank>has<S2SV_blank>%s" , ip6addr_string ( ndo , & p -> nd_ns_target ) ) ) ; if ( ndo -> ndo_vflag ) { # define NDSOLLEN 24 icmp6_opt_print ( ndo , ( const u_char * ) dp + NDSOLLEN , length - NDSOLLEN ) ; } } break ; case ND_NEIGHBOR_ADVERT : { const struct nd_neighbor_advert * p ; p = ( const struct nd_neighbor_advert * ) dp ; ND_TCHECK ( p -> nd_na_target ) ; ND_PRINT ( ( ndo , ",<S2SV_blank>tgt<S2SV_blank>is<S2SV_blank>%s" , ip6addr_string ( ndo , & p -> nd_na_target ) ) ) ; if ( ndo -> ndo_vflag ) { ND_PRINT ( ( ndo , ",<S2SV_blank>Flags<S2SV_blank>[%s]" , bittok2str ( icmp6_nd_na_flag_values , "none" , EXTRACT_32BITS ( & p -> nd_na_flags_reserved ) ) ) ) ; # define NDADVLEN 24 icmp6_opt_print ( ndo , ( const u_char * ) dp + NDADVLEN , length - NDADVLEN ) ; # undef NDADVLEN } } break ; case ND_REDIRECT : # define RDR ( i ) ( ( const struct nd_redirect * ) ( i ) ) ND_TCHECK ( RDR ( dp ) -> nd_rd_dst ) ; ND_PRINT ( ( ndo , ",<S2SV_blank>%s" , ip6addr_string ( ndo , & RDR ( dp ) -> nd_rd_dst ) ) ) ; ND_TCHECK ( RDR ( dp ) -> nd_rd_target ) ; ND_PRINT ( ( ndo , "<S2SV_blank>to<S2SV_blank>%s" , ip6addr_string ( ndo , & RDR ( dp ) -> nd_rd_target ) ) ) ; # define REDIRECTLEN 40 if ( ndo -> ndo_vflag ) { icmp6_opt_print ( ndo , ( const u_char * ) dp + REDIRECTLEN , length - REDIRECTLEN ) ; } break ; # undef REDIRECTLEN # undef RDR case ICMP6_ROUTER_RENUMBERING : icmp6_rrenum_print ( ndo , bp , ep ) ; break ; case ICMP6_NI_QUERY : case ICMP6_NI_REPLY : icmp6_nodeinfo_print ( ndo , length , bp , ep ) ; break ; case IND_SOLICIT : case IND_ADVERT : break ; case ICMP6_V2_MEMBERSHIP_REPORT : mldv2_report_print ( ndo , ( const u_char * ) dp , length ) ; break ; case ICMP6_MOBILEPREFIX_SOLICIT : case ICMP6_HADISCOV_REQUEST : ND_TCHECK ( dp -> icmp6_data16 [ 0 ] ) ; ND_PRINT ( ( ndo , ",<S2SV_blank>id<S2SV_blank>0x%04x" , EXTRACT_16BITS ( & dp -> icmp6_data16 [ 0 ] ) ) ) ; break ; case ICMP6_HADISCOV_REPLY : if ( ndo -> ndo_vflag ) { const struct in6_addr * in6 ; const u_char * cp ; ND_TCHECK ( dp -> icmp6_data16 [ 0 ] ) ; ND_PRINT ( ( ndo , ",<S2SV_blank>id<S2SV_blank>0x%04x" , EXTRACT_16BITS ( & dp -> icmp6_data16 [ 0 ] ) ) ) ; cp = ( const u_char * ) dp + length ; in6 = ( const struct in6_addr * ) ( dp + 1 ) ; for ( ; ( const u_char * ) in6 < cp ; in6 ++ ) { ND_TCHECK ( * in6 ) ; ND_PRINT ( ( ndo , ",<S2SV_blank>%s" , ip6addr_string ( ndo , in6 ) ) ) ; } } break ; case ICMP6_MOBILEPREFIX_ADVERT : if ( ndo -> ndo_vflag ) { ND_TCHECK ( dp -> icmp6_data16 [ 0 ] ) ; ND_PRINT ( ( ndo , ",<S2SV_blank>id<S2SV_blank>0x%04x" , EXTRACT_16BITS ( & dp -> icmp6_data16 [ 0 ] ) ) ) ; ND_TCHECK ( dp -> icmp6_data16 [ 1 ] ) ; if ( dp -> icmp6_data16 [ 1 ] & 0xc0 ) ND_PRINT ( ( ndo , "<S2SV_blank>" ) ) ; if ( dp -> icmp6_data16 [ 1 ] & 0x80 ) ND_PRINT ( ( ndo , "M" ) ) ; if ( dp -> icmp6_data16 [ 1 ] & 0x40 ) ND_PRINT ( ( ndo , "O" ) ) ; # define MPADVLEN 8 icmp6_opt_print ( ndo , ( const u_char * ) dp + MPADVLEN , length - MPADVLEN ) ; } break ; case ND_RPL_MESSAGE : rpl_print ( ndo , dp , & dp -> icmp6_data8 [ 0 ] , length - sizeof ( struct icmp6_hdr ) + 4 ) ; break ; default : ND_PRINT ( ( ndo , ",<S2SV_blank>length<S2SV_blank>%u" , length ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , bp , "\\n\\t" , length ) ; return ; } if ( ! ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ",<S2SV_blank>length<S2SV_blank>%u" , length ) ) ; return ; trunc : <S2SV_StartBug> ND_PRINT ( ( ndo , "[|icmp6]" ) ) ; <S2SV_EndBug> }
CWE-125 static void icmp6_rrenum_print ( netdissect_options * ndo , const u_char * bp , const u_char * ep ) { const struct icmp6_router_renum * rr6 ; const char * cp ; const struct rr_pco_match * match ; const struct rr_pco_use * use ; char hbuf [ NI_MAXHOST ] ; int n ; if ( ep < bp ) return ; rr6 = ( const struct icmp6_router_renum * ) bp ; cp = ( const char * ) ( rr6 + 1 ) ; ND_TCHECK ( rr6 -> rr_reserved ) ; switch ( rr6 -> rr_code ) { case ICMP6_ROUTER_RENUMBERING_COMMAND : ND_PRINT ( ( ndo , "router<S2SV_blank>renum:<S2SV_blank>command" ) ) ; break ; case ICMP6_ROUTER_RENUMBERING_RESULT : ND_PRINT ( ( ndo , "router<S2SV_blank>renum:<S2SV_blank>result" ) ) ; break ; case ICMP6_ROUTER_RENUMBERING_SEQNUM_RESET : ND_PRINT ( ( ndo , "router<S2SV_blank>renum:<S2SV_blank>sequence<S2SV_blank>number<S2SV_blank>reset" ) ) ; break ; default : ND_PRINT ( ( ndo , "router<S2SV_blank>renum:<S2SV_blank>code-#%d" , rr6 -> rr_code ) ) ; break ; } ND_PRINT ( ( ndo , ",<S2SV_blank>seq=%u" , EXTRACT_32BITS ( & rr6 -> rr_seqnum ) ) ) ; if ( ndo -> ndo_vflag ) { # define F ( x , y ) ( ( rr6 -> rr_flags ) & ( x ) ? ( y ) : "" ) ND_PRINT ( ( ndo , "[" ) ) ; if ( rr6 -> rr_flags ) { ND_PRINT ( ( ndo , "%s%s%s%s%s," , F ( ICMP6_RR_FLAGS_TEST , "T" ) , F ( ICMP6_RR_FLAGS_REQRESULT , "R" ) , F ( ICMP6_RR_FLAGS_FORCEAPPLY , "A" ) , F ( ICMP6_RR_FLAGS_SPECSITE , "S" ) , F ( ICMP6_RR_FLAGS_PREVDONE , "P" ) ) ) ; } ND_PRINT ( ( ndo , "seg=%u," , rr6 -> rr_segnum ) ) ; ND_PRINT ( ( ndo , "maxdelay=%u" , EXTRACT_16BITS ( & rr6 -> rr_maxdelay ) ) ) ; if ( rr6 -> rr_reserved ) ND_PRINT ( ( ndo , "rsvd=0x%x" , EXTRACT_32BITS ( & rr6 -> rr_reserved ) ) ) ; ND_PRINT ( ( ndo , "]" ) ) ; # undef F } if ( rr6 -> rr_code == ICMP6_ROUTER_RENUMBERING_COMMAND ) { match = ( const struct rr_pco_match * ) cp ; cp = ( const char * ) ( match + 1 ) ; ND_TCHECK ( match -> rpm_prefix ) ; if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , "\\n\\t" ) ) ; else ND_PRINT ( ( ndo , "<S2SV_blank>" ) ) ; ND_PRINT ( ( ndo , "match(" ) ) ; switch ( match -> rpm_code ) { case RPM_PCO_ADD : ND_PRINT ( ( ndo , "add" ) ) ; break ; case RPM_PCO_CHANGE : ND_PRINT ( ( ndo , "change" ) ) ; break ; case RPM_PCO_SETGLOBAL : ND_PRINT ( ( ndo , "setglobal" ) ) ; break ; default : ND_PRINT ( ( ndo , "#%u" , match -> rpm_code ) ) ; break ; } if ( ndo -> ndo_vflag ) { ND_PRINT ( ( ndo , ",ord=%u" , match -> rpm_ordinal ) ) ; ND_PRINT ( ( ndo , ",min=%u" , match -> rpm_minlen ) ) ; ND_PRINT ( ( ndo , ",max=%u" , match -> rpm_maxlen ) ) ; } if ( addrtostr6 ( & match -> rpm_prefix , hbuf , sizeof ( hbuf ) ) ) ND_PRINT ( ( ndo , ",%s/%u" , hbuf , match -> rpm_matchlen ) ) ; else ND_PRINT ( ( ndo , ",?/%u" , match -> rpm_matchlen ) ) ; ND_PRINT ( ( ndo , ")" ) ) ; n = match -> rpm_len - 3 ; if ( n % 4 ) goto trunc ; n /= 4 ; while ( n -- > 0 ) { use = ( const struct rr_pco_use * ) cp ; cp = ( const char * ) ( use + 1 ) ; ND_TCHECK ( use -> rpu_prefix ) ; if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , "\\n\\t" ) ) ; else ND_PRINT ( ( ndo , "<S2SV_blank>" ) ) ; ND_PRINT ( ( ndo , "use(" ) ) ; if ( use -> rpu_flags ) { # define F ( x , y ) ( ( use -> rpu_flags ) & ( x ) ? ( y ) : "" ) ND_PRINT ( ( ndo , "%s%s," , F ( ICMP6_RR_PCOUSE_FLAGS_DECRVLTIME , "V" ) , F ( ICMP6_RR_PCOUSE_FLAGS_DECRPLTIME , "P" ) ) ) ; # undef F } if ( ndo -> ndo_vflag ) { ND_PRINT ( ( ndo , "mask=0x%x," , use -> rpu_ramask ) ) ; ND_PRINT ( ( ndo , "raflags=0x%x," , use -> rpu_raflags ) ) ; if ( ~ use -> rpu_vltime == 0 ) ND_PRINT ( ( ndo , "vltime=infty," ) ) ; else ND_PRINT ( ( ndo , "vltime=%u," , EXTRACT_32BITS ( & use -> rpu_vltime ) ) ) ; if ( ~ use -> rpu_pltime == 0 ) ND_PRINT ( ( ndo , "pltime=infty," ) ) ; else ND_PRINT ( ( ndo , "pltime=%u," , EXTRACT_32BITS ( & use -> rpu_pltime ) ) ) ; } if ( addrtostr6 ( & use -> rpu_prefix , hbuf , sizeof ( hbuf ) ) ) ND_PRINT ( ( ndo , "%s/%u/%u" , hbuf , use -> rpu_uselen , use -> rpu_keeplen ) ) ; else ND_PRINT ( ( ndo , "?/%u/%u" , use -> rpu_uselen , use -> rpu_keeplen ) ) ; ND_PRINT ( ( ndo , ")" ) ) ; } } return ; trunc : <S2SV_StartBug> ND_PRINT ( ( ndo , "[|icmp6]" ) ) ; <S2SV_EndBug> }
CWE-125 static void mldv2_query_print ( netdissect_options * ndo , const u_char * bp , u_int len ) { const struct icmp6_hdr * icp = ( const struct icmp6_hdr * ) bp ; u_int mrc ; int mrt , qqi ; u_int nsrcs ; register u_int i ; if ( len < 28 ) { ND_PRINT ( ( ndo , "<S2SV_blank>[invalid<S2SV_blank>len<S2SV_blank>%d]" , len ) ) ; return ; } ND_TCHECK ( icp -> icmp6_data16 [ 0 ] ) ; mrc = EXTRACT_16BITS ( & icp -> icmp6_data16 [ 0 ] ) ; if ( mrc < 32768 ) { mrt = mrc ; } else { mrt = ( ( mrc & 0x0fff ) | 0x1000 ) << ( ( ( mrc & 0x7000 ) >> 12 ) + 3 ) ; } if ( ndo -> ndo_vflag ) { ND_PRINT ( ( ndo , "<S2SV_blank>[max<S2SV_blank>resp<S2SV_blank>delay=%d]" , mrt ) ) ; } ND_TCHECK2 ( bp [ 8 ] , sizeof ( struct in6_addr ) ) ; ND_PRINT ( ( ndo , "<S2SV_blank>[gaddr<S2SV_blank>%s" , ip6addr_string ( ndo , & bp [ 8 ] ) ) ) ; if ( ndo -> ndo_vflag ) { ND_TCHECK ( bp [ 25 ] ) ; if ( bp [ 24 ] & 0x08 ) { ND_PRINT ( ( ndo , "<S2SV_blank>sflag" ) ) ; } if ( bp [ 24 ] & 0x07 ) { ND_PRINT ( ( ndo , "<S2SV_blank>robustness=%d" , bp [ 24 ] & 0x07 ) ) ; } if ( bp [ 25 ] < 128 ) { qqi = bp [ 25 ] ; } else { qqi = ( ( bp [ 25 ] & 0x0f ) | 0x10 ) << ( ( ( bp [ 25 ] & 0x70 ) >> 4 ) + 3 ) ; } ND_PRINT ( ( ndo , "<S2SV_blank>qqi=%d" , qqi ) ) ; } ND_TCHECK2 ( bp [ 26 ] , 2 ) ; nsrcs = EXTRACT_16BITS ( & bp [ 26 ] ) ; if ( nsrcs > 0 ) { if ( len < 28 + nsrcs * sizeof ( struct in6_addr ) ) ND_PRINT ( ( ndo , "<S2SV_blank>[invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>sources]" ) ) ; else if ( ndo -> ndo_vflag > 1 ) { ND_PRINT ( ( ndo , "<S2SV_blank>{" ) ) ; for ( i = 0 ; i < nsrcs ; i ++ ) { ND_TCHECK2 ( bp [ 28 + i * sizeof ( struct in6_addr ) ] , sizeof ( struct in6_addr ) ) ; ND_PRINT ( ( ndo , "<S2SV_blank>%s" , ip6addr_string ( ndo , & bp [ 28 + i * sizeof ( struct in6_addr ) ] ) ) ) ; } ND_PRINT ( ( ndo , "<S2SV_blank>}" ) ) ; } else ND_PRINT ( ( ndo , ",<S2SV_blank>%d<S2SV_blank>source(s)" , nsrcs ) ) ; } ND_PRINT ( ( ndo , "]" ) ) ; return ; trunc : <S2SV_StartBug> ND_PRINT ( ( ndo , "[|icmp6]" ) ) ; <S2SV_EndBug> return ; }
CWE-125 static void mldv2_report_print ( netdissect_options * ndo , const u_char * bp , u_int len ) { const struct icmp6_hdr * icp = ( const struct icmp6_hdr * ) bp ; u_int group , nsrcs , ngroups ; u_int i , j ; if ( len < 8 ) { ND_PRINT ( ( ndo , "<S2SV_blank>[invalid<S2SV_blank>len<S2SV_blank>%d]" , len ) ) ; return ; } ND_TCHECK ( icp -> icmp6_data16 [ 1 ] ) ; ngroups = EXTRACT_16BITS ( & icp -> icmp6_data16 [ 1 ] ) ; ND_PRINT ( ( ndo , ",<S2SV_blank>%d<S2SV_blank>group<S2SV_blank>record(s)" , ngroups ) ) ; if ( ndo -> ndo_vflag > 0 ) { group = 8 ; for ( i = 0 ; i < ngroups ; i ++ ) { if ( len < group + 20 ) { ND_PRINT ( ( ndo , "<S2SV_blank>[invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>groups]" ) ) ; return ; } ND_TCHECK2 ( bp [ group + 4 ] , sizeof ( struct in6_addr ) ) ; ND_PRINT ( ( ndo , "<S2SV_blank>[gaddr<S2SV_blank>%s" , ip6addr_string ( ndo , & bp [ group + 4 ] ) ) ) ; ND_PRINT ( ( ndo , "<S2SV_blank>%s" , tok2str ( mldv2report2str , "<S2SV_blank>[v2-report-#%d]" , bp [ group ] ) ) ) ; nsrcs = ( bp [ group + 2 ] << 8 ) + bp [ group + 3 ] ; if ( len < group + 20 + ( nsrcs * sizeof ( struct in6_addr ) ) ) { ND_PRINT ( ( ndo , "<S2SV_blank>[invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>sources<S2SV_blank>%d]" , nsrcs ) ) ; return ; } if ( ndo -> ndo_vflag == 1 ) ND_PRINT ( ( ndo , ",<S2SV_blank>%d<S2SV_blank>source(s)" , nsrcs ) ) ; else { ND_PRINT ( ( ndo , "<S2SV_blank>{" ) ) ; for ( j = 0 ; j < nsrcs ; j ++ ) { ND_TCHECK2 ( bp [ group + 20 + j * sizeof ( struct in6_addr ) ] , sizeof ( struct in6_addr ) ) ; ND_PRINT ( ( ndo , "<S2SV_blank>%s" , ip6addr_string ( ndo , & bp [ group + 20 + j * sizeof ( struct in6_addr ) ] ) ) ) ; } ND_PRINT ( ( ndo , "<S2SV_blank>}" ) ) ; } group += 20 + nsrcs * sizeof ( struct in6_addr ) ; ND_PRINT ( ( ndo , "]" ) ) ; } } return ; trunc : <S2SV_StartBug> ND_PRINT ( ( ndo , "[|icmp6]" ) ) ; <S2SV_EndBug> return ; }
CWE-125 static void rpl_dao_print ( netdissect_options * ndo , const u_char * bp , u_int length ) { const struct nd_rpl_dao * dao = ( const struct nd_rpl_dao * ) bp ; const char * dagid_str = "<elided>" ; ND_TCHECK ( * dao ) ; if ( length < ND_RPL_DAO_MIN_LEN ) goto tooshort ; bp += ND_RPL_DAO_MIN_LEN ; length -= ND_RPL_DAO_MIN_LEN ; if ( RPL_DAO_D ( dao -> rpl_flags ) ) { ND_TCHECK2 ( dao -> rpl_dagid , DAGID_LEN ) ; if ( length < DAGID_LEN ) goto tooshort ; dagid_str = ip6addr_string ( ndo , dao -> rpl_dagid ) ; bp += DAGID_LEN ; length -= DAGID_LEN ; } ND_PRINT ( ( ndo , "<S2SV_blank>[dagid:%s,seq:%u,instance:%u%s%s,%02x]" , dagid_str , dao -> rpl_daoseq , dao -> rpl_instanceid , RPL_DAO_K ( dao -> rpl_flags ) ? ",acK" : "" , RPL_DAO_D ( dao -> rpl_flags ) ? ",Dagid" : "" , dao -> rpl_flags ) ) ; if ( ndo -> ndo_vflag > 1 ) { const struct rpl_dio_genoption * opt = ( const struct rpl_dio_genoption * ) bp ; rpl_dio_printopt ( ndo , opt , length ) ; } return ; trunc : <S2SV_StartBug> ND_PRINT ( ( ndo , "<S2SV_blank>[|truncated]" ) ) ; <S2SV_EndBug> return ; tooshort : ND_PRINT ( ( ndo , "<S2SV_blank>[|length<S2SV_blank>too<S2SV_blank>short]" ) ) ; return ; }
CWE-125 static void rpl_daoack_print ( netdissect_options * ndo , const u_char * bp , u_int length ) { const struct nd_rpl_daoack * daoack = ( const struct nd_rpl_daoack * ) bp ; const char * dagid_str = "<elided>" ; ND_TCHECK2 ( * daoack , ND_RPL_DAOACK_MIN_LEN ) ; if ( length < ND_RPL_DAOACK_MIN_LEN ) goto tooshort ; bp += ND_RPL_DAOACK_MIN_LEN ; length -= ND_RPL_DAOACK_MIN_LEN ; if ( RPL_DAOACK_D ( daoack -> rpl_flags ) ) { ND_TCHECK2 ( daoack -> rpl_dagid , DAGID_LEN ) ; if ( length < DAGID_LEN ) goto tooshort ; dagid_str = ip6addr_string ( ndo , daoack -> rpl_dagid ) ; bp += DAGID_LEN ; length -= DAGID_LEN ; } ND_PRINT ( ( ndo , "<S2SV_blank>[dagid:%s,seq:%u,instance:%u,status:%u]" , dagid_str , daoack -> rpl_daoseq , daoack -> rpl_instanceid , daoack -> rpl_status ) ) ; if ( ndo -> ndo_vflag > 1 ) { const struct rpl_dio_genoption * opt = ( const struct rpl_dio_genoption * ) bp ; rpl_dio_printopt ( ndo , opt , length ) ; } return ; trunc : <S2SV_StartBug> ND_PRINT ( ( ndo , "<S2SV_blank>[|dao-truncated]" ) ) ; <S2SV_EndBug> return ; tooshort : ND_PRINT ( ( ndo , "<S2SV_blank>[|dao-length<S2SV_blank>too<S2SV_blank>short]" ) ) ; return ; }
CWE-125 static void rpl_dio_print ( netdissect_options * ndo , const u_char * bp , u_int length ) { const struct nd_rpl_dio * dio = ( const struct nd_rpl_dio * ) bp ; const char * dagid_str ; ND_TCHECK ( * dio ) ; dagid_str = ip6addr_string ( ndo , dio -> rpl_dagid ) ; ND_PRINT ( ( ndo , "<S2SV_blank>[dagid:%s,seq:%u,instance:%u,rank:%u,%smop:%s,prf:%u]" , dagid_str , dio -> rpl_dtsn , dio -> rpl_instanceid , EXTRACT_16BITS ( & dio -> rpl_dagrank ) , RPL_DIO_GROUNDED ( dio -> rpl_mopprf ) ? "grounded," : "" , tok2str ( rpl_mop_values , "mop%u" , RPL_DIO_MOP ( dio -> rpl_mopprf ) ) , RPL_DIO_PRF ( dio -> rpl_mopprf ) ) ) ; if ( ndo -> ndo_vflag > 1 ) { const struct rpl_dio_genoption * opt = ( const struct rpl_dio_genoption * ) & dio [ 1 ] ; rpl_dio_printopt ( ndo , opt , length ) ; } return ; trunc : <S2SV_StartBug> ND_PRINT ( ( ndo , "<S2SV_blank>[|truncated]" ) ) ; <S2SV_EndBug> return ; }
CWE-125 static void rpl_dio_printopt ( netdissect_options * ndo , const struct rpl_dio_genoption * opt , u_int length ) { if ( length < RPL_DIO_GENOPTION_LEN ) return ; length -= RPL_DIO_GENOPTION_LEN ; ND_TCHECK ( opt -> rpl_dio_len ) ; while ( ( opt -> rpl_dio_type == RPL_OPT_PAD0 && ( const u_char * ) opt < ndo -> ndo_snapend ) || ND_TTEST2 ( * opt , ( opt -> rpl_dio_len + 2 ) ) ) { unsigned int optlen = opt -> rpl_dio_len + 2 ; if ( opt -> rpl_dio_type == RPL_OPT_PAD0 ) { optlen = 1 ; ND_PRINT ( ( ndo , "<S2SV_blank>opt:pad0" ) ) ; } else { ND_PRINT ( ( ndo , "<S2SV_blank>opt:%s<S2SV_blank>len:%u<S2SV_blank>" , tok2str ( rpl_subopt_values , "subopt:%u" , opt -> rpl_dio_type ) , optlen ) ) ; if ( ndo -> ndo_vflag > 2 ) { unsigned int paylen = opt -> rpl_dio_len ; if ( paylen > length ) paylen = length ; hex_print ( ndo , "<S2SV_blank>" , ( ( const uint8_t * ) opt ) + RPL_DIO_GENOPTION_LEN , paylen ) ; } } opt = ( const struct rpl_dio_genoption * ) ( ( ( const char * ) opt ) + optlen ) ; length -= optlen ; <S2SV_StartBug> } <S2SV_EndBug> return ; trunc : <S2SV_StartBug> ND_PRINT ( ( ndo , "<S2SV_blank>[|truncated]" ) ) ; <S2SV_EndBug> return ; }
CWE-125 static void rpl_print ( netdissect_options * ndo , const struct icmp6_hdr * hdr , const u_char * bp , u_int length ) { int secured = hdr -> icmp6_code & 0x80 ; int basecode = hdr -> icmp6_code & 0x7f ; if ( secured ) { ND_PRINT ( ( ndo , ",<S2SV_blank>(SEC)<S2SV_blank>[worktodo]" ) ) ; return ; } else { ND_PRINT ( ( ndo , ",<S2SV_blank>(CLR)" ) ) ; } switch ( basecode ) { case ND_RPL_DAG_IS : ND_PRINT ( ( ndo , "DODAG<S2SV_blank>Information<S2SV_blank>Solicitation" ) ) ; if ( ndo -> ndo_vflag ) { } break ; case ND_RPL_DAG_IO : ND_PRINT ( ( ndo , "DODAG<S2SV_blank>Information<S2SV_blank>Object" ) ) ; if ( ndo -> ndo_vflag ) { rpl_dio_print ( ndo , bp , length ) ; } break ; case ND_RPL_DAO : ND_PRINT ( ( ndo , "Destination<S2SV_blank>Advertisement<S2SV_blank>Object" ) ) ; if ( ndo -> ndo_vflag ) { rpl_dao_print ( ndo , bp , length ) ; } break ; case ND_RPL_DAO_ACK : ND_PRINT ( ( ndo , "Destination<S2SV_blank>Advertisement<S2SV_blank>Object<S2SV_blank>Ack" ) ) ; if ( ndo -> ndo_vflag ) { rpl_daoack_print ( ndo , bp , length ) ; } break ; default : ND_PRINT ( ( ndo , "RPL<S2SV_blank>message,<S2SV_blank>unknown<S2SV_blank>code<S2SV_blank>%u" , hdr -> icmp6_code ) ) ; break ; } return ; # if 0 trunc : <S2SV_StartBug> ND_PRINT ( ( ndo , "<S2SV_blank>[|truncated]" ) ) ; <S2SV_EndBug> return ; # endif }
CWE-125 void lmp_print ( netdissect_options * ndo , register const u_char * pptr , register u_int len ) { const struct lmp_common_header * lmp_com_header ; const struct lmp_object_header * lmp_obj_header ; const u_char * tptr , * obj_tptr ; u_int tlen , lmp_obj_len , lmp_obj_ctype , obj_tlen ; <S2SV_StartBug> int hexdump ; <S2SV_EndBug> u_int offset ; u_int link_type ; union { float f ; uint32_t i ; } bw ; tptr = pptr ; lmp_com_header = ( const struct lmp_common_header * ) pptr ; ND_TCHECK ( * lmp_com_header ) ; if ( LMP_EXTRACT_VERSION ( lmp_com_header -> version_res [ 0 ] ) != LMP_VERSION ) { ND_PRINT ( ( ndo , "LMP<S2SV_blank>version<S2SV_blank>%u<S2SV_blank>packet<S2SV_blank>not<S2SV_blank>supported" , LMP_EXTRACT_VERSION ( lmp_com_header -> version_res [ 0 ] ) ) ) ; return ; } if ( ndo -> ndo_vflag < 1 ) { ND_PRINT ( ( ndo , "LMPv%u<S2SV_blank>%s<S2SV_blank>Message,<S2SV_blank>length:<S2SV_blank>%u" , LMP_EXTRACT_VERSION ( lmp_com_header -> version_res [ 0 ] ) , tok2str ( lmp_msg_type_values , "unknown<S2SV_blank>(%u)" , lmp_com_header -> msg_type ) , len ) ) ; return ; } tlen = EXTRACT_16BITS ( lmp_com_header -> length ) ; ND_PRINT ( ( ndo , "\\n\\tLMPv%u,<S2SV_blank>msg-type:<S2SV_blank>%s,<S2SV_blank>Flags:<S2SV_blank>[%s],<S2SV_blank>length:<S2SV_blank>%u" , LMP_EXTRACT_VERSION ( lmp_com_header -> version_res [ 0 ] ) , tok2str ( lmp_msg_type_values , "unknown,<S2SV_blank>type:<S2SV_blank>%u" , lmp_com_header -> msg_type ) , bittok2str ( lmp_header_flag_values , "none" , lmp_com_header -> flags ) , tlen ) ) ; if ( tlen < sizeof ( const struct lmp_common_header ) ) { ND_PRINT ( ( ndo , "<S2SV_blank>(too<S2SV_blank>short)" ) ) ; return ; } if ( tlen > len ) { ND_PRINT ( ( ndo , "<S2SV_blank>(too<S2SV_blank>long)" ) ) ; tlen = len ; } tptr += sizeof ( const struct lmp_common_header ) ; tlen -= sizeof ( const struct lmp_common_header ) ; while ( tlen > 0 ) { ND_TCHECK2 ( * tptr , sizeof ( struct lmp_object_header ) ) ; lmp_obj_header = ( const struct lmp_object_header * ) tptr ; lmp_obj_len = EXTRACT_16BITS ( lmp_obj_header -> length ) ; lmp_obj_ctype = ( lmp_obj_header -> ctype ) & 0x7f ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Object<S2SV_blank>(%u),<S2SV_blank>Class-Type:<S2SV_blank>%s<S2SV_blank>(%u)<S2SV_blank>Flags:<S2SV_blank>[%snegotiable],<S2SV_blank>length:<S2SV_blank>%u" , tok2str ( lmp_obj_values , "Unknown" , lmp_obj_header -> class_num ) , lmp_obj_header -> class_num , tok2str ( lmp_ctype_values , "Unknown" , ( ( lmp_obj_header -> class_num ) << 8 ) + lmp_obj_ctype ) , lmp_obj_ctype , ( lmp_obj_header -> ctype ) & 0x80 ? "" : "non-" , lmp_obj_len ) ) ; if ( lmp_obj_len < 4 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(too<S2SV_blank>short)" ) ) ; return ; } if ( ( lmp_obj_len % 4 ) != 0 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>a<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>4)" ) ) ; return ; } obj_tptr = tptr + sizeof ( struct lmp_object_header ) ; obj_tlen = lmp_obj_len - sizeof ( struct lmp_object_header ) ; ND_TCHECK2 ( * tptr , lmp_obj_len ) ; hexdump = FALSE ; switch ( lmp_obj_header -> class_num ) { case LMP_OBJ_CC_ID : switch ( lmp_obj_ctype ) { case LMP_CTYPE_LOC : case LMP_CTYPE_RMT : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Control<S2SV_blank>Channel<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)" , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_LINK_ID : case LMP_OBJ_INTERFACE_ID : switch ( lmp_obj_ctype ) { case LMP_CTYPE_IPV4_LOC : case LMP_CTYPE_IPV4_RMT : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>IPv4<S2SV_blank>Link<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)" , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; case LMP_CTYPE_IPV6_LOC : case LMP_CTYPE_IPV6_RMT : if ( obj_tlen != 16 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>IPv6<S2SV_blank>Link<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)" , ip6addr_string ( ndo , obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; case LMP_CTYPE_UNMD_LOC : case LMP_CTYPE_UNMD_RMT : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Link<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)" , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_MESSAGE_ID : switch ( lmp_obj_ctype ) { case LMP_CTYPE_1 : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Message<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)" , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; case LMP_CTYPE_2 : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Message<S2SV_blank>ID<S2SV_blank>Ack:<S2SV_blank>%u<S2SV_blank>(0x%08x)" , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_NODE_ID : switch ( lmp_obj_ctype ) { case LMP_CTYPE_LOC : case LMP_CTYPE_RMT : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Node<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)" , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_CONFIG : switch ( lmp_obj_ctype ) { case LMP_CTYPE_HELLO_CONFIG : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Hello<S2SV_blank>Interval:<S2SV_blank>%u\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Hello<S2SV_blank>Dead<S2SV_blank>Interval:<S2SV_blank>%u" , EXTRACT_16BITS ( obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_HELLO : switch ( lmp_obj_ctype ) { case LMP_CTYPE_HELLO : if ( obj_tlen != 8 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Tx<S2SV_blank>Seq:<S2SV_blank>%u,<S2SV_blank>Rx<S2SV_blank>Seq:<S2SV_blank>%u" , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr + 4 ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_TE_LINK : switch ( lmp_obj_ctype ) { case LMP_CTYPE_IPV4 : if ( obj_tlen != 12 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[%s]" , bittok2str ( lmp_obj_te_link_flag_values , "none" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Link-ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)" "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Remote<S2SV_blank>Link-ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)" , ipaddr_string ( ndo , obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , ipaddr_string ( ndo , obj_tptr + 8 ) , EXTRACT_32BITS ( obj_tptr + 8 ) ) ) ; break ; case LMP_CTYPE_IPV6 : if ( obj_tlen != 36 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[%s]" , bittok2str ( lmp_obj_te_link_flag_values , "none" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Link-ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)" "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Remote<S2SV_blank>Link-ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)" , ip6addr_string ( ndo , obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , ip6addr_string ( ndo , obj_tptr + 20 ) , EXTRACT_32BITS ( obj_tptr + 20 ) ) ) ; break ; case LMP_CTYPE_UNMD : if ( obj_tlen != 12 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[%s]" , bittok2str ( lmp_obj_te_link_flag_values , "none" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Link-ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)" "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Remote<S2SV_blank>Link-ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)" , EXTRACT_32BITS ( obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 8 ) , EXTRACT_32BITS ( obj_tptr + 8 ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_DATA_LINK : switch ( lmp_obj_ctype ) { case LMP_CTYPE_IPV4 : if ( obj_tlen < 12 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[%s]" , bittok2str ( lmp_obj_data_link_flag_values , "none" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)" "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Remote<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)" , ipaddr_string ( ndo , obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , ipaddr_string ( ndo , obj_tptr + 8 ) , EXTRACT_32BITS ( obj_tptr + 8 ) ) ) ; <S2SV_StartBug> if ( lmp_print_data_link_subobjs ( ndo , obj_tptr , obj_tlen - 12 , 12 ) ) <S2SV_EndBug> hexdump = TRUE ; break ; case LMP_CTYPE_IPV6 : if ( obj_tlen < 36 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[%s]" , bittok2str ( lmp_obj_data_link_flag_values , "none" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)" "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Remote<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)" , ip6addr_string ( ndo , obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , ip6addr_string ( ndo , obj_tptr + 20 ) , EXTRACT_32BITS ( obj_tptr + 20 ) ) ) ; <S2SV_StartBug> if ( lmp_print_data_link_subobjs ( ndo , obj_tptr , obj_tlen - 36 , 36 ) ) <S2SV_EndBug> hexdump = TRUE ; break ; case LMP_CTYPE_UNMD : if ( obj_tlen < 12 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[%s]" , bittok2str ( lmp_obj_data_link_flag_values , "none" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)" "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Remote<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)" , EXTRACT_32BITS ( obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 8 ) , EXTRACT_32BITS ( obj_tptr + 8 ) ) ) ; <S2SV_StartBug> if ( lmp_print_data_link_subobjs ( ndo , obj_tptr , obj_tlen - 12 , 12 ) ) <S2SV_EndBug> hexdump = TRUE ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_VERIFY_BEGIN : switch ( lmp_obj_ctype ) { case LMP_CTYPE_1 : if ( obj_tlen != 20 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>%s" , bittok2str ( lmp_obj_begin_verify_flag_values , "none" , EXTRACT_16BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Verify<S2SV_blank>Interval:<S2SV_blank>%u" , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Data<S2SV_blank>links:<S2SV_blank>%u" , EXTRACT_32BITS ( obj_tptr + 4 ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Encoding<S2SV_blank>type:<S2SV_blank>%s" , tok2str ( gmpls_encoding_values , "Unknown" , * ( obj_tptr + 8 ) ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Verify<S2SV_blank>Transport<S2SV_blank>Mechanism:<S2SV_blank>%u<S2SV_blank>(0x%x)%s" , EXTRACT_16BITS ( obj_tptr + 10 ) , EXTRACT_16BITS ( obj_tptr + 10 ) , EXTRACT_16BITS ( obj_tptr + 10 ) & 8000 ? "<S2SV_blank>(Payload<S2SV_blank>test<S2SV_blank>messages<S2SV_blank>capable)" : "" ) ) ; bw . i = EXTRACT_32BITS ( obj_tptr + 12 ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Transmission<S2SV_blank>Rate:<S2SV_blank>%.3f<S2SV_blank>Mbps" , bw . f * 8 / 1000000 ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Wavelength:<S2SV_blank>%u" , EXTRACT_32BITS ( obj_tptr + 16 ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_VERIFY_BEGIN_ACK : switch ( lmp_obj_ctype ) { case LMP_CTYPE_1 : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Verify<S2SV_blank>Dead<S2SV_blank>Interval:<S2SV_blank>%u" "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Verify<S2SV_blank>Transport<S2SV_blank>Response:<S2SV_blank>%u" , EXTRACT_16BITS ( obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_VERIFY_ID : switch ( lmp_obj_ctype ) { case LMP_CTYPE_1 : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Verify<S2SV_blank>ID:<S2SV_blank>%u" , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_CHANNEL_STATUS : switch ( lmp_obj_ctype ) { case LMP_CTYPE_IPV4 : offset = 0 ; while ( offset + 8 <= obj_tlen ) { ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)" , ipaddr_string ( ndo , obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Active:<S2SV_blank>%s<S2SV_blank>(%u)" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 31 ) ? "Allocated" : "Non-allocated" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 31 ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Direction:<S2SV_blank>%s<S2SV_blank>(%u)" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 30 ) & 0x1 ? "Transmit" : "Receive" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 30 ) & 0x1 ) ) ; ND_PRINT ( ( ndo , "\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Channel<S2SV_blank>Status:<S2SV_blank>%s<S2SV_blank>(%u)" , tok2str ( lmp_obj_channel_status_values , "Unknown" , EXTRACT_32BITS ( obj_tptr + offset + 4 ) & 0x3FFFFFF ) , EXTRACT_32BITS ( obj_tptr + offset + 4 ) & 0x3FFFFFF ) ) ; offset += 8 ; } break ; case LMP_CTYPE_IPV6 : offset = 0 ; while ( offset + 20 <= obj_tlen ) { ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)" , ip6addr_string ( ndo , obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Active:<S2SV_blank>%s<S2SV_blank>(%u)" , ( EXTRACT_32BITS ( obj_tptr + offset + 16 ) >> 31 ) ? "Allocated" : "Non-allocated" , ( EXTRACT_32BITS ( obj_tptr + offset + 16 ) >> 31 ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Direction:<S2SV_blank>%s<S2SV_blank>(%u)" , ( EXTRACT_32BITS ( obj_tptr + offset + 16 ) >> 30 ) & 0x1 ? "Transmit" : "Receive" , ( EXTRACT_32BITS ( obj_tptr + offset + 16 ) >> 30 ) & 0x1 ) ) ; ND_PRINT ( ( ndo , "\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Channel<S2SV_blank>Status:<S2SV_blank>%s<S2SV_blank>(%u)" , tok2str ( lmp_obj_channel_status_values , "Unknown" , EXTRACT_32BITS ( obj_tptr + offset + 16 ) & 0x3FFFFFF ) , EXTRACT_32BITS ( obj_tptr + offset + 16 ) & 0x3FFFFFF ) ) ; offset += 20 ; } break ; case LMP_CTYPE_UNMD : offset = 0 ; while ( offset + 8 <= obj_tlen ) { ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)" , EXTRACT_32BITS ( obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Active:<S2SV_blank>%s<S2SV_blank>(%u)" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 31 ) ? "Allocated" : "Non-allocated" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 31 ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Direction:<S2SV_blank>%s<S2SV_blank>(%u)" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 30 ) & 0x1 ? "Transmit" : "Receive" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 30 ) & 0x1 ) ) ; ND_PRINT ( ( ndo , "\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Channel<S2SV_blank>Status:<S2SV_blank>%s<S2SV_blank>(%u)" , tok2str ( lmp_obj_channel_status_values , "Unknown" , EXTRACT_32BITS ( obj_tptr + offset + 4 ) & 0x3FFFFFF ) , EXTRACT_32BITS ( obj_tptr + offset + 4 ) & 0x3FFFFFF ) ) ; offset += 8 ; } break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_CHANNEL_STATUS_REQ : switch ( lmp_obj_ctype ) { case LMP_CTYPE_IPV4 : offset = 0 ; while ( offset + 4 <= obj_tlen ) { ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)" , ipaddr_string ( ndo , obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; offset += 4 ; } break ; case LMP_CTYPE_IPV6 : offset = 0 ; while ( offset + 16 <= obj_tlen ) { ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)" , ip6addr_string ( ndo , obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; offset += 16 ; } break ; case LMP_CTYPE_UNMD : offset = 0 ; while ( offset + 4 <= obj_tlen ) { ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)" , EXTRACT_32BITS ( obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; offset += 4 ; } break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_ERROR_CODE : switch ( lmp_obj_ctype ) { case LMP_CTYPE_BEGIN_VERIFY_ERROR : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Error<S2SV_blank>Code:<S2SV_blank>%s" , bittok2str ( lmp_obj_begin_verify_error_values , "none" , EXTRACT_32BITS ( obj_tptr ) ) ) ) ; break ; case LMP_CTYPE_LINK_SUMMARY_ERROR : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Error<S2SV_blank>Code:<S2SV_blank>%s" , bittok2str ( lmp_obj_link_summary_error_values , "none" , EXTRACT_32BITS ( obj_tptr ) ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_SERVICE_CONFIG : switch ( lmp_obj_ctype ) { case LMP_CTYPE_SERVICE_CONFIG_SP : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank>Flags:<S2SV_blank>%s" , bittok2str ( lmp_obj_service_config_sp_flag_values , "none" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>UNI<S2SV_blank>Version:<S2SV_blank>%u" , EXTRACT_8BITS ( obj_tptr + 1 ) ) ) ; break ; case LMP_CTYPE_SERVICE_CONFIG_CPSA : if ( obj_tlen != 16 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } link_type = EXTRACT_8BITS ( obj_tptr ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank>Link<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u)" , tok2str ( lmp_sd_service_config_cpsa_link_type_values , "Unknown" , link_type ) , link_type ) ) ; switch ( link_type ) { case LMP_SD_SERVICE_CONFIG_CPSA_LINK_TYPE_SDH : ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank>Signal<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u)" , tok2str ( lmp_sd_service_config_cpsa_signal_type_sdh_values , "Unknown" , EXTRACT_8BITS ( obj_tptr + 1 ) ) , EXTRACT_8BITS ( obj_tptr + 1 ) ) ) ; break ; case LMP_SD_SERVICE_CONFIG_CPSA_LINK_TYPE_SONET : ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank>Signal<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u)" , tok2str ( lmp_sd_service_config_cpsa_signal_type_sonet_values , "Unknown" , EXTRACT_8BITS ( obj_tptr + 1 ) ) , EXTRACT_8BITS ( obj_tptr + 1 ) ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank>Transparency:<S2SV_blank>%s" , bittok2str ( lmp_obj_service_config_cpsa_tp_flag_values , "none" , EXTRACT_8BITS ( obj_tptr + 2 ) ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank>Contiguous<S2SV_blank>Concatenation<S2SV_blank>Types:<S2SV_blank>%s" , bittok2str ( lmp_obj_service_config_cpsa_cct_flag_values , "none" , EXTRACT_8BITS ( obj_tptr + 3 ) ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank>Minimum<S2SV_blank>NCC:<S2SV_blank>%u" , EXTRACT_16BITS ( obj_tptr + 4 ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank>Maximum<S2SV_blank>NCC:<S2SV_blank>%u" , EXTRACT_16BITS ( obj_tptr + 6 ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank>Minimum<S2SV_blank>NVC:%u" , EXTRACT_16BITS ( obj_tptr + 8 ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank>Maximum<S2SV_blank>NVC:%u" , EXTRACT_16BITS ( obj_tptr + 10 ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)" , ipaddr_string ( ndo , obj_tptr + 12 ) , EXTRACT_32BITS ( obj_tptr + 12 ) ) ) ; break ; case LMP_CTYPE_SERVICE_CONFIG_TRANSPARENCY_TCM : if ( obj_tlen != 8 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank>Transparency<S2SV_blank>Flags:<S2SV_blank>%s" , bittok2str ( lmp_obj_service_config_nsa_transparency_flag_values , "none" , EXTRACT_32BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank>TCM<S2SV_blank>Monitoring<S2SV_blank>Flags:<S2SV_blank>%s" , bittok2str ( lmp_obj_service_config_nsa_tcm_flag_values , "none" , EXTRACT_8BITS ( obj_tptr + 7 ) ) ) ) ; break ; case LMP_CTYPE_SERVICE_CONFIG_NETWORK_DIVERSITY : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank>Diversity:<S2SV_blank>Flags:<S2SV_blank>%s" , bittok2str ( lmp_obj_service_config_nsa_network_diversity_flag_values , "none" , EXTRACT_8BITS ( obj_tptr + 3 ) ) ) ) ; break ; default : hexdump = TRUE ; } break ; default : if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , obj_tptr , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , obj_tlen ) ; break ; } if ( ndo -> ndo_vflag > 1 || hexdump == TRUE ) print_unknown_data ( ndo , tptr + sizeof ( struct lmp_object_header ) , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , lmp_obj_len - sizeof ( struct lmp_object_header ) ) ; tptr += lmp_obj_len ; tlen -= lmp_obj_len ; } return ; trunc : ND_PRINT ( ( ndo , "\\n\\t\\t<S2SV_blank>packet<S2SV_blank>exceeded<S2SV_blank>snapshot" ) ) ; }
CWE-125 static int lmp_print_data_link_subobjs ( netdissect_options * ndo , const u_char * obj_tptr , int total_subobj_len , int offset ) { int hexdump = FALSE ; int subobj_type , subobj_len ; union { float f ; uint32_t i ; } bw ; while ( total_subobj_len > 0 && hexdump == FALSE ) { subobj_type = EXTRACT_8BITS ( obj_tptr + offset ) ; subobj_len = EXTRACT_8BITS ( obj_tptr + offset + 1 ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Subobject,<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>Length:<S2SV_blank>%u" , tok2str ( lmp_data_link_subobj , "Unknown" , subobj_type ) , subobj_type , subobj_len ) ) ; if ( subobj_len < 4 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(too<S2SV_blank>short)" ) ) ; break ; } if ( ( subobj_len % 4 ) != 0 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>a<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>4)" ) ) ; break ; } if ( total_subobj_len < subobj_len ) { ND_PRINT ( ( ndo , "<S2SV_blank>(goes<S2SV_blank>past<S2SV_blank>the<S2SV_blank>end<S2SV_blank>of<S2SV_blank>the<S2SV_blank>object)" ) ) ; break ; } switch ( subobj_type ) { case INT_SWITCHING_TYPE_SUBOBJ : ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Switching<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u)" , tok2str ( gmpls_switch_cap_values , "Unknown" , EXTRACT_8BITS ( obj_tptr + offset + 2 ) ) , EXTRACT_8BITS ( obj_tptr + offset + 2 ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Encoding<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u)" , tok2str ( gmpls_encoding_values , "Unknown" , EXTRACT_8BITS ( obj_tptr + offset + 3 ) ) , EXTRACT_8BITS ( obj_tptr + offset + 3 ) ) ) ; <S2SV_StartBug> bw . i = EXTRACT_32BITS ( obj_tptr + offset + 4 ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Min<S2SV_blank>Reservable<S2SV_blank>Bandwidth:<S2SV_blank>%.3f<S2SV_blank>Mbps" , bw . f * 8 / 1000000 ) ) ; bw . i = EXTRACT_32BITS ( obj_tptr + offset + 8 ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Max<S2SV_blank>Reservable<S2SV_blank>Bandwidth:<S2SV_blank>%.3f<S2SV_blank>Mbps" , bw . f * 8 / 1000000 ) ) ; break ; case WAVELENGTH_SUBOBJ : ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Wavelength:<S2SV_blank>%u" , EXTRACT_32BITS ( obj_tptr + offset + 4 ) ) ) ; break ; default : hexdump = TRUE ; break ; } total_subobj_len -= subobj_len ; offset += subobj_len ; } return ( hexdump ) ; <S2SV_StartBug> } <S2SV_EndBug>
CWE-125 static int ospf6_print_lshdr ( netdissect_options * ndo , register const struct lsa6_hdr * lshp , const u_char * dataend ) { if ( ( const u_char * ) ( lshp + 1 ) > dataend ) goto trunc ; <S2SV_StartBug> ND_TCHECK ( lshp -> ls_type ) ; <S2SV_EndBug> ND_TCHECK ( lshp -> ls_seq ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>Advertising<S2SV_blank>Router<S2SV_blank>%s,<S2SV_blank>seq<S2SV_blank>0x%08x,<S2SV_blank>age<S2SV_blank>%us,<S2SV_blank>length<S2SV_blank>%u" , ipaddr_string ( ndo , & lshp -> ls_router ) , EXTRACT_32BITS ( & lshp -> ls_seq ) , EXTRACT_16BITS ( & lshp -> ls_age ) , EXTRACT_16BITS ( & lshp -> ls_length ) - ( u_int ) sizeof ( struct lsa6_hdr ) ) ) ; ospf6_print_ls_type ( ndo , EXTRACT_16BITS ( & lshp -> ls_type ) , & lshp -> ls_stateid ) ; return ( 0 ) ; trunc : return ( 1 ) ; }
CWE-125 static void bgp_capabilities_print ( netdissect_options * ndo , const u_char * opt , int caps_len ) { int cap_type , cap_len , tcap_len , cap_offset ; int i = 0 ; while ( i < caps_len ) { ND_TCHECK2 ( opt [ i ] , BGP_CAP_HEADER_SIZE ) ; cap_type = opt [ i ] ; cap_len = opt [ i + 1 ] ; tcap_len = cap_len ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>length:<S2SV_blank>%u" , tok2str ( bgp_capcode_values , "Unknown" , cap_type ) , cap_type , cap_len ) ) ; ND_TCHECK2 ( opt [ i + 2 ] , cap_len ) ; switch ( cap_type ) { <S2SV_StartBug> case BGP_CAPCODE_MP : <S2SV_EndBug> ND_PRINT ( ( ndo , "\\n\\t\\tAFI<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>SAFI<S2SV_blank>%s<S2SV_blank>(%u)" , tok2str ( af_values , "Unknown" , EXTRACT_16BITS ( opt + i + 2 ) ) , EXTRACT_16BITS ( opt + i + 2 ) , tok2str ( bgp_safi_values , "Unknown" , opt [ i + 5 ] ) , opt [ i + 5 ] ) ) ; break ; case BGP_CAPCODE_RESTART : ND_TCHECK_16BITS ( opt + i + 2 ) ; ND_PRINT ( ( ndo , "\\n\\t\\tRestart<S2SV_blank>Flags:<S2SV_blank>[%s],<S2SV_blank>Restart<S2SV_blank>Time<S2SV_blank>%us" , ( ( opt [ i + 2 ] ) & 0x80 ) ? "R" : "none" , EXTRACT_16BITS ( opt + i + 2 ) & 0xfff ) ) ; tcap_len -= 2 ; cap_offset = 4 ; while ( tcap_len >= 4 ) { ND_PRINT ( ( ndo , "\\n\\t\\t<S2SV_blank><S2SV_blank>AFI<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>SAFI<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>Forwarding<S2SV_blank>state<S2SV_blank>preserved:<S2SV_blank>%s" , tok2str ( af_values , "Unknown" , EXTRACT_16BITS ( opt + i + cap_offset ) ) , EXTRACT_16BITS ( opt + i + cap_offset ) , tok2str ( bgp_safi_values , "Unknown" , opt [ i + cap_offset + 2 ] ) , opt [ i + cap_offset + 2 ] , ( ( opt [ i + cap_offset + 3 ] ) & 0x80 ) ? "yes" : "no" ) ) ; tcap_len -= 4 ; cap_offset += 4 ; } break ; case BGP_CAPCODE_RR : case BGP_CAPCODE_RR_CISCO : break ; case BGP_CAPCODE_AS_NEW : if ( cap_len == 4 ) { ND_PRINT ( ( ndo , "\\n\\t\\t<S2SV_blank>4<S2SV_blank>Byte<S2SV_blank>AS<S2SV_blank>%s" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( opt + i + 2 ) ) ) ) ; } break ; case BGP_CAPCODE_ADD_PATH : cap_offset = 2 ; if ( tcap_len == 0 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(bogus)" ) ) ; break ; } while ( tcap_len > 0 ) { if ( tcap_len < 4 ) { ND_PRINT ( ( ndo , "\\n\\t\\t(invalid)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t\\tAFI<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>SAFI<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>Send/Receive:<S2SV_blank>%s" , tok2str ( af_values , "Unknown" , EXTRACT_16BITS ( opt + i + cap_offset ) ) , EXTRACT_16BITS ( opt + i + cap_offset ) , tok2str ( bgp_safi_values , "Unknown" , opt [ i + cap_offset + 2 ] ) , opt [ i + cap_offset + 2 ] , tok2str ( bgp_add_path_recvsend , "Bogus<S2SV_blank>(0x%02x)" , opt [ i + cap_offset + 3 ] ) ) ) ; tcap_len -= 4 ; cap_offset += 4 ; } break ; default : ND_PRINT ( ( ndo , "\\n\\t\\tno<S2SV_blank>decoder<S2SV_blank>for<S2SV_blank>Capability<S2SV_blank>%u" , cap_type ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , & opt [ i + 2 ] , "\\n\\t\\t" , cap_len ) ; break ; } if ( ndo -> ndo_vflag > 1 && cap_len > 0 ) { print_unknown_data ( ndo , & opt [ i + 2 ] , "\\n\\t\\t" , cap_len ) ; } i += BGP_CAP_HEADER_SIZE + cap_len ; } return ; trunc : ND_PRINT ( ( ndo , "[|BGP]" ) ) ; }
CWE-119 bool radeon_atom_get_tv_timings ( struct radeon_device * rdev , int index , struct drm_display_mode * mode ) { struct radeon_mode_info * mode_info = & rdev -> mode_info ; ATOM_ANALOG_TV_INFO * tv_info ; ATOM_ANALOG_TV_INFO_V1_2 * tv_info_v1_2 ; ATOM_DTD_FORMAT * dtd_timings ; int data_index = GetIndexIntoMasterTable ( DATA , AnalogTV_Info ) ; u8 frev , crev ; u16 data_offset , misc ; if ( ! atom_parse_data_header ( mode_info -> atom_context , data_index , NULL , & frev , & crev , & data_offset ) ) return false ; switch ( crev ) { case 1 : tv_info = ( ATOM_ANALOG_TV_INFO * ) ( mode_info -> atom_context -> bios + data_offset ) ; <S2SV_StartBug> if ( index > MAX_SUPPORTED_TV_TIMING ) <S2SV_EndBug> return false ; mode -> crtc_htotal = le16_to_cpu ( tv_info -> aModeTimings [ index ] . usCRTC_H_Total ) ; mode -> crtc_hdisplay = le16_to_cpu ( tv_info -> aModeTimings [ index ] . usCRTC_H_Disp ) ; mode -> crtc_hsync_start = le16_to_cpu ( tv_info -> aModeTimings [ index ] . usCRTC_H_SyncStart ) ; mode -> crtc_hsync_end = le16_to_cpu ( tv_info -> aModeTimings [ index ] . usCRTC_H_SyncStart ) + le16_to_cpu ( tv_info -> aModeTimings [ index ] . usCRTC_H_SyncWidth ) ; mode -> crtc_vtotal = le16_to_cpu ( tv_info -> aModeTimings [ index ] . usCRTC_V_Total ) ; mode -> crtc_vdisplay = le16_to_cpu ( tv_info -> aModeTimings [ index ] . usCRTC_V_Disp ) ; mode -> crtc_vsync_start = le16_to_cpu ( tv_info -> aModeTimings [ index ] . usCRTC_V_SyncStart ) ; mode -> crtc_vsync_end = le16_to_cpu ( tv_info -> aModeTimings [ index ] . usCRTC_V_SyncStart ) + le16_to_cpu ( tv_info -> aModeTimings [ index ] . usCRTC_V_SyncWidth ) ; mode -> flags = 0 ; misc = le16_to_cpu ( tv_info -> aModeTimings [ index ] . susModeMiscInfo . usAccess ) ; if ( misc & ATOM_VSYNC_POLARITY ) mode -> flags |= DRM_MODE_FLAG_NVSYNC ; if ( misc & ATOM_HSYNC_POLARITY ) mode -> flags |= DRM_MODE_FLAG_NHSYNC ; if ( misc & ATOM_COMPOSITESYNC ) mode -> flags |= DRM_MODE_FLAG_CSYNC ; if ( misc & ATOM_INTERLACE ) mode -> flags |= DRM_MODE_FLAG_INTERLACE ; if ( misc & ATOM_DOUBLE_CLOCK_MODE ) mode -> flags |= DRM_MODE_FLAG_DBLSCAN ; mode -> clock = le16_to_cpu ( tv_info -> aModeTimings [ index ] . usPixelClock ) * 10 ; if ( index == 1 ) { mode -> crtc_htotal -= 1 ; mode -> crtc_vtotal -= 1 ; } break ; case 2 : tv_info_v1_2 = ( ATOM_ANALOG_TV_INFO_V1_2 * ) ( mode_info -> atom_context -> bios + data_offset ) ; <S2SV_StartBug> if ( index > MAX_SUPPORTED_TV_TIMING_V1_2 ) <S2SV_EndBug> return false ; dtd_timings = & tv_info_v1_2 -> aModeTimings [ index ] ; mode -> crtc_htotal = le16_to_cpu ( dtd_timings -> usHActive ) + le16_to_cpu ( dtd_timings -> usHBlanking_Time ) ; mode -> crtc_hdisplay = le16_to_cpu ( dtd_timings -> usHActive ) ; mode -> crtc_hsync_start = le16_to_cpu ( dtd_timings -> usHActive ) + le16_to_cpu ( dtd_timings -> usHSyncOffset ) ; mode -> crtc_hsync_end = mode -> crtc_hsync_start + le16_to_cpu ( dtd_timings -> usHSyncWidth ) ; mode -> crtc_vtotal = le16_to_cpu ( dtd_timings -> usVActive ) + le16_to_cpu ( dtd_timings -> usVBlanking_Time ) ; mode -> crtc_vdisplay = le16_to_cpu ( dtd_timings -> usVActive ) ; mode -> crtc_vsync_start = le16_to_cpu ( dtd_timings -> usVActive ) + le16_to_cpu ( dtd_timings -> usVSyncOffset ) ; mode -> crtc_vsync_end = mode -> crtc_vsync_start + le16_to_cpu ( dtd_timings -> usVSyncWidth ) ; mode -> flags = 0 ; misc = le16_to_cpu ( dtd_timings -> susModeMiscInfo . usAccess ) ; if ( misc & ATOM_VSYNC_POLARITY ) mode -> flags |= DRM_MODE_FLAG_NVSYNC ; if ( misc & ATOM_HSYNC_POLARITY ) mode -> flags |= DRM_MODE_FLAG_NHSYNC ; if ( misc & ATOM_COMPOSITESYNC ) mode -> flags |= DRM_MODE_FLAG_CSYNC ; if ( misc & ATOM_INTERLACE ) mode -> flags |= DRM_MODE_FLAG_INTERLACE ; if ( misc & ATOM_DOUBLE_CLOCK_MODE ) mode -> flags |= DRM_MODE_FLAG_DBLSCAN ; mode -> clock = le16_to_cpu ( dtd_timings -> usPixClk ) * 10 ; break ; } return true ; }
CWE-362 void uverbs_user_mmap_disassociate ( struct ib_uverbs_file * ufile ) { struct rdma_umap_priv * priv , * next_priv ; lockdep_assert_held ( & ufile -> hw_destroy_rwsem ) ; while ( 1 ) { struct mm_struct * mm = NULL ; mutex_lock ( & ufile -> umap_lock ) ; while ( ! list_empty ( & ufile -> umaps ) ) { int ret ; priv = list_first_entry ( & ufile -> umaps , struct rdma_umap_priv , list ) ; mm = priv -> vma -> vm_mm ; ret = mmget_not_zero ( mm ) ; if ( ! ret ) { list_del_init ( & priv -> list ) ; mm = NULL ; continue ; } break ; } mutex_unlock ( & ufile -> umap_lock ) ; if ( ! mm ) return ; <S2SV_StartBug> down_write ( & mm -> mmap_sem ) ; <S2SV_EndBug> mutex_lock ( & ufile -> umap_lock ) ; list_for_each_entry_safe ( priv , next_priv , & ufile -> umaps , list ) { struct vm_area_struct * vma = priv -> vma ; if ( vma -> vm_mm != mm ) continue ; list_del_init ( & priv -> list ) ; zap_vma_ptes ( vma , vma -> vm_start , vma -> vm_end - vma -> vm_start ) ; vma -> vm_flags &= ~ ( VM_SHARED | VM_MAYSHARE ) ; } mutex_unlock ( & ufile -> umap_lock ) ; <S2SV_StartBug> up_write ( & mm -> mmap_sem ) ; <S2SV_EndBug> mmput ( mm ) ; } }
CWE-362 static void userfaultfd_event_wait_completion ( struct userfaultfd_ctx * ctx , struct userfaultfd_wait_queue * ewq ) { struct userfaultfd_ctx * release_new_ctx ; if ( WARN_ON_ONCE ( current -> flags & PF_EXITING ) ) goto out ; ewq -> ctx = ctx ; init_waitqueue_entry ( & ewq -> wq , current ) ; release_new_ctx = NULL ; spin_lock ( & ctx -> event_wqh . lock ) ; __add_wait_queue ( & ctx -> event_wqh , & ewq -> wq ) ; for ( ; ; ) { set_current_state ( TASK_KILLABLE ) ; if ( ewq -> msg . event == 0 ) break ; if ( READ_ONCE ( ctx -> released ) || fatal_signal_pending ( current ) ) { __remove_wait_queue ( & ctx -> event_wqh , & ewq -> wq ) ; if ( ewq -> msg . event == UFFD_EVENT_FORK ) { struct userfaultfd_ctx * new ; new = ( struct userfaultfd_ctx * ) ( unsigned long ) ewq -> msg . arg . reserved . reserved1 ; release_new_ctx = new ; } break ; } spin_unlock ( & ctx -> event_wqh . lock ) ; wake_up_poll ( & ctx -> fd_wqh , EPOLLIN ) ; schedule ( ) ; spin_lock ( & ctx -> event_wqh . lock ) ; } __set_current_state ( TASK_RUNNING ) ; spin_unlock ( & ctx -> event_wqh . lock ) ; if ( release_new_ctx ) { struct vm_area_struct * vma ; struct mm_struct * mm = release_new_ctx -> mm ; down_write ( & mm -> mmap_sem ) ; <S2SV_StartBug> for ( vma = mm -> mmap ; vma ; vma = vma -> vm_next ) <S2SV_EndBug> if ( vma -> vm_userfaultfd_ctx . ctx == release_new_ctx ) { vma -> vm_userfaultfd_ctx = NULL_VM_UFFD_CTX ; vma -> vm_flags &= ~ ( VM_UFFD_WP | VM_UFFD_MISSING ) ; } up_write ( & mm -> mmap_sem ) ; userfaultfd_ctx_put ( release_new_ctx ) ; } out : WRITE_ONCE ( ctx -> mmap_changing , false ) ; userfaultfd_ctx_put ( ctx ) ; }
CWE-362 static int userfaultfd_register ( struct userfaultfd_ctx * ctx , unsigned long arg ) { struct mm_struct * mm = ctx -> mm ; struct vm_area_struct * vma , * prev , * cur ; int ret ; struct uffdio_register uffdio_register ; struct uffdio_register __user * user_uffdio_register ; unsigned long vm_flags , new_flags ; bool found ; bool basic_ioctls ; unsigned long start , end , vma_end ; user_uffdio_register = ( struct uffdio_register __user * ) arg ; ret = - EFAULT ; if ( copy_from_user ( & uffdio_register , user_uffdio_register , sizeof ( uffdio_register ) - sizeof ( __u64 ) ) ) goto out ; ret = - EINVAL ; if ( ! uffdio_register . mode ) goto out ; if ( uffdio_register . mode & ~ ( UFFDIO_REGISTER_MODE_MISSING | UFFDIO_REGISTER_MODE_WP ) ) goto out ; vm_flags = 0 ; if ( uffdio_register . mode & UFFDIO_REGISTER_MODE_MISSING ) vm_flags |= VM_UFFD_MISSING ; if ( uffdio_register . mode & UFFDIO_REGISTER_MODE_WP ) { vm_flags |= VM_UFFD_WP ; ret = - EINVAL ; goto out ; } ret = validate_range ( mm , uffdio_register . range . start , uffdio_register . range . len ) ; if ( ret ) goto out ; start = uffdio_register . range . start ; end = start + uffdio_register . range . len ; ret = - ENOMEM ; if ( ! mmget_not_zero ( mm ) ) goto out ; <S2SV_StartBug> down_write ( & mm -> mmap_sem ) ; <S2SV_EndBug> vma = find_vma_prev ( mm , start , & prev ) ; if ( ! vma ) goto out_unlock ; ret = - EINVAL ; if ( vma -> vm_start >= end ) goto out_unlock ; if ( is_vm_hugetlb_page ( vma ) ) { unsigned long vma_hpagesize = vma_kernel_pagesize ( vma ) ; if ( start & ( vma_hpagesize - 1 ) ) goto out_unlock ; } found = false ; basic_ioctls = false ; for ( cur = vma ; cur && cur -> vm_start < end ; cur = cur -> vm_next ) { cond_resched ( ) ; BUG_ON ( ! ! cur -> vm_userfaultfd_ctx . ctx ^ ! ! ( cur -> vm_flags & ( VM_UFFD_MISSING | VM_UFFD_WP ) ) ) ; ret = - EINVAL ; if ( ! vma_can_userfault ( cur ) ) goto out_unlock ; ret = - EPERM ; if ( unlikely ( ! ( cur -> vm_flags & VM_MAYWRITE ) ) ) goto out_unlock ; if ( is_vm_hugetlb_page ( cur ) && end <= cur -> vm_end && end > cur -> vm_start ) { unsigned long vma_hpagesize = vma_kernel_pagesize ( cur ) ; ret = - EINVAL ; if ( end & ( vma_hpagesize - 1 ) ) goto out_unlock ; } ret = - EBUSY ; if ( cur -> vm_userfaultfd_ctx . ctx && cur -> vm_userfaultfd_ctx . ctx != ctx ) goto out_unlock ; if ( is_vm_hugetlb_page ( cur ) ) basic_ioctls = true ; found = true ; } BUG_ON ( ! found ) ; if ( vma -> vm_start < start ) prev = vma ; ret = 0 ; do { cond_resched ( ) ; BUG_ON ( ! vma_can_userfault ( vma ) ) ; BUG_ON ( vma -> vm_userfaultfd_ctx . ctx && vma -> vm_userfaultfd_ctx . ctx != ctx ) ; WARN_ON ( ! ( vma -> vm_flags & VM_MAYWRITE ) ) ; if ( vma -> vm_userfaultfd_ctx . ctx == ctx && ( vma -> vm_flags & vm_flags ) == vm_flags ) goto skip ; if ( vma -> vm_start > start ) start = vma -> vm_start ; vma_end = min ( end , vma -> vm_end ) ; new_flags = ( vma -> vm_flags & ~ vm_flags ) | vm_flags ; prev = vma_merge ( mm , prev , start , vma_end , new_flags , vma -> anon_vma , vma -> vm_file , vma -> vm_pgoff , vma_policy ( vma ) , ( ( struct vm_userfaultfd_ctx ) { ctx } ) ) ; if ( prev ) { vma = prev ; goto next ; } if ( vma -> vm_start < start ) { ret = split_vma ( mm , vma , start , 1 ) ; if ( ret ) break ; } if ( vma -> vm_end > end ) { ret = split_vma ( mm , vma , end , 0 ) ; if ( ret ) break ; } next : vma -> vm_flags = new_flags ; vma -> vm_userfaultfd_ctx . ctx = ctx ; skip : prev = vma ; start = vma -> vm_end ; vma = vma -> vm_next ; } while ( vma && vma -> vm_start < end ) ; out_unlock : up_write ( & mm -> mmap_sem ) ; mmput ( mm ) ; if ( ! ret ) { if ( put_user ( basic_ioctls ? UFFD_API_RANGE_IOCTLS_BASIC : UFFD_API_RANGE_IOCTLS , & user_uffdio_register -> ioctls ) ) ret = - EFAULT ; } out : return ret ; }
CWE-362 static int userfaultfd_release ( struct inode * inode , struct file * file ) { struct userfaultfd_ctx * ctx = file -> private_data ; struct mm_struct * mm = ctx -> mm ; struct vm_area_struct * vma , * prev ; struct userfaultfd_wake_range range = { . len = 0 , } ; unsigned long new_flags ; WRITE_ONCE ( ctx -> released , true ) ; if ( ! mmget_not_zero ( mm ) ) goto wakeup ; down_write ( & mm -> mmap_sem ) ; <S2SV_StartBug> prev = NULL ; <S2SV_EndBug> for ( vma = mm -> mmap ; vma ; vma = vma -> vm_next ) { cond_resched ( ) ; BUG_ON ( ! ! vma -> vm_userfaultfd_ctx . ctx ^ ! ! ( vma -> vm_flags & ( VM_UFFD_MISSING | VM_UFFD_WP ) ) ) ; if ( vma -> vm_userfaultfd_ctx . ctx != ctx ) { prev = vma ; continue ; } new_flags = vma -> vm_flags & ~ ( VM_UFFD_MISSING | VM_UFFD_WP ) ; prev = vma_merge ( mm , prev , vma -> vm_start , vma -> vm_end , new_flags , vma -> anon_vma , vma -> vm_file , vma -> vm_pgoff , vma_policy ( vma ) , NULL_VM_UFFD_CTX ) ; if ( prev ) vma = prev ; else prev = vma ; vma -> vm_flags = new_flags ; vma -> vm_userfaultfd_ctx = NULL_VM_UFFD_CTX ; } <S2SV_StartBug> up_write ( & mm -> mmap_sem ) ; <S2SV_EndBug> mmput ( mm ) ; wakeup : spin_lock ( & ctx -> fault_pending_wqh . lock ) ; __wake_up_locked_key ( & ctx -> fault_pending_wqh , TASK_NORMAL , & range ) ; __wake_up ( & ctx -> fault_wqh , TASK_NORMAL , 1 , & range ) ; spin_unlock ( & ctx -> fault_pending_wqh . lock ) ; wake_up_all ( & ctx -> event_wqh ) ; wake_up_poll ( & ctx -> fd_wqh , EPOLLHUP ) ; userfaultfd_ctx_put ( ctx ) ; return 0 ; }
CWE-362 static int userfaultfd_unregister ( struct userfaultfd_ctx * ctx , unsigned long arg ) { struct mm_struct * mm = ctx -> mm ; struct vm_area_struct * vma , * prev , * cur ; int ret ; struct uffdio_range uffdio_unregister ; unsigned long new_flags ; bool found ; unsigned long start , end , vma_end ; const void __user * buf = ( void __user * ) arg ; ret = - EFAULT ; if ( copy_from_user ( & uffdio_unregister , buf , sizeof ( uffdio_unregister ) ) ) goto out ; ret = validate_range ( mm , uffdio_unregister . start , uffdio_unregister . len ) ; if ( ret ) goto out ; start = uffdio_unregister . start ; end = start + uffdio_unregister . len ; ret = - ENOMEM ; if ( ! mmget_not_zero ( mm ) ) goto out ; down_write ( & mm -> mmap_sem ) ; <S2SV_StartBug> vma = find_vma_prev ( mm , start , & prev ) ; <S2SV_EndBug> if ( ! vma ) goto out_unlock ; ret = - EINVAL ; if ( vma -> vm_start >= end ) goto out_unlock ; if ( is_vm_hugetlb_page ( vma ) ) { unsigned long vma_hpagesize = vma_kernel_pagesize ( vma ) ; if ( start & ( vma_hpagesize - 1 ) ) goto out_unlock ; } found = false ; ret = - EINVAL ; for ( cur = vma ; cur && cur -> vm_start < end ; cur = cur -> vm_next ) { cond_resched ( ) ; BUG_ON ( ! ! cur -> vm_userfaultfd_ctx . ctx ^ ! ! ( cur -> vm_flags & ( VM_UFFD_MISSING | VM_UFFD_WP ) ) ) ; if ( ! vma_can_userfault ( cur ) ) goto out_unlock ; found = true ; } BUG_ON ( ! found ) ; if ( vma -> vm_start < start ) prev = vma ; ret = 0 ; do { cond_resched ( ) ; BUG_ON ( ! vma_can_userfault ( vma ) ) ; if ( ! vma -> vm_userfaultfd_ctx . ctx ) goto skip ; WARN_ON ( ! ( vma -> vm_flags & VM_MAYWRITE ) ) ; if ( vma -> vm_start > start ) start = vma -> vm_start ; vma_end = min ( end , vma -> vm_end ) ; if ( userfaultfd_missing ( vma ) ) { struct userfaultfd_wake_range range ; range . start = start ; range . len = vma_end - start ; wake_userfault ( vma -> vm_userfaultfd_ctx . ctx , & range ) ; } new_flags = vma -> vm_flags & ~ ( VM_UFFD_MISSING | VM_UFFD_WP ) ; prev = vma_merge ( mm , prev , start , vma_end , new_flags , vma -> anon_vma , vma -> vm_file , vma -> vm_pgoff , vma_policy ( vma ) , NULL_VM_UFFD_CTX ) ; if ( prev ) { vma = prev ; goto next ; } if ( vma -> vm_start < start ) { ret = split_vma ( mm , vma , start , 1 ) ; if ( ret ) break ; } if ( vma -> vm_end > end ) { ret = split_vma ( mm , vma , end , 0 ) ; if ( ret ) break ; } next : vma -> vm_flags = new_flags ; vma -> vm_userfaultfd_ctx = NULL_VM_UFFD_CTX ; skip : prev = vma ; start = vma -> vm_end ; vma = vma -> vm_next ; } while ( vma && vma -> vm_start < end ) ; out_unlock : up_write ( & mm -> mmap_sem ) ; mmput ( mm ) ; out : return ret ; }
CWE-362 struct vm_area_struct * find_extend_vma ( struct mm_struct * mm , unsigned long addr ) { struct vm_area_struct * vma ; unsigned long start ; addr &= PAGE_MASK ; vma = find_vma ( mm , addr ) ; if ( ! vma ) return NULL ; if ( vma -> vm_start <= addr ) return vma ; if ( ! ( vma -> vm_flags & VM_GROWSDOWN ) ) return NULL ; <S2SV_StartBug> start = vma -> vm_start ; <S2SV_EndBug> if ( expand_stack ( vma , addr ) ) return NULL ; if ( vma -> vm_flags & VM_LOCKED ) populate_vma_page_range ( vma , addr , start , NULL ) ; return vma ; }
CWE-119 static int create_qp_common ( struct mlx5_ib_dev * dev , struct ib_pd * pd , struct ib_qp_init_attr * init_attr , struct ib_udata * udata , struct mlx5_ib_qp * qp ) { struct mlx5_ib_resources * devr = & dev -> devr ; int inlen = MLX5_ST_SZ_BYTES ( create_qp_in ) ; struct mlx5_core_dev * mdev = dev -> mdev ; <S2SV_StartBug> struct mlx5_ib_create_qp_resp resp ; <S2SV_EndBug> struct mlx5_ib_cq * send_cq ; struct mlx5_ib_cq * recv_cq ; unsigned long flags ; u32 uidx = MLX5_IB_DEFAULT_UIDX ; struct mlx5_ib_create_qp ucmd ; struct mlx5_ib_qp_base * base ; int mlx5_st ; void * qpc ; u32 * in ; int err ; mutex_init ( & qp -> mutex ) ; spin_lock_init ( & qp -> sq . lock ) ; spin_lock_init ( & qp -> rq . lock ) ; mlx5_st = to_mlx5_st ( init_attr -> qp_type ) ; if ( mlx5_st < 0 ) return - EINVAL ; if ( init_attr -> rwq_ind_tbl ) { if ( ! udata ) return - ENOSYS ; err = create_rss_raw_qp_tir ( dev , qp , pd , init_attr , udata ) ; return err ; } if ( init_attr -> create_flags & IB_QP_CREATE_BLOCK_MULTICAST_LOOPBACK ) { if ( ! MLX5_CAP_GEN ( mdev , block_lb_mc ) ) { mlx5_ib_dbg ( dev , "block<S2SV_blank>multicast<S2SV_blank>loopback<S2SV_blank>isn\'t<S2SV_blank>supported\\n" ) ; return - EINVAL ; } else { qp -> flags |= MLX5_IB_QP_BLOCK_MULTICAST_LOOPBACK ; } } if ( init_attr -> create_flags & ( IB_QP_CREATE_CROSS_CHANNEL | IB_QP_CREATE_MANAGED_SEND | IB_QP_CREATE_MANAGED_RECV ) ) { if ( ! MLX5_CAP_GEN ( mdev , cd ) ) { mlx5_ib_dbg ( dev , "cross-channel<S2SV_blank>isn\'t<S2SV_blank>supported\\n" ) ; return - EINVAL ; } if ( init_attr -> create_flags & IB_QP_CREATE_CROSS_CHANNEL ) qp -> flags |= MLX5_IB_QP_CROSS_CHANNEL ; if ( init_attr -> create_flags & IB_QP_CREATE_MANAGED_SEND ) qp -> flags |= MLX5_IB_QP_MANAGED_SEND ; if ( init_attr -> create_flags & IB_QP_CREATE_MANAGED_RECV ) qp -> flags |= MLX5_IB_QP_MANAGED_RECV ; } if ( init_attr -> qp_type == IB_QPT_UD && ( init_attr -> create_flags & IB_QP_CREATE_IPOIB_UD_LSO ) ) if ( ! MLX5_CAP_GEN ( mdev , ipoib_basic_offloads ) ) { mlx5_ib_dbg ( dev , "ipoib<S2SV_blank>UD<S2SV_blank>lso<S2SV_blank>qp<S2SV_blank>isn\'t<S2SV_blank>supported\\n" ) ; return - EOPNOTSUPP ; } if ( init_attr -> create_flags & IB_QP_CREATE_SCATTER_FCS ) { if ( init_attr -> qp_type != IB_QPT_RAW_PACKET ) { mlx5_ib_dbg ( dev , "Scatter<S2SV_blank>FCS<S2SV_blank>is<S2SV_blank>supported<S2SV_blank>only<S2SV_blank>for<S2SV_blank>Raw<S2SV_blank>Packet<S2SV_blank>QPs" ) ; return - EOPNOTSUPP ; } if ( ! MLX5_CAP_GEN ( dev -> mdev , eth_net_offloads ) || ! MLX5_CAP_ETH ( dev -> mdev , scatter_fcs ) ) { mlx5_ib_dbg ( dev , "Scatter<S2SV_blank>FCS<S2SV_blank>isn\'t<S2SV_blank>supported\\n" ) ; return - EOPNOTSUPP ; } qp -> flags |= MLX5_IB_QP_CAP_SCATTER_FCS ; } if ( init_attr -> sq_sig_type == IB_SIGNAL_ALL_WR ) qp -> sq_signal_bits = MLX5_WQE_CTRL_CQ_UPDATE ; if ( init_attr -> create_flags & IB_QP_CREATE_CVLAN_STRIPPING ) { if ( ! ( MLX5_CAP_GEN ( dev -> mdev , eth_net_offloads ) && MLX5_CAP_ETH ( dev -> mdev , vlan_cap ) ) || ( init_attr -> qp_type != IB_QPT_RAW_PACKET ) ) return - EOPNOTSUPP ; qp -> flags |= MLX5_IB_QP_CVLAN_STRIPPING ; } if ( pd && pd -> uobject ) { if ( ib_copy_from_udata ( & ucmd , udata , sizeof ( ucmd ) ) ) { mlx5_ib_dbg ( dev , "copy<S2SV_blank>failed\\n" ) ; return - EFAULT ; } err = get_qp_user_index ( to_mucontext ( pd -> uobject -> context ) , & ucmd , udata -> inlen , & uidx ) ; if ( err ) return err ; qp -> wq_sig = ! ! ( ucmd . flags & MLX5_QP_FLAG_SIGNATURE ) ; qp -> scat_cqe = ! ! ( ucmd . flags & MLX5_QP_FLAG_SCATTER_CQE ) ; if ( ucmd . flags & MLX5_QP_FLAG_TUNNEL_OFFLOADS ) { if ( init_attr -> qp_type != IB_QPT_RAW_PACKET || ! tunnel_offload_supported ( mdev ) ) { mlx5_ib_dbg ( dev , "Tunnel<S2SV_blank>offload<S2SV_blank>isn\'t<S2SV_blank>supported\\n" ) ; return - EOPNOTSUPP ; } qp -> tunnel_offload_en = true ; } if ( init_attr -> create_flags & IB_QP_CREATE_SOURCE_QPN ) { if ( init_attr -> qp_type != IB_QPT_UD || ( MLX5_CAP_GEN ( dev -> mdev , port_type ) != MLX5_CAP_PORT_TYPE_IB ) || ! mlx5_get_flow_namespace ( dev -> mdev , MLX5_FLOW_NAMESPACE_BYPASS ) ) { mlx5_ib_dbg ( dev , "Source<S2SV_blank>QP<S2SV_blank>option<S2SV_blank>isn\'t<S2SV_blank>supported\\n" ) ; return - EOPNOTSUPP ; } qp -> flags |= MLX5_IB_QP_UNDERLAY ; qp -> underlay_qpn = init_attr -> source_qpn ; } } else { qp -> wq_sig = ! ! wq_signature ; } base = ( init_attr -> qp_type == IB_QPT_RAW_PACKET || qp -> flags & MLX5_IB_QP_UNDERLAY ) ? & qp -> raw_packet_qp . rq . base : & qp -> trans_qp . base ; qp -> has_rq = qp_has_rq ( init_attr ) ; err = set_rq_size ( dev , & init_attr -> cap , qp -> has_rq , qp , ( pd && pd -> uobject ) ? & ucmd : NULL ) ; if ( err ) { mlx5_ib_dbg ( dev , "err<S2SV_blank>%d\\n" , err ) ; return err ; } if ( pd ) { if ( pd -> uobject ) { __u32 max_wqes = 1 << MLX5_CAP_GEN ( mdev , log_max_qp_sz ) ; mlx5_ib_dbg ( dev , "requested<S2SV_blank>sq_wqe_count<S2SV_blank>(%d)\\n" , ucmd . sq_wqe_count ) ; if ( ucmd . rq_wqe_shift != qp -> rq . wqe_shift || ucmd . rq_wqe_count != qp -> rq . wqe_cnt ) { mlx5_ib_dbg ( dev , "invalid<S2SV_blank>rq<S2SV_blank>params\\n" ) ; return - EINVAL ; } if ( ucmd . sq_wqe_count > max_wqes ) { mlx5_ib_dbg ( dev , "requested<S2SV_blank>sq_wqe_count<S2SV_blank>(%d)<S2SV_blank>><S2SV_blank>max<S2SV_blank>allowed<S2SV_blank>(%d)\\n" , ucmd . sq_wqe_count , max_wqes ) ; return - EINVAL ; } if ( init_attr -> create_flags & mlx5_ib_create_qp_sqpn_qp1 ( ) ) { mlx5_ib_dbg ( dev , "user-space<S2SV_blank>is<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>UD<S2SV_blank>QPs<S2SV_blank>spoofing<S2SV_blank>as<S2SV_blank>QP1\\n" ) ; return - EINVAL ; } err = create_user_qp ( dev , pd , qp , udata , init_attr , & in , & resp , & inlen , base ) ; if ( err ) mlx5_ib_dbg ( dev , "err<S2SV_blank>%d\\n" , err ) ; } else { err = create_kernel_qp ( dev , init_attr , qp , & in , & inlen , base ) ; if ( err ) mlx5_ib_dbg ( dev , "err<S2SV_blank>%d\\n" , err ) ; } if ( err ) return err ; } else { in = kvzalloc ( inlen , GFP_KERNEL ) ; if ( ! in ) return - ENOMEM ; qp -> create_type = MLX5_QP_EMPTY ; } if ( is_sqp ( init_attr -> qp_type ) ) qp -> port = init_attr -> port_num ; qpc = MLX5_ADDR_OF ( create_qp_in , in , qpc ) ; MLX5_SET ( qpc , qpc , st , mlx5_st ) ; MLX5_SET ( qpc , qpc , pm_state , MLX5_QP_PM_MIGRATED ) ; if ( init_attr -> qp_type != MLX5_IB_QPT_REG_UMR ) MLX5_SET ( qpc , qpc , pd , to_mpd ( pd ? pd : devr -> p0 ) -> pdn ) ; else MLX5_SET ( qpc , qpc , latency_sensitive , 1 ) ; if ( qp -> wq_sig ) MLX5_SET ( qpc , qpc , wq_signature , 1 ) ; if ( qp -> flags & MLX5_IB_QP_BLOCK_MULTICAST_LOOPBACK ) MLX5_SET ( qpc , qpc , block_lb_mc , 1 ) ; if ( qp -> flags & MLX5_IB_QP_CROSS_CHANNEL ) MLX5_SET ( qpc , qpc , cd_master , 1 ) ; if ( qp -> flags & MLX5_IB_QP_MANAGED_SEND ) MLX5_SET ( qpc , qpc , cd_slave_send , 1 ) ; if ( qp -> flags & MLX5_IB_QP_MANAGED_RECV ) MLX5_SET ( qpc , qpc , cd_slave_receive , 1 ) ; if ( qp -> scat_cqe && is_connected ( init_attr -> qp_type ) ) { int rcqe_sz ; int scqe_sz ; rcqe_sz = mlx5_ib_get_cqe_size ( dev , init_attr -> recv_cq ) ; scqe_sz = mlx5_ib_get_cqe_size ( dev , init_attr -> send_cq ) ; if ( rcqe_sz == 128 ) MLX5_SET ( qpc , qpc , cs_res , MLX5_RES_SCAT_DATA64_CQE ) ; else MLX5_SET ( qpc , qpc , cs_res , MLX5_RES_SCAT_DATA32_CQE ) ; if ( init_attr -> sq_sig_type == IB_SIGNAL_ALL_WR ) { if ( scqe_sz == 128 ) MLX5_SET ( qpc , qpc , cs_req , MLX5_REQ_SCAT_DATA64_CQE ) ; else MLX5_SET ( qpc , qpc , cs_req , MLX5_REQ_SCAT_DATA32_CQE ) ; } } if ( qp -> rq . wqe_cnt ) { MLX5_SET ( qpc , qpc , log_rq_stride , qp -> rq . wqe_shift - 4 ) ; MLX5_SET ( qpc , qpc , log_rq_size , ilog2 ( qp -> rq . wqe_cnt ) ) ; } MLX5_SET ( qpc , qpc , rq_type , get_rx_type ( qp , init_attr ) ) ; if ( qp -> sq . wqe_cnt ) { MLX5_SET ( qpc , qpc , log_sq_size , ilog2 ( qp -> sq . wqe_cnt ) ) ; } else { MLX5_SET ( qpc , qpc , no_sq , 1 ) ; if ( init_attr -> srq && init_attr -> srq -> srq_type == IB_SRQT_TM ) MLX5_SET ( qpc , qpc , offload_type , MLX5_QPC_OFFLOAD_TYPE_RNDV ) ; } switch ( init_attr -> qp_type ) { case IB_QPT_XRC_TGT : MLX5_SET ( qpc , qpc , cqn_rcv , to_mcq ( devr -> c0 ) -> mcq . cqn ) ; MLX5_SET ( qpc , qpc , cqn_snd , to_mcq ( devr -> c0 ) -> mcq . cqn ) ; MLX5_SET ( qpc , qpc , srqn_rmpn_xrqn , to_msrq ( devr -> s0 ) -> msrq . srqn ) ; MLX5_SET ( qpc , qpc , xrcd , to_mxrcd ( init_attr -> xrcd ) -> xrcdn ) ; break ; case IB_QPT_XRC_INI : MLX5_SET ( qpc , qpc , cqn_rcv , to_mcq ( devr -> c0 ) -> mcq . cqn ) ; MLX5_SET ( qpc , qpc , xrcd , to_mxrcd ( devr -> x1 ) -> xrcdn ) ; MLX5_SET ( qpc , qpc , srqn_rmpn_xrqn , to_msrq ( devr -> s0 ) -> msrq . srqn ) ; break ; default : if ( init_attr -> srq ) { MLX5_SET ( qpc , qpc , xrcd , to_mxrcd ( devr -> x0 ) -> xrcdn ) ; MLX5_SET ( qpc , qpc , srqn_rmpn_xrqn , to_msrq ( init_attr -> srq ) -> msrq . srqn ) ; } else { MLX5_SET ( qpc , qpc , xrcd , to_mxrcd ( devr -> x1 ) -> xrcdn ) ; MLX5_SET ( qpc , qpc , srqn_rmpn_xrqn , to_msrq ( devr -> s1 ) -> msrq . srqn ) ; } } if ( init_attr -> send_cq ) MLX5_SET ( qpc , qpc , cqn_snd , to_mcq ( init_attr -> send_cq ) -> mcq . cqn ) ; if ( init_attr -> recv_cq ) MLX5_SET ( qpc , qpc , cqn_rcv , to_mcq ( init_attr -> recv_cq ) -> mcq . cqn ) ; MLX5_SET64 ( qpc , qpc , dbr_addr , qp -> db . dma ) ; if ( MLX5_CAP_GEN ( mdev , cqe_version ) == MLX5_CQE_VERSION_V1 ) MLX5_SET ( qpc , qpc , user_index , uidx ) ; if ( init_attr -> qp_type == IB_QPT_UD && ( init_attr -> create_flags & IB_QP_CREATE_IPOIB_UD_LSO ) ) { MLX5_SET ( qpc , qpc , ulp_stateless_offload_mode , 1 ) ; qp -> flags |= MLX5_IB_QP_LSO ; } if ( init_attr -> create_flags & IB_QP_CREATE_PCI_WRITE_END_PADDING ) { if ( ! MLX5_CAP_GEN ( dev -> mdev , end_pad ) ) { mlx5_ib_dbg ( dev , "scatter<S2SV_blank>end<S2SV_blank>padding<S2SV_blank>is<S2SV_blank>not<S2SV_blank>supported\\n" ) ; err = - EOPNOTSUPP ; goto err ; } else if ( init_attr -> qp_type != IB_QPT_RAW_PACKET ) { MLX5_SET ( qpc , qpc , end_padding_mode , MLX5_WQ_END_PAD_MODE_ALIGN ) ; } else { qp -> flags |= MLX5_IB_QP_PCI_WRITE_END_PADDING ; } } if ( inlen < 0 ) { err = - EINVAL ; goto err ; } if ( init_attr -> qp_type == IB_QPT_RAW_PACKET || qp -> flags & MLX5_IB_QP_UNDERLAY ) { qp -> raw_packet_qp . sq . ubuffer . buf_addr = ucmd . sq_buf_addr ; raw_packet_qp_copy_info ( qp , & qp -> raw_packet_qp ) ; err = create_raw_packet_qp ( dev , qp , in , inlen , pd ) ; } else { err = mlx5_core_create_qp ( dev -> mdev , & base -> mqp , in , inlen ) ; } if ( err ) { mlx5_ib_dbg ( dev , "create<S2SV_blank>qp<S2SV_blank>failed\\n" ) ; goto err_create ; } kvfree ( in ) ; base -> container_mibqp = qp ; base -> mqp . event = mlx5_ib_qp_event ; get_cqs ( init_attr -> qp_type , init_attr -> send_cq , init_attr -> recv_cq , & send_cq , & recv_cq ) ; spin_lock_irqsave ( & dev -> reset_flow_resource_lock , flags ) ; mlx5_ib_lock_cqs ( send_cq , recv_cq ) ; list_add_tail ( & qp -> qps_list , & dev -> qp_list ) ; if ( send_cq ) list_add_tail ( & qp -> cq_send_list , & send_cq -> list_send_qp ) ; if ( recv_cq ) list_add_tail ( & qp -> cq_recv_list , & recv_cq -> list_recv_qp ) ; mlx5_ib_unlock_cqs ( send_cq , recv_cq ) ; spin_unlock_irqrestore ( & dev -> reset_flow_resource_lock , flags ) ; return 0 ; err_create : if ( qp -> create_type == MLX5_QP_USER ) destroy_qp_user ( dev , pd , qp , base ) ; else if ( qp -> create_type == MLX5_QP_KERNEL ) destroy_qp_kernel ( dev , qp ) ; err : kvfree ( in ) ; return err ; }
CWE-189 static ssize_t f_hidg_write ( struct file * file , const char __user * buffer , size_t count , loff_t * offp ) { struct f_hidg * hidg = file -> private_data ; struct usb_request * req ; unsigned long flags ; ssize_t status = - ENOMEM ; if ( ! access_ok ( buffer , count ) ) return - EFAULT ; spin_lock_irqsave ( & hidg -> write_spinlock , flags ) ; # define WRITE_COND ( ! hidg -> write_pending ) try_again : while ( ! WRITE_COND ) { spin_unlock_irqrestore ( & hidg -> write_spinlock , flags ) ; if ( file -> f_flags & O_NONBLOCK ) return - EAGAIN ; if ( wait_event_interruptible_exclusive ( hidg -> write_queue , WRITE_COND ) ) return - ERESTARTSYS ; spin_lock_irqsave ( & hidg -> write_spinlock , flags ) ; } hidg -> write_pending = 1 ; req = hidg -> req ; count = min_t ( unsigned , count , hidg -> report_length ) ; spin_unlock_irqrestore ( & hidg -> write_spinlock , flags ) ; status = copy_from_user ( req -> buf , buffer , count ) ; if ( status != 0 ) { ERROR ( hidg -> func . config -> cdev , "copy_from_user<S2SV_blank>error\\n" ) ; status = - EINVAL ; goto release_write_pending ; } spin_lock_irqsave ( & hidg -> write_spinlock , flags ) ; if ( ! hidg -> req ) { free_ep_req ( hidg -> in_ep , req ) ; goto try_again ; } req -> status = 0 ; req -> zero = 0 ; req -> length = count ; req -> complete = f_hidg_req_complete ; req -> context = hidg ; <S2SV_StartBug> status = usb_ep_queue ( hidg -> in_ep , req , GFP_ATOMIC ) ; <S2SV_EndBug> if ( status < 0 ) { ERROR ( hidg -> func . config -> cdev , "usb_ep_queue<S2SV_blank>error<S2SV_blank>on<S2SV_blank>int<S2SV_blank>endpoint<S2SV_blank>%zd\\n" , status ) ; <S2SV_StartBug> goto release_write_pending_unlocked ; <S2SV_EndBug> } else { status = count ; } <S2SV_StartBug> spin_unlock_irqrestore ( & hidg -> write_spinlock , flags ) ; <S2SV_EndBug> return status ; release_write_pending : spin_lock_irqsave ( & hidg -> write_spinlock , flags ) ; <S2SV_StartBug> release_write_pending_unlocked : <S2SV_EndBug> hidg -> write_pending = 0 ; spin_unlock_irqrestore ( & hidg -> write_spinlock , flags ) ; wake_up ( & hidg -> write_queue ) ; return status ; }
CWE-416 int SMB2_read ( const unsigned int xid , struct cifs_io_parms * io_parms , unsigned int * nbytes , char * * buf , int * buf_type ) { struct smb_rqst rqst ; int resp_buftype , rc = - EACCES ; struct smb2_read_plain_req * req = NULL ; struct smb2_read_rsp * rsp = NULL ; struct kvec iov [ 1 ] ; struct kvec rsp_iov ; unsigned int total_len ; int flags = CIFS_LOG_ERROR ; struct cifs_ses * ses = io_parms -> tcon -> ses ; * nbytes = 0 ; rc = smb2_new_read_req ( ( void * * ) & req , & total_len , io_parms , NULL , 0 , 0 ) ; if ( rc ) return rc ; if ( smb3_encryption_required ( io_parms -> tcon ) ) flags |= CIFS_TRANSFORM_REQ ; iov [ 0 ] . iov_base = ( char * ) req ; iov [ 0 ] . iov_len = total_len ; memset ( & rqst , 0 , sizeof ( struct smb_rqst ) ) ; rqst . rq_iov = iov ; rqst . rq_nvec = 1 ; rc = cifs_send_recv ( xid , ses , & rqst , & resp_buftype , flags , & rsp_iov ) ; <S2SV_StartBug> cifs_small_buf_release ( req ) ; <S2SV_EndBug> rsp = ( struct smb2_read_rsp * ) rsp_iov . iov_base ; if ( rc ) { if ( rc != - ENODATA ) { cifs_stats_fail_inc ( io_parms -> tcon , SMB2_READ_HE ) ; cifs_dbg ( VFS , "Send<S2SV_blank>error<S2SV_blank>in<S2SV_blank>read<S2SV_blank>=<S2SV_blank>%d\\n" , rc ) ; trace_smb3_read_err ( xid , req -> PersistentFileId , io_parms -> tcon -> tid , ses -> Suid , io_parms -> offset , io_parms -> length , rc ) ; } else trace_smb3_read_done ( xid , req -> PersistentFileId , io_parms -> tcon -> tid , ses -> Suid , io_parms -> offset , 0 ) ; free_rsp_buf ( resp_buftype , rsp_iov . iov_base ) ; return rc == - ENODATA ? 0 : rc ; } else trace_smb3_read_done ( xid , req -> PersistentFileId , io_parms -> tcon -> tid , ses -> Suid , io_parms -> offset , io_parms -> length ) ; <S2SV_StartBug> * nbytes = le32_to_cpu ( rsp -> DataLength ) ; <S2SV_EndBug> if ( ( * nbytes > CIFS_MAX_MSGSIZE ) || ( * nbytes > io_parms -> length ) ) { cifs_dbg ( FYI , "bad<S2SV_blank>length<S2SV_blank>%d<S2SV_blank>for<S2SV_blank>count<S2SV_blank>%d\\n" , * nbytes , io_parms -> length ) ; rc = - EIO ; * nbytes = 0 ; } if ( * buf ) { memcpy ( * buf , ( char * ) rsp + rsp -> DataOffset , * nbytes ) ; free_rsp_buf ( resp_buftype , rsp_iov . iov_base ) ; } else if ( resp_buftype != CIFS_NO_BUFFER ) { * buf = rsp_iov . iov_base ; if ( resp_buftype == CIFS_SMALL_BUFFER ) * buf_type = CIFS_SMALL_BUFFER ; else if ( resp_buftype == CIFS_LARGE_BUFFER ) * buf_type = CIFS_LARGE_BUFFER ; } return rc ; }
CWE-119 int mlx4_register_mac ( struct mlx4_dev * dev , u8 port , u64 mac , int * index ) { struct mlx4_mac_table * table = & mlx4_priv ( dev ) -> port [ port ] . mac_table ; int i , err = 0 ; int free = - 1 ; mlx4_dbg ( dev , "Registering<S2SV_blank>MAC:<S2SV_blank>0x%llx\\n" , ( unsigned long long ) mac ) ; mutex_lock ( & table -> mutex ) ; for ( i = 0 ; i < MLX4_MAX_MAC_NUM - 1 ; i ++ ) { if ( free < 0 && ! table -> refs [ i ] ) { free = i ; continue ; } if ( mac == ( MLX4_MAC_MASK & be64_to_cpu ( table -> entries [ i ] ) ) ) { * index = i ; ++ table -> refs [ i ] ; goto out ; } } <S2SV_StartBug> mlx4_dbg ( dev , "Free<S2SV_blank>MAC<S2SV_blank>index<S2SV_blank>is<S2SV_blank>%d\\n" , free ) ; <S2SV_EndBug> if ( table -> total == table -> max ) { err = - ENOSPC ; goto out ; } table -> refs [ free ] = 1 ; table -> entries [ free ] = cpu_to_be64 ( mac | MLX4_MAC_VALID ) ; err = mlx4_set_port_mac_table ( dev , port , table -> entries ) ; if ( unlikely ( err ) ) { mlx4_err ( dev , "Failed<S2SV_blank>adding<S2SV_blank>MAC:<S2SV_blank>0x%llx\\n" , ( unsigned long long ) mac ) ; table -> refs [ free ] = 0 ; table -> entries [ free ] = 0 ; goto out ; } * index = free ; ++ table -> total ; out : mutex_unlock ( & table -> mutex ) ; return err ; }
CWE-119 int mlx4_register_vlan ( struct mlx4_dev * dev , u8 port , u16 vlan , int * index ) { struct mlx4_vlan_table * table = & mlx4_priv ( dev ) -> port [ port ] . vlan_table ; int i , err = 0 ; int free = - 1 ; mutex_lock ( & table -> mutex ) ; for ( i = MLX4_VLAN_REGULAR ; i < MLX4_MAX_VLAN_NUM ; i ++ ) { if ( free < 0 && ( table -> refs [ i ] == 0 ) ) { free = i ; continue ; } if ( table -> refs [ i ] && ( vlan == ( MLX4_VLAN_MASK & be32_to_cpu ( table -> entries [ i ] ) ) ) ) { * index = i ; ++ table -> refs [ i ] ; goto out ; <S2SV_StartBug> } <S2SV_EndBug> } if ( table -> total == table -> max ) { err = - ENOSPC ; goto out ; } table -> refs [ free ] = 1 ; table -> entries [ free ] = cpu_to_be32 ( vlan | MLX4_VLAN_VALID ) ; err = mlx4_set_port_vlan_table ( dev , port , table -> entries ) ; if ( unlikely ( err ) ) { mlx4_warn ( dev , "Failed<S2SV_blank>adding<S2SV_blank>vlan:<S2SV_blank>%u\\n" , vlan ) ; table -> refs [ free ] = 0 ; table -> entries [ free ] = 0 ; goto out ; } * index = free ; ++ table -> total ; out : mutex_unlock ( & table -> mutex ) ; return err ; }
CWE-476 int expand_downwards ( struct vm_area_struct * vma , unsigned long address ) { struct mm_struct * mm = vma -> vm_mm ; struct vm_area_struct * prev ; <S2SV_StartBug> int error ; <S2SV_EndBug> address &= PAGE_MASK ; <S2SV_StartBug> error = security_mmap_addr ( address ) ; <S2SV_EndBug> if ( error ) return error ; prev = vma -> vm_prev ; if ( prev && ! ( prev -> vm_flags & VM_GROWSDOWN ) && ( prev -> vm_flags & ( VM_WRITE | VM_READ | VM_EXEC ) ) ) { if ( address - prev -> vm_end < stack_guard_gap ) return - ENOMEM ; } if ( unlikely ( anon_vma_prepare ( vma ) ) ) return - ENOMEM ; anon_vma_lock_write ( vma -> anon_vma ) ; if ( address < vma -> vm_start ) { unsigned long size , grow ; size = vma -> vm_end - address ; grow = ( vma -> vm_start - address ) >> PAGE_SHIFT ; error = - ENOMEM ; if ( grow <= vma -> vm_pgoff ) { error = acct_stack_growth ( vma , size , grow ) ; if ( ! error ) { spin_lock ( & mm -> page_table_lock ) ; if ( vma -> vm_flags & VM_LOCKED ) mm -> locked_vm += grow ; vm_stat_account ( mm , vma -> vm_flags , grow ) ; anon_vma_interval_tree_pre_update_vma ( vma ) ; vma -> vm_start = address ; vma -> vm_pgoff -= grow ; anon_vma_interval_tree_post_update_vma ( vma ) ; vma_gap_update ( vma ) ; spin_unlock ( & mm -> page_table_lock ) ; perf_event_mmap ( vma ) ; } } } anon_vma_unlock_write ( vma -> anon_vma ) ; khugepaged_enter_vma_merge ( vma , vma -> vm_flags ) ; validate_mm ( mm ) ; return error ; }
CWE-476 static int tun_set_iff ( struct net * net , struct file * file , struct ifreq * ifr ) { struct tun_struct * tun ; struct tun_file * tfile = file -> private_data ; struct net_device * dev ; int err ; if ( tfile -> detached ) return - EINVAL ; dev = __dev_get_by_name ( net , ifr -> ifr_name ) ; if ( dev ) { if ( ifr -> ifr_flags & IFF_TUN_EXCL ) return - EBUSY ; if ( ( ifr -> ifr_flags & IFF_TUN ) && dev -> netdev_ops == & tun_netdev_ops ) tun = netdev_priv ( dev ) ; else if ( ( ifr -> ifr_flags & IFF_TAP ) && dev -> netdev_ops == & tap_netdev_ops ) tun = netdev_priv ( dev ) ; else return - EINVAL ; if ( ! ! ( ifr -> ifr_flags & IFF_MULTI_QUEUE ) != ! ! ( tun -> flags & IFF_MULTI_QUEUE ) ) return - EINVAL ; if ( tun_not_capable ( tun ) ) return - EPERM ; err = security_tun_dev_open ( tun -> security ) ; if ( err < 0 ) return err ; err = tun_attach ( tun , file , ifr -> ifr_flags & IFF_NOFILTER ) ; if ( err < 0 ) return err ; if ( tun -> flags & IFF_MULTI_QUEUE && ( tun -> numqueues + tun -> numdisabled > 1 ) ) { return 0 ; } } else { char * name ; unsigned long flags = 0 ; int queues = ifr -> ifr_flags & IFF_MULTI_QUEUE ? MAX_TAP_QUEUES : 1 ; if ( ! ns_capable ( net -> user_ns , CAP_NET_ADMIN ) ) return - EPERM ; err = security_tun_dev_create ( ) ; if ( err < 0 ) return err ; if ( ifr -> ifr_flags & IFF_TUN ) { flags |= IFF_TUN ; name = "tun%d" ; } else if ( ifr -> ifr_flags & IFF_TAP ) { flags |= IFF_TAP ; name = "tap%d" ; } else return - EINVAL ; if ( * ifr -> ifr_name ) name = ifr -> ifr_name ; dev = alloc_netdev_mqs ( sizeof ( struct tun_struct ) , name , NET_NAME_UNKNOWN , tun_setup , queues , queues ) ; if ( ! dev ) return - ENOMEM ; <S2SV_StartBug> dev_net_set ( dev , net ) ; <S2SV_EndBug> dev -> rtnl_link_ops = & tun_link_ops ; dev -> ifindex = tfile -> ifindex ; dev -> sysfs_groups [ 0 ] = & tun_attr_group ; tun = netdev_priv ( dev ) ; tun -> dev = dev ; tun -> flags = flags ; tun -> txflt . count = 0 ; tun -> vnet_hdr_sz = sizeof ( struct virtio_net_hdr ) ; tun -> align = NET_SKB_PAD ; tun -> filter_attached = false ; tun -> sndbuf = tfile -> socket . sk -> sk_sndbuf ; tun -> rx_batched = 0 ; tun -> pcpu_stats = netdev_alloc_pcpu_stats ( struct tun_pcpu_stats ) ; if ( ! tun -> pcpu_stats ) { err = - ENOMEM ; goto err_free_dev ; } spin_lock_init ( & tun -> lock ) ; err = security_tun_dev_alloc_security ( & tun -> security ) ; if ( err < 0 ) goto err_free_stat ; tun_net_init ( dev ) ; tun_flow_init ( tun ) ; dev -> hw_features = NETIF_F_SG | NETIF_F_FRAGLIST | TUN_USER_FEATURES | NETIF_F_HW_VLAN_CTAG_TX | NETIF_F_HW_VLAN_STAG_TX ; dev -> features = dev -> hw_features | NETIF_F_LLTX ; dev -> vlan_features = dev -> features & ~ ( NETIF_F_HW_VLAN_CTAG_TX | NETIF_F_HW_VLAN_STAG_TX ) ; INIT_LIST_HEAD ( & tun -> disabled ) ; err = tun_attach ( tun , file , false ) ; if ( err < 0 ) goto err_free_flow ; err = register_netdevice ( tun -> dev ) ; if ( err < 0 ) goto err_detach ; } netif_carrier_on ( tun -> dev ) ; tun_debug ( KERN_INFO , tun , "tun_set_iff\\n" ) ; tun -> flags = ( tun -> flags & ~ TUN_FEATURES ) | ( ifr -> ifr_flags & TUN_FEATURES ) ; if ( netif_running ( tun -> dev ) ) netif_tx_wake_all_queues ( tun -> dev ) ; strcpy ( ifr -> ifr_name , tun -> dev -> name ) ; return 0 ; err_detach : tun_detach_all ( dev ) ; goto err_free_dev ; err_free_flow : tun_flow_uninit ( tun ) ; security_tun_dev_free_security ( tun -> security ) ; err_free_stat : free_percpu ( tun -> pcpu_stats ) ; err_free_dev : free_netdev ( dev ) ; return err ; }
CWE-476 <S2SV_StartBug> static int dev_get_valid_name ( struct net * net , <S2SV_EndBug> struct net_device * dev , const char * name ) { BUG_ON ( ! net ) ; if ( ! dev_valid_name ( name ) ) return - EINVAL ; if ( strchr ( name , '%' ) ) return dev_alloc_name_ns ( net , dev , name ) ; else if ( __dev_get_by_name ( net , name ) ) return - EEXIST ; else if ( dev -> name != name ) strlcpy ( dev -> name , name , IFNAMSIZ ) ; return 0 ; }
CWE-119 static struct nvmet_fc_tgt_queue * nvmet_fc_find_target_queue ( struct nvmet_fc_tgtport * tgtport , u64 connection_id ) { struct nvmet_fc_tgt_assoc * assoc ; struct nvmet_fc_tgt_queue * queue ; u64 association_id = nvmet_fc_getassociationid ( connection_id ) ; u16 qid = nvmet_fc_getqueueid ( connection_id ) ; <S2SV_StartBug> unsigned long flags ; <S2SV_EndBug> spin_lock_irqsave ( & tgtport -> lock , flags ) ; list_for_each_entry ( assoc , & tgtport -> assoc_list , a_list ) { if ( association_id == assoc -> association_id ) { queue = assoc -> queues [ qid ] ; if ( queue && ( ! atomic_read ( & queue -> connected ) || ! nvmet_fc_tgt_q_get ( queue ) ) ) queue = NULL ; spin_unlock_irqrestore ( & tgtport -> lock , flags ) ; return queue ; } } spin_unlock_irqrestore ( & tgtport -> lock , flags ) ; return NULL ; }
CWE-119 struct se_portal_group * tcm_loop_make_naa_tpg ( struct se_wwn * wwn , struct config_group * group , const char * name ) { struct tcm_loop_hba * tl_hba = container_of ( wwn , struct tcm_loop_hba , tl_hba_wwn ) ; struct tcm_loop_tpg * tl_tpg ; char * tpgt_str , * end_ptr ; int ret ; unsigned short int tpgt ; tpgt_str = strstr ( name , "tpgt_" ) ; if ( ! tpgt_str ) { printk ( KERN_ERR "Unable<S2SV_blank>to<S2SV_blank>locate<S2SV_blank>\\"tpgt_#\\"<S2SV_blank>directory" "<S2SV_blank>group\\n" ) ; return ERR_PTR ( - EINVAL ) ; } tpgt_str += 5 ; tpgt = ( unsigned short int ) simple_strtoul ( tpgt_str , & end_ptr , 0 ) ; <S2SV_StartBug> if ( tpgt > TL_TPGS_PER_HBA ) { <S2SV_EndBug> printk ( KERN_ERR "Passed<S2SV_blank>tpgt:<S2SV_blank>%hu<S2SV_blank>exceeds<S2SV_blank>TL_TPGS_PER_HBA:" "<S2SV_blank>%u\\n" , tpgt , TL_TPGS_PER_HBA ) ; return ERR_PTR ( - EINVAL ) ; } tl_tpg = & tl_hba -> tl_hba_tpgs [ tpgt ] ; tl_tpg -> tl_hba = tl_hba ; tl_tpg -> tl_tpgt = tpgt ; ret = core_tpg_register ( & tcm_loop_fabric_configfs -> tf_ops , wwn , & tl_tpg -> tl_se_tpg , tl_tpg , TRANSPORT_TPG_TYPE_NORMAL ) ; if ( ret < 0 ) return ERR_PTR ( - ENOMEM ) ; printk ( KERN_INFO "TCM_Loop_ConfigFS:<S2SV_blank>Allocated<S2SV_blank>Emulated<S2SV_blank>%s" "<S2SV_blank>Target<S2SV_blank>Port<S2SV_blank>%s,t,0x%04x\\n" , tcm_loop_dump_proto_id ( tl_hba ) , config_item_name ( & wwn -> wwn_group . cg_item ) , tpgt ) ; return & tl_tpg -> tl_se_tpg ; }
CWE-416 <S2SV_StartBug> void generic_pipe_buf_get ( struct pipe_inode_info * pipe , struct pipe_buffer * buf ) <S2SV_EndBug> { <S2SV_StartBug> get_page ( buf -> page ) ; <S2SV_EndBug> }
CWE-416 static int link_pipe ( struct pipe_inode_info * ipipe , struct pipe_inode_info * opipe , size_t len , unsigned int flags ) { struct pipe_buffer * ibuf , * obuf ; int ret = 0 , i = 0 , nbuf ; pipe_double_lock ( ipipe , opipe ) ; do { if ( ! opipe -> readers ) { send_sig ( SIGPIPE , current , 0 ) ; if ( ! ret ) ret = - EPIPE ; break ; } if ( i >= ipipe -> nrbufs || opipe -> nrbufs >= opipe -> buffers ) break ; ibuf = ipipe -> bufs + ( ( ipipe -> curbuf + i ) & ( ipipe -> buffers - 1 ) ) ; nbuf = ( opipe -> curbuf + opipe -> nrbufs ) & ( opipe -> buffers - 1 ) ; <S2SV_StartBug> pipe_buf_get ( ipipe , ibuf ) ; <S2SV_EndBug> obuf = opipe -> bufs + nbuf ; * obuf = * ibuf ; obuf -> flags &= ~ PIPE_BUF_FLAG_GIFT ; if ( obuf -> len > len ) obuf -> len = len ; opipe -> nrbufs ++ ; ret += obuf -> len ; len -= obuf -> len ; i ++ ; } while ( len ) ; if ( ! ret && ipipe -> waiting_writers && ( flags & SPLICE_F_NONBLOCK ) ) ret = - EAGAIN ; pipe_unlock ( ipipe ) ; pipe_unlock ( opipe ) ; if ( ret > 0 ) wakeup_pipe_readers ( opipe ) ; return ret ; }
CWE-416 static int splice_pipe_to_pipe ( struct pipe_inode_info * ipipe , struct pipe_inode_info * opipe , size_t len , unsigned int flags ) { struct pipe_buffer * ibuf , * obuf ; int ret = 0 , nbuf ; bool input_wakeup = false ; retry : ret = ipipe_prep ( ipipe , flags ) ; if ( ret ) return ret ; ret = opipe_prep ( opipe , flags ) ; if ( ret ) return ret ; pipe_double_lock ( ipipe , opipe ) ; do { if ( ! opipe -> readers ) { send_sig ( SIGPIPE , current , 0 ) ; if ( ! ret ) ret = - EPIPE ; break ; } if ( ! ipipe -> nrbufs && ! ipipe -> writers ) break ; if ( ! ipipe -> nrbufs || opipe -> nrbufs >= opipe -> buffers ) { if ( ret ) break ; if ( flags & SPLICE_F_NONBLOCK ) { ret = - EAGAIN ; break ; } pipe_unlock ( ipipe ) ; pipe_unlock ( opipe ) ; goto retry ; } ibuf = ipipe -> bufs + ipipe -> curbuf ; nbuf = ( opipe -> curbuf + opipe -> nrbufs ) & ( opipe -> buffers - 1 ) ; obuf = opipe -> bufs + nbuf ; if ( len >= ibuf -> len ) { * obuf = * ibuf ; ibuf -> ops = NULL ; opipe -> nrbufs ++ ; ipipe -> curbuf = ( ipipe -> curbuf + 1 ) & ( ipipe -> buffers - 1 ) ; ipipe -> nrbufs -- ; input_wakeup = true ; } else { <S2SV_StartBug> pipe_buf_get ( ipipe , ibuf ) ; <S2SV_EndBug> * obuf = * ibuf ; obuf -> flags &= ~ PIPE_BUF_FLAG_GIFT ; obuf -> len = len ; opipe -> nrbufs ++ ; ibuf -> offset += obuf -> len ; ibuf -> len -= obuf -> len ; } ret += obuf -> len ; len -= obuf -> len ; } while ( len ) ; pipe_unlock ( ipipe ) ; pipe_unlock ( opipe ) ; if ( ret > 0 ) wakeup_pipe_readers ( opipe ) ; if ( input_wakeup ) wakeup_pipe_writers ( ipipe ) ; return ret ; }
CWE-416 <S2SV_StartBug> static void buffer_pipe_buf_get ( struct pipe_inode_info * pipe , <S2SV_EndBug> struct pipe_buffer * buf ) { struct buffer_ref * ref = ( struct buffer_ref * ) buf -> private ; <S2SV_StartBug> ref -> ref ++ ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>
CWE-119 static int cqspi_setup_flash ( struct cqspi_st * cqspi , struct device_node * np ) { struct platform_device * pdev = cqspi -> pdev ; struct device * dev = & pdev -> dev ; struct cqspi_flash_pdata * f_pdata ; struct spi_nor * nor ; struct mtd_info * mtd ; unsigned int cs ; int i , ret ; for_each_available_child_of_node ( dev -> of_node , np ) { if ( of_property_read_u32 ( np , "reg" , & cs ) ) { dev_err ( dev , "Couldn\'t<S2SV_blank>determine<S2SV_blank>chip<S2SV_blank>select.\\n" ) ; goto err ; } <S2SV_StartBug> if ( cs > CQSPI_MAX_CHIPSELECT ) { <S2SV_EndBug> dev_err ( dev , "Chip<S2SV_blank>select<S2SV_blank>%d<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range.\\n" , cs ) ; goto err ; } f_pdata = & cqspi -> f_pdata [ cs ] ; f_pdata -> cqspi = cqspi ; f_pdata -> cs = cs ; ret = cqspi_of_get_flash_pdata ( pdev , f_pdata , np ) ; if ( ret ) goto err ; nor = & f_pdata -> nor ; mtd = & nor -> mtd ; mtd -> priv = nor ; nor -> dev = dev ; spi_nor_set_flash_node ( nor , np ) ; nor -> priv = f_pdata ; nor -> read_reg = cqspi_read_reg ; nor -> write_reg = cqspi_write_reg ; nor -> read = cqspi_read ; nor -> write = cqspi_write ; nor -> erase = cqspi_erase ; nor -> prepare = cqspi_prep ; nor -> unprepare = cqspi_unprep ; mtd -> name = devm_kasprintf ( dev , GFP_KERNEL , "%s.%d" , dev_name ( dev ) , cs ) ; if ( ! mtd -> name ) { ret = - ENOMEM ; goto err ; } ret = spi_nor_scan ( nor , NULL , SPI_NOR_QUAD ) ; if ( ret ) goto err ; ret = mtd_device_register ( mtd , NULL , 0 ) ; if ( ret ) goto err ; f_pdata -> registered = true ; } return 0 ; err : for ( i = 0 ; i < CQSPI_MAX_CHIPSELECT ; i ++ ) if ( cqspi -> f_pdata [ i ] . registered ) mtd_device_unregister ( & cqspi -> f_pdata [ i ] . nor . mtd ) ; return ret ; }
CWE-119 static int cx24116_send_diseqc_msg ( struct dvb_frontend * fe , struct dvb_diseqc_master_cmd * d ) { struct cx24116_state * state = fe -> demodulator_priv ; int i , ret ; <S2SV_StartBug> if ( debug ) { <S2SV_EndBug> printk ( KERN_INFO "cx24116:<S2SV_blank>%s(" , __func__ ) ; for ( i = 0 ; i < d -> msg_len ; ) { printk ( KERN_INFO "0x%02x" , d -> msg [ i ] ) ; if ( ++ i < d -> msg_len ) printk ( KERN_INFO ",<S2SV_blank>" ) ; } printk ( ")<S2SV_blank>toneburst=%d\\n" , toneburst ) ; } <S2SV_StartBug> if ( d -> msg_len > ( CX24116_ARGLEN - CX24116_DISEQC_MSGOFS ) ) <S2SV_EndBug> return - EINVAL ; for ( i = 0 ; i < d -> msg_len ; i ++ ) state -> dsec_cmd . args [ CX24116_DISEQC_MSGOFS + i ] = d -> msg [ i ] ; state -> dsec_cmd . args [ CX24116_DISEQC_MSGLEN ] = d -> msg_len ; state -> dsec_cmd . len = CX24116_DISEQC_MSGOFS + state -> dsec_cmd . args [ CX24116_DISEQC_MSGLEN ] ; if ( toneburst == CX24116_DISEQC_MESGCACHE ) return 0 ; else if ( toneburst == CX24116_DISEQC_TONEOFF ) state -> dsec_cmd . args [ CX24116_DISEQC_BURST ] = 0 ; else if ( toneburst == CX24116_DISEQC_TONECACHE ) { if ( d -> msg_len >= 4 && d -> msg [ 2 ] == 0x38 ) state -> dsec_cmd . args [ CX24116_DISEQC_BURST ] = ( ( d -> msg [ 3 ] & 4 ) >> 2 ) ; if ( debug ) dprintk ( "%s<S2SV_blank>burst=%d\\n" , __func__ , state -> dsec_cmd . args [ CX24116_DISEQC_BURST ] ) ; } ret = cx24116_wait_for_lnb ( fe ) ; if ( ret != 0 ) return ret ; msleep ( 100 ) ; ret = cx24116_cmd_execute ( fe , & state -> dsec_cmd ) ; if ( ret != 0 ) return ret ; msleep ( ( state -> dsec_cmd . args [ CX24116_DISEQC_MSGLEN ] << 4 ) + ( ( toneburst == CX24116_DISEQC_TONEOFF ) ? 30 : 60 ) ) ; return 0 ; }
CWE-399 int xfs_setattr_nonsize ( struct xfs_inode * ip , struct iattr * iattr , int flags ) { xfs_mount_t * mp = ip -> i_mount ; struct inode * inode = VFS_I ( ip ) ; int mask = iattr -> ia_valid ; xfs_trans_t * tp ; int error ; kuid_t uid = GLOBAL_ROOT_UID , iuid = GLOBAL_ROOT_UID ; kgid_t gid = GLOBAL_ROOT_GID , igid = GLOBAL_ROOT_GID ; struct xfs_dquot * udqp = NULL , * gdqp = NULL ; struct xfs_dquot * olddquot1 = NULL , * olddquot2 = NULL ; ASSERT ( ( mask & ATTR_SIZE ) == 0 ) ; if ( XFS_IS_QUOTA_ON ( mp ) && ( mask & ( ATTR_UID | ATTR_GID ) ) ) { uint qflags = 0 ; if ( ( mask & ATTR_UID ) && XFS_IS_UQUOTA_ON ( mp ) ) { uid = iattr -> ia_uid ; qflags |= XFS_QMOPT_UQUOTA ; } else { uid = inode -> i_uid ; } if ( ( mask & ATTR_GID ) && XFS_IS_GQUOTA_ON ( mp ) ) { gid = iattr -> ia_gid ; qflags |= XFS_QMOPT_GQUOTA ; } else { gid = inode -> i_gid ; } ASSERT ( udqp == NULL ) ; ASSERT ( gdqp == NULL ) ; error = xfs_qm_vop_dqalloc ( ip , xfs_kuid_to_uid ( uid ) , xfs_kgid_to_gid ( gid ) , xfs_get_projid ( ip ) , qflags , & udqp , & gdqp , NULL ) ; if ( error ) return error ; } error = xfs_trans_alloc ( mp , & M_RES ( mp ) -> tr_ichange , 0 , 0 , 0 , & tp ) ; if ( error ) goto out_dqrele ; xfs_ilock ( ip , XFS_ILOCK_EXCL ) ; xfs_trans_ijoin ( tp , ip , 0 ) ; if ( mask & ( ATTR_UID | ATTR_GID ) ) { iuid = inode -> i_uid ; igid = inode -> i_gid ; gid = ( mask & ATTR_GID ) ? iattr -> ia_gid : igid ; uid = ( mask & ATTR_UID ) ? iattr -> ia_uid : iuid ; if ( XFS_IS_QUOTA_RUNNING ( mp ) && ( ( XFS_IS_UQUOTA_ON ( mp ) && ! uid_eq ( iuid , uid ) ) || ( XFS_IS_GQUOTA_ON ( mp ) && ! gid_eq ( igid , gid ) ) ) ) { ASSERT ( tp ) ; error = xfs_qm_vop_chown_reserve ( tp , ip , udqp , gdqp , NULL , capable ( CAP_FOWNER ) ? XFS_QMOPT_FORCE_RES : 0 ) ; if ( error ) goto out_cancel ; } } if ( mask & ( ATTR_UID | ATTR_GID ) ) { if ( ( inode -> i_mode & ( S_ISUID | S_ISGID ) ) && ! capable ( CAP_FSETID ) ) inode -> i_mode &= ~ ( S_ISUID | S_ISGID ) ; if ( ! uid_eq ( iuid , uid ) ) { if ( XFS_IS_QUOTA_RUNNING ( mp ) && XFS_IS_UQUOTA_ON ( mp ) ) { ASSERT ( mask & ATTR_UID ) ; ASSERT ( udqp ) ; olddquot1 = xfs_qm_vop_chown ( tp , ip , & ip -> i_udquot , udqp ) ; } ip -> i_d . di_uid = xfs_kuid_to_uid ( uid ) ; inode -> i_uid = uid ; } if ( ! gid_eq ( igid , gid ) ) { if ( XFS_IS_QUOTA_RUNNING ( mp ) && XFS_IS_GQUOTA_ON ( mp ) ) { ASSERT ( xfs_sb_version_has_pquotino ( & mp -> m_sb ) || ! XFS_IS_PQUOTA_ON ( mp ) ) ; ASSERT ( mask & ATTR_GID ) ; ASSERT ( gdqp ) ; olddquot2 = xfs_qm_vop_chown ( tp , ip , & ip -> i_gdquot , gdqp ) ; } ip -> i_d . di_gid = xfs_kgid_to_gid ( gid ) ; inode -> i_gid = gid ; } } if ( mask & ATTR_MODE ) xfs_setattr_mode ( ip , iattr ) ; if ( mask & ( ATTR_ATIME | ATTR_CTIME | ATTR_MTIME ) ) xfs_setattr_time ( ip , iattr ) ; xfs_trans_log_inode ( tp , ip , XFS_ILOG_CORE ) ; XFS_STATS_INC ( mp , xs_ig_attrchg ) ; if ( mp -> m_flags & XFS_MOUNT_WSYNC ) xfs_trans_set_sync ( tp ) ; error = xfs_trans_commit ( tp ) ; xfs_iunlock ( ip , XFS_ILOCK_EXCL ) ; xfs_qm_dqrele ( olddquot1 ) ; xfs_qm_dqrele ( olddquot2 ) ; xfs_qm_dqrele ( udqp ) ; xfs_qm_dqrele ( gdqp ) ; if ( error ) return error ; if ( ( mask & ATTR_MODE ) && ! ( flags & XFS_ATTR_NOACL ) ) { error = posix_acl_chmod ( inode , inode -> i_mode ) ; if ( error ) return error ; } return 0 ; out_cancel : xfs_trans_cancel ( tp ) ; <S2SV_StartBug> out_dqrele : <S2SV_EndBug> xfs_qm_dqrele ( udqp ) ; xfs_qm_dqrele ( gdqp ) ; return error ; }
CWE-119 static int netlbl_cipsov4_add_common ( struct genl_info * info , struct cipso_v4_doi * doi_def ) { struct nlattr * nla ; int nla_rem ; u32 iter = 0 ; doi_def -> doi = nla_get_u32 ( info -> attrs [ NLBL_CIPSOV4_A_DOI ] ) ; if ( nla_validate_nested ( info -> attrs [ NLBL_CIPSOV4_A_TAGLST ] , NLBL_CIPSOV4_A_MAX , netlbl_cipsov4_genl_policy ) != 0 ) return - EINVAL ; nla_for_each_nested ( nla , info -> attrs [ NLBL_CIPSOV4_A_TAGLST ] , nla_rem ) if ( nla -> nla_type == NLBL_CIPSOV4_A_TAG ) { <S2SV_StartBug> if ( iter > CIPSO_V4_TAG_MAXCNT ) <S2SV_EndBug> return - EINVAL ; doi_def -> tags [ iter ++ ] = nla_get_u8 ( nla ) ; } <S2SV_StartBug> if ( iter < CIPSO_V4_TAG_MAXCNT ) <S2SV_EndBug> <S2SV_StartBug> doi_def -> tags [ iter ] = CIPSO_V4_TAG_INVALID ; <S2SV_EndBug> return 0 ; }
CWE-119 static int iwl_process_add_sta_resp ( struct iwl_priv * priv , struct iwl_addsta_cmd * addsta , struct iwl_rx_packet * pkt ) { u8 sta_id = addsta -> sta . sta_id ; unsigned long flags ; int ret = - EIO ; if ( pkt -> hdr . flags & IWL_CMD_FAILED_MSK ) { IWL_ERR ( priv , "Bad<S2SV_blank>return<S2SV_blank>from<S2SV_blank>REPLY_ADD_STA<S2SV_blank>(0x%08X)\\n" , pkt -> hdr . flags ) ; return ret ; } IWL_DEBUG_INFO ( priv , "Processing<S2SV_blank>response<S2SV_blank>for<S2SV_blank>adding<S2SV_blank>station<S2SV_blank>%u\\n" , sta_id ) ; spin_lock_irqsave ( & priv -> shrd -> sta_lock , flags ) ; switch ( pkt -> u . add_sta . status ) { case ADD_STA_SUCCESS_MSK : IWL_DEBUG_INFO ( priv , "REPLY_ADD_STA<S2SV_blank>PASSED\\n" ) ; <S2SV_StartBug> iwl_sta_ucode_activate ( priv , sta_id ) ; <S2SV_EndBug> ret = 0 ; break ; case ADD_STA_NO_ROOM_IN_TABLE : IWL_ERR ( priv , "Adding<S2SV_blank>station<S2SV_blank>%d<S2SV_blank>failed,<S2SV_blank>no<S2SV_blank>room<S2SV_blank>in<S2SV_blank>table.\\n" , sta_id ) ; break ; case ADD_STA_NO_BLOCK_ACK_RESOURCE : IWL_ERR ( priv , "Adding<S2SV_blank>station<S2SV_blank>%d<S2SV_blank>failed,<S2SV_blank>no<S2SV_blank>block<S2SV_blank>ack<S2SV_blank>" "resource.\\n" , sta_id ) ; break ; case ADD_STA_MODIFY_NON_EXIST_STA : IWL_ERR ( priv , "Attempting<S2SV_blank>to<S2SV_blank>modify<S2SV_blank>non-existing<S2SV_blank>station<S2SV_blank>%d\\n" , sta_id ) ; break ; default : IWL_DEBUG_ASSOC ( priv , "Received<S2SV_blank>REPLY_ADD_STA:(0x%08X)\\n" , pkt -> u . add_sta . status ) ; break ; } IWL_DEBUG_INFO ( priv , "%s<S2SV_blank>station<S2SV_blank>id<S2SV_blank>%u<S2SV_blank>addr<S2SV_blank>%pM\\n" , priv -> stations [ sta_id ] . sta . mode == STA_CONTROL_MODIFY_MSK ? "Modified" : "Added" , sta_id , priv -> stations [ sta_id ] . sta . sta . addr ) ; IWL_DEBUG_INFO ( priv , "%s<S2SV_blank>station<S2SV_blank>according<S2SV_blank>to<S2SV_blank>cmd<S2SV_blank>buffer<S2SV_blank>%pM\\n" , priv -> stations [ sta_id ] . sta . mode == STA_CONTROL_MODIFY_MSK ? "Modified" : "Added" , addsta -> sta . addr ) ; spin_unlock_irqrestore ( & priv -> shrd -> sta_lock , flags ) ; return ret ; }
CWE-119 <S2SV_StartBug> static void iwl_sta_ucode_activate ( struct iwl_priv * priv , u8 sta_id ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> if ( ! ( priv -> stations [ sta_id ] . used & IWL_STA_DRIVER_ACTIVE ) ) IWL_ERR ( priv , "ACTIVATE<S2SV_blank>a<S2SV_blank>non<S2SV_blank>DRIVER<S2SV_blank>active<S2SV_blank>station<S2SV_blank>id<S2SV_blank>%u<S2SV_blank>" "addr<S2SV_blank>%pM\\n" , sta_id , priv -> stations [ sta_id ] . sta . sta . addr ) ; if ( priv -> stations [ sta_id ] . used & IWL_STA_UCODE_ACTIVE ) { IWL_DEBUG_ASSOC ( priv , "STA<S2SV_blank>id<S2SV_blank>%u<S2SV_blank>addr<S2SV_blank>%pM<S2SV_blank>already<S2SV_blank>present<S2SV_blank>in<S2SV_blank>uCode<S2SV_blank>" "(according<S2SV_blank>to<S2SV_blank>driver)\\n" , sta_id , priv -> stations [ sta_id ] . sta . sta . addr ) ; } else { priv -> stations [ sta_id ] . used |= IWL_STA_UCODE_ACTIVE ; IWL_DEBUG_ASSOC ( priv , "Added<S2SV_blank>STA<S2SV_blank>id<S2SV_blank>%u<S2SV_blank>addr<S2SV_blank>%pM<S2SV_blank>to<S2SV_blank>uCode\\n" , sta_id , priv -> stations [ sta_id ] . sta . sta . addr ) ; } <S2SV_StartBug> } <S2SV_EndBug>
CWE-200 static __net_init int setup_net ( struct net * net , struct user_namespace * user_ns ) { const struct pernet_operations * ops , * saved_ops ; int error = 0 ; LIST_HEAD ( net_exit_list ) ; refcount_set ( & net -> count , 1 ) ; refcount_set ( & net -> passive , 1 ) ; <S2SV_StartBug> net -> dev_base_seq = 1 ; <S2SV_EndBug> net -> user_ns = user_ns ; idr_init ( & net -> netns_ids ) ; spin_lock_init ( & net -> nsid_lock ) ; mutex_init ( & net -> ipv4 . ra_mutex ) ; list_for_each_entry ( ops , & pernet_list , list ) { error = ops_init ( ops , net ) ; if ( error < 0 ) goto out_undo ; } down_write ( & net_rwsem ) ; list_add_tail_rcu ( & net -> list , & net_namespace_list ) ; up_write ( & net_rwsem ) ; out : return error ; out_undo : list_add ( & net -> exit_list , & net_exit_list ) ; saved_ops = ops ; list_for_each_entry_continue_reverse ( ops , & pernet_list , list ) ops_exit_list ( ops , & net_exit_list ) ; ops = saved_ops ; list_for_each_entry_continue_reverse ( ops , & pernet_list , list ) ops_free_list ( ops , & net_exit_list ) ; rcu_barrier ( ) ; goto out ; }
CWE-476 static int nfc_genl_deactivate_target ( struct sk_buff * skb , struct genl_info * info ) { struct nfc_dev * dev ; u32 device_idx , target_idx ; int rc ; <S2SV_StartBug> if ( ! info -> attrs [ NFC_ATTR_DEVICE_INDEX ] ) <S2SV_EndBug> return - EINVAL ; device_idx = nla_get_u32 ( info -> attrs [ NFC_ATTR_DEVICE_INDEX ] ) ; dev = nfc_get_device ( device_idx ) ; if ( ! dev ) return - ENODEV ; target_idx = nla_get_u32 ( info -> attrs [ NFC_ATTR_TARGET_INDEX ] ) ; rc = nfc_deactivate_target ( dev , target_idx , NFC_TARGET_MODE_SLEEP ) ; nfc_put_device ( dev ) ; return rc ; }
CWE-416 static int try_smi_init ( struct smi_info * new_smi ) { int rv = 0 ; int i ; char * init_name = NULL ; pr_info ( "Trying<S2SV_blank>%s-specified<S2SV_blank>%s<S2SV_blank>state<S2SV_blank>machine<S2SV_blank>at<S2SV_blank>%s<S2SV_blank>address<S2SV_blank>0x%lx,<S2SV_blank>slave<S2SV_blank>address<S2SV_blank>0x%x,<S2SV_blank>irq<S2SV_blank>%d\\n" , ipmi_addr_src_to_str ( new_smi -> io . addr_source ) , si_to_str [ new_smi -> io . si_type ] , addr_space_to_str [ new_smi -> io . addr_type ] , new_smi -> io . addr_data , new_smi -> io . slave_addr , new_smi -> io . irq ) ; switch ( new_smi -> io . si_type ) { case SI_KCS : new_smi -> handlers = & kcs_smi_handlers ; break ; case SI_SMIC : new_smi -> handlers = & smic_smi_handlers ; break ; case SI_BT : new_smi -> handlers = & bt_smi_handlers ; break ; default : rv = - EIO ; goto out_err ; } new_smi -> si_num = smi_num ; if ( ! new_smi -> io . dev ) { init_name = kasprintf ( GFP_KERNEL , "ipmi_si.%d" , new_smi -> si_num ) ; new_smi -> pdev = platform_device_alloc ( "ipmi_si" , new_smi -> si_num ) ; if ( ! new_smi -> pdev ) { pr_err ( "Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>platform<S2SV_blank>device\\n" ) ; rv = - ENOMEM ; goto out_err ; } new_smi -> io . dev = & new_smi -> pdev -> dev ; new_smi -> io . dev -> driver = & ipmi_platform_driver . driver ; new_smi -> io . dev -> init_name = init_name ; } new_smi -> si_sm = kmalloc ( new_smi -> handlers -> size ( ) , GFP_KERNEL ) ; if ( ! new_smi -> si_sm ) { rv = - ENOMEM ; goto out_err ; } new_smi -> io . io_size = new_smi -> handlers -> init_data ( new_smi -> si_sm , & new_smi -> io ) ; rv = new_smi -> io . io_setup ( & new_smi -> io ) ; if ( rv ) { dev_err ( new_smi -> io . dev , "Could<S2SV_blank>not<S2SV_blank>set<S2SV_blank>up<S2SV_blank>I/O<S2SV_blank>space\\n" ) ; goto out_err ; } if ( new_smi -> handlers -> detect ( new_smi -> si_sm ) ) { if ( new_smi -> io . addr_source ) dev_err ( new_smi -> io . dev , "Interface<S2SV_blank>detection<S2SV_blank>failed\\n" ) ; rv = - ENODEV ; goto out_err ; } rv = try_get_dev_id ( new_smi ) ; if ( rv ) { if ( new_smi -> io . addr_source ) dev_err ( new_smi -> io . dev , "There<S2SV_blank>appears<S2SV_blank>to<S2SV_blank>be<S2SV_blank>no<S2SV_blank>BMC<S2SV_blank>at<S2SV_blank>this<S2SV_blank>location\\n" ) ; goto out_err ; } setup_oem_data_handler ( new_smi ) ; setup_xaction_handlers ( new_smi ) ; check_for_broken_irqs ( new_smi ) ; new_smi -> waiting_msg = NULL ; new_smi -> curr_msg = NULL ; atomic_set ( & new_smi -> req_events , 0 ) ; new_smi -> run_to_completion = false ; for ( i = 0 ; i < SI_NUM_STATS ; i ++ ) atomic_set ( & new_smi -> stats [ i ] , 0 ) ; new_smi -> interrupt_disabled = true ; atomic_set ( & new_smi -> need_watch , 0 ) ; rv = try_enable_event_buffer ( new_smi ) ; if ( rv == 0 ) new_smi -> has_event_buffer = true ; start_clear_flags ( new_smi ) ; if ( new_smi -> io . irq ) { new_smi -> interrupt_disabled = false ; atomic_set ( & new_smi -> req_events , 1 ) ; } if ( new_smi -> pdev && ! new_smi -> pdev_registered ) { rv = platform_device_add ( new_smi -> pdev ) ; if ( rv ) { dev_err ( new_smi -> io . dev , "Unable<S2SV_blank>to<S2SV_blank>register<S2SV_blank>system<S2SV_blank>interface<S2SV_blank>device:<S2SV_blank>%d\\n" , rv ) ; goto out_err ; } new_smi -> pdev_registered = true ; } dev_set_drvdata ( new_smi -> io . dev , new_smi ) ; rv = device_add_group ( new_smi -> io . dev , & ipmi_si_dev_attr_group ) ; if ( rv ) { dev_err ( new_smi -> io . dev , "Unable<S2SV_blank>to<S2SV_blank>add<S2SV_blank>device<S2SV_blank>attributes:<S2SV_blank>error<S2SV_blank>%d\\n" , rv ) ; goto out_err ; } new_smi -> dev_group_added = true ; rv = ipmi_register_smi ( & handlers , new_smi , new_smi -> io . dev , new_smi -> io . slave_addr ) ; if ( rv ) { dev_err ( new_smi -> io . dev , "Unable<S2SV_blank>to<S2SV_blank>register<S2SV_blank>device:<S2SV_blank>error<S2SV_blank>%d\\n" , rv ) ; goto out_err ; } smi_num ++ ; dev_info ( new_smi -> io . dev , "IPMI<S2SV_blank>%s<S2SV_blank>interface<S2SV_blank>initialized\\n" , si_to_str [ new_smi -> io . si_type ] ) ; WARN_ON ( new_smi -> io . dev -> init_name != NULL ) ; out_err : <S2SV_StartBug> kfree ( init_name ) ; <S2SV_EndBug> return rv ; }
CWE-416 int ipmi_si_mem_setup ( struct si_sm_io * io ) { unsigned long addr = io -> addr_data ; int mapsize , idx ; if ( ! addr ) return - ENODEV ; <S2SV_StartBug> io -> io_cleanup = mem_cleanup ; <S2SV_EndBug> switch ( io -> regsize ) { case 1 : io -> inputb = intf_mem_inb ; io -> outputb = intf_mem_outb ; break ; case 2 : io -> inputb = intf_mem_inw ; io -> outputb = intf_mem_outw ; break ; case 4 : io -> inputb = intf_mem_inl ; io -> outputb = intf_mem_outl ; break ; # ifdef readq case 8 : io -> inputb = mem_inq ; io -> outputb = mem_outq ; break ; # endif default : dev_warn ( io -> dev , "Invalid<S2SV_blank>register<S2SV_blank>size:<S2SV_blank>%d\\n" , io -> regsize ) ; return - EINVAL ; } for ( idx = 0 ; idx < io -> io_size ; idx ++ ) { if ( request_mem_region ( addr + idx * io -> regspacing , io -> regsize , DEVICE_NAME ) == NULL ) { mem_region_cleanup ( io , idx ) ; return - EIO ; } } mapsize = ( ( io -> io_size * io -> regspacing ) - ( io -> regspacing - io -> regsize ) ) ; io -> addr = ioremap ( addr , mapsize ) ; if ( io -> addr == NULL ) { mem_region_cleanup ( io , io -> io_size ) ; return - EIO ; } <S2SV_StartBug> return 0 ; <S2SV_EndBug> }
CWE-416 int ipmi_si_port_setup ( struct si_sm_io * io ) { unsigned int addr = io -> addr_data ; int idx ; if ( ! addr ) return - ENODEV ; <S2SV_StartBug> io -> io_cleanup = port_cleanup ; <S2SV_EndBug> switch ( io -> regsize ) { case 1 : io -> inputb = port_inb ; io -> outputb = port_outb ; break ; case 2 : io -> inputb = port_inw ; io -> outputb = port_outw ; break ; case 4 : io -> inputb = port_inl ; io -> outputb = port_outl ; break ; default : dev_warn ( io -> dev , "Invalid<S2SV_blank>register<S2SV_blank>size:<S2SV_blank>%d\\n" , io -> regsize ) ; return - EINVAL ; } for ( idx = 0 ; idx < io -> io_size ; idx ++ ) { if ( request_region ( addr + idx * io -> regspacing , io -> regsize , DEVICE_NAME ) == NULL ) { while ( idx -- ) release_region ( addr + idx * io -> regspacing , io -> regsize ) ; return - EIO ; } } <S2SV_StartBug> return 0 ; <S2SV_EndBug> }
CWE-416 int blk_init_allocated_queue ( struct request_queue * q ) { WARN_ON_ONCE ( q -> mq_ops ) ; q -> fq = blk_alloc_flush_queue ( q , NUMA_NO_NODE , q -> cmd_size ) ; if ( ! q -> fq ) return - ENOMEM ; if ( q -> init_rq_fn && q -> init_rq_fn ( q , q -> fq -> flush_rq , GFP_KERNEL ) ) goto out_free_flush_queue ; if ( blk_init_rl ( & q -> root_rl , q , GFP_KERNEL ) ) goto out_exit_flush_rq ; INIT_WORK ( & q -> timeout_work , blk_timeout_work ) ; q -> queue_flags |= QUEUE_FLAG_DEFAULT ; blk_queue_make_request ( q , blk_queue_bio ) ; q -> sg_reserved_size = INT_MAX ; if ( elevator_init ( q ) ) goto out_exit_flush_rq ; return 0 ; out_exit_flush_rq : if ( q -> exit_rq_fn ) q -> exit_rq_fn ( q , q -> fq -> flush_rq ) ; out_free_flush_queue : blk_free_flush_queue ( q -> fq ) ; <S2SV_StartBug> return - ENOMEM ; <S2SV_EndBug> }
CWE-200 void __ip_select_ident ( struct iphdr * iph , int segs ) { static u32 ip_idents_hashrnd __read_mostly ; <S2SV_StartBug> u32 hash , id ; <S2SV_EndBug> <S2SV_StartBug> net_get_random_once ( & ip_idents_hashrnd , sizeof ( ip_idents_hashrnd ) ) ; <S2SV_EndBug> hash = jhash_3words ( ( __force u32 ) iph -> daddr , ( __force u32 ) iph -> saddr , <S2SV_StartBug> iph -> protocol , <S2SV_EndBug> ip_idents_hashrnd ) ; id = ip_idents_reserve ( hash , segs ) ; iph -> id = htons ( id ) ; }
CWE-200 static void ipv6_select_ident ( struct frag_hdr * fhdr , struct rt6_info * rt ) { static u32 ip6_idents_hashrnd __read_mostly ; <S2SV_StartBug> u32 hash , id ; <S2SV_EndBug> <S2SV_StartBug> net_get_random_once ( & ip6_idents_hashrnd , sizeof ( ip6_idents_hashrnd ) ) ; <S2SV_EndBug> hash = __ipv6_addr_jhash ( & rt -> rt6i_dst . addr , ip6_idents_hashrnd ) ; hash = __ipv6_addr_jhash ( & rt -> rt6i_src . addr , hash ) ; <S2SV_StartBug> id = ip_idents_reserve ( hash , 1 ) ; <S2SV_EndBug> fhdr -> identification = htonl ( id ) ; }
CWE-416 static int hci_uart_set_proto ( struct hci_uart * hu , int id ) { const struct hci_uart_proto * p ; int err ; p = hci_uart_get_proto ( id ) ; if ( ! p ) return - EPROTONOSUPPORT ; hu -> proto = p ; <S2SV_StartBug> set_bit ( HCI_UART_PROTO_READY , & hu -> flags ) ; <S2SV_EndBug> err = hci_uart_register_dev ( hu ) ; if ( err ) { <S2SV_StartBug> clear_bit ( HCI_UART_PROTO_READY , & hu -> flags ) ; <S2SV_EndBug> <S2SV_StartBug> return err ; <S2SV_EndBug> } return 0 ; }
CWE-200 static int mincore_pte_range ( pmd_t * pmd , unsigned long addr , unsigned long end , struct mm_walk * walk ) { spinlock_t * ptl ; struct vm_area_struct * vma = walk -> vma ; pte_t * ptep ; unsigned char * vec = walk -> private ; int nr = ( end - addr ) >> PAGE_SHIFT ; ptl = pmd_trans_huge_lock ( pmd , vma ) ; if ( ptl ) { memset ( vec , 1 , nr ) ; spin_unlock ( ptl ) ; goto out ; } if ( pmd_trans_unstable ( pmd ) ) { <S2SV_StartBug> __mincore_unmapped_range ( addr , end , vma , vec ) ; <S2SV_EndBug> goto out ; } ptep = pte_offset_map_lock ( walk -> mm , pmd , addr , & ptl ) ; for ( ; addr != end ; ptep ++ , addr += PAGE_SIZE ) { pte_t pte = * ptep ; if ( pte_none ( pte ) ) <S2SV_StartBug> __mincore_unmapped_range ( addr , addr + PAGE_SIZE , <S2SV_EndBug> vma , vec ) ; else if ( pte_present ( pte ) ) * vec = 1 ; else { swp_entry_t entry = pte_to_swp_entry ( pte ) ; <S2SV_StartBug> if ( non_swap_entry ( entry ) ) { <S2SV_EndBug> * vec = 1 ; } else { # ifdef CONFIG_SWAP * vec = mincore_page ( swap_address_space ( entry ) , swp_offset ( entry ) ) ; # else WARN_ON ( 1 ) ; * vec = 1 ; # endif } } vec ++ ; } pte_unmap_unlock ( ptep - 1 , ptl ) ; out : walk -> private += nr ; cond_resched ( ) ; return 0 ; }
CWE-200 static int mincore_unmapped_range ( unsigned long addr , unsigned long end , struct mm_walk * walk ) { <S2SV_StartBug> walk -> private += __mincore_unmapped_range ( addr , end , <S2SV_EndBug> walk -> vma , walk -> private ) ; return 0 ; }
CWE-476 int nfc_llcp_send_cc ( struct nfc_llcp_sock * sock ) { struct nfc_llcp_local * local ; struct sk_buff * skb ; u8 * miux_tlv = NULL , miux_tlv_length ; u8 * rw_tlv = NULL , rw_tlv_length , rw ; int err ; u16 size = 0 ; __be16 miux ; pr_debug ( "Sending<S2SV_blank>CC\\n" ) ; local = sock -> local ; if ( local == NULL ) return - ENODEV ; miux = be16_to_cpu ( sock -> miux ) > LLCP_MAX_MIUX ? local -> miux : sock -> miux ; rw = sock -> rw > LLCP_MAX_RW ? local -> rw : sock -> rw ; miux_tlv = nfc_llcp_build_tlv ( LLCP_TLV_MIUX , ( u8 * ) & miux , 0 , & miux_tlv_length ) ; <S2SV_StartBug> size += miux_tlv_length ; <S2SV_EndBug> rw_tlv = nfc_llcp_build_tlv ( LLCP_TLV_RW , & rw , 0 , & rw_tlv_length ) ; <S2SV_StartBug> size += rw_tlv_length ; <S2SV_EndBug> skb = llcp_allocate_pdu ( sock , LLCP_PDU_CC , size ) ; if ( skb == NULL ) { err = - ENOMEM ; goto error_tlv ; } llcp_add_tlv ( skb , miux_tlv , miux_tlv_length ) ; llcp_add_tlv ( skb , rw_tlv , rw_tlv_length ) ; skb_queue_tail ( & local -> tx_queue , skb ) ; err = 0 ; error_tlv : if ( err ) pr_err ( "error<S2SV_blank>%d\\n" , err ) ; kfree ( miux_tlv ) ; kfree ( rw_tlv ) ; return err ; }
CWE-476 int nfc_llcp_send_connect ( struct nfc_llcp_sock * sock ) { struct nfc_llcp_local * local ; struct sk_buff * skb ; u8 * service_name_tlv = NULL , service_name_tlv_length ; u8 * miux_tlv = NULL , miux_tlv_length ; u8 * rw_tlv = NULL , rw_tlv_length , rw ; int err ; u16 size = 0 ; __be16 miux ; pr_debug ( "Sending<S2SV_blank>CONNECT\\n" ) ; local = sock -> local ; if ( local == NULL ) return - ENODEV ; if ( sock -> service_name != NULL ) { service_name_tlv = nfc_llcp_build_tlv ( LLCP_TLV_SN , sock -> service_name , sock -> service_name_len , & service_name_tlv_length ) ; <S2SV_StartBug> size += service_name_tlv_length ; <S2SV_EndBug> } miux = be16_to_cpu ( sock -> miux ) > LLCP_MAX_MIUX ? local -> miux : sock -> miux ; rw = sock -> rw > LLCP_MAX_RW ? local -> rw : sock -> rw ; miux_tlv = nfc_llcp_build_tlv ( LLCP_TLV_MIUX , ( u8 * ) & miux , 0 , & miux_tlv_length ) ; <S2SV_StartBug> size += miux_tlv_length ; <S2SV_EndBug> rw_tlv = nfc_llcp_build_tlv ( LLCP_TLV_RW , & rw , 0 , & rw_tlv_length ) ; <S2SV_StartBug> size += rw_tlv_length ; <S2SV_EndBug> pr_debug ( "SKB<S2SV_blank>size<S2SV_blank>%d<S2SV_blank>SN<S2SV_blank>length<S2SV_blank>%zu\\n" , size , sock -> service_name_len ) ; skb = llcp_allocate_pdu ( sock , LLCP_PDU_CONNECT , size ) ; if ( skb == NULL ) { err = - ENOMEM ; goto error_tlv ; } llcp_add_tlv ( skb , service_name_tlv , service_name_tlv_length ) ; llcp_add_tlv ( skb , miux_tlv , miux_tlv_length ) ; llcp_add_tlv ( skb , rw_tlv , rw_tlv_length ) ; skb_queue_tail ( & local -> tx_queue , skb ) ; err = 0 ; error_tlv : if ( err ) pr_err ( "error<S2SV_blank>%d\\n" , err ) ; kfree ( service_name_tlv ) ; kfree ( miux_tlv ) ; kfree ( rw_tlv ) ; return err ; }
CWE-476 static int nfc_llcp_build_gb ( struct nfc_llcp_local * local ) { <S2SV_StartBug> u8 * gb_cur , * version_tlv , version , version_length ; <S2SV_EndBug> u8 * lto_tlv , lto_length ; u8 * wks_tlv , wks_length ; u8 * miux_tlv , miux_length ; __be16 wks = cpu_to_be16 ( local -> local_wks ) ; u8 gb_len = 0 ; int ret = 0 ; version = LLCP_VERSION_11 ; version_tlv = nfc_llcp_build_tlv ( LLCP_TLV_VERSION , & version , 1 , & version_length ) ; <S2SV_StartBug> gb_len += version_length ; <S2SV_EndBug> lto_tlv = nfc_llcp_build_tlv ( LLCP_TLV_LTO , & local -> lto , 1 , & lto_length ) ; <S2SV_StartBug> gb_len += lto_length ; <S2SV_EndBug> pr_debug ( "Local<S2SV_blank>wks<S2SV_blank>0x%lx\\n" , local -> local_wks ) ; wks_tlv = nfc_llcp_build_tlv ( LLCP_TLV_WKS , ( u8 * ) & wks , 2 , & wks_length ) ; <S2SV_StartBug> gb_len += wks_length ; <S2SV_EndBug> miux_tlv = nfc_llcp_build_tlv ( LLCP_TLV_MIUX , ( u8 * ) & local -> miux , 0 , <S2SV_StartBug> & miux_length ) ; <S2SV_EndBug> gb_len += miux_length ; gb_len += ARRAY_SIZE ( llcp_magic ) ; if ( gb_len > NFC_MAX_GT_LEN ) { ret = - EINVAL ; goto out ; } gb_cur = local -> gb ; memcpy ( gb_cur , llcp_magic , ARRAY_SIZE ( llcp_magic ) ) ; gb_cur += ARRAY_SIZE ( llcp_magic ) ; memcpy ( gb_cur , version_tlv , version_length ) ; gb_cur += version_length ; memcpy ( gb_cur , lto_tlv , lto_length ) ; gb_cur += lto_length ; memcpy ( gb_cur , wks_tlv , wks_length ) ; gb_cur += wks_length ; memcpy ( gb_cur , miux_tlv , miux_length ) ; gb_cur += miux_length ; local -> gb_len = gb_len ; out : kfree ( version_tlv ) ; kfree ( lto_tlv ) ; kfree ( wks_tlv ) ; kfree ( miux_tlv ) ; return ret ; }
CWE-200 static int ext4_ext_grow_indepth ( handle_t * handle , struct inode * inode , unsigned int flags ) { struct ext4_extent_header * neh ; struct buffer_head * bh ; ext4_fsblk_t newblock , goal = 0 ; struct ext4_super_block * es = EXT4_SB ( inode -> i_sb ) -> s_es ; int err = 0 ; <S2SV_StartBug> if ( ext_depth ( inode ) ) <S2SV_EndBug> goal = ext4_idx_pblock ( EXT_FIRST_INDEX ( ext_inode_hdr ( inode ) ) ) ; if ( goal > le32_to_cpu ( es -> s_first_data_block ) ) { flags |= EXT4_MB_HINT_TRY_GOAL ; goal -- ; } else goal = ext4_inode_to_goal_block ( inode ) ; newblock = ext4_new_meta_blocks ( handle , inode , goal , flags , NULL , & err ) ; if ( newblock == 0 ) return err ; bh = sb_getblk_gfp ( inode -> i_sb , newblock , __GFP_MOVABLE | GFP_NOFS ) ; if ( unlikely ( ! bh ) ) return - ENOMEM ; lock_buffer ( bh ) ; err = ext4_journal_get_create_access ( handle , bh ) ; if ( err ) { unlock_buffer ( bh ) ; goto out ; } <S2SV_StartBug> memmove ( bh -> b_data , EXT4_I ( inode ) -> i_data , <S2SV_EndBug> <S2SV_StartBug> sizeof ( EXT4_I ( inode ) -> i_data ) ) ; <S2SV_EndBug> neh = ext_block_hdr ( bh ) ; if ( ext_depth ( inode ) ) neh -> eh_max = cpu_to_le16 ( ext4_ext_space_block_idx ( inode , 0 ) ) ; else neh -> eh_max = cpu_to_le16 ( ext4_ext_space_block ( inode , 0 ) ) ; neh -> eh_magic = EXT4_EXT_MAGIC ; ext4_extent_block_csum_set ( inode , neh ) ; set_buffer_uptodate ( bh ) ; unlock_buffer ( bh ) ; err = ext4_handle_dirty_metadata ( handle , inode , bh ) ; if ( err ) goto out ; neh = ext_inode_hdr ( inode ) ; neh -> eh_entries = cpu_to_le16 ( 1 ) ; ext4_idx_store_pblock ( EXT_FIRST_INDEX ( neh ) , newblock ) ; if ( neh -> eh_depth == 0 ) { neh -> eh_max = cpu_to_le16 ( ext4_ext_space_root_idx ( inode , 0 ) ) ; EXT_FIRST_INDEX ( neh ) -> ei_block = EXT_FIRST_EXTENT ( neh ) -> ee_block ; } ext_debug ( "new<S2SV_blank>root:<S2SV_blank>num<S2SV_blank>%d(%d),<S2SV_blank>lblock<S2SV_blank>%d,<S2SV_blank>ptr<S2SV_blank>%llu\\n" , le16_to_cpu ( neh -> eh_entries ) , le16_to_cpu ( neh -> eh_max ) , le32_to_cpu ( EXT_FIRST_INDEX ( neh ) -> ei_block ) , ext4_idx_pblock ( EXT_FIRST_INDEX ( neh ) ) ) ; le16_add_cpu ( & neh -> eh_depth , 1 ) ; ext4_mark_inode_dirty ( handle , inode ) ; out : brelse ( bh ) ; return err ; }
CWE-200 static int ext4_ext_split ( handle_t * handle , struct inode * inode , unsigned int flags , struct ext4_ext_path * path , struct ext4_extent * newext , int at ) { struct buffer_head * bh = NULL ; int depth = ext_depth ( inode ) ; struct ext4_extent_header * neh ; struct ext4_extent_idx * fidx ; int i = at , k , m , a ; ext4_fsblk_t newblock , oldblock ; __le32 border ; ext4_fsblk_t * ablocks = NULL ; int err = 0 ; <S2SV_StartBug> if ( unlikely ( path [ depth ] . p_ext > EXT_MAX_EXTENT ( path [ depth ] . p_hdr ) ) ) { <S2SV_EndBug> EXT4_ERROR_INODE ( inode , "p_ext<S2SV_blank>><S2SV_blank>EXT_MAX_EXTENT!" ) ; return - EFSCORRUPTED ; } if ( path [ depth ] . p_ext != EXT_MAX_EXTENT ( path [ depth ] . p_hdr ) ) { border = path [ depth ] . p_ext [ 1 ] . ee_block ; ext_debug ( "leaf<S2SV_blank>will<S2SV_blank>be<S2SV_blank>split." "<S2SV_blank>next<S2SV_blank>leaf<S2SV_blank>starts<S2SV_blank>at<S2SV_blank>%d\\n" , le32_to_cpu ( border ) ) ; } else { border = newext -> ee_block ; ext_debug ( "leaf<S2SV_blank>will<S2SV_blank>be<S2SV_blank>added." "<S2SV_blank>next<S2SV_blank>leaf<S2SV_blank>starts<S2SV_blank>at<S2SV_blank>%d\\n" , le32_to_cpu ( border ) ) ; } ablocks = kcalloc ( depth , sizeof ( ext4_fsblk_t ) , GFP_NOFS ) ; if ( ! ablocks ) return - ENOMEM ; ext_debug ( "allocate<S2SV_blank>%d<S2SV_blank>blocks<S2SV_blank>for<S2SV_blank>indexes/leaf\\n" , depth - at ) ; for ( a = 0 ; a < depth - at ; a ++ ) { newblock = ext4_ext_new_meta_block ( handle , inode , path , newext , & err , flags ) ; if ( newblock == 0 ) goto cleanup ; ablocks [ a ] = newblock ; } newblock = ablocks [ -- a ] ; if ( unlikely ( newblock == 0 ) ) { EXT4_ERROR_INODE ( inode , "newblock<S2SV_blank>==<S2SV_blank>0!" ) ; err = - EFSCORRUPTED ; goto cleanup ; } bh = sb_getblk_gfp ( inode -> i_sb , newblock , __GFP_MOVABLE | GFP_NOFS ) ; if ( unlikely ( ! bh ) ) { err = - ENOMEM ; goto cleanup ; } lock_buffer ( bh ) ; err = ext4_journal_get_create_access ( handle , bh ) ; if ( err ) goto cleanup ; neh = ext_block_hdr ( bh ) ; neh -> eh_entries = 0 ; neh -> eh_max = cpu_to_le16 ( ext4_ext_space_block ( inode , 0 ) ) ; neh -> eh_magic = EXT4_EXT_MAGIC ; neh -> eh_depth = 0 ; if ( unlikely ( path [ depth ] . p_hdr -> eh_entries != path [ depth ] . p_hdr -> eh_max ) ) { EXT4_ERROR_INODE ( inode , "eh_entries<S2SV_blank>%d<S2SV_blank>!=<S2SV_blank>eh_max<S2SV_blank>%d!" , path [ depth ] . p_hdr -> eh_entries , path [ depth ] . p_hdr -> eh_max ) ; err = - EFSCORRUPTED ; goto cleanup ; } m = EXT_MAX_EXTENT ( path [ depth ] . p_hdr ) - path [ depth ] . p_ext ++ ; ext4_ext_show_move ( inode , path , newblock , depth ) ; if ( m ) { struct ext4_extent * ex ; ex = EXT_FIRST_EXTENT ( neh ) ; memmove ( ex , path [ depth ] . p_ext , sizeof ( struct ext4_extent ) * m ) ; le16_add_cpu ( & neh -> eh_entries , m ) ; } <S2SV_StartBug> ext4_extent_block_csum_set ( inode , neh ) ; <S2SV_EndBug> set_buffer_uptodate ( bh ) ; unlock_buffer ( bh ) ; err = ext4_handle_dirty_metadata ( handle , inode , bh ) ; if ( err ) goto cleanup ; brelse ( bh ) ; bh = NULL ; if ( m ) { err = ext4_ext_get_access ( handle , inode , path + depth ) ; if ( err ) goto cleanup ; le16_add_cpu ( & path [ depth ] . p_hdr -> eh_entries , - m ) ; err = ext4_ext_dirty ( handle , inode , path + depth ) ; if ( err ) goto cleanup ; } k = depth - at - 1 ; if ( unlikely ( k < 0 ) ) { EXT4_ERROR_INODE ( inode , "k<S2SV_blank>%d<S2SV_blank><<S2SV_blank>0!" , k ) ; err = - EFSCORRUPTED ; goto cleanup ; } if ( k ) ext_debug ( "create<S2SV_blank>%d<S2SV_blank>intermediate<S2SV_blank>indices\\n" , k ) ; i = depth - 1 ; while ( k -- ) { oldblock = newblock ; newblock = ablocks [ -- a ] ; bh = sb_getblk ( inode -> i_sb , newblock ) ; if ( unlikely ( ! bh ) ) { err = - ENOMEM ; goto cleanup ; } lock_buffer ( bh ) ; err = ext4_journal_get_create_access ( handle , bh ) ; if ( err ) goto cleanup ; neh = ext_block_hdr ( bh ) ; neh -> eh_entries = cpu_to_le16 ( 1 ) ; neh -> eh_magic = EXT4_EXT_MAGIC ; neh -> eh_max = cpu_to_le16 ( ext4_ext_space_block_idx ( inode , 0 ) ) ; neh -> eh_depth = cpu_to_le16 ( depth - i ) ; fidx = EXT_FIRST_INDEX ( neh ) ; fidx -> ei_block = border ; ext4_idx_store_pblock ( fidx , oldblock ) ; ext_debug ( "int.index<S2SV_blank>at<S2SV_blank>%d<S2SV_blank>(block<S2SV_blank>%llu):<S2SV_blank>%u<S2SV_blank>-><S2SV_blank>%llu\\n" , i , newblock , le32_to_cpu ( border ) , oldblock ) ; if ( unlikely ( EXT_MAX_INDEX ( path [ i ] . p_hdr ) != EXT_LAST_INDEX ( path [ i ] . p_hdr ) ) ) { EXT4_ERROR_INODE ( inode , "EXT_MAX_INDEX<S2SV_blank>!=<S2SV_blank>EXT_LAST_INDEX<S2SV_blank>ee_block<S2SV_blank>%d!" , le32_to_cpu ( path [ i ] . p_ext -> ee_block ) ) ; err = - EFSCORRUPTED ; goto cleanup ; } m = EXT_MAX_INDEX ( path [ i ] . p_hdr ) - path [ i ] . p_idx ++ ; ext_debug ( "cur<S2SV_blank>0x%p,<S2SV_blank>last<S2SV_blank>0x%p\\n" , path [ i ] . p_idx , EXT_MAX_INDEX ( path [ i ] . p_hdr ) ) ; ext4_ext_show_move ( inode , path , newblock , i ) ; if ( m ) { memmove ( ++ fidx , path [ i ] . p_idx , sizeof ( struct ext4_extent_idx ) * m ) ; le16_add_cpu ( & neh -> eh_entries , m ) ; } <S2SV_StartBug> ext4_extent_block_csum_set ( inode , neh ) ; <S2SV_EndBug> set_buffer_uptodate ( bh ) ; unlock_buffer ( bh ) ; err = ext4_handle_dirty_metadata ( handle , inode , bh ) ; if ( err ) goto cleanup ; brelse ( bh ) ; bh = NULL ; if ( m ) { err = ext4_ext_get_access ( handle , inode , path + i ) ; if ( err ) goto cleanup ; le16_add_cpu ( & path [ i ] . p_hdr -> eh_entries , - m ) ; err = ext4_ext_dirty ( handle , inode , path + i ) ; if ( err ) goto cleanup ; } i -- ; } err = ext4_ext_insert_index ( handle , inode , path + at , le32_to_cpu ( border ) , newblock ) ; cleanup : if ( bh ) { if ( buffer_locked ( bh ) ) unlock_buffer ( bh ) ; brelse ( bh ) ; } if ( err ) { for ( i = 0 ; i < depth ; i ++ ) { if ( ! ablocks [ i ] ) continue ; ext4_free_blocks ( handle , inode , NULL , ablocks [ i ] , 1 , EXT4_FREE_BLOCKS_METADATA ) ; } } kfree ( ablocks ) ; return err ; }
CWE-476 static int tun_set_iff ( struct net * net , struct file * file , struct ifreq * ifr ) { struct tun_struct * tun ; struct tun_file * tfile = file -> private_data ; struct net_device * dev ; int err ; if ( tfile -> detached ) return - EINVAL ; dev = __dev_get_by_name ( net , ifr -> ifr_name ) ; if ( dev ) { if ( ifr -> ifr_flags & IFF_TUN_EXCL ) return - EBUSY ; if ( ( ifr -> ifr_flags & IFF_TUN ) && dev -> netdev_ops == & tun_netdev_ops ) tun = netdev_priv ( dev ) ; else if ( ( ifr -> ifr_flags & IFF_TAP ) && dev -> netdev_ops == & tap_netdev_ops ) tun = netdev_priv ( dev ) ; else return - EINVAL ; if ( ! ! ( ifr -> ifr_flags & IFF_MULTI_QUEUE ) != ! ! ( tun -> flags & IFF_MULTI_QUEUE ) ) return - EINVAL ; if ( tun_not_capable ( tun ) ) return - EPERM ; err = security_tun_dev_open ( tun -> security ) ; if ( err < 0 ) return err ; err = tun_attach ( tun , file , ifr -> ifr_flags & IFF_NOFILTER ) ; if ( err < 0 ) return err ; if ( tun -> flags & IFF_MULTI_QUEUE && ( tun -> numqueues + tun -> numdisabled > 1 ) ) { return 0 ; } } else { char * name ; unsigned long flags = 0 ; int queues = ifr -> ifr_flags & IFF_MULTI_QUEUE ? MAX_TAP_QUEUES : 1 ; if ( ! ns_capable ( net -> user_ns , CAP_NET_ADMIN ) ) return - EPERM ; err = security_tun_dev_create ( ) ; if ( err < 0 ) return err ; if ( ifr -> ifr_flags & IFF_TUN ) { flags |= IFF_TUN ; name = "tun%d" ; } else if ( ifr -> ifr_flags & IFF_TAP ) { flags |= IFF_TAP ; name = "tap%d" ; } else return - EINVAL ; if ( * ifr -> ifr_name ) name = ifr -> ifr_name ; dev = alloc_netdev_mqs ( sizeof ( struct tun_struct ) , name , NET_NAME_UNKNOWN , tun_setup , queues , queues ) ; if ( ! dev ) return - ENOMEM ; err = dev_get_valid_name ( net , dev , name ) ; <S2SV_StartBug> if ( err ) <S2SV_EndBug> goto err_free_dev ; dev_net_set ( dev , net ) ; dev -> rtnl_link_ops = & tun_link_ops ; dev -> ifindex = tfile -> ifindex ; dev -> sysfs_groups [ 0 ] = & tun_attr_group ; tun = netdev_priv ( dev ) ; tun -> dev = dev ; tun -> flags = flags ; tun -> txflt . count = 0 ; tun -> vnet_hdr_sz = sizeof ( struct virtio_net_hdr ) ; tun -> align = NET_SKB_PAD ; tun -> filter_attached = false ; tun -> sndbuf = tfile -> socket . sk -> sk_sndbuf ; tun -> rx_batched = 0 ; tun -> pcpu_stats = netdev_alloc_pcpu_stats ( struct tun_pcpu_stats ) ; if ( ! tun -> pcpu_stats ) { err = - ENOMEM ; goto err_free_dev ; } spin_lock_init ( & tun -> lock ) ; err = security_tun_dev_alloc_security ( & tun -> security ) ; if ( err < 0 ) goto err_free_stat ; tun_net_init ( dev ) ; tun_flow_init ( tun ) ; dev -> hw_features = NETIF_F_SG | NETIF_F_FRAGLIST | TUN_USER_FEATURES | NETIF_F_HW_VLAN_CTAG_TX | NETIF_F_HW_VLAN_STAG_TX ; dev -> features = dev -> hw_features | NETIF_F_LLTX ; dev -> vlan_features = dev -> features & ~ ( NETIF_F_HW_VLAN_CTAG_TX | NETIF_F_HW_VLAN_STAG_TX ) ; INIT_LIST_HEAD ( & tun -> disabled ) ; err = tun_attach ( tun , file , false ) ; if ( err < 0 ) goto err_free_flow ; err = register_netdevice ( tun -> dev ) ; if ( err < 0 ) goto err_detach ; } netif_carrier_on ( tun -> dev ) ; tun_debug ( KERN_INFO , tun , "tun_set_iff\\n" ) ; tun -> flags = ( tun -> flags & ~ TUN_FEATURES ) | ( ifr -> ifr_flags & TUN_FEATURES ) ; if ( netif_running ( tun -> dev ) ) netif_tx_wake_all_queues ( tun -> dev ) ; strcpy ( ifr -> ifr_name , tun -> dev -> name ) ; return 0 ; err_detach : tun_detach_all ( dev ) ; goto err_free_dev ; err_free_flow : tun_flow_uninit ( tun ) ; security_tun_dev_free_security ( tun -> security ) ; err_free_stat : free_percpu ( tun -> pcpu_stats ) ; err_free_dev : free_netdev ( dev ) ; return err ; }
CWE-264 static void ptrace_link ( struct task_struct * child , struct task_struct * new_parent ) { <S2SV_StartBug> rcu_read_lock ( ) ; <S2SV_EndBug> <S2SV_StartBug> __ptrace_link ( child , new_parent , __task_cred ( new_parent ) ) ; <S2SV_EndBug> rcu_read_unlock ( ) ; }
CWE-416 int SMB2_write ( const unsigned int xid , struct cifs_io_parms * io_parms , unsigned int * nbytes , struct kvec * iov , int n_vec ) { struct smb_rqst rqst ; int rc = 0 ; struct smb2_write_req * req = NULL ; struct smb2_write_rsp * rsp = NULL ; int resp_buftype ; struct kvec rsp_iov ; int flags = 0 ; unsigned int total_len ; * nbytes = 0 ; if ( n_vec < 1 ) return rc ; rc = smb2_plain_req_init ( SMB2_WRITE , io_parms -> tcon , ( void * * ) & req , & total_len ) ; if ( rc ) return rc ; if ( io_parms -> tcon -> ses -> server == NULL ) return - ECONNABORTED ; if ( smb3_encryption_required ( io_parms -> tcon ) ) flags |= CIFS_TRANSFORM_REQ ; req -> sync_hdr . ProcessId = cpu_to_le32 ( io_parms -> pid ) ; req -> PersistentFileId = io_parms -> persistent_fid ; req -> VolatileFileId = io_parms -> volatile_fid ; req -> WriteChannelInfoOffset = 0 ; req -> WriteChannelInfoLength = 0 ; req -> Channel = 0 ; req -> Length = cpu_to_le32 ( io_parms -> length ) ; req -> Offset = cpu_to_le64 ( io_parms -> offset ) ; req -> DataOffset = cpu_to_le16 ( offsetof ( struct smb2_write_req , Buffer ) ) ; req -> RemainingBytes = 0 ; trace_smb3_write_enter ( xid , io_parms -> persistent_fid , io_parms -> tcon -> tid , io_parms -> tcon -> ses -> Suid , io_parms -> offset , io_parms -> length ) ; iov [ 0 ] . iov_base = ( char * ) req ; iov [ 0 ] . iov_len = total_len - 1 ; memset ( & rqst , 0 , sizeof ( struct smb_rqst ) ) ; rqst . rq_iov = iov ; rqst . rq_nvec = n_vec + 1 ; rc = cifs_send_recv ( xid , io_parms -> tcon -> ses , & rqst , & resp_buftype , flags , & rsp_iov ) ; <S2SV_StartBug> cifs_small_buf_release ( req ) ; <S2SV_EndBug> rsp = ( struct smb2_write_rsp * ) rsp_iov . iov_base ; if ( rc ) { trace_smb3_write_err ( xid , req -> PersistentFileId , io_parms -> tcon -> tid , io_parms -> tcon -> ses -> Suid , io_parms -> offset , io_parms -> length , rc ) ; cifs_stats_fail_inc ( io_parms -> tcon , SMB2_WRITE_HE ) ; cifs_dbg ( VFS , "Send<S2SV_blank>error<S2SV_blank>in<S2SV_blank>write<S2SV_blank>=<S2SV_blank>%d\\n" , rc ) ; } else { * nbytes = le32_to_cpu ( rsp -> DataLength ) ; trace_smb3_write_done ( xid , req -> PersistentFileId , io_parms -> tcon -> tid , io_parms -> tcon -> ses -> Suid , io_parms -> offset , * nbytes ) ; } <S2SV_StartBug> free_rsp_buf ( resp_buftype , rsp ) ; <S2SV_EndBug> return rc ; }
CWE-125 static int serdes_probe ( struct platform_device * pdev ) { struct phy_provider * provider ; struct serdes_ctrl * ctrl ; unsigned int i ; int ret ; ctrl = devm_kzalloc ( & pdev -> dev , sizeof ( * ctrl ) , GFP_KERNEL ) ; if ( ! ctrl ) return - ENOMEM ; ctrl -> dev = & pdev -> dev ; ctrl -> regs = syscon_node_to_regmap ( pdev -> dev . parent -> of_node ) ; if ( IS_ERR ( ctrl -> regs ) ) return PTR_ERR ( ctrl -> regs ) ; <S2SV_StartBug> for ( i = 0 ; i <= SERDES_MAX ; i ++ ) { <S2SV_EndBug> ret = serdes_phy_create ( ctrl , i , & ctrl -> phys [ i ] ) ; if ( ret ) return ret ; } dev_set_drvdata ( & pdev -> dev , ctrl ) ; provider = devm_of_phy_provider_register ( ctrl -> dev , serdes_simple_xlate ) ; return PTR_ERR_OR_ZERO ( provider ) ; }
CWE-125 static struct phy * serdes_simple_xlate ( struct device * dev , struct of_phandle_args * args ) { struct serdes_ctrl * ctrl = dev_get_drvdata ( dev ) ; unsigned int port , idx , i ; if ( args -> args_count != 2 ) return ERR_PTR ( - EINVAL ) ; port = args -> args [ 0 ] ; idx = args -> args [ 1 ] ; <S2SV_StartBug> for ( i = 0 ; i <= SERDES_MAX ; i ++ ) { <S2SV_EndBug> struct serdes_macro * macro = phy_get_drvdata ( ctrl -> phys [ i ] ) ; if ( idx != macro -> idx ) continue ; if ( idx != SERDES6G ( 0 ) && macro -> port >= 0 ) return ERR_PTR ( - EBUSY ) ; macro -> port = port ; return ctrl -> phys [ i ] ; } return ERR_PTR ( - ENODEV ) ; }
CWE-369 static void change_port_settings ( struct tty_struct * tty , struct edgeport_port * edge_port , struct ktermios * old_termios ) { struct device * dev = & edge_port -> port -> dev ; struct ump_uart_config * config ; int baud ; unsigned cflag ; int status ; int port_number = edge_port -> port -> port_number ; config = kmalloc ( sizeof ( * config ) , GFP_KERNEL ) ; if ( ! config ) { tty -> termios = * old_termios ; return ; } cflag = tty -> termios . c_cflag ; config -> wFlags = 0 ; config -> wFlags |= UMP_MASK_UART_FLAGS_RECEIVE_MS_INT ; config -> wFlags |= UMP_MASK_UART_FLAGS_AUTO_START_ON_ERR ; config -> bUartMode = ( __u8 ) ( edge_port -> bUartMode ) ; switch ( cflag & CSIZE ) { case CS5 : config -> bDataBits = UMP_UART_CHAR5BITS ; dev_dbg ( dev , "%s<S2SV_blank>-<S2SV_blank>data<S2SV_blank>bits<S2SV_blank>=<S2SV_blank>5\\n" , __func__ ) ; break ; case CS6 : config -> bDataBits = UMP_UART_CHAR6BITS ; dev_dbg ( dev , "%s<S2SV_blank>-<S2SV_blank>data<S2SV_blank>bits<S2SV_blank>=<S2SV_blank>6\\n" , __func__ ) ; break ; case CS7 : config -> bDataBits = UMP_UART_CHAR7BITS ; dev_dbg ( dev , "%s<S2SV_blank>-<S2SV_blank>data<S2SV_blank>bits<S2SV_blank>=<S2SV_blank>7\\n" , __func__ ) ; break ; default : case CS8 : config -> bDataBits = UMP_UART_CHAR8BITS ; dev_dbg ( dev , "%s<S2SV_blank>-<S2SV_blank>data<S2SV_blank>bits<S2SV_blank>=<S2SV_blank>8\\n" , __func__ ) ; break ; } if ( cflag & PARENB ) { if ( cflag & PARODD ) { config -> wFlags |= UMP_MASK_UART_FLAGS_PARITY ; config -> bParity = UMP_UART_ODDPARITY ; dev_dbg ( dev , "%s<S2SV_blank>-<S2SV_blank>parity<S2SV_blank>=<S2SV_blank>odd\\n" , __func__ ) ; } else { config -> wFlags |= UMP_MASK_UART_FLAGS_PARITY ; config -> bParity = UMP_UART_EVENPARITY ; dev_dbg ( dev , "%s<S2SV_blank>-<S2SV_blank>parity<S2SV_blank>=<S2SV_blank>even\\n" , __func__ ) ; } } else { config -> bParity = UMP_UART_NOPARITY ; dev_dbg ( dev , "%s<S2SV_blank>-<S2SV_blank>parity<S2SV_blank>=<S2SV_blank>none\\n" , __func__ ) ; } if ( cflag & CSTOPB ) { config -> bStopBits = UMP_UART_STOPBIT2 ; dev_dbg ( dev , "%s<S2SV_blank>-<S2SV_blank>stop<S2SV_blank>bits<S2SV_blank>=<S2SV_blank>2\\n" , __func__ ) ; } else { config -> bStopBits = UMP_UART_STOPBIT1 ; dev_dbg ( dev , "%s<S2SV_blank>-<S2SV_blank>stop<S2SV_blank>bits<S2SV_blank>=<S2SV_blank>1\\n" , __func__ ) ; } if ( cflag & CRTSCTS ) { config -> wFlags |= UMP_MASK_UART_FLAGS_OUT_X_CTS_FLOW ; config -> wFlags |= UMP_MASK_UART_FLAGS_RTS_FLOW ; dev_dbg ( dev , "%s<S2SV_blank>-<S2SV_blank>RTS/CTS<S2SV_blank>is<S2SV_blank>enabled\\n" , __func__ ) ; } else { dev_dbg ( dev , "%s<S2SV_blank>-<S2SV_blank>RTS/CTS<S2SV_blank>is<S2SV_blank>disabled\\n" , __func__ ) ; restart_read ( edge_port ) ; } config -> cXon = START_CHAR ( tty ) ; config -> cXoff = STOP_CHAR ( tty ) ; if ( I_IXOFF ( tty ) ) { config -> wFlags |= UMP_MASK_UART_FLAGS_IN_X ; dev_dbg ( dev , "%s<S2SV_blank>-<S2SV_blank>INBOUND<S2SV_blank>XON/XOFF<S2SV_blank>is<S2SV_blank>enabled,<S2SV_blank>XON<S2SV_blank>=<S2SV_blank>%2x,<S2SV_blank>XOFF<S2SV_blank>=<S2SV_blank>%2x\\n" , __func__ , config -> cXon , config -> cXoff ) ; } else dev_dbg ( dev , "%s<S2SV_blank>-<S2SV_blank>INBOUND<S2SV_blank>XON/XOFF<S2SV_blank>is<S2SV_blank>disabled\\n" , __func__ ) ; if ( I_IXON ( tty ) ) { config -> wFlags |= UMP_MASK_UART_FLAGS_OUT_X ; dev_dbg ( dev , "%s<S2SV_blank>-<S2SV_blank>OUTBOUND<S2SV_blank>XON/XOFF<S2SV_blank>is<S2SV_blank>enabled,<S2SV_blank>XON<S2SV_blank>=<S2SV_blank>%2x,<S2SV_blank>XOFF<S2SV_blank>=<S2SV_blank>%2x\\n" , __func__ , config -> cXon , config -> cXoff ) ; } else dev_dbg ( dev , "%s<S2SV_blank>-<S2SV_blank>OUTBOUND<S2SV_blank>XON/XOFF<S2SV_blank>is<S2SV_blank>disabled\\n" , __func__ ) ; tty -> termios . c_cflag &= ~ CMSPAR ; baud = tty_get_baud_rate ( tty ) ; if ( ! baud ) { baud = 9600 ; <S2SV_StartBug> } else <S2SV_EndBug> <S2SV_StartBug> tty_encode_baud_rate ( tty , baud , baud ) ; <S2SV_EndBug> edge_port -> baud_rate = baud ; config -> wBaudRate = ( __u16 ) ( ( 461550L + baud / 2 ) / baud ) ; dev_dbg ( dev , "%s<S2SV_blank>-<S2SV_blank>baud<S2SV_blank>rate<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>wBaudRate<S2SV_blank>=<S2SV_blank>%d\\n" , __func__ , baud , config -> wBaudRate ) ; dev_dbg ( dev , "wBaudRate:<S2SV_blank><S2SV_blank><S2SV_blank>%d\\n" , ( int ) ( 461550L / config -> wBaudRate ) ) ; dev_dbg ( dev , "wFlags:<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x%x\\n" , config -> wFlags ) ; dev_dbg ( dev , "bDataBits:<S2SV_blank><S2SV_blank><S2SV_blank>%d\\n" , config -> bDataBits ) ; dev_dbg ( dev , "bParity:<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%d\\n" , config -> bParity ) ; dev_dbg ( dev , "bStopBits:<S2SV_blank><S2SV_blank><S2SV_blank>%d\\n" , config -> bStopBits ) ; dev_dbg ( dev , "cXon:<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%d\\n" , config -> cXon ) ; dev_dbg ( dev , "cXoff:<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%d\\n" , config -> cXoff ) ; dev_dbg ( dev , "bUartMode:<S2SV_blank><S2SV_blank><S2SV_blank>%d\\n" , config -> bUartMode ) ; cpu_to_be16s ( & config -> wFlags ) ; cpu_to_be16s ( & config -> wBaudRate ) ; status = send_cmd ( edge_port -> port -> serial -> dev , UMPC_SET_CONFIG , ( __u8 ) ( UMPM_UART1_PORT + port_number ) , 0 , ( __u8 * ) config , sizeof ( * config ) ) ; if ( status ) dev_dbg ( dev , "%s<S2SV_blank>-<S2SV_blank>error<S2SV_blank>%d<S2SV_blank>when<S2SV_blank>trying<S2SV_blank>to<S2SV_blank>write<S2SV_blank>config<S2SV_blank>to<S2SV_blank>device\\n" , __func__ , status ) ; kfree ( config ) ; }
CWE-416 <S2SV_StartBug> void generic_pipe_buf_get ( struct pipe_inode_info * pipe , struct pipe_buffer * buf ) <S2SV_EndBug> { <S2SV_StartBug> get_page ( buf -> page ) ; <S2SV_EndBug> }
CWE-416 static int link_pipe ( struct pipe_inode_info * ipipe , struct pipe_inode_info * opipe , size_t len , unsigned int flags ) { struct pipe_buffer * ibuf , * obuf ; int ret = 0 , i = 0 , nbuf ; pipe_double_lock ( ipipe , opipe ) ; do { if ( ! opipe -> readers ) { send_sig ( SIGPIPE , current , 0 ) ; if ( ! ret ) ret = - EPIPE ; break ; } if ( i >= ipipe -> nrbufs || opipe -> nrbufs >= opipe -> buffers ) break ; ibuf = ipipe -> bufs + ( ( ipipe -> curbuf + i ) & ( ipipe -> buffers - 1 ) ) ; nbuf = ( opipe -> curbuf + opipe -> nrbufs ) & ( opipe -> buffers - 1 ) ; <S2SV_StartBug> pipe_buf_get ( ipipe , ibuf ) ; <S2SV_EndBug> obuf = opipe -> bufs + nbuf ; * obuf = * ibuf ; obuf -> flags &= ~ PIPE_BUF_FLAG_GIFT ; pipe_buf_mark_unmergeable ( obuf ) ; if ( obuf -> len > len ) obuf -> len = len ; opipe -> nrbufs ++ ; ret += obuf -> len ; len -= obuf -> len ; i ++ ; } while ( len ) ; if ( ! ret && ipipe -> waiting_writers && ( flags & SPLICE_F_NONBLOCK ) ) ret = - EAGAIN ; pipe_unlock ( ipipe ) ; pipe_unlock ( opipe ) ; if ( ret > 0 ) wakeup_pipe_readers ( opipe ) ; return ret ; }
CWE-416 static int splice_pipe_to_pipe ( struct pipe_inode_info * ipipe , struct pipe_inode_info * opipe , size_t len , unsigned int flags ) { struct pipe_buffer * ibuf , * obuf ; int ret = 0 , nbuf ; bool input_wakeup = false ; retry : ret = ipipe_prep ( ipipe , flags ) ; if ( ret ) return ret ; ret = opipe_prep ( opipe , flags ) ; if ( ret ) return ret ; pipe_double_lock ( ipipe , opipe ) ; do { if ( ! opipe -> readers ) { send_sig ( SIGPIPE , current , 0 ) ; if ( ! ret ) ret = - EPIPE ; break ; } if ( ! ipipe -> nrbufs && ! ipipe -> writers ) break ; if ( ! ipipe -> nrbufs || opipe -> nrbufs >= opipe -> buffers ) { if ( ret ) break ; if ( flags & SPLICE_F_NONBLOCK ) { ret = - EAGAIN ; break ; } pipe_unlock ( ipipe ) ; pipe_unlock ( opipe ) ; goto retry ; } ibuf = ipipe -> bufs + ipipe -> curbuf ; nbuf = ( opipe -> curbuf + opipe -> nrbufs ) & ( opipe -> buffers - 1 ) ; obuf = opipe -> bufs + nbuf ; if ( len >= ibuf -> len ) { * obuf = * ibuf ; ibuf -> ops = NULL ; opipe -> nrbufs ++ ; ipipe -> curbuf = ( ipipe -> curbuf + 1 ) & ( ipipe -> buffers - 1 ) ; ipipe -> nrbufs -- ; input_wakeup = true ; } else { <S2SV_StartBug> pipe_buf_get ( ipipe , ibuf ) ; <S2SV_EndBug> * obuf = * ibuf ; obuf -> flags &= ~ PIPE_BUF_FLAG_GIFT ; pipe_buf_mark_unmergeable ( obuf ) ; obuf -> len = len ; opipe -> nrbufs ++ ; ibuf -> offset += obuf -> len ; ibuf -> len -= obuf -> len ; } ret += obuf -> len ; len -= obuf -> len ; } while ( len ) ; pipe_unlock ( ipipe ) ; pipe_unlock ( opipe ) ; if ( ret > 0 ) wakeup_pipe_readers ( opipe ) ; if ( input_wakeup ) wakeup_pipe_writers ( ipipe ) ; return ret ; }
CWE-416 <S2SV_StartBug> static void buffer_pipe_buf_get ( struct pipe_inode_info * pipe , <S2SV_EndBug> struct pipe_buffer * buf ) { struct buffer_ref * ref = ( struct buffer_ref * ) buf -> private ; <S2SV_StartBug> ref -> ref ++ ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>
CWE-416 static struct page * follow_page_pte ( struct vm_area_struct * vma , unsigned long address , pmd_t * pmd , unsigned int flags , struct dev_pagemap * * pgmap ) { struct mm_struct * mm = vma -> vm_mm ; struct page * page ; spinlock_t * ptl ; pte_t * ptep , pte ; retry : if ( unlikely ( pmd_bad ( * pmd ) ) ) return no_page_table ( vma , flags ) ; ptep = pte_offset_map_lock ( mm , pmd , address , & ptl ) ; pte = * ptep ; if ( ! pte_present ( pte ) ) { swp_entry_t entry ; if ( likely ( ! ( flags & FOLL_MIGRATION ) ) ) goto no_page ; if ( pte_none ( pte ) ) goto no_page ; entry = pte_to_swp_entry ( pte ) ; if ( ! is_migration_entry ( entry ) ) goto no_page ; pte_unmap_unlock ( ptep , ptl ) ; migration_entry_wait ( mm , pmd , address ) ; goto retry ; } if ( ( flags & FOLL_NUMA ) && pte_protnone ( pte ) ) goto no_page ; if ( ( flags & FOLL_WRITE ) && ! can_follow_write_pte ( pte , flags ) ) { pte_unmap_unlock ( ptep , ptl ) ; return NULL ; } page = vm_normal_page ( vma , address , pte ) ; if ( ! page && pte_devmap ( pte ) && ( flags & FOLL_GET ) ) { * pgmap = get_dev_pagemap ( pte_pfn ( pte ) , * pgmap ) ; if ( * pgmap ) page = pte_page ( pte ) ; else goto no_page ; } else if ( unlikely ( ! page ) ) { if ( flags & FOLL_DUMP ) { page = ERR_PTR ( - EFAULT ) ; goto out ; } if ( is_zero_pfn ( pte_pfn ( pte ) ) ) { page = pte_page ( pte ) ; } else { int ret ; ret = follow_pfn_pte ( vma , address , ptep , flags ) ; page = ERR_PTR ( ret ) ; goto out ; } } if ( flags & FOLL_SPLIT && PageTransCompound ( page ) ) { int ret ; get_page ( page ) ; pte_unmap_unlock ( ptep , ptl ) ; lock_page ( page ) ; ret = split_huge_page ( page ) ; unlock_page ( page ) ; put_page ( page ) ; if ( ret ) return ERR_PTR ( ret ) ; goto retry ; } if ( flags & FOLL_GET ) <S2SV_StartBug> get_page ( page ) ; <S2SV_EndBug> if ( flags & FOLL_TOUCH ) { if ( ( flags & FOLL_WRITE ) && ! pte_dirty ( pte ) && ! PageDirty ( page ) ) set_page_dirty ( page ) ; mark_page_accessed ( page ) ; } if ( ( flags & FOLL_MLOCK ) && ( vma -> vm_flags & VM_LOCKED ) ) { if ( PageTransCompound ( page ) ) goto out ; if ( page -> mapping && trylock_page ( page ) ) { lru_add_drain ( ) ; mlock_vma_page ( page ) ; unlock_page ( page ) ; } } out : pte_unmap_unlock ( ptep , ptl ) ; return page ; no_page : pte_unmap_unlock ( ptep , ptl ) ; if ( ! pte_none ( pte ) ) return NULL ; return no_page_table ( vma , flags ) ; }
CWE-416 static struct page * follow_pmd_mask ( struct vm_area_struct * vma , unsigned long address , pud_t * pudp , unsigned int flags , struct follow_page_context * ctx ) { pmd_t * pmd , pmdval ; spinlock_t * ptl ; struct page * page ; struct mm_struct * mm = vma -> vm_mm ; pmd = pmd_offset ( pudp , address ) ; pmdval = READ_ONCE ( * pmd ) ; if ( pmd_none ( pmdval ) ) return no_page_table ( vma , flags ) ; if ( pmd_huge ( pmdval ) && vma -> vm_flags & VM_HUGETLB ) { page = follow_huge_pmd ( mm , address , pmd , flags ) ; if ( page ) return page ; return no_page_table ( vma , flags ) ; } if ( is_hugepd ( __hugepd ( pmd_val ( pmdval ) ) ) ) { page = follow_huge_pd ( vma , address , __hugepd ( pmd_val ( pmdval ) ) , flags , PMD_SHIFT ) ; if ( page ) return page ; return no_page_table ( vma , flags ) ; } retry : if ( ! pmd_present ( pmdval ) ) { if ( likely ( ! ( flags & FOLL_MIGRATION ) ) ) return no_page_table ( vma , flags ) ; VM_BUG_ON ( thp_migration_supported ( ) && ! is_pmd_migration_entry ( pmdval ) ) ; if ( is_pmd_migration_entry ( pmdval ) ) pmd_migration_entry_wait ( mm , pmd ) ; pmdval = READ_ONCE ( * pmd ) ; if ( pmd_none ( pmdval ) ) return no_page_table ( vma , flags ) ; goto retry ; } if ( pmd_devmap ( pmdval ) ) { ptl = pmd_lock ( mm , pmd ) ; page = follow_devmap_pmd ( vma , address , pmd , flags , & ctx -> pgmap ) ; spin_unlock ( ptl ) ; if ( page ) return page ; } if ( likely ( ! pmd_trans_huge ( pmdval ) ) ) return follow_page_pte ( vma , address , pmd , flags , & ctx -> pgmap ) ; if ( ( flags & FOLL_NUMA ) && pmd_protnone ( pmdval ) ) return no_page_table ( vma , flags ) ; retry_locked : ptl = pmd_lock ( mm , pmd ) ; if ( unlikely ( pmd_none ( * pmd ) ) ) { spin_unlock ( ptl ) ; return no_page_table ( vma , flags ) ; } if ( unlikely ( ! pmd_present ( * pmd ) ) ) { spin_unlock ( ptl ) ; if ( likely ( ! ( flags & FOLL_MIGRATION ) ) ) return no_page_table ( vma , flags ) ; pmd_migration_entry_wait ( mm , pmd ) ; goto retry_locked ; } if ( unlikely ( ! pmd_trans_huge ( * pmd ) ) ) { spin_unlock ( ptl ) ; return follow_page_pte ( vma , address , pmd , flags , & ctx -> pgmap ) ; } if ( flags & FOLL_SPLIT ) { int ret ; page = pmd_page ( * pmd ) ; if ( is_huge_zero_page ( page ) ) { spin_unlock ( ptl ) ; ret = 0 ; split_huge_pmd ( vma , pmd , address ) ; if ( pmd_trans_unstable ( pmd ) ) ret = - EBUSY ; } else { <S2SV_StartBug> get_page ( page ) ; <S2SV_EndBug> spin_unlock ( ptl ) ; lock_page ( page ) ; ret = split_huge_page ( page ) ; unlock_page ( page ) ; put_page ( page ) ; if ( pmd_none ( * pmd ) ) return no_page_table ( vma , flags ) ; } return ret ? ERR_PTR ( ret ) : follow_page_pte ( vma , address , pmd , flags , & ctx -> pgmap ) ; } page = follow_trans_huge_pmd ( vma , address , pmd , flags ) ; spin_unlock ( ptl ) ; ctx -> page_mask = HPAGE_PMD_NR - 1 ; return page ; }
CWE-416 static int get_gate_page ( struct mm_struct * mm , unsigned long address , unsigned int gup_flags , struct vm_area_struct * * vma , struct page * * page ) { pgd_t * pgd ; p4d_t * p4d ; pud_t * pud ; pmd_t * pmd ; pte_t * pte ; int ret = - EFAULT ; if ( gup_flags & FOLL_WRITE ) return - EFAULT ; if ( address > TASK_SIZE ) pgd = pgd_offset_k ( address ) ; else pgd = pgd_offset_gate ( mm , address ) ; BUG_ON ( pgd_none ( * pgd ) ) ; p4d = p4d_offset ( pgd , address ) ; BUG_ON ( p4d_none ( * p4d ) ) ; pud = pud_offset ( p4d , address ) ; BUG_ON ( pud_none ( * pud ) ) ; pmd = pmd_offset ( pud , address ) ; if ( ! pmd_present ( * pmd ) ) return - EFAULT ; VM_BUG_ON ( pmd_trans_huge ( * pmd ) ) ; pte = pte_offset_map ( pmd , address ) ; if ( pte_none ( * pte ) ) goto unmap ; * vma = get_gate_vma ( mm ) ; if ( ! page ) goto out ; * page = vm_normal_page ( * vma , address , * pte ) ; if ( ! * page ) { if ( ( gup_flags & FOLL_DUMP ) || ! is_zero_pfn ( pte_pfn ( * pte ) ) ) goto unmap ; * page = pte_page ( * pte ) ; if ( is_device_public_page ( * page ) ) goto unmap ; } <S2SV_StartBug> get_page ( * page ) ; <S2SV_EndBug> out : ret = 0 ; unmap : pte_unmap ( pte ) ; return ret ; }
CWE-416 long follow_hugetlb_page ( struct mm_struct * mm , struct vm_area_struct * vma , struct page * * pages , struct vm_area_struct * * vmas , unsigned long * position , unsigned long * nr_pages , long i , unsigned int flags , int * nonblocking ) { unsigned long pfn_offset ; unsigned long vaddr = * position ; unsigned long remainder = * nr_pages ; struct hstate * h = hstate_vma ( vma ) ; int err = - EFAULT ; while ( vaddr < vma -> vm_end && remainder ) { pte_t * pte ; spinlock_t * ptl = NULL ; int absent ; struct page * page ; if ( fatal_signal_pending ( current ) ) { remainder = 0 ; break ; } pte = huge_pte_offset ( mm , vaddr & huge_page_mask ( h ) , huge_page_size ( h ) ) ; if ( pte ) ptl = huge_pte_lock ( h , mm , pte ) ; absent = ! pte || huge_pte_none ( huge_ptep_get ( pte ) ) ; if ( absent && ( flags & FOLL_DUMP ) && ! hugetlbfs_pagecache_present ( h , vma , vaddr ) ) { if ( pte ) spin_unlock ( ptl ) ; remainder = 0 ; break ; } if ( absent || is_swap_pte ( huge_ptep_get ( pte ) ) || ( ( flags & FOLL_WRITE ) && ! huge_pte_write ( huge_ptep_get ( pte ) ) ) ) { vm_fault_t ret ; unsigned int fault_flags = 0 ; if ( pte ) spin_unlock ( ptl ) ; if ( flags & FOLL_WRITE ) fault_flags |= FAULT_FLAG_WRITE ; if ( nonblocking ) fault_flags |= FAULT_FLAG_ALLOW_RETRY ; if ( flags & FOLL_NOWAIT ) fault_flags |= FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_RETRY_NOWAIT ; if ( flags & FOLL_TRIED ) { VM_WARN_ON_ONCE ( fault_flags & FAULT_FLAG_ALLOW_RETRY ) ; fault_flags |= FAULT_FLAG_TRIED ; } ret = hugetlb_fault ( mm , vma , vaddr , fault_flags ) ; if ( ret & VM_FAULT_ERROR ) { err = vm_fault_to_errno ( ret , flags ) ; remainder = 0 ; break ; } if ( ret & VM_FAULT_RETRY ) { if ( nonblocking && ! ( fault_flags & FAULT_FLAG_RETRY_NOWAIT ) ) * nonblocking = 0 ; * nr_pages = 0 ; return i ; } continue ; } pfn_offset = ( vaddr & ~ huge_page_mask ( h ) ) >> PAGE_SHIFT ; page = pte_page ( huge_ptep_get ( pte ) ) ; <S2SV_StartBug> same_page : <S2SV_EndBug> if ( pages ) { pages [ i ] = mem_map_offset ( page , pfn_offset ) ; get_page ( pages [ i ] ) ; } if ( vmas ) vmas [ i ] = vma ; vaddr += PAGE_SIZE ; ++ pfn_offset ; -- remainder ; ++ i ; if ( vaddr < vma -> vm_end && remainder && pfn_offset < pages_per_huge_page ( h ) ) { goto same_page ; } spin_unlock ( ptl ) ; } * nr_pages = remainder ; * position = vaddr ; return i ? i : err ; }
CWE-772 int hsr_dev_finalize ( struct net_device * hsr_dev , struct net_device * slave [ 2 ] , unsigned char multicast_spec , u8 protocol_version ) { struct hsr_priv * hsr ; struct hsr_port * port ; int res ; hsr = netdev_priv ( hsr_dev ) ; INIT_LIST_HEAD ( & hsr -> ports ) ; INIT_LIST_HEAD ( & hsr -> node_db ) ; INIT_LIST_HEAD ( & hsr -> self_node_db ) ; ether_addr_copy ( hsr_dev -> dev_addr , slave [ 0 ] -> dev_addr ) ; res = hsr_create_self_node ( & hsr -> self_node_db , hsr_dev -> dev_addr , slave [ 1 ] -> dev_addr ) ; if ( res < 0 ) return res ; spin_lock_init ( & hsr -> seqnr_lock ) ; hsr -> sequence_nr = HSR_SEQNR_START ; hsr -> sup_sequence_nr = HSR_SUP_SEQNR_START ; timer_setup ( & hsr -> announce_timer , hsr_announce , 0 ) ; timer_setup ( & hsr -> prune_timer , hsr_prune_nodes , 0 ) ; ether_addr_copy ( hsr -> sup_multicast_addr , def_multicast_addr ) ; hsr -> sup_multicast_addr [ ETH_ALEN - 1 ] = multicast_spec ; hsr -> protVersion = protocol_version ; netif_carrier_off ( hsr_dev ) ; res = hsr_add_port ( hsr , hsr_dev , HSR_PT_MASTER ) ; if ( res ) <S2SV_StartBug> return res ; <S2SV_EndBug> res = register_netdevice ( hsr_dev ) ; if ( res ) goto fail ; res = hsr_add_port ( hsr , slave [ 0 ] , HSR_PT_SLAVE_A ) ; if ( res ) goto fail ; res = hsr_add_port ( hsr , slave [ 1 ] , HSR_PT_SLAVE_B ) ; if ( res ) goto fail ; mod_timer ( & hsr -> prune_timer , jiffies + msecs_to_jiffies ( PRUNE_PERIOD ) ) ; return 0 ; fail : hsr_for_each_port ( hsr , port ) hsr_del_port ( port ) ; <S2SV_StartBug> return res ; <S2SV_EndBug> }
CWE-400 static int add_ballooned_pages ( int nr_pages ) { enum bp_state st ; if ( xen_hotplug_unpopulated ) { st = reserve_additional_memory ( ) ; if ( st != BP_ECANCELED ) { mutex_unlock ( & balloon_mutex ) ; wait_event ( balloon_wq , ! list_empty ( & ballooned_pages ) ) ; mutex_lock ( & balloon_mutex ) ; return 0 ; } } <S2SV_StartBug> st = decrease_reservation ( nr_pages , GFP_USER ) ; <S2SV_EndBug> if ( st != BP_DONE ) return - ENOMEM ; return 0 ; }
CWE-400 static void balloon_process ( struct work_struct * work ) { enum bp_state state = BP_DONE ; long credit ; do { mutex_lock ( & balloon_mutex ) ; credit = current_credit ( ) ; if ( credit > 0 ) { if ( balloon_is_inflated ( ) ) state = increase_reservation ( credit ) ; else state = reserve_additional_memory ( ) ; } <S2SV_StartBug> if ( credit < 0 ) <S2SV_EndBug> <S2SV_StartBug> state = decrease_reservation ( - credit , GFP_BALLOON ) ; <S2SV_EndBug> state = update_schedule ( state ) ; mutex_unlock ( & balloon_mutex ) ; cond_resched ( ) ; } while ( credit && state == BP_DONE ) ; if ( state == BP_EAGAIN ) schedule_delayed_work ( & balloon_worker , balloon_stats . schedule_delay * HZ ) ; }
CWE-416 int __mdiobus_register ( struct mii_bus * bus , struct module * owner ) { struct mdio_device * mdiodev ; int i , err ; struct gpio_desc * gpiod ; if ( NULL == bus || NULL == bus -> name || NULL == bus -> read || NULL == bus -> write ) return - EINVAL ; BUG_ON ( bus -> state != MDIOBUS_ALLOCATED && bus -> state != MDIOBUS_UNREGISTERED ) ; bus -> owner = owner ; bus -> dev . parent = bus -> parent ; bus -> dev . class = & mdio_bus_class ; bus -> dev . groups = NULL ; dev_set_name ( & bus -> dev , "%s" , bus -> id ) ; err = device_register ( & bus -> dev ) ; if ( err ) { pr_err ( "mii_bus<S2SV_blank>%s<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>register\\n" , bus -> id ) ; <S2SV_StartBug> put_device ( & bus -> dev ) ; <S2SV_EndBug> return - EINVAL ; } mutex_init ( & bus -> mdio_lock ) ; gpiod = devm_gpiod_get_optional ( & bus -> dev , "reset" , GPIOD_OUT_LOW ) ; if ( IS_ERR ( gpiod ) ) { dev_err ( & bus -> dev , "mii_bus<S2SV_blank>%s<S2SV_blank>couldn\'t<S2SV_blank>get<S2SV_blank>reset<S2SV_blank>GPIO\\n" , bus -> id ) ; device_del ( & bus -> dev ) ; return PTR_ERR ( gpiod ) ; } else if ( gpiod ) { bus -> reset_gpiod = gpiod ; gpiod_set_value_cansleep ( gpiod , 1 ) ; udelay ( bus -> reset_delay_us ) ; gpiod_set_value_cansleep ( gpiod , 0 ) ; } if ( bus -> reset ) bus -> reset ( bus ) ; for ( i = 0 ; i < PHY_MAX_ADDR ; i ++ ) { if ( ( bus -> phy_mask & ( 1 << i ) ) == 0 ) { struct phy_device * phydev ; phydev = mdiobus_scan ( bus , i ) ; if ( IS_ERR ( phydev ) && ( PTR_ERR ( phydev ) != - ENODEV ) ) { err = PTR_ERR ( phydev ) ; goto error ; } } } mdiobus_setup_mdiodev_from_board_info ( bus , mdiobus_create_device ) ; bus -> state = MDIOBUS_REGISTERED ; pr_info ( "%s:<S2SV_blank>probed\\n" , bus -> name ) ; return 0 ; error : while ( -- i >= 0 ) { mdiodev = bus -> mdio_map [ i ] ; if ( ! mdiodev ) continue ; mdiodev -> device_remove ( mdiodev ) ; mdiodev -> device_free ( mdiodev ) ; } if ( bus -> reset_gpiod ) gpiod_set_value_cansleep ( bus -> reset_gpiod , 1 ) ; device_del ( & bus -> dev ) ; return err ; }
CWE-416 static void free_user ( struct kref * ref ) { struct ipmi_user * user = container_of ( ref , struct ipmi_user , refcount ) ; <S2SV_StartBug> kfree ( user ) ; <S2SV_EndBug> }
CWE-416 int ipmi_destroy_user ( struct ipmi_user * user ) { <S2SV_StartBug> _ipmi_destroy_user ( user ) ; <S2SV_EndBug> cleanup_srcu_struct ( & user -> release_barrier ) ; kref_put ( & user -> refcount , free_user ) ; return 0 ; }
CWE-120 static int mwifiex_update_vs_ie ( const u8 * ies , int ies_len , struct mwifiex_ie * * ie_ptr , u16 mask , unsigned int oui , u8 oui_type ) { struct ieee_types_header * vs_ie ; struct mwifiex_ie * ie = * ie_ptr ; const u8 * vendor_ie ; vendor_ie = cfg80211_find_vendor_ie ( oui , oui_type , ies , ies_len ) ; if ( vendor_ie ) { if ( ! * ie_ptr ) { * ie_ptr = kzalloc ( sizeof ( struct mwifiex_ie ) , GFP_KERNEL ) ; if ( ! * ie_ptr ) return - ENOMEM ; ie = * ie_ptr ; } vs_ie = ( struct ieee_types_header * ) vendor_ie ; <S2SV_StartBug> memcpy ( ie -> ie_buffer + le16_to_cpu ( ie -> ie_length ) , <S2SV_EndBug> vs_ie , vs_ie -> len + 2 ) ; le16_unaligned_add_cpu ( & ie -> ie_length , vs_ie -> len + 2 ) ; ie -> mgmt_subtype_mask = cpu_to_le16 ( mask ) ; ie -> ie_index = cpu_to_le16 ( MWIFIEX_AUTO_IDX_MASK ) ; } * ie_ptr = ie ; return 0 ; }
CWE-120 void mwifiex_set_uap_rates ( struct mwifiex_uap_bss_param * bss_cfg , struct cfg80211_ap_settings * params ) { struct ieee_types_header * rate_ie ; int var_offset = offsetof ( struct ieee80211_mgmt , u . beacon . variable ) ; const u8 * var_pos = params -> beacon . head + var_offset ; int len = params -> beacon . head_len - var_offset ; u8 rate_len = 0 ; rate_ie = ( void * ) cfg80211_find_ie ( WLAN_EID_SUPP_RATES , var_pos , len ) ; if ( rate_ie ) { <S2SV_StartBug> memcpy ( bss_cfg -> rates , rate_ie + 1 , rate_ie -> len ) ; <S2SV_EndBug> rate_len = rate_ie -> len ; } rate_ie = ( void * ) cfg80211_find_ie ( WLAN_EID_EXT_SUPP_RATES , params -> beacon . tail , params -> beacon . tail_len ) ; <S2SV_StartBug> if ( rate_ie ) <S2SV_EndBug> <S2SV_StartBug> memcpy ( bss_cfg -> rates + rate_len , rate_ie + 1 , rate_ie -> len ) ; <S2SV_EndBug> return ; }
CWE-120 void mwifiex_set_wmm_params ( struct mwifiex_private * priv , struct mwifiex_uap_bss_param * bss_cfg , struct cfg80211_ap_settings * params ) { const u8 * vendor_ie ; const u8 * wmm_ie ; u8 wmm_oui [ ] = { 0x00 , 0x50 , 0xf2 , 0x02 } ; vendor_ie = cfg80211_find_vendor_ie ( WLAN_OUI_MICROSOFT , WLAN_OUI_TYPE_MICROSOFT_WMM , params -> beacon . tail , params -> beacon . tail_len ) ; if ( vendor_ie ) { wmm_ie = vendor_ie ; <S2SV_StartBug> memcpy ( & bss_cfg -> wmm_info , wmm_ie + <S2SV_EndBug> <S2SV_StartBug> sizeof ( struct ieee_types_header ) , * ( wmm_ie + 1 ) ) ; <S2SV_EndBug> priv -> wmm_enabled = 1 ; } else { memset ( & bss_cfg -> wmm_info , 0 , sizeof ( bss_cfg -> wmm_info ) ) ; memcpy ( & bss_cfg -> wmm_info . oui , wmm_oui , sizeof ( wmm_oui ) ) ; bss_cfg -> wmm_info . subtype = MWIFIEX_WMM_SUBTYPE ; bss_cfg -> wmm_info . version = MWIFIEX_WMM_VERSION ; priv -> wmm_enabled = 0 ; } bss_cfg -> qos_info = 0x00 ; return ; }
CWE-415 static int f_midi_set_alt ( struct usb_function * f , unsigned intf , unsigned alt ) { struct f_midi * midi = func_to_midi ( f ) ; unsigned i ; int err ; if ( intf != midi -> ms_id ) return 0 ; err = f_midi_start_ep ( midi , f , midi -> in_ep ) ; if ( err ) return err ; err = f_midi_start_ep ( midi , f , midi -> out_ep ) ; if ( err ) return err ; while ( kfifo_avail ( & midi -> in_req_fifo ) ) { struct usb_request * req = midi_alloc_ep_req ( midi -> in_ep , midi -> buflen ) ; if ( req == NULL ) return - ENOMEM ; req -> length = 0 ; req -> complete = f_midi_complete ; kfifo_put ( & midi -> in_req_fifo , req ) ; } for ( i = 0 ; i < midi -> qlen && err == 0 ; i ++ ) { struct usb_request * req = midi_alloc_ep_req ( midi -> out_ep , midi -> buflen ) ; if ( req == NULL ) return - ENOMEM ; req -> complete = f_midi_complete ; err = usb_ep_queue ( midi -> out_ep , req , GFP_ATOMIC ) ; if ( err ) { ERROR ( midi , "%s:<S2SV_blank>couldn\'t<S2SV_blank>enqueue<S2SV_blank>request:<S2SV_blank>%d\\n" , midi -> out_ep -> name , err ) ; <S2SV_StartBug> free_ep_req ( midi -> out_ep , req ) ; <S2SV_EndBug> return err ; } } return 0 ; }
CWE-416 static struct page * follow_page_pte ( struct vm_area_struct * vma , unsigned long address , pmd_t * pmd , unsigned int flags , struct dev_pagemap * * pgmap ) { struct mm_struct * mm = vma -> vm_mm ; struct page * page ; spinlock_t * ptl ; pte_t * ptep , pte ; retry : if ( unlikely ( pmd_bad ( * pmd ) ) ) return no_page_table ( vma , flags ) ; ptep = pte_offset_map_lock ( mm , pmd , address , & ptl ) ; pte = * ptep ; if ( ! pte_present ( pte ) ) { swp_entry_t entry ; if ( likely ( ! ( flags & FOLL_MIGRATION ) ) ) goto no_page ; if ( pte_none ( pte ) ) goto no_page ; entry = pte_to_swp_entry ( pte ) ; if ( ! is_migration_entry ( entry ) ) goto no_page ; pte_unmap_unlock ( ptep , ptl ) ; migration_entry_wait ( mm , pmd , address ) ; goto retry ; } if ( ( flags & FOLL_NUMA ) && pte_protnone ( pte ) ) goto no_page ; if ( ( flags & FOLL_WRITE ) && ! can_follow_write_pte ( pte , flags ) ) { pte_unmap_unlock ( ptep , ptl ) ; return NULL ; } page = vm_normal_page ( vma , address , pte ) ; if ( ! page && pte_devmap ( pte ) && ( flags & FOLL_GET ) ) { * pgmap = get_dev_pagemap ( pte_pfn ( pte ) , * pgmap ) ; if ( * pgmap ) page = pte_page ( pte ) ; else goto no_page ; } else if ( unlikely ( ! page ) ) { if ( flags & FOLL_DUMP ) { page = ERR_PTR ( - EFAULT ) ; goto out ; } if ( is_zero_pfn ( pte_pfn ( pte ) ) ) { page = pte_page ( pte ) ; } else { int ret ; ret = follow_pfn_pte ( vma , address , ptep , flags ) ; page = ERR_PTR ( ret ) ; goto out ; } } if ( flags & FOLL_SPLIT && PageTransCompound ( page ) ) { int ret ; get_page ( page ) ; pte_unmap_unlock ( ptep , ptl ) ; lock_page ( page ) ; ret = split_huge_page ( page ) ; unlock_page ( page ) ; put_page ( page ) ; if ( ret ) return ERR_PTR ( ret ) ; goto retry ; } if ( flags & FOLL_GET ) <S2SV_StartBug> get_page ( page ) ; <S2SV_EndBug> if ( flags & FOLL_TOUCH ) { if ( ( flags & FOLL_WRITE ) && ! pte_dirty ( pte ) && ! PageDirty ( page ) ) set_page_dirty ( page ) ; mark_page_accessed ( page ) ; } if ( ( flags & FOLL_MLOCK ) && ( vma -> vm_flags & VM_LOCKED ) ) { if ( PageTransCompound ( page ) ) goto out ; if ( page -> mapping && trylock_page ( page ) ) { lru_add_drain ( ) ; mlock_vma_page ( page ) ; unlock_page ( page ) ; } } out : pte_unmap_unlock ( ptep , ptl ) ; return page ; no_page : pte_unmap_unlock ( ptep , ptl ) ; if ( ! pte_none ( pte ) ) return NULL ; return no_page_table ( vma , flags ) ; }
CWE-416 static struct page * follow_pmd_mask ( struct vm_area_struct * vma , unsigned long address , pud_t * pudp , unsigned int flags , struct follow_page_context * ctx ) { pmd_t * pmd , pmdval ; spinlock_t * ptl ; struct page * page ; struct mm_struct * mm = vma -> vm_mm ; pmd = pmd_offset ( pudp , address ) ; pmdval = READ_ONCE ( * pmd ) ; if ( pmd_none ( pmdval ) ) return no_page_table ( vma , flags ) ; if ( pmd_huge ( pmdval ) && vma -> vm_flags & VM_HUGETLB ) { page = follow_huge_pmd ( mm , address , pmd , flags ) ; if ( page ) return page ; return no_page_table ( vma , flags ) ; } if ( is_hugepd ( __hugepd ( pmd_val ( pmdval ) ) ) ) { page = follow_huge_pd ( vma , address , __hugepd ( pmd_val ( pmdval ) ) , flags , PMD_SHIFT ) ; if ( page ) return page ; return no_page_table ( vma , flags ) ; } retry : if ( ! pmd_present ( pmdval ) ) { if ( likely ( ! ( flags & FOLL_MIGRATION ) ) ) return no_page_table ( vma , flags ) ; VM_BUG_ON ( thp_migration_supported ( ) && ! is_pmd_migration_entry ( pmdval ) ) ; if ( is_pmd_migration_entry ( pmdval ) ) pmd_migration_entry_wait ( mm , pmd ) ; pmdval = READ_ONCE ( * pmd ) ; if ( pmd_none ( pmdval ) ) return no_page_table ( vma , flags ) ; goto retry ; } if ( pmd_devmap ( pmdval ) ) { ptl = pmd_lock ( mm , pmd ) ; page = follow_devmap_pmd ( vma , address , pmd , flags , & ctx -> pgmap ) ; spin_unlock ( ptl ) ; if ( page ) return page ; } if ( likely ( ! pmd_trans_huge ( pmdval ) ) ) return follow_page_pte ( vma , address , pmd , flags , & ctx -> pgmap ) ; if ( ( flags & FOLL_NUMA ) && pmd_protnone ( pmdval ) ) return no_page_table ( vma , flags ) ; retry_locked : ptl = pmd_lock ( mm , pmd ) ; if ( unlikely ( pmd_none ( * pmd ) ) ) { spin_unlock ( ptl ) ; return no_page_table ( vma , flags ) ; } if ( unlikely ( ! pmd_present ( * pmd ) ) ) { spin_unlock ( ptl ) ; if ( likely ( ! ( flags & FOLL_MIGRATION ) ) ) return no_page_table ( vma , flags ) ; pmd_migration_entry_wait ( mm , pmd ) ; goto retry_locked ; } if ( unlikely ( ! pmd_trans_huge ( * pmd ) ) ) { spin_unlock ( ptl ) ; return follow_page_pte ( vma , address , pmd , flags , & ctx -> pgmap ) ; } if ( flags & FOLL_SPLIT ) { int ret ; page = pmd_page ( * pmd ) ; if ( is_huge_zero_page ( page ) ) { spin_unlock ( ptl ) ; ret = 0 ; split_huge_pmd ( vma , pmd , address ) ; if ( pmd_trans_unstable ( pmd ) ) ret = - EBUSY ; } else { <S2SV_StartBug> get_page ( page ) ; <S2SV_EndBug> spin_unlock ( ptl ) ; lock_page ( page ) ; ret = split_huge_page ( page ) ; unlock_page ( page ) ; put_page ( page ) ; if ( pmd_none ( * pmd ) ) return no_page_table ( vma , flags ) ; } return ret ? ERR_PTR ( ret ) : follow_page_pte ( vma , address , pmd , flags , & ctx -> pgmap ) ; } page = follow_trans_huge_pmd ( vma , address , pmd , flags ) ; spin_unlock ( ptl ) ; ctx -> page_mask = HPAGE_PMD_NR - 1 ; return page ; }
CWE-416 static int get_gate_page ( struct mm_struct * mm , unsigned long address , unsigned int gup_flags , struct vm_area_struct * * vma , struct page * * page ) { pgd_t * pgd ; p4d_t * p4d ; pud_t * pud ; pmd_t * pmd ; pte_t * pte ; int ret = - EFAULT ; if ( gup_flags & FOLL_WRITE ) return - EFAULT ; if ( address > TASK_SIZE ) pgd = pgd_offset_k ( address ) ; else pgd = pgd_offset_gate ( mm , address ) ; BUG_ON ( pgd_none ( * pgd ) ) ; p4d = p4d_offset ( pgd , address ) ; BUG_ON ( p4d_none ( * p4d ) ) ; pud = pud_offset ( p4d , address ) ; BUG_ON ( pud_none ( * pud ) ) ; pmd = pmd_offset ( pud , address ) ; if ( ! pmd_present ( * pmd ) ) return - EFAULT ; VM_BUG_ON ( pmd_trans_huge ( * pmd ) ) ; pte = pte_offset_map ( pmd , address ) ; if ( pte_none ( * pte ) ) goto unmap ; * vma = get_gate_vma ( mm ) ; if ( ! page ) goto out ; * page = vm_normal_page ( * vma , address , * pte ) ; if ( ! * page ) { if ( ( gup_flags & FOLL_DUMP ) || ! is_zero_pfn ( pte_pfn ( * pte ) ) ) goto unmap ; * page = pte_page ( * pte ) ; if ( is_device_public_page ( * page ) ) goto unmap ; } <S2SV_StartBug> get_page ( * page ) ; <S2SV_EndBug> out : ret = 0 ; unmap : pte_unmap ( pte ) ; return ret ; }
CWE-416 long follow_hugetlb_page ( struct mm_struct * mm , struct vm_area_struct * vma , struct page * * pages , struct vm_area_struct * * vmas , unsigned long * position , unsigned long * nr_pages , long i , unsigned int flags , int * nonblocking ) { unsigned long pfn_offset ; unsigned long vaddr = * position ; unsigned long remainder = * nr_pages ; struct hstate * h = hstate_vma ( vma ) ; int err = - EFAULT ; while ( vaddr < vma -> vm_end && remainder ) { pte_t * pte ; spinlock_t * ptl = NULL ; int absent ; struct page * page ; if ( fatal_signal_pending ( current ) ) { remainder = 0 ; break ; } pte = huge_pte_offset ( mm , vaddr & huge_page_mask ( h ) , huge_page_size ( h ) ) ; if ( pte ) ptl = huge_pte_lock ( h , mm , pte ) ; absent = ! pte || huge_pte_none ( huge_ptep_get ( pte ) ) ; if ( absent && ( flags & FOLL_DUMP ) && ! hugetlbfs_pagecache_present ( h , vma , vaddr ) ) { if ( pte ) spin_unlock ( ptl ) ; remainder = 0 ; break ; } if ( absent || is_swap_pte ( huge_ptep_get ( pte ) ) || ( ( flags & FOLL_WRITE ) && ! huge_pte_write ( huge_ptep_get ( pte ) ) ) ) { vm_fault_t ret ; unsigned int fault_flags = 0 ; if ( pte ) spin_unlock ( ptl ) ; if ( flags & FOLL_WRITE ) fault_flags |= FAULT_FLAG_WRITE ; if ( nonblocking ) fault_flags |= FAULT_FLAG_ALLOW_RETRY ; if ( flags & FOLL_NOWAIT ) fault_flags |= FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_RETRY_NOWAIT ; if ( flags & FOLL_TRIED ) { VM_WARN_ON_ONCE ( fault_flags & FAULT_FLAG_ALLOW_RETRY ) ; fault_flags |= FAULT_FLAG_TRIED ; } ret = hugetlb_fault ( mm , vma , vaddr , fault_flags ) ; if ( ret & VM_FAULT_ERROR ) { err = vm_fault_to_errno ( ret , flags ) ; remainder = 0 ; break ; } if ( ret & VM_FAULT_RETRY ) { if ( nonblocking && ! ( fault_flags & FAULT_FLAG_RETRY_NOWAIT ) ) * nonblocking = 0 ; * nr_pages = 0 ; return i ; } continue ; } pfn_offset = ( vaddr & ~ huge_page_mask ( h ) ) >> PAGE_SHIFT ; page = pte_page ( huge_ptep_get ( pte ) ) ; <S2SV_StartBug> same_page : <S2SV_EndBug> if ( pages ) { pages [ i ] = mem_map_offset ( page , pfn_offset ) ; get_page ( pages [ i ] ) ; } if ( vmas ) vmas [ i ] = vma ; vaddr += PAGE_SIZE ; ++ pfn_offset ; -- remainder ; ++ i ; if ( vaddr < vma -> vm_end && remainder && pfn_offset < pages_per_huge_page ( h ) ) { goto same_page ; } spin_unlock ( ptl ) ; } * nr_pages = remainder ; * position = vaddr ; return i ? i : err ; }
CWE-189 static int adjust_ptr_min_max_vals ( struct bpf_verifier_env * env , struct bpf_insn * insn , const struct bpf_reg_state * ptr_reg , const struct bpf_reg_state * off_reg ) { struct bpf_verifier_state * vstate = env -> cur_state ; struct bpf_func_state * state = vstate -> frame [ vstate -> curframe ] ; struct bpf_reg_state * regs = state -> regs , * dst_reg ; bool known = tnum_is_const ( off_reg -> var_off ) ; s64 smin_val = off_reg -> smin_value , smax_val = off_reg -> smax_value , smin_ptr = ptr_reg -> smin_value , smax_ptr = ptr_reg -> smax_value ; u64 umin_val = off_reg -> umin_value , umax_val = off_reg -> umax_value , umin_ptr = ptr_reg -> umin_value , umax_ptr = ptr_reg -> umax_value ; u32 dst = insn -> dst_reg , src = insn -> src_reg ; <S2SV_StartBug> u8 opcode = BPF_OP ( insn -> code ) ; <S2SV_EndBug> dst_reg = & regs [ dst ] ; if ( ( known && ( smin_val != smax_val || umin_val != umax_val ) ) || smin_val > smax_val || umin_val > umax_val ) { __mark_reg_unknown ( dst_reg ) ; return 0 ; } if ( BPF_CLASS ( insn -> code ) != BPF_ALU64 ) { verbose ( env , "R%d<S2SV_blank>32-bit<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>prohibited\\n" , dst ) ; return - EACCES ; } switch ( ptr_reg -> type ) { case PTR_TO_MAP_VALUE_OR_NULL : verbose ( env , "R%d<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>on<S2SV_blank>%s<S2SV_blank>prohibited,<S2SV_blank>null-check<S2SV_blank>it<S2SV_blank>first\\n" , dst , reg_type_str [ ptr_reg -> type ] ) ; return - EACCES ; case CONST_PTR_TO_MAP : case PTR_TO_PACKET_END : case PTR_TO_SOCKET : case PTR_TO_SOCKET_OR_NULL : verbose ( env , "R%d<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>on<S2SV_blank>%s<S2SV_blank>prohibited\\n" , dst , reg_type_str [ ptr_reg -> type ] ) ; return - EACCES ; case PTR_TO_MAP_VALUE : if ( ! env -> allow_ptr_leaks && ! known && ( smin_val < 0 ) != ( smax_val < 0 ) ) { verbose ( env , "R%d<S2SV_blank>has<S2SV_blank>unknown<S2SV_blank>scalar<S2SV_blank>with<S2SV_blank>mixed<S2SV_blank>signed<S2SV_blank>bounds,<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>with<S2SV_blank>it<S2SV_blank>prohibited<S2SV_blank>for<S2SV_blank>!root\\n" , off_reg == dst_reg ? dst : src ) ; return - EACCES ; } default : break ; } dst_reg -> type = ptr_reg -> type ; dst_reg -> id = ptr_reg -> id ; if ( ! check_reg_sane_offset ( env , off_reg , ptr_reg -> type ) || ! check_reg_sane_offset ( env , ptr_reg , ptr_reg -> type ) ) return - EINVAL ; switch ( opcode ) { case BPF_ADD : <S2SV_StartBug> if ( known && ( ptr_reg -> off + smin_val == <S2SV_EndBug> ( s64 ) ( s32 ) ( ptr_reg -> off + smin_val ) ) ) { dst_reg -> smin_value = smin_ptr ; dst_reg -> smax_value = smax_ptr ; dst_reg -> umin_value = umin_ptr ; dst_reg -> umax_value = umax_ptr ; dst_reg -> var_off = ptr_reg -> var_off ; dst_reg -> off = ptr_reg -> off + smin_val ; dst_reg -> raw = ptr_reg -> raw ; break ; } if ( signed_add_overflows ( smin_ptr , smin_val ) || signed_add_overflows ( smax_ptr , smax_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = smin_ptr + smin_val ; dst_reg -> smax_value = smax_ptr + smax_val ; } if ( umin_ptr + umin_val < umin_ptr || umax_ptr + umax_val < umax_ptr ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value = umin_ptr + umin_val ; dst_reg -> umax_value = umax_ptr + umax_val ; } dst_reg -> var_off = tnum_add ( ptr_reg -> var_off , off_reg -> var_off ) ; dst_reg -> off = ptr_reg -> off ; dst_reg -> raw = ptr_reg -> raw ; if ( reg_is_pkt_pointer ( ptr_reg ) ) { dst_reg -> id = ++ env -> id_gen ; dst_reg -> raw = 0 ; } break ; case BPF_SUB : <S2SV_StartBug> if ( dst_reg == off_reg ) { <S2SV_EndBug> verbose ( env , "R%d<S2SV_blank>tried<S2SV_blank>to<S2SV_blank>subtract<S2SV_blank>pointer<S2SV_blank>from<S2SV_blank>scalar\\n" , dst ) ; return - EACCES ; } if ( ptr_reg -> type == PTR_TO_STACK ) { verbose ( env , "R%d<S2SV_blank>subtraction<S2SV_blank>from<S2SV_blank>stack<S2SV_blank>pointer<S2SV_blank>prohibited\\n" , dst ) ; return - EACCES ; } if ( known && ( ptr_reg -> off - smin_val == ( s64 ) ( s32 ) ( ptr_reg -> off - smin_val ) ) ) { dst_reg -> smin_value = smin_ptr ; dst_reg -> smax_value = smax_ptr ; dst_reg -> umin_value = umin_ptr ; dst_reg -> umax_value = umax_ptr ; dst_reg -> var_off = ptr_reg -> var_off ; dst_reg -> id = ptr_reg -> id ; dst_reg -> off = ptr_reg -> off - smin_val ; dst_reg -> raw = ptr_reg -> raw ; break ; } if ( signed_sub_overflows ( smin_ptr , smax_val ) || signed_sub_overflows ( smax_ptr , smin_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = smin_ptr - smax_val ; dst_reg -> smax_value = smax_ptr - smin_val ; } if ( umin_ptr < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value = umin_ptr - umax_val ; dst_reg -> umax_value = umax_ptr - umin_val ; } dst_reg -> var_off = tnum_sub ( ptr_reg -> var_off , off_reg -> var_off ) ; dst_reg -> off = ptr_reg -> off ; dst_reg -> raw = ptr_reg -> raw ; if ( reg_is_pkt_pointer ( ptr_reg ) ) { dst_reg -> id = ++ env -> id_gen ; if ( smin_val < 0 ) dst_reg -> raw = 0 ; } break ; case BPF_AND : case BPF_OR : case BPF_XOR : verbose ( env , "R%d<S2SV_blank>bitwise<S2SV_blank>operator<S2SV_blank>%s<S2SV_blank>on<S2SV_blank>pointer<S2SV_blank>prohibited\\n" , dst , bpf_alu_string [ opcode >> 4 ] ) ; return - EACCES ; default : verbose ( env , "R%d<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>with<S2SV_blank>%s<S2SV_blank>operator<S2SV_blank>prohibited\\n" , dst , bpf_alu_string [ opcode >> 4 ] ) ; return - EACCES ; } if ( ! check_reg_sane_offset ( env , dst_reg , ptr_reg -> type ) ) return - EINVAL ; __update_reg_bounds ( dst_reg ) ; __reg_deduce_bounds ( dst_reg ) ; __reg_bound_offset ( dst_reg ) ; if ( ! env -> allow_ptr_leaks ) { if ( dst_reg -> type == PTR_TO_MAP_VALUE && check_map_access ( env , dst , dst_reg -> off , 1 , false ) ) { verbose ( env , "R%d<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>of<S2SV_blank>map<S2SV_blank>value<S2SV_blank>goes<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range,<S2SV_blank>" "prohibited<S2SV_blank>for<S2SV_blank>!root\\n" , dst ) ; return - EACCES ; } else if ( dst_reg -> type == PTR_TO_STACK && check_stack_access ( env , dst_reg , dst_reg -> off + dst_reg -> var_off . value , 1 ) ) { verbose ( env , "R%d<S2SV_blank>stack<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>goes<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range,<S2SV_blank>" "prohibited<S2SV_blank>for<S2SV_blank>!root\\n" , dst ) ; return - EACCES ; } } return 0 ; }
CWE-189 static int check_cond_jmp_op ( struct bpf_verifier_env * env , struct bpf_insn * insn , int * insn_idx ) { struct bpf_verifier_state * this_branch = env -> cur_state ; struct bpf_verifier_state * other_branch ; struct bpf_reg_state * regs = this_branch -> frame [ this_branch -> curframe ] -> regs ; struct bpf_reg_state * dst_reg , * other_branch_regs ; u8 opcode = BPF_OP ( insn -> code ) ; int err ; if ( opcode > BPF_JSLE ) { verbose ( env , "invalid<S2SV_blank>BPF_JMP<S2SV_blank>opcode<S2SV_blank>%x\\n" , opcode ) ; return - EINVAL ; } if ( BPF_SRC ( insn -> code ) == BPF_X ) { if ( insn -> imm != 0 ) { verbose ( env , "BPF_JMP<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n" ) ; return - EINVAL ; } err = check_reg_arg ( env , insn -> src_reg , SRC_OP ) ; if ( err ) return err ; if ( is_pointer_value ( env , insn -> src_reg ) ) { verbose ( env , "R%d<S2SV_blank>pointer<S2SV_blank>comparison<S2SV_blank>prohibited\\n" , insn -> src_reg ) ; return - EACCES ; } } else { if ( insn -> src_reg != BPF_REG_0 ) { verbose ( env , "BPF_JMP<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n" ) ; return - EINVAL ; } } err = check_reg_arg ( env , insn -> dst_reg , SRC_OP ) ; if ( err ) return err ; dst_reg = & regs [ insn -> dst_reg ] ; if ( BPF_SRC ( insn -> code ) == BPF_K ) { int pred = is_branch_taken ( dst_reg , insn -> imm , opcode ) ; if ( pred == 1 ) { * insn_idx += insn -> off ; return 0 ; } else if ( pred == 0 ) { return 0 ; } } <S2SV_StartBug> other_branch = push_stack ( env , * insn_idx + insn -> off + 1 , * insn_idx ) ; <S2SV_EndBug> if ( ! other_branch ) return - EFAULT ; other_branch_regs = other_branch -> frame [ other_branch -> curframe ] -> regs ; if ( BPF_SRC ( insn -> code ) == BPF_X ) { if ( dst_reg -> type == SCALAR_VALUE && regs [ insn -> src_reg ] . type == SCALAR_VALUE ) { if ( tnum_is_const ( regs [ insn -> src_reg ] . var_off ) ) reg_set_min_max ( & other_branch_regs [ insn -> dst_reg ] , dst_reg , regs [ insn -> src_reg ] . var_off . value , opcode ) ; else if ( tnum_is_const ( dst_reg -> var_off ) ) reg_set_min_max_inv ( & other_branch_regs [ insn -> src_reg ] , & regs [ insn -> src_reg ] , dst_reg -> var_off . value , opcode ) ; else if ( opcode == BPF_JEQ || opcode == BPF_JNE ) reg_combine_min_max ( & other_branch_regs [ insn -> src_reg ] , & other_branch_regs [ insn -> dst_reg ] , & regs [ insn -> src_reg ] , & regs [ insn -> dst_reg ] , opcode ) ; } } else if ( dst_reg -> type == SCALAR_VALUE ) { reg_set_min_max ( & other_branch_regs [ insn -> dst_reg ] , dst_reg , insn -> imm , opcode ) ; } if ( BPF_SRC ( insn -> code ) == BPF_K && insn -> imm == 0 && ( opcode == BPF_JEQ || opcode == BPF_JNE ) && reg_type_may_be_null ( dst_reg -> type ) ) { mark_ptr_or_null_regs ( this_branch , insn -> dst_reg , opcode == BPF_JNE ) ; mark_ptr_or_null_regs ( other_branch , insn -> dst_reg , opcode == BPF_JEQ ) ; } else if ( ! try_match_pkt_pointers ( insn , dst_reg , & regs [ insn -> src_reg ] , this_branch , other_branch ) && is_pointer_value ( env , insn -> dst_reg ) ) { verbose ( env , "R%d<S2SV_blank>pointer<S2SV_blank>comparison<S2SV_blank>prohibited\\n" , insn -> dst_reg ) ; return - EACCES ; } if ( env -> log . level ) print_verifier_state ( env , this_branch -> frame [ this_branch -> curframe ] ) ; return 0 ; }
CWE-189 static int copy_verifier_state ( struct bpf_verifier_state * dst_state , const struct bpf_verifier_state * src ) { struct bpf_func_state * dst ; int i , err ; for ( i = src -> curframe + 1 ; i <= dst_state -> curframe ; i ++ ) { free_func_state ( dst_state -> frame [ i ] ) ; dst_state -> frame [ i ] = NULL ; <S2SV_StartBug> } <S2SV_EndBug> dst_state -> curframe = src -> curframe ; for ( i = 0 ; i <= src -> curframe ; i ++ ) { dst = dst_state -> frame [ i ] ; if ( ! dst ) { dst = kzalloc ( sizeof ( * dst ) , GFP_KERNEL ) ; if ( ! dst ) return - ENOMEM ; dst_state -> frame [ i ] = dst ; } err = copy_func_state ( dst , src -> frame [ i ] ) ; if ( err ) return err ; } return 0 ; }
CWE-189 static int do_check ( struct bpf_verifier_env * env ) { struct bpf_verifier_state * state ; struct bpf_insn * insns = env -> prog -> insnsi ; struct bpf_reg_state * regs ; int insn_cnt = env -> prog -> len , i ; int insn_processed = 0 ; bool do_print_state = false ; env -> prev_linfo = NULL ; state = kzalloc ( sizeof ( struct bpf_verifier_state ) , GFP_KERNEL ) ; if ( ! state ) return - ENOMEM ; state -> curframe = 0 ; <S2SV_StartBug> state -> frame [ 0 ] = kzalloc ( sizeof ( struct bpf_func_state ) , GFP_KERNEL ) ; <S2SV_EndBug> if ( ! state -> frame [ 0 ] ) { kfree ( state ) ; return - ENOMEM ; } env -> cur_state = state ; init_func_state ( env , state -> frame [ 0 ] , BPF_MAIN_FUNC , 0 , 0 ) ; for ( ; ; ) { struct bpf_insn * insn ; u8 class ; int err ; if ( env -> insn_idx >= insn_cnt ) { verbose ( env , "invalid<S2SV_blank>insn<S2SV_blank>idx<S2SV_blank>%d<S2SV_blank>insn_cnt<S2SV_blank>%d\\n" , env -> insn_idx , insn_cnt ) ; return - EFAULT ; } insn = & insns [ env -> insn_idx ] ; class = BPF_CLASS ( insn -> code ) ; if ( ++ insn_processed > BPF_COMPLEXITY_LIMIT_INSNS ) { verbose ( env , "BPF<S2SV_blank>program<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large.<S2SV_blank>Processed<S2SV_blank>%d<S2SV_blank>insn\\n" , insn_processed ) ; return - E2BIG ; } err = is_state_visited ( env , env -> insn_idx ) ; if ( err < 0 ) return err ; if ( err == 1 ) { if ( env -> log . level ) { if ( do_print_state ) <S2SV_StartBug> verbose ( env , "\\nfrom<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%d:<S2SV_blank>safe\\n" , <S2SV_EndBug> <S2SV_StartBug> env -> prev_insn_idx , env -> insn_idx ) ; <S2SV_EndBug> else verbose ( env , "%d:<S2SV_blank>safe\\n" , env -> insn_idx ) ; } goto process_bpf_exit ; } if ( signal_pending ( current ) ) return - EAGAIN ; if ( need_resched ( ) ) cond_resched ( ) ; if ( env -> log . level > 1 || ( env -> log . level && do_print_state ) ) { if ( env -> log . level > 1 ) verbose ( env , "%d:" , env -> insn_idx ) ; else <S2SV_StartBug> verbose ( env , "\\nfrom<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%d:" , <S2SV_EndBug> <S2SV_StartBug> env -> prev_insn_idx , env -> insn_idx ) ; <S2SV_EndBug> print_verifier_state ( env , state -> frame [ state -> curframe ] ) ; do_print_state = false ; } if ( env -> log . level ) { const struct bpf_insn_cbs cbs = { . cb_print = verbose , . private_data = env , } ; verbose_linfo ( env , env -> insn_idx , ";<S2SV_blank>" ) ; verbose ( env , "%d:<S2SV_blank>" , env -> insn_idx ) ; print_bpf_insn ( & cbs , insn , env -> allow_ptr_leaks ) ; } if ( bpf_prog_is_dev_bound ( env -> prog -> aux ) ) { err = bpf_prog_offload_verify_insn ( env , env -> insn_idx , env -> prev_insn_idx ) ; if ( err ) return err ; } regs = cur_regs ( env ) ; env -> insn_aux_data [ env -> insn_idx ] . seen = true ; if ( class == BPF_ALU || class == BPF_ALU64 ) { err = check_alu_op ( env , insn ) ; if ( err ) return err ; } else if ( class == BPF_LDX ) { enum bpf_reg_type * prev_src_type , src_reg_type ; err = check_reg_arg ( env , insn -> src_reg , SRC_OP ) ; if ( err ) return err ; err = check_reg_arg ( env , insn -> dst_reg , DST_OP_NO_MARK ) ; if ( err ) return err ; src_reg_type = regs [ insn -> src_reg ] . type ; err = check_mem_access ( env , env -> insn_idx , insn -> src_reg , insn -> off , BPF_SIZE ( insn -> code ) , BPF_READ , insn -> dst_reg , false ) ; if ( err ) return err ; prev_src_type = & env -> insn_aux_data [ env -> insn_idx ] . ptr_type ; if ( * prev_src_type == NOT_INIT ) { * prev_src_type = src_reg_type ; } else if ( reg_type_mismatch ( src_reg_type , * prev_src_type ) ) { verbose ( env , "same<S2SV_blank>insn<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>used<S2SV_blank>with<S2SV_blank>different<S2SV_blank>pointers\\n" ) ; return - EINVAL ; } } else if ( class == BPF_STX ) { enum bpf_reg_type * prev_dst_type , dst_reg_type ; if ( BPF_MODE ( insn -> code ) == BPF_XADD ) { err = check_xadd ( env , env -> insn_idx , insn ) ; if ( err ) return err ; env -> insn_idx ++ ; continue ; } err = check_reg_arg ( env , insn -> src_reg , SRC_OP ) ; if ( err ) return err ; err = check_reg_arg ( env , insn -> dst_reg , SRC_OP ) ; if ( err ) return err ; dst_reg_type = regs [ insn -> dst_reg ] . type ; err = check_mem_access ( env , env -> insn_idx , insn -> dst_reg , insn -> off , BPF_SIZE ( insn -> code ) , BPF_WRITE , insn -> src_reg , false ) ; if ( err ) return err ; prev_dst_type = & env -> insn_aux_data [ env -> insn_idx ] . ptr_type ; if ( * prev_dst_type == NOT_INIT ) { * prev_dst_type = dst_reg_type ; } else if ( reg_type_mismatch ( dst_reg_type , * prev_dst_type ) ) { verbose ( env , "same<S2SV_blank>insn<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>used<S2SV_blank>with<S2SV_blank>different<S2SV_blank>pointers\\n" ) ; return - EINVAL ; } } else if ( class == BPF_ST ) { if ( BPF_MODE ( insn -> code ) != BPF_MEM || insn -> src_reg != BPF_REG_0 ) { verbose ( env , "BPF_ST<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n" ) ; return - EINVAL ; } err = check_reg_arg ( env , insn -> dst_reg , SRC_OP ) ; if ( err ) return err ; if ( is_ctx_reg ( env , insn -> dst_reg ) ) { verbose ( env , "BPF_ST<S2SV_blank>stores<S2SV_blank>into<S2SV_blank>R%d<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>allowed\\n" , insn -> dst_reg , reg_type_str [ reg_state ( env , insn -> dst_reg ) -> type ] ) ; return - EACCES ; } err = check_mem_access ( env , env -> insn_idx , insn -> dst_reg , insn -> off , BPF_SIZE ( insn -> code ) , BPF_WRITE , - 1 , false ) ; if ( err ) return err ; } else if ( class == BPF_JMP ) { u8 opcode = BPF_OP ( insn -> code ) ; if ( opcode == BPF_CALL ) { if ( BPF_SRC ( insn -> code ) != BPF_K || insn -> off != 0 || ( insn -> src_reg != BPF_REG_0 && insn -> src_reg != BPF_PSEUDO_CALL ) || insn -> dst_reg != BPF_REG_0 ) { verbose ( env , "BPF_CALL<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n" ) ; return - EINVAL ; } if ( insn -> src_reg == BPF_PSEUDO_CALL ) err = check_func_call ( env , insn , & env -> insn_idx ) ; else err = check_helper_call ( env , insn -> imm , env -> insn_idx ) ; if ( err ) return err ; } else if ( opcode == BPF_JA ) { if ( BPF_SRC ( insn -> code ) != BPF_K || insn -> imm != 0 || insn -> src_reg != BPF_REG_0 || insn -> dst_reg != BPF_REG_0 ) { verbose ( env , "BPF_JA<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n" ) ; return - EINVAL ; } env -> insn_idx += insn -> off + 1 ; continue ; } else if ( opcode == BPF_EXIT ) { if ( BPF_SRC ( insn -> code ) != BPF_K || insn -> imm != 0 || insn -> src_reg != BPF_REG_0 || insn -> dst_reg != BPF_REG_0 ) { verbose ( env , "BPF_EXIT<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n" ) ; return - EINVAL ; } if ( state -> curframe ) { env -> prev_insn_idx = env -> insn_idx ; err = prepare_func_exit ( env , & env -> insn_idx ) ; if ( err ) return err ; do_print_state = true ; continue ; } err = check_reference_leak ( env ) ; if ( err ) return err ; err = check_reg_arg ( env , BPF_REG_0 , SRC_OP ) ; if ( err ) return err ; if ( is_pointer_value ( env , BPF_REG_0 ) ) { verbose ( env , "R0<S2SV_blank>leaks<S2SV_blank>addr<S2SV_blank>as<S2SV_blank>return<S2SV_blank>value\\n" ) ; return - EACCES ; } err = check_return_code ( env ) ; if ( err ) return err ; process_bpf_exit : err = pop_stack ( env , & env -> prev_insn_idx , & env -> insn_idx ) ; if ( err < 0 ) { if ( err != - ENOENT ) return err ; break ; } else { do_print_state = true ; continue ; } } else { err = check_cond_jmp_op ( env , insn , & env -> insn_idx ) ; if ( err ) return err ; } } else if ( class == BPF_LD ) { u8 mode = BPF_MODE ( insn -> code ) ; if ( mode == BPF_ABS || mode == BPF_IND ) { err = check_ld_abs ( env , insn ) ; if ( err ) return err ; } else if ( mode == BPF_IMM ) { err = check_ld_imm ( env , insn ) ; if ( err ) return err ; env -> insn_idx ++ ; env -> insn_aux_data [ env -> insn_idx ] . seen = true ; } else { verbose ( env , "invalid<S2SV_blank>BPF_LD<S2SV_blank>mode\\n" ) ; return - EINVAL ; } } else { verbose ( env , "unknown<S2SV_blank>insn<S2SV_blank>class<S2SV_blank>%d\\n" , class ) ; return - EINVAL ; } env -> insn_idx ++ ; } verbose ( env , "processed<S2SV_blank>%d<S2SV_blank>insns<S2SV_blank>(limit<S2SV_blank>%d),<S2SV_blank>stack<S2SV_blank>depth<S2SV_blank>" , insn_processed , BPF_COMPLEXITY_LIMIT_INSNS ) ; for ( i = 0 ; i < env -> subprog_cnt ; i ++ ) { u32 depth = env -> subprog_info [ i ] . stack_depth ; verbose ( env , "%d" , depth ) ; if ( i + 1 < env -> subprog_cnt ) verbose ( env , "+" ) ; } verbose ( env , "\\n" ) ; env -> prog -> aux -> stack_depth = env -> subprog_info [ 0 ] . stack_depth ; return 0 ; }
CWE-189 static int fixup_bpf_calls ( struct bpf_verifier_env * env ) { struct bpf_prog * prog = env -> prog ; struct bpf_insn * insn = prog -> insnsi ; const struct bpf_func_proto * fn ; const int insn_cnt = prog -> len ; const struct bpf_map_ops * ops ; struct bpf_insn_aux_data * aux ; struct bpf_insn insn_buf [ 16 ] ; struct bpf_prog * new_prog ; struct bpf_map * map_ptr ; int i , cnt , delta = 0 ; for ( i = 0 ; i < insn_cnt ; i ++ , insn ++ ) { if ( insn -> code == ( BPF_ALU64 | BPF_MOD | BPF_X ) || insn -> code == ( BPF_ALU64 | BPF_DIV | BPF_X ) || insn -> code == ( BPF_ALU | BPF_MOD | BPF_X ) || insn -> code == ( BPF_ALU | BPF_DIV | BPF_X ) ) { bool is64 = BPF_CLASS ( insn -> code ) == BPF_ALU64 ; struct bpf_insn mask_and_div [ ] = { BPF_MOV32_REG ( insn -> src_reg , insn -> src_reg ) , BPF_JMP_IMM ( BPF_JNE , insn -> src_reg , 0 , 2 ) , BPF_ALU32_REG ( BPF_XOR , insn -> dst_reg , insn -> dst_reg ) , BPF_JMP_IMM ( BPF_JA , 0 , 0 , 1 ) , * insn , } ; struct bpf_insn mask_and_mod [ ] = { BPF_MOV32_REG ( insn -> src_reg , insn -> src_reg ) , BPF_JMP_IMM ( BPF_JEQ , insn -> src_reg , 0 , 1 ) , * insn , } ; struct bpf_insn * patchlet ; if ( insn -> code == ( BPF_ALU64 | BPF_DIV | BPF_X ) || insn -> code == ( BPF_ALU | BPF_DIV | BPF_X ) ) { patchlet = mask_and_div + ( is64 ? 1 : 0 ) ; cnt = ARRAY_SIZE ( mask_and_div ) - ( is64 ? 1 : 0 ) ; } else { patchlet = mask_and_mod + ( is64 ? 1 : 0 ) ; cnt = ARRAY_SIZE ( mask_and_mod ) - ( is64 ? 1 : 0 ) ; } new_prog = bpf_patch_insn_data ( env , i + delta , patchlet , cnt ) ; if ( ! new_prog ) return - ENOMEM ; delta += cnt - 1 ; env -> prog = prog = new_prog ; insn = new_prog -> insnsi + i + delta ; continue ; } if ( BPF_CLASS ( insn -> code ) == BPF_LD && ( BPF_MODE ( insn -> code ) == BPF_ABS || BPF_MODE ( insn -> code ) == BPF_IND ) ) { cnt = env -> ops -> gen_ld_abs ( insn , insn_buf ) ; if ( cnt == 0 || cnt >= ARRAY_SIZE ( insn_buf ) ) { verbose ( env , "bpf<S2SV_blank>verifier<S2SV_blank>is<S2SV_blank>misconfigured\\n" ) ; return - EINVAL ; } new_prog = bpf_patch_insn_data ( env , i + delta , insn_buf , cnt ) ; if ( ! new_prog ) return - ENOMEM ; delta += cnt - 1 ; env -> prog = prog = new_prog ; insn = new_prog -> insnsi + i + delta ; continue ; } <S2SV_StartBug> if ( insn -> code != ( BPF_JMP | BPF_CALL ) ) <S2SV_EndBug> continue ; if ( insn -> src_reg == BPF_PSEUDO_CALL ) continue ; if ( insn -> imm == BPF_FUNC_get_route_realm ) prog -> dst_needed = 1 ; if ( insn -> imm == BPF_FUNC_get_prandom_u32 ) bpf_user_rnd_init_once ( ) ; if ( insn -> imm == BPF_FUNC_override_return ) prog -> kprobe_override = 1 ; if ( insn -> imm == BPF_FUNC_tail_call ) { prog -> cb_access = 1 ; env -> prog -> aux -> stack_depth = MAX_BPF_STACK ; env -> prog -> aux -> max_pkt_offset = MAX_PACKET_OFF ; insn -> imm = 0 ; insn -> code = BPF_JMP | BPF_TAIL_CALL ; aux = & env -> insn_aux_data [ i + delta ] ; <S2SV_StartBug> if ( ! bpf_map_ptr_unpriv ( aux ) ) <S2SV_EndBug> continue ; <S2SV_StartBug> if ( bpf_map_ptr_poisoned ( aux ) ) { <S2SV_EndBug> verbose ( env , "tail_call<S2SV_blank>abusing<S2SV_blank>map_ptr\\n" ) ; return - EINVAL ; } map_ptr = BPF_MAP_PTR ( aux -> map_state ) ; insn_buf [ 0 ] = BPF_JMP_IMM ( BPF_JGE , BPF_REG_3 , map_ptr -> max_entries , 2 ) ; insn_buf [ 1 ] = BPF_ALU32_IMM ( BPF_AND , BPF_REG_3 , container_of ( map_ptr , struct bpf_array , map ) -> index_mask ) ; insn_buf [ 2 ] = * insn ; cnt = 3 ; new_prog = bpf_patch_insn_data ( env , i + delta , insn_buf , cnt ) ; if ( ! new_prog ) return - ENOMEM ; delta += cnt - 1 ; env -> prog = prog = new_prog ; insn = new_prog -> insnsi + i + delta ; continue ; } <S2SV_StartBug> if ( prog -> jit_requested && BITS_PER_LONG == 64 && <S2SV_EndBug> ( insn -> imm == BPF_FUNC_map_lookup_elem || insn -> imm == BPF_FUNC_map_update_elem || insn -> imm == BPF_FUNC_map_delete_elem || insn -> imm == BPF_FUNC_map_push_elem || insn -> imm == BPF_FUNC_map_pop_elem || insn -> imm == BPF_FUNC_map_peek_elem ) ) { aux = & env -> insn_aux_data [ i + delta ] ; <S2SV_StartBug> if ( bpf_map_ptr_poisoned ( aux ) ) <S2SV_EndBug> <S2SV_StartBug> goto patch_call_imm ; <S2SV_EndBug> map_ptr = BPF_MAP_PTR ( aux -> map_state ) ; <S2SV_StartBug> ops = map_ptr -> ops ; <S2SV_EndBug> if ( insn -> imm == BPF_FUNC_map_lookup_elem && ops -> map_gen_lookup ) { <S2SV_StartBug> cnt = ops -> map_gen_lookup ( map_ptr , insn_buf ) ; <S2SV_EndBug> if ( cnt == 0 || cnt >= ARRAY_SIZE ( insn_buf ) ) { verbose ( env , "bpf<S2SV_blank>verifier<S2SV_blank>is<S2SV_blank>misconfigured\\n" ) ; return - EINVAL ; } new_prog = bpf_patch_insn_data ( env , i + delta , insn_buf , cnt ) ; if ( ! new_prog ) return - ENOMEM ; delta += cnt - 1 ; env -> prog = prog = new_prog ; insn = new_prog -> insnsi + i + delta ; continue ; } <S2SV_StartBug> BUILD_BUG_ON ( ! __same_type ( ops -> map_lookup_elem , <S2SV_EndBug> ( void * ( * ) ( struct bpf_map * map , void * key ) ) NULL ) ) ; BUILD_BUG_ON ( ! __same_type ( ops -> map_delete_elem , ( int ( * ) ( struct bpf_map * map , void * key ) ) NULL ) ) ; BUILD_BUG_ON ( ! __same_type ( ops -> map_update_elem , ( int ( * ) ( struct bpf_map * map , void * key , void * value , u64 flags ) ) NULL ) ) ; BUILD_BUG_ON ( ! __same_type ( ops -> map_push_elem , ( int ( * ) ( struct bpf_map * map , void * value , u64 flags ) ) NULL ) ) ; BUILD_BUG_ON ( ! __same_type ( ops -> map_pop_elem , ( int ( * ) ( struct bpf_map * map , void * value ) ) NULL ) ) ; BUILD_BUG_ON ( ! __same_type ( ops -> map_peek_elem , ( int ( * ) ( struct bpf_map * map , void * value ) ) NULL ) ) ; switch ( insn -> imm ) { case BPF_FUNC_map_lookup_elem : insn -> imm = BPF_CAST_CALL ( ops -> map_lookup_elem ) - __bpf_call_base ; continue ; case BPF_FUNC_map_update_elem : insn -> imm = BPF_CAST_CALL ( ops -> map_update_elem ) - __bpf_call_base ; continue ; case BPF_FUNC_map_delete_elem : insn -> imm = BPF_CAST_CALL ( ops -> map_delete_elem ) - __bpf_call_base ; continue ; case BPF_FUNC_map_push_elem : insn -> imm = BPF_CAST_CALL ( ops -> map_push_elem ) - __bpf_call_base ; continue ; case BPF_FUNC_map_pop_elem : insn -> imm = BPF_CAST_CALL ( ops -> map_pop_elem ) - __bpf_call_base ; continue ; case BPF_FUNC_map_peek_elem : insn -> imm = BPF_CAST_CALL ( ops -> map_peek_elem ) - __bpf_call_base ; continue ; } goto patch_call_imm ; } patch_call_imm : fn = env -> ops -> get_func_proto ( insn -> imm , env -> prog ) ; if ( ! fn -> func ) { verbose ( env , "kernel<S2SV_blank>subsystem<S2SV_blank>misconfigured<S2SV_blank>func<S2SV_blank>%s#%d\\n" , func_id_name ( insn -> imm ) , insn -> imm ) ; return - EFAULT ; } insn -> imm = fn -> func - __bpf_call_base ; } return 0 ; }
CWE-189 static struct bpf_verifier_state * push_stack ( struct bpf_verifier_env * env , <S2SV_StartBug> int insn_idx , int prev_insn_idx ) <S2SV_EndBug> { struct bpf_verifier_state * cur = env -> cur_state ; struct bpf_verifier_stack_elem * elem ; int err ; elem = kzalloc ( sizeof ( struct bpf_verifier_stack_elem ) , GFP_KERNEL ) ; if ( ! elem ) goto err ; elem -> insn_idx = insn_idx ; elem -> prev_insn_idx = prev_insn_idx ; elem -> next = env -> head ; env -> head = elem ; env -> stack_size ++ ; err = copy_verifier_state ( & elem -> st , cur ) ; if ( err ) <S2SV_StartBug> goto err ; <S2SV_EndBug> if ( env -> stack_size > BPF_COMPLEXITY_LIMIT_STACK ) { verbose ( env , "BPF<S2SV_blank>program<S2SV_blank>is<S2SV_blank>too<S2SV_blank>complex\\n" ) ; goto err ; } return & elem -> st ; err : free_verifier_state ( env -> cur_state , true ) ; env -> cur_state = NULL ; while ( ! pop_stack ( env , NULL , NULL ) ) ; return NULL ; }
CWE-189 static bool states_equal ( struct bpf_verifier_env * env , struct bpf_verifier_state * old , struct bpf_verifier_state * cur ) { int i ; <S2SV_StartBug> if ( old -> curframe != cur -> curframe ) <S2SV_EndBug> return false ; for ( i = 0 ; i <= old -> curframe ; i ++ ) { if ( old -> frame [ i ] -> callsite != cur -> frame [ i ] -> callsite ) return false ; if ( ! func_states_equal ( old -> frame [ i ] , cur -> frame [ i ] ) ) return false ; } return true ; }
CWE-77 static int do_hidp_sock_ioctl ( struct socket * sock , unsigned int cmd , void __user * argp ) { struct hidp_connadd_req ca ; struct hidp_conndel_req cd ; struct hidp_connlist_req cl ; struct hidp_conninfo ci ; struct socket * csock ; struct socket * isock ; int err ; BT_DBG ( "cmd<S2SV_blank>%x<S2SV_blank>arg<S2SV_blank>%p" , cmd , argp ) ; switch ( cmd ) { case HIDPCONNADD : if ( ! capable ( CAP_NET_ADMIN ) ) return - EPERM ; if ( copy_from_user ( & ca , argp , sizeof ( ca ) ) ) return - EFAULT ; csock = sockfd_lookup ( ca . ctrl_sock , & err ) ; if ( ! csock ) return err ; isock = sockfd_lookup ( ca . intr_sock , & err ) ; if ( ! isock ) { sockfd_put ( csock ) ; return err ; <S2SV_StartBug> } <S2SV_EndBug> err = hidp_connection_add ( & ca , csock , isock ) ; if ( ! err && copy_to_user ( argp , & ca , sizeof ( ca ) ) ) err = - EFAULT ; sockfd_put ( csock ) ; sockfd_put ( isock ) ; return err ; case HIDPCONNDEL : if ( ! capable ( CAP_NET_ADMIN ) ) return - EPERM ; if ( copy_from_user ( & cd , argp , sizeof ( cd ) ) ) return - EFAULT ; return hidp_connection_del ( & cd ) ; case HIDPGETCONNLIST : if ( copy_from_user ( & cl , argp , sizeof ( cl ) ) ) return - EFAULT ; if ( cl . cnum <= 0 ) return - EINVAL ; err = hidp_get_connlist ( & cl ) ; if ( ! err && copy_to_user ( argp , & cl , sizeof ( cl ) ) ) return - EFAULT ; return err ; case HIDPGETCONNINFO : if ( copy_from_user ( & ci , argp , sizeof ( ci ) ) ) return - EFAULT ; err = hidp_get_conninfo ( & ci ) ; if ( ! err && copy_to_user ( argp , & ci , sizeof ( ci ) ) ) return - EFAULT ; return err ; } return - EINVAL ; }
CWE-125 int SMB2_negotiate ( const unsigned int xid , struct cifs_ses * ses ) { struct smb_rqst rqst ; struct smb2_negotiate_req * req ; struct smb2_negotiate_rsp * rsp ; struct kvec iov [ 1 ] ; struct kvec rsp_iov ; int rc = 0 ; int resp_buftype ; struct TCP_Server_Info * server = ses -> server ; int blob_offset , blob_length ; char * security_blob ; int flags = CIFS_NEG_OP ; unsigned int total_len ; cifs_dbg ( FYI , "Negotiate<S2SV_blank>protocol\\n" ) ; if ( ! server ) { WARN ( 1 , "%s:<S2SV_blank>server<S2SV_blank>is<S2SV_blank>NULL!\\n" , __func__ ) ; return - EIO ; } rc = smb2_plain_req_init ( SMB2_NEGOTIATE , NULL , ( void * * ) & req , & total_len ) ; if ( rc ) return rc ; req -> sync_hdr . SessionId = 0 ; memset ( server -> preauth_sha_hash , 0 , SMB2_PREAUTH_HASH_SIZE ) ; memset ( ses -> preauth_sha_hash , 0 , SMB2_PREAUTH_HASH_SIZE ) ; if ( strcmp ( ses -> server -> vals -> version_string , SMB3ANY_VERSION_STRING ) == 0 ) { req -> Dialects [ 0 ] = cpu_to_le16 ( SMB30_PROT_ID ) ; req -> Dialects [ 1 ] = cpu_to_le16 ( SMB302_PROT_ID ) ; req -> DialectCount = cpu_to_le16 ( 2 ) ; total_len += 4 ; } else if ( strcmp ( ses -> server -> vals -> version_string , SMBDEFAULT_VERSION_STRING ) == 0 ) { req -> Dialects [ 0 ] = cpu_to_le16 ( SMB21_PROT_ID ) ; req -> Dialects [ 1 ] = cpu_to_le16 ( SMB30_PROT_ID ) ; req -> Dialects [ 2 ] = cpu_to_le16 ( SMB302_PROT_ID ) ; req -> Dialects [ 3 ] = cpu_to_le16 ( SMB311_PROT_ID ) ; req -> DialectCount = cpu_to_le16 ( 4 ) ; total_len += 8 ; } else { req -> Dialects [ 0 ] = cpu_to_le16 ( ses -> server -> vals -> protocol_id ) ; req -> DialectCount = cpu_to_le16 ( 1 ) ; total_len += 2 ; } if ( ses -> sign ) req -> SecurityMode = cpu_to_le16 ( SMB2_NEGOTIATE_SIGNING_REQUIRED ) ; else if ( global_secflags & CIFSSEC_MAY_SIGN ) req -> SecurityMode = cpu_to_le16 ( SMB2_NEGOTIATE_SIGNING_ENABLED ) ; else req -> SecurityMode = 0 ; req -> Capabilities = cpu_to_le32 ( ses -> server -> vals -> req_capabilities ) ; if ( ses -> server -> vals -> protocol_id == SMB20_PROT_ID ) memset ( req -> ClientGUID , 0 , SMB2_CLIENT_GUID_SIZE ) ; else { memcpy ( req -> ClientGUID , server -> client_guid , SMB2_CLIENT_GUID_SIZE ) ; if ( ( ses -> server -> vals -> protocol_id == SMB311_PROT_ID ) || ( strcmp ( ses -> server -> vals -> version_string , SMBDEFAULT_VERSION_STRING ) == 0 ) ) assemble_neg_contexts ( req , & total_len ) ; } iov [ 0 ] . iov_base = ( char * ) req ; iov [ 0 ] . iov_len = total_len ; memset ( & rqst , 0 , sizeof ( struct smb_rqst ) ) ; rqst . rq_iov = iov ; rqst . rq_nvec = 1 ; rc = cifs_send_recv ( xid , ses , & rqst , & resp_buftype , flags , & rsp_iov ) ; cifs_small_buf_release ( req ) ; rsp = ( struct smb2_negotiate_rsp * ) rsp_iov . iov_base ; if ( rc == - EOPNOTSUPP ) { cifs_dbg ( VFS , "Dialect<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>server.<S2SV_blank>Consider<S2SV_blank>" "specifying<S2SV_blank>vers=1.0<S2SV_blank>or<S2SV_blank>vers=2.0<S2SV_blank>on<S2SV_blank>mount<S2SV_blank>for<S2SV_blank>accessing" "<S2SV_blank>older<S2SV_blank>servers\\n" ) ; goto neg_exit ; } else if ( rc != 0 ) goto neg_exit ; if ( strcmp ( ses -> server -> vals -> version_string , SMB3ANY_VERSION_STRING ) == 0 ) { if ( rsp -> DialectRevision == cpu_to_le16 ( SMB20_PROT_ID ) ) { cifs_dbg ( VFS , "SMB2<S2SV_blank>dialect<S2SV_blank>returned<S2SV_blank>but<S2SV_blank>not<S2SV_blank>requested\\n" ) ; return - EIO ; } else if ( rsp -> DialectRevision == cpu_to_le16 ( SMB21_PROT_ID ) ) { cifs_dbg ( VFS , "SMB2.1<S2SV_blank>dialect<S2SV_blank>returned<S2SV_blank>but<S2SV_blank>not<S2SV_blank>requested\\n" ) ; return - EIO ; } } else if ( strcmp ( ses -> server -> vals -> version_string , SMBDEFAULT_VERSION_STRING ) == 0 ) { if ( rsp -> DialectRevision == cpu_to_le16 ( SMB20_PROT_ID ) ) { cifs_dbg ( VFS , "SMB2<S2SV_blank>dialect<S2SV_blank>returned<S2SV_blank>but<S2SV_blank>not<S2SV_blank>requested\\n" ) ; return - EIO ; } else if ( rsp -> DialectRevision == cpu_to_le16 ( SMB21_PROT_ID ) ) { ses -> server -> ops = & smb21_operations ; <S2SV_StartBug> } else if ( rsp -> DialectRevision == cpu_to_le16 ( SMB311_PROT_ID ) ) <S2SV_EndBug> <S2SV_StartBug> ses -> server -> ops = & smb311_operations ; <S2SV_EndBug> } else if ( le16_to_cpu ( rsp -> DialectRevision ) != ses -> server -> vals -> protocol_id ) { cifs_dbg ( VFS , "Illegal<S2SV_blank>0x%x<S2SV_blank>dialect<S2SV_blank>returned:<S2SV_blank>not<S2SV_blank>requested\\n" , le16_to_cpu ( rsp -> DialectRevision ) ) ; return - EIO ; } cifs_dbg ( FYI , "mode<S2SV_blank>0x%x\\n" , rsp -> SecurityMode ) ; if ( rsp -> DialectRevision == cpu_to_le16 ( SMB20_PROT_ID ) ) cifs_dbg ( FYI , "negotiated<S2SV_blank>smb2.0<S2SV_blank>dialect\\n" ) ; else if ( rsp -> DialectRevision == cpu_to_le16 ( SMB21_PROT_ID ) ) cifs_dbg ( FYI , "negotiated<S2SV_blank>smb2.1<S2SV_blank>dialect\\n" ) ; else if ( rsp -> DialectRevision == cpu_to_le16 ( SMB30_PROT_ID ) ) cifs_dbg ( FYI , "negotiated<S2SV_blank>smb3.0<S2SV_blank>dialect\\n" ) ; else if ( rsp -> DialectRevision == cpu_to_le16 ( SMB302_PROT_ID ) ) cifs_dbg ( FYI , "negotiated<S2SV_blank>smb3.02<S2SV_blank>dialect\\n" ) ; else if ( rsp -> DialectRevision == cpu_to_le16 ( SMB311_PROT_ID ) ) cifs_dbg ( FYI , "negotiated<S2SV_blank>smb3.1.1<S2SV_blank>dialect\\n" ) ; else { cifs_dbg ( VFS , "Illegal<S2SV_blank>dialect<S2SV_blank>returned<S2SV_blank>by<S2SV_blank>server<S2SV_blank>0x%x\\n" , le16_to_cpu ( rsp -> DialectRevision ) ) ; rc = - EIO ; goto neg_exit ; } server -> dialect = le16_to_cpu ( rsp -> DialectRevision ) ; memcpy ( server -> preauth_sha_hash , ses -> preauth_sha_hash , SMB2_PREAUTH_HASH_SIZE ) ; server -> negflavor = CIFS_NEGFLAVOR_EXTENDED ; server -> maxBuf = min_t ( unsigned int , le32_to_cpu ( rsp -> MaxTransactSize ) , SMB2_MAX_BUFFER_SIZE ) ; server -> max_read = le32_to_cpu ( rsp -> MaxReadSize ) ; server -> max_write = le32_to_cpu ( rsp -> MaxWriteSize ) ; server -> sec_mode = le16_to_cpu ( rsp -> SecurityMode ) ; if ( ( server -> sec_mode & SMB2_SEC_MODE_FLAGS_ALL ) != server -> sec_mode ) cifs_dbg ( FYI , "Server<S2SV_blank>returned<S2SV_blank>unexpected<S2SV_blank>security<S2SV_blank>mode<S2SV_blank>0x%x\\n" , server -> sec_mode ) ; server -> capabilities = le32_to_cpu ( rsp -> Capabilities ) ; server -> capabilities |= SMB2_NT_FIND | SMB2_LARGE_FILES ; security_blob = smb2_get_data_area_len ( & blob_offset , & blob_length , ( struct smb2_sync_hdr * ) rsp ) ; if ( blob_length == 0 ) { cifs_dbg ( FYI , "missing<S2SV_blank>security<S2SV_blank>blob<S2SV_blank>on<S2SV_blank>negprot\\n" ) ; server -> sec_ntlmssp = true ; } rc = cifs_enable_signing ( server , ses -> sign ) ; if ( rc ) goto neg_exit ; if ( blob_length ) { rc = decode_negTokenInit ( security_blob , blob_length , server ) ; if ( rc == 1 ) rc = 0 ; else if ( rc == 0 ) rc = - EIO ; } if ( rsp -> DialectRevision == cpu_to_le16 ( SMB311_PROT_ID ) ) { if ( rsp -> NegotiateContextCount ) rc = smb311_decode_neg_context ( rsp , server , rsp_iov . iov_len ) ; else cifs_dbg ( VFS , "Missing<S2SV_blank>expected<S2SV_blank>negotiate<S2SV_blank>contexts\\n" ) ; } neg_exit : free_rsp_buf ( resp_buftype , rsp ) ; return rc ; }
CWE-416 static void smp_task_done ( struct sas_task * task ) { <S2SV_StartBug> if ( ! del_timer ( & task -> slow_task -> timer ) ) <S2SV_EndBug> return ; complete ( & task -> slow_task -> completion ) ; }
CWE-416 static void smp_task_timedout ( struct timer_list * t ) { struct sas_task_slow * slow = from_timer ( slow , t , timer ) ; struct sas_task * task = slow -> task ; unsigned long flags ; spin_lock_irqsave ( & task -> task_state_lock , flags ) ; <S2SV_StartBug> if ( ! ( task -> task_state_flags & SAS_TASK_STATE_DONE ) ) <S2SV_EndBug> <S2SV_StartBug> task -> task_state_flags |= SAS_TASK_STATE_ABORTED ; <S2SV_EndBug> spin_unlock_irqrestore ( & task -> task_state_lock , flags ) ; complete ( & task -> slow_task -> completion ) ; <S2SV_StartBug> } <S2SV_EndBug>
CWE-476 int megasas_alloc_cmds ( struct megasas_instance * instance ) { int i ; int j ; u16 max_cmd ; struct megasas_cmd * cmd ; max_cmd = instance -> max_mfi_cmds ; instance -> cmd_list = kcalloc ( max_cmd , sizeof ( struct megasas_cmd * ) , GFP_KERNEL ) ; if ( ! instance -> cmd_list ) { dev_printk ( KERN_DEBUG , & instance -> pdev -> dev , "out<S2SV_blank>of<S2SV_blank>memory\\n" ) ; return - ENOMEM ; } memset ( instance -> cmd_list , 0 , sizeof ( struct megasas_cmd * ) * max_cmd ) ; for ( i = 0 ; i < max_cmd ; i ++ ) { instance -> cmd_list [ i ] = kmalloc ( sizeof ( struct megasas_cmd ) , GFP_KERNEL ) ; if ( ! instance -> cmd_list [ i ] ) { for ( j = 0 ; j < i ; j ++ ) kfree ( instance -> cmd_list [ j ] ) ; kfree ( instance -> cmd_list ) ; instance -> cmd_list = NULL ; return - ENOMEM ; } } for ( i = 0 ; i < max_cmd ; i ++ ) { cmd = instance -> cmd_list [ i ] ; memset ( cmd , 0 , sizeof ( struct megasas_cmd ) ) ; cmd -> index = i ; cmd -> scmd = NULL ; cmd -> instance = instance ; list_add_tail ( & cmd -> list , & instance -> cmd_pool ) ; } if ( megasas_create_frame_pool ( instance ) ) { dev_printk ( KERN_DEBUG , & instance -> pdev -> dev , "Error<S2SV_blank>creating<S2SV_blank>frame<S2SV_blank>DMA<S2SV_blank>pool\\n" ) ; megasas_free_cmds ( instance ) ; <S2SV_StartBug> } <S2SV_EndBug> return 0 ; }
CWE-125 void qedi_dbg_err ( struct qedi_dbg_ctx * qedi , const char * func , u32 line , const char * fmt , ... ) { va_list va ; <S2SV_StartBug> struct va_format vaf ; <S2SV_EndBug> char nfunc [ 32 ] ; memset ( nfunc , 0 , sizeof ( nfunc ) ) ; memcpy ( nfunc , func , sizeof ( nfunc ) - 1 ) ; va_start ( va , fmt ) ; vaf . fmt = fmt ; vaf . va = & va ; if ( likely ( qedi ) && likely ( qedi -> pdev ) ) pr_err ( "[%s]:[%s:%d]:%d:<S2SV_blank>%pV" , dev_name ( & qedi -> pdev -> dev ) , <S2SV_StartBug> nfunc , line , qedi -> host_no , & vaf ) ; <S2SV_EndBug> else <S2SV_StartBug> pr_err ( "[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV" , nfunc , line , & vaf ) ; <S2SV_EndBug> va_end ( va ) ; }
CWE-125 void qedi_dbg_info ( struct qedi_dbg_ctx * qedi , const char * func , u32 line , u32 level , const char * fmt , ... ) { va_list va ; <S2SV_StartBug> struct va_format vaf ; <S2SV_EndBug> char nfunc [ 32 ] ; memset ( nfunc , 0 , sizeof ( nfunc ) ) ; memcpy ( nfunc , func , sizeof ( nfunc ) - 1 ) ; va_start ( va , fmt ) ; vaf . fmt = fmt ; vaf . va = & va ; if ( ! ( qedi_dbg_log & level ) ) goto ret ; if ( likely ( qedi ) && likely ( qedi -> pdev ) ) pr_info ( "[%s]:[%s:%d]:%d:<S2SV_blank>%pV" , dev_name ( & qedi -> pdev -> dev ) , <S2SV_StartBug> nfunc , line , qedi -> host_no , & vaf ) ; <S2SV_EndBug> else <S2SV_StartBug> pr_info ( "[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV" , nfunc , line , & vaf ) ; <S2SV_EndBug> ret : va_end ( va ) ; }
CWE-125 void qedi_dbg_notice ( struct qedi_dbg_ctx * qedi , const char * func , u32 line , const char * fmt , ... ) { va_list va ; <S2SV_StartBug> struct va_format vaf ; <S2SV_EndBug> char nfunc [ 32 ] ; memset ( nfunc , 0 , sizeof ( nfunc ) ) ; memcpy ( nfunc , func , sizeof ( nfunc ) - 1 ) ; va_start ( va , fmt ) ; vaf . fmt = fmt ; vaf . va = & va ; if ( ! ( qedi_dbg_log & QEDI_LOG_NOTICE ) ) goto ret ; if ( likely ( qedi ) && likely ( qedi -> pdev ) ) pr_notice ( "[%s]:[%s:%d]:%d:<S2SV_blank>%pV" , <S2SV_StartBug> dev_name ( & qedi -> pdev -> dev ) , nfunc , line , <S2SV_EndBug> qedi -> host_no , & vaf ) ; else <S2SV_StartBug> pr_notice ( "[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV" , nfunc , line , & vaf ) ; <S2SV_EndBug> ret : va_end ( va ) ; }
CWE-125 void qedi_dbg_warn ( struct qedi_dbg_ctx * qedi , const char * func , u32 line , const char * fmt , ... ) { va_list va ; <S2SV_StartBug> struct va_format vaf ; <S2SV_EndBug> char nfunc [ 32 ] ; memset ( nfunc , 0 , sizeof ( nfunc ) ) ; memcpy ( nfunc , func , sizeof ( nfunc ) - 1 ) ; va_start ( va , fmt ) ; vaf . fmt = fmt ; vaf . va = & va ; if ( ! ( qedi_dbg_log & QEDI_LOG_WARN ) ) goto ret ; if ( likely ( qedi ) && likely ( qedi -> pdev ) ) pr_warn ( "[%s]:[%s:%d]:%d:<S2SV_blank>%pV" , dev_name ( & qedi -> pdev -> dev ) , <S2SV_StartBug> nfunc , line , qedi -> host_no , & vaf ) ; <S2SV_EndBug> else <S2SV_StartBug> pr_warn ( "[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV" , nfunc , line , & vaf ) ; <S2SV_EndBug> ret : va_end ( va ) ; }
CWE-129 int snmp_helper ( void * context , size_t hdrlen , unsigned char tag , const void * data , size_t datalen ) { struct snmp_ctx * ctx = ( struct snmp_ctx * ) context ; <S2SV_StartBug> __be32 * pdata = ( __be32 * ) data ; <S2SV_EndBug> if ( * pdata == ctx -> from ) { pr_debug ( "%s:<S2SV_blank>%pI4<S2SV_blank>to<S2SV_blank>%pI4\\n" , __func__ , ( void * ) & ctx -> from , ( void * ) & ctx -> to ) ; if ( * ctx -> check ) fast_csum ( ctx , ( unsigned char * ) data - ctx -> begin ) ; * pdata = ctx -> to ; } return 1 ; }
CWE-129 int snmp_version ( void * context , size_t hdrlen , unsigned char tag , const void * data , size_t datalen ) { <S2SV_StartBug> if ( * ( unsigned char * ) data > 1 ) <S2SV_EndBug> return - ENOTSUPP ; return 1 ; }
CWE-189 static int __dwc3_gadget_kick_transfer ( struct dwc3_ep * dep ) { struct dwc3_gadget_ep_cmd_params params ; struct dwc3_request * req ; int starting ; int ret ; u32 cmd ; if ( ! dwc3_calc_trbs_left ( dep ) ) return 0 ; starting = ! ( dep -> flags & DWC3_EP_BUSY ) ; dwc3_prepare_trbs ( dep ) ; req = next_request ( & dep -> started_list ) ; if ( ! req ) { dep -> flags |= DWC3_EP_PENDING_REQUEST ; return 0 ; } memset ( & params , 0 , sizeof ( params ) ) ; if ( starting ) { params . param0 = upper_32_bits ( req -> trb_dma ) ; params . param1 = lower_32_bits ( req -> trb_dma ) ; cmd = DWC3_DEPCMD_STARTTRANSFER ; if ( usb_endpoint_xfer_isoc ( dep -> endpoint . desc ) ) cmd |= DWC3_DEPCMD_PARAM ( dep -> frame_number ) ; } else { cmd = DWC3_DEPCMD_UPDATETRANSFER | DWC3_DEPCMD_PARAM ( dep -> resource_index ) ; } ret = dwc3_send_gadget_ep_cmd ( dep , cmd , & params ) ; if ( ret < 0 ) { if ( req -> trb ) memset ( req -> trb , 0 , sizeof ( struct dwc3_trb ) ) ; dep -> queued_requests -- ; <S2SV_StartBug> dwc3_gadget_giveback ( dep , req , ret ) ; <S2SV_EndBug> return ret ; } dep -> flags |= DWC3_EP_BUSY ; if ( starting ) { dep -> resource_index = dwc3_gadget_ep_get_transfer_index ( dep ) ; WARN_ON_ONCE ( ! dep -> resource_index ) ; } return 0 ; }
CWE-189 void dwc3_gadget_giveback ( struct dwc3_ep * dep , struct dwc3_request * req , int status ) { struct dwc3 * dwc = dep -> dwc ; <S2SV_StartBug> req -> started = false ; <S2SV_EndBug> list_del ( & req -> list ) ; req -> remaining = 0 ; if ( req -> request . status == - EINPROGRESS ) req -> request . status = status ; if ( req -> trb ) usb_gadget_unmap_request_by_dev ( dwc -> sysdev , & req -> request , req -> direction ) ; req -> trb = NULL ; trace_dwc3_gadget_giveback ( req ) ; spin_unlock ( & dwc -> lock ) ; usb_gadget_giveback_request ( & dep -> endpoint , & req -> request ) ; spin_lock ( & dwc -> lock ) ; <S2SV_StartBug> if ( dep -> number > 1 ) <S2SV_EndBug> pm_runtime_put ( dwc -> dev ) ; }
CWE-362 static void rds_tcp_kill_sock ( struct net * net ) { struct rds_tcp_connection * tc , * _tc ; LIST_HEAD ( tmp_list ) ; struct rds_tcp_net * rtn = net_generic ( net , rds_tcp_netid ) ; struct socket * lsock = rtn -> rds_tcp_listen_sock ; rtn -> rds_tcp_listen_sock = NULL ; rds_tcp_listen_stop ( lsock , & rtn -> rds_tcp_accept_w ) ; spin_lock_irq ( & rds_tcp_conn_lock ) ; list_for_each_entry_safe ( tc , _tc , & rds_tcp_conn_list , t_tcp_node ) { struct net * c_net = read_pnet ( & tc -> t_cpath -> cp_conn -> c_net ) ; <S2SV_StartBug> if ( net != c_net || ! tc -> t_sock ) <S2SV_EndBug> continue ; if ( ! list_has_conn ( & tmp_list , tc -> t_cpath -> cp_conn ) ) { list_move_tail ( & tc -> t_tcp_node , & tmp_list ) ; } else { list_del ( & tc -> t_tcp_node ) ; tc -> t_tcp_node_detached = true ; } } spin_unlock_irq ( & rds_tcp_conn_lock ) ; list_for_each_entry_safe ( tc , _tc , & tmp_list , t_tcp_node ) rds_conn_destroy ( tc -> t_cpath -> cp_conn ) ; }
CWE-399 int genl_register_family ( struct genl_family * family ) { int err , i ; int start = GENL_START_ALLOC , end = GENL_MAX_ID ; err = genl_validate_ops ( family ) ; if ( err ) return err ; genl_lock_all ( ) ; if ( genl_family_find_byname ( family -> name ) ) { err = - EEXIST ; goto errout_locked ; } if ( family == & genl_ctrl ) { start = end = GENL_ID_CTRL ; } else if ( strcmp ( family -> name , "pmcraid" ) == 0 ) { start = end = GENL_ID_PMCRAID ; } else if ( strcmp ( family -> name , "VFS_DQUOT" ) == 0 ) { start = end = GENL_ID_VFS_DQUOT ; } if ( family -> maxattr && ! family -> parallel_ops ) { family -> attrbuf = kmalloc_array ( family -> maxattr + 1 , sizeof ( struct nlattr * ) , GFP_KERNEL ) ; if ( family -> attrbuf == NULL ) { err = - ENOMEM ; goto errout_locked ; } } else family -> attrbuf = NULL ; family -> id = idr_alloc ( & genl_fam_idr , family , start , end + 1 , GFP_KERNEL ) ; if ( family -> id < 0 ) { err = family -> id ; <S2SV_StartBug> goto errout_locked ; <S2SV_EndBug> } err = genl_validate_assign_mc_groups ( family ) ; if ( err ) goto errout_remove ; genl_unlock_all ( ) ; genl_ctrl_event ( CTRL_CMD_NEWFAMILY , family , NULL , 0 ) ; for ( i = 0 ; i < family -> n_mcgrps ; i ++ ) genl_ctrl_event ( CTRL_CMD_NEWMCAST_GRP , family , & family -> mcgrps [ i ] , family -> mcgrp_offset + i ) ; return 0 ; errout_remove : idr_remove ( & genl_fam_idr , family -> id ) ; <S2SV_StartBug> kfree ( family -> attrbuf ) ; <S2SV_EndBug> errout_locked : genl_unlock_all ( ) ; return err ; }
CWE-362 static int kvm_ioctl_create_device ( struct kvm * kvm , struct kvm_create_device * cd ) { struct kvm_device_ops * ops = NULL ; struct kvm_device * dev ; bool test = cd -> flags & KVM_CREATE_DEVICE_TEST ; int ret ; if ( cd -> type >= ARRAY_SIZE ( kvm_device_ops_table ) ) return - ENODEV ; ops = kvm_device_ops_table [ cd -> type ] ; if ( ops == NULL ) return - ENODEV ; if ( test ) return 0 ; dev = kzalloc ( sizeof ( * dev ) , GFP_KERNEL ) ; if ( ! dev ) return - ENOMEM ; dev -> ops = ops ; dev -> kvm = kvm ; mutex_lock ( & kvm -> lock ) ; ret = ops -> create ( dev , cd -> type ) ; if ( ret < 0 ) { mutex_unlock ( & kvm -> lock ) ; kfree ( dev ) ; return ret ; } list_add ( & dev -> vm_node , & kvm -> devices ) ; mutex_unlock ( & kvm -> lock ) ; if ( ops -> init ) ops -> init ( dev ) ; <S2SV_StartBug> ret = anon_inode_getfd ( ops -> name , & kvm_device_fops , dev , O_RDWR | O_CLOEXEC ) ; <S2SV_EndBug> if ( ret < 0 ) { <S2SV_StartBug> mutex_lock ( & kvm -> lock ) ; <S2SV_EndBug> list_del ( & dev -> vm_node ) ; mutex_unlock ( & kvm -> lock ) ; ops -> destroy ( dev ) ; return ret ; } <S2SV_StartBug> kvm_get_kvm ( kvm ) ; <S2SV_EndBug> cd -> fd = ret ; return 0 ; }
CWE-189 static int adjust_scalar_min_max_vals ( struct bpf_verifier_env * env , struct bpf_insn * insn , struct bpf_reg_state * dst_reg , struct bpf_reg_state src_reg ) { struct bpf_reg_state * regs = cur_regs ( env ) ; u8 opcode = BPF_OP ( insn -> code ) ; bool src_known , dst_known ; s64 smin_val , smax_val ; u64 umin_val , umax_val ; <S2SV_StartBug> u64 insn_bitness = ( BPF_CLASS ( insn -> code ) == BPF_ALU64 ) ? 64 : 32 ; <S2SV_EndBug> if ( insn_bitness == 32 ) { coerce_reg_to_size ( dst_reg , 4 ) ; coerce_reg_to_size ( & src_reg , 4 ) ; } smin_val = src_reg . smin_value ; smax_val = src_reg . smax_value ; umin_val = src_reg . umin_value ; umax_val = src_reg . umax_value ; src_known = tnum_is_const ( src_reg . var_off ) ; dst_known = tnum_is_const ( dst_reg -> var_off ) ; if ( ( src_known && ( smin_val != smax_val || umin_val != umax_val ) ) || smin_val > smax_val || umin_val > umax_val ) { __mark_reg_unknown ( dst_reg ) ; return 0 ; } if ( ! src_known && opcode != BPF_ADD && opcode != BPF_SUB && opcode != BPF_AND ) { __mark_reg_unknown ( dst_reg ) ; return 0 ; } switch ( opcode ) { case BPF_ADD : <S2SV_StartBug> if ( signed_add_overflows ( dst_reg -> smin_value , smin_val ) || <S2SV_EndBug> signed_add_overflows ( dst_reg -> smax_value , smax_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value += smin_val ; dst_reg -> smax_value += smax_val ; } if ( dst_reg -> umin_value + umin_val < umin_val || dst_reg -> umax_value + umax_val < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value += umin_val ; dst_reg -> umax_value += umax_val ; } dst_reg -> var_off = tnum_add ( dst_reg -> var_off , src_reg . var_off ) ; break ; case BPF_SUB : <S2SV_StartBug> if ( signed_sub_overflows ( dst_reg -> smin_value , smax_val ) || <S2SV_EndBug> signed_sub_overflows ( dst_reg -> smax_value , smin_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value -= smax_val ; dst_reg -> smax_value -= smin_val ; } if ( dst_reg -> umin_value < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value -= umax_val ; dst_reg -> umax_value -= umin_val ; } dst_reg -> var_off = tnum_sub ( dst_reg -> var_off , src_reg . var_off ) ; break ; case BPF_MUL : dst_reg -> var_off = tnum_mul ( dst_reg -> var_off , src_reg . var_off ) ; if ( smin_val < 0 || dst_reg -> smin_value < 0 ) { __mark_reg_unbounded ( dst_reg ) ; __update_reg_bounds ( dst_reg ) ; break ; } if ( umax_val > U32_MAX || dst_reg -> umax_value > U32_MAX ) { __mark_reg_unbounded ( dst_reg ) ; __update_reg_bounds ( dst_reg ) ; break ; } dst_reg -> umin_value *= umin_val ; dst_reg -> umax_value *= umax_val ; if ( dst_reg -> umax_value > S64_MAX ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } break ; case BPF_AND : if ( src_known && dst_known ) { __mark_reg_known ( dst_reg , dst_reg -> var_off . value & src_reg . var_off . value ) ; break ; } dst_reg -> var_off = tnum_and ( dst_reg -> var_off , src_reg . var_off ) ; dst_reg -> umin_value = dst_reg -> var_off . value ; dst_reg -> umax_value = min ( dst_reg -> umax_value , umax_val ) ; if ( dst_reg -> smin_value < 0 || smin_val < 0 ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } __update_reg_bounds ( dst_reg ) ; break ; case BPF_OR : if ( src_known && dst_known ) { __mark_reg_known ( dst_reg , dst_reg -> var_off . value | src_reg . var_off . value ) ; break ; } dst_reg -> var_off = tnum_or ( dst_reg -> var_off , src_reg . var_off ) ; dst_reg -> umin_value = max ( dst_reg -> umin_value , umin_val ) ; dst_reg -> umax_value = dst_reg -> var_off . value | dst_reg -> var_off . mask ; if ( dst_reg -> smin_value < 0 || smin_val < 0 ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } __update_reg_bounds ( dst_reg ) ; break ; case BPF_LSH : if ( umax_val >= insn_bitness ) { mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; if ( dst_reg -> umax_value > 1ULL << ( 63 - umax_val ) ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value <<= umin_val ; dst_reg -> umax_value <<= umax_val ; } dst_reg -> var_off = tnum_lshift ( dst_reg -> var_off , umin_val ) ; __update_reg_bounds ( dst_reg ) ; break ; case BPF_RSH : if ( umax_val >= insn_bitness ) { mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; dst_reg -> var_off = tnum_rshift ( dst_reg -> var_off , umin_val ) ; dst_reg -> umin_value >>= umax_val ; dst_reg -> umax_value >>= umin_val ; __update_reg_bounds ( dst_reg ) ; break ; case BPF_ARSH : if ( umax_val >= insn_bitness ) { mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } dst_reg -> smin_value >>= umin_val ; dst_reg -> smax_value >>= umin_val ; dst_reg -> var_off = tnum_arshift ( dst_reg -> var_off , umin_val ) ; dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; __update_reg_bounds ( dst_reg ) ; break ; default : mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } if ( BPF_CLASS ( insn -> code ) != BPF_ALU64 ) { coerce_reg_to_size ( dst_reg , 4 ) ; } __reg_deduce_bounds ( dst_reg ) ; __reg_bound_offset ( dst_reg ) ; return 0 ; }
CWE-189 static int sanitize_ptr_alu ( struct bpf_verifier_env * env , struct bpf_insn * insn , const struct bpf_reg_state * ptr_reg , struct bpf_reg_state * dst_reg , bool off_is_neg ) { struct bpf_verifier_state * vstate = env -> cur_state ; struct bpf_insn_aux_data * aux = cur_aux ( env ) ; bool ptr_is_dst_reg = ptr_reg == dst_reg ; u8 opcode = BPF_OP ( insn -> code ) ; u32 alu_state , alu_limit ; struct bpf_reg_state tmp ; bool ret ; <S2SV_StartBug> if ( env -> allow_ptr_leaks || BPF_SRC ( insn -> code ) == BPF_K ) <S2SV_EndBug> return 0 ; if ( vstate -> speculative ) goto do_sim ; alu_state = off_is_neg ? BPF_ALU_NEG_VALUE : 0 ; alu_state |= ptr_is_dst_reg ? BPF_ALU_SANITIZE_SRC : BPF_ALU_SANITIZE_DST ; if ( retrieve_ptr_limit ( ptr_reg , & alu_limit , opcode , off_is_neg ) ) return 0 ; <S2SV_StartBug> if ( aux -> alu_state && <S2SV_EndBug> ( aux -> alu_state != alu_state || aux -> alu_limit != alu_limit ) ) <S2SV_StartBug> return - EACCES ; <S2SV_EndBug> aux -> alu_state = alu_state ; aux -> alu_limit = alu_limit ; do_sim : if ( ! ptr_is_dst_reg ) { tmp = * dst_reg ; * dst_reg = * ptr_reg ; } ret = push_stack ( env , env -> insn_idx + 1 , env -> insn_idx , true ) ; if ( ! ptr_is_dst_reg ) * dst_reg = tmp ; return ! ret ? - EFAULT : 0 ; }
CWE-125 static int set_geometry ( unsigned int cmd , struct floppy_struct * g , int drive , int type , struct block_device * bdev ) { int cnt ; <S2SV_StartBug> if ( g -> sect <= 0 || <S2SV_EndBug> <S2SV_StartBug> g -> head <= 0 || <S2SV_EndBug> ( unsigned char ) ( ( g -> sect << 2 ) >> FD_SIZECODE ( g ) ) == 0 || g -> track <= 0 || g -> track > UDP -> tracks >> STRETCH ( g ) || ( g -> stretch & ~ ( FD_STRETCH | FD_SWAPSIDES | FD_SECTBASEMASK ) ) != 0 ) return - EINVAL ; if ( type ) { if ( ! capable ( CAP_SYS_ADMIN ) ) return - EPERM ; mutex_lock ( & open_lock ) ; if ( lock_fdc ( drive ) ) { mutex_unlock ( & open_lock ) ; return - EINTR ; } floppy_type [ type ] = * g ; floppy_type [ type ] . name = "user<S2SV_blank>format" ; for ( cnt = type << 2 ; cnt < ( type << 2 ) + 4 ; cnt ++ ) floppy_sizes [ cnt ] = floppy_sizes [ cnt + 0x80 ] = floppy_type [ type ] . size + 1 ; process_fd_request ( ) ; for ( cnt = 0 ; cnt < N_DRIVE ; cnt ++ ) { struct block_device * bdev = opened_bdev [ cnt ] ; if ( ! bdev || ITYPE ( drive_state [ cnt ] . fd_device ) != type ) continue ; __invalidate_device ( bdev , true ) ; } mutex_unlock ( & open_lock ) ; } else { int oldStretch ; if ( lock_fdc ( drive ) ) return - EINTR ; if ( cmd != FDDEFPRM ) { if ( poll_drive ( true , FD_RAW_NEED_DISK ) == - EINTR ) return - EINTR ; } oldStretch = g -> stretch ; user_params [ drive ] = * g ; if ( buffer_drive == drive ) SUPBOUND ( buffer_max , user_params [ drive ] . sect ) ; current_type [ drive ] = & user_params [ drive ] ; floppy_sizes [ drive ] = user_params [ drive ] . size ; if ( cmd == FDDEFPRM ) DRS -> keep_data = - 1 ; else DRS -> keep_data = 1 ; if ( DRS -> maxblock > user_params [ drive ] . sect || DRS -> maxtrack || ( ( user_params [ drive ] . sect ^ oldStretch ) & ( FD_SWAPSIDES | FD_SECTBASEMASK ) ) ) invalidate_drive ( bdev ) ; else process_fd_request ( ) ; } return 0 ; }
CWE-362 <S2SV_StartBug> static struct desc_struct * get_desc ( unsigned short sel ) <S2SV_EndBug> { struct desc_ptr gdt_desc = { 0 , 0 } ; unsigned long desc_base ; # ifdef CONFIG_MODIFY_LDT_SYSCALL if ( ( sel & SEGMENT_TI_MASK ) == SEGMENT_LDT ) { <S2SV_StartBug> struct desc_struct * desc = NULL ; <S2SV_EndBug> struct ldt_struct * ldt ; sel >>= 3 ; mutex_lock ( & current -> active_mm -> context . lock ) ; ldt = current -> active_mm -> context . ldt ; <S2SV_StartBug> if ( ldt && sel < ldt -> nr_entries ) <S2SV_EndBug> <S2SV_StartBug> desc = & ldt -> entries [ sel ] ; <S2SV_EndBug> mutex_unlock ( & current -> active_mm -> context . lock ) ; <S2SV_StartBug> return desc ; <S2SV_EndBug> } # endif native_store_gdt ( & gdt_desc ) ; desc_base = sel & ~ ( SEGMENT_RPL_MASK | SEGMENT_TI_MASK ) ; if ( desc_base > gdt_desc . size ) <S2SV_StartBug> return NULL ; <S2SV_EndBug> return ( struct desc_struct * ) ( gdt_desc . address + desc_base ) ; <S2SV_StartBug> } <S2SV_EndBug>
CWE-362 static unsigned long get_seg_limit ( struct pt_regs * regs , int seg_reg_idx ) { <S2SV_StartBug> struct desc_struct * desc ; <S2SV_EndBug> unsigned long limit ; short sel ; sel = get_segment_selector ( regs , seg_reg_idx ) ; if ( sel < 0 ) return 0 ; if ( user_64bit_mode ( regs ) || v8086_mode ( regs ) ) return - 1L ; if ( ! sel ) return 0 ; <S2SV_StartBug> desc = get_desc ( sel ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! desc ) <S2SV_EndBug> return 0 ; <S2SV_StartBug> limit = get_desc_limit ( desc ) ; <S2SV_EndBug> <S2SV_StartBug> if ( desc -> g ) <S2SV_EndBug> limit = ( limit << 12 ) + 0xfff ; return limit ; }
CWE-362 int insn_get_code_seg_params ( struct pt_regs * regs ) { <S2SV_StartBug> struct desc_struct * desc ; <S2SV_EndBug> short sel ; if ( v8086_mode ( regs ) ) return INSN_CODE_SEG_PARAMS ( 2 , 2 ) ; sel = get_segment_selector ( regs , INAT_SEG_REG_CS ) ; if ( sel < 0 ) return sel ; <S2SV_StartBug> desc = get_desc ( sel ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! desc ) <S2SV_EndBug> return - EINVAL ; <S2SV_StartBug> if ( ! ( desc -> type & BIT ( 3 ) ) ) <S2SV_EndBug> return - EINVAL ; <S2SV_StartBug> switch ( ( desc -> l << 1 ) | desc -> d ) { <S2SV_EndBug> case 0 : return INSN_CODE_SEG_PARAMS ( 2 , 2 ) ; case 1 : return INSN_CODE_SEG_PARAMS ( 4 , 4 ) ; case 2 : return INSN_CODE_SEG_PARAMS ( 4 , 8 ) ; case 3 : default : return - EINVAL ; } }
CWE-362 unsigned long insn_get_seg_base ( struct pt_regs * regs , int seg_reg_idx ) { <S2SV_StartBug> struct desc_struct * desc ; <S2SV_EndBug> short sel ; sel = get_segment_selector ( regs , seg_reg_idx ) ; if ( sel < 0 ) return - 1L ; if ( v8086_mode ( regs ) ) return ( unsigned long ) ( sel << 4 ) ; if ( user_64bit_mode ( regs ) ) { unsigned long base ; if ( seg_reg_idx == INAT_SEG_REG_FS ) rdmsrl ( MSR_FS_BASE , base ) ; else if ( seg_reg_idx == INAT_SEG_REG_GS ) rdmsrl ( MSR_KERNEL_GS_BASE , base ) ; else base = 0 ; return base ; } if ( ! sel ) return - 1L ; <S2SV_StartBug> desc = get_desc ( sel ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! desc ) <S2SV_EndBug> return - 1L ; <S2SV_StartBug> return get_desc_base ( desc ) ; <S2SV_EndBug> }
CWE-200 void __ip_select_ident ( struct net * net , struct iphdr * iph , int segs ) { <S2SV_StartBug> static u32 ip_idents_hashrnd __read_mostly ; <S2SV_EndBug> u32 hash , id ; <S2SV_StartBug> net_get_random_once ( & ip_idents_hashrnd , sizeof ( ip_idents_hashrnd ) ) ; <S2SV_EndBug> <S2SV_StartBug> hash = jhash_3words ( ( __force u32 ) iph -> daddr , <S2SV_EndBug> ( __force u32 ) iph -> saddr , <S2SV_StartBug> iph -> protocol ^ net_hash_mix ( net ) , <S2SV_EndBug> ip_idents_hashrnd ) ; id = ip_idents_reserve ( hash , segs ) ; iph -> id = htons ( id ) ; }
CWE-200 <S2SV_StartBug> static u32 __ipv6_select_ident ( struct net * net , u32 hashrnd , <S2SV_EndBug> const struct in6_addr * dst , const struct in6_addr * src ) { <S2SV_StartBug> u32 hash , id ; <S2SV_EndBug> <S2SV_StartBug> hash = __ipv6_addr_jhash ( dst , hashrnd ) ; <S2SV_EndBug> <S2SV_StartBug> hash = __ipv6_addr_jhash ( src , hash ) ; <S2SV_EndBug> hash ^= net_hash_mix ( net ) ; id = ip_idents_reserve ( hash , 1 ) ; if ( unlikely ( ! id ) ) id = 1 << 31 ; return id ; }
CWE-200 __be32 ipv6_proxy_select_ident ( struct net * net , struct sk_buff * skb ) { <S2SV_StartBug> static u32 ip6_proxy_idents_hashrnd __read_mostly ; <S2SV_EndBug> struct in6_addr buf [ 2 ] ; struct in6_addr * addrs ; u32 id ; addrs = skb_header_pointer ( skb , skb_network_offset ( skb ) + offsetof ( struct ipv6hdr , saddr ) , sizeof ( buf ) , buf ) ; if ( ! addrs ) return 0 ; <S2SV_StartBug> net_get_random_once ( & ip6_proxy_idents_hashrnd , <S2SV_EndBug> sizeof ( ip6_proxy_idents_hashrnd ) ) ; <S2SV_StartBug> id = __ipv6_select_ident ( net , ip6_proxy_idents_hashrnd , <S2SV_EndBug> & addrs [ 1 ] , & addrs [ 0 ] ) ; return htonl ( id ) ; }
CWE-200 __be32 ipv6_select_ident ( struct net * net , const struct in6_addr * daddr , const struct in6_addr * saddr ) { <S2SV_StartBug> static u32 ip6_idents_hashrnd __read_mostly ; <S2SV_EndBug> u32 id ; net_get_random_once ( & ip6_idents_hashrnd , sizeof ( ip6_idents_hashrnd ) ) ; <S2SV_StartBug> id = __ipv6_select_ident ( net , ip6_idents_hashrnd , daddr , saddr ) ; <S2SV_EndBug> return htonl ( id ) ; }
CWE-665 static struct ib_ucontext * hns_roce_alloc_ucontext ( struct ib_device * ib_dev , struct ib_udata * udata ) { int ret = 0 ; struct hns_roce_ucontext * context ; <S2SV_StartBug> struct hns_roce_ib_alloc_ucontext_resp resp ; <S2SV_EndBug> struct hns_roce_dev * hr_dev = to_hr_dev ( ib_dev ) ; resp . qp_tab_size = hr_dev -> caps . num_qps ; context = kmalloc ( sizeof ( * context ) , GFP_KERNEL ) ; if ( ! context ) return ERR_PTR ( - ENOMEM ) ; ret = hns_roce_uar_alloc ( hr_dev , & context -> uar ) ; if ( ret ) goto error_fail_uar_alloc ; if ( hr_dev -> caps . flags & HNS_ROCE_CAP_FLAG_RECORD_DB ) { INIT_LIST_HEAD ( & context -> page_list ) ; mutex_init ( & context -> page_mutex ) ; } ret = ib_copy_to_udata ( udata , & resp , sizeof ( resp ) ) ; if ( ret ) goto error_fail_copy_to_udata ; return & context -> ibucontext ; error_fail_copy_to_udata : hns_roce_uar_free ( hr_dev , & context -> uar ) ; error_fail_uar_alloc : kfree ( context ) ; return ERR_PTR ( ret ) ; }
CWE-476 static int pcd_detect ( void ) { char id [ 18 ] ; int k , unit ; struct pcd_unit * cd ; printk ( "%s:<S2SV_blank>%s<S2SV_blank>version<S2SV_blank>%s,<S2SV_blank>major<S2SV_blank>%d,<S2SV_blank>nice<S2SV_blank>%d\\n" , name , name , PCD_VERSION , major , nice ) ; par_drv = pi_register_driver ( name ) ; if ( ! par_drv ) { pr_err ( "failed<S2SV_blank>to<S2SV_blank>register<S2SV_blank>%s<S2SV_blank>driver\\n" , name ) ; return - 1 ; } k = 0 ; if ( pcd_drive_count == 0 ) { cd = pcd ; if ( pi_init ( cd -> pi , 1 , - 1 , - 1 , - 1 , - 1 , - 1 , pcd_buffer , PI_PCD , verbose , cd -> name ) ) { if ( ! pcd_probe ( cd , - 1 , id ) && cd -> disk ) { cd -> present = 1 ; k ++ ; } else pi_release ( cd -> pi ) ; } } else { for ( unit = 0 , cd = pcd ; unit < PCD_UNITS ; unit ++ , cd ++ ) { int * conf = * drives [ unit ] ; if ( ! conf [ D_PRT ] ) continue ; if ( ! pi_init ( cd -> pi , 0 , conf [ D_PRT ] , conf [ D_MOD ] , conf [ D_UNI ] , conf [ D_PRO ] , conf [ D_DLY ] , pcd_buffer , PI_PCD , verbose , cd -> name ) ) continue ; if ( ! pcd_probe ( cd , conf [ D_SLV ] , id ) && cd -> disk ) { cd -> present = 1 ; k ++ ; } else pi_release ( cd -> pi ) ; } } if ( k ) return 0 ; printk ( "%s:<S2SV_blank>No<S2SV_blank>CD-ROM<S2SV_blank>drive<S2SV_blank>found\\n" , name ) ; for ( unit = 0 , cd = pcd ; unit < PCD_UNITS ; unit ++ , cd ++ ) { <S2SV_StartBug> blk_cleanup_queue ( cd -> disk -> queue ) ; <S2SV_EndBug> cd -> disk -> queue = NULL ; blk_mq_free_tag_set ( & cd -> tag_set ) ; put_disk ( cd -> disk ) ; } pi_unregister_driver ( par_drv ) ; return - 1 ; }
CWE-476 static void pcd_init_units ( void ) { struct pcd_unit * cd ; int unit ; pcd_drive_count = 0 ; for ( unit = 0 , cd = pcd ; unit < PCD_UNITS ; unit ++ , cd ++ ) { struct gendisk * disk = alloc_disk ( 1 ) ; if ( ! disk ) continue ; disk -> queue = blk_mq_init_sq_queue ( & cd -> tag_set , & pcd_mq_ops , 1 , BLK_MQ_F_SHOULD_MERGE ) ; if ( IS_ERR ( disk -> queue ) ) { <S2SV_StartBug> disk -> queue = NULL ; <S2SV_EndBug> continue ; } INIT_LIST_HEAD ( & cd -> rq_list ) ; disk -> queue -> queuedata = cd ; blk_queue_bounce_limit ( disk -> queue , BLK_BOUNCE_HIGH ) ; cd -> disk = disk ; cd -> pi = & cd -> pia ; cd -> present = 0 ; cd -> last_sense = 0 ; cd -> changed = 1 ; cd -> drive = ( * drives [ unit ] ) [ D_SLV ] ; if ( ( * drives [ unit ] ) [ D_PRT ] ) pcd_drive_count ++ ; cd -> name = & cd -> info . name [ 0 ] ; snprintf ( cd -> name , sizeof ( cd -> info . name ) , "%s%d" , name , unit ) ; cd -> info . ops = & pcd_dops ; cd -> info . handle = cd ; cd -> info . speed = 0 ; cd -> info . capacity = 1 ; cd -> info . mask = 0 ; disk -> major = major ; disk -> first_minor = unit ; strcpy ( disk -> disk_name , cd -> name ) ; disk -> fops = & pcd_bdops ; disk -> flags = GENHD_FL_BLOCK_EVENTS_ON_EXCL_WRITE ; } }
CWE-369 static int set_geometry ( unsigned int cmd , struct floppy_struct * g , int drive , int type , struct block_device * bdev ) { int cnt ; if ( g -> sect <= 0 || <S2SV_StartBug> g -> head <= 0 || <S2SV_EndBug> g -> track <= 0 || g -> track > UDP -> tracks >> STRETCH ( g ) || ( g -> stretch & ~ ( FD_STRETCH | FD_SWAPSIDES | FD_SECTBASEMASK ) ) != 0 ) return - EINVAL ; if ( type ) { if ( ! capable ( CAP_SYS_ADMIN ) ) return - EPERM ; mutex_lock ( & open_lock ) ; if ( lock_fdc ( drive ) ) { mutex_unlock ( & open_lock ) ; return - EINTR ; } floppy_type [ type ] = * g ; floppy_type [ type ] . name = "user<S2SV_blank>format" ; for ( cnt = type << 2 ; cnt < ( type << 2 ) + 4 ; cnt ++ ) floppy_sizes [ cnt ] = floppy_sizes [ cnt + 0x80 ] = floppy_type [ type ] . size + 1 ; process_fd_request ( ) ; for ( cnt = 0 ; cnt < N_DRIVE ; cnt ++ ) { struct block_device * bdev = opened_bdev [ cnt ] ; if ( ! bdev || ITYPE ( drive_state [ cnt ] . fd_device ) != type ) continue ; __invalidate_device ( bdev , true ) ; } mutex_unlock ( & open_lock ) ; } else { int oldStretch ; if ( lock_fdc ( drive ) ) return - EINTR ; if ( cmd != FDDEFPRM ) { if ( poll_drive ( true , FD_RAW_NEED_DISK ) == - EINTR ) return - EINTR ; } oldStretch = g -> stretch ; user_params [ drive ] = * g ; if ( buffer_drive == drive ) SUPBOUND ( buffer_max , user_params [ drive ] . sect ) ; current_type [ drive ] = & user_params [ drive ] ; floppy_sizes [ drive ] = user_params [ drive ] . size ; if ( cmd == FDDEFPRM ) DRS -> keep_data = - 1 ; else DRS -> keep_data = 1 ; if ( DRS -> maxblock > user_params [ drive ] . sect || DRS -> maxtrack || ( ( user_params [ drive ] . sect ^ oldStretch ) & ( FD_SWAPSIDES | FD_SECTBASEMASK ) ) ) invalidate_drive ( bdev ) ; else process_fd_request ( ) ; } return 0 ; }
CWE-369 static void setup_format_params ( int track ) { int n ; int il ; int count ; int head_shift ; int track_shift ; struct fparm { unsigned char track , head , sect , size ; } * here = ( struct fparm * ) floppy_track_buffer ; raw_cmd = & default_raw_cmd ; raw_cmd -> track = track ; raw_cmd -> flags = ( FD_RAW_WRITE | FD_RAW_INTR | FD_RAW_SPIN | FD_RAW_NEED_DISK | FD_RAW_NEED_SEEK ) ; raw_cmd -> rate = _floppy -> rate & 0x43 ; raw_cmd -> cmd_count = NR_F ; COMMAND = FM_MODE ( _floppy , FD_FORMAT ) ; DR_SELECT = UNIT ( current_drive ) + PH_HEAD ( _floppy , format_req . head ) ; F_SIZECODE = FD_SIZECODE ( _floppy ) ; F_SECT_PER_TRACK = _floppy -> sect << 2 >> F_SIZECODE ; F_GAP = _floppy -> fmt_gap ; F_FILL = FD_FILL_BYTE ; raw_cmd -> kernel_data = floppy_track_buffer ; raw_cmd -> length = 4 * F_SECT_PER_TRACK ; <S2SV_StartBug> head_shift = ( F_SECT_PER_TRACK + 5 ) / 6 ; <S2SV_EndBug> track_shift = 2 * head_shift + 3 ; n = ( track_shift * format_req . track + head_shift * format_req . head ) % F_SECT_PER_TRACK ; il = 1 ; if ( _floppy -> fmt_gap < 0x22 ) il ++ ; for ( count = 0 ; count < F_SECT_PER_TRACK ; ++ count ) { here [ count ] . track = format_req . track ; here [ count ] . head = format_req . head ; here [ count ] . sect = 0 ; here [ count ] . size = F_SIZECODE ; } for ( count = 1 ; count <= F_SECT_PER_TRACK ; ++ count ) { here [ n ] . sect = count ; n = ( n + il ) % F_SECT_PER_TRACK ; if ( here [ n ] . sect ) { ++ n ; if ( n >= F_SECT_PER_TRACK ) { n -= F_SECT_PER_TRACK ; while ( here [ n ] . sect ) ++ n ; } } } if ( _floppy -> stretch & FD_SECTBASEMASK ) { for ( count = 0 ; count < F_SECT_PER_TRACK ; count ++ ) here [ count ] . sect += FD_SECTBASE ( _floppy ) - 1 ; } }
CWE-119 static void ssdp_recv ( int sd ) { ssize_t len ; struct sockaddr sa ; socklen_t salen ; <S2SV_StartBug> char buf [ MAX_PKT_SIZE ] ; <S2SV_EndBug> memset ( buf , 0 , sizeof ( buf ) ) ; <S2SV_StartBug> len = recvfrom ( sd , buf , sizeof ( buf ) , MSG_DONTWAIT , & sa , & salen ) ; <S2SV_EndBug> if ( len > 0 ) { <S2SV_StartBug> buf [ len ] = 0 ; <S2SV_EndBug> if ( sa . sa_family != AF_INET ) return ; if ( strstr ( buf , "M-SEARCH<S2SV_blank>*" ) ) { size_t i ; char * ptr , * type ; struct ifsock * ifs ; struct sockaddr_in * sin = ( struct sockaddr_in * ) & sa ; ifs = find_outbound ( & sa ) ; if ( ! ifs ) { logit ( LOG_DEBUG , "No<S2SV_blank>matching<S2SV_blank>socket<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s" , inet_ntoa ( sin -> sin_addr ) ) ; return ; } logit ( LOG_DEBUG , "Matching<S2SV_blank>socket<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s" , inet_ntoa ( sin -> sin_addr ) ) ; type = strcasestr ( buf , "\\r\\nST:" ) ; if ( ! type ) { logit ( LOG_DEBUG , "No<S2SV_blank>Search<S2SV_blank>Type<S2SV_blank>(ST:)<S2SV_blank>found<S2SV_blank>in<S2SV_blank>M-SEARCH<S2SV_blank>*,<S2SV_blank>assuming<S2SV_blank>" SSDP_ST_ALL ) ; type = SSDP_ST_ALL ; send_message ( ifs , type , & sa ) ; return ; } type = strchr ( type , ':' ) ; if ( ! type ) return ; type ++ ; while ( isspace ( * type ) ) type ++ ; ptr = strstr ( type , "\\r\\n" ) ; if ( ! ptr ) return ; * ptr = 0 ; for ( i = 0 ; supported_types [ i ] ; i ++ ) { if ( ! strcmp ( supported_types [ i ] , type ) ) { logit ( LOG_DEBUG , "M-SEARCH<S2SV_blank>*<S2SV_blank>ST:<S2SV_blank>%s<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>port<S2SV_blank>%d" , type , inet_ntoa ( sin -> sin_addr ) , ntohs ( sin -> sin_port ) ) ; send_message ( ifs , type , & sa ) ; return ; } } logit ( LOG_DEBUG , "M-SEARCH<S2SV_blank>*<S2SV_blank>for<S2SV_blank>unsupported<S2SV_blank>ST:<S2SV_blank>%s<S2SV_blank>from<S2SV_blank>%s" , type , inet_ntoa ( sin -> sin_addr ) ) ; } } }
CWE-190 void opj_get_all_encoding_parameters ( const opj_image_t * p_image , const opj_cp_t * p_cp , OPJ_UINT32 tileno , OPJ_INT32 * p_tx0 , OPJ_INT32 * p_tx1 , OPJ_INT32 * p_ty0 , OPJ_INT32 * p_ty1 , OPJ_UINT32 * p_dx_min , OPJ_UINT32 * p_dy_min , OPJ_UINT32 * p_max_prec , OPJ_UINT32 * p_max_res , OPJ_UINT32 * * p_resolutions ) { OPJ_UINT32 compno , resno ; const opj_tcp_t * tcp = 00 ; const opj_tccp_t * l_tccp = 00 ; const opj_image_comp_t * l_img_comp = 00 ; OPJ_UINT32 * lResolutionPtr ; OPJ_UINT32 p , q ; assert ( p_cp != 00 ) ; assert ( p_image != 00 ) ; assert ( tileno < p_cp -> tw * p_cp -> th ) ; tcp = & p_cp -> tcps [ tileno ] ; l_tccp = tcp -> tccps ; l_img_comp = p_image -> comps ; p = tileno % p_cp -> tw ; q = tileno / p_cp -> tw ; <S2SV_StartBug> * p_tx0 = opj_int_max ( ( OPJ_INT32 ) ( p_cp -> tx0 + p * p_cp -> tdx ) , ( OPJ_INT32 ) p_image -> x0 ) ; <S2SV_EndBug> <S2SV_StartBug> * p_tx1 = opj_int_min ( ( OPJ_INT32 ) ( p_cp -> tx0 + ( p + 1 ) * p_cp -> tdx ) , ( OPJ_INT32 ) p_image -> x1 ) ; <S2SV_EndBug> <S2SV_StartBug> * p_ty0 = opj_int_max ( ( OPJ_INT32 ) ( p_cp -> ty0 + q * p_cp -> tdy ) , ( OPJ_INT32 ) p_image -> y0 ) ; <S2SV_EndBug> <S2SV_StartBug> * p_ty1 = opj_int_min ( ( OPJ_INT32 ) ( p_cp -> ty0 + ( q + 1 ) * p_cp -> tdy ) , ( OPJ_INT32 ) p_image -> y1 ) ; <S2SV_EndBug> * p_max_prec = 0 ; * p_max_res = 0 ; * p_dx_min = 0x7fffffff ; * p_dy_min = 0x7fffffff ; for ( compno = 0 ; compno < p_image -> numcomps ; ++ compno ) { OPJ_UINT32 l_level_no ; OPJ_INT32 l_rx0 , l_ry0 , l_rx1 , l_ry1 ; OPJ_INT32 l_px0 , l_py0 , l_px1 , py1 ; OPJ_UINT32 l_product ; OPJ_INT32 l_tcx0 , l_tcy0 , l_tcx1 , l_tcy1 ; OPJ_UINT32 l_pdx , l_pdy , l_pw , l_ph ; lResolutionPtr = p_resolutions [ compno ] ; l_tcx0 = opj_int_ceildiv ( * p_tx0 , ( OPJ_INT32 ) l_img_comp -> dx ) ; l_tcy0 = opj_int_ceildiv ( * p_ty0 , ( OPJ_INT32 ) l_img_comp -> dy ) ; l_tcx1 = opj_int_ceildiv ( * p_tx1 , ( OPJ_INT32 ) l_img_comp -> dx ) ; l_tcy1 = opj_int_ceildiv ( * p_ty1 , ( OPJ_INT32 ) l_img_comp -> dy ) ; if ( l_tccp -> numresolutions > * p_max_res ) { * p_max_res = l_tccp -> numresolutions ; } l_level_no = l_tccp -> numresolutions - 1 ; for ( resno = 0 ; resno < l_tccp -> numresolutions ; ++ resno ) { OPJ_UINT32 l_dx , l_dy ; l_pdx = l_tccp -> prcw [ resno ] ; l_pdy = l_tccp -> prch [ resno ] ; * lResolutionPtr ++ = l_pdx ; * lResolutionPtr ++ = l_pdy ; l_dx = l_img_comp -> dx * ( 1u << ( l_pdx + l_level_no ) ) ; l_dy = l_img_comp -> dy * ( 1u << ( l_pdy + l_level_no ) ) ; * p_dx_min = ( OPJ_UINT32 ) opj_int_min ( ( OPJ_INT32 ) * p_dx_min , ( OPJ_INT32 ) l_dx ) ; * p_dy_min = ( OPJ_UINT32 ) opj_int_min ( ( OPJ_INT32 ) * p_dy_min , ( OPJ_INT32 ) l_dy ) ; l_rx0 = opj_int_ceildivpow2 ( l_tcx0 , ( OPJ_INT32 ) l_level_no ) ; l_ry0 = opj_int_ceildivpow2 ( l_tcy0 , ( OPJ_INT32 ) l_level_no ) ; l_rx1 = opj_int_ceildivpow2 ( l_tcx1 , ( OPJ_INT32 ) l_level_no ) ; l_ry1 = opj_int_ceildivpow2 ( l_tcy1 , ( OPJ_INT32 ) l_level_no ) ; l_px0 = opj_int_floordivpow2 ( l_rx0 , ( OPJ_INT32 ) l_pdx ) << l_pdx ; l_py0 = opj_int_floordivpow2 ( l_ry0 , ( OPJ_INT32 ) l_pdy ) << l_pdy ; l_px1 = opj_int_ceildivpow2 ( l_rx1 , ( OPJ_INT32 ) l_pdx ) << l_pdx ; py1 = opj_int_ceildivpow2 ( l_ry1 , ( OPJ_INT32 ) l_pdy ) << l_pdy ; l_pw = ( l_rx0 == l_rx1 ) ? 0 : ( OPJ_UINT32 ) ( ( l_px1 - l_px0 ) >> l_pdx ) ; l_ph = ( l_ry0 == l_ry1 ) ? 0 : ( OPJ_UINT32 ) ( ( py1 - l_py0 ) >> l_pdy ) ; * lResolutionPtr ++ = l_pw ; * lResolutionPtr ++ = l_ph ; l_product = l_pw * l_ph ; if ( l_product > * p_max_prec ) { * p_max_prec = l_product ; } -- l_level_no ; } ++ l_tccp ; ++ l_img_comp ; } }
CWE-400 static OPJ_BOOL bmp_read_rle8_data ( FILE * IN , OPJ_UINT8 * pData , OPJ_UINT32 stride , OPJ_UINT32 width , OPJ_UINT32 height ) { <S2SV_StartBug> OPJ_UINT32 x , y ; <S2SV_EndBug> OPJ_UINT8 * pix ; const OPJ_UINT8 * beyond ; beyond = pData + stride * height ; pix = pData ; <S2SV_StartBug> x = y = 0U ; <S2SV_EndBug> while ( y < height ) { int c = getc ( IN ) ; if ( c == EOF ) { return OPJ_FALSE ; } if ( c ) { int j , c1_int ; OPJ_UINT8 c1 ; c1_int = getc ( IN ) ; if ( c1_int == EOF ) { return OPJ_FALSE ; } c1 = ( OPJ_UINT8 ) c1_int ; for ( j = 0 ; ( j < c ) && ( x < width ) && ( ( OPJ_SIZE_T ) pix < ( OPJ_SIZE_T ) beyond ) ; j ++ , x ++ , pix ++ ) { <S2SV_StartBug> * pix = c1 ; <S2SV_EndBug> } } else { c = getc ( IN ) ; if ( c == EOF ) { return OPJ_FALSE ; } if ( c == 0x00 ) { x = 0 ; ++ y ; pix = pData + y * stride + x ; } else if ( c == 0x01 ) { break ; } else if ( c == 0x02 ) { c = getc ( IN ) ; if ( c == EOF ) { return OPJ_FALSE ; } x += ( OPJ_UINT32 ) c ; c = getc ( IN ) ; if ( c == EOF ) { return OPJ_FALSE ; } y += ( OPJ_UINT32 ) c ; pix = pData + y * stride + x ; } else { int j ; for ( j = 0 ; ( j < c ) && ( x < width ) && ( ( OPJ_SIZE_T ) pix < ( OPJ_SIZE_T ) beyond ) ; j ++ , x ++ , pix ++ ) { int c1_int ; OPJ_UINT8 c1 ; c1_int = getc ( IN ) ; if ( c1_int == EOF ) { return OPJ_FALSE ; } c1 = ( OPJ_UINT8 ) c1_int ; * pix = c1 ; <S2SV_StartBug> } <S2SV_EndBug> if ( ( OPJ_UINT32 ) c & 1U ) { c = getc ( IN ) ; if ( c == EOF ) { return OPJ_FALSE ; } } } } } <S2SV_StartBug> return OPJ_TRUE ; <S2SV_EndBug> }
CWE-119 NTSTATUS ProcessMainDeviceControlIrp ( PDEVICE_OBJECT DeviceObject , PEXTENSION Extension , PIRP Irp ) { PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation ( Irp ) ; NTSTATUS ntStatus ; switch ( irpSp -> Parameters . DeviceIoControl . IoControlCode ) { case TC_IOCTL_GET_DRIVER_VERSION : case TC_IOCTL_LEGACY_GET_DRIVER_VERSION : if ( ValidateIOBufferSize ( Irp , sizeof ( LONG ) , ValidateOutput ) ) { LONG tmp = VERSION_NUM ; memcpy ( Irp -> AssociatedIrp . SystemBuffer , & tmp , 4 ) ; Irp -> IoStatus . Information = sizeof ( LONG ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_GET_DEVICE_REFCOUNT : if ( ValidateIOBufferSize ( Irp , sizeof ( int ) , ValidateOutput ) ) { * ( int * ) Irp -> AssociatedIrp . SystemBuffer = DeviceObject -> ReferenceCount ; Irp -> IoStatus . Information = sizeof ( int ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_IS_DRIVER_UNLOAD_DISABLED : if ( ValidateIOBufferSize ( Irp , sizeof ( int ) , ValidateOutput ) ) { LONG deviceObjectCount = 0 ; * ( int * ) Irp -> AssociatedIrp . SystemBuffer = DriverUnloadDisabled ; if ( IoEnumerateDeviceObjectList ( TCDriverObject , NULL , 0 , & deviceObjectCount ) == STATUS_BUFFER_TOO_SMALL && deviceObjectCount > 1 ) * ( int * ) Irp -> AssociatedIrp . SystemBuffer = TRUE ; Irp -> IoStatus . Information = sizeof ( int ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_IS_ANY_VOLUME_MOUNTED : if ( ValidateIOBufferSize ( Irp , sizeof ( int ) , ValidateOutput ) ) { int drive ; * ( int * ) Irp -> AssociatedIrp . SystemBuffer = 0 ; for ( drive = MIN_MOUNTED_VOLUME_DRIVE_NUMBER ; drive <= MAX_MOUNTED_VOLUME_DRIVE_NUMBER ; ++ drive ) { if ( GetVirtualVolumeDeviceObject ( drive ) ) { * ( int * ) Irp -> AssociatedIrp . SystemBuffer = 1 ; break ; } } if ( IsBootDriveMounted ( ) ) * ( int * ) Irp -> AssociatedIrp . SystemBuffer = 1 ; Irp -> IoStatus . Information = sizeof ( int ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_OPEN_TEST : { OPEN_TEST_STRUCT * opentest = ( OPEN_TEST_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; OBJECT_ATTRIBUTES ObjectAttributes ; HANDLE NtFileHandle ; UNICODE_STRING FullFileName ; IO_STATUS_BLOCK IoStatus ; LARGE_INTEGER offset ; ACCESS_MASK access = FILE_READ_ATTRIBUTES ; if ( ! ValidateIOBufferSize ( Irp , sizeof ( OPEN_TEST_STRUCT ) , ValidateInputOutput ) ) break ; EnsureNullTerminatedString ( opentest -> wszFileName , sizeof ( opentest -> wszFileName ) ) ; RtlInitUnicodeString ( & FullFileName , opentest -> wszFileName ) ; InitializeObjectAttributes ( & ObjectAttributes , & FullFileName , OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE , NULL , NULL ) ; if ( opentest -> bDetectTCBootLoader || opentest -> DetectFilesystem || opentest -> bComputeVolumeIDs ) access |= FILE_READ_DATA ; ntStatus = ZwCreateFile ( & NtFileHandle , SYNCHRONIZE | access , & ObjectAttributes , & IoStatus , NULL , 0 , FILE_SHARE_READ | FILE_SHARE_WRITE , FILE_OPEN , FILE_SYNCHRONOUS_IO_NONALERT , NULL , 0 ) ; if ( NT_SUCCESS ( ntStatus ) ) { opentest -> TCBootLoaderDetected = FALSE ; opentest -> FilesystemDetected = FALSE ; memset ( opentest -> VolumeIDComputed , 0 , sizeof ( opentest -> VolumeIDComputed ) ) ; memset ( opentest -> volumeIDs , 0 , sizeof ( opentest -> volumeIDs ) ) ; if ( opentest -> bDetectTCBootLoader || opentest -> DetectFilesystem || opentest -> bComputeVolumeIDs ) { byte * readBuffer = TCalloc ( TC_MAX_VOLUME_SECTOR_SIZE ) ; if ( ! readBuffer ) { ntStatus = STATUS_INSUFFICIENT_RESOURCES ; } else { if ( opentest -> bDetectTCBootLoader || opentest -> DetectFilesystem ) { offset . QuadPart = 0 ; ntStatus = ZwReadFile ( NtFileHandle , NULL , NULL , NULL , & IoStatus , readBuffer , TC_MAX_VOLUME_SECTOR_SIZE , & offset , NULL ) ; if ( NT_SUCCESS ( ntStatus ) ) { size_t i ; if ( opentest -> bDetectTCBootLoader && IoStatus . Information >= TC_SECTOR_SIZE_BIOS ) { for ( i = 0 ; i < TC_SECTOR_SIZE_BIOS - strlen ( TC_APP_NAME ) ; ++ i ) { if ( memcmp ( readBuffer + i , TC_APP_NAME , strlen ( TC_APP_NAME ) ) == 0 ) { opentest -> TCBootLoaderDetected = TRUE ; break ; } } } if ( opentest -> DetectFilesystem && IoStatus . Information >= sizeof ( int64 ) ) { switch ( BE64 ( * ( uint64 * ) readBuffer ) ) { case 0xEB52904E54465320ULL : case 0xEB3C904D53444F53ULL : case 0xEB58904D53444F53ULL : case 0xEB76904558464154ULL : case 0x0000005265465300ULL : case 0xEB58906D6B66732EULL : case 0xEB58906D6B646F73ULL : case 0xEB3C906D6B66732EULL : case 0xEB3C906D6B646F73ULL : opentest -> FilesystemDetected = TRUE ; break ; case 0x0000000000000000ULL : if ( IsAllZeroes ( readBuffer + 8 , TC_VOLUME_HEADER_EFFECTIVE_SIZE - 8 ) ) opentest -> FilesystemDetected = TRUE ; break ; } } } } if ( opentest -> bComputeVolumeIDs && ( ! opentest -> DetectFilesystem || ! opentest -> FilesystemDetected ) ) { int volumeType ; for ( volumeType = TC_VOLUME_TYPE_NORMAL ; volumeType < TC_VOLUME_TYPE_COUNT ; volumeType ++ ) { switch ( volumeType ) { case TC_VOLUME_TYPE_NORMAL : offset . QuadPart = TC_VOLUME_HEADER_OFFSET ; break ; case TC_VOLUME_TYPE_HIDDEN : offset . QuadPart = TC_HIDDEN_VOLUME_HEADER_OFFSET ; break ; } ntStatus = ZwReadFile ( NtFileHandle , NULL , NULL , NULL , & IoStatus , readBuffer , TC_MAX_VOLUME_SECTOR_SIZE , & offset , NULL ) ; if ( NT_SUCCESS ( ntStatus ) ) { sha256 ( opentest -> volumeIDs [ volumeType ] , readBuffer , TC_VOLUME_HEADER_EFFECTIVE_SIZE ) ; opentest -> VolumeIDComputed [ volumeType ] = TRUE ; } } } TCfree ( readBuffer ) ; } } ZwClose ( NtFileHandle ) ; Dump ( "Open<S2SV_blank>test<S2SV_blank>on<S2SV_blank>file<S2SV_blank>%ls<S2SV_blank>success.\\n" , opentest -> wszFileName ) ; } else { # if 0 Dump ( "Open<S2SV_blank>test<S2SV_blank>on<S2SV_blank>file<S2SV_blank>%ls<S2SV_blank>failed<S2SV_blank>NTSTATUS<S2SV_blank>0x%08x\\n" , opentest -> wszFileName , ntStatus ) ; # endif } Irp -> IoStatus . Information = NT_SUCCESS ( ntStatus ) ? sizeof ( OPEN_TEST_STRUCT ) : 0 ; Irp -> IoStatus . Status = ntStatus ; } break ; case TC_IOCTL_GET_SYSTEM_DRIVE_CONFIG : { GetSystemDriveConfigurationRequest * request = ( GetSystemDriveConfigurationRequest * ) Irp -> AssociatedIrp . SystemBuffer ; OBJECT_ATTRIBUTES ObjectAttributes ; HANDLE NtFileHandle ; UNICODE_STRING FullFileName ; IO_STATUS_BLOCK IoStatus ; LARGE_INTEGER offset ; <S2SV_StartBug> byte readBuffer [ TC_SECTOR_SIZE_BIOS ] ; <S2SV_EndBug> if ( ! ValidateIOBufferSize ( Irp , sizeof ( GetSystemDriveConfigurationRequest ) , ValidateInputOutput ) ) <S2SV_StartBug> break ; <S2SV_EndBug> EnsureNullTerminatedString ( request -> DevicePath , sizeof ( request -> DevicePath ) ) ; RtlInitUnicodeString ( & FullFileName , request -> DevicePath ) ; InitializeObjectAttributes ( & ObjectAttributes , & FullFileName , OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE , NULL , NULL ) ; ntStatus = ZwCreateFile ( & NtFileHandle , SYNCHRONIZE | GENERIC_READ , & ObjectAttributes , & IoStatus , NULL , FILE_ATTRIBUTE_NORMAL , FILE_SHARE_READ | FILE_SHARE_WRITE , FILE_OPEN , FILE_SYNCHRONOUS_IO_NONALERT | FILE_RANDOM_ACCESS , NULL , 0 ) ; if ( NT_SUCCESS ( ntStatus ) ) { <S2SV_StartBug> offset . QuadPart = 0 ; <S2SV_EndBug> ntStatus = ZwReadFile ( NtFileHandle , NULL , NULL , NULL , & IoStatus , readBuffer , <S2SV_StartBug> sizeof ( readBuffer ) , <S2SV_EndBug> & offset , NULL ) ; <S2SV_StartBug> if ( NT_SUCCESS ( ntStatus ) ) <S2SV_EndBug> { size_t i ; request -> DriveIsDynamic = FALSE ; if ( readBuffer [ 510 ] == 0x55 && readBuffer [ 511 ] == 0xaa ) { int i ; for ( i = 0 ; i < 4 ; ++ i ) { if ( readBuffer [ 446 + i * 16 + 4 ] == PARTITION_LDM ) { request -> DriveIsDynamic = TRUE ; break ; } } } request -> BootLoaderVersion = 0 ; request -> Configuration = 0 ; request -> UserConfiguration = 0 ; request -> CustomUserMessage [ 0 ] = 0 ; for ( i = 0 ; i < sizeof ( readBuffer ) - strlen ( TC_APP_NAME ) ; ++ i ) { if ( memcmp ( readBuffer + i , TC_APP_NAME , strlen ( TC_APP_NAME ) ) == 0 ) { request -> BootLoaderVersion = BE16 ( * ( uint16 * ) ( readBuffer + TC_BOOT_SECTOR_VERSION_OFFSET ) ) ; request -> Configuration = readBuffer [ TC_BOOT_SECTOR_CONFIG_OFFSET ] ; if ( request -> BootLoaderVersion != 0 && request -> BootLoaderVersion <= VERSION_NUM ) { request -> UserConfiguration = readBuffer [ TC_BOOT_SECTOR_USER_CONFIG_OFFSET ] ; memcpy ( request -> CustomUserMessage , readBuffer + TC_BOOT_SECTOR_USER_MESSAGE_OFFSET , TC_BOOT_SECTOR_USER_MESSAGE_MAX_LENGTH ) ; } break ; } } Irp -> IoStatus . Status = STATUS_SUCCESS ; Irp -> IoStatus . Information = sizeof ( * request ) ; } else { <S2SV_StartBug> Irp -> IoStatus . Status = ntStatus ; <S2SV_EndBug> <S2SV_StartBug> Irp -> IoStatus . Information = 0 ; <S2SV_EndBug> } ZwClose ( NtFileHandle ) ; } else { Irp -> IoStatus . Status = ntStatus ; Irp -> IoStatus . Information = 0 ; } } break ; case TC_IOCTL_WIPE_PASSWORD_CACHE : WipeCache ( ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_GET_PASSWORD_CACHE_STATUS : Irp -> IoStatus . Status = cacheEmpty ? STATUS_PIPE_EMPTY : STATUS_SUCCESS ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_SET_PORTABLE_MODE_STATUS : if ( ! UserCanAccessDriveDevice ( ) ) { Irp -> IoStatus . Status = STATUS_ACCESS_DENIED ; Irp -> IoStatus . Information = 0 ; } else { PortableMode = TRUE ; Dump ( "Setting<S2SV_blank>portable<S2SV_blank>mode\\n" ) ; } break ; case TC_IOCTL_GET_PORTABLE_MODE_STATUS : Irp -> IoStatus . Status = PortableMode ? STATUS_SUCCESS : STATUS_PIPE_EMPTY ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_GET_MOUNTED_VOLUMES : if ( ValidateIOBufferSize ( Irp , sizeof ( MOUNT_LIST_STRUCT ) , ValidateOutput ) ) { MOUNT_LIST_STRUCT * list = ( MOUNT_LIST_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; PDEVICE_OBJECT ListDevice ; int drive ; list -> ulMountedDrives = 0 ; for ( drive = MIN_MOUNTED_VOLUME_DRIVE_NUMBER ; drive <= MAX_MOUNTED_VOLUME_DRIVE_NUMBER ; ++ drive ) { PEXTENSION ListExtension ; ListDevice = GetVirtualVolumeDeviceObject ( drive ) ; if ( ! ListDevice ) continue ; ListExtension = ( PEXTENSION ) ListDevice -> DeviceExtension ; if ( IsVolumeAccessibleByCurrentUser ( ListExtension ) ) { list -> ulMountedDrives |= ( 1 << ListExtension -> nDosDriveNo ) ; RtlStringCbCopyW ( list -> wszVolume [ ListExtension -> nDosDriveNo ] , sizeof ( list -> wszVolume [ ListExtension -> nDosDriveNo ] ) , ListExtension -> wszVolume ) ; RtlStringCbCopyW ( list -> wszLabel [ ListExtension -> nDosDriveNo ] , sizeof ( list -> wszLabel [ ListExtension -> nDosDriveNo ] ) , ListExtension -> wszLabel ) ; memcpy ( list -> volumeID [ ListExtension -> nDosDriveNo ] , ListExtension -> volumeID , VOLUME_ID_SIZE ) ; list -> diskLength [ ListExtension -> nDosDriveNo ] = ListExtension -> DiskLength ; list -> ea [ ListExtension -> nDosDriveNo ] = ListExtension -> cryptoInfo -> ea ; if ( ListExtension -> cryptoInfo -> hiddenVolume ) list -> volumeType [ ListExtension -> nDosDriveNo ] = PROP_VOL_TYPE_HIDDEN ; else if ( ListExtension -> cryptoInfo -> bHiddenVolProtectionAction ) list -> volumeType [ ListExtension -> nDosDriveNo ] = PROP_VOL_TYPE_OUTER_VOL_WRITE_PREVENTED ; else if ( ListExtension -> cryptoInfo -> bProtectHiddenVolume ) list -> volumeType [ ListExtension -> nDosDriveNo ] = PROP_VOL_TYPE_OUTER ; else list -> volumeType [ ListExtension -> nDosDriveNo ] = PROP_VOL_TYPE_NORMAL ; list -> truecryptMode [ ListExtension -> nDosDriveNo ] = ListExtension -> cryptoInfo -> bTrueCryptMode ; } } Irp -> IoStatus . Status = STATUS_SUCCESS ; Irp -> IoStatus . Information = sizeof ( MOUNT_LIST_STRUCT ) ; } break ; case TC_IOCTL_LEGACY_GET_MOUNTED_VOLUMES : if ( ValidateIOBufferSize ( Irp , sizeof ( uint32 ) , ValidateOutput ) ) { memset ( Irp -> AssociatedIrp . SystemBuffer , 0 , irpSp -> Parameters . DeviceIoControl . OutputBufferLength ) ; * ( uint32 * ) Irp -> AssociatedIrp . SystemBuffer = 0xffffFFFF ; Irp -> IoStatus . Status = STATUS_SUCCESS ; Irp -> IoStatus . Information = irpSp -> Parameters . DeviceIoControl . OutputBufferLength ; } break ; case TC_IOCTL_GET_VOLUME_PROPERTIES : if ( ValidateIOBufferSize ( Irp , sizeof ( VOLUME_PROPERTIES_STRUCT ) , ValidateInputOutput ) ) { VOLUME_PROPERTIES_STRUCT * prop = ( VOLUME_PROPERTIES_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; PDEVICE_OBJECT ListDevice = GetVirtualVolumeDeviceObject ( prop -> driveNo ) ; Irp -> IoStatus . Status = STATUS_INVALID_PARAMETER ; Irp -> IoStatus . Information = 0 ; if ( ListDevice ) { PEXTENSION ListExtension = ( PEXTENSION ) ListDevice -> DeviceExtension ; if ( IsVolumeAccessibleByCurrentUser ( ListExtension ) ) { prop -> uniqueId = ListExtension -> UniqueVolumeId ; RtlStringCbCopyW ( prop -> wszVolume , sizeof ( prop -> wszVolume ) , ListExtension -> wszVolume ) ; RtlStringCbCopyW ( prop -> wszLabel , sizeof ( prop -> wszLabel ) , ListExtension -> wszLabel ) ; memcpy ( prop -> volumeID , ListExtension -> volumeID , VOLUME_ID_SIZE ) ; prop -> bDriverSetLabel = ListExtension -> bDriverSetLabel ; prop -> diskLength = ListExtension -> DiskLength ; prop -> ea = ListExtension -> cryptoInfo -> ea ; prop -> mode = ListExtension -> cryptoInfo -> mode ; prop -> pkcs5 = ListExtension -> cryptoInfo -> pkcs5 ; prop -> pkcs5Iterations = ListExtension -> cryptoInfo -> noIterations ; prop -> volumePim = ListExtension -> cryptoInfo -> volumePim ; # if 0 prop -> volumeCreationTime = ListExtension -> cryptoInfo -> volume_creation_time ; prop -> headerCreationTime = ListExtension -> cryptoInfo -> header_creation_time ; # endif prop -> volumeHeaderFlags = ListExtension -> cryptoInfo -> HeaderFlags ; prop -> readOnly = ListExtension -> bReadOnly ; prop -> removable = ListExtension -> bRemovable ; prop -> partitionInInactiveSysEncScope = ListExtension -> PartitionInInactiveSysEncScope ; prop -> hiddenVolume = ListExtension -> cryptoInfo -> hiddenVolume ; if ( ListExtension -> cryptoInfo -> bProtectHiddenVolume ) prop -> hiddenVolProtection = ListExtension -> cryptoInfo -> bHiddenVolProtectionAction ? HIDVOL_PROT_STATUS_ACTION_TAKEN : HIDVOL_PROT_STATUS_ACTIVE ; else prop -> hiddenVolProtection = HIDVOL_PROT_STATUS_NONE ; prop -> totalBytesRead = ListExtension -> Queue . TotalBytesRead ; prop -> totalBytesWritten = ListExtension -> Queue . TotalBytesWritten ; prop -> volFormatVersion = ListExtension -> cryptoInfo -> LegacyVolume ? TC_VOLUME_FORMAT_VERSION_PRE_6_0 : TC_VOLUME_FORMAT_VERSION ; Irp -> IoStatus . Status = STATUS_SUCCESS ; Irp -> IoStatus . Information = sizeof ( VOLUME_PROPERTIES_STRUCT ) ; } } } break ; case TC_IOCTL_GET_RESOLVED_SYMLINK : if ( ValidateIOBufferSize ( Irp , sizeof ( RESOLVE_SYMLINK_STRUCT ) , ValidateInputOutput ) ) { RESOLVE_SYMLINK_STRUCT * resolve = ( RESOLVE_SYMLINK_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; { NTSTATUS ntStatus ; EnsureNullTerminatedString ( resolve -> symLinkName , sizeof ( resolve -> symLinkName ) ) ; ntStatus = SymbolicLinkToTarget ( resolve -> symLinkName , resolve -> targetName , sizeof ( resolve -> targetName ) ) ; Irp -> IoStatus . Information = sizeof ( RESOLVE_SYMLINK_STRUCT ) ; Irp -> IoStatus . Status = ntStatus ; } } break ; case TC_IOCTL_GET_DRIVE_PARTITION_INFO : if ( ValidateIOBufferSize ( Irp , sizeof ( DISK_PARTITION_INFO_STRUCT ) , ValidateInputOutput ) ) { DISK_PARTITION_INFO_STRUCT * info = ( DISK_PARTITION_INFO_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; { PARTITION_INFORMATION_EX pi ; NTSTATUS ntStatus ; EnsureNullTerminatedString ( info -> deviceName , sizeof ( info -> deviceName ) ) ; ntStatus = TCDeviceIoControl ( info -> deviceName , IOCTL_DISK_GET_PARTITION_INFO_EX , NULL , 0 , & pi , sizeof ( pi ) ) ; if ( NT_SUCCESS ( ntStatus ) ) { memset ( & info -> partInfo , 0 , sizeof ( info -> partInfo ) ) ; info -> partInfo . PartitionLength = pi . PartitionLength ; info -> partInfo . PartitionNumber = pi . PartitionNumber ; info -> partInfo . StartingOffset = pi . StartingOffset ; if ( pi . PartitionStyle == PARTITION_STYLE_MBR ) { info -> partInfo . PartitionType = pi . Mbr . PartitionType ; info -> partInfo . BootIndicator = pi . Mbr . BootIndicator ; } info -> IsGPT = pi . PartitionStyle == PARTITION_STYLE_GPT ; } else { ntStatus = TCDeviceIoControl ( info -> deviceName , IOCTL_DISK_GET_PARTITION_INFO , NULL , 0 , & info -> partInfo , sizeof ( info -> partInfo ) ) ; info -> IsGPT = FALSE ; } if ( ! NT_SUCCESS ( ntStatus ) ) { GET_LENGTH_INFORMATION lengthInfo ; ntStatus = TCDeviceIoControl ( info -> deviceName , IOCTL_DISK_GET_LENGTH_INFO , NULL , 0 , & lengthInfo , sizeof ( lengthInfo ) ) ; if ( NT_SUCCESS ( ntStatus ) ) { memset ( & info -> partInfo , 0 , sizeof ( info -> partInfo ) ) ; info -> partInfo . PartitionLength = lengthInfo . Length ; } } info -> IsDynamic = FALSE ; if ( NT_SUCCESS ( ntStatus ) && OsMajorVersion >= 6 ) { # define IOCTL_VOLUME_IS_DYNAMIC CTL_CODE ( IOCTL_VOLUME_BASE , 18 , METHOD_BUFFERED , FILE_ANY_ACCESS ) if ( ! NT_SUCCESS ( TCDeviceIoControl ( info -> deviceName , IOCTL_VOLUME_IS_DYNAMIC , NULL , 0 , & info -> IsDynamic , sizeof ( info -> IsDynamic ) ) ) ) info -> IsDynamic = FALSE ; } Irp -> IoStatus . Information = sizeof ( DISK_PARTITION_INFO_STRUCT ) ; Irp -> IoStatus . Status = ntStatus ; } } break ; case TC_IOCTL_GET_DRIVE_GEOMETRY : if ( ValidateIOBufferSize ( Irp , sizeof ( DISK_GEOMETRY_STRUCT ) , ValidateInputOutput ) ) { DISK_GEOMETRY_STRUCT * g = ( DISK_GEOMETRY_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; { NTSTATUS ntStatus ; EnsureNullTerminatedString ( g -> deviceName , sizeof ( g -> deviceName ) ) ; Dump ( "Calling<S2SV_blank>IOCTL_DISK_GET_DRIVE_GEOMETRY<S2SV_blank>on<S2SV_blank>%ls\\n" , g -> deviceName ) ; ntStatus = TCDeviceIoControl ( g -> deviceName , IOCTL_DISK_GET_DRIVE_GEOMETRY , NULL , 0 , & g -> diskGeometry , sizeof ( g -> diskGeometry ) ) ; Irp -> IoStatus . Information = sizeof ( DISK_GEOMETRY_STRUCT ) ; Irp -> IoStatus . Status = ntStatus ; } } break ; case VC_IOCTL_GET_DRIVE_GEOMETRY_EX : if ( ValidateIOBufferSize ( Irp , sizeof ( DISK_GEOMETRY_EX_STRUCT ) , ValidateInputOutput ) ) { DISK_GEOMETRY_EX_STRUCT * g = ( DISK_GEOMETRY_EX_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; { NTSTATUS ntStatus ; PVOID buffer = TCalloc ( 256 ) ; if ( buffer ) { EnsureNullTerminatedString ( g -> deviceName , sizeof ( g -> deviceName ) ) ; Dump ( "Calling<S2SV_blank>IOCTL_DISK_GET_DRIVE_GEOMETRY_EX<S2SV_blank>on<S2SV_blank>%ls\\n" , g -> deviceName ) ; ntStatus = TCDeviceIoControl ( g -> deviceName , IOCTL_DISK_GET_DRIVE_GEOMETRY_EX , NULL , 0 , buffer , 256 ) ; if ( NT_SUCCESS ( ntStatus ) ) { PDISK_GEOMETRY_EX pGeo = ( PDISK_GEOMETRY_EX ) buffer ; memcpy ( & g -> diskGeometry , & pGeo -> Geometry , sizeof ( DISK_GEOMETRY ) ) ; g -> DiskSize . QuadPart = pGeo -> DiskSize . QuadPart ; } else { DISK_GEOMETRY dg = { 0 } ; Dump ( "Failed.<S2SV_blank>Calling<S2SV_blank>IOCTL_DISK_GET_DRIVE_GEOMETRY<S2SV_blank>on<S2SV_blank>%ls\\n" , g -> deviceName ) ; ntStatus = TCDeviceIoControl ( g -> deviceName , IOCTL_DISK_GET_DRIVE_GEOMETRY , NULL , 0 , & dg , sizeof ( dg ) ) ; if ( NT_SUCCESS ( ntStatus ) ) { memcpy ( & g -> diskGeometry , & dg , sizeof ( DISK_GEOMETRY ) ) ; g -> DiskSize . QuadPart = dg . Cylinders . QuadPart * dg . SectorsPerTrack * dg . TracksPerCylinder * dg . BytesPerSector ; if ( OsMajorVersion >= 6 ) { STORAGE_READ_CAPACITY storage = { 0 } ; NTSTATUS lStatus ; storage . Version = sizeof ( STORAGE_READ_CAPACITY ) ; Dump ( "Calling<S2SV_blank>IOCTL_STORAGE_READ_CAPACITY<S2SV_blank>on<S2SV_blank>%ls\\n" , g -> deviceName ) ; lStatus = TCDeviceIoControl ( g -> deviceName , IOCTL_STORAGE_READ_CAPACITY , NULL , 0 , & storage , sizeof ( STORAGE_READ_CAPACITY ) ) ; if ( NT_SUCCESS ( lStatus ) && ( storage . Size == sizeof ( STORAGE_READ_CAPACITY ) ) ) { g -> DiskSize . QuadPart = storage . DiskLength . QuadPart ; } } } } TCfree ( buffer ) ; Irp -> IoStatus . Information = sizeof ( DISK_GEOMETRY_EX_STRUCT ) ; Irp -> IoStatus . Status = ntStatus ; } else { Irp -> IoStatus . Status = STATUS_INSUFFICIENT_RESOURCES ; Irp -> IoStatus . Information = 0 ; } } } break ; case TC_IOCTL_PROBE_REAL_DRIVE_SIZE : if ( ValidateIOBufferSize ( Irp , sizeof ( ProbeRealDriveSizeRequest ) , ValidateInputOutput ) ) { ProbeRealDriveSizeRequest * request = ( ProbeRealDriveSizeRequest * ) Irp -> AssociatedIrp . SystemBuffer ; NTSTATUS status ; UNICODE_STRING name ; PFILE_OBJECT fileObject ; PDEVICE_OBJECT deviceObject ; EnsureNullTerminatedString ( request -> DeviceName , sizeof ( request -> DeviceName ) ) ; RtlInitUnicodeString ( & name , request -> DeviceName ) ; status = IoGetDeviceObjectPointer ( & name , FILE_READ_ATTRIBUTES , & fileObject , & deviceObject ) ; if ( ! NT_SUCCESS ( status ) ) { Irp -> IoStatus . Information = 0 ; Irp -> IoStatus . Status = status ; break ; } status = ProbeRealDriveSize ( deviceObject , & request -> RealDriveSize ) ; ObDereferenceObject ( fileObject ) ; if ( status == STATUS_TIMEOUT ) { request -> TimeOut = TRUE ; Irp -> IoStatus . Information = sizeof ( ProbeRealDriveSizeRequest ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } else if ( ! NT_SUCCESS ( status ) ) { Irp -> IoStatus . Information = 0 ; Irp -> IoStatus . Status = status ; } else { request -> TimeOut = FALSE ; Irp -> IoStatus . Information = sizeof ( ProbeRealDriveSizeRequest ) ; Irp -> IoStatus . Status = status ; } } break ; case TC_IOCTL_MOUNT_VOLUME : if ( ValidateIOBufferSize ( Irp , sizeof ( MOUNT_STRUCT ) , ValidateInputOutput ) ) { MOUNT_STRUCT * mount = ( MOUNT_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; if ( mount -> VolumePassword . Length > MAX_PASSWORD || mount -> ProtectedHidVolPassword . Length > MAX_PASSWORD || mount -> pkcs5_prf < 0 || mount -> pkcs5_prf > LAST_PRF_ID || mount -> VolumePim < - 1 || mount -> VolumePim == INT_MAX || mount -> ProtectedHidVolPkcs5Prf < 0 || mount -> ProtectedHidVolPkcs5Prf > LAST_PRF_ID || ( mount -> bTrueCryptMode != FALSE && mount -> bTrueCryptMode != TRUE ) ) { Irp -> IoStatus . Status = STATUS_INVALID_PARAMETER ; Irp -> IoStatus . Information = 0 ; break ; } EnsureNullTerminatedString ( mount -> wszVolume , sizeof ( mount -> wszVolume ) ) ; EnsureNullTerminatedString ( mount -> wszLabel , sizeof ( mount -> wszLabel ) ) ; Irp -> IoStatus . Information = sizeof ( MOUNT_STRUCT ) ; Irp -> IoStatus . Status = MountDevice ( DeviceObject , mount ) ; burn ( & mount -> VolumePassword , sizeof ( mount -> VolumePassword ) ) ; burn ( & mount -> ProtectedHidVolPassword , sizeof ( mount -> ProtectedHidVolPassword ) ) ; burn ( & mount -> pkcs5_prf , sizeof ( mount -> pkcs5_prf ) ) ; burn ( & mount -> VolumePim , sizeof ( mount -> VolumePim ) ) ; burn ( & mount -> bTrueCryptMode , sizeof ( mount -> bTrueCryptMode ) ) ; burn ( & mount -> ProtectedHidVolPkcs5Prf , sizeof ( mount -> ProtectedHidVolPkcs5Prf ) ) ; burn ( & mount -> ProtectedHidVolPim , sizeof ( mount -> ProtectedHidVolPim ) ) ; } break ; case TC_IOCTL_DISMOUNT_VOLUME : if ( ValidateIOBufferSize ( Irp , sizeof ( UNMOUNT_STRUCT ) , ValidateInputOutput ) ) { UNMOUNT_STRUCT * unmount = ( UNMOUNT_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; PDEVICE_OBJECT ListDevice = GetVirtualVolumeDeviceObject ( unmount -> nDosDriveNo ) ; unmount -> nReturnCode = ERR_DRIVE_NOT_FOUND ; if ( ListDevice ) { PEXTENSION ListExtension = ( PEXTENSION ) ListDevice -> DeviceExtension ; if ( IsVolumeAccessibleByCurrentUser ( ListExtension ) ) unmount -> nReturnCode = UnmountDevice ( unmount , ListDevice , unmount -> ignoreOpenFiles ) ; } Irp -> IoStatus . Information = sizeof ( UNMOUNT_STRUCT ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_DISMOUNT_ALL_VOLUMES : if ( ValidateIOBufferSize ( Irp , sizeof ( UNMOUNT_STRUCT ) , ValidateInputOutput ) ) { UNMOUNT_STRUCT * unmount = ( UNMOUNT_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; unmount -> nReturnCode = UnmountAllDevices ( unmount , unmount -> ignoreOpenFiles ) ; Irp -> IoStatus . Information = sizeof ( UNMOUNT_STRUCT ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_BOOT_ENCRYPTION_SETUP : Irp -> IoStatus . Status = StartBootEncryptionSetup ( DeviceObject , Irp , irpSp ) ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_ABORT_BOOT_ENCRYPTION_SETUP : Irp -> IoStatus . Status = AbortBootEncryptionSetup ( ) ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_GET_BOOT_ENCRYPTION_STATUS : GetBootEncryptionStatus ( Irp , irpSp ) ; break ; case TC_IOCTL_GET_BOOT_ENCRYPTION_SETUP_RESULT : Irp -> IoStatus . Information = 0 ; Irp -> IoStatus . Status = GetSetupResult ( ) ; break ; case TC_IOCTL_GET_BOOT_DRIVE_VOLUME_PROPERTIES : GetBootDriveVolumeProperties ( Irp , irpSp ) ; break ; case TC_IOCTL_GET_BOOT_LOADER_VERSION : GetBootLoaderVersion ( Irp , irpSp ) ; break ; case TC_IOCTL_REOPEN_BOOT_VOLUME_HEADER : ReopenBootVolumeHeader ( Irp , irpSp ) ; break ; case VC_IOCTL_GET_BOOT_LOADER_FINGERPRINT : GetBootLoaderFingerprint ( Irp , irpSp ) ; break ; case TC_IOCTL_GET_BOOT_ENCRYPTION_ALGORITHM_NAME : GetBootEncryptionAlgorithmName ( Irp , irpSp ) ; break ; case TC_IOCTL_IS_HIDDEN_SYSTEM_RUNNING : if ( ValidateIOBufferSize ( Irp , sizeof ( int ) , ValidateOutput ) ) { * ( int * ) Irp -> AssociatedIrp . SystemBuffer = IsHiddenSystemRunning ( ) ? 1 : 0 ; Irp -> IoStatus . Information = sizeof ( int ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_START_DECOY_SYSTEM_WIPE : Irp -> IoStatus . Status = StartDecoySystemWipe ( DeviceObject , Irp , irpSp ) ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_ABORT_DECOY_SYSTEM_WIPE : Irp -> IoStatus . Status = AbortDecoySystemWipe ( ) ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_GET_DECOY_SYSTEM_WIPE_RESULT : Irp -> IoStatus . Status = GetDecoySystemWipeResult ( ) ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_GET_DECOY_SYSTEM_WIPE_STATUS : GetDecoySystemWipeStatus ( Irp , irpSp ) ; break ; case TC_IOCTL_WRITE_BOOT_DRIVE_SECTOR : Irp -> IoStatus . Status = WriteBootDriveSector ( Irp , irpSp ) ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_GET_WARNING_FLAGS : if ( ValidateIOBufferSize ( Irp , sizeof ( GetWarningFlagsRequest ) , ValidateOutput ) ) { GetWarningFlagsRequest * flags = ( GetWarningFlagsRequest * ) Irp -> AssociatedIrp . SystemBuffer ; flags -> PagingFileCreationPrevented = PagingFileCreationPrevented ; PagingFileCreationPrevented = FALSE ; flags -> SystemFavoriteVolumeDirty = SystemFavoriteVolumeDirty ; SystemFavoriteVolumeDirty = FALSE ; Irp -> IoStatus . Information = sizeof ( GetWarningFlagsRequest ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_SET_SYSTEM_FAVORITE_VOLUME_DIRTY : if ( UserCanAccessDriveDevice ( ) ) { SystemFavoriteVolumeDirty = TRUE ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } else Irp -> IoStatus . Status = STATUS_ACCESS_DENIED ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_REREAD_DRIVER_CONFIG : Irp -> IoStatus . Status = ReadRegistryConfigFlags ( FALSE ) ; Irp -> IoStatus . Information = 0 ; break ; case TC_IOCTL_GET_SYSTEM_DRIVE_DUMP_CONFIG : if ( ( ValidateIOBufferSize ( Irp , sizeof ( GetSystemDriveDumpConfigRequest ) , ValidateOutput ) ) && ( Irp -> RequestorMode == KernelMode ) ) { GetSystemDriveDumpConfigRequest * request = ( GetSystemDriveDumpConfigRequest * ) Irp -> AssociatedIrp . SystemBuffer ; request -> BootDriveFilterExtension = GetBootDriveFilterExtension ( ) ; if ( IsBootDriveMounted ( ) && request -> BootDriveFilterExtension ) { request -> HwEncryptionEnabled = IsHwEncryptionEnabled ( ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; Irp -> IoStatus . Information = sizeof ( * request ) ; } else { Irp -> IoStatus . Status = STATUS_INVALID_PARAMETER ; Irp -> IoStatus . Information = 0 ; } } break ; default : return TCCompleteIrp ( Irp , STATUS_INVALID_DEVICE_REQUEST , 0 ) ; } # if defined ( DEBUG ) || defined ( DEBUG_TRACE ) if ( ! NT_SUCCESS ( Irp -> IoStatus . Status ) ) { switch ( irpSp -> Parameters . DeviceIoControl . IoControlCode ) { case TC_IOCTL_GET_MOUNTED_VOLUMES : case TC_IOCTL_GET_PASSWORD_CACHE_STATUS : case TC_IOCTL_GET_PORTABLE_MODE_STATUS : case TC_IOCTL_SET_PORTABLE_MODE_STATUS : case TC_IOCTL_OPEN_TEST : case TC_IOCTL_GET_RESOLVED_SYMLINK : case TC_IOCTL_GET_DRIVE_PARTITION_INFO : case TC_IOCTL_GET_BOOT_DRIVE_VOLUME_PROPERTIES : case TC_IOCTL_GET_BOOT_ENCRYPTION_STATUS : case TC_IOCTL_IS_HIDDEN_SYSTEM_RUNNING : break ; default : Dump ( "IOCTL<S2SV_blank>error<S2SV_blank>0x%08x\\n" , Irp -> IoStatus . Status ) ; } } # endif return TCCompleteIrp ( Irp , Irp -> IoStatus . Status , Irp -> IoStatus . Information ) ; }
CWE-787 void * adminchild ( struct clientparam * param ) { int i , res ; char * buf ; char username [ 256 ] ; char * sb ; char * req = NULL ; struct printparam pp ; <S2SV_StartBug> int contentlen = 0 ; <S2SV_EndBug> int isform = 0 ; pp . inbuf = 0 ; pp . cp = param ; buf = myalloc ( LINESIZE ) ; if ( ! buf ) { RETURN ( 555 ) ; } i = sockgetlinebuf ( param , CLIENT , ( unsigned char * ) buf , LINESIZE - 1 , '\\n' , conf . timeouts [ STRING_S ] ) ; if ( i < 5 || ( ( buf [ 0 ] != 'G' || buf [ 1 ] != 'E' || buf [ 2 ] != 'T' || buf [ 3 ] != '<S2SV_blank>' || buf [ 4 ] != '/' ) && ( buf [ 0 ] != 'P' || buf [ 1 ] != 'O' || buf [ 2 ] != 'S' || buf [ 3 ] != 'T' || buf [ 4 ] != '<S2SV_blank>' || buf [ 5 ] != '/' ) ) ) { RETURN ( 701 ) ; } buf [ i ] = 0 ; sb = strchr ( buf + 5 , '<S2SV_blank>' ) ; if ( ! sb ) { RETURN ( 702 ) ; } * sb = 0 ; req = mystrdup ( buf + ( ( * buf == 'P' ) ? 6 : 5 ) ) ; while ( ( i = sockgetlinebuf ( param , CLIENT , ( unsigned char * ) buf , LINESIZE - 1 , '\\n' , conf . timeouts [ STRING_S ] ) ) > 2 ) { buf [ i ] = 0 ; if ( i > 19 && ( ! strncasecmp ( buf , "authorization" , 13 ) ) ) { sb = strchr ( buf , ':' ) ; if ( ! sb ) continue ; ++ sb ; while ( isspace ( * sb ) ) sb ++ ; if ( ! * sb || strncasecmp ( sb , "basic" , 5 ) ) { continue ; } sb += 5 ; while ( isspace ( * sb ) ) sb ++ ; i = de64 ( ( unsigned char * ) sb , ( unsigned char * ) username , 255 ) ; if ( i <= 0 ) continue ; username [ i ] = 0 ; sb = strchr ( ( char * ) username , ':' ) ; if ( sb ) { * sb = 0 ; if ( param -> password ) myfree ( param -> password ) ; param -> password = ( unsigned char * ) mystrdup ( sb + 1 ) ; } if ( param -> username ) myfree ( param -> username ) ; param -> username = ( unsigned char * ) mystrdup ( username ) ; continue ; } else if ( i > 15 && ( ! strncasecmp ( buf , "content-length:" , 15 ) ) ) { sb = buf + 15 ; while ( isspace ( * sb ) ) sb ++ ; <S2SV_StartBug> contentlen = atoi ( sb ) ; <S2SV_EndBug> } else if ( i > 13 && ( ! strncasecmp ( buf , "content-type:" , 13 ) ) ) { sb = buf + 13 ; while ( isspace ( * sb ) ) sb ++ ; if ( ! strncasecmp ( sb , "x-www-form-urlencoded" , 21 ) ) isform = 1 ; } } param -> operation = ADMIN ; if ( isform && contentlen ) { printstr ( & pp , "HTTP/1.0<S2SV_blank>100<S2SV_blank>Continue\\r\\n\\r\\n" ) ; stdpr ( & pp , NULL , 0 ) ; } res = ( * param -> srv -> authfunc ) ( param ) ; if ( res && res != 10 ) { printstr ( & pp , authreq ) ; RETURN ( res ) ; } if ( param -> srv -> singlepacket || param -> redirected ) { if ( * req == 'C' ) req [ 1 ] = 0 ; else * req = 0 ; } sprintf ( buf , ok , conf . stringtable ? ( char * ) conf . stringtable [ 2 ] : "3proxy" , conf . stringtable ? ( char * ) conf . stringtable [ 2 ] : "3[APA3A]<S2SV_blank>tiny<S2SV_blank>proxy" , conf . stringtable ? ( char * ) conf . stringtable [ 3 ] : "" ) ; if ( * req != 'S' ) printstr ( & pp , buf ) ; switch ( * req ) { case 'C' : printstr ( & pp , counters ) ; { struct trafcount * cp ; int num = 0 ; for ( cp = conf . trafcounter ; cp ; cp = cp -> next , num ++ ) { int inbuf = 0 ; if ( cp -> ace && ( param -> srv -> singlepacket || param -> redirected ) ) { if ( ! ACLmatches ( cp -> ace , param ) ) continue ; } if ( req [ 1 ] == 'S' && atoi ( req + 2 ) == num ) cp -> disabled = 0 ; if ( req [ 1 ] == 'D' && atoi ( req + 2 ) == num ) cp -> disabled = 1 ; inbuf += sprintf ( buf , "<tr>" "<td>%s</td><td><A<S2SV_blank>HREF=\\\'/C%c%d\\\'>%s</A></td><td>" , ( cp -> comment ) ? cp -> comment : "&nbsp;" , ( cp -> disabled ) ? 'S' : 'D' , num , ( cp -> disabled ) ? "NO" : "YES" ) ; if ( ! cp -> ace || ! cp -> ace -> users ) { inbuf += sprintf ( buf + inbuf , "<center>ANY</center>" ) ; } else { inbuf += printuserlist ( buf + inbuf , LINESIZE - 800 , cp -> ace -> users , ",<br<S2SV_blank>/>\\r\\n" ) ; } inbuf += sprintf ( buf + inbuf , "</td><td>" ) ; if ( ! cp -> ace || ! cp -> ace -> src ) { inbuf += sprintf ( buf + inbuf , "<center>ANY</center>" ) ; } else { inbuf += printiplist ( buf + inbuf , LINESIZE - 512 , cp -> ace -> src , ",<br<S2SV_blank>/>\\r\\n" ) ; } inbuf += sprintf ( buf + inbuf , "</td><td>" ) ; if ( ! cp -> ace || ! cp -> ace -> dst ) { inbuf += sprintf ( buf + inbuf , "<center>ANY</center>" ) ; } else { inbuf += printiplist ( buf + inbuf , LINESIZE - 512 , cp -> ace -> dst , ",<br<S2SV_blank>/>\\r\\n" ) ; } inbuf += sprintf ( buf + inbuf , "</td><td>" ) ; if ( ! cp -> ace || ! cp -> ace -> ports ) { inbuf += sprintf ( buf + inbuf , "<center>ANY</center>" ) ; } else { inbuf += printportlist ( buf + inbuf , LINESIZE - 128 , cp -> ace -> ports , ",<br<S2SV_blank>/>\\r\\n" ) ; } if ( cp -> type == NONE ) { inbuf += sprintf ( buf + inbuf , "</td><td<S2SV_blank>colspan=\\\'6\\\'<S2SV_blank>align=\\\'center\\\'>exclude<S2SV_blank>from<S2SV_blank>limitation</td></tr>\\r\\n" ) ; } else { inbuf += sprintf ( buf + inbuf , "</td><td>%" PRINTF_INT64_MODIFIER "u</td>" "<td>MB%s</td>" "<td>%" PRINTF_INT64_MODIFIER "u</td>" "<td>%s</td>" , cp -> traflim64 / ( 1024 * 1024 ) , rotations [ cp -> type ] , cp -> traf64 , cp -> cleared ? ctime ( & cp -> cleared ) : "never" ) ; inbuf += sprintf ( buf + inbuf , "<td>%s</td>" "<td>%i</td>" "</tr>\\r\\n" , cp -> updated ? ctime ( & cp -> updated ) : "never" , cp -> number ) ; } printstr ( & pp , buf ) ; } } printstr ( & pp , counterstail ) ; break ; case 'R' : conf . needreload = 1 ; printstr ( & pp , "<h3>Reload<S2SV_blank>scheduled</h3>" ) ; break ; case 'S' : { if ( req [ 1 ] == 'X' ) { printstr ( & pp , style ) ; break ; } printstr ( & pp , xml ) ; printval ( conf . services , TYPE_SERVER , 0 , & pp ) ; printstr ( & pp , postxml ) ; } break ; case 'F' : { FILE * fp ; char buf [ 256 ] ; fp = confopen ( ) ; if ( ! fp ) { printstr ( & pp , "<h3><font<S2SV_blank>color=\\"red\\">Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>config<S2SV_blank>file</font></h3>" ) ; break ; } printstr ( & pp , "<h3>Please<S2SV_blank>be<S2SV_blank>careful<S2SV_blank>editing<S2SV_blank>config<S2SV_blank>file<S2SV_blank>remotely</h3>" ) ; <S2SV_StartBug> printstr ( & pp , "<form<S2SV_blank>method=\\"POST\\"<S2SV_blank>action=\\"/U\\"><textarea<S2SV_blank>cols=\\"80\\"<S2SV_blank>rows=\\"30\\"<S2SV_blank>name=\\"conffile\\">" ) ; <S2SV_EndBug> while ( fgets ( buf , 256 , fp ) ) { printstr ( & pp , buf ) ; } if ( ! writable ) fclose ( fp ) ; printstr ( & pp , "</textarea><br><input<S2SV_blank>type=\\"Submit\\"></form>" ) ; break ; } case 'U' : { <S2SV_StartBug> int l = 0 ; <S2SV_EndBug> int error = 0 ; <S2SV_StartBug> if ( ! writable || fseek ( writable , 0 , 0 ) ) { <S2SV_EndBug> error = 1 ; } <S2SV_StartBug> while ( ( i = sockgetlinebuf ( param , CLIENT , ( unsigned char * ) buf , LINESIZE - 1 , '+' , conf . timeouts [ STRING_S ] ) ) > 0 ) { <S2SV_EndBug> if ( i > ( contentlen - l ) ) i = ( contentlen - l ) ; <S2SV_StartBug> buf [ i ] = 0 ; <S2SV_EndBug> if ( ! l ) { if ( strncasecmp ( buf , "conffile=" , 9 ) ) error = 1 ; } <S2SV_StartBug> if ( ! error ) { <S2SV_EndBug> decodeurl ( ( unsigned char * ) buf , 1 ) ; fprintf ( writable , "%s" , l ? buf : buf + 9 ) ; } <S2SV_StartBug> l += i ; <S2SV_EndBug> if ( l >= contentlen ) break ; } if ( writable && ! error ) { fflush ( writable ) ; # ifndef _WINCE ftruncate ( fileno ( writable ) , ftell ( writable ) ) ; # endif } printstr ( & pp , error ? "<h3><font<S2SV_blank>color=\\"red\\">Config<S2SV_blank>file<S2SV_blank>is<S2SV_blank>not<S2SV_blank>writable</font></h3>Make<S2SV_blank>sure<S2SV_blank>you<S2SV_blank>have<S2SV_blank>\\"writable\\"<S2SV_blank>command<S2SV_blank>in<S2SV_blank>configuration<S2SV_blank>file" : "<h3>Configuration<S2SV_blank>updated</h3>" ) ; } break ; default : printstr ( & pp , ( char * ) conf . stringtable [ WEBBANNERS ] ) ; break ; } if ( * req != 'S' ) printstr ( & pp , tail ) ; CLEANRET : printstr ( & pp , NULL ) ; if ( buf ) myfree ( buf ) ; ( * param -> srv -> logfunc ) ( param , ( unsigned char * ) req ) ; if ( req ) myfree ( req ) ; freeparam ( param ) ; return ( NULL ) ; }
CWE-79 static int oidc_handle_session_management_iframe_rp ( request_rec * r , oidc_cfg * c , oidc_session_t * session , const char * client_id , const char * check_session_iframe ) { oidc_debug ( r , "enter" ) ; const char * java_script = "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><script<S2SV_blank>type=\\"text/javascript\\">\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>var<S2SV_blank>targetOrigin<S2SV_blank><S2SV_blank>=<S2SV_blank>\'%s\';\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>var<S2SV_blank>message<S2SV_blank>=<S2SV_blank>\'%s\'<S2SV_blank>+<S2SV_blank>\'<S2SV_blank>\'<S2SV_blank>+<S2SV_blank>\'%s\';\\n" "\t<S2SV_blank><S2SV_blank><S2SV_blank>var<S2SV_blank>timerID;\\n" "\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>function<S2SV_blank>checkSession()<S2SV_blank>{\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>console.debug(\'checkSession:<S2SV_blank>posting<S2SV_blank>\'<S2SV_blank>+<S2SV_blank>message<S2SV_blank>+<S2SV_blank>\'<S2SV_blank>to<S2SV_blank>\'<S2SV_blank>+<S2SV_blank>targetOrigin);\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>var<S2SV_blank>win<S2SV_blank>=<S2SV_blank>window.parent.document.getElementById(\'%s\').contentWindow;\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>win.postMessage(<S2SV_blank>message,<S2SV_blank>targetOrigin);\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}\\n" "\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>function<S2SV_blank>setTimer()<S2SV_blank>{\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>checkSession();\\n" <S2SV_StartBug> "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>timerID<S2SV_blank>=<S2SV_blank>setInterval(\'checkSession()\',<S2SV_blank>%s);\\n" <S2SV_EndBug> "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}\\n" "\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>function<S2SV_blank>receiveMessage(e)<S2SV_blank>{\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>console.debug(\'receiveMessage:<S2SV_blank>\'<S2SV_blank>+<S2SV_blank>e.data<S2SV_blank>+<S2SV_blank>\'<S2SV_blank>from<S2SV_blank>\'<S2SV_blank>+<S2SV_blank>e.origin);\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>if<S2SV_blank>(e.origin<S2SV_blank>!==<S2SV_blank>targetOrigin<S2SV_blank>)<S2SV_blank>{\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>console.debug(\'receiveMessage:<S2SV_blank>cross-site<S2SV_blank>scripting<S2SV_blank>attack?\');\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>return;\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>if<S2SV_blank>(e.data<S2SV_blank>!=<S2SV_blank>\'unchanged\')<S2SV_blank>{\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>clearInterval(timerID);\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>if<S2SV_blank>(e.data<S2SV_blank>==<S2SV_blank>\'changed\')<S2SV_blank>{\\n" "\t\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>window.location.href<S2SV_blank>=<S2SV_blank>\'%s?session=check\';\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}<S2SV_blank>else<S2SV_blank>{\\n" "\t\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>window.location.href<S2SV_blank>=<S2SV_blank>\'%s?session=logout\';\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}\\n" "\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>window.addEventListener(\'message\',<S2SV_blank>receiveMessage,<S2SV_blank>false);\\n" "\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank></script>\\n" ; char * origin = apr_pstrdup ( r -> pool , check_session_iframe ) ; apr_uri_t uri ; apr_uri_parse ( r -> pool , check_session_iframe , & uri ) ; char * p = strstr ( origin , uri . path ) ; * p = '\\0' ; const char * op_iframe_id = "openidc-op" ; const char * session_state = oidc_session_get_session_state ( r , session ) ; if ( session_state == NULL ) { oidc_warn ( r , "no<S2SV_blank>session_state<S2SV_blank>found<S2SV_blank>in<S2SV_blank>the<S2SV_blank>session;<S2SV_blank>the<S2SV_blank>OP<S2SV_blank>does<S2SV_blank>probably<S2SV_blank>not<S2SV_blank>support<S2SV_blank>session<S2SV_blank>management!?" ) ; return DONE ; } char * s_poll_interval = NULL ; oidc_util_get_request_parameter ( r , "poll" , & s_poll_interval ) ; <S2SV_StartBug> if ( s_poll_interval == NULL ) <S2SV_EndBug> s_poll_interval = "3000" ; const char * redirect_uri = oidc_get_redirect_uri ( r , c ) ; java_script = apr_psprintf ( r -> pool , java_script , origin , client_id , <S2SV_StartBug> session_state , op_iframe_id , s_poll_interval , redirect_uri , <S2SV_EndBug> redirect_uri ) ; return oidc_util_html_send ( r , NULL , java_script , "setTimer" , NULL , DONE ) ; }
